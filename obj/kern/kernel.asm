
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 00 18 00 	lgdtl  0x180018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 00 18 f0       	mov    $0xf0180000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 b8 d7 b5 f0 01 	movl   $0x1,0xf0b5d7b8
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 04 d7 b5 f0 01 	movl   $0x1,0xf0b5d704
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 70 04 6f f2       	mov    $0xf26f0470,%edx
f010006a:	b8 c4 44 73 f0       	mov    $0xf07344c4,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 c4 44 73 f0       	push   $0xf07344c4
f010007e:	e8 87 01 02 00       	call   f012020a <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 00 29 12 f0       	push   $0xf0122900
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 47 29 12 f0       	push   $0xf0122947
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 5b 29 12 f0       	push   $0xf012295b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 6f 29 12 f0       	push   $0xf012296f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 67 73 00 00       	call   f0107441 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 7b 29 12 f0       	push   $0xf012297b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 83 29 12 f0       	push   $0xf0122983
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 ac 7c 00 00       	call   f0107dae <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 4d 78 00 00       	call   f0107954 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 ed 7f 00 00       	call   f01080f9 <initialize_paging>
		sharing_init();
f010010c:	e8 5e 8c 00 00       	call   f0108d6f <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 48 94 00 00       	call   f0109570 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 bb f8 00 00       	call   f010f9eb <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 a4 f9 00 00       	call   f010fae8 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 7f f9 00 00       	call   f010fad0 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 9f f9 00 00       	call   f010fb00 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 f8 05 02 00       	call   f0120761 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 91 29 12 f0       	push   $0xf0122991
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 53 af 00 00       	call   f010b0d1 <env_init>
		ts_init();
f010017e:	e8 37 d1 00 00       	call   f010d2ba <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 7b 29 12 f0       	push   $0xf012297b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 a4 29 12 f0       	push   $0xf01229a4
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 85 6f 00 00       	call   f010712d <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 cd 29 12 f0       	push   $0xf01229cd
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 5d 71 00 00       	call   f010731f <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 e3 29 12 f0       	push   $0xf01229e3
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 40 71 00 00       	call   f010731f <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 00 2a 12 f0       	push   $0xf0122a00
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 23 71 00 00       	call   f010731f <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 1f 2a 12 f0       	push   $0xf0122a1f
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 3c 2a 12 f0       	push   $0xf0122a3c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 c2 4b 00 00       	call   f0104de6 <kclock_init>
		sched_init() ;
f0100224:	e8 b8 67 00 00       	call   f01069e1 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 60 2a 12 f0       	push   $0xf0122a60
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 00 18 f0       	mov    $0xf0180000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 80 2a 12 f0       	push   $0xf0122a80
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 a4 2a 12 f0       	push   $0xf0122aa4
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 7c da f5 f0 00 	movl   $0x0,0xf0f5da7c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 ec 2a 12 f0       	push   $0xf0122aec
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 18 2b 12 f0       	push   $0xf0122b18
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 3d 2b 12 f0       	push   $0xf0122b3d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 44 2b 12 f0       	push   $0xf0122b44
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 8c 2b 12 f0       	push   $0xf0122b8c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 d4 2b 12 f0       	push   $0xf0122bd4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 8c 2b 12 f0       	push   $0xf0122b8c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 44 2b 12 f0       	push   $0xf0122b44
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 19 2c 12 f0       	push   $0xf0122c19
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 e1 b9 00 00       	call   f010bd25 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 e0 44 73 f0       	mov    %eax,0xf07344e0

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 20 2c 12 f0       	push   $0xf0122c20
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 45 2c 12 f0       	push   $0xf0122c45
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 3d b9 00 00       	call   f010bce3 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 47 2c 12 f0       	push   $0xf0122c47
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 e0 44 73 f0       	mov    %eax,0xf07344e0

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 51 2c 12 f0       	push   $0xf0122c51
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 45 2c 12 f0       	push   $0xf0122c45
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 dd 70 00 00       	call   f01074fa <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 15 70 00 00       	call   f0107437 <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 16 71 00 00       	call   f010754c <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 ff 62 00 00       	call   f0106740 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 df b8 00 00       	call   f010bd25 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 84 b8 00 00       	call   f010bce3 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 e0 44 73 f0       	mov    %eax,0xf07344e0

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 51 2c 12 f0       	push   $0xf0122c51
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 45 2c 12 f0       	push   $0xf0122c45
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 6d b8 00 00       	call   f010bd25 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 12 b8 00 00       	call   f010bce3 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 6a 2c 12 f0       	push   $0xf0122c6a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 45 2c 12 f0       	push   $0xf0122c45
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 04 45 73 f0       	mov    0xf0734504,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 88 2c 12 f0       	push   $0xf0122c88
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 04 45 73 f0       	mov    %eax,0xf0734504
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 49 df 00 00       	call   f010e5be <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 08 45 73 f0 b4 	movl   $0x3b4,0xf0734508
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 08 45 73 f0 d4 	movl   $0x3d4,0xf0734508
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 08 45 73 f0       	mov    0xf0734508,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 08 45 73 f0       	mov    0xf0734508,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 08 45 73 f0       	mov    0xf0734508,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 08 45 73 f0       	mov    0xf0734508,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 0c 45 73 f0       	mov    %eax,0xf073450c
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 10 45 73 f0    	mov    %ax,0xf0734510
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 10 45 73 f0    	mov    %ax,0xf0734510
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 0c 45 73 f0    	mov    0xf073450c,%edx
f010087a:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 10 45 73 f0    	mov    %ax,0xf0734510
		text_length = 0;
f01008a6:	c7 05 00 45 73 f0 00 	movl   $0x0,0xf0734500
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d 10 45 73 f0 	mov    0xf0734510,%cx
f01008b7:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 10 45 73 f0    	mov    %ax,0xf0734510
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 10 45 73 f0    	mov    %ax,0xf0734510
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 10 45 73 f0    	mov    %ax,0xf0734510
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d 0c 45 73 f0    	mov    0xf073450c,%ecx
f0100972:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 10 45 73 f0 	mov    %dx,0xf0734510
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 00 45 73 f0    	mov    0xf0734500,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 00 45 73 f0       	mov    0xf0734500,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 00 45 73 f0       	mov    %eax,0xf0734500
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 0c 45 73 f0       	mov    0xf073450c,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 0c 45 73 f0       	mov    0xf073450c,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 4f f8 01 00       	call   f012023a <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 0c 45 73 f0    	mov    0xf073450c,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 10 45 73 f0    	mov    %ax,0xf0734510
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 08 45 73 f0       	mov    0xf0734508,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 08 45 73 f0    	mov    0xf0734508,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 08 45 73 f0       	mov    0xf0734508,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 08 45 73 f0    	mov    0xf0734508,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 28 47 73 f0       	mov    %eax,0xf0734728
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 28 47 73 f0       	mov    %eax,0xf0734728
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 28 47 73 f0       	mov    %eax,0xf0734728
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 00 18 f0    	mov    -0xfe7ffe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 28 47 73 f0       	mov    %eax,0xf0734728
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 01 18 f0    	mov    -0xfe7fee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 28 47 73 f0       	mov    %eax,0xf0734728

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 05 18 f0 	mov    -0xfe7fae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 00 45 73 f0       	mov    0xf0734500,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 00 45 73 f0    	mov    0xf0734500,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 00 45 73 f0       	mov    0xf0734500,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 00 45 73 f0       	mov    %eax,0xf0734500
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 10 45 73 f0    	mov    0xf0734510,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 0c 45 73 f0    	mov    0xf073450c,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 0c 45 73 f0       	mov    0xf073450c,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 00 45 73 f0       	mov    0xf0734500,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 28 47 73 f0       	mov    0xf0734728,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 9b 2c 12 f0       	push   $0xf0122c9b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 a9 d8 00 00       	call   f010e5be <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 24 47 73 f0       	mov    0xf0734724,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 24 47 73 f0    	mov    %edx,0xf0734724
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 20 45 73 f0    	mov    %dl,-0xf8cbae0(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 24 47 73 f0       	mov    0xf0734724,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 24 47 73 f0 00 	movl   $0x0,0xf0734724
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 20 47 73 f0    	mov    0xf0734720,%edx
f0100d7f:	a1 24 47 73 f0       	mov    0xf0734724,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 20 47 73 f0       	mov    0xf0734720,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 20 47 73 f0    	mov    %edx,0xf0734720
f0100d96:	8a 80 20 45 73 f0    	mov    -0xf8cbae0(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 20 47 73 f0       	mov    0xf0734720,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 20 47 73 f0 00 	movl   $0x0,0xf0734720
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 20 47 73 f0    	mov    0xf0734720,%edx
f0100dd0:	a1 24 47 73 f0       	mov    0xf0734724,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 20 47 73 f0       	mov    0xf0734720,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 20 47 73 f0    	mov    %edx,0xf0734720
f0100de7:	8a 80 20 45 73 f0    	mov    -0xf8cbae0(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 20 47 73 f0       	mov    0xf0734720,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 20 47 73 f0 00 	movl   $0x0,0xf0734720
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 04 45 73 f0       	mov    0xf0734504,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 a7 2c 12 f0       	push   $0xf0122ca7
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ed 3f 00 00       	call   f0104ea8 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 64 ae 00 00       	call   f010bd25 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 c4 2c 12 f0       	push   $0xf0122cc4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 eb 2c 12 f0       	push   $0xf0122ceb
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 a6 3f 00 00       	call   f0104ea8 <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 1d ae 00 00       	call   f010bd25 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 00 2d 12 f0       	push   $0xf0122d00
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 eb 2c 12 f0       	push   $0xf0122ceb
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 d7 e9 01 00       	call   f011f95a <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 64 65 00 00       	call   f01074fa <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 96 65 00 00       	call   f010754c <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 40 6b f7 f0       	add    $0xf0f76b40,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 24 f0 01 00       	call   f012001c <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 60 bb f7 f0       	push   $0xf0f7bb60
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 27 f2 01 00       	call   f012023a <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 40 6b f7 f0       	add    $0xf0f76b40,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 40 6b f7 f0       	add    $0xf0f76b40,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 62 ef 01 00       	call   f012001c <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 60 bb f7 f0       	push   $0xf0f7bb60
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 65 f1 01 00       	call   f012023a <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 40 db f5 f0       	add    $0xf0f5db40,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 a2 f0 01 00       	call   f012020a <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 2c 2d 12 f0       	push   $0xf0122d2c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 2f 2d 12 f0       	push   $0xf0122d2f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 40 db f5 f0       	push   $0xf0f5db40
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 47 ed 01 00       	call   f012001c <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 5c ed 01 00       	call   f012006b <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 ff ec 01 00       	call   f012001c <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 3f 2d 12 f0       	push   $0xf0122d3f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 da f2 01 00       	call   f0120631 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 44 2d 12 f0       	push   $0xf0122d44
f010137e:	50                   	push   %eax
f010137f:	e8 a4 ed 01 00       	call   f0120128 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 48 2d 12 f0       	push   $0xf0122d48
f0101399:	50                   	push   %eax
f010139a:	e8 89 ed 01 00       	call   f0120128 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 4d 2d 12 f0       	push   $0xf0122d4d
f01013b4:	50                   	push   %eax
f01013b5:	e8 6e ed 01 00       	call   f0120128 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 4d 2d 12 f0       	push   $0xf0122d4d
f01013d5:	50                   	push   %eax
f01013d6:	e8 4d ed 01 00       	call   f0120128 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 f5 eb 01 00       	call   f012001c <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 f7 eb 01 00       	call   f012006b <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 d6 eb 01 00       	call   f012006b <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 53 eb 01 00       	call   f012001c <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 6e ec 01 00       	call   f0120160 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 a3 ea 01 00       	call   f012001c <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 40 db f5 f0       	add    $0xf0f5db40,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 6e ec 01 00       	call   f012020a <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 40 db f5 f0    	add    $0xf0f5db40,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 d9 ea 01 00       	call   f0120099 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 19 ea 01 00       	call   f012001c <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d 48 0d 18 f0    	mov    0xf0180d48,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 31 eb 01 00       	call   f0120160 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 7c e9 01 00       	call   f012001c <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 1c e9 01 00       	call   f012001c <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 40 db f5 f0       	add    $0xf0f5db40,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 e7 ea 01 00       	call   f012020a <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 40 db f5 f0    	add    $0xf0f5db40,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 52 e9 01 00       	call   f0120099 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 94 e8 01 00       	call   f012001c <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 af e9 01 00       	call   f0120160 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 fa e7 01 00       	call   f012001c <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 a0 e7 01 00       	call   f012001c <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 40 db f5 f0       	add    $0xf0f5db40,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 6b e9 01 00       	call   f012020a <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 40 db f5 f0    	add    $0xf0f5db40,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 d6 e7 01 00       	call   f0120099 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 14 0e 18 f0       	mov    0xf0180e14,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 40 db f5 f0       	add    $0xf0f5db40,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 40 db f5 f0       	push   $0xf0f5db40
f0101929:	e8 ee e6 01 00       	call   f012001c <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 95 e6 01 00       	call   f012001c <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 82 e6 01 00       	call   f012001c <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 40 db f5 f0    	lea    -0xf0a24c0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 40 db f5 f0       	add    $0xf0f5db40,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 27 e6 01 00       	call   f012001c <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 40 6b f7 f0    	lea    -0xf0894c0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 40 6b f7 f0       	add    $0xf0f76b40,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 1c e6 01 00       	call   f012023a <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 40 b7 f7 f0       	push   $0xf0f7b740
f0101c3a:	e8 fb e5 01 00       	call   f012023a <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 40 6b f7 f0       	add    $0xf0f76b40,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 cb e4 01 00       	call   f0120128 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 05 18 f0       	mov    %eax,0xf0180530
f0101c6f:	a1 30 05 18 f0       	mov    0xf0180530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 40 6b f7 f0       	add    $0xf0f76b40,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 ad e5 01 00       	call   f012023a <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 7c da f5 f0       	mov    0xf0f5da7c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 57 2d 12 f0       	mov    $0xf0122d57,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 57 31 12 f0       	mov    $0xf0123157,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 57 35 12 f0       	mov    $0xf0123557,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 7c da f5 f0 00 	movl   $0x0,0xf0f5da7c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 f8 d9 f5 f0 00 	movl   $0x0,0xf0f5d9f8
f0101d59:	00 00 00 
f0101d5c:	c7 05 fc d9 f5 f0 00 	movl   $0x0,0xf0f5d9fc
f0101d63:	00 00 00 
f0101d66:	c7 05 04 da f5 f0 00 	movl   $0x0,0xf0f5da04
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 84 e4 01 00       	call   f012020a <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 51 2d 12 f0       	push   $0xf0122d51
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 d3 a1 00 00       	call   f010bfb2 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 53 56 00 00       	call   f0107437 <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 20 db f5 f0       	mov    %eax,0xf0f5db20
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 40 bb f7 f0       	mov    %eax,0xf0f7bb40
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 20 db f5 f0       	mov    0xf0f5db20,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 20 db f5 f0    	mov    %edx,0xf0f5db20
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 40 bb f7 f0       	mov    0xf0f7bb40,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 40 bb f7 f0       	mov    %eax,0xf0f7bb40
f0101e98:	a1 40 bb f7 f0       	mov    0xf0f7bb40,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 20 db f5 f0       	mov    %eax,0xf0f5db20
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 40 bb f7 f0       	mov    %eax,0xf0f7bb40
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 20 db f5 f0       	mov    0xf0f5db20,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 20 db f5 f0    	mov    %edx,0xf0f5db20
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 40 bb f7 f0       	mov    0xf0f7bb40,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 40 bb f7 f0       	mov    %eax,0xf0f7bb40
f0101ed4:	a1 40 bb f7 f0       	mov    0xf0f7bb40,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 3f 2d 12 f0       	push   $0xf0122d3f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 1b e7 01 00       	call   f0120631 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 57 39 12 f0       	push   $0xf0123957
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 04 da f5 f0       	mov    0xf0f5da04,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 70 39 12 f0       	push   $0xf0123970
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 c1 39 12 f0       	push   $0xf01239c1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 dc 39 12 f0       	push   $0xf01239dc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 04 da f5 f0       	mov    0xf0f5da04,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 0c 3a 12 f0       	push   $0xf0123a0c
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 c1 39 12 f0       	push   $0xf01239c1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 36 3a 12 f0       	push   $0xf0123a36
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 00 da f5 f0       	mov    %eax,0xf0f5da00
f010203b:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 40 3a 12 f0       	push   $0xf0123a40
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 a3 3a 12 f0       	push   $0xf0123aa3
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 ac 3a 12 f0       	push   $0xf0123aac
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 00 da f5 f0       	mov    %eax,0xf0f5da00
f010218b:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 05 18 f0       	add    $0xf0180548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 b4 3a 12 f0       	push   $0xf0123ab4
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 c1 39 12 f0       	push   $0xf01239c1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 fc d9 f5 f0       	mov    %eax,0xf0f5d9fc
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 f8 d9 f5 f0       	mov    %eax,0xf0f5d9f8
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 04 da f5 f0       	mov    0xf0f5da04,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 04 da f5 f0       	mov    %eax,0xf0f5da04

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 00 da f5 f0       	mov    %eax,0xf0f5da00
f0102292:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 4a de 01 00       	call   f0120128 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c 05 18 f0       	add    $0xf018054c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 f8 d9 f5 f0    	mov    0xf0f5d9f8,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 05 18 f0       	add    $0xf0180550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 f8 d9 f5 f0    	mov    0xf0f5d9f8,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010238d:	a3 fc d9 f5 f0       	mov    %eax,0xf0f5d9fc
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01023a3:	a3 f8 d9 f5 f0       	mov    %eax,0xf0f5d9f8
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 05 18 f0       	add    $0xf0180554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 04 da f5 f0       	mov    0xf0f5da04,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 04 da f5 f0       	mov    %eax,0xf0f5da04
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 f8 d9 f5 f0    	mov    0xf0f5d9f8,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 05 18 f0       	add    $0xf0180550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 f8 d9 f5 f0    	mov    0xf0f5d9f8,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 05 18 f0       	add    $0xf0180540,%eax
f010248c:	a3 fc d9 f5 f0       	mov    %eax,0xf0f5d9fc
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01024a2:	a3 f8 d9 f5 f0       	mov    %eax,0xf0f5d9f8
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 05 18 f0       	add    $0xf0180554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 04 da f5 f0       	mov    0xf0f5da04,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 04 da f5 f0       	mov    %eax,0xf0f5da04
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 b8 d7 b5 f0 00 	movl   $0x0,0xf0b5d7b8
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 b8 d7 b5 f0 01 	movl   $0x1,0xf0b5d7b8
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 b8 d7 b5 f0 02 	movl   $0x2,0xf0b5d7b8
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 b8 d7 b5 f0 03 	movl   $0x3,0xf0b5d7b8
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 b8 d7 b5 f0 04 	movl   $0x4,0xf0b5d7b8
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 04 d7 b5 f0 01 	movl   $0x1,0xf0b5d704
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 04 d7 b5 f0 02 	movl   $0x2,0xf0b5d704
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 04 d7 b5 f0 03 	movl   $0x3,0xf0b5d704
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 04 d7 b5 f0 04 	movl   $0x4,0xf0b5d704
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 04 d7 b5 f0       	mov    0xf0b5d704,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 04 d7 b5 f0       	mov    0xf0b5d704,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 04 d7 b5 f0       	mov    0xf0b5d704,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 04 d7 b5 f0       	mov    0xf0b5d704,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 d4 3a 12 f0       	push   $0xf0123ad4
f0102662:	6a 56                	push   $0x56
f0102664:	68 fc 3a 12 f0       	push   $0xf0123afc
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 20 d7 b5 f0    	mov    0xf0b5d720,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 05 18 f0       	add    $0xf0180544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 05 18 f0       	add    $0xf0180540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 33 44 12 f0       	push   $0xf0124433
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 3c 44 12 f0       	push   $0xf012443c
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d 48 0d 18 f0    	mov    0xf0180d48,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d 48 0d 18 f0    	mov    0xf0180d48,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 51 44 12 f0       	push   $0xf0124451
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 6d 44 12 f0       	push   $0xf012446d
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 88 44 12 f0       	push   $0xf0124488
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 e9 28 12 00       	mov    $0x1228e9,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 e9 28 12 f0       	push   $0xf01228e9
f010278e:	68 c4 44 12 f0       	push   $0xf01244c4
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 c4 44 73 00       	mov    $0x7344c4,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 c4 44 73 f0       	push   $0xf07344c4
f01027a9:	68 00 45 12 f0       	push   $0xf0124500
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 70 04 6f 02       	mov    $0x26f0470,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 70 04 6f f2       	push   $0xf26f0470
f01027c4:	68 48 45 12 f0       	push   $0xf0124548
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 70 04 6f f2       	mov    $0xf26f0470,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 84 45 12 f0       	push   $0xf0124584
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 52 db 01 00       	call   f012037c <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 11 db 01 00       	call   f012037c <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 ec 94 00 00       	call   f010bd75 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 db da 01 00       	call   f012037c <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 b0 45 12 f0       	push   $0xf01245b0
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 55 da 01 00       	call   f012037c <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 d2 d6 01 00       	call   f012001c <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 d7 d9 01 00       	call   f012037c <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 da 45 12 f0       	push   $0xf01245da
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 8b d9 01 00       	call   f012037c <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 66 93 00 00       	call   f010bd75 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 55 d9 01 00       	call   f012037c <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 da 45 12 f0       	push   $0xf01245da
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 f4 45 12 f0       	push   $0xf01245f4
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 c4 d8 01 00       	call   f012037c <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 1e 46 12 f0       	push   $0xf012461e
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 21 46 12 f0       	push   $0xf0124621
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 67 d8 01 00       	call   f012037c <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 42 92 00 00       	call   f010bd75 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 31 d8 01 00       	call   f012037c <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 16 d8 01 00       	call   f012037c <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 23 46 12 f0       	push   $0xf0124623
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 7a d7 01 00       	call   f012037c <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 55 91 00 00       	call   f010bd75 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 33 d7 01 00       	call   f012037c <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 8d 6f 00 00       	call   f0109c12 <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 fe 6d 00 00       	call   f0109a8f <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 76 59 00 00       	call   f0108631 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 34 46 12 f0       	push   $0xf0124634
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 3e d6 01 00       	call   f012037c <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 19 90 00 00       	call   f010bd75 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 f7 d5 01 00       	call   f012037c <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 46 57 00 00       	call   f01084dd <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 5e 46 12 f0       	push   $0xf012465e
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 d2 5b 00 00       	call   f01089aa <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 78 46 12 f0       	push   $0xf0124678
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 43 5b 00 00       	call   f01089aa <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 07 5e 00 00       	call   f0108c8c <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 bc 46 12 f0       	push   $0xf01246bc
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 d0 d8 b5 f0       	mov    0xf0b5d8d0,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 14 47 12 f0       	push   $0xf0124714
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0102ef6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102efd:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f00:	83 f8 04             	cmp    $0x4,%eax
f0102f03:	0f 84 c3 00 00 00    	je     f0102fcc <CreateEnv+0xf8>
f0102f09:	83 f8 05             	cmp    $0x5,%eax
f0102f0c:	74 0e                	je     f0102f1c <CreateEnv+0x48>
f0102f0e:	83 f8 03             	cmp    $0x3,%eax
f0102f11:	0f 84 4a 01 00 00    	je     f0103061 <CreateEnv+0x18d>
f0102f17:	e9 8d 01 00 00       	jmp    f01030a9 <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f1c:	83 ec 0c             	sub    $0xc,%esp
f0102f1f:	6a 02                	push   $0x2
f0102f21:	e8 0d cb 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f0102f26:	83 c4 10             	add    $0x10,%esp
f0102f29:	85 c0                	test   %eax,%eax
f0102f2b:	75 1a                	jne    f0102f47 <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f2d:	83 ec 0c             	sub    $0xc,%esp
f0102f30:	68 50 47 12 f0       	push   $0xf0124750
f0102f35:	e8 51 e0 ff ff       	call   f0100f8b <cprintf>
f0102f3a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f3d:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f42:	e9 7b 02 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0102f47:	e8 6f 3a 00 00       	call   f01069bb <isSchedMethodBSD>
f0102f4c:	85 c0                	test   %eax,%eax
f0102f4e:	74 1d                	je     f0102f6d <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f50:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f53:	83 c0 10             	add    $0x10,%eax
f0102f56:	8b 00                	mov    (%eax),%eax
f0102f58:	83 ec 04             	sub    $0x4,%esp
f0102f5b:	6a 0a                	push   $0xa
f0102f5d:	6a 00                	push   $0x0
f0102f5f:	50                   	push   %eax
f0102f60:	e8 17 d4 01 00       	call   f012037c <strtol>
f0102f65:	83 c4 10             	add    $0x10,%esp
f0102f68:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102f6b:	eb 24                	jmp    f0102f91 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0102f6d:	e8 5c 3a 00 00       	call   f01069ce <isSchedMethodPRIRR>
f0102f72:	85 c0                	test   %eax,%eax
f0102f74:	74 1b                	je     f0102f91 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 10             	add    $0x10,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 f1 d3 01 00       	call   f012037c <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f94:	83 c0 0c             	add    $0xc,%eax
f0102f97:	8b 00                	mov    (%eax),%eax
f0102f99:	83 ec 04             	sub    $0x4,%esp
f0102f9c:	6a 0a                	push   $0xa
f0102f9e:	6a 00                	push   $0x0
f0102fa0:	50                   	push   %eax
f0102fa1:	e8 d6 d3 01 00       	call   f012037c <strtol>
f0102fa6:	83 c4 10             	add    $0x10,%esp
f0102fa9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fac:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faf:	83 c0 08             	add    $0x8,%eax
f0102fb2:	8b 00                	mov    (%eax),%eax
f0102fb4:	83 ec 04             	sub    $0x4,%esp
f0102fb7:	6a 0a                	push   $0xa
f0102fb9:	6a 00                	push   $0x0
f0102fbb:	50                   	push   %eax
f0102fbc:	e8 bb d3 01 00       	call   f012037c <strtol>
f0102fc1:	83 c4 10             	add    $0x10,%esp
f0102fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102fc7:	e9 f7 00 00 00       	jmp    f01030c3 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102fcc:	83 ec 0c             	sub    $0xc,%esp
f0102fcf:	6a 02                	push   $0x2
f0102fd1:	e8 5d ca 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f0102fd6:	83 c4 10             	add    $0x10,%esp
f0102fd9:	85 c0                	test   %eax,%eax
f0102fdb:	75 4c                	jne    f0103029 <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0102fdd:	e8 d9 39 00 00       	call   f01069bb <isSchedMethodBSD>
f0102fe2:	85 c0                	test   %eax,%eax
f0102fe4:	74 1d                	je     f0103003 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe9:	83 c0 0c             	add    $0xc,%eax
f0102fec:	8b 00                	mov    (%eax),%eax
f0102fee:	83 ec 04             	sub    $0x4,%esp
f0102ff1:	6a 0a                	push   $0xa
f0102ff3:	6a 00                	push   $0x0
f0102ff5:	50                   	push   %eax
f0102ff6:	e8 81 d3 01 00       	call   f012037c <strtol>
f0102ffb:	83 c4 10             	add    $0x10,%esp
f0102ffe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103001:	eb 41                	jmp    f0103044 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103003:	e8 c6 39 00 00       	call   f01069ce <isSchedMethodPRIRR>
f0103008:	85 c0                	test   %eax,%eax
f010300a:	74 38                	je     f0103044 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f010300c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010300f:	83 c0 0c             	add    $0xc,%eax
f0103012:	8b 00                	mov    (%eax),%eax
f0103014:	83 ec 04             	sub    $0x4,%esp
f0103017:	6a 0a                	push   $0xa
f0103019:	6a 00                	push   $0x0
f010301b:	50                   	push   %eax
f010301c:	e8 5b d3 01 00       	call   f012037c <strtol>
f0103021:	83 c4 10             	add    $0x10,%esp
f0103024:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103027:	eb 1b                	jmp    f0103044 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103029:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302c:	83 c0 0c             	add    $0xc,%eax
f010302f:	8b 00                	mov    (%eax),%eax
f0103031:	83 ec 04             	sub    $0x4,%esp
f0103034:	6a 0a                	push   $0xa
f0103036:	6a 00                	push   $0x0
f0103038:	50                   	push   %eax
f0103039:	e8 3e d3 01 00       	call   f012037c <strtol>
f010303e:	83 c4 10             	add    $0x10,%esp
f0103041:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103044:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103047:	83 c0 08             	add    $0x8,%eax
f010304a:	8b 00                	mov    (%eax),%eax
f010304c:	83 ec 04             	sub    $0x4,%esp
f010304f:	6a 0a                	push   $0xa
f0103051:	6a 00                	push   $0x0
f0103053:	50                   	push   %eax
f0103054:	e8 23 d3 01 00       	call   f012037c <strtol>
f0103059:	83 c4 10             	add    $0x10,%esp
f010305c:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f010305f:	eb 62                	jmp    f01030c3 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103061:	83 ec 0c             	sub    $0xc,%esp
f0103064:	6a 02                	push   $0x2
f0103066:	e8 c8 c9 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010306b:	83 c4 10             	add    $0x10,%esp
f010306e:	85 c0                	test   %eax,%eax
f0103070:	74 1a                	je     f010308c <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103072:	83 ec 0c             	sub    $0xc,%esp
f0103075:	68 fc 47 12 f0       	push   $0xf01247fc
f010307a:	e8 0c df ff ff       	call   f0100f8b <cprintf>
f010307f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103082:	b8 00 00 00 00       	mov    $0x0,%eax
f0103087:	e9 36 01 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f010308c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010308f:	83 c0 08             	add    $0x8,%eax
f0103092:	8b 00                	mov    (%eax),%eax
f0103094:	83 ec 04             	sub    $0x4,%esp
f0103097:	6a 0a                	push   $0xa
f0103099:	6a 00                	push   $0x0
f010309b:	50                   	push   %eax
f010309c:	e8 db d2 01 00       	call   f012037c <strtol>
f01030a1:	83 c4 10             	add    $0x10,%esp
f01030a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f01030a7:	eb 1a                	jmp    f01030c3 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f01030a9:	83 ec 0c             	sub    $0xc,%esp
f01030ac:	68 8c 48 12 f0       	push   $0xf012488c
f01030b1:	e8 d5 de ff ff       	call   f0100f8b <cprintf>
f01030b6:	83 c4 10             	add    $0x10,%esp
			return NULL;
f01030b9:	b8 00 00 00 00       	mov    $0x0,%eax
f01030be:	e9 ff 00 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01030c3:	83 ec 0c             	sub    $0xc,%esp
f01030c6:	6a 02                	push   $0x2
f01030c8:	e8 66 c9 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f01030cd:	83 c4 10             	add    $0x10,%esp
f01030d0:	85 c0                	test   %eax,%eax
f01030d2:	74 23                	je     f01030f7 <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f01030d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030d7:	48                   	dec    %eax
f01030d8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01030db:	73 1a                	jae    f01030f7 <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f01030dd:	83 ec 0c             	sub    $0xc,%esp
f01030e0:	68 24 49 12 f0       	push   $0xf0124924
f01030e5:	e8 a1 de ff ff       	call   f0100f8b <cprintf>
f01030ea:	83 c4 10             	add    $0x10,%esp
				return NULL;
f01030ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01030f2:	e9 cb 00 00 00       	jmp    f01031c2 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030f7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01030fb:	76 19                	jbe    f0103116 <CreateEnv+0x242>
f01030fd:	68 7c 49 12 f0       	push   $0xf012497c
f0103102:	68 c1 49 12 f0       	push   $0xf01249c1
f0103107:	68 af 01 00 00       	push   $0x1af
f010310c:	68 d6 49 12 f0       	push   $0xf01249d6
f0103111:	e8 23 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103116:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f010311a:	76 19                	jbe    f0103135 <CreateEnv+0x261>
f010311c:	68 7c 49 12 f0       	push   $0xf012497c
f0103121:	68 c1 49 12 f0       	push   $0xf01249c1
f0103126:	68 cd 01 00 00       	push   $0x1cd
f010312b:	68 d6 49 12 f0       	push   $0xf01249d6
f0103130:	e8 04 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103135:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103138:	83 c0 04             	add    $0x4,%eax
f010313b:	8b 00                	mov    (%eax),%eax
f010313d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103140:	ff 75 f0             	pushl  -0x10(%ebp)
f0103143:	ff 75 f4             	pushl  -0xc(%ebp)
f0103146:	50                   	push   %eax
f0103147:	e8 5b 81 00 00       	call   f010b2a7 <env_create>
f010314c:	83 c4 10             	add    $0x10,%esp
f010314f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103152:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103156:	74 49                	je     f01031a1 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103158:	83 ec 08             	sub    $0x8,%esp
f010315b:	ff 75 ec             	pushl  -0x14(%ebp)
f010315e:	68 ea 49 12 f0       	push   $0xf01249ea
f0103163:	e8 23 de ff ff       	call   f0100f8b <cprintf>
f0103168:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f010316b:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010316f:	7c 06                	jl     f0103177 <CreateEnv+0x2a3>
f0103171:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103175:	7e 19                	jle    f0103190 <CreateEnv+0x2bc>
f0103177:	68 fc 49 12 f0       	push   $0xf01249fc
f010317c:	68 c1 49 12 f0       	push   $0xf01249c1
f0103181:	68 d2 01 00 00       	push   $0x1d2
f0103186:	68 d6 49 12 f0       	push   $0xf01249d6
f010318b:	e8 a9 d1 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103190:	83 ec 08             	sub    $0x8,%esp
f0103193:	ff 75 ec             	pushl  -0x14(%ebp)
f0103196:	ff 75 e0             	pushl  -0x20(%ebp)
f0103199:	e8 53 37 00 00       	call   f01068f1 <env_set_nice>
f010319e:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f01031a1:	e8 28 38 00 00       	call   f01069ce <isSchedMethodPRIRR>
f01031a6:	85 c0                	test   %eax,%eax
f01031a8:	74 15                	je     f01031bf <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f01031aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01031ad:	8b 40 10             	mov    0x10(%eax),%eax
f01031b0:	83 ec 08             	sub    $0x8,%esp
f01031b3:	ff 75 e8             	pushl  -0x18(%ebp)
f01031b6:	50                   	push   %eax
f01031b7:	e8 8c 37 00 00       	call   f0106948 <env_set_priority>
f01031bc:	83 c4 10             	add    $0x10,%esp

	return env;
f01031bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01031c2:	c9                   	leave  
f01031c3:	c3                   	ret    

f01031c4 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f01031c4:	55                   	push   %ebp
f01031c5:	89 e5                	mov    %esp,%ebp
f01031c7:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ca:	83 ec 08             	sub    $0x8,%esp
f01031cd:	ff 75 0c             	pushl  0xc(%ebp)
f01031d0:	ff 75 08             	pushl  0x8(%ebp)
f01031d3:	e8 fc fc ff ff       	call   f0102ed4 <CreateEnv>
f01031d8:	83 c4 10             	add    $0x10,%esp
f01031db:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f01031de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01031e2:	75 07                	jne    f01031eb <command_run_program+0x27>
f01031e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01031e9:	eb 46                	jmp    f0103231 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f01031eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031ee:	8b 40 10             	mov    0x10(%eax),%eax
f01031f1:	83 ec 08             	sub    $0x8,%esp
f01031f4:	50                   	push   %eax
f01031f5:	68 2c 4a 12 f0       	push   $0xf0124a2c
f01031fa:	e8 8c dd ff ff       	call   f0100f8b <cprintf>
f01031ff:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103202:	83 ec 0c             	sub    $0xc,%esp
f0103205:	ff 75 f4             	pushl  -0xc(%ebp)
f0103208:	e8 7a 27 00 00       	call   f0105987 <sched_new_env>
f010320d:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103210:	c7 05 d0 d8 b5 f0 00 	movl   $0x0,0xf0b5d8d0
f0103217:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f010321a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321d:	8b 40 10             	mov    0x10(%eax),%eax
f0103220:	83 ec 0c             	sub    $0xc,%esp
f0103223:	50                   	push   %eax
f0103224:	e8 b4 27 00 00       	call   f01059dd <sched_run_env>
f0103229:	83 c4 10             	add    $0x10,%esp

	return 0;
f010322c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103231:	c9                   	leave  
f0103232:	c3                   	ret    

f0103233 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103233:	55                   	push   %ebp
f0103234:	89 e5                	mov    %esp,%ebp
f0103236:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103239:	8b 45 0c             	mov    0xc(%ebp),%eax
f010323c:	83 c0 04             	add    $0x4,%eax
f010323f:	8b 00                	mov    (%eax),%eax
f0103241:	83 ec 04             	sub    $0x4,%esp
f0103244:	6a 0a                	push   $0xa
f0103246:	6a 00                	push   $0x0
f0103248:	50                   	push   %eax
f0103249:	e8 2e d1 01 00       	call   f012037c <strtol>
f010324e:	83 c4 10             	add    $0x10,%esp
f0103251:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103257:	83 ec 0c             	sub    $0xc,%esp
f010325a:	50                   	push   %eax
f010325b:	e8 c3 2a 00 00       	call   f0105d23 <sched_kill_env>
f0103260:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103263:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103268:	c9                   	leave  
f0103269:	c3                   	ret    

f010326a <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f010326a:	55                   	push   %ebp
f010326b:	89 e5                	mov    %esp,%ebp
f010326d:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103270:	83 ec 08             	sub    $0x8,%esp
f0103273:	ff 75 0c             	pushl  0xc(%ebp)
f0103276:	ff 75 08             	pushl  0x8(%ebp)
f0103279:	e8 56 fc ff ff       	call   f0102ed4 <CreateEnv>
f010327e:	83 c4 10             	add    $0x10,%esp
f0103281:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103284:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103288:	75 07                	jne    f0103291 <commnad_load_env+0x27>
		return 0 ;
f010328a:	b8 00 00 00 00       	mov    $0x0,%eax
f010328f:	eb 2a                	jmp    f01032bb <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103291:	83 ec 0c             	sub    $0xc,%esp
f0103294:	ff 75 f4             	pushl  -0xc(%ebp)
f0103297:	e8 eb 26 00 00       	call   f0105987 <sched_new_env>
f010329c:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010329f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032a2:	8b 40 10             	mov    0x10(%eax),%eax
f01032a5:	83 ec 08             	sub    $0x8,%esp
f01032a8:	50                   	push   %eax
f01032a9:	68 2c 4a 12 f0       	push   $0xf0124a2c
f01032ae:	e8 d8 dc ff ff       	call   f0100f8b <cprintf>
f01032b3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01032b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032bb:	c9                   	leave  
f01032bc:	c3                   	ret    

f01032bd <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f01032bd:	55                   	push   %ebp
f01032be:	89 e5                	mov    %esp,%ebp
f01032c0:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f01032c3:	c7 05 d0 d8 b5 f0 00 	movl   $0x0,0xf0b5d8d0
f01032ca:	00 00 00 
	sched_run_all();
f01032cd:	e8 0e 30 00 00       	call   f01062e0 <sched_run_all>

	return 0 ;
f01032d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032d7:	c9                   	leave  
f01032d8:	c3                   	ret    

f01032d9 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f01032d9:	55                   	push   %ebp
f01032da:	89 e5                	mov    %esp,%ebp
f01032dc:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f01032df:	e8 db 2d 00 00       	call   f01060bf <sched_print_all>

	return 0 ;
f01032e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032e9:	c9                   	leave  
f01032ea:	c3                   	ret    

f01032eb <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f01032eb:	55                   	push   %ebp
f01032ec:	89 e5                	mov    %esp,%ebp
f01032ee:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01032f1:	e8 7f 30 00 00       	call   f0106375 <sched_kill_all>

	return 0 ;
f01032f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032fb:	c9                   	leave  
f01032fc:	c3                   	ret    

f01032fd <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f01032fd:	55                   	push   %ebp
f01032fe:	89 e5                	mov    %esp,%ebp
f0103300:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103303:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103307:	7f 1a                	jg     f0103323 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103309:	83 ec 0c             	sub    $0xc,%esp
f010330c:	68 44 4a 12 f0       	push   $0xf0124a44
f0103311:	e8 75 dc ff ff       	call   f0100f8b <cprintf>
f0103316:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103319:	b8 00 00 00 00       	mov    $0x0,%eax
f010331e:	e9 83 00 00 00       	jmp    f01033a6 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103323:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103326:	83 c0 04             	add    $0x4,%eax
f0103329:	8b 00                	mov    (%eax),%eax
f010332b:	83 ec 04             	sub    $0x4,%esp
f010332e:	6a 0a                	push   $0xa
f0103330:	6a 00                	push   $0x0
f0103332:	50                   	push   %eax
f0103333:	e8 44 d0 01 00       	call   f012037c <strtol>
f0103338:	83 c4 10             	add    $0x10,%esp
f010333b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f010333e:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103342:	75 20                	jne    f0103364 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103344:	83 ec 0c             	sub    $0xc,%esp
f0103347:	ff 75 f4             	pushl  -0xc(%ebp)
f010334a:	e8 59 c6 00 00       	call   f010f9a8 <setPageReplacmentAlgorithmLRU>
f010334f:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103352:	83 ec 0c             	sub    $0xc,%esp
f0103355:	68 a4 4a 12 f0       	push   $0xf0124aa4
f010335a:	e8 2c dc ff ff       	call   f0100f8b <cprintf>
f010335f:	83 c4 10             	add    $0x10,%esp
f0103362:	eb 3d                	jmp    f01033a1 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103364:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103368:	75 20                	jne    f010338a <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f010336a:	83 ec 0c             	sub    $0xc,%esp
f010336d:	ff 75 f4             	pushl  -0xc(%ebp)
f0103370:	e8 33 c6 00 00       	call   f010f9a8 <setPageReplacmentAlgorithmLRU>
f0103375:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103378:	83 ec 0c             	sub    $0xc,%esp
f010337b:	68 e8 4a 12 f0       	push   $0xf0124ae8
f0103380:	e8 06 dc ff ff       	call   f0100f8b <cprintf>
f0103385:	83 c4 10             	add    $0x10,%esp
f0103388:	eb 17                	jmp    f01033a1 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f010338a:	83 ec 0c             	sub    $0xc,%esp
f010338d:	68 28 4b 12 f0       	push   $0xf0124b28
f0103392:	e8 f4 db ff ff       	call   f0100f8b <cprintf>
f0103397:	83 c4 10             	add    $0x10,%esp
		return 0;
f010339a:	b8 00 00 00 00       	mov    $0x0,%eax
f010339f:	eb 05                	jmp    f01033a6 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f01033a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a6:	c9                   	leave  
f01033a7:	c3                   	ret    

f01033a8 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f01033a8:	55                   	push   %ebp
f01033a9:	89 e5                	mov    %esp,%ebp
f01033ab:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f01033ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033b1:	83 c0 04             	add    $0x4,%eax
f01033b4:	8b 00                	mov    (%eax),%eax
f01033b6:	83 ec 04             	sub    $0x4,%esp
f01033b9:	6a 0a                	push   $0xa
f01033bb:	6a 00                	push   $0x0
f01033bd:	50                   	push   %eax
f01033be:	e8 b9 cf 01 00       	call   f012037c <strtol>
f01033c3:	83 c4 10             	add    $0x10,%esp
f01033c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f01033c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033cc:	83 c0 08             	add    $0x8,%eax
f01033cf:	8b 00                	mov    (%eax),%eax
f01033d1:	83 ec 04             	sub    $0x4,%esp
f01033d4:	6a 0a                	push   $0xa
f01033d6:	6a 00                	push   $0x0
f01033d8:	50                   	push   %eax
f01033d9:	e8 9e cf 01 00       	call   f012037c <strtol>
f01033de:	83 c4 10             	add    $0x10,%esp
f01033e1:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f01033e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01033e8:	75 17                	jne    f0103401 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f01033ea:	83 ec 0c             	sub    $0xc,%esp
f01033ed:	68 7c 4b 12 f0       	push   $0xf0124b7c
f01033f2:	e8 94 db ff ff       	call   f0100f8b <cprintf>
f01033f7:	83 c4 10             	add    $0x10,%esp
		return 0;
f01033fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01033ff:	eb 4b                	jmp    f010344c <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0103401:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f0103405:	74 22                	je     f0103429 <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f0103407:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f010340b:	75 05                	jne    f0103412 <command_set_page_rep_nthCLOCK+0x6a>
f010340d:	f7 5d f4             	negl   -0xc(%ebp)
f0103410:	eb 17                	jmp    f0103429 <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0103412:	83 ec 0c             	sub    $0xc,%esp
f0103415:	68 ac 4b 12 f0       	push   $0xf0124bac
f010341a:	e8 6c db ff ff       	call   f0100f8b <cprintf>
f010341f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103422:	b8 00 00 00 00       	mov    $0x0,%eax
f0103427:	eb 23                	jmp    f010344c <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103429:	83 ec 0c             	sub    $0xc,%esp
f010342c:	ff 75 f4             	pushl  -0xc(%ebp)
f010342f:	e8 e7 c5 00 00       	call   f010fa1b <setPageReplacmentAlgorithmNchanceCLOCK>
f0103434:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103437:	83 ec 0c             	sub    $0xc,%esp
f010343a:	68 e8 4b 12 f0       	push   $0xf0124be8
f010343f:	e8 47 db ff ff       	call   f0100f8b <cprintf>
f0103444:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103447:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010344c:	c9                   	leave  
f010344d:	c3                   	ret    

f010344e <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010344e:	55                   	push   %ebp
f010344f:	89 e5                	mov    %esp,%ebp
f0103451:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103454:	e8 82 c5 00 00       	call   f010f9db <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103459:	83 ec 0c             	sub    $0xc,%esp
f010345c:	68 1c 4c 12 f0       	push   $0xf0124c1c
f0103461:	e8 25 db ff ff       	call   f0100f8b <cprintf>
f0103466:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103469:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010346e:	c9                   	leave  
f010346f:	c3                   	ret    

f0103470 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f0103470:	55                   	push   %ebp
f0103471:	89 e5                	mov    %esp,%ebp
f0103473:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103476:	e8 70 c5 00 00       	call   f010f9eb <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f010347b:	83 ec 0c             	sub    $0xc,%esp
f010347e:	68 48 4c 12 f0       	push   $0xf0124c48
f0103483:	e8 03 db ff ff       	call   f0100f8b <cprintf>
f0103488:	83 c4 10             	add    $0x10,%esp
	return 0;
f010348b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103490:	c9                   	leave  
f0103491:	c3                   	ret    

f0103492 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0103492:	55                   	push   %ebp
f0103493:	89 e5                	mov    %esp,%ebp
f0103495:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0103498:	e8 5e c5 00 00       	call   f010f9fb <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f010349d:	83 ec 0c             	sub    $0xc,%esp
f01034a0:	68 70 4c 12 f0       	push   $0xf0124c70
f01034a5:	e8 e1 da ff ff       	call   f0100f8b <cprintf>
f01034aa:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034b2:	c9                   	leave  
f01034b3:	c3                   	ret    

f01034b4 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01034b4:	55                   	push   %ebp
f01034b5:	89 e5                	mov    %esp,%ebp
f01034b7:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01034ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034bd:	83 c0 04             	add    $0x4,%eax
f01034c0:	8b 00                	mov    (%eax),%eax
f01034c2:	83 ec 04             	sub    $0x4,%esp
f01034c5:	6a 0a                	push   $0xa
f01034c7:	6a 00                	push   $0x0
f01034c9:	50                   	push   %eax
f01034ca:	e8 ad ce 01 00       	call   f012037c <strtol>
f01034cf:	83 c4 10             	add    $0x10,%esp
f01034d2:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01034d5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01034d9:	83 ec 0c             	sub    $0xc,%esp
f01034dc:	50                   	push   %eax
f01034dd:	e8 7f 37 00 00       	call   f0106c61 <sched_init_RR>
f01034e2:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f01034e5:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f01034ea:	8a 00                	mov    (%eax),%al
f01034ec:	0f b6 c0             	movzbl %al,%eax
f01034ef:	83 ec 08             	sub    $0x8,%esp
f01034f2:	50                   	push   %eax
f01034f3:	68 a4 4c 12 f0       	push   $0xf0124ca4
f01034f8:	e8 8e da ff ff       	call   f0100f8b <cprintf>
f01034fd:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103500:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103505:	c9                   	leave  
f0103506:	c3                   	ret    

f0103507 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103507:	55                   	push   %ebp
f0103508:	89 e5                	mov    %esp,%ebp
f010350a:	53                   	push   %ebx
f010350b:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010350e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103511:	83 c0 04             	add    $0x4,%eax
f0103514:	8b 00                	mov    (%eax),%eax
f0103516:	83 ec 04             	sub    $0x4,%esp
f0103519:	6a 0a                	push   $0xa
f010351b:	6a 00                	push   $0x0
f010351d:	50                   	push   %eax
f010351e:	e8 59 ce 01 00       	call   f012037c <strtol>
f0103523:	83 c4 10             	add    $0x10,%esp
f0103526:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103529:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103530:	eb 2e                	jmp    f0103560 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0103532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103535:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103538:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010353b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103542:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103545:	01 d0                	add    %edx,%eax
f0103547:	8b 00                	mov    (%eax),%eax
f0103549:	83 ec 04             	sub    $0x4,%esp
f010354c:	6a 0a                	push   $0xa
f010354e:	6a 00                	push   $0x0
f0103550:	50                   	push   %eax
f0103551:	e8 26 ce 01 00       	call   f012037c <strtol>
f0103556:	83 c4 10             	add    $0x10,%esp
f0103559:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010355d:	ff 45 f4             	incl   -0xc(%ebp)
f0103560:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103563:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103566:	7c ca                	jl     f0103532 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103568:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f010356c:	83 ec 08             	sub    $0x8,%esp
f010356f:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f0103572:	52                   	push   %edx
f0103573:	50                   	push   %eax
f0103574:	e8 96 37 00 00       	call   f0106d0f <sched_init_MLFQ>
f0103579:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f010357c:	83 ec 0c             	sub    $0xc,%esp
f010357f:	68 dc 4c 12 f0       	push   $0xf0124cdc
f0103584:	e8 02 da ff ff       	call   f0100f8b <cprintf>
f0103589:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010358c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103593:	eb 24                	jmp    f01035b9 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f0103595:	8b 15 e4 d5 b5 f0    	mov    0xf0b5d5e4,%edx
f010359b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010359e:	01 d0                	add    %edx,%eax
f01035a0:	8a 00                	mov    (%eax),%al
f01035a2:	0f b6 c0             	movzbl %al,%eax
f01035a5:	83 ec 08             	sub    $0x8,%esp
f01035a8:	50                   	push   %eax
f01035a9:	68 09 4d 12 f0       	push   $0xf0124d09
f01035ae:	e8 d8 d9 ff ff       	call   f0100f8b <cprintf>
f01035b3:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01035b6:	ff 45 f0             	incl   -0x10(%ebp)
f01035b9:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f01035be:	0f b6 c0             	movzbl %al,%eax
f01035c1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01035c4:	7f cf                	jg     f0103595 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01035c6:	83 ec 0c             	sub    $0xc,%esp
f01035c9:	68 21 46 12 f0       	push   $0xf0124621
f01035ce:	e8 b8 d9 ff ff       	call   f0100f8b <cprintf>
f01035d3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01035d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01035de:	c9                   	leave  
f01035df:	c3                   	ret    

f01035e0 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01035e0:	55                   	push   %ebp
f01035e1:	89 e5                	mov    %esp,%ebp
f01035e3:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01035e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035e9:	83 c0 04             	add    $0x4,%eax
f01035ec:	8b 00                	mov    (%eax),%eax
f01035ee:	83 ec 04             	sub    $0x4,%esp
f01035f1:	6a 0a                	push   $0xa
f01035f3:	6a 00                	push   $0x0
f01035f5:	50                   	push   %eax
f01035f6:	e8 81 cd 01 00       	call   f012037c <strtol>
f01035fb:	83 c4 10             	add    $0x10,%esp
f01035fe:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0103601:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103604:	83 c0 08             	add    $0x8,%eax
f0103607:	8b 00                	mov    (%eax),%eax
f0103609:	83 ec 04             	sub    $0x4,%esp
f010360c:	6a 0a                	push   $0xa
f010360e:	6a 00                	push   $0x0
f0103610:	50                   	push   %eax
f0103611:	e8 66 cd 01 00       	call   f012037c <strtol>
f0103616:	83 c4 10             	add    $0x10,%esp
f0103619:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f010361c:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103620:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103624:	83 ec 08             	sub    $0x8,%esp
f0103627:	52                   	push   %edx
f0103628:	50                   	push   %eax
f0103629:	e8 09 37 00 00       	call   f0106d37 <sched_init_BSD>
f010362e:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0103631:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103635:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103639:	83 ec 04             	sub    $0x4,%esp
f010363c:	52                   	push   %edx
f010363d:	50                   	push   %eax
f010363e:	68 10 4d 12 f0       	push   $0xf0124d10
f0103643:	e8 43 d9 ff ff       	call   f0100f8b <cprintf>
f0103648:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010364b:	83 ec 0c             	sub    $0xc,%esp
f010364e:	68 21 46 12 f0       	push   $0xf0124621
f0103653:	e8 33 d9 ff ff       	call   f0100f8b <cprintf>
f0103658:	83 c4 10             	add    $0x10,%esp
	return 0;
f010365b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103660:	c9                   	leave  
f0103661:	c3                   	ret    

f0103662 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0103662:	55                   	push   %ebp
f0103663:	89 e5                	mov    %esp,%ebp
f0103665:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f0103668:	8b 45 0c             	mov    0xc(%ebp),%eax
f010366b:	83 c0 04             	add    $0x4,%eax
f010366e:	8b 00                	mov    (%eax),%eax
f0103670:	83 ec 04             	sub    $0x4,%esp
f0103673:	6a 0a                	push   $0xa
f0103675:	6a 00                	push   $0x0
f0103677:	50                   	push   %eax
f0103678:	e8 ff cc 01 00       	call   f012037c <strtol>
f010367d:	83 c4 10             	add    $0x10,%esp
f0103680:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f0103683:	83 ec 0c             	sub    $0xc,%esp
f0103686:	ff 75 f4             	pushl  -0xc(%ebp)
f0103689:	e8 eb 32 00 00       	call   f0106979 <sched_set_starv_thresh>
f010368e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103691:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103696:	c9                   	leave  
f0103697:	c3                   	ret    

f0103698 <command_set_priority>:
int command_set_priority(int number_of_arguments, char **arguments)
{
f0103698:	55                   	push   %ebp
f0103699:	89 e5                	mov    %esp,%ebp
f010369b:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010369e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036a1:	83 c0 04             	add    $0x4,%eax
f01036a4:	8b 00                	mov    (%eax),%eax
f01036a6:	83 ec 04             	sub    $0x4,%esp
f01036a9:	6a 0a                	push   $0xa
f01036ab:	6a 00                	push   $0x0
f01036ad:	50                   	push   %eax
f01036ae:	e8 c9 cc 01 00       	call   f012037c <strtol>
f01036b3:	83 c4 10             	add    $0x10,%esp
f01036b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01036b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036bc:	83 c0 08             	add    $0x8,%eax
f01036bf:	8b 00                	mov    (%eax),%eax
f01036c1:	83 ec 04             	sub    $0x4,%esp
f01036c4:	6a 0a                	push   $0xa
f01036c6:	6a 00                	push   $0x0
f01036c8:	50                   	push   %eax
f01036c9:	e8 ae cc 01 00       	call   f012037c <strtol>
f01036ce:	83 c4 10             	add    $0x10,%esp
f01036d1:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01036d4:	83 ec 08             	sub    $0x8,%esp
f01036d7:	ff 75 f0             	pushl  -0x10(%ebp)
f01036da:	ff 75 f4             	pushl  -0xc(%ebp)
f01036dd:	e8 66 32 00 00       	call   f0106948 <env_set_priority>
f01036e2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01036e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036ea:	c9                   	leave  
f01036eb:	c3                   	ret    

f01036ec <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01036ec:	55                   	push   %ebp
f01036ed:	89 e5                	mov    %esp,%ebp
f01036ef:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01036f2:	e8 b1 32 00 00       	call   f01069a8 <isSchedMethodMLFQ>
f01036f7:	85 c0                	test   %eax,%eax
f01036f9:	74 5f                	je     f010375a <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01036fb:	83 ec 0c             	sub    $0xc,%esp
f01036fe:	68 4c 4d 12 f0       	push   $0xf0124d4c
f0103703:	e8 83 d8 ff ff       	call   f0100f8b <cprintf>
f0103708:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010370b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103712:	eb 24                	jmp    f0103738 <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f0103714:	8b 15 e4 d5 b5 f0    	mov    0xf0b5d5e4,%edx
f010371a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010371d:	01 d0                	add    %edx,%eax
f010371f:	8a 00                	mov    (%eax),%al
f0103721:	0f b6 c0             	movzbl %al,%eax
f0103724:	83 ec 08             	sub    $0x8,%esp
f0103727:	50                   	push   %eax
f0103728:	68 09 4d 12 f0       	push   $0xf0124d09
f010372d:	e8 59 d8 ff ff       	call   f0100f8b <cprintf>
f0103732:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103735:	ff 45 f4             	incl   -0xc(%ebp)
f0103738:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f010373d:	0f b6 c0             	movzbl %al,%eax
f0103740:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103743:	7f cf                	jg     f0103714 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0103745:	83 ec 0c             	sub    $0xc,%esp
f0103748:	68 21 46 12 f0       	push   $0xf0124621
f010374d:	e8 39 d8 ff ff       	call   f0100f8b <cprintf>
f0103752:	83 c4 10             	add    $0x10,%esp
f0103755:	e9 94 00 00 00       	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f010375a:	e8 37 32 00 00       	call   f0106996 <isSchedMethodRR>
f010375f:	85 c0                	test   %eax,%eax
f0103761:	74 1d                	je     f0103780 <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103763:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f0103768:	8a 00                	mov    (%eax),%al
f010376a:	0f b6 c0             	movzbl %al,%eax
f010376d:	83 ec 08             	sub    $0x8,%esp
f0103770:	50                   	push   %eax
f0103771:	68 80 4d 12 f0       	push   $0xf0124d80
f0103776:	e8 10 d8 ff ff       	call   f0100f8b <cprintf>
f010377b:	83 c4 10             	add    $0x10,%esp
f010377e:	eb 6e                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f0103780:	e8 36 32 00 00       	call   f01069bb <isSchedMethodBSD>
f0103785:	85 c0                	test   %eax,%eax
f0103787:	74 26                	je     f01037af <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103789:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f010378e:	8a 00                	mov    (%eax),%al
f0103790:	0f b6 d0             	movzbl %al,%edx
f0103793:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f0103798:	0f b6 c0             	movzbl %al,%eax
f010379b:	83 ec 04             	sub    $0x4,%esp
f010379e:	52                   	push   %edx
f010379f:	50                   	push   %eax
f01037a0:	68 10 4d 12 f0       	push   $0xf0124d10
f01037a5:	e8 e1 d7 ff ff       	call   f0100f8b <cprintf>
f01037aa:	83 c4 10             	add    $0x10,%esp
f01037ad:	eb 3f                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01037af:	e8 1a 32 00 00       	call   f01069ce <isSchedMethodPRIRR>
f01037b4:	85 c0                	test   %eax,%eax
f01037b6:	74 26                	je     f01037de <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01037b8:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f01037bd:	8a 00                	mov    (%eax),%al
f01037bf:	0f b6 d0             	movzbl %al,%edx
f01037c2:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f01037c7:	0f b6 c0             	movzbl %al,%eax
f01037ca:	83 ec 04             	sub    $0x4,%esp
f01037cd:	52                   	push   %edx
f01037ce:	50                   	push   %eax
f01037cf:	68 bc 4d 12 f0       	push   $0xf0124dbc
f01037d4:	e8 b2 d7 ff ff       	call   f0100f8b <cprintf>
f01037d9:	83 c4 10             	add    $0x10,%esp
f01037dc:	eb 10                	jmp    f01037ee <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01037de:	83 ec 0c             	sub    $0xc,%esp
f01037e1:	68 04 4e 12 f0       	push   $0xf0124e04
f01037e6:	e8 a0 d7 ff ff       	call   f0100f8b <cprintf>
f01037eb:	83 c4 10             	add    $0x10,%esp

	return 0;
f01037ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037f3:	c9                   	leave  
f01037f4:	c3                   	ret    

f01037f5 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01037f5:	55                   	push   %ebp
f01037f6:	89 e5                	mov    %esp,%ebp
f01037f8:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01037fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01037fe:	83 c0 04             	add    $0x4,%eax
f0103801:	8b 00                	mov    (%eax),%eax
f0103803:	83 ec 04             	sub    $0x4,%esp
f0103806:	6a 0a                	push   $0xa
f0103808:	6a 00                	push   $0x0
f010380a:	50                   	push   %eax
f010380b:	e8 6c cb 01 00       	call   f012037c <strtol>
f0103810:	83 c4 10             	add    $0x10,%esp
f0103813:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103816:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103819:	0f b6 c0             	movzbl %al,%eax
f010381c:	83 ec 0c             	sub    $0xc,%esp
f010381f:	50                   	push   %eax
f0103820:	e8 4b b9 01 00       	call   f011f170 <chksch>
f0103825:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103828:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010382c:	75 12                	jne    f0103840 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010382e:	83 ec 0c             	sub    $0xc,%esp
f0103831:	68 2c 4e 12 f0       	push   $0xf0124e2c
f0103836:	e8 50 d7 ff ff       	call   f0100f8b <cprintf>
f010383b:	83 c4 10             	add    $0x10,%esp
f010383e:	eb 16                	jmp    f0103856 <command_sch_test+0x61>
	else if (status == 1)
f0103840:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103844:	75 10                	jne    f0103856 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0103846:	83 ec 0c             	sub    $0xc,%esp
f0103849:	68 54 4e 12 f0       	push   $0xf0124e54
f010384e:	e8 38 d7 ff ff       	call   f0100f8b <cprintf>
f0103853:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103856:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010385b:	c9                   	leave  
f010385c:	c3                   	ret    

f010385d <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f010385d:	55                   	push   %ebp
f010385e:	89 e5                	mov    %esp,%ebp
f0103860:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0103863:	e8 e1 c1 00 00       	call   f010fa49 <isPageReplacmentAlgorithmCLOCK>
f0103868:	85 c0                	test   %eax,%eax
f010386a:	74 15                	je     f0103881 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f010386c:	83 ec 0c             	sub    $0xc,%esp
f010386f:	68 78 4e 12 f0       	push   $0xf0124e78
f0103874:	e8 12 d7 ff ff       	call   f0100f8b <cprintf>
f0103879:	83 c4 10             	add    $0x10,%esp
f010387c:	e9 e1 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0103881:	83 ec 0c             	sub    $0xc,%esp
f0103884:	6a 01                	push   $0x1
f0103886:	e8 a8 c1 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010388b:	83 c4 10             	add    $0x10,%esp
f010388e:	85 c0                	test   %eax,%eax
f0103890:	74 15                	je     f01038a7 <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0103892:	83 ec 0c             	sub    $0xc,%esp
f0103895:	68 a0 4e 12 f0       	push   $0xf0124ea0
f010389a:	e8 ec d6 ff ff       	call   f0100f8b <cprintf>
f010389f:	83 c4 10             	add    $0x10,%esp
f01038a2:	e9 bb 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01038a7:	83 ec 0c             	sub    $0xc,%esp
f01038aa:	6a 02                	push   $0x2
f01038ac:	e8 82 c1 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f01038b1:	83 c4 10             	add    $0x10,%esp
f01038b4:	85 c0                	test   %eax,%eax
f01038b6:	74 15                	je     f01038cd <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01038b8:	83 ec 0c             	sub    $0xc,%esp
f01038bb:	68 e0 4e 12 f0       	push   $0xf0124ee0
f01038c0:	e8 c6 d6 ff ff       	call   f0100f8b <cprintf>
f01038c5:	83 c4 10             	add    $0x10,%esp
f01038c8:	e9 95 00 00 00       	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmFIFO())
f01038cd:	e8 92 c1 00 00       	call   f010fa64 <isPageReplacmentAlgorithmFIFO>
f01038d2:	85 c0                	test   %eax,%eax
f01038d4:	74 12                	je     f01038e8 <command_print_page_rep+0x8b>
		cprintf("Page replacement algorithm is FIFO\n");
f01038d6:	83 ec 0c             	sub    $0xc,%esp
f01038d9:	68 1c 4f 12 f0       	push   $0xf0124f1c
f01038de:	e8 a8 d6 ff ff       	call   f0100f8b <cprintf>
f01038e3:	83 c4 10             	add    $0x10,%esp
f01038e6:	eb 7a                	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01038e8:	e8 92 c1 00 00       	call   f010fa7f <isPageReplacmentAlgorithmModifiedCLOCK>
f01038ed:	85 c0                	test   %eax,%eax
f01038ef:	74 12                	je     f0103903 <command_print_page_rep+0xa6>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01038f1:	83 ec 0c             	sub    $0xc,%esp
f01038f4:	68 40 4f 12 f0       	push   $0xf0124f40
f01038f9:	e8 8d d6 ff ff       	call   f0100f8b <cprintf>
f01038fe:	83 c4 10             	add    $0x10,%esp
f0103901:	eb 5f                	jmp    f0103962 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0103903:	e8 ad c1 00 00       	call   f010fab5 <isPageReplacmentAlgorithmNchanceCLOCK>
f0103908:	85 c0                	test   %eax,%eax
f010390a:	74 46                	je     f0103952 <command_print_page_rep+0xf5>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f010390c:	83 ec 0c             	sub    $0xc,%esp
f010390f:	68 70 4f 12 f0       	push   $0xf0124f70
f0103914:	e8 72 d6 ff ff       	call   f0100f8b <cprintf>
f0103919:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f010391c:	a1 b4 d2 75 f0       	mov    0xf075d2b4,%eax
f0103921:	85 c0                	test   %eax,%eax
f0103923:	7e 12                	jle    f0103937 <command_print_page_rep+0xda>
f0103925:	83 ec 0c             	sub    $0xc,%esp
f0103928:	68 a0 4f 12 f0       	push   $0xf0124fa0
f010392d:	e8 59 d6 ff ff       	call   f0100f8b <cprintf>
f0103932:	83 c4 10             	add    $0x10,%esp
f0103935:	eb 2b                	jmp    f0103962 <command_print_page_rep+0x105>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f0103937:	a1 b4 d2 75 f0       	mov    0xf075d2b4,%eax
f010393c:	85 c0                	test   %eax,%eax
f010393e:	79 22                	jns    f0103962 <command_print_page_rep+0x105>
f0103940:	83 ec 0c             	sub    $0xc,%esp
f0103943:	68 ae 4f 12 f0       	push   $0xf0124fae
f0103948:	e8 3e d6 ff ff       	call   f0100f8b <cprintf>
f010394d:	83 c4 10             	add    $0x10,%esp
f0103950:	eb 10                	jmp    f0103962 <command_print_page_rep+0x105>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0103952:	83 ec 0c             	sub    $0xc,%esp
f0103955:	68 c0 4f 12 f0       	push   $0xf0124fc0
f010395a:	e8 2c d6 ff ff       	call   f0100f8b <cprintf>
f010395f:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103962:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103967:	c9                   	leave  
f0103968:	c3                   	ret    

f0103969 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103969:	55                   	push   %ebp
f010396a:	89 e5                	mov    %esp,%ebp
f010396c:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010396f:	e8 3b ec ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103974:	83 ec 0c             	sub    $0xc,%esp
f0103977:	68 ec 4f 12 f0       	push   $0xf0124fec
f010397c:	e8 0a d6 ff ff       	call   f0100f8b <cprintf>
f0103981:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103984:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103989:	c9                   	leave  
f010398a:	c3                   	ret    

f010398b <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f010398b:	55                   	push   %ebp
f010398c:	89 e5                	mov    %esp,%ebp
f010398e:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f0103991:	e8 29 ec ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f0103996:	83 ec 0c             	sub    $0xc,%esp
f0103999:	68 1c 50 12 f0       	push   $0xf012501c
f010399e:	e8 e8 d5 ff ff       	call   f0100f8b <cprintf>
f01039a3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039ab:	c9                   	leave  
f01039ac:	c3                   	ret    

f01039ad <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01039ad:	55                   	push   %ebp
f01039ae:	89 e5                	mov    %esp,%ebp
f01039b0:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01039b3:	e8 17 ec ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01039b8:	83 ec 0c             	sub    $0xc,%esp
f01039bb:	68 4c 50 12 f0       	push   $0xf012504c
f01039c0:	e8 c6 d5 ff ff       	call   f0100f8b <cprintf>
f01039c5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039cd:	c9                   	leave  
f01039ce:	c3                   	ret    

f01039cf <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01039cf:	55                   	push   %ebp
f01039d0:	89 e5                	mov    %esp,%ebp
f01039d2:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01039d5:	e8 05 ec ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01039da:	83 ec 0c             	sub    $0xc,%esp
f01039dd:	68 7c 50 12 f0       	push   $0xf012507c
f01039e2:	e8 a4 d5 ff ff       	call   f0100f8b <cprintf>
f01039e7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039ef:	c9                   	leave  
f01039f0:	c3                   	ret    

f01039f1 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01039f1:	55                   	push   %ebp
f01039f2:	89 e5                	mov    %esp,%ebp
f01039f4:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f01039f7:	e8 f3 eb ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f01039fc:	84 c0                	test   %al,%al
f01039fe:	74 12                	je     f0103a12 <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0103a00:	83 ec 0c             	sub    $0xc,%esp
f0103a03:	68 ac 50 12 f0       	push   $0xf01250ac
f0103a08:	e8 7e d5 ff ff       	call   f0100f8b <cprintf>
f0103a0d:	83 c4 10             	add    $0x10,%esp
f0103a10:	eb 61                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f0103a12:	e8 ed eb ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103a17:	84 c0                	test   %al,%al
f0103a19:	74 12                	je     f0103a2d <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103a1b:	83 ec 0c             	sub    $0xc,%esp
f0103a1e:	68 d8 50 12 f0       	push   $0xf01250d8
f0103a23:	e8 63 d5 ff ff       	call   f0100f8b <cprintf>
f0103a28:	83 c4 10             	add    $0x10,%esp
f0103a2b:	eb 46                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103a2d:	e8 e7 eb ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f0103a32:	84 c0                	test   %al,%al
f0103a34:	74 12                	je     f0103a48 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103a36:	83 ec 0c             	sub    $0xc,%esp
f0103a39:	68 04 51 12 f0       	push   $0xf0125104
f0103a3e:	e8 48 d5 ff ff       	call   f0100f8b <cprintf>
f0103a43:	83 c4 10             	add    $0x10,%esp
f0103a46:	eb 2b                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103a48:	e8 e1 eb ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103a4d:	84 c0                	test   %al,%al
f0103a4f:	74 12                	je     f0103a63 <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f0103a51:	83 ec 0c             	sub    $0xc,%esp
f0103a54:	68 30 51 12 f0       	push   $0xf0125130
f0103a59:	e8 2d d5 ff ff       	call   f0100f8b <cprintf>
f0103a5e:	83 c4 10             	add    $0x10,%esp
f0103a61:	eb 10                	jmp    f0103a73 <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f0103a63:	83 ec 0c             	sub    $0xc,%esp
f0103a66:	68 5c 51 12 f0       	push   $0xf012515c
f0103a6b:	e8 1b d5 ff ff       	call   f0100f8b <cprintf>
f0103a70:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103a73:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a78:	c9                   	leave  
f0103a79:	c3                   	ret    

f0103a7a <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103a7a:	55                   	push   %ebp
f0103a7b:	89 e5                	mov    %esp,%ebp
f0103a7d:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f0103a80:	e8 72 ea ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103a85:	83 ec 0c             	sub    $0xc,%esp
f0103a88:	68 88 51 12 f0       	push   $0xf0125188
f0103a8d:	e8 f9 d4 ff ff       	call   f0100f8b <cprintf>
f0103a92:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a95:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a9a:	c9                   	leave  
f0103a9b:	c3                   	ret    

f0103a9c <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103a9c:	55                   	push   %ebp
f0103a9d:	89 e5                	mov    %esp,%ebp
f0103a9f:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f0103aa2:	e8 60 ea ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103aa7:	83 ec 0c             	sub    $0xc,%esp
f0103aaa:	68 88 51 12 f0       	push   $0xf0125188
f0103aaf:	e8 d7 d4 ff ff       	call   f0100f8b <cprintf>
f0103ab4:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ab7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103abc:	c9                   	leave  
f0103abd:	c3                   	ret    

f0103abe <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103abe:	55                   	push   %ebp
f0103abf:	89 e5                	mov    %esp,%ebp
f0103ac1:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f0103ac4:	e8 4e ea ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0103ac9:	83 ec 0c             	sub    $0xc,%esp
f0103acc:	68 bc 51 12 f0       	push   $0xf01251bc
f0103ad1:	e8 b5 d4 ff ff       	call   f0100f8b <cprintf>
f0103ad6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ad9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ade:	c9                   	leave  
f0103adf:	c3                   	ret    

f0103ae0 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103ae0:	55                   	push   %ebp
f0103ae1:	89 e5                	mov    %esp,%ebp
f0103ae3:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f0103ae6:	e8 3c ea ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103aeb:	83 ec 0c             	sub    $0xc,%esp
f0103aee:	68 ec 51 12 f0       	push   $0xf01251ec
f0103af3:	e8 93 d4 ff ff       	call   f0100f8b <cprintf>
f0103af8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103afb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b00:	c9                   	leave  
f0103b01:	c3                   	ret    

f0103b02 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103b02:	55                   	push   %ebp
f0103b03:	89 e5                	mov    %esp,%ebp
f0103b05:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103b08:	e8 2a ea ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103b0d:	83 ec 0c             	sub    $0xc,%esp
f0103b10:	68 1c 52 12 f0       	push   $0xf012521c
f0103b15:	e8 71 d4 ff ff       	call   f0100f8b <cprintf>
f0103b1a:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b1d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b22:	c9                   	leave  
f0103b23:	c3                   	ret    

f0103b24 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103b24:	55                   	push   %ebp
f0103b25:	89 e5                	mov    %esp,%ebp
f0103b27:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103b2a:	e8 18 ea ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f0103b2f:	84 c0                	test   %al,%al
f0103b31:	74 12                	je     f0103b45 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f0103b33:	83 ec 0c             	sub    $0xc,%esp
f0103b36:	68 50 52 12 f0       	push   $0xf0125250
f0103b3b:	e8 4b d4 ff ff       	call   f0100f8b <cprintf>
f0103b40:	83 c4 10             	add    $0x10,%esp
f0103b43:	eb 7c                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103b45:	e8 11 ea ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103b4a:	84 c0                	test   %al,%al
f0103b4c:	74 12                	je     f0103b60 <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0103b4e:	83 ec 0c             	sub    $0xc,%esp
f0103b51:	68 8c 52 12 f0       	push   $0xf012528c
f0103b56:	e8 30 d4 ff ff       	call   f0100f8b <cprintf>
f0103b5b:	83 c4 10             	add    $0x10,%esp
f0103b5e:	eb 61                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f0103b60:	e8 0b ea ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103b65:	84 c0                	test   %al,%al
f0103b67:	74 12                	je     f0103b7b <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103b69:	83 ec 0c             	sub    $0xc,%esp
f0103b6c:	68 bc 52 12 f0       	push   $0xf01252bc
f0103b71:	e8 15 d4 ff ff       	call   f0100f8b <cprintf>
f0103b76:	83 c4 10             	add    $0x10,%esp
f0103b79:	eb 46                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103b7b:	e8 05 ea ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f0103b80:	84 c0                	test   %al,%al
f0103b82:	74 12                	je     f0103b96 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103b84:	83 ec 0c             	sub    $0xc,%esp
f0103b87:	68 e8 52 12 f0       	push   $0xf01252e8
f0103b8c:	e8 fa d3 ff ff       	call   f0100f8b <cprintf>
f0103b91:	83 c4 10             	add    $0x10,%esp
f0103b94:	eb 2b                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f0103b96:	e8 ff e9 ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f0103b9b:	84 c0                	test   %al,%al
f0103b9d:	74 12                	je     f0103bb1 <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0103b9f:	83 ec 0c             	sub    $0xc,%esp
f0103ba2:	68 14 53 12 f0       	push   $0xf0125314
f0103ba7:	e8 df d3 ff ff       	call   f0100f8b <cprintf>
f0103bac:	83 c4 10             	add    $0x10,%esp
f0103baf:	eb 10                	jmp    f0103bc1 <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f0103bb1:	83 ec 0c             	sub    $0xc,%esp
f0103bb4:	68 44 53 12 f0       	push   $0xf0125344
f0103bb9:	e8 cd d3 ff ff       	call   f0100f8b <cprintf>
f0103bbe:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103bc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bc6:	c9                   	leave  
f0103bc7:	c3                   	ret    

f0103bc8 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103bc8:	55                   	push   %ebp
f0103bc9:	89 e5                	mov    %esp,%ebp
f0103bcb:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103bce:	e8 23 bf 00 00       	call   f010faf6 <isBufferingEnabled>
f0103bd3:	84 c0                	test   %al,%al
f0103bd5:	75 12                	jne    f0103be9 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103bd7:	83 ec 0c             	sub    $0xc,%esp
f0103bda:	68 74 53 12 f0       	push   $0xf0125374
f0103bdf:	e8 a7 d3 ff ff       	call   f0100f8b <cprintf>
f0103be4:	83 c4 10             	add    $0x10,%esp
f0103be7:	eb 1d                	jmp    f0103c06 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103be9:	83 ec 0c             	sub    $0xc,%esp
f0103bec:	6a 00                	push   $0x0
f0103bee:	e8 dd be 00 00       	call   f010fad0 <enableModifiedBuffer>
f0103bf3:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103bf6:	83 ec 0c             	sub    $0xc,%esp
f0103bf9:	68 b0 53 12 f0       	push   $0xf01253b0
f0103bfe:	e8 88 d3 ff ff       	call   f0100f8b <cprintf>
f0103c03:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c06:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c0b:	c9                   	leave  
f0103c0c:	c3                   	ret    

f0103c0d <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103c0d:	55                   	push   %ebp
f0103c0e:	89 e5                	mov    %esp,%ebp
f0103c10:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103c13:	e8 de be 00 00       	call   f010faf6 <isBufferingEnabled>
f0103c18:	84 c0                	test   %al,%al
f0103c1a:	75 12                	jne    f0103c2e <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103c1c:	83 ec 0c             	sub    $0xc,%esp
f0103c1f:	68 74 53 12 f0       	push   $0xf0125374
f0103c24:	e8 62 d3 ff ff       	call   f0100f8b <cprintf>
f0103c29:	83 c4 10             	add    $0x10,%esp
f0103c2c:	eb 1d                	jmp    f0103c4b <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103c2e:	83 ec 0c             	sub    $0xc,%esp
f0103c31:	6a 01                	push   $0x1
f0103c33:	e8 98 be 00 00       	call   f010fad0 <enableModifiedBuffer>
f0103c38:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103c3b:	83 ec 0c             	sub    $0xc,%esp
f0103c3e:	68 d4 53 12 f0       	push   $0xf01253d4
f0103c43:	e8 43 d3 ff ff       	call   f0100f8b <cprintf>
f0103c48:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c50:	c9                   	leave  
f0103c51:	c3                   	ret    

f0103c52 <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103c52:	55                   	push   %ebp
f0103c53:	89 e5                	mov    %esp,%ebp
f0103c55:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103c58:	83 ec 0c             	sub    $0xc,%esp
f0103c5b:	6a 00                	push   $0x0
f0103c5d:	e8 86 be 00 00       	call   f010fae8 <enableBuffering>
f0103c62:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103c65:	83 ec 0c             	sub    $0xc,%esp
f0103c68:	6a 00                	push   $0x0
f0103c6a:	e8 61 be 00 00       	call   f010fad0 <enableModifiedBuffer>
f0103c6f:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103c72:	83 ec 0c             	sub    $0xc,%esp
f0103c75:	68 f4 53 12 f0       	push   $0xf01253f4
f0103c7a:	e8 0c d3 ff ff       	call   f0100f8b <cprintf>
f0103c7f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103c82:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c87:	c9                   	leave  
f0103c88:	c3                   	ret    

f0103c89 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103c89:	55                   	push   %ebp
f0103c8a:	89 e5                	mov    %esp,%ebp
f0103c8c:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103c8f:	83 ec 0c             	sub    $0xc,%esp
f0103c92:	6a 01                	push   $0x1
f0103c94:	e8 4f be 00 00       	call   f010fae8 <enableBuffering>
f0103c99:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103c9c:	83 ec 0c             	sub    $0xc,%esp
f0103c9f:	6a 01                	push   $0x1
f0103ca1:	e8 2a be 00 00       	call   f010fad0 <enableModifiedBuffer>
f0103ca6:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ca9:	e8 60 be 00 00       	call   f010fb0e <getModifiedBufferLength>
f0103cae:	85 c0                	test   %eax,%eax
f0103cb0:	75 59                	jne    f0103d0b <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103cb2:	83 ec 0c             	sub    $0xc,%esp
f0103cb5:	68 10 54 12 f0       	push   $0xf0125410
f0103cba:	e8 cc d2 ff ff       	call   f0100f8b <cprintf>
f0103cbf:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103cc2:	83 ec 08             	sub    $0x8,%esp
f0103cc5:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103cc8:	50                   	push   %eax
f0103cc9:	68 40 54 12 f0       	push   $0xf0125440
f0103cce:	e8 41 c1 01 00       	call   f011fe14 <readline>
f0103cd3:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103cd6:	83 ec 04             	sub    $0x4,%esp
f0103cd9:	6a 0a                	push   $0xa
f0103cdb:	6a 00                	push   $0x0
f0103cdd:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ce0:	50                   	push   %eax
f0103ce1:	e8 96 c6 01 00       	call   f012037c <strtol>
f0103ce6:	83 c4 10             	add    $0x10,%esp
f0103ce9:	83 ec 0c             	sub    $0xc,%esp
f0103cec:	50                   	push   %eax
f0103ced:	e8 0e be 00 00       	call   f010fb00 <setModifiedBufferLength>
f0103cf2:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103cf5:	e8 14 be 00 00       	call   f010fb0e <getModifiedBufferLength>
f0103cfa:	83 ec 08             	sub    $0x8,%esp
f0103cfd:	50                   	push   %eax
f0103cfe:	68 6c 54 12 f0       	push   $0xf012546c
f0103d03:	e8 83 d2 ff ff       	call   f0100f8b <cprintf>
f0103d08:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103d0b:	83 ec 0c             	sub    $0xc,%esp
f0103d0e:	68 91 54 12 f0       	push   $0xf0125491
f0103d13:	e8 73 d2 ff ff       	call   f0100f8b <cprintf>
f0103d18:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d20:	c9                   	leave  
f0103d21:	c3                   	ret    

f0103d22 <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d22:	55                   	push   %ebp
f0103d23:	89 e5                	mov    %esp,%ebp
f0103d25:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103d28:	e8 c9 bd 00 00       	call   f010faf6 <isBufferingEnabled>
f0103d2d:	84 c0                	test   %al,%al
f0103d2f:	75 12                	jne    f0103d43 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103d31:	83 ec 0c             	sub    $0xc,%esp
f0103d34:	68 ac 54 12 f0       	push   $0xf01254ac
f0103d39:	e8 4d d2 ff ff       	call   f0100f8b <cprintf>
f0103d3e:	83 c4 10             	add    $0x10,%esp
f0103d41:	eb 19                	jmp    f0103d5c <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103d43:	e8 96 bd 00 00       	call   f010fade <isModifiedBufferEnabled>
f0103d48:	84 c0                	test   %al,%al
f0103d4a:	75 10                	jne    f0103d5c <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103d4c:	83 ec 0c             	sub    $0xc,%esp
f0103d4f:	68 fc 54 12 f0       	push   $0xf01254fc
f0103d54:	e8 32 d2 ff ff       	call   f0100f8b <cprintf>
f0103d59:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d5f:	83 c0 04             	add    $0x4,%eax
f0103d62:	8b 00                	mov    (%eax),%eax
f0103d64:	83 ec 04             	sub    $0x4,%esp
f0103d67:	6a 0a                	push   $0xa
f0103d69:	6a 00                	push   $0x0
f0103d6b:	50                   	push   %eax
f0103d6c:	e8 0b c6 01 00       	call   f012037c <strtol>
f0103d71:	83 c4 10             	add    $0x10,%esp
f0103d74:	83 ec 0c             	sub    $0xc,%esp
f0103d77:	50                   	push   %eax
f0103d78:	e8 83 bd 00 00       	call   f010fb00 <setModifiedBufferLength>
f0103d7d:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103d80:	e8 89 bd 00 00       	call   f010fb0e <getModifiedBufferLength>
f0103d85:	83 ec 08             	sub    $0x8,%esp
f0103d88:	50                   	push   %eax
f0103d89:	68 6c 54 12 f0       	push   $0xf012546c
f0103d8e:	e8 f8 d1 ff ff       	call   f0100f8b <cprintf>
f0103d93:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d96:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d9b:	c9                   	leave  
f0103d9c:	c3                   	ret    

f0103d9d <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d9d:	55                   	push   %ebp
f0103d9e:	89 e5                	mov    %esp,%ebp
f0103da0:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103da3:	e8 4e bd 00 00       	call   f010faf6 <isBufferingEnabled>
f0103da8:	84 c0                	test   %al,%al
f0103daa:	75 12                	jne    f0103dbe <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103dac:	83 ec 0c             	sub    $0xc,%esp
f0103daf:	68 ac 54 12 f0       	push   $0xf01254ac
f0103db4:	e8 d2 d1 ff ff       	call   f0100f8b <cprintf>
f0103db9:	83 c4 10             	add    $0x10,%esp
f0103dbc:	eb 19                	jmp    f0103dd7 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103dbe:	e8 1b bd 00 00       	call   f010fade <isModifiedBufferEnabled>
f0103dc3:	84 c0                	test   %al,%al
f0103dc5:	75 10                	jne    f0103dd7 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103dc7:	83 ec 0c             	sub    $0xc,%esp
f0103dca:	68 fc 54 12 f0       	push   $0xf01254fc
f0103dcf:	e8 b7 d1 ff ff       	call   f0100f8b <cprintf>
f0103dd4:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103dd7:	e8 32 bd 00 00       	call   f010fb0e <getModifiedBufferLength>
f0103ddc:	83 ec 08             	sub    $0x8,%esp
f0103ddf:	50                   	push   %eax
f0103de0:	68 42 55 12 f0       	push   $0xf0125542
f0103de5:	e8 a1 d1 ff ff       	call   f0100f8b <cprintf>
f0103dea:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ded:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103df2:	c9                   	leave  
f0103df3:	c3                   	ret    

f0103df4 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103df4:	55                   	push   %ebp
f0103df5:	89 e5                	mov    %esp,%ebp
f0103df7:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103dfa:	83 ec 08             	sub    $0x8,%esp
f0103dfd:	ff 75 0c             	pushl  0xc(%ebp)
f0103e00:	ff 75 08             	pushl  0x8(%ebp)
f0103e03:	e8 4d c8 00 00       	call   f0110655 <tst_handler>
f0103e08:	83 c4 10             	add    $0x10,%esp
}
f0103e0b:	c9                   	leave  
f0103e0c:	c3                   	ret    

f0103e0d <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103e0d:	55                   	push   %ebp
f0103e0e:	89 e5                	mov    %esp,%ebp
f0103e10:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e13:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e16:	05 00 14 00 00       	add    $0x1400,%eax
f0103e1b:	c1 e0 03             	shl    $0x3,%eax
f0103e1e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e21:	83 ec 04             	sub    $0x4,%esp
f0103e24:	6a 08                	push   $0x8
f0103e26:	ff 75 0c             	pushl  0xc(%ebp)
f0103e29:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e2c:	e8 d3 c9 01 00       	call   f0120804 <ide_read>
f0103e31:	83 c4 10             	add    $0x10,%esp
f0103e34:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e3a:	c9                   	leave  
f0103e3b:	c3                   	ret    

f0103e3c <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103e3c:	55                   	push   %ebp
f0103e3d:	89 e5                	mov    %esp,%ebp
f0103e3f:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e42:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e45:	05 00 14 00 00       	add    $0x1400,%eax
f0103e4a:	c1 e0 03             	shl    $0x3,%eax
f0103e4d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e50:	83 ec 04             	sub    $0x4,%esp
f0103e53:	6a 08                	push   $0x8
f0103e55:	ff 75 0c             	pushl  0xc(%ebp)
f0103e58:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e5b:	e8 e4 ca 01 00       	call   f0120944 <ide_write>
f0103e60:	83 c4 10             	add    $0x10,%esp
f0103e63:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103e66:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e6a:	74 14                	je     f0103e80 <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103e6c:	83 ec 04             	sub    $0x4,%esp
f0103e6f:	68 60 55 12 f0       	push   $0xf0125560
f0103e74:	6a 2f                	push   $0x2f
f0103e76:	68 77 55 12 f0       	push   $0xf0125577
f0103e7b:	e8 b9 c4 ff ff       	call   f0100339 <_panic>
	return success;
f0103e80:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e83:	c9                   	leave  
f0103e84:	c3                   	ret    

f0103e85 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103e85:	55                   	push   %ebp
f0103e86:	89 e5                	mov    %esp,%ebp
f0103e88:	53                   	push   %ebx
f0103e89:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103e8c:	c7 05 60 d9 f5 f0 00 	movl   $0x0,0xf0f5d960
f0103e93:	00 00 00 
f0103e96:	c7 05 64 d9 f5 f0 00 	movl   $0x0,0xf0f5d964
f0103e9d:	00 00 00 
f0103ea0:	c7 05 6c d9 f5 f0 00 	movl   $0x0,0xf0f5d96c
f0103ea7:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103eaa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103eb1:	e9 e8 00 00 00       	jmp    f0103f9e <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103eb6:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f0103ebc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ebf:	89 d0                	mov    %edx,%eax
f0103ec1:	01 c0                	add    %eax,%eax
f0103ec3:	01 d0                	add    %edx,%eax
f0103ec5:	c1 e0 03             	shl    $0x3,%eax
f0103ec8:	01 c8                	add    %ecx,%eax
f0103eca:	83 ec 0c             	sub    $0xc,%esp
f0103ecd:	50                   	push   %eax
f0103ece:	e8 ef 45 00 00       	call   f01084c2 <initialize_frame_info>
f0103ed3:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ed6:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f0103edc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103edf:	89 d0                	mov    %edx,%eax
f0103ee1:	01 c0                	add    %eax,%eax
f0103ee3:	01 d0                	add    %edx,%eax
f0103ee5:	c1 e0 03             	shl    $0x3,%eax
f0103ee8:	01 c8                	add    %ecx,%eax
f0103eea:	85 c0                	test   %eax,%eax
f0103eec:	75 14                	jne    f0103f02 <initialize_disk_page_file+0x7d>
f0103eee:	83 ec 04             	sub    $0x4,%esp
f0103ef1:	68 94 55 12 f0       	push   $0xf0125594
f0103ef6:	6a 56                	push   $0x56
f0103ef8:	68 77 55 12 f0       	push   $0xf0125577
f0103efd:	e8 37 c4 ff ff       	call   f0100339 <_panic>
f0103f02:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f0103f08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f0b:	89 d0                	mov    %edx,%eax
f0103f0d:	01 c0                	add    %eax,%eax
f0103f0f:	01 d0                	add    %edx,%eax
f0103f11:	c1 e0 03             	shl    $0x3,%eax
f0103f14:	01 c8                	add    %ecx,%eax
f0103f16:	8b 15 60 d9 f5 f0    	mov    0xf0f5d960,%edx
f0103f1c:	89 10                	mov    %edx,(%eax)
f0103f1e:	8b 00                	mov    (%eax),%eax
f0103f20:	85 c0                	test   %eax,%eax
f0103f22:	74 1f                	je     f0103f43 <initialize_disk_page_file+0xbe>
f0103f24:	8b 15 60 d9 f5 f0    	mov    0xf0f5d960,%edx
f0103f2a:	8b 1d e0 cf 75 f0    	mov    0xf075cfe0,%ebx
f0103f30:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103f33:	89 c8                	mov    %ecx,%eax
f0103f35:	01 c0                	add    %eax,%eax
f0103f37:	01 c8                	add    %ecx,%eax
f0103f39:	c1 e0 03             	shl    $0x3,%eax
f0103f3c:	01 d8                	add    %ebx,%eax
f0103f3e:	89 42 04             	mov    %eax,0x4(%edx)
f0103f41:	eb 19                	jmp    f0103f5c <initialize_disk_page_file+0xd7>
f0103f43:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f0103f49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f4c:	89 d0                	mov    %edx,%eax
f0103f4e:	01 c0                	add    %eax,%eax
f0103f50:	01 d0                	add    %edx,%eax
f0103f52:	c1 e0 03             	shl    $0x3,%eax
f0103f55:	01 c8                	add    %ecx,%eax
f0103f57:	a3 64 d9 f5 f0       	mov    %eax,0xf0f5d964
f0103f5c:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f0103f62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f65:	89 d0                	mov    %edx,%eax
f0103f67:	01 c0                	add    %eax,%eax
f0103f69:	01 d0                	add    %edx,%eax
f0103f6b:	c1 e0 03             	shl    $0x3,%eax
f0103f6e:	01 c8                	add    %ecx,%eax
f0103f70:	a3 60 d9 f5 f0       	mov    %eax,0xf0f5d960
f0103f75:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f0103f7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f7e:	89 d0                	mov    %edx,%eax
f0103f80:	01 c0                	add    %eax,%eax
f0103f82:	01 d0                	add    %edx,%eax
f0103f84:	c1 e0 03             	shl    $0x3,%eax
f0103f87:	01 c8                	add    %ecx,%eax
f0103f89:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103f90:	a1 6c d9 f5 f0       	mov    0xf0f5d96c,%eax
f0103f95:	40                   	inc    %eax
f0103f96:	a3 6c d9 f5 f0       	mov    %eax,0xf0f5d96c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103f9b:	ff 45 f4             	incl   -0xc(%ebp)
f0103f9e:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103fa5:	0f 8e 0b ff ff ff    	jle    f0103eb6 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103fab:	90                   	nop
f0103fac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103faf:	c9                   	leave  
f0103fb0:	c3                   	ret    

f0103fb1 <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103fb1:	55                   	push   %ebp
f0103fb2:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103fb4:	8b 45 08             	mov    0x8(%ebp),%eax
f0103fb7:	8b 15 e0 cf 75 f0    	mov    0xf075cfe0,%edx
f0103fbd:	29 d0                	sub    %edx,%eax
f0103fbf:	c1 f8 03             	sar    $0x3,%eax
f0103fc2:	89 c2                	mov    %eax,%edx
f0103fc4:	89 d0                	mov    %edx,%eax
f0103fc6:	c1 e0 02             	shl    $0x2,%eax
f0103fc9:	01 d0                	add    %edx,%eax
f0103fcb:	c1 e0 02             	shl    $0x2,%eax
f0103fce:	01 d0                	add    %edx,%eax
f0103fd0:	c1 e0 02             	shl    $0x2,%eax
f0103fd3:	01 d0                	add    %edx,%eax
f0103fd5:	89 c1                	mov    %eax,%ecx
f0103fd7:	c1 e1 08             	shl    $0x8,%ecx
f0103fda:	01 c8                	add    %ecx,%eax
f0103fdc:	89 c1                	mov    %eax,%ecx
f0103fde:	c1 e1 10             	shl    $0x10,%ecx
f0103fe1:	01 c8                	add    %ecx,%eax
f0103fe3:	01 c0                	add    %eax,%eax
f0103fe5:	01 d0                	add    %edx,%eax
}
f0103fe7:	5d                   	pop    %ebp
f0103fe8:	c3                   	ret    

f0103fe9 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103fe9:	55                   	push   %ebp
f0103fea:	89 e5                	mov    %esp,%ebp
f0103fec:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103fef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ff6:	83 ec 0c             	sub    $0xc,%esp
f0103ff9:	68 70 d9 f5 f0       	push   $0xf0f5d970
f0103ffe:	e8 6b c0 00 00       	call   f011006e <acquire_spinlock>
f0104003:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104006:	a1 60 d9 f5 f0       	mov    0xf0f5d960,%eax
f010400b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f010400e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104012:	75 0c                	jne    f0104020 <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104014:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f010401b:	e9 a2 00 00 00       	jmp    f01040c2 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0104020:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104024:	75 14                	jne    f010403a <allocate_disk_frame+0x51>
f0104026:	83 ec 04             	sub    $0x4,%esp
f0104029:	68 b7 55 12 f0       	push   $0xf01255b7
f010402e:	6a 7b                	push   $0x7b
f0104030:	68 77 55 12 f0       	push   $0xf0125577
f0104035:	e8 ff c2 ff ff       	call   f0100339 <_panic>
f010403a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010403d:	8b 00                	mov    (%eax),%eax
f010403f:	85 c0                	test   %eax,%eax
f0104041:	74 10                	je     f0104053 <allocate_disk_frame+0x6a>
f0104043:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104046:	8b 00                	mov    (%eax),%eax
f0104048:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010404b:	8b 52 04             	mov    0x4(%edx),%edx
f010404e:	89 50 04             	mov    %edx,0x4(%eax)
f0104051:	eb 0b                	jmp    f010405e <allocate_disk_frame+0x75>
f0104053:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104056:	8b 40 04             	mov    0x4(%eax),%eax
f0104059:	a3 64 d9 f5 f0       	mov    %eax,0xf0f5d964
f010405e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104061:	8b 40 04             	mov    0x4(%eax),%eax
f0104064:	85 c0                	test   %eax,%eax
f0104066:	74 0f                	je     f0104077 <allocate_disk_frame+0x8e>
f0104068:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010406b:	8b 40 04             	mov    0x4(%eax),%eax
f010406e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104071:	8b 12                	mov    (%edx),%edx
f0104073:	89 10                	mov    %edx,(%eax)
f0104075:	eb 0a                	jmp    f0104081 <allocate_disk_frame+0x98>
f0104077:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010407a:	8b 00                	mov    (%eax),%eax
f010407c:	a3 60 d9 f5 f0       	mov    %eax,0xf0f5d960
f0104081:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104084:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010408a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010408d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104094:	a1 6c d9 f5 f0       	mov    0xf0f5d96c,%eax
f0104099:	48                   	dec    %eax
f010409a:	a3 6c d9 f5 f0       	mov    %eax,0xf0f5d96c
			initialize_frame_info(ptr_frame_info);
f010409f:	83 ec 0c             	sub    $0xc,%esp
f01040a2:	ff 75 f0             	pushl  -0x10(%ebp)
f01040a5:	e8 18 44 00 00       	call   f01084c2 <initialize_frame_info>
f01040aa:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f01040ad:	83 ec 0c             	sub    $0xc,%esp
f01040b0:	ff 75 f0             	pushl  -0x10(%ebp)
f01040b3:	e8 f9 fe ff ff       	call   f0103fb1 <to_disk_frame_number>
f01040b8:	83 c4 10             	add    $0x10,%esp
f01040bb:	89 c2                	mov    %eax,%edx
f01040bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01040c0:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01040c2:	83 ec 0c             	sub    $0xc,%esp
f01040c5:	68 70 d9 f5 f0       	push   $0xf0f5d970
f01040ca:	e8 26 c0 00 00       	call   f01100f5 <release_spinlock>
f01040cf:	83 c4 10             	add    $0x10,%esp

	return ret;
f01040d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01040d5:	c9                   	leave  
f01040d6:	c3                   	ret    

f01040d7 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f01040d7:	55                   	push   %ebp
f01040d8:	89 e5                	mov    %esp,%ebp
f01040da:	53                   	push   %ebx
f01040db:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f01040de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01040e2:	0f 84 ea 00 00 00    	je     f01041d2 <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f01040e8:	83 ec 0c             	sub    $0xc,%esp
f01040eb:	68 70 d9 f5 f0       	push   $0xf0f5d970
f01040f0:	e8 79 bf 00 00       	call   f011006e <acquire_spinlock>
f01040f5:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f01040f8:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f01040fe:	8b 55 08             	mov    0x8(%ebp),%edx
f0104101:	89 d0                	mov    %edx,%eax
f0104103:	01 c0                	add    %eax,%eax
f0104105:	01 d0                	add    %edx,%eax
f0104107:	c1 e0 03             	shl    $0x3,%eax
f010410a:	01 c8                	add    %ecx,%eax
f010410c:	85 c0                	test   %eax,%eax
f010410e:	75 17                	jne    f0104127 <free_disk_frame+0x50>
f0104110:	83 ec 04             	sub    $0x4,%esp
f0104113:	68 94 55 12 f0       	push   $0xf0125594
f0104118:	68 8e 00 00 00       	push   $0x8e
f010411d:	68 77 55 12 f0       	push   $0xf0125577
f0104122:	e8 12 c2 ff ff       	call   f0100339 <_panic>
f0104127:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f010412d:	8b 55 08             	mov    0x8(%ebp),%edx
f0104130:	89 d0                	mov    %edx,%eax
f0104132:	01 c0                	add    %eax,%eax
f0104134:	01 d0                	add    %edx,%eax
f0104136:	c1 e0 03             	shl    $0x3,%eax
f0104139:	01 c8                	add    %ecx,%eax
f010413b:	8b 15 60 d9 f5 f0    	mov    0xf0f5d960,%edx
f0104141:	89 10                	mov    %edx,(%eax)
f0104143:	8b 00                	mov    (%eax),%eax
f0104145:	85 c0                	test   %eax,%eax
f0104147:	74 1f                	je     f0104168 <free_disk_frame+0x91>
f0104149:	8b 15 60 d9 f5 f0    	mov    0xf0f5d960,%edx
f010414f:	8b 1d e0 cf 75 f0    	mov    0xf075cfe0,%ebx
f0104155:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0104158:	89 c8                	mov    %ecx,%eax
f010415a:	01 c0                	add    %eax,%eax
f010415c:	01 c8                	add    %ecx,%eax
f010415e:	c1 e0 03             	shl    $0x3,%eax
f0104161:	01 d8                	add    %ebx,%eax
f0104163:	89 42 04             	mov    %eax,0x4(%edx)
f0104166:	eb 19                	jmp    f0104181 <free_disk_frame+0xaa>
f0104168:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f010416e:	8b 55 08             	mov    0x8(%ebp),%edx
f0104171:	89 d0                	mov    %edx,%eax
f0104173:	01 c0                	add    %eax,%eax
f0104175:	01 d0                	add    %edx,%eax
f0104177:	c1 e0 03             	shl    $0x3,%eax
f010417a:	01 c8                	add    %ecx,%eax
f010417c:	a3 64 d9 f5 f0       	mov    %eax,0xf0f5d964
f0104181:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f0104187:	8b 55 08             	mov    0x8(%ebp),%edx
f010418a:	89 d0                	mov    %edx,%eax
f010418c:	01 c0                	add    %eax,%eax
f010418e:	01 d0                	add    %edx,%eax
f0104190:	c1 e0 03             	shl    $0x3,%eax
f0104193:	01 c8                	add    %ecx,%eax
f0104195:	a3 60 d9 f5 f0       	mov    %eax,0xf0f5d960
f010419a:	8b 0d e0 cf 75 f0    	mov    0xf075cfe0,%ecx
f01041a0:	8b 55 08             	mov    0x8(%ebp),%edx
f01041a3:	89 d0                	mov    %edx,%eax
f01041a5:	01 c0                	add    %eax,%eax
f01041a7:	01 d0                	add    %edx,%eax
f01041a9:	c1 e0 03             	shl    $0x3,%eax
f01041ac:	01 c8                	add    %ecx,%eax
f01041ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01041b5:	a1 6c d9 f5 f0       	mov    0xf0f5d96c,%eax
f01041ba:	40                   	inc    %eax
f01041bb:	a3 6c d9 f5 f0       	mov    %eax,0xf0f5d96c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01041c0:	83 ec 0c             	sub    $0xc,%esp
f01041c3:	68 70 d9 f5 f0       	push   $0xf0f5d970
f01041c8:	e8 28 bf 00 00       	call   f01100f5 <release_spinlock>
f01041cd:	83 c4 10             	add    $0x10,%esp
f01041d0:	eb 01                	jmp    f01041d3 <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f01041d2:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f01041d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01041d6:	c9                   	leave  
f01041d7:	c3                   	ret    

f01041d8 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f01041d8:	55                   	push   %ebp
f01041d9:	89 e5                	mov    %esp,%ebp
f01041db:	53                   	push   %ebx
f01041dc:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f01041df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01041e2:	c1 e8 16             	shr    $0x16,%eax
f01041e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01041ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01041ef:	01 d0                	add    %edx,%eax
f01041f1:	8b 00                	mov    (%eax),%eax
f01041f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01041f6:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01041fd:	77 1d                	ja     f010421c <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f01041ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104202:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104207:	83 ec 0c             	sub    $0xc,%esp
f010420a:	50                   	push   %eax
f010420b:	e8 02 5a 00 00       	call   f0109c12 <kheap_virtual_address>
f0104210:	83 c4 10             	add    $0x10,%esp
f0104213:	89 c2                	mov    %eax,%edx
f0104215:	8b 45 14             	mov    0x14(%ebp),%eax
f0104218:	89 10                	mov    %edx,(%eax)
f010421a:	eb 44                	jmp    f0104260 <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f010421c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010421f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104224:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104227:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010422a:	c1 e8 0c             	shr    $0xc,%eax
f010422d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0104230:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0104235:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104238:	72 17                	jb     f0104251 <get_disk_page_table+0x79>
f010423a:	ff 75 f0             	pushl  -0x10(%ebp)
f010423d:	68 d8 55 12 f0       	push   $0xf01255d8
f0104242:	68 9d 00 00 00       	push   $0x9d
f0104247:	68 77 55 12 f0       	push   $0xf0125577
f010424c:	e8 e8 c0 ff ff       	call   f0100339 <_panic>
f0104251:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104254:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104259:	89 c2                	mov    %eax,%edx
f010425b:	8b 45 14             	mov    0x14(%ebp),%eax
f010425e:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0104260:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104264:	0f 85 80 00 00 00    	jne    f01042ea <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010426a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010426e:	74 6a                	je     f01042da <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f0104270:	83 ec 0c             	sub    $0xc,%esp
f0104273:	68 00 10 00 00       	push   $0x1000
f0104278:	e8 52 55 00 00       	call   f01097cf <kmalloc>
f010427d:	83 c4 10             	add    $0x10,%esp
f0104280:	89 c2                	mov    %eax,%edx
f0104282:	8b 45 14             	mov    0x14(%ebp),%eax
f0104285:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104287:	8b 45 14             	mov    0x14(%ebp),%eax
f010428a:	8b 00                	mov    (%eax),%eax
f010428c:	85 c0                	test   %eax,%eax
f010428e:	75 07                	jne    f0104297 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f0104290:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104295:	eb 58                	jmp    f01042ef <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f0104297:	8b 45 0c             	mov    0xc(%ebp),%eax
f010429a:	c1 e8 16             	shr    $0x16,%eax
f010429d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01042a7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01042aa:	8b 45 14             	mov    0x14(%ebp),%eax
f01042ad:	8b 00                	mov    (%eax),%eax
f01042af:	83 ec 0c             	sub    $0xc,%esp
f01042b2:	50                   	push   %eax
f01042b3:	e8 fd 58 00 00       	call   f0109bb5 <kheap_physical_address>
f01042b8:	83 c4 10             	add    $0x10,%esp
f01042bb:	83 c8 01             	or     $0x1,%eax
f01042be:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01042c0:	8b 45 14             	mov    0x14(%ebp),%eax
f01042c3:	8b 00                	mov    (%eax),%eax
f01042c5:	83 ec 04             	sub    $0x4,%esp
f01042c8:	68 00 10 00 00       	push   $0x1000
f01042cd:	6a 00                	push   $0x0
f01042cf:	50                   	push   %eax
f01042d0:	e8 35 bf 01 00       	call   f012020a <memset>
f01042d5:	83 c4 10             	add    $0x10,%esp
f01042d8:	eb 10                	jmp    f01042ea <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01042da:	8b 45 14             	mov    0x14(%ebp),%eax
f01042dd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01042e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01042e8:	eb 05                	jmp    f01042ef <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01042ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01042ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01042f2:	c9                   	leave  
f01042f3:	c3                   	ret    

f01042f4 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f01042f4:	55                   	push   %ebp
f01042f5:	89 e5                	mov    %esp,%ebp
f01042f7:	83 ec 28             	sub    $0x28,%esp
f01042fa:	8b 45 10             	mov    0x10(%ebp),%eax
f01042fd:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0104300:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104304:	74 72                	je     f0104378 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104306:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f010430d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104310:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104315:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104318:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010431b:	ba 00 00 00 00       	mov    $0x0,%edx
f0104320:	f7 75 f4             	divl   -0xc(%ebp)
f0104323:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104326:	29 d0                	sub    %edx,%eax
f0104328:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010432b:	73 2f                	jae    f010435c <pf_add_empty_env_page+0x68>
f010432d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104330:	8b 50 6c             	mov    0x6c(%eax),%edx
f0104333:	b8 00 00 00 00       	mov    $0x0,%eax
f0104338:	29 d0                	sub    %edx,%eax
f010433a:	c1 e0 0c             	shl    $0xc,%eax
f010433d:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0104342:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104345:	76 15                	jbe    f010435c <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104347:	8b 45 08             	mov    0x8(%ebp),%eax
f010434a:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104350:	8d 50 01             	lea    0x1(%eax),%edx
f0104353:	8b 45 08             	mov    0x8(%ebp),%eax
f0104356:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f010435c:	a1 bc d7 b5 f0       	mov    0xf0b5d7bc,%eax
f0104361:	83 ec 04             	sub    $0x4,%esp
f0104364:	50                   	push   %eax
f0104365:	ff 75 0c             	pushl  0xc(%ebp)
f0104368:	ff 75 08             	pushl  0x8(%ebp)
f010436b:	e8 b5 00 00 00       	call   f0104425 <pf_add_env_page>
f0104370:	83 c4 10             	add    $0x10,%esp
f0104373:	e9 ab 00 00 00       	jmp    f0104423 <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104378:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010437f:	76 19                	jbe    f010439a <pf_add_empty_env_page+0xa6>
f0104381:	68 08 56 12 f0       	push   $0xf0125608
f0104386:	68 2e 56 12 f0       	push   $0xf012562e
f010438b:	68 dc 00 00 00       	push   $0xdc
f0104390:	68 77 55 12 f0       	push   $0xf0125577
f0104395:	e8 9f bf ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010439a:	8b 45 08             	mov    0x8(%ebp),%eax
f010439d:	83 e8 80             	sub    $0xffffff80,%eax
f01043a0:	83 ec 08             	sub    $0x8,%esp
f01043a3:	50                   	push   %eax
f01043a4:	ff 75 08             	pushl  0x8(%ebp)
f01043a7:	e8 c2 05 00 00       	call   f010496e <get_disk_page_directory>
f01043ac:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01043af:	8b 45 08             	mov    0x8(%ebp),%eax
f01043b2:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01043b8:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01043bb:	52                   	push   %edx
f01043bc:	6a 01                	push   $0x1
f01043be:	ff 75 0c             	pushl  0xc(%ebp)
f01043c1:	50                   	push   %eax
f01043c2:	e8 11 fe ff ff       	call   f01041d8 <get_disk_page_table>
f01043c7:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01043ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043cd:	8b 55 0c             	mov    0xc(%ebp),%edx
f01043d0:	c1 ea 0c             	shr    $0xc,%edx
f01043d3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01043d9:	c1 e2 02             	shl    $0x2,%edx
f01043dc:	01 d0                	add    %edx,%eax
f01043de:	8b 00                	mov    (%eax),%eax
f01043e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01043e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01043e6:	85 c0                	test   %eax,%eax
f01043e8:	75 34                	jne    f010441e <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01043ea:	83 ec 0c             	sub    $0xc,%esp
f01043ed:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01043f0:	50                   	push   %eax
f01043f1:	e8 f3 fb ff ff       	call   f0103fe9 <allocate_disk_frame>
f01043f6:	83 c4 10             	add    $0x10,%esp
f01043f9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01043fc:	75 07                	jne    f0104405 <pf_add_empty_env_page+0x111>
f01043fe:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104403:	eb 1e                	jmp    f0104423 <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104405:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104408:	8b 55 0c             	mov    0xc(%ebp),%edx
f010440b:	c1 ea 0c             	shr    $0xc,%edx
f010440e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104414:	c1 e2 02             	shl    $0x2,%edx
f0104417:	01 c2                	add    %eax,%edx
f0104419:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010441c:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010441e:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0104423:	c9                   	leave  
f0104424:	c3                   	ret    

f0104425 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104425:	55                   	push   %ebp
f0104426:	89 e5                	mov    %esp,%ebp
f0104428:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010442b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104432:	76 19                	jbe    f010444d <pf_add_env_page+0x28>
f0104434:	68 08 56 12 f0       	push   $0xf0125608
f0104439:	68 2e 56 12 f0       	push   $0xf012562e
f010443e:	68 f1 00 00 00       	push   $0xf1
f0104443:	68 77 55 12 f0       	push   $0xf0125577
f0104448:	e8 ec be ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010444d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104450:	83 e8 80             	sub    $0xffffff80,%eax
f0104453:	83 ec 08             	sub    $0x8,%esp
f0104456:	50                   	push   %eax
f0104457:	ff 75 08             	pushl  0x8(%ebp)
f010445a:	e8 0f 05 00 00       	call   f010496e <get_disk_page_directory>
f010445f:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0104462:	8b 45 08             	mov    0x8(%ebp),%eax
f0104465:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010446b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010446e:	52                   	push   %edx
f010446f:	6a 01                	push   $0x1
f0104471:	ff 75 0c             	pushl  0xc(%ebp)
f0104474:	50                   	push   %eax
f0104475:	e8 5e fd ff ff       	call   f01041d8 <get_disk_page_table>
f010447a:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010447d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104480:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104483:	c1 ea 0c             	shr    $0xc,%edx
f0104486:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010448c:	c1 e2 02             	shl    $0x2,%edx
f010448f:	01 d0                	add    %edx,%eax
f0104491:	8b 00                	mov    (%eax),%eax
f0104493:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0104496:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104499:	85 c0                	test   %eax,%eax
f010449b:	75 34                	jne    f01044d1 <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010449d:	83 ec 0c             	sub    $0xc,%esp
f01044a0:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01044a3:	50                   	push   %eax
f01044a4:	e8 40 fb ff ff       	call   f0103fe9 <allocate_disk_frame>
f01044a9:	83 c4 10             	add    $0x10,%esp
f01044ac:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01044af:	75 07                	jne    f01044b8 <pf_add_env_page+0x93>
f01044b1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01044b6:	eb 31                	jmp    f01044e9 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01044b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044bb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044be:	c1 ea 0c             	shr    $0xc,%edx
f01044c1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044c7:	c1 e2 02             	shl    $0x2,%edx
f01044ca:	01 c2                	add    %eax,%edx
f01044cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044cf:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01044d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044d4:	83 ec 08             	sub    $0x8,%esp
f01044d7:	ff 75 10             	pushl  0x10(%ebp)
f01044da:	50                   	push   %eax
f01044db:	e8 5c f9 ff ff       	call   f0103e3c <write_disk_page>
f01044e0:	83 c4 10             	add    $0x10,%esp
f01044e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01044e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01044e9:	c9                   	leave  
f01044ea:	c3                   	ret    

f01044eb <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01044eb:	55                   	push   %ebp
f01044ec:	89 e5                	mov    %esp,%ebp
f01044ee:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01044f1:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01044f8:	76 19                	jbe    f0104513 <pf_update_env_page+0x28>
f01044fa:	68 08 56 12 f0       	push   $0xf0125608
f01044ff:	68 2e 56 12 f0       	push   $0xf012562e
f0104504:	68 13 01 00 00       	push   $0x113
f0104509:	68 77 55 12 f0       	push   $0xf0125577
f010450e:	e8 26 be ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104513:	8b 45 08             	mov    0x8(%ebp),%eax
f0104516:	83 e8 80             	sub    $0xffffff80,%eax
f0104519:	83 ec 08             	sub    $0x8,%esp
f010451c:	50                   	push   %eax
f010451d:	ff 75 08             	pushl  0x8(%ebp)
f0104520:	e8 49 04 00 00       	call   f010496e <get_disk_page_directory>
f0104525:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104528:	8b 45 08             	mov    0x8(%ebp),%eax
f010452b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104531:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104534:	52                   	push   %edx
f0104535:	6a 00                	push   $0x0
f0104537:	ff 75 0c             	pushl  0xc(%ebp)
f010453a:	50                   	push   %eax
f010453b:	e8 98 fc ff ff       	call   f01041d8 <get_disk_page_table>
f0104540:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104543:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104546:	85 c0                	test   %eax,%eax
f0104548:	74 29                	je     f0104573 <pf_update_env_page+0x88>
f010454a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010454d:	85 c0                	test   %eax,%eax
f010454f:	0f 84 bf 00 00 00    	je     f0104614 <pf_update_env_page+0x129>
f0104555:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104558:	8b 55 0c             	mov    0xc(%ebp),%edx
f010455b:	c1 ea 0c             	shr    $0xc,%edx
f010455e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104564:	c1 e2 02             	shl    $0x2,%edx
f0104567:	01 d0                	add    %edx,%eax
f0104569:	8b 00                	mov    (%eax),%eax
f010456b:	85 c0                	test   %eax,%eax
f010456d:	0f 85 a1 00 00 00    	jne    f0104614 <pf_update_env_page+0x129>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0104573:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104576:	85 c0                	test   %eax,%eax
f0104578:	79 09                	jns    f0104583 <pf_update_env_page+0x98>
f010457a:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f0104581:	76 30                	jbe    f01045b3 <pf_update_env_page+0xc8>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f0104583:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f010458a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010458d:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104592:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104595:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104598:	ba 00 00 00 00       	mov    $0x0,%edx
f010459d:	f7 75 f4             	divl   -0xc(%ebp)
f01045a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045a3:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f01045a5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01045a8:	77 53                	ja     f01045fd <pf_update_env_page+0x112>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f01045aa:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f01045b1:	77 4a                	ja     f01045fd <pf_update_env_page+0x112>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f01045b3:	83 ec 04             	sub    $0x4,%esp
f01045b6:	6a 00                	push   $0x0
f01045b8:	ff 75 0c             	pushl  0xc(%ebp)
f01045bb:	ff 75 08             	pushl  0x8(%ebp)
f01045be:	e8 31 fd ff ff       	call   f01042f4 <pf_add_empty_env_page>
f01045c3:	83 c4 10             	add    $0x10,%esp
f01045c6:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01045c9:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f01045cd:	75 17                	jne    f01045e6 <pf_update_env_page+0xfb>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01045cf:	83 ec 04             	sub    $0x4,%esp
f01045d2:	68 44 56 12 f0       	push   $0xf0125644
f01045d7:	68 43 01 00 00       	push   $0x143
f01045dc:	68 77 55 12 f0       	push   $0xf0125577
f01045e1:	e8 53 bd ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01045e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01045e9:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f01045ef:	8d 50 01             	lea    0x1(%eax),%edx
f01045f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01045f5:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f01045fb:	eb 17                	jmp    f0104614 <pf_update_env_page+0x129>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01045fd:	83 ec 04             	sub    $0x4,%esp
f0104600:	68 90 56 12 f0       	push   $0xf0125690
f0104605:	68 4c 01 00 00       	push   $0x14c
f010460a:	68 77 55 12 f0       	push   $0xf0125577
f010460f:	e8 25 bd ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104614:	8b 45 08             	mov    0x8(%ebp),%eax
f0104617:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010461d:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104620:	52                   	push   %edx
f0104621:	6a 00                	push   $0x0
f0104623:	ff 75 0c             	pushl  0xc(%ebp)
f0104626:	50                   	push   %eax
f0104627:	e8 ac fb ff ff       	call   f01041d8 <get_disk_page_table>
f010462c:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010462f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104632:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104635:	c1 ea 0c             	shr    $0xc,%edx
f0104638:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010463e:	c1 e2 02             	shl    $0x2,%edx
f0104641:	01 d0                	add    %edx,%eax
f0104643:	8b 00                	mov    (%eax),%eax
f0104645:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'24 (el7): due to concurrency issues in 1-1 thread model, using the USER_LIMIT as a temp loc
		//				will lead to concurrency problems since it's shared among processes.
		//				Instead, use PGFLTEMP as a local temporarily page at user space for this mapping
		//				to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (uint32)PGFLTEMP, 0);
f0104648:	8b 45 08             	mov    0x8(%ebp),%eax
f010464b:	8b 40 64             	mov    0x64(%eax),%eax
f010464e:	6a 00                	push   $0x0
f0104650:	68 00 f0 3f 00       	push   $0x3ff000
f0104655:	ff 75 10             	pushl  0x10(%ebp)
f0104658:	50                   	push   %eax
f0104659:	e8 4c 43 00 00       	call   f01089aa <map_frame>
f010465e:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN((uint32)PGFLTEMP, PAGE_SIZE));
f0104661:	c7 45 e4 00 f0 3f 00 	movl   $0x3ff000,-0x1c(%ebp)
f0104668:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010466b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104670:	83 ec 08             	sub    $0x8,%esp
f0104673:	50                   	push   %eax
f0104674:	ff 75 e8             	pushl  -0x18(%ebp)
f0104677:	e8 c0 f7 ff ff       	call   f0103e3c <write_disk_page>
f010467c:	83 c4 10             	add    $0x10,%esp
f010467f:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104682:	8b 45 10             	mov    0x10(%ebp),%eax
f0104685:	8b 40 08             	mov    0x8(%eax),%eax
f0104688:	40                   	inc    %eax
f0104689:	8b 55 10             	mov    0x10(%ebp),%edx
f010468c:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (uint32)PGFLTEMP);
f0104690:	8b 45 08             	mov    0x8(%ebp),%eax
f0104693:	8b 40 64             	mov    0x64(%eax),%eax
f0104696:	83 ec 08             	sub    $0x8,%esp
f0104699:	68 00 f0 3f 00       	push   $0x3ff000
f010469e:	50                   	push   %eax
f010469f:	e8 66 44 00 00       	call   f0108b0a <unmap_frame>
f01046a4:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01046a7:	8b 45 10             	mov    0x10(%ebp),%eax
f01046aa:	8b 40 08             	mov    0x8(%eax),%eax
f01046ad:	48                   	dec    %eax
f01046ae:	8b 55 10             	mov    0x10(%ebp),%edx
f01046b1:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01046b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01046b8:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01046be:	8d 50 01             	lea    0x1(%eax),%edx
f01046c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01046c4:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01046ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01046cd:	c9                   	leave  
f01046ce:	c3                   	ret    

f01046cf <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01046cf:	55                   	push   %ebp
f01046d0:	89 e5                	mov    %esp,%ebp
f01046d2:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01046d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01046d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01046db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01046de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01046e3:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01046e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01046e9:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046ef:	85 c0                	test   %eax,%eax
f01046f1:	75 0a                	jne    f01046fd <pf_read_env_page+0x2e>
f01046f3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01046f8:	e9 93 00 00 00       	jmp    f0104790 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01046fd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104700:	8b 45 08             	mov    0x8(%ebp),%eax
f0104703:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104709:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010470c:	51                   	push   %ecx
f010470d:	6a 00                	push   $0x0
f010470f:	52                   	push   %edx
f0104710:	50                   	push   %eax
f0104711:	e8 c2 fa ff ff       	call   f01041d8 <get_disk_page_table>
f0104716:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104719:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010471c:	85 c0                	test   %eax,%eax
f010471e:	75 07                	jne    f0104727 <pf_read_env_page+0x58>
f0104720:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104725:	eb 69                	jmp    f0104790 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104727:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010472a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010472d:	c1 ea 0c             	shr    $0xc,%edx
f0104730:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104736:	c1 e2 02             	shl    $0x2,%edx
f0104739:	01 d0                	add    %edx,%eax
f010473b:	8b 00                	mov    (%eax),%eax
f010473d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104740:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104744:	75 07                	jne    f010474d <pf_read_env_page+0x7e>
f0104746:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010474b:	eb 43                	jmp    f0104790 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010474d:	83 ec 08             	sub    $0x8,%esp
f0104750:	ff 75 0c             	pushl  0xc(%ebp)
f0104753:	ff 75 f0             	pushl  -0x10(%ebp)
f0104756:	e8 b2 f6 ff ff       	call   f0103e0d <read_disk_page>
f010475b:	83 c4 10             	add    $0x10,%esp
f010475e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104761:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104764:	8b 45 08             	mov    0x8(%ebp),%eax
f0104767:	8b 40 64             	mov    0x64(%eax),%eax
f010476a:	6a 40                	push   $0x40
f010476c:	6a 00                	push   $0x0
f010476e:	52                   	push   %edx
f010476f:	50                   	push   %eax
f0104770:	e8 34 58 00 00       	call   f0109fa9 <pt_set_page_permissions>
f0104775:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f0104778:	8b 45 08             	mov    0x8(%ebp),%eax
f010477b:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104781:	8d 50 01             	lea    0x1(%eax),%edx
f0104784:	8b 45 08             	mov    0x8(%ebp),%eax
f0104787:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010478d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104790:	c9                   	leave  
f0104791:	c3                   	ret    

f0104792 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104792:	55                   	push   %ebp
f0104793:	89 e5                	mov    %esp,%ebp
f0104795:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104798:	8b 45 08             	mov    0x8(%ebp),%eax
f010479b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047a1:	85 c0                	test   %eax,%eax
f01047a3:	74 65                	je     f010480a <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01047a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a8:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047ae:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01047b1:	52                   	push   %edx
f01047b2:	6a 00                	push   $0x0
f01047b4:	ff 75 0c             	pushl  0xc(%ebp)
f01047b7:	50                   	push   %eax
f01047b8:	e8 1b fa ff ff       	call   f01041d8 <get_disk_page_table>
f01047bd:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01047c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047c3:	85 c0                	test   %eax,%eax
f01047c5:	74 46                	je     f010480d <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01047c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047ca:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047cd:	c1 ea 0c             	shr    $0xc,%edx
f01047d0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01047d6:	c1 e2 02             	shl    $0x2,%edx
f01047d9:	01 d0                	add    %edx,%eax
f01047db:	8b 00                	mov    (%eax),%eax
f01047dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01047e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047e3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047e6:	c1 ea 0c             	shr    $0xc,%edx
f01047e9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01047ef:	c1 e2 02             	shl    $0x2,%edx
f01047f2:	01 d0                	add    %edx,%eax
f01047f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01047fa:	83 ec 0c             	sub    $0xc,%esp
f01047fd:	ff 75 f4             	pushl  -0xc(%ebp)
f0104800:	e8 d2 f8 ff ff       	call   f01040d7 <free_disk_frame>
f0104805:	83 c4 10             	add    $0x10,%esp
f0104808:	eb 04                	jmp    f010480e <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010480a:	90                   	nop
f010480b:	eb 01                	jmp    f010480e <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010480d:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f010480e:	c9                   	leave  
f010480f:	c3                   	ret    

f0104810 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104810:	55                   	push   %ebp
f0104811:	89 e5                	mov    %esp,%ebp
f0104813:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104816:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010481d:	e9 c1 00 00 00       	jmp    f01048e3 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104822:	8b 45 08             	mov    0x8(%ebp),%eax
f0104825:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010482b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010482e:	c1 e2 02             	shl    $0x2,%edx
f0104831:	01 d0                	add    %edx,%eax
f0104833:	8b 00                	mov    (%eax),%eax
f0104835:	83 e0 01             	and    $0x1,%eax
f0104838:	85 c0                	test   %eax,%eax
f010483a:	0f 84 9f 00 00 00    	je     f01048df <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104840:	8b 45 08             	mov    0x8(%ebp),%eax
f0104843:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104849:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010484c:	c1 e2 02             	shl    $0x2,%edx
f010484f:	01 d0                	add    %edx,%eax
f0104851:	8b 00                	mov    (%eax),%eax
f0104853:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104858:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010485b:	83 ec 0c             	sub    $0xc,%esp
f010485e:	ff 75 ec             	pushl  -0x14(%ebp)
f0104861:	e8 ac 53 00 00       	call   f0109c12 <kheap_virtual_address>
f0104866:	83 c4 10             	add    $0x10,%esp
f0104869:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010486c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104873:	eb 3a                	jmp    f01048af <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104875:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104878:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010487f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104882:	01 d0                	add    %edx,%eax
f0104884:	8b 00                	mov    (%eax),%eax
f0104886:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f0104889:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010488c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104893:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104896:	01 d0                	add    %edx,%eax
f0104898:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f010489e:	83 ec 0c             	sub    $0xc,%esp
f01048a1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01048a4:	e8 2e f8 ff ff       	call   f01040d7 <free_disk_frame>
f01048a9:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01048ac:	ff 45 f0             	incl   -0x10(%ebp)
f01048af:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01048b6:	76 bd                	jbe    f0104875 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01048b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01048bb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01048c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01048c4:	c1 e2 02             	shl    $0x2,%edx
f01048c7:	01 d0                	add    %edx,%eax
f01048c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01048cf:	83 ec 0c             	sub    $0xc,%esp
f01048d2:	ff 75 e8             	pushl  -0x18(%ebp)
f01048d5:	e8 b5 51 00 00       	call   f0109a8f <kfree>
f01048da:	83 c4 10             	add    $0x10,%esp
f01048dd:	eb 01                	jmp    f01048e0 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01048df:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01048e0:	ff 45 f4             	incl   -0xc(%ebp)
f01048e3:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01048ea:	0f 86 32 ff ff ff    	jbe    f0104822 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01048f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01048f3:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01048f9:	83 ec 0c             	sub    $0xc,%esp
f01048fc:	50                   	push   %eax
f01048fd:	e8 8d 51 00 00       	call   f0109a8f <kfree>
f0104902:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104905:	8b 45 08             	mov    0x8(%ebp),%eax
f0104908:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010490f:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104912:	8b 45 08             	mov    0x8(%ebp),%eax
f0104915:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010491c:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f010491f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104922:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104928:	85 c0                	test   %eax,%eax
f010492a:	74 3f                	je     f010496b <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010492c:	83 ec 0c             	sub    $0xc,%esp
f010492f:	ff 75 08             	pushl  0x8(%ebp)
f0104932:	e8 14 03 00 00       	call   f0104c4b <__pf_remove_env_all_tables>
f0104937:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010493a:	8b 45 08             	mov    0x8(%ebp),%eax
f010493d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104943:	83 ec 0c             	sub    $0xc,%esp
f0104946:	50                   	push   %eax
f0104947:	e8 43 51 00 00       	call   f0109a8f <kfree>
f010494c:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f010494f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104952:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f0104959:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010495c:	8b 45 08             	mov    0x8(%ebp),%eax
f010495f:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104966:	00 00 00 
f0104969:	eb 01                	jmp    f010496c <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010496b:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010496c:	c9                   	leave  
f010496d:	c3                   	ret    

f010496e <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f010496e:	55                   	push   %ebp
f010496f:	89 e5                	mov    %esp,%ebp
f0104971:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104974:	8b 45 08             	mov    0x8(%ebp),%eax
f0104977:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010497d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104980:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104982:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104985:	8b 00                	mov    (%eax),%eax
f0104987:	85 c0                	test   %eax,%eax
f0104989:	75 5b                	jne    f01049e6 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010498b:	83 ec 0c             	sub    $0xc,%esp
f010498e:	68 00 10 00 00       	push   $0x1000
f0104993:	e8 37 4e 00 00       	call   f01097cf <kmalloc>
f0104998:	83 c4 10             	add    $0x10,%esp
f010499b:	89 c2                	mov    %eax,%edx
f010499d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049a0:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01049a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049a5:	8b 00                	mov    (%eax),%eax
f01049a7:	85 c0                	test   %eax,%eax
f01049a9:	75 07                	jne    f01049b2 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01049ab:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01049b0:	eb 39                	jmp    f01049eb <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01049b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049b5:	8b 00                	mov    (%eax),%eax
f01049b7:	83 ec 0c             	sub    $0xc,%esp
f01049ba:	50                   	push   %eax
f01049bb:	e8 f5 51 00 00       	call   f0109bb5 <kheap_physical_address>
f01049c0:	83 c4 10             	add    $0x10,%esp
f01049c3:	89 c2                	mov    %eax,%edx
f01049c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01049c8:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01049ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049d1:	8b 00                	mov    (%eax),%eax
f01049d3:	83 ec 04             	sub    $0x4,%esp
f01049d6:	68 00 10 00 00       	push   $0x1000
f01049db:	6a 00                	push   $0x0
f01049dd:	50                   	push   %eax
f01049de:	e8 27 b8 01 00       	call   f012020a <memset>
f01049e3:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01049e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049eb:	c9                   	leave  
f01049ec:	c3                   	ret    

f01049ed <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01049ed:	55                   	push   %ebp
f01049ee:	89 e5                	mov    %esp,%ebp
f01049f0:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f01049f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f01049fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a01:	eb 7e                	jmp    f0104a81 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104a03:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a06:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a0f:	c1 e2 02             	shl    $0x2,%edx
f0104a12:	01 d0                	add    %edx,%eax
f0104a14:	8b 00                	mov    (%eax),%eax
f0104a16:	83 e0 01             	and    $0x1,%eax
f0104a19:	85 c0                	test   %eax,%eax
f0104a1b:	74 60                	je     f0104a7d <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f0104a1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a20:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a26:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a29:	c1 e2 02             	shl    $0x2,%edx
f0104a2c:	01 d0                	add    %edx,%eax
f0104a2e:	8b 00                	mov    (%eax),%eax
f0104a30:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104a35:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0104a38:	83 ec 0c             	sub    $0xc,%esp
f0104a3b:	ff 75 e8             	pushl  -0x18(%ebp)
f0104a3e:	e8 cf 51 00 00       	call   f0109c12 <kheap_virtual_address>
f0104a43:	83 c4 10             	add    $0x10,%esp
f0104a46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104a50:	eb 20                	jmp    f0104a72 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104a52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104a55:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104a5f:	01 d0                	add    %edx,%eax
f0104a61:	8b 00                	mov    (%eax),%eax
f0104a63:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104a66:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0104a6a:	74 03                	je     f0104a6f <pf_calculate_allocated_pages+0x82>
				counter ++;
f0104a6c:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a6f:	ff 45 ec             	incl   -0x14(%ebp)
f0104a72:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0104a79:	76 d7                	jbe    f0104a52 <pf_calculate_allocated_pages+0x65>
f0104a7b:	eb 01                	jmp    f0104a7e <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0104a7d:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104a7e:	ff 45 f4             	incl   -0xc(%ebp)
f0104a81:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104a88:	0f 86 75 ff ff ff    	jbe    f0104a03 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104a8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a91:	c9                   	leave  
f0104a92:	c3                   	ret    

f0104a93 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104a93:	55                   	push   %ebp
f0104a94:	89 e5                	mov    %esp,%ebp
f0104a96:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104a99:	83 ec 0c             	sub    $0xc,%esp
f0104a9c:	68 70 d9 f5 f0       	push   $0xf0f5d970
f0104aa1:	e8 c8 b5 00 00       	call   f011006e <acquire_spinlock>
f0104aa6:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0104aa9:	a1 6c d9 f5 f0       	mov    0xf0f5d96c,%eax
f0104aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104ab1:	83 ec 0c             	sub    $0xc,%esp
f0104ab4:	68 70 d9 f5 f0       	push   $0xf0f5d970
f0104ab9:	e8 37 b6 00 00       	call   f01100f5 <release_spinlock>
f0104abe:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104ac4:	c9                   	leave  
f0104ac5:	c3                   	ret    

f0104ac6 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104ac6:	55                   	push   %ebp
f0104ac7:	89 e5                	mov    %esp,%ebp
f0104ac9:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0104acc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104acf:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f0104ad5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ad8:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0104ada:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104add:	8b 00                	mov    (%eax),%eax
f0104adf:	85 c0                	test   %eax,%eax
f0104ae1:	75 5b                	jne    f0104b3e <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0104ae3:	83 ec 0c             	sub    $0xc,%esp
f0104ae6:	68 00 10 00 00       	push   $0x1000
f0104aeb:	e8 df 4c 00 00       	call   f01097cf <kmalloc>
f0104af0:	83 c4 10             	add    $0x10,%esp
f0104af3:	89 c2                	mov    %eax,%edx
f0104af5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104af8:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f0104afa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104afd:	8b 00                	mov    (%eax),%eax
f0104aff:	85 c0                	test   %eax,%eax
f0104b01:	75 07                	jne    f0104b0a <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104b03:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104b08:	eb 39                	jmp    f0104b43 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f0104b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b0d:	8b 00                	mov    (%eax),%eax
f0104b0f:	83 ec 0c             	sub    $0xc,%esp
f0104b12:	50                   	push   %eax
f0104b13:	e8 9d 50 00 00       	call   f0109bb5 <kheap_physical_address>
f0104b18:	83 c4 10             	add    $0x10,%esp
f0104b1b:	89 c2                	mov    %eax,%edx
f0104b1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b20:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104b26:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b29:	8b 00                	mov    (%eax),%eax
f0104b2b:	83 ec 04             	sub    $0x4,%esp
f0104b2e:	68 00 10 00 00       	push   $0x1000
f0104b33:	6a 00                	push   $0x0
f0104b35:	50                   	push   %eax
f0104b36:	e8 cf b6 01 00       	call   f012020a <memset>
f0104b3b:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104b3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b43:	c9                   	leave  
f0104b44:	c3                   	ret    

f0104b45 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104b45:	55                   	push   %ebp
f0104b46:	89 e5                	mov    %esp,%ebp
f0104b48:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f0104b4b:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104b52:	76 19                	jbe    f0104b6d <__pf_write_env_table+0x28>
f0104b54:	68 08 56 12 f0       	push   $0xf0125608
f0104b59:	68 2e 56 12 f0       	push   $0xf012562e
f0104b5e:	68 96 02 00 00       	push   $0x296
f0104b63:	68 77 55 12 f0       	push   $0xf0125577
f0104b68:	e8 cc b7 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0104b6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b70:	05 88 00 00 00       	add    $0x88,%eax
f0104b75:	83 ec 08             	sub    $0x8,%esp
f0104b78:	50                   	push   %eax
f0104b79:	ff 75 08             	pushl  0x8(%ebp)
f0104b7c:	e8 45 ff ff ff       	call   f0104ac6 <get_disk_table_directory>
f0104b81:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104b84:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b87:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b8d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b90:	c1 ea 16             	shr    $0x16,%edx
f0104b93:	c1 e2 02             	shl    $0x2,%edx
f0104b96:	01 d0                	add    %edx,%eax
f0104b98:	8b 00                	mov    (%eax),%eax
f0104b9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104b9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ba0:	85 c0                	test   %eax,%eax
f0104ba2:	75 34                	jne    f0104bd8 <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104ba4:	83 ec 0c             	sub    $0xc,%esp
f0104ba7:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0104baa:	50                   	push   %eax
f0104bab:	e8 39 f4 ff ff       	call   f0103fe9 <allocate_disk_frame>
f0104bb0:	83 c4 10             	add    $0x10,%esp
f0104bb3:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104bb6:	75 07                	jne    f0104bbf <__pf_write_env_table+0x7a>
f0104bb8:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104bbd:	eb 31                	jmp    f0104bf0 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f0104bbf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bc2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104bc8:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104bcb:	c1 ea 16             	shr    $0x16,%edx
f0104bce:	c1 e2 02             	shl    $0x2,%edx
f0104bd1:	01 c2                	add    %eax,%edx
f0104bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bd6:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0104bd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bdb:	83 ec 08             	sub    $0x8,%esp
f0104bde:	ff 75 10             	pushl  0x10(%ebp)
f0104be1:	50                   	push   %eax
f0104be2:	e8 55 f2 ff ff       	call   f0103e3c <write_disk_page>
f0104be7:	83 c4 10             	add    $0x10,%esp
f0104bea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0104bed:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104bf0:	c9                   	leave  
f0104bf1:	c3                   	ret    

f0104bf2 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104bf2:	55                   	push   %ebp
f0104bf3:	89 e5                	mov    %esp,%ebp
f0104bf5:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104bf8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bfb:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c01:	85 c0                	test   %eax,%eax
f0104c03:	75 07                	jne    f0104c0c <__pf_read_env_table+0x1a>
f0104c05:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c0a:	eb 3d                	jmp    f0104c49 <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104c0c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c0f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c15:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104c18:	c1 ea 16             	shr    $0x16,%edx
f0104c1b:	c1 e2 02             	shl    $0x2,%edx
f0104c1e:	01 d0                	add    %edx,%eax
f0104c20:	8b 00                	mov    (%eax),%eax
f0104c22:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104c25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104c29:	75 07                	jne    f0104c32 <__pf_read_env_table+0x40>
f0104c2b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c30:	eb 17                	jmp    f0104c49 <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104c32:	83 ec 08             	sub    $0x8,%esp
f0104c35:	ff 75 10             	pushl  0x10(%ebp)
f0104c38:	ff 75 f4             	pushl  -0xc(%ebp)
f0104c3b:	e8 cd f1 ff ff       	call   f0103e0d <read_disk_page>
f0104c40:	83 c4 10             	add    $0x10,%esp
f0104c43:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104c46:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104c49:	c9                   	leave  
f0104c4a:	c3                   	ret    

f0104c4b <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104c4b:	55                   	push   %ebp
f0104c4c:	89 e5                	mov    %esp,%ebp
f0104c4e:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104c51:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c54:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c5a:	85 c0                	test   %eax,%eax
f0104c5c:	74 52                	je     f0104cb0 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104c5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104c65:	eb 3e                	jmp    f0104ca5 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c6a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c70:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c73:	c1 e2 02             	shl    $0x2,%edx
f0104c76:	01 d0                	add    %edx,%eax
f0104c78:	8b 00                	mov    (%eax),%eax
f0104c7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104c7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c80:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c86:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c89:	c1 e2 02             	shl    $0x2,%edx
f0104c8c:	01 d0                	add    %edx,%eax
f0104c8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104c94:	83 ec 0c             	sub    $0xc,%esp
f0104c97:	ff 75 f0             	pushl  -0x10(%ebp)
f0104c9a:	e8 38 f4 ff ff       	call   f01040d7 <free_disk_frame>
f0104c9f:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ca2:	ff 45 f4             	incl   -0xc(%ebp)
f0104ca5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104cac:	76 b9                	jbe    f0104c67 <__pf_remove_env_all_tables+0x1c>
f0104cae:	eb 01                	jmp    f0104cb1 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104cb0:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104cb1:	c9                   	leave  
f0104cb2:	c3                   	ret    

f0104cb3 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104cb3:	55                   	push   %ebp
f0104cb4:	89 e5                	mov    %esp,%ebp
f0104cb6:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104cb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104cbd:	75 10                	jne    f0104ccf <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104cbf:	83 ec 0c             	sub    $0xc,%esp
f0104cc2:	68 0c 57 12 f0       	push   $0xf012570c
f0104cc7:	e8 bf c2 ff ff       	call   f0100f8b <cprintf>
f0104ccc:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ccf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cd2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cd8:	85 c0                	test   %eax,%eax
f0104cda:	74 43                	je     f0104d1f <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104cdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cdf:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104ce5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ce8:	c1 ea 16             	shr    $0x16,%edx
f0104ceb:	c1 e2 02             	shl    $0x2,%edx
f0104cee:	01 d0                	add    %edx,%eax
f0104cf0:	8b 00                	mov    (%eax),%eax
f0104cf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104cf5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cf8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cfe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104d01:	c1 ea 16             	shr    $0x16,%edx
f0104d04:	c1 e2 02             	shl    $0x2,%edx
f0104d07:	01 d0                	add    %edx,%eax
f0104d09:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104d0f:	83 ec 0c             	sub    $0xc,%esp
f0104d12:	ff 75 f4             	pushl  -0xc(%ebp)
f0104d15:	e8 bd f3 ff ff       	call   f01040d7 <free_disk_frame>
f0104d1a:	83 c4 10             	add    $0x10,%esp
f0104d1d:	eb 01                	jmp    f0104d20 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104d1f:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104d20:	c9                   	leave  
f0104d21:	c3                   	ret    

f0104d22 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104d22:	55                   	push   %ebp
f0104d23:	89 e5                	mov    %esp,%ebp
f0104d25:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104d28:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104d2f:	eb 1f                	jmp    f0104d50 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d34:	83 ec 04             	sub    $0x4,%esp
f0104d37:	6a 08                	push   $0x8
f0104d39:	ff 75 08             	pushl  0x8(%ebp)
f0104d3c:	50                   	push   %eax
f0104d3d:	e8 02 bc 01 00       	call   f0120944 <ide_write>
f0104d42:	83 c4 10             	add    $0x10,%esp
f0104d45:	85 c0                	test   %eax,%eax
f0104d47:	75 12                	jne    f0104d5b <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104d49:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104d50:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104d57:	7e d8                	jle    f0104d31 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d59:	eb 01                	jmp    f0104d5c <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104d5b:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d5c:	90                   	nop
f0104d5d:	c9                   	leave  
f0104d5e:	c3                   	ret    

f0104d5f <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104d5f:	55                   	push   %ebp
  pushl %eax
f0104d60:	50                   	push   %eax
  pushl %ebx
f0104d61:	53                   	push   %ebx
  pushl %ecx
f0104d62:	51                   	push   %ecx
  pushl %edx
f0104d63:	52                   	push   %edx
  pushl %esi
f0104d64:	56                   	push   %esi
  pushl %edi
f0104d65:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104d66:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104d6a:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104d6e:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104d70:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104d72:	5f                   	pop    %edi
  popl %esi
f0104d73:	5e                   	pop    %esi
  popl %edx
f0104d74:	5a                   	pop    %edx
  popl %ecx
f0104d75:	59                   	pop    %ecx
  popl %ebx
f0104d76:	5b                   	pop    %ebx
  popl %eax
f0104d77:	58                   	pop    %eax
  popl %ebp
f0104d78:	5d                   	pop    %ebp
  ret
f0104d79:	c3                   	ret    

f0104d7a <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104d7a:	55                   	push   %ebp
f0104d7b:	89 e5                	mov    %esp,%ebp
f0104d7d:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104d80:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d83:	0f b6 c0             	movzbl %al,%eax
f0104d86:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104d8d:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104d90:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104d93:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104d96:	ee                   	out    %al,(%dx)
f0104d97:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104d9e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104da1:	89 c2                	mov    %eax,%edx
f0104da3:	ec                   	in     (%dx),%al
f0104da4:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104da7:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104daa:	0f b6 c0             	movzbl %al,%eax
}
f0104dad:	c9                   	leave  
f0104dae:	c3                   	ret    

f0104daf <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104daf:	55                   	push   %ebp
f0104db0:	89 e5                	mov    %esp,%ebp
f0104db2:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104db5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104db8:	0f b6 c0             	movzbl %al,%eax
f0104dbb:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104dc2:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104dc5:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104dc8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104dcb:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104dcf:	0f b6 c0             	movzbl %al,%eax
f0104dd2:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104dd9:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104ddc:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104ddf:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104de2:	ee                   	out    %al,(%dx)
}
f0104de3:	90                   	nop
f0104de4:	c9                   	leave  
f0104de5:	c3                   	ret    

f0104de6 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104de6:	55                   	push   %ebp
f0104de7:	89 e5                	mov    %esp,%ebp
f0104de9:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104dec:	c7 05 c8 d8 b5 f0 00 	movl   $0x0,0xf0b5d8c8
f0104df3:	00 00 00 
f0104df6:	c7 05 cc d8 b5 f0 00 	movl   $0x0,0xf0b5d8cc
f0104dfd:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104e00:	83 ec 08             	sub    $0x8,%esp
f0104e03:	68 ea 6e 10 f0       	push   $0xf0106eea
f0104e08:	6a 00                	push   $0x0
f0104e0a:	e8 af 97 00 00       	call   f010e5be <irq_install_handler>
f0104e0f:	83 c4 10             	add    $0x10,%esp
}
f0104e12:	90                   	nop
f0104e13:	c9                   	leave  
f0104e14:	c3                   	ret    

f0104e15 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104e15:	55                   	push   %ebp
f0104e16:	89 e5                	mov    %esp,%ebp
f0104e18:	53                   	push   %ebx
f0104e19:	83 ec 24             	sub    $0x24,%esp
f0104e1c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e1f:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104e22:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e29:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e2d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e30:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e33:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104e34:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104e38:	77 48                	ja     f0104e82 <kclock_start+0x6d>
f0104e3a:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104e41:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104e45:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e48:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e4b:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104e4c:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e50:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104e55:	99                   	cltd   
f0104e56:	f7 fb                	idiv   %ebx
f0104e58:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104e5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e62:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104e67:	99                   	cltd   
f0104e68:	f7 fb                	idiv   %ebx
f0104e6a:	89 c3                	mov    %eax,%ebx
f0104e6c:	89 c8                	mov    %ecx,%eax
f0104e6e:	99                   	cltd   
f0104e6f:	f7 fb                	idiv   %ebx
f0104e71:	0f b7 c0             	movzwl %ax,%eax
f0104e74:	83 ec 0c             	sub    $0xc,%esp
f0104e77:	50                   	push   %eax
f0104e78:	e8 b3 01 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104e7d:	83 c4 10             	add    $0x10,%esp
f0104e80:	eb 13                	jmp    f0104e95 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e82:	6a 35                	push   $0x35
f0104e84:	68 30 57 12 f0       	push   $0xf0125730
f0104e89:	6a 41                	push   $0x41
f0104e8b:	68 8c 57 12 f0       	push   $0xf012578c
f0104e90:	e8 a4 b4 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104e95:	83 ec 0c             	sub    $0xc,%esp
f0104e98:	6a 00                	push   $0x0
f0104e9a:	e8 80 24 00 00       	call   f010731f <irq_clear_mask>
f0104e9f:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104ea2:	90                   	nop
f0104ea3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104ea6:	c9                   	leave  
f0104ea7:	c3                   	ret    

f0104ea8 <kclock_stop>:

void
kclock_stop(void)
{
f0104ea8:	55                   	push   %ebp
f0104ea9:	89 e5                	mov    %esp,%ebp
f0104eab:	83 ec 18             	sub    $0x18,%esp
f0104eae:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104eb5:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104eb9:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104ebc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ebf:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104ec0:	83 ec 0c             	sub    $0xc,%esp
f0104ec3:	6a 00                	push   $0x0
f0104ec5:	e8 e0 23 00 00       	call   f01072aa <irq_set_mask>
f0104eca:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104ecd:	90                   	nop
f0104ece:	c9                   	leave  
f0104ecf:	c3                   	ret    

f0104ed0 <kclock_resume>:

void
kclock_resume(void)
{
f0104ed0:	55                   	push   %ebp
f0104ed1:	89 e5                	mov    %esp,%ebp
f0104ed3:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ed6:	e8 f5 01 00 00       	call   f01050d0 <kclock_read_cnt0_latch>
f0104edb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104edf:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104ee4:	77 06                	ja     f0104eec <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104ee6:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104eec:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104ef0:	83 e0 01             	and    $0x1,%eax
f0104ef3:	66 85 c0             	test   %ax,%ax
f0104ef6:	74 09                	je     f0104f01 <kclock_resume+0x31>
		cnt0++;
f0104ef8:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104efc:	40                   	inc    %eax
f0104efd:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104f01:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104f08:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104f0c:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104f0f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104f12:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f13:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104f17:	83 ec 0c             	sub    $0xc,%esp
f0104f1a:	50                   	push   %eax
f0104f1b:	e8 10 01 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104f20:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f23:	83 ec 0c             	sub    $0xc,%esp
f0104f26:	6a 00                	push   $0x0
f0104f28:	e8 f2 23 00 00       	call   f010731f <irq_clear_mask>
f0104f2d:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104f30:	90                   	nop
f0104f31:	c9                   	leave  
f0104f32:	c3                   	ret    

f0104f33 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104f33:	55                   	push   %ebp
f0104f34:	89 e5                	mov    %esp,%ebp
f0104f36:	83 ec 28             	sub    $0x28,%esp
f0104f39:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f3c:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104f3f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f46:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104f4a:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104f4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f50:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f51:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104f55:	83 ec 0c             	sub    $0xc,%esp
f0104f58:	50                   	push   %eax
f0104f59:	e8 d2 00 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0104f5e:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f61:	83 ec 0c             	sub    $0xc,%esp
f0104f64:	6a 00                	push   $0x0
f0104f66:	e8 b4 23 00 00       	call   f010731f <irq_clear_mask>
f0104f6b:	83 c4 10             	add    $0x10,%esp
}
f0104f6e:	90                   	nop
f0104f6f:	c9                   	leave  
f0104f70:	c3                   	ret    

f0104f71 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104f71:	55                   	push   %ebp
f0104f72:	89 e5                	mov    %esp,%ebp
f0104f74:	56                   	push   %esi
f0104f75:	53                   	push   %ebx
f0104f76:	83 ec 20             	sub    $0x20,%esp
f0104f79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7c:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104f7f:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104f83:	0f 87 8a 00 00 00    	ja     f0105013 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104f89:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104f8d:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104f92:	99                   	cltd   
f0104f93:	f7 fe                	idiv   %esi
f0104f95:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104f9b:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104f9f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104fa4:	99                   	cltd   
f0104fa5:	f7 fb                	idiv   %ebx
f0104fa7:	89 c6                	mov    %eax,%esi
f0104fa9:	89 c8                	mov    %ecx,%eax
f0104fab:	99                   	cltd   
f0104fac:	f7 fe                	idiv   %esi
f0104fae:	89 c3                	mov    %eax,%ebx
f0104fb0:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104fb4:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104fb9:	99                   	cltd   
f0104fba:	f7 f9                	idiv   %ecx
f0104fbc:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104fc2:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104fc6:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104fcb:	99                   	cltd   
f0104fcc:	f7 fe                	idiv   %esi
f0104fce:	89 c6                	mov    %eax,%esi
f0104fd0:	89 c8                	mov    %ecx,%eax
f0104fd2:	99                   	cltd   
f0104fd3:	f7 fe                	idiv   %esi
f0104fd5:	25 01 00 00 80       	and    $0x80000001,%eax
f0104fda:	85 c0                	test   %eax,%eax
f0104fdc:	79 05                	jns    f0104fe3 <kclock_set_quantum+0x72>
f0104fde:	48                   	dec    %eax
f0104fdf:	83 c8 fe             	or     $0xfffffffe,%eax
f0104fe2:	40                   	inc    %eax
f0104fe3:	01 d8                	add    %ebx,%eax
f0104fe5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104fe8:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104fef:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104ff3:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104ff6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104ff9:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ffd:	0f b7 c0             	movzwl %ax,%eax
f0105000:	83 ec 0c             	sub    $0xc,%esp
f0105003:	50                   	push   %eax
f0105004:	e8 27 00 00 00       	call   f0105030 <kclock_write_cnt0_LSB_first>
f0105009:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f010500c:	e8 97 fe ff ff       	call   f0104ea8 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105011:	eb 16                	jmp    f0105029 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105013:	6a 35                	push   $0x35
f0105015:	68 30 57 12 f0       	push   $0xf0125730
f010501a:	68 ea 00 00 00       	push   $0xea
f010501f:	68 8c 57 12 f0       	push   $0xf012578c
f0105024:	e8 10 b3 ff ff       	call   f0100339 <_panic>
	}
}
f0105029:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010502c:	5b                   	pop    %ebx
f010502d:	5e                   	pop    %esi
f010502e:	5d                   	pop    %ebp
f010502f:	c3                   	ret    

f0105030 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105030:	55                   	push   %ebp
f0105031:	89 e5                	mov    %esp,%ebp
f0105033:	83 ec 28             	sub    $0x28,%esp
f0105036:	8b 45 08             	mov    0x8(%ebp),%eax
f0105039:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f010503d:	e8 b8 24 00 00       	call   f01074fa <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105042:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105045:	0f b6 c0             	movzbl %al,%eax
f0105048:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f010504f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105052:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105055:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105058:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0105059:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010505c:	66 c1 e8 08          	shr    $0x8,%ax
f0105060:	0f b6 c0             	movzbl %al,%eax
f0105063:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f010506a:	88 45 ef             	mov    %al,-0x11(%ebp)
f010506d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105070:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105073:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105074:	e8 d3 24 00 00       	call   f010754c <popcli>

}
f0105079:	90                   	nop
f010507a:	c9                   	leave  
f010507b:	c3                   	ret    

f010507c <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f010507c:	55                   	push   %ebp
f010507d:	89 e5                	mov    %esp,%ebp
f010507f:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0105082:	e8 73 24 00 00       	call   f01074fa <pushcli>
f0105087:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010508e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105091:	89 c2                	mov    %eax,%edx
f0105093:	ec                   	in     (%dx),%al
f0105094:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0105097:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f010509a:	88 45 f7             	mov    %al,-0x9(%ebp)
f010509d:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01050a7:	89 c2                	mov    %eax,%edx
f01050a9:	ec                   	in     (%dx),%al
f01050aa:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f01050ad:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f01050b0:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f01050b3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01050b7:	c1 e0 08             	shl    $0x8,%eax
f01050ba:	89 c2                	mov    %eax,%edx
f01050bc:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01050c0:	09 d0                	or     %edx,%eax
f01050c2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f01050c6:	e8 81 24 00 00       	call   f010754c <popcli>
	return cnt0 ;
f01050cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01050ce:	c9                   	leave  
f01050cf:	c3                   	ret    

f01050d0 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f01050d0:	55                   	push   %ebp
f01050d1:	89 e5                	mov    %esp,%ebp
f01050d3:	83 ec 30             	sub    $0x30,%esp
f01050d6:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01050e0:	89 c2                	mov    %eax,%edx
f01050e2:	ec                   	in     (%dx),%al
f01050e3:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f01050e6:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f01050e9:	88 45 ff             	mov    %al,-0x1(%ebp)
f01050ec:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f01050f3:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01050f7:	8a 45 dc             	mov    -0x24(%ebp),%al
f01050fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050fd:	ee                   	out    %al,(%dx)
f01050fe:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105105:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105108:	89 c2                	mov    %eax,%edx
f010510a:	ec                   	in     (%dx),%al
f010510b:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f010510e:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105111:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105114:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010511b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010511e:	89 c2                	mov    %eax,%edx
f0105120:	ec                   	in     (%dx),%al
f0105121:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105124:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105127:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f010512a:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f010512e:	c1 e0 08             	shl    $0x8,%eax
f0105131:	89 c2                	mov    %eax,%edx
f0105133:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105137:	09 d0                	or     %edx,%eax
f0105139:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f010513d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105141:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105148:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010514b:	8a 45 df             	mov    -0x21(%ebp),%al
f010514e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105151:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105152:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105155:	c9                   	leave  
f0105156:	c3                   	ret    

f0105157 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0105157:	55                   	push   %ebp
f0105158:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f010515a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010515e:	74 1d                	je     f010517d <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105160:	8b 45 08             	mov    0x8(%ebp),%eax
f0105163:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105169:	8b 45 08             	mov    0x8(%ebp),%eax
f010516c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105173:	8b 45 08             	mov    0x8(%ebp),%eax
f0105176:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f010517d:	90                   	nop
f010517e:	5d                   	pop    %ebp
f010517f:	c3                   	ret    

f0105180 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0105180:	55                   	push   %ebp
f0105181:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105183:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105187:	74 08                	je     f0105191 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0105189:	8b 45 08             	mov    0x8(%ebp),%eax
f010518c:	8b 40 0c             	mov    0xc(%eax),%eax
f010518f:	eb 05                	jmp    f0105196 <queue_size+0x16>
	}
	else
	{
		return 0;
f0105191:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0105196:	5d                   	pop    %ebp
f0105197:	c3                   	ret    

f0105198 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0105198:	55                   	push   %ebp
f0105199:	89 e5                	mov    %esp,%ebp
f010519b:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010519e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051a2:	75 16                	jne    f01051ba <enqueue+0x22>
f01051a4:	68 a0 57 12 f0       	push   $0xf01257a0
f01051a9:	68 ae 57 12 f0       	push   $0xf01257ae
f01051ae:	6a 34                	push   $0x34
f01051b0:	68 c3 57 12 f0       	push   $0xf01257c3
f01051b5:	e8 7f b1 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f01051ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051be:	74 66                	je     f0105226 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f01051c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051c4:	75 14                	jne    f01051da <enqueue+0x42>
f01051c6:	83 ec 04             	sub    $0x4,%esp
f01051c9:	68 dc 57 12 f0       	push   $0xf01257dc
f01051ce:	6a 37                	push   $0x37
f01051d0:	68 c3 57 12 f0       	push   $0xf01257c3
f01051d5:	e8 5f b1 ff ff       	call   f0100339 <_panic>
f01051da:	8b 45 08             	mov    0x8(%ebp),%eax
f01051dd:	8b 10                	mov    (%eax),%edx
f01051df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051e2:	89 50 08             	mov    %edx,0x8(%eax)
f01051e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051e8:	8b 40 08             	mov    0x8(%eax),%eax
f01051eb:	85 c0                	test   %eax,%eax
f01051ed:	74 0d                	je     f01051fc <enqueue+0x64>
f01051ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01051f2:	8b 00                	mov    (%eax),%eax
f01051f4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051f7:	89 50 0c             	mov    %edx,0xc(%eax)
f01051fa:	eb 09                	jmp    f0105205 <enqueue+0x6d>
f01051fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01051ff:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105202:	89 50 04             	mov    %edx,0x4(%eax)
f0105205:	8b 45 08             	mov    0x8(%ebp),%eax
f0105208:	8b 55 0c             	mov    0xc(%ebp),%edx
f010520b:	89 10                	mov    %edx,(%eax)
f010520d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105210:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105217:	8b 45 08             	mov    0x8(%ebp),%eax
f010521a:	8b 40 0c             	mov    0xc(%eax),%eax
f010521d:	8d 50 01             	lea    0x1(%eax),%edx
f0105220:	8b 45 08             	mov    0x8(%ebp),%eax
f0105223:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105226:	90                   	nop
f0105227:	c9                   	leave  
f0105228:	c3                   	ret    

f0105229 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0105229:	55                   	push   %ebp
f010522a:	89 e5                	mov    %esp,%ebp
f010522c:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f010522f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105233:	75 0a                	jne    f010523f <dequeue+0x16>
f0105235:	b8 00 00 00 00       	mov    $0x0,%eax
f010523a:	e9 a0 00 00 00       	jmp    f01052df <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f010523f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105242:	8b 40 04             	mov    0x4(%eax),%eax
f0105245:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0105248:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010524c:	0f 84 8a 00 00 00    	je     f01052dc <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105252:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105256:	75 14                	jne    f010526c <dequeue+0x43>
f0105258:	83 ec 04             	sub    $0x4,%esp
f010525b:	68 ff 57 12 f0       	push   $0xf01257ff
f0105260:	6a 44                	push   $0x44
f0105262:	68 c3 57 12 f0       	push   $0xf01257c3
f0105267:	e8 cd b0 ff ff       	call   f0100339 <_panic>
f010526c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010526f:	8b 40 08             	mov    0x8(%eax),%eax
f0105272:	85 c0                	test   %eax,%eax
f0105274:	74 11                	je     f0105287 <dequeue+0x5e>
f0105276:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105279:	8b 40 08             	mov    0x8(%eax),%eax
f010527c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010527f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105282:	89 50 0c             	mov    %edx,0xc(%eax)
f0105285:	eb 0c                	jmp    f0105293 <dequeue+0x6a>
f0105287:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010528a:	8b 50 0c             	mov    0xc(%eax),%edx
f010528d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105290:	89 50 04             	mov    %edx,0x4(%eax)
f0105293:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105296:	8b 40 0c             	mov    0xc(%eax),%eax
f0105299:	85 c0                	test   %eax,%eax
f010529b:	74 11                	je     f01052ae <dequeue+0x85>
f010529d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052a0:	8b 40 0c             	mov    0xc(%eax),%eax
f01052a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01052a6:	8b 52 08             	mov    0x8(%edx),%edx
f01052a9:	89 50 08             	mov    %edx,0x8(%eax)
f01052ac:	eb 0b                	jmp    f01052b9 <dequeue+0x90>
f01052ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052b1:	8b 50 08             	mov    0x8(%eax),%edx
f01052b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01052b7:	89 10                	mov    %edx,(%eax)
f01052b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052bc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01052c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052c6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01052cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01052d0:	8b 40 0c             	mov    0xc(%eax),%eax
f01052d3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01052d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052d9:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01052dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01052df:	c9                   	leave  
f01052e0:	c3                   	ret    

f01052e1 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01052e1:	55                   	push   %ebp
f01052e2:	89 e5                	mov    %esp,%ebp
f01052e4:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01052e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052eb:	75 16                	jne    f0105303 <remove_from_queue+0x22>
f01052ed:	68 a0 57 12 f0       	push   $0xf01257a0
f01052f2:	68 ae 57 12 f0       	push   $0xf01257ae
f01052f7:	6a 4e                	push   $0x4e
f01052f9:	68 c3 57 12 f0       	push   $0xf01257c3
f01052fe:	e8 36 b0 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105303:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105307:	0f 84 8a 00 00 00    	je     f0105397 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010530d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105311:	75 14                	jne    f0105327 <remove_from_queue+0x46>
f0105313:	83 ec 04             	sub    $0x4,%esp
f0105316:	68 ff 57 12 f0       	push   $0xf01257ff
f010531b:	6a 52                	push   $0x52
f010531d:	68 c3 57 12 f0       	push   $0xf01257c3
f0105322:	e8 12 b0 ff ff       	call   f0100339 <_panic>
f0105327:	8b 45 0c             	mov    0xc(%ebp),%eax
f010532a:	8b 40 08             	mov    0x8(%eax),%eax
f010532d:	85 c0                	test   %eax,%eax
f010532f:	74 11                	je     f0105342 <remove_from_queue+0x61>
f0105331:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105334:	8b 40 08             	mov    0x8(%eax),%eax
f0105337:	8b 55 0c             	mov    0xc(%ebp),%edx
f010533a:	8b 52 0c             	mov    0xc(%edx),%edx
f010533d:	89 50 0c             	mov    %edx,0xc(%eax)
f0105340:	eb 0c                	jmp    f010534e <remove_from_queue+0x6d>
f0105342:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105345:	8b 50 0c             	mov    0xc(%eax),%edx
f0105348:	8b 45 08             	mov    0x8(%ebp),%eax
f010534b:	89 50 04             	mov    %edx,0x4(%eax)
f010534e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105351:	8b 40 0c             	mov    0xc(%eax),%eax
f0105354:	85 c0                	test   %eax,%eax
f0105356:	74 11                	je     f0105369 <remove_from_queue+0x88>
f0105358:	8b 45 0c             	mov    0xc(%ebp),%eax
f010535b:	8b 40 0c             	mov    0xc(%eax),%eax
f010535e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105361:	8b 52 08             	mov    0x8(%edx),%edx
f0105364:	89 50 08             	mov    %edx,0x8(%eax)
f0105367:	eb 0b                	jmp    f0105374 <remove_from_queue+0x93>
f0105369:	8b 45 0c             	mov    0xc(%ebp),%eax
f010536c:	8b 50 08             	mov    0x8(%eax),%edx
f010536f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105372:	89 10                	mov    %edx,(%eax)
f0105374:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105377:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010537e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105381:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105388:	8b 45 08             	mov    0x8(%ebp),%eax
f010538b:	8b 40 0c             	mov    0xc(%eax),%eax
f010538e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105391:	8b 45 08             	mov    0x8(%ebp),%eax
f0105394:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105397:	90                   	nop
f0105398:	c9                   	leave  
f0105399:	c3                   	ret    

f010539a <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010539a:	55                   	push   %ebp
f010539b:	89 e5                	mov    %esp,%ebp
f010539d:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01053a0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053a4:	75 07                	jne    f01053ad <find_env_in_queue+0x13>
f01053a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01053ab:	eb 58                	jmp    f0105405 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01053ad:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01053b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b7:	8b 00                	mov    (%eax),%eax
f01053b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053bc:	eb 19                	jmp    f01053d7 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01053be:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053c1:	8b 40 10             	mov    0x10(%eax),%eax
f01053c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01053c7:	75 05                	jne    f01053ce <find_env_in_queue+0x34>
		{
			return ptr_env;
f01053c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053cc:	eb 37                	jmp    f0105405 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01053ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d1:	8b 40 08             	mov    0x8(%eax),%eax
f01053d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053d7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01053db:	74 08                	je     f01053e5 <find_env_in_queue+0x4b>
f01053dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053e0:	8b 40 08             	mov    0x8(%eax),%eax
f01053e3:	eb 05                	jmp    f01053ea <find_env_in_queue+0x50>
f01053e5:	b8 00 00 00 00       	mov    $0x0,%eax
f01053ea:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ed:	89 42 08             	mov    %eax,0x8(%edx)
f01053f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f3:	8b 40 08             	mov    0x8(%eax),%eax
f01053f6:	85 c0                	test   %eax,%eax
f01053f8:	75 c4                	jne    f01053be <find_env_in_queue+0x24>
f01053fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01053fe:	75 be                	jne    f01053be <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105400:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105405:	c9                   	leave  
f0105406:	c3                   	ret    

f0105407 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105407:	55                   	push   %ebp
f0105408:	89 e5                	mov    %esp,%ebp
f010540a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010540d:	83 ec 0c             	sub    $0xc,%esp
f0105410:	68 20 d2 75 f0       	push   $0xf075d220
f0105415:	e8 54 ac 00 00       	call   f011006e <acquire_spinlock>
f010541a:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010541d:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105422:	85 c0                	test   %eax,%eax
f0105424:	74 11                	je     f0105437 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105426:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010542b:	83 ec 0c             	sub    $0xc,%esp
f010542e:	50                   	push   %eax
f010542f:	e8 5b 46 00 00       	call   f0109a8f <kfree>
f0105434:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105437:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f010543c:	85 c0                	test   %eax,%eax
f010543e:	74 11                	je     f0105451 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105440:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f0105445:	83 ec 0c             	sub    $0xc,%esp
f0105448:	50                   	push   %eax
f0105449:	e8 41 46 00 00       	call   f0109a8f <kfree>
f010544e:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105451:	83 ec 0c             	sub    $0xc,%esp
f0105454:	68 20 d2 75 f0       	push   $0xf075d220
f0105459:	e8 97 ac 00 00       	call   f01100f5 <release_spinlock>
f010545e:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105461:	90                   	nop
f0105462:	c9                   	leave  
f0105463:	c3                   	ret    

f0105464 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105464:	55                   	push   %ebp
f0105465:	89 e5                	mov    %esp,%ebp
f0105467:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010546a:	83 ec 0c             	sub    $0xc,%esp
f010546d:	68 20 d2 75 f0       	push   $0xf075d220
f0105472:	e8 10 ae 00 00       	call   f0110287 <holding_spinlock>
f0105477:	83 c4 10             	add    $0x10,%esp
f010547a:	85 c0                	test   %eax,%eax
f010547c:	75 17                	jne    f0105495 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010547e:	83 ec 04             	sub    $0x4,%esp
f0105481:	68 20 58 12 f0       	push   $0xf0125820
f0105486:	68 85 00 00 00       	push   $0x85
f010548b:	68 c3 57 12 f0       	push   $0xf01257c3
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105495:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105499:	75 19                	jne    f01054b4 <sched_insert_ready0+0x50>
f010549b:	68 61 58 12 f0       	push   $0xf0125861
f01054a0:	68 ae 57 12 f0       	push   $0xf01257ae
f01054a5:	68 88 00 00 00       	push   $0x88
f01054aa:	68 c3 57 12 f0       	push   $0xf01257c3
f01054af:	e8 85 ae ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01054b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b7:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01054be:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f01054c3:	83 ec 08             	sub    $0x8,%esp
f01054c6:	ff 75 08             	pushl  0x8(%ebp)
f01054c9:	50                   	push   %eax
f01054ca:	e8 c9 fc ff ff       	call   f0105198 <enqueue>
f01054cf:	83 c4 10             	add    $0x10,%esp
	}
}
f01054d2:	90                   	nop
f01054d3:	c9                   	leave  
f01054d4:	c3                   	ret    

f01054d5 <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01054d5:	55                   	push   %ebp
f01054d6:	89 e5                	mov    %esp,%ebp
f01054d8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054db:	83 ec 0c             	sub    $0xc,%esp
f01054de:	68 20 d2 75 f0       	push   $0xf075d220
f01054e3:	e8 9f ad 00 00       	call   f0110287 <holding_spinlock>
f01054e8:	83 c4 10             	add    $0x10,%esp
f01054eb:	85 c0                	test   %eax,%eax
f01054ed:	75 17                	jne    f0105506 <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054ef:	83 ec 04             	sub    $0x4,%esp
f01054f2:	68 20 58 12 f0       	push   $0xf0125820
f01054f7:	68 97 00 00 00       	push   $0x97
f01054fc:	68 c3 57 12 f0       	push   $0xf01257c3
f0105501:	e8 33 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105506:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010550a:	75 19                	jne    f0105525 <sched_insert_ready+0x50>
f010550c:	68 61 58 12 f0       	push   $0xf0125861
f0105511:	68 ae 57 12 f0       	push   $0xf01257ae
f0105516:	68 9a 00 00 00       	push   $0x9a
f010551b:	68 c3 57 12 f0       	push   $0xf01257c3
f0105520:	e8 14 ae ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0105525:	8b 45 08             	mov    0x8(%ebp),%eax
f0105528:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f010552f:	8b 15 b0 d2 75 f0    	mov    0xf075d2b0,%edx
f0105535:	8b 45 08             	mov    0x8(%ebp),%eax
f0105538:	8b 40 1c             	mov    0x1c(%eax),%eax
f010553b:	c1 e0 04             	shl    $0x4,%eax
f010553e:	01 d0                	add    %edx,%eax
f0105540:	83 ec 08             	sub    $0x8,%esp
f0105543:	ff 75 08             	pushl  0x8(%ebp)
f0105546:	50                   	push   %eax
f0105547:	e8 4c fc ff ff       	call   f0105198 <enqueue>
f010554c:	83 c4 10             	add    $0x10,%esp
	}
}
f010554f:	90                   	nop
f0105550:	c9                   	leave  
f0105551:	c3                   	ret    

f0105552 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105552:	55                   	push   %ebp
f0105553:	89 e5                	mov    %esp,%ebp
f0105555:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105558:	83 ec 0c             	sub    $0xc,%esp
f010555b:	68 20 d2 75 f0       	push   $0xf075d220
f0105560:	e8 22 ad 00 00       	call   f0110287 <holding_spinlock>
f0105565:	83 c4 10             	add    $0x10,%esp
f0105568:	85 c0                	test   %eax,%eax
f010556a:	75 17                	jne    f0105583 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010556c:	83 ec 04             	sub    $0x4,%esp
f010556f:	68 20 58 12 f0       	push   $0xf0125820
f0105574:	68 a9 00 00 00       	push   $0xa9
f0105579:	68 c3 57 12 f0       	push   $0xf01257c3
f010557e:	e8 b6 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105583:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105587:	74 0b                	je     f0105594 <sched_remove_ready+0x42>
f0105589:	8b 45 08             	mov    0x8(%ebp),%eax
f010558c:	8b 40 18             	mov    0x18(%eax),%eax
f010558f:	83 f8 01             	cmp    $0x1,%eax
f0105592:	74 19                	je     f01055ad <sched_remove_ready+0x5b>
f0105594:	68 70 58 12 f0       	push   $0xf0125870
f0105599:	68 ae 57 12 f0       	push   $0xf01257ae
f010559e:	68 ac 00 00 00       	push   $0xac
f01055a3:	68 c3 57 12 f0       	push   $0xf01257c3
f01055a8:	e8 8c ad ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01055ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01055b4:	e9 e4 00 00 00       	jmp    f010569d <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01055b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01055bc:	8b 40 10             	mov    0x10(%eax),%eax
f01055bf:	89 c2                	mov    %eax,%edx
f01055c1:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f01055c6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01055c9:	c1 e1 04             	shl    $0x4,%ecx
f01055cc:	01 c8                	add    %ecx,%eax
f01055ce:	83 ec 08             	sub    $0x8,%esp
f01055d1:	52                   	push   %edx
f01055d2:	50                   	push   %eax
f01055d3:	e8 c2 fd ff ff       	call   f010539a <find_env_in_queue>
f01055d8:	83 c4 10             	add    $0x10,%esp
f01055db:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01055de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01055e2:	0f 84 b2 00 00 00    	je     f010569a <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01055e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055ec:	75 17                	jne    f0105605 <sched_remove_ready+0xb3>
f01055ee:	83 ec 04             	sub    $0x4,%esp
f01055f1:	68 ff 57 12 f0       	push   $0xf01257ff
f01055f6:	68 b3 00 00 00       	push   $0xb3
f01055fb:	68 c3 57 12 f0       	push   $0xf01257c3
f0105600:	e8 34 ad ff ff       	call   f0100339 <_panic>
f0105605:	8b 45 08             	mov    0x8(%ebp),%eax
f0105608:	8b 40 08             	mov    0x8(%eax),%eax
f010560b:	85 c0                	test   %eax,%eax
f010560d:	74 11                	je     f0105620 <sched_remove_ready+0xce>
f010560f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105612:	8b 40 08             	mov    0x8(%eax),%eax
f0105615:	8b 55 08             	mov    0x8(%ebp),%edx
f0105618:	8b 52 0c             	mov    0xc(%edx),%edx
f010561b:	89 50 0c             	mov    %edx,0xc(%eax)
f010561e:	eb 16                	jmp    f0105636 <sched_remove_ready+0xe4>
f0105620:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105625:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105628:	c1 e2 04             	shl    $0x4,%edx
f010562b:	01 c2                	add    %eax,%edx
f010562d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105630:	8b 40 0c             	mov    0xc(%eax),%eax
f0105633:	89 42 04             	mov    %eax,0x4(%edx)
f0105636:	8b 45 08             	mov    0x8(%ebp),%eax
f0105639:	8b 40 0c             	mov    0xc(%eax),%eax
f010563c:	85 c0                	test   %eax,%eax
f010563e:	74 11                	je     f0105651 <sched_remove_ready+0xff>
f0105640:	8b 45 08             	mov    0x8(%ebp),%eax
f0105643:	8b 40 0c             	mov    0xc(%eax),%eax
f0105646:	8b 55 08             	mov    0x8(%ebp),%edx
f0105649:	8b 52 08             	mov    0x8(%edx),%edx
f010564c:	89 50 08             	mov    %edx,0x8(%eax)
f010564f:	eb 15                	jmp    f0105666 <sched_remove_ready+0x114>
f0105651:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105656:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105659:	c1 e2 04             	shl    $0x4,%edx
f010565c:	01 c2                	add    %eax,%edx
f010565e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105661:	8b 40 08             	mov    0x8(%eax),%eax
f0105664:	89 02                	mov    %eax,(%edx)
f0105666:	8b 45 08             	mov    0x8(%ebp),%eax
f0105669:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105670:	8b 45 08             	mov    0x8(%ebp),%eax
f0105673:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010567a:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010567f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105682:	c1 e2 04             	shl    $0x4,%edx
f0105685:	01 d0                	add    %edx,%eax
f0105687:	8b 50 0c             	mov    0xc(%eax),%edx
f010568a:	4a                   	dec    %edx
f010568b:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f010568e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105691:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f0105698:	eb 14                	jmp    f01056ae <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010569a:	ff 45 f4             	incl   -0xc(%ebp)
f010569d:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f01056a2:	0f b6 c0             	movzbl %al,%eax
f01056a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01056a8:	0f 8f 0b ff ff ff    	jg     f01055b9 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01056ae:	c9                   	leave  
f01056af:	c3                   	ret    

f01056b0 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01056b0:	55                   	push   %ebp
f01056b1:	89 e5                	mov    %esp,%ebp
f01056b3:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01056b6:	83 ec 0c             	sub    $0xc,%esp
f01056b9:	68 20 d2 75 f0       	push   $0xf075d220
f01056be:	e8 c4 ab 00 00       	call   f0110287 <holding_spinlock>
f01056c3:	83 c4 10             	add    $0x10,%esp
f01056c6:	85 c0                	test   %eax,%eax
f01056c8:	75 17                	jne    f01056e1 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01056ca:	83 ec 04             	sub    $0x4,%esp
f01056cd:	68 20 58 12 f0       	push   $0xf0125820
f01056d2:	68 c2 00 00 00       	push   $0xc2
f01056d7:	68 c3 57 12 f0       	push   $0xf01257c3
f01056dc:	e8 58 ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01056e1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056e5:	75 19                	jne    f0105700 <sched_insert_new+0x50>
f01056e7:	68 61 58 12 f0       	push   $0xf0125861
f01056ec:	68 ae 57 12 f0       	push   $0xf01257ae
f01056f1:	68 c5 00 00 00       	push   $0xc5
f01056f6:	68 c3 57 12 f0       	push   $0xf01257c3
f01056fb:	e8 39 ac ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105700:	8b 45 08             	mov    0x8(%ebp),%eax
f0105703:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010570a:	83 ec 08             	sub    $0x8,%esp
f010570d:	ff 75 08             	pushl  0x8(%ebp)
f0105710:	68 90 d2 75 f0       	push   $0xf075d290
f0105715:	e8 7e fa ff ff       	call   f0105198 <enqueue>
f010571a:	83 c4 10             	add    $0x10,%esp
	}
}
f010571d:	90                   	nop
f010571e:	c9                   	leave  
f010571f:	c3                   	ret    

f0105720 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0105720:	55                   	push   %ebp
f0105721:	89 e5                	mov    %esp,%ebp
f0105723:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105726:	83 ec 0c             	sub    $0xc,%esp
f0105729:	68 20 d2 75 f0       	push   $0xf075d220
f010572e:	e8 54 ab 00 00       	call   f0110287 <holding_spinlock>
f0105733:	83 c4 10             	add    $0x10,%esp
f0105736:	85 c0                	test   %eax,%eax
f0105738:	75 17                	jne    f0105751 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010573a:	83 ec 04             	sub    $0x4,%esp
f010573d:	68 20 58 12 f0       	push   $0xf0125820
f0105742:	68 d3 00 00 00       	push   $0xd3
f0105747:	68 c3 57 12 f0       	push   $0xf01257c3
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105751:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105755:	74 0b                	je     f0105762 <sched_remove_new+0x42>
f0105757:	8b 45 08             	mov    0x8(%ebp),%eax
f010575a:	8b 40 18             	mov    0x18(%eax),%eax
f010575d:	83 f8 04             	cmp    $0x4,%eax
f0105760:	74 19                	je     f010577b <sched_remove_new+0x5b>
f0105762:	68 9c 58 12 f0       	push   $0xf012589c
f0105767:	68 ae 57 12 f0       	push   $0xf01257ae
f010576c:	68 d6 00 00 00       	push   $0xd6
f0105771:	68 c3 57 12 f0       	push   $0xf01257c3
f0105776:	e8 be ab ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010577b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010577f:	75 17                	jne    f0105798 <sched_remove_new+0x78>
f0105781:	83 ec 04             	sub    $0x4,%esp
f0105784:	68 ff 57 12 f0       	push   $0xf01257ff
f0105789:	68 d8 00 00 00       	push   $0xd8
f010578e:	68 c3 57 12 f0       	push   $0xf01257c3
f0105793:	e8 a1 ab ff ff       	call   f0100339 <_panic>
f0105798:	8b 45 08             	mov    0x8(%ebp),%eax
f010579b:	8b 40 08             	mov    0x8(%eax),%eax
f010579e:	85 c0                	test   %eax,%eax
f01057a0:	74 11                	je     f01057b3 <sched_remove_new+0x93>
f01057a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01057a5:	8b 40 08             	mov    0x8(%eax),%eax
f01057a8:	8b 55 08             	mov    0x8(%ebp),%edx
f01057ab:	8b 52 0c             	mov    0xc(%edx),%edx
f01057ae:	89 50 0c             	mov    %edx,0xc(%eax)
f01057b1:	eb 0b                	jmp    f01057be <sched_remove_new+0x9e>
f01057b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b6:	8b 40 0c             	mov    0xc(%eax),%eax
f01057b9:	a3 94 d2 75 f0       	mov    %eax,0xf075d294
f01057be:	8b 45 08             	mov    0x8(%ebp),%eax
f01057c1:	8b 40 0c             	mov    0xc(%eax),%eax
f01057c4:	85 c0                	test   %eax,%eax
f01057c6:	74 11                	je     f01057d9 <sched_remove_new+0xb9>
f01057c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01057cb:	8b 40 0c             	mov    0xc(%eax),%eax
f01057ce:	8b 55 08             	mov    0x8(%ebp),%edx
f01057d1:	8b 52 08             	mov    0x8(%edx),%edx
f01057d4:	89 50 08             	mov    %edx,0x8(%eax)
f01057d7:	eb 0b                	jmp    f01057e4 <sched_remove_new+0xc4>
f01057d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01057dc:	8b 40 08             	mov    0x8(%eax),%eax
f01057df:	a3 90 d2 75 f0       	mov    %eax,0xf075d290
f01057e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01057e7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01057ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01057f1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01057f8:	a1 9c d2 75 f0       	mov    0xf075d29c,%eax
f01057fd:	48                   	dec    %eax
f01057fe:	a3 9c d2 75 f0       	mov    %eax,0xf075d29c
		env->env_status = ENV_UNKNOWN;
f0105803:	8b 45 08             	mov    0x8(%ebp),%eax
f0105806:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f010580d:	90                   	nop
f010580e:	c9                   	leave  
f010580f:	c3                   	ret    

f0105810 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0105810:	55                   	push   %ebp
f0105811:	89 e5                	mov    %esp,%ebp
f0105813:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 20 d2 75 f0       	push   $0xf075d220
f010581e:	e8 64 aa 00 00       	call   f0110287 <holding_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
f0105826:	85 c0                	test   %eax,%eax
f0105828:	75 17                	jne    f0105841 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010582a:	83 ec 04             	sub    $0x4,%esp
f010582d:	68 20 58 12 f0       	push   $0xf0125820
f0105832:	68 e4 00 00 00       	push   $0xe4
f0105837:	68 c3 57 12 f0       	push   $0xf01257c3
f010583c:	e8 f8 aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105841:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105845:	75 19                	jne    f0105860 <sched_insert_exit+0x50>
f0105847:	68 61 58 12 f0       	push   $0xf0125861
f010584c:	68 ae 57 12 f0       	push   $0xf01257ae
f0105851:	68 e7 00 00 00       	push   $0xe7
f0105856:	68 c3 57 12 f0       	push   $0xf01257c3
f010585b:	e8 d9 aa ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105860:	e8 91 a2 00 00       	call   f010faf6 <isBufferingEnabled>
f0105865:	84 c0                	test   %al,%al
f0105867:	74 0e                	je     f0105877 <sched_insert_exit+0x67>
f0105869:	83 ec 0c             	sub    $0xc,%esp
f010586c:	ff 75 08             	pushl  0x8(%ebp)
f010586f:	e8 33 77 00 00       	call   f010cfa7 <cleanup_buffers>
f0105874:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0105877:	8b 45 08             	mov    0x8(%ebp),%eax
f010587a:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105881:	83 ec 08             	sub    $0x8,%esp
f0105884:	ff 75 08             	pushl  0x8(%ebp)
f0105887:	68 a0 d2 75 f0       	push   $0xf075d2a0
f010588c:	e8 07 f9 ff ff       	call   f0105198 <enqueue>
f0105891:	83 c4 10             	add    $0x10,%esp
	}
}
f0105894:	90                   	nop
f0105895:	c9                   	leave  
f0105896:	c3                   	ret    

f0105897 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f0105897:	55                   	push   %ebp
f0105898:	89 e5                	mov    %esp,%ebp
f010589a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010589d:	83 ec 0c             	sub    $0xc,%esp
f01058a0:	68 20 d2 75 f0       	push   $0xf075d220
f01058a5:	e8 dd a9 00 00       	call   f0110287 <holding_spinlock>
f01058aa:	83 c4 10             	add    $0x10,%esp
f01058ad:	85 c0                	test   %eax,%eax
f01058af:	75 17                	jne    f01058c8 <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01058b1:	83 ec 04             	sub    $0x4,%esp
f01058b4:	68 20 58 12 f0       	push   $0xf0125820
f01058b9:	68 f5 00 00 00       	push   $0xf5
f01058be:	68 c3 57 12 f0       	push   $0xf01257c3
f01058c3:	e8 71 aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01058c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01058cc:	74 0b                	je     f01058d9 <sched_remove_exit+0x42>
f01058ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01058d1:	8b 40 18             	mov    0x18(%eax),%eax
f01058d4:	83 f8 05             	cmp    $0x5,%eax
f01058d7:	74 19                	je     f01058f2 <sched_remove_exit+0x5b>
f01058d9:	68 c8 58 12 f0       	push   $0xf01258c8
f01058de:	68 ae 57 12 f0       	push   $0xf01257ae
f01058e3:	68 f8 00 00 00       	push   $0xf8
f01058e8:	68 c3 57 12 f0       	push   $0xf01257c3
f01058ed:	e8 47 aa ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01058f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01058f6:	75 17                	jne    f010590f <sched_remove_exit+0x78>
f01058f8:	83 ec 04             	sub    $0x4,%esp
f01058fb:	68 ff 57 12 f0       	push   $0xf01257ff
f0105900:	68 fa 00 00 00       	push   $0xfa
f0105905:	68 c3 57 12 f0       	push   $0xf01257c3
f010590a:	e8 2a aa ff ff       	call   f0100339 <_panic>
f010590f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105912:	8b 40 08             	mov    0x8(%eax),%eax
f0105915:	85 c0                	test   %eax,%eax
f0105917:	74 11                	je     f010592a <sched_remove_exit+0x93>
f0105919:	8b 45 08             	mov    0x8(%ebp),%eax
f010591c:	8b 40 08             	mov    0x8(%eax),%eax
f010591f:	8b 55 08             	mov    0x8(%ebp),%edx
f0105922:	8b 52 0c             	mov    0xc(%edx),%edx
f0105925:	89 50 0c             	mov    %edx,0xc(%eax)
f0105928:	eb 0b                	jmp    f0105935 <sched_remove_exit+0x9e>
f010592a:	8b 45 08             	mov    0x8(%ebp),%eax
f010592d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105930:	a3 a4 d2 75 f0       	mov    %eax,0xf075d2a4
f0105935:	8b 45 08             	mov    0x8(%ebp),%eax
f0105938:	8b 40 0c             	mov    0xc(%eax),%eax
f010593b:	85 c0                	test   %eax,%eax
f010593d:	74 11                	je     f0105950 <sched_remove_exit+0xb9>
f010593f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105942:	8b 40 0c             	mov    0xc(%eax),%eax
f0105945:	8b 55 08             	mov    0x8(%ebp),%edx
f0105948:	8b 52 08             	mov    0x8(%edx),%edx
f010594b:	89 50 08             	mov    %edx,0x8(%eax)
f010594e:	eb 0b                	jmp    f010595b <sched_remove_exit+0xc4>
f0105950:	8b 45 08             	mov    0x8(%ebp),%eax
f0105953:	8b 40 08             	mov    0x8(%eax),%eax
f0105956:	a3 a0 d2 75 f0       	mov    %eax,0xf075d2a0
f010595b:	8b 45 08             	mov    0x8(%ebp),%eax
f010595e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105965:	8b 45 08             	mov    0x8(%ebp),%eax
f0105968:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010596f:	a1 ac d2 75 f0       	mov    0xf075d2ac,%eax
f0105974:	48                   	dec    %eax
f0105975:	a3 ac d2 75 f0       	mov    %eax,0xf075d2ac
		env->env_status = ENV_UNKNOWN;
f010597a:	8b 45 08             	mov    0x8(%ebp),%eax
f010597d:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105984:	90                   	nop
f0105985:	c9                   	leave  
f0105986:	c3                   	ret    

f0105987 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f0105987:	55                   	push   %ebp
f0105988:	89 e5                	mov    %esp,%ebp
f010598a:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010598d:	83 ec 0c             	sub    $0xc,%esp
f0105990:	68 20 d2 75 f0       	push   $0xf075d220
f0105995:	e8 d4 a6 00 00       	call   f011006e <acquire_spinlock>
f010599a:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f010599d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01059a1:	75 19                	jne    f01059bc <sched_new_env+0x35>
f01059a3:	68 f3 58 12 f0       	push   $0xf01258f3
f01059a8:	68 ae 57 12 f0       	push   $0xf01257ae
f01059ad:	68 08 01 00 00       	push   $0x108
f01059b2:	68 c3 57 12 f0       	push   $0xf01257c3
f01059b7:	e8 7d a9 ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f01059bc:	83 ec 0c             	sub    $0xc,%esp
f01059bf:	ff 75 08             	pushl  0x8(%ebp)
f01059c2:	e8 e9 fc ff ff       	call   f01056b0 <sched_insert_new>
f01059c7:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059ca:	83 ec 0c             	sub    $0xc,%esp
f01059cd:	68 20 d2 75 f0       	push   $0xf075d220
f01059d2:	e8 1e a7 00 00       	call   f01100f5 <release_spinlock>
f01059d7:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01059da:	90                   	nop
f01059db:	c9                   	leave  
f01059dc:	c3                   	ret    

f01059dd <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01059dd:	55                   	push   %ebp
f01059de:	89 e5                	mov    %esp,%ebp
f01059e0:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059e3:	83 ec 0c             	sub    $0xc,%esp
f01059e6:	68 20 d2 75 f0       	push   $0xf075d220
f01059eb:	e8 7e a6 00 00       	call   f011006e <acquire_spinlock>
f01059f0:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01059f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01059fa:	a1 90 d2 75 f0       	mov    0xf075d290,%eax
f01059ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a02:	eb 53                	jmp    f0105a57 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105a04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a07:	8b 40 10             	mov    0x10(%eax),%eax
f0105a0a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a0d:	75 40                	jne    f0105a4f <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0105a0f:	83 ec 0c             	sub    $0xc,%esp
f0105a12:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a15:	e8 06 fd ff ff       	call   f0105720 <sched_remove_new>
f0105a1a:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f0105a1d:	83 ec 0c             	sub    $0xc,%esp
f0105a20:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a23:	e8 ad fa ff ff       	call   f01054d5 <sched_insert_ready>
f0105a28:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0105a2b:	e8 07 1a 00 00       	call   f0107437 <mycpu>
f0105a30:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105a36:	85 c0                	test   %eax,%eax
f0105a38:	75 46                	jne    f0105a80 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a3a:	83 ec 0c             	sub    $0xc,%esp
f0105a3d:	68 20 d2 75 f0       	push   $0xf075d220
f0105a42:	e8 ae a6 00 00       	call   f01100f5 <release_spinlock>
f0105a47:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105a4a:	e8 f6 0f 00 00       	call   f0106a45 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a4f:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0105a54:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a5b:	74 08                	je     f0105a65 <sched_run_env+0x88>
f0105a5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a60:	8b 40 08             	mov    0x8(%eax),%eax
f0105a63:	eb 05                	jmp    f0105a6a <sched_run_env+0x8d>
f0105a65:	b8 00 00 00 00       	mov    $0x0,%eax
f0105a6a:	a3 98 d2 75 f0       	mov    %eax,0xf075d298
f0105a6f:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0105a74:	85 c0                	test   %eax,%eax
f0105a76:	75 8c                	jne    f0105a04 <sched_run_env+0x27>
f0105a78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a7c:	75 86                	jne    f0105a04 <sched_run_env+0x27>
f0105a7e:	eb 01                	jmp    f0105a81 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105a80:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	68 20 d2 75 f0       	push   $0xf075d220
f0105a89:	e8 67 a6 00 00       	call   f01100f5 <release_spinlock>
f0105a8e:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105a91:	90                   	nop
f0105a92:	c9                   	leave  
f0105a93:	c3                   	ret    

f0105a94 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105a94:	55                   	push   %ebp
f0105a95:	89 e5                	mov    %esp,%ebp
f0105a97:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f0105a9a:	83 ec 0c             	sub    $0xc,%esp
f0105a9d:	68 20 d2 75 f0       	push   $0xf075d220
f0105aa2:	e8 e0 a7 00 00       	call   f0110287 <holding_spinlock>
f0105aa7:	83 c4 10             	add    $0x10,%esp
f0105aaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105aad:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105ab1:	75 10                	jne    f0105ac3 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105ab3:	83 ec 0c             	sub    $0xc,%esp
f0105ab6:	68 20 d2 75 f0       	push   $0xf075d220
f0105abb:	e8 ae a5 00 00       	call   f011006e <acquire_spinlock>
f0105ac0:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105ac3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105aca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105ad1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ad5:	75 59                	jne    f0105b30 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ad7:	a1 90 d2 75 f0       	mov    0xf075d290,%eax
f0105adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105adf:	eb 28                	jmp    f0105b09 <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ae4:	8b 40 10             	mov    0x10(%eax),%eax
f0105ae7:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105aea:	75 15                	jne    f0105b01 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105aec:	83 ec 0c             	sub    $0xc,%esp
f0105aef:	ff 75 f4             	pushl  -0xc(%ebp)
f0105af2:	e8 29 fc ff ff       	call   f0105720 <sched_remove_new>
f0105af7:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105afa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b01:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0105b06:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b0d:	74 08                	je     f0105b17 <sched_exit_env+0x83>
f0105b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b12:	8b 40 08             	mov    0x8(%eax),%eax
f0105b15:	eb 05                	jmp    f0105b1c <sched_exit_env+0x88>
f0105b17:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b1c:	a3 98 d2 75 f0       	mov    %eax,0xf075d298
f0105b21:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0105b26:	85 c0                	test   %eax,%eax
f0105b28:	75 b7                	jne    f0105ae1 <sched_exit_env+0x4d>
f0105b2a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b2e:	75 b1                	jne    f0105ae1 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105b30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b34:	0f 85 67 01 00 00    	jne    f0105ca1 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b41:	e9 47 01 00 00       	jmp    f0105c8d <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b46:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105b4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b4e:	c1 e2 04             	shl    $0x4,%edx
f0105b51:	01 d0                	add    %edx,%eax
f0105b53:	8b 00                	mov    (%eax),%eax
f0105b55:	85 c0                	test   %eax,%eax
f0105b57:	0f 84 27 01 00 00    	je     f0105c84 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0105b5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b64:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105b69:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b6c:	c1 e2 04             	shl    $0x4,%edx
f0105b6f:	01 d0                	add    %edx,%eax
f0105b71:	8b 00                	mov    (%eax),%eax
f0105b73:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b76:	e9 d1 00 00 00       	jmp    f0105c4c <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b7e:	8b 40 10             	mov    0x10(%eax),%eax
f0105b81:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b84:	0f 85 af 00 00 00    	jne    f0105c39 <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105b8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b8e:	75 17                	jne    f0105ba7 <sched_exit_env+0x113>
f0105b90:	83 ec 04             	sub    $0x4,%esp
f0105b93:	68 ff 57 12 f0       	push   $0xf01257ff
f0105b98:	68 56 01 00 00       	push   $0x156
f0105b9d:	68 c3 57 12 f0       	push   $0xf01257c3
f0105ba2:	e8 92 a7 ff ff       	call   f0100339 <_panic>
f0105ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105baa:	8b 40 08             	mov    0x8(%eax),%eax
f0105bad:	85 c0                	test   %eax,%eax
f0105baf:	74 11                	je     f0105bc2 <sched_exit_env+0x12e>
f0105bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb4:	8b 40 08             	mov    0x8(%eax),%eax
f0105bb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bba:	8b 52 0c             	mov    0xc(%edx),%edx
f0105bbd:	89 50 0c             	mov    %edx,0xc(%eax)
f0105bc0:	eb 16                	jmp    f0105bd8 <sched_exit_env+0x144>
f0105bc2:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105bc7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bca:	c1 e2 04             	shl    $0x4,%edx
f0105bcd:	01 c2                	add    %eax,%edx
f0105bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bd2:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bd5:	89 42 04             	mov    %eax,0x4(%edx)
f0105bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bdb:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bde:	85 c0                	test   %eax,%eax
f0105be0:	74 11                	je     f0105bf3 <sched_exit_env+0x15f>
f0105be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105be5:	8b 40 0c             	mov    0xc(%eax),%eax
f0105be8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105beb:	8b 52 08             	mov    0x8(%edx),%edx
f0105bee:	89 50 08             	mov    %edx,0x8(%eax)
f0105bf1:	eb 15                	jmp    f0105c08 <sched_exit_env+0x174>
f0105bf3:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105bf8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bfb:	c1 e2 04             	shl    $0x4,%edx
f0105bfe:	01 c2                	add    %eax,%edx
f0105c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c03:	8b 40 08             	mov    0x8(%eax),%eax
f0105c06:	89 02                	mov    %eax,(%edx)
f0105c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c0b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c15:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c1c:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105c21:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c24:	c1 e2 04             	shl    $0x4,%edx
f0105c27:	01 d0                	add    %edx,%eax
f0105c29:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c2c:	4a                   	dec    %edx
f0105c2d:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c30:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c37:	eb 4b                	jmp    f0105c84 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c39:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105c3e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c41:	c1 e2 04             	shl    $0x4,%edx
f0105c44:	01 d0                	add    %edx,%eax
f0105c46:	8b 40 08             	mov    0x8(%eax),%eax
f0105c49:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c4c:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105c51:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c54:	c1 e2 04             	shl    $0x4,%edx
f0105c57:	01 d0                	add    %edx,%eax
f0105c59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c5d:	74 08                	je     f0105c67 <sched_exit_env+0x1d3>
f0105c5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c62:	8b 52 08             	mov    0x8(%edx),%edx
f0105c65:	eb 05                	jmp    f0105c6c <sched_exit_env+0x1d8>
f0105c67:	ba 00 00 00 00       	mov    $0x0,%edx
f0105c6c:	89 50 08             	mov    %edx,0x8(%eax)
f0105c6f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c72:	85 c0                	test   %eax,%eax
f0105c74:	0f 85 01 ff ff ff    	jne    f0105b7b <sched_exit_env+0xe7>
f0105c7a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c7e:	0f 85 f7 fe ff ff    	jne    f0105b7b <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105c84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105c88:	75 16                	jne    f0105ca0 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105c8a:	ff 45 ec             	incl   -0x14(%ebp)
f0105c8d:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f0105c92:	0f b6 c0             	movzbl %al,%eax
f0105c95:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105c98:	0f 8f a8 fe ff ff    	jg     f0105b46 <sched_exit_env+0xb2>
f0105c9e:	eb 01                	jmp    f0105ca1 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105ca0:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105ca1:	e8 7f 60 00 00       	call   f010bd25 <get_cpu_proc>
f0105ca6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105ca9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105cad:	75 19                	jne    f0105cc8 <sched_exit_env+0x234>
f0105caf:	68 fb 58 12 f0       	push   $0xf01258fb
f0105cb4:	68 ae 57 12 f0       	push   $0xf01257ae
f0105cb9:	68 60 01 00 00       	push   $0x160
f0105cbe:	68 c3 57 12 f0       	push   $0xf01257c3
f0105cc3:	e8 71 a6 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105cc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ccc:	75 18                	jne    f0105ce6 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105cce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cd1:	8b 40 10             	mov    0x10(%eax),%eax
f0105cd4:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cd7:	75 0d                	jne    f0105ce6 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105cd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105cdf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105ce6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cea:	74 1e                	je     f0105d0a <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105cec:	83 ec 0c             	sub    $0xc,%esp
f0105cef:	ff 75 f4             	pushl  -0xc(%ebp)
f0105cf2:	e8 19 fb ff ff       	call   f0105810 <sched_insert_exit>
f0105cf7:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105cfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cfd:	8b 40 10             	mov    0x10(%eax),%eax
f0105d00:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d03:	75 05                	jne    f0105d0a <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105d05:	e8 9c 61 00 00       	call   f010bea6 <sched>
		}
	}
	if (!lock_already_held)
f0105d0a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d0e:	75 10                	jne    f0105d20 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105d10:	83 ec 0c             	sub    $0xc,%esp
f0105d13:	68 20 d2 75 f0       	push   $0xf075d220
f0105d18:	e8 d8 a3 00 00       	call   f01100f5 <release_spinlock>
f0105d1d:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105d20:	90                   	nop
f0105d21:	c9                   	leave  
f0105d22:	c3                   	ret    

f0105d23 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105d23:	55                   	push   %ebp
f0105d24:	89 e5                	mov    %esp,%ebp
f0105d26:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d29:	83 ec 0c             	sub    $0xc,%esp
f0105d2c:	68 20 d2 75 f0       	push   $0xf075d220
f0105d31:	e8 38 a3 00 00       	call   f011006e <acquire_spinlock>
f0105d36:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105d39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105d40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105d47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d4b:	75 79                	jne    f0105dc6 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105d4d:	a1 90 d2 75 f0       	mov    0xf075d290,%eax
f0105d52:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d55:	eb 48                	jmp    f0105d9f <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d5a:	8b 40 10             	mov    0x10(%eax),%eax
f0105d5d:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d60:	75 35                	jne    f0105d97 <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d65:	8d 50 20             	lea    0x20(%eax),%edx
f0105d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d6b:	8b 40 10             	mov    0x10(%eax),%eax
f0105d6e:	83 ec 04             	sub    $0x4,%esp
f0105d71:	52                   	push   %edx
f0105d72:	50                   	push   %eax
f0105d73:	68 0c 59 12 f0       	push   $0xf012590c
f0105d78:	e8 0e b2 ff ff       	call   f0100f8b <cprintf>
f0105d7d:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105d80:	83 ec 0c             	sub    $0xc,%esp
f0105d83:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d86:	e8 95 f9 ff ff       	call   f0105720 <sched_remove_new>
f0105d8b:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d8e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d95:	eb 2f                	jmp    f0105dc6 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105d97:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0105d9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d9f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105da3:	74 08                	je     f0105dad <sched_kill_env+0x8a>
f0105da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105da8:	8b 40 08             	mov    0x8(%eax),%eax
f0105dab:	eb 05                	jmp    f0105db2 <sched_kill_env+0x8f>
f0105dad:	b8 00 00 00 00       	mov    $0x0,%eax
f0105db2:	a3 98 d2 75 f0       	mov    %eax,0xf075d298
f0105db7:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0105dbc:	85 c0                	test   %eax,%eax
f0105dbe:	75 97                	jne    f0105d57 <sched_kill_env+0x34>
f0105dc0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105dc4:	75 91                	jne    f0105d57 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105dc6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105dca:	0f 85 85 01 00 00    	jne    f0105f55 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105dd0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105dd7:	e9 65 01 00 00       	jmp    f0105f41 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ddc:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105de1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105de4:	c1 e2 04             	shl    $0x4,%edx
f0105de7:	01 d0                	add    %edx,%eax
f0105de9:	8b 00                	mov    (%eax),%eax
f0105deb:	85 c0                	test   %eax,%eax
f0105ded:	0f 84 45 01 00 00    	je     f0105f38 <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105df3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105dfa:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105dff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e02:	c1 e2 04             	shl    $0x4,%edx
f0105e05:	01 d0                	add    %edx,%eax
f0105e07:	8b 00                	mov    (%eax),%eax
f0105e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e0c:	e9 ef 00 00 00       	jmp    f0105f00 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e14:	8b 40 10             	mov    0x10(%eax),%eax
f0105e17:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105e1a:	0f 85 cd 00 00 00    	jne    f0105eed <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e23:	8d 50 20             	lea    0x20(%eax),%edx
f0105e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e29:	8b 40 10             	mov    0x10(%eax),%eax
f0105e2c:	ff 75 ec             	pushl  -0x14(%ebp)
f0105e2f:	52                   	push   %edx
f0105e30:	50                   	push   %eax
f0105e31:	68 34 59 12 f0       	push   $0xf0125934
f0105e36:	e8 50 b1 ff ff       	call   f0100f8b <cprintf>
f0105e3b:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105e3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e42:	75 17                	jne    f0105e5b <sched_kill_env+0x138>
f0105e44:	83 ec 04             	sub    $0x4,%esp
f0105e47:	68 ff 57 12 f0       	push   $0xf01257ff
f0105e4c:	68 a3 01 00 00       	push   $0x1a3
f0105e51:	68 c3 57 12 f0       	push   $0xf01257c3
f0105e56:	e8 de a4 ff ff       	call   f0100339 <_panic>
f0105e5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e5e:	8b 40 08             	mov    0x8(%eax),%eax
f0105e61:	85 c0                	test   %eax,%eax
f0105e63:	74 11                	je     f0105e76 <sched_kill_env+0x153>
f0105e65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e68:	8b 40 08             	mov    0x8(%eax),%eax
f0105e6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e6e:	8b 52 0c             	mov    0xc(%edx),%edx
f0105e71:	89 50 0c             	mov    %edx,0xc(%eax)
f0105e74:	eb 16                	jmp    f0105e8c <sched_kill_env+0x169>
f0105e76:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105e7b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e7e:	c1 e2 04             	shl    $0x4,%edx
f0105e81:	01 c2                	add    %eax,%edx
f0105e83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e86:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e89:	89 42 04             	mov    %eax,0x4(%edx)
f0105e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e8f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e92:	85 c0                	test   %eax,%eax
f0105e94:	74 11                	je     f0105ea7 <sched_kill_env+0x184>
f0105e96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e99:	8b 40 0c             	mov    0xc(%eax),%eax
f0105e9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e9f:	8b 52 08             	mov    0x8(%edx),%edx
f0105ea2:	89 50 08             	mov    %edx,0x8(%eax)
f0105ea5:	eb 15                	jmp    f0105ebc <sched_kill_env+0x199>
f0105ea7:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105eac:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105eaf:	c1 e2 04             	shl    $0x4,%edx
f0105eb2:	01 c2                	add    %eax,%edx
f0105eb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eb7:	8b 40 08             	mov    0x8(%eax),%eax
f0105eba:	89 02                	mov    %eax,(%edx)
f0105ebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105ec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ec9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105ed0:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105ed5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ed8:	c1 e2 04             	shl    $0x4,%edx
f0105edb:	01 d0                	add    %edx,%eax
f0105edd:	8b 50 0c             	mov    0xc(%eax),%edx
f0105ee0:	4a                   	dec    %edx
f0105ee1:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105ee4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105eeb:	eb 4b                	jmp    f0105f38 <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105eed:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105ef2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ef5:	c1 e2 04             	shl    $0x4,%edx
f0105ef8:	01 d0                	add    %edx,%eax
f0105efa:	8b 40 08             	mov    0x8(%eax),%eax
f0105efd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f00:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0105f05:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105f08:	c1 e2 04             	shl    $0x4,%edx
f0105f0b:	01 d0                	add    %edx,%eax
f0105f0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f11:	74 08                	je     f0105f1b <sched_kill_env+0x1f8>
f0105f13:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f16:	8b 52 08             	mov    0x8(%edx),%edx
f0105f19:	eb 05                	jmp    f0105f20 <sched_kill_env+0x1fd>
f0105f1b:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f20:	89 50 08             	mov    %edx,0x8(%eax)
f0105f23:	8b 40 08             	mov    0x8(%eax),%eax
f0105f26:	85 c0                	test   %eax,%eax
f0105f28:	0f 85 e3 fe ff ff    	jne    f0105e11 <sched_kill_env+0xee>
f0105f2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f32:	0f 85 d9 fe ff ff    	jne    f0105e11 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105f38:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f3c:	75 16                	jne    f0105f54 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f3e:	ff 45 ec             	incl   -0x14(%ebp)
f0105f41:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f0105f46:	0f b6 c0             	movzbl %al,%eax
f0105f49:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105f4c:	0f 8f 8a fe ff ff    	jg     f0105ddc <sched_kill_env+0xb9>
f0105f52:	eb 01                	jmp    f0105f55 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105f54:	90                   	nop
		}
	}
	if (!found)
f0105f55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f59:	0f 85 80 00 00 00    	jne    f0105fdf <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105f5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105f66:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f0105f6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f6e:	eb 48                	jmp    f0105fb8 <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105f70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f73:	8b 40 10             	mov    0x10(%eax),%eax
f0105f76:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105f79:	75 35                	jne    f0105fb0 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105f7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f7e:	8d 50 20             	lea    0x20(%eax),%edx
f0105f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f84:	8b 40 10             	mov    0x10(%eax),%eax
f0105f87:	83 ec 04             	sub    $0x4,%esp
f0105f8a:	52                   	push   %edx
f0105f8b:	50                   	push   %eax
f0105f8c:	68 60 59 12 f0       	push   $0xf0125960
f0105f91:	e8 f5 af ff ff       	call   f0100f8b <cprintf>
f0105f96:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105f99:	83 ec 0c             	sub    $0xc,%esp
f0105f9c:	ff 75 f4             	pushl  -0xc(%ebp)
f0105f9f:	e8 f3 f8 ff ff       	call   f0105897 <sched_remove_exit>
f0105fa4:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105fa7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105fae:	eb 2f                	jmp    f0105fdf <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fb0:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f0105fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fb8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fbc:	74 08                	je     f0105fc6 <sched_kill_env+0x2a3>
f0105fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fc1:	8b 40 08             	mov    0x8(%eax),%eax
f0105fc4:	eb 05                	jmp    f0105fcb <sched_kill_env+0x2a8>
f0105fc6:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fcb:	a3 a8 d2 75 f0       	mov    %eax,0xf075d2a8
f0105fd0:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f0105fd5:	85 c0                	test   %eax,%eax
f0105fd7:	75 97                	jne    f0105f70 <sched_kill_env+0x24d>
f0105fd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fdd:	75 91                	jne    f0105f70 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105fdf:	83 ec 0c             	sub    $0xc,%esp
f0105fe2:	68 20 d2 75 f0       	push   $0xf075d220
f0105fe7:	e8 09 a1 00 00       	call   f01100f5 <release_spinlock>
f0105fec:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105fef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ff3:	74 23                	je     f0106018 <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105ff5:	83 ec 0c             	sub    $0xc,%esp
f0105ff8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ffb:	e8 dd 5c 00 00       	call   f010bcdd <env_free>
f0106000:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106003:	83 ec 0c             	sub    $0xc,%esp
f0106006:	68 86 59 12 f0       	push   $0xf0125986
f010600b:	e8 7b af ff ff       	call   f0100f8b <cprintf>
f0106010:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0106013:	e9 a4 00 00 00       	jmp    f01060bc <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0106018:	e8 08 5d 00 00       	call   f010bd25 <get_cpu_proc>
f010601d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106020:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106024:	75 19                	jne    f010603f <sched_kill_env+0x31c>
f0106026:	68 fb 58 12 f0       	push   $0xf01258fb
f010602b:	68 ae 57 12 f0       	push   $0xf01257ae
f0106030:	68 c5 01 00 00       	push   $0x1c5
f0106035:	68 c3 57 12 f0       	push   $0xf01257c3
f010603a:	e8 fa a2 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f010603f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106042:	8b 40 10             	mov    0x10(%eax),%eax
f0106045:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106048:	75 72                	jne    f01060bc <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f010604a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010604d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106053:	8b 40 18             	mov    0x18(%eax),%eax
f0106056:	83 f8 02             	cmp    $0x2,%eax
f0106059:	74 19                	je     f0106074 <sched_kill_env+0x351>
f010605b:	68 8c 59 12 f0       	push   $0xf012598c
f0106060:	68 ae 57 12 f0       	push   $0xf01257ae
f0106065:	68 ca 01 00 00       	push   $0x1ca
f010606a:	68 c3 57 12 f0       	push   $0xf01257c3
f010606f:	e8 c5 a2 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106074:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106077:	8d 50 20             	lea    0x20(%eax),%edx
f010607a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010607d:	8b 40 10             	mov    0x10(%eax),%eax
f0106080:	83 ec 04             	sub    $0x4,%esp
f0106083:	52                   	push   %edx
f0106084:	50                   	push   %eax
f0106085:	68 b0 59 12 f0       	push   $0xf01259b0
f010608a:	e8 fc ae ff ff       	call   f0100f8b <cprintf>
f010608f:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106092:	83 ec 0c             	sub    $0xc,%esp
f0106095:	ff 75 f4             	pushl  -0xc(%ebp)
f0106098:	e8 40 5c 00 00       	call   f010bcdd <env_free>
f010609d:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01060a0:	83 ec 0c             	sub    $0xc,%esp
f01060a3:	68 86 59 12 f0       	push   $0xf0125986
f01060a8:	e8 de ae ff ff       	call   f0100f8b <cprintf>
f01060ad:	83 c4 10             	add    $0x10,%esp
			found = 1;
f01060b0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f01060b7:	e8 ea 5d 00 00       	call   f010bea6 <sched>
		}
	}

}
f01060bc:	90                   	nop
f01060bd:	c9                   	leave  
f01060be:	c3                   	ret    

f01060bf <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f01060bf:	55                   	push   %ebp
f01060c0:	89 e5                	mov    %esp,%ebp
f01060c2:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060c5:	83 ec 0c             	sub    $0xc,%esp
f01060c8:	68 20 d2 75 f0       	push   $0xf075d220
f01060cd:	e8 9c 9f 00 00       	call   f011006e <acquire_spinlock>
f01060d2:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060d5:	a1 90 d2 75 f0       	mov    0xf075d290,%eax
f01060da:	85 c0                	test   %eax,%eax
f01060dc:	74 69                	je     f0106147 <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f01060de:	83 ec 0c             	sub    $0xc,%esp
f01060e1:	68 dc 59 12 f0       	push   $0xf01259dc
f01060e6:	e8 a0 ae ff ff       	call   f0100f8b <cprintf>
f01060eb:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01060ee:	a1 90 d2 75 f0       	mov    0xf075d290,%eax
f01060f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060f6:	eb 26                	jmp    f010611e <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01060f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060fb:	8d 50 20             	lea    0x20(%eax),%edx
f01060fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106101:	8b 40 10             	mov    0x10(%eax),%eax
f0106104:	83 ec 04             	sub    $0x4,%esp
f0106107:	52                   	push   %edx
f0106108:	50                   	push   %eax
f0106109:	68 fe 59 12 f0       	push   $0xf01259fe
f010610e:	e8 78 ae ff ff       	call   f0100f8b <cprintf>
f0106113:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106116:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f010611b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010611e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106122:	74 08                	je     f010612c <sched_print_all+0x6d>
f0106124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106127:	8b 40 08             	mov    0x8(%eax),%eax
f010612a:	eb 05                	jmp    f0106131 <sched_print_all+0x72>
f010612c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106131:	a3 98 d2 75 f0       	mov    %eax,0xf075d298
f0106136:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f010613b:	85 c0                	test   %eax,%eax
f010613d:	75 b9                	jne    f01060f8 <sched_print_all+0x39>
f010613f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106143:	75 b3                	jne    f01060f8 <sched_print_all+0x39>
f0106145:	eb 10                	jmp    f0106157 <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0106147:	83 ec 0c             	sub    $0xc,%esp
f010614a:	68 08 5a 12 f0       	push   $0xf0125a08
f010614f:	e8 37 ae ff ff       	call   f0100f8b <cprintf>
f0106154:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106157:	83 ec 0c             	sub    $0xc,%esp
f010615a:	68 24 5a 12 f0       	push   $0xf0125a24
f010615f:	e8 27 ae ff ff       	call   f0100f8b <cprintf>
f0106164:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106167:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010616e:	e9 c7 00 00 00       	jmp    f010623a <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106173:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106178:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010617b:	c1 e2 04             	shl    $0x4,%edx
f010617e:	01 d0                	add    %edx,%eax
f0106180:	8b 00                	mov    (%eax),%eax
f0106182:	85 c0                	test   %eax,%eax
f0106184:	0f 84 8a 00 00 00    	je     f0106214 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f010618a:	83 ec 08             	sub    $0x8,%esp
f010618d:	ff 75 f0             	pushl  -0x10(%ebp)
f0106190:	68 58 5a 12 f0       	push   $0xf0125a58
f0106195:	e8 f1 ad ff ff       	call   f0100f8b <cprintf>
f010619a:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010619d:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f01061a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061a5:	c1 e2 04             	shl    $0x4,%edx
f01061a8:	01 d0                	add    %edx,%eax
f01061aa:	8b 00                	mov    (%eax),%eax
f01061ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061af:	eb 31                	jmp    f01061e2 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01061b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061b4:	8d 50 20             	lea    0x20(%eax),%edx
f01061b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061ba:	8b 40 10             	mov    0x10(%eax),%eax
f01061bd:	83 ec 04             	sub    $0x4,%esp
f01061c0:	52                   	push   %edx
f01061c1:	50                   	push   %eax
f01061c2:	68 fe 59 12 f0       	push   $0xf01259fe
f01061c7:	e8 bf ad ff ff       	call   f0100f8b <cprintf>
f01061cc:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061cf:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f01061d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061d7:	c1 e2 04             	shl    $0x4,%edx
f01061da:	01 d0                	add    %edx,%eax
f01061dc:	8b 40 08             	mov    0x8(%eax),%eax
f01061df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061e2:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f01061e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061ea:	c1 e2 04             	shl    $0x4,%edx
f01061ed:	01 d0                	add    %edx,%eax
f01061ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061f3:	74 08                	je     f01061fd <sched_print_all+0x13e>
f01061f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01061f8:	8b 52 08             	mov    0x8(%edx),%edx
f01061fb:	eb 05                	jmp    f0106202 <sched_print_all+0x143>
f01061fd:	ba 00 00 00 00       	mov    $0x0,%edx
f0106202:	89 50 08             	mov    %edx,0x8(%eax)
f0106205:	8b 40 08             	mov    0x8(%eax),%eax
f0106208:	85 c0                	test   %eax,%eax
f010620a:	75 a5                	jne    f01061b1 <sched_print_all+0xf2>
f010620c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106210:	75 9f                	jne    f01061b1 <sched_print_all+0xf2>
f0106212:	eb 13                	jmp    f0106227 <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0106214:	83 ec 08             	sub    $0x8,%esp
f0106217:	ff 75 f0             	pushl  -0x10(%ebp)
f010621a:	68 80 5a 12 f0       	push   $0xf0125a80
f010621f:	e8 67 ad ff ff       	call   f0100f8b <cprintf>
f0106224:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106227:	83 ec 0c             	sub    $0xc,%esp
f010622a:	68 24 5a 12 f0       	push   $0xf0125a24
f010622f:	e8 57 ad ff ff       	call   f0100f8b <cprintf>
f0106234:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106237:	ff 45 f0             	incl   -0x10(%ebp)
f010623a:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f010623f:	0f b6 c0             	movzbl %al,%eax
f0106242:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106245:	0f 8f 28 ff ff ff    	jg     f0106173 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f010624b:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f0106250:	85 c0                	test   %eax,%eax
f0106252:	74 69                	je     f01062bd <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0106254:	83 ec 0c             	sub    $0xc,%esp
f0106257:	68 a4 5a 12 f0       	push   $0xf0125aa4
f010625c:	e8 2a ad ff ff       	call   f0100f8b <cprintf>
f0106261:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106264:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f0106269:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010626c:	eb 26                	jmp    f0106294 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f010626e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106271:	8d 50 20             	lea    0x20(%eax),%edx
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 10             	mov    0x10(%eax),%eax
f010627a:	83 ec 04             	sub    $0x4,%esp
f010627d:	52                   	push   %edx
f010627e:	50                   	push   %eax
f010627f:	68 fe 59 12 f0       	push   $0xf01259fe
f0106284:	e8 02 ad ff ff       	call   f0100f8b <cprintf>
f0106289:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010628c:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f0106291:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106294:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106298:	74 08                	je     f01062a2 <sched_print_all+0x1e3>
f010629a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629d:	8b 40 08             	mov    0x8(%eax),%eax
f01062a0:	eb 05                	jmp    f01062a7 <sched_print_all+0x1e8>
f01062a2:	b8 00 00 00 00       	mov    $0x0,%eax
f01062a7:	a3 a8 d2 75 f0       	mov    %eax,0xf075d2a8
f01062ac:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f01062b1:	85 c0                	test   %eax,%eax
f01062b3:	75 b9                	jne    f010626e <sched_print_all+0x1af>
f01062b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062b9:	75 b3                	jne    f010626e <sched_print_all+0x1af>
f01062bb:	eb 10                	jmp    f01062cd <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01062bd:	83 ec 0c             	sub    $0xc,%esp
f01062c0:	68 c6 5a 12 f0       	push   $0xf0125ac6
f01062c5:	e8 c1 ac ff ff       	call   f0100f8b <cprintf>
f01062ca:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01062cd:	83 ec 0c             	sub    $0xc,%esp
f01062d0:	68 20 d2 75 f0       	push   $0xf075d220
f01062d5:	e8 1b 9e 00 00       	call   f01100f5 <release_spinlock>
f01062da:	83 c4 10             	add    $0x10,%esp
}
f01062dd:	90                   	nop
f01062de:	c9                   	leave  
f01062df:	c3                   	ret    

f01062e0 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f01062e0:	55                   	push   %ebp
f01062e1:	89 e5                	mov    %esp,%ebp
f01062e3:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01062e6:	83 ec 0c             	sub    $0xc,%esp
f01062e9:	68 20 d2 75 f0       	push   $0xf075d220
f01062ee:	e8 7b 9d 00 00       	call   f011006e <acquire_spinlock>
f01062f3:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01062f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f01062fd:	a1 9c d2 75 f0       	mov    0xf075d29c,%eax
f0106302:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0106305:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010630c:	eb 24                	jmp    f0106332 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f010630e:	83 ec 0c             	sub    $0xc,%esp
f0106311:	68 90 d2 75 f0       	push   $0xf075d290
f0106316:	e8 0e ef ff ff       	call   f0105229 <dequeue>
f010631b:	83 c4 10             	add    $0x10,%esp
f010631e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0106321:	83 ec 0c             	sub    $0xc,%esp
f0106324:	ff 75 f0             	pushl  -0x10(%ebp)
f0106327:	e8 a9 f1 ff ff       	call   f01054d5 <sched_insert_ready>
f010632c:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f010632f:	ff 45 f4             	incl   -0xc(%ebp)
f0106332:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106335:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106338:	7c d4                	jl     f010630e <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010633a:	83 ec 0c             	sub    $0xc,%esp
f010633d:	68 20 d2 75 f0       	push   $0xf075d220
f0106342:	e8 ae 9d 00 00       	call   f01100f5 <release_spinlock>
f0106347:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f010634a:	e8 e8 10 00 00       	call   f0107437 <mycpu>
f010634f:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106355:	85 c0                	test   %eax,%eax
f0106357:	75 05                	jne    f010635e <sched_run_all+0x7e>
		fos_scheduler();
f0106359:	e8 e7 06 00 00       	call   f0106a45 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f010635e:	83 ec 04             	sub    $0x4,%esp
f0106361:	68 e4 5a 12 f0       	push   $0xf0125ae4
f0106366:	68 27 02 00 00       	push   $0x227
f010636b:	68 c3 57 12 f0       	push   $0xf01257c3
f0106370:	e8 c4 9f ff ff       	call   f0100339 <_panic>

f0106375 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f0106375:	55                   	push   %ebp
f0106376:	89 e5                	mov    %esp,%ebp
f0106378:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010637b:	83 ec 0c             	sub    $0xc,%esp
f010637e:	68 20 d2 75 f0       	push   $0xf075d220
f0106383:	e8 e6 9c 00 00       	call   f011006e <acquire_spinlock>
f0106388:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f010638b:	a1 90 d2 75 f0       	mov    0xf075d290,%eax
f0106390:	85 c0                	test   %eax,%eax
f0106392:	0f 84 95 00 00 00    	je     f010642d <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f0106398:	83 ec 0c             	sub    $0xc,%esp
f010639b:	68 20 5b 12 f0       	push   $0xf0125b20
f01063a0:	e8 e6 ab ff ff       	call   f0100f8b <cprintf>
f01063a5:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01063a8:	a1 90 d2 75 f0       	mov    0xf075d290,%eax
f01063ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063b0:	eb 52                	jmp    f0106404 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063b5:	8d 50 20             	lea    0x20(%eax),%edx
f01063b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bb:	8b 40 10             	mov    0x10(%eax),%eax
f01063be:	83 ec 04             	sub    $0x4,%esp
f01063c1:	52                   	push   %edx
f01063c2:	50                   	push   %eax
f01063c3:	68 4c 5b 12 f0       	push   $0xf0125b4c
f01063c8:	e8 be ab ff ff       	call   f0100f8b <cprintf>
f01063cd:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01063d0:	83 ec 0c             	sub    $0xc,%esp
f01063d3:	ff 75 f4             	pushl  -0xc(%ebp)
f01063d6:	e8 45 f3 ff ff       	call   f0105720 <sched_remove_new>
f01063db:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063de:	83 ec 0c             	sub    $0xc,%esp
f01063e1:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e4:	e8 f4 58 00 00       	call   f010bcdd <env_free>
f01063e9:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063ec:	83 ec 0c             	sub    $0xc,%esp
f01063ef:	68 86 59 12 f0       	push   $0xf0125986
f01063f4:	e8 92 ab ff ff       	call   f0100f8b <cprintf>
f01063f9:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01063fc:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0106401:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106404:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106408:	74 08                	je     f0106412 <sched_kill_all+0x9d>
f010640a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010640d:	8b 40 08             	mov    0x8(%eax),%eax
f0106410:	eb 05                	jmp    f0106417 <sched_kill_all+0xa2>
f0106412:	b8 00 00 00 00       	mov    $0x0,%eax
f0106417:	a3 98 d2 75 f0       	mov    %eax,0xf075d298
f010641c:	a1 98 d2 75 f0       	mov    0xf075d298,%eax
f0106421:	85 c0                	test   %eax,%eax
f0106423:	75 8d                	jne    f01063b2 <sched_kill_all+0x3d>
f0106425:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106429:	75 87                	jne    f01063b2 <sched_kill_all+0x3d>
f010642b:	eb 10                	jmp    f010643d <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f010642d:	83 ec 0c             	sub    $0xc,%esp
f0106430:	68 5f 5b 12 f0       	push   $0xf0125b5f
f0106435:	e8 51 ab ff ff       	call   f0100f8b <cprintf>
f010643a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f010643d:	83 ec 0c             	sub    $0xc,%esp
f0106440:	68 24 5a 12 f0       	push   $0xf0125a24
f0106445:	e8 41 ab ff ff       	call   f0100f8b <cprintf>
f010644a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010644d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106454:	e9 96 01 00 00       	jmp    f01065ef <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106459:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010645e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106461:	c1 e2 04             	shl    $0x4,%edx
f0106464:	01 d0                	add    %edx,%eax
f0106466:	8b 00                	mov    (%eax),%eax
f0106468:	85 c0                	test   %eax,%eax
f010646a:	0f 84 59 01 00 00    	je     f01065c9 <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106470:	83 ec 08             	sub    $0x8,%esp
f0106473:	ff 75 f0             	pushl  -0x10(%ebp)
f0106476:	68 7c 5b 12 f0       	push   $0xf0125b7c
f010647b:	e8 0b ab ff ff       	call   f0100f8b <cprintf>
f0106480:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106483:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106488:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010648b:	c1 e2 04             	shl    $0x4,%edx
f010648e:	01 d0                	add    %edx,%eax
f0106490:	8b 00                	mov    (%eax),%eax
f0106492:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106495:	e9 f5 00 00 00       	jmp    f010658f <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010649a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010649d:	8d 50 20             	lea    0x20(%eax),%edx
f01064a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064a3:	8b 40 10             	mov    0x10(%eax),%eax
f01064a6:	83 ec 04             	sub    $0x4,%esp
f01064a9:	52                   	push   %edx
f01064aa:	50                   	push   %eax
f01064ab:	68 4c 5b 12 f0       	push   $0xf0125b4c
f01064b0:	e8 d6 aa ff ff       	call   f0100f8b <cprintf>
f01064b5:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01064b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01064bc:	75 17                	jne    f01064d5 <sched_kill_all+0x160>
f01064be:	83 ec 04             	sub    $0x4,%esp
f01064c1:	68 ff 57 12 f0       	push   $0xf01257ff
f01064c6:	68 49 02 00 00       	push   $0x249
f01064cb:	68 c3 57 12 f0       	push   $0xf01257c3
f01064d0:	e8 64 9e ff ff       	call   f0100339 <_panic>
f01064d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064d8:	8b 40 08             	mov    0x8(%eax),%eax
f01064db:	85 c0                	test   %eax,%eax
f01064dd:	74 11                	je     f01064f0 <sched_kill_all+0x17b>
f01064df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064e2:	8b 40 08             	mov    0x8(%eax),%eax
f01064e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01064e8:	8b 52 0c             	mov    0xc(%edx),%edx
f01064eb:	89 50 0c             	mov    %edx,0xc(%eax)
f01064ee:	eb 16                	jmp    f0106506 <sched_kill_all+0x191>
f01064f0:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f01064f5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064f8:	c1 e2 04             	shl    $0x4,%edx
f01064fb:	01 c2                	add    %eax,%edx
f01064fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106500:	8b 40 0c             	mov    0xc(%eax),%eax
f0106503:	89 42 04             	mov    %eax,0x4(%edx)
f0106506:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106509:	8b 40 0c             	mov    0xc(%eax),%eax
f010650c:	85 c0                	test   %eax,%eax
f010650e:	74 11                	je     f0106521 <sched_kill_all+0x1ac>
f0106510:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106513:	8b 40 0c             	mov    0xc(%eax),%eax
f0106516:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106519:	8b 52 08             	mov    0x8(%edx),%edx
f010651c:	89 50 08             	mov    %edx,0x8(%eax)
f010651f:	eb 15                	jmp    f0106536 <sched_kill_all+0x1c1>
f0106521:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106526:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106529:	c1 e2 04             	shl    $0x4,%edx
f010652c:	01 c2                	add    %eax,%edx
f010652e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106531:	8b 40 08             	mov    0x8(%eax),%eax
f0106534:	89 02                	mov    %eax,(%edx)
f0106536:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106539:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106540:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106543:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010654a:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010654f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106552:	c1 e2 04             	shl    $0x4,%edx
f0106555:	01 d0                	add    %edx,%eax
f0106557:	8b 50 0c             	mov    0xc(%eax),%edx
f010655a:	4a                   	dec    %edx
f010655b:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f010655e:	83 ec 0c             	sub    $0xc,%esp
f0106561:	ff 75 f4             	pushl  -0xc(%ebp)
f0106564:	e8 74 57 00 00       	call   f010bcdd <env_free>
f0106569:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f010656c:	83 ec 0c             	sub    $0xc,%esp
f010656f:	68 86 59 12 f0       	push   $0xf0125986
f0106574:	e8 12 aa ff ff       	call   f0100f8b <cprintf>
f0106579:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010657c:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106581:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106584:	c1 e2 04             	shl    $0x4,%edx
f0106587:	01 d0                	add    %edx,%eax
f0106589:	8b 40 08             	mov    0x8(%eax),%eax
f010658c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010658f:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106594:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106597:	c1 e2 04             	shl    $0x4,%edx
f010659a:	01 d0                	add    %edx,%eax
f010659c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065a0:	74 08                	je     f01065aa <sched_kill_all+0x235>
f01065a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065a5:	8b 52 08             	mov    0x8(%edx),%edx
f01065a8:	eb 05                	jmp    f01065af <sched_kill_all+0x23a>
f01065aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01065af:	89 50 08             	mov    %edx,0x8(%eax)
f01065b2:	8b 40 08             	mov    0x8(%eax),%eax
f01065b5:	85 c0                	test   %eax,%eax
f01065b7:	0f 85 dd fe ff ff    	jne    f010649a <sched_kill_all+0x125>
f01065bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065c1:	0f 85 d3 fe ff ff    	jne    f010649a <sched_kill_all+0x125>
f01065c7:	eb 13                	jmp    f01065dc <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01065c9:	83 ec 08             	sub    $0x8,%esp
f01065cc:	ff 75 f0             	pushl  -0x10(%ebp)
f01065cf:	68 80 5a 12 f0       	push   $0xf0125a80
f01065d4:	e8 b2 a9 ff ff       	call   f0100f8b <cprintf>
f01065d9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01065dc:	83 ec 0c             	sub    $0xc,%esp
f01065df:	68 24 5a 12 f0       	push   $0xf0125a24
f01065e4:	e8 a2 a9 ff ff       	call   f0100f8b <cprintf>
f01065e9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01065ec:	ff 45 f0             	incl   -0x10(%ebp)
f01065ef:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f01065f4:	0f b6 c0             	movzbl %al,%eax
f01065f7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01065fa:	0f 8f 59 fe ff ff    	jg     f0106459 <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106600:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f0106605:	85 c0                	test   %eax,%eax
f0106607:	0f 84 95 00 00 00    	je     f01066a2 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f010660d:	83 ec 0c             	sub    $0xc,%esp
f0106610:	68 b0 5b 12 f0       	push   $0xf0125bb0
f0106615:	e8 71 a9 ff ff       	call   f0100f8b <cprintf>
f010661a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010661d:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f0106622:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106625:	eb 52                	jmp    f0106679 <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106627:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010662a:	8d 50 20             	lea    0x20(%eax),%edx
f010662d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106630:	8b 40 10             	mov    0x10(%eax),%eax
f0106633:	83 ec 04             	sub    $0x4,%esp
f0106636:	52                   	push   %edx
f0106637:	50                   	push   %eax
f0106638:	68 4c 5b 12 f0       	push   $0xf0125b4c
f010663d:	e8 49 a9 ff ff       	call   f0100f8b <cprintf>
f0106642:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f0106645:	83 ec 0c             	sub    $0xc,%esp
f0106648:	ff 75 f4             	pushl  -0xc(%ebp)
f010664b:	e8 47 f2 ff ff       	call   f0105897 <sched_remove_exit>
f0106650:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106653:	83 ec 0c             	sub    $0xc,%esp
f0106656:	ff 75 f4             	pushl  -0xc(%ebp)
f0106659:	e8 7f 56 00 00       	call   f010bcdd <env_free>
f010665e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106661:	83 ec 0c             	sub    $0xc,%esp
f0106664:	68 86 59 12 f0       	push   $0xf0125986
f0106669:	e8 1d a9 ff ff       	call   f0100f8b <cprintf>
f010666e:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106671:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f0106676:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106679:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010667d:	74 08                	je     f0106687 <sched_kill_all+0x312>
f010667f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106682:	8b 40 08             	mov    0x8(%eax),%eax
f0106685:	eb 05                	jmp    f010668c <sched_kill_all+0x317>
f0106687:	b8 00 00 00 00       	mov    $0x0,%eax
f010668c:	a3 a8 d2 75 f0       	mov    %eax,0xf075d2a8
f0106691:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f0106696:	85 c0                	test   %eax,%eax
f0106698:	75 8d                	jne    f0106627 <sched_kill_all+0x2b2>
f010669a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010669e:	75 87                	jne    f0106627 <sched_kill_all+0x2b2>
f01066a0:	eb 10                	jmp    f01066b2 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01066a2:	83 ec 0c             	sub    $0xc,%esp
f01066a5:	68 c6 5a 12 f0       	push   $0xf0125ac6
f01066aa:	e8 dc a8 ff ff       	call   f0100f8b <cprintf>
f01066af:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01066b2:	e8 6e 56 00 00       	call   f010bd25 <get_cpu_proc>
f01066b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01066ba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01066be:	74 6b                	je     f010672b <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01066c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01066c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01066c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066c9:	8b 40 18             	mov    0x18(%eax),%eax
f01066cc:	83 f8 02             	cmp    $0x2,%eax
f01066cf:	74 19                	je     f01066ea <sched_kill_all+0x375>
f01066d1:	68 8c 59 12 f0       	push   $0xf012598c
f01066d6:	68 ae 57 12 f0       	push   $0xf01257ae
f01066db:	68 69 02 00 00       	push   $0x269
f01066e0:	68 c3 57 12 f0       	push   $0xf01257c3
f01066e5:	e8 4f 9c ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01066ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066ed:	8d 50 20             	lea    0x20(%eax),%edx
f01066f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066f3:	8b 40 10             	mov    0x10(%eax),%eax
f01066f6:	83 ec 04             	sub    $0x4,%esp
f01066f9:	52                   	push   %edx
f01066fa:	50                   	push   %eax
f01066fb:	68 b0 59 12 f0       	push   $0xf01259b0
f0106700:	e8 86 a8 ff ff       	call   f0100f8b <cprintf>
f0106705:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f0106708:	83 ec 0c             	sub    $0xc,%esp
f010670b:	ff 75 f4             	pushl  -0xc(%ebp)
f010670e:	e8 ca 55 00 00       	call   f010bcdd <env_free>
f0106713:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106716:	83 ec 0c             	sub    $0xc,%esp
f0106719:	68 86 59 12 f0       	push   $0xf0125986
f010671e:	e8 68 a8 ff ff       	call   f0100f8b <cprintf>
f0106723:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f0106726:	e8 7b 57 00 00       	call   f010bea6 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010672b:	83 ec 0c             	sub    $0xc,%esp
f010672e:	68 20 d2 75 f0       	push   $0xf075d220
f0106733:	e8 bd 99 00 00       	call   f01100f5 <release_spinlock>
f0106738:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f010673b:	e8 82 b6 ff ff       	call   f0101dc2 <get_into_prompt>

f0106740 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0106740:	55                   	push   %ebp
f0106741:	89 e5                	mov    %esp,%ebp
f0106743:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106746:	83 ec 0c             	sub    $0xc,%esp
f0106749:	68 20 d2 75 f0       	push   $0xf075d220
f010674e:	e8 1b 99 00 00       	call   f011006e <acquire_spinlock>
f0106753:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106756:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010675d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106764:	e9 37 01 00 00       	jmp    f01068a0 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106769:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010676e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106771:	c1 e2 04             	shl    $0x4,%edx
f0106774:	01 d0                	add    %edx,%eax
f0106776:	8b 00                	mov    (%eax),%eax
f0106778:	85 c0                	test   %eax,%eax
f010677a:	0f 84 1d 01 00 00    	je     f010689d <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106780:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106787:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010678c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010678f:	c1 e2 04             	shl    $0x4,%edx
f0106792:	01 d0                	add    %edx,%eax
f0106794:	8b 00                	mov    (%eax),%eax
f0106796:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106799:	e9 c7 00 00 00       	jmp    f0106865 <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010679e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01067a2:	75 17                	jne    f01067bb <sched_exit_all_ready_envs+0x7b>
f01067a4:	83 ec 04             	sub    $0x4,%esp
f01067a7:	68 ff 57 12 f0       	push   $0xf01257ff
f01067ac:	68 8b 02 00 00       	push   $0x28b
f01067b1:	68 c3 57 12 f0       	push   $0xf01257c3
f01067b6:	e8 7e 9b ff ff       	call   f0100339 <_panic>
f01067bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067be:	8b 40 08             	mov    0x8(%eax),%eax
f01067c1:	85 c0                	test   %eax,%eax
f01067c3:	74 11                	je     f01067d6 <sched_exit_all_ready_envs+0x96>
f01067c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067c8:	8b 40 08             	mov    0x8(%eax),%eax
f01067cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01067ce:	8b 52 0c             	mov    0xc(%edx),%edx
f01067d1:	89 50 0c             	mov    %edx,0xc(%eax)
f01067d4:	eb 16                	jmp    f01067ec <sched_exit_all_ready_envs+0xac>
f01067d6:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f01067db:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01067de:	c1 e2 04             	shl    $0x4,%edx
f01067e1:	01 c2                	add    %eax,%edx
f01067e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067e6:	8b 40 0c             	mov    0xc(%eax),%eax
f01067e9:	89 42 04             	mov    %eax,0x4(%edx)
f01067ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067ef:	8b 40 0c             	mov    0xc(%eax),%eax
f01067f2:	85 c0                	test   %eax,%eax
f01067f4:	74 11                	je     f0106807 <sched_exit_all_ready_envs+0xc7>
f01067f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067f9:	8b 40 0c             	mov    0xc(%eax),%eax
f01067fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01067ff:	8b 52 08             	mov    0x8(%edx),%edx
f0106802:	89 50 08             	mov    %edx,0x8(%eax)
f0106805:	eb 15                	jmp    f010681c <sched_exit_all_ready_envs+0xdc>
f0106807:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010680c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010680f:	c1 e2 04             	shl    $0x4,%edx
f0106812:	01 c2                	add    %eax,%edx
f0106814:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106817:	8b 40 08             	mov    0x8(%eax),%eax
f010681a:	89 02                	mov    %eax,(%edx)
f010681c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010681f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106826:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106829:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106830:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106835:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106838:	c1 e2 04             	shl    $0x4,%edx
f010683b:	01 d0                	add    %edx,%eax
f010683d:	8b 50 0c             	mov    0xc(%eax),%edx
f0106840:	4a                   	dec    %edx
f0106841:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f0106844:	83 ec 0c             	sub    $0xc,%esp
f0106847:	ff 75 f4             	pushl  -0xc(%ebp)
f010684a:	e8 c1 ef ff ff       	call   f0105810 <sched_insert_exit>
f010684f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106852:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106857:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010685a:	c1 e2 04             	shl    $0x4,%edx
f010685d:	01 d0                	add    %edx,%eax
f010685f:	8b 40 08             	mov    0x8(%eax),%eax
f0106862:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106865:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f010686a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010686d:	c1 e2 04             	shl    $0x4,%edx
f0106870:	01 d0                	add    %edx,%eax
f0106872:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106876:	74 08                	je     f0106880 <sched_exit_all_ready_envs+0x140>
f0106878:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010687b:	8b 52 08             	mov    0x8(%edx),%edx
f010687e:	eb 05                	jmp    f0106885 <sched_exit_all_ready_envs+0x145>
f0106880:	ba 00 00 00 00       	mov    $0x0,%edx
f0106885:	89 50 08             	mov    %edx,0x8(%eax)
f0106888:	8b 40 08             	mov    0x8(%eax),%eax
f010688b:	85 c0                	test   %eax,%eax
f010688d:	0f 85 0b ff ff ff    	jne    f010679e <sched_exit_all_ready_envs+0x5e>
f0106893:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106897:	0f 85 01 ff ff ff    	jne    f010679e <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010689d:	ff 45 f0             	incl   -0x10(%ebp)
f01068a0:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f01068a5:	0f b6 c0             	movzbl %al,%eax
f01068a8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01068ab:	0f 8f b8 fe ff ff    	jg     f0106769 <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01068b1:	83 ec 0c             	sub    $0xc,%esp
f01068b4:	68 20 d2 75 f0       	push   $0xf075d220
f01068b9:	e8 37 98 00 00       	call   f01100f5 <release_spinlock>
f01068be:	83 c4 10             	add    $0x10,%esp
}
f01068c1:	90                   	nop
f01068c2:	c9                   	leave  
f01068c3:	c3                   	ret    

f01068c4 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01068c4:	55                   	push   %ebp
f01068c5:	89 e5                	mov    %esp,%ebp
	return ticks;
f01068c7:	a1 c8 d8 b5 f0       	mov    0xf0b5d8c8,%eax
f01068cc:	8b 15 cc d8 b5 f0    	mov    0xf0b5d8cc,%edx
}
f01068d2:	5d                   	pop    %ebp
f01068d3:	c3                   	ret    

f01068d4 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01068d4:	55                   	push   %ebp
f01068d5:	89 e5                	mov    %esp,%ebp
f01068d7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068da:	83 ec 04             	sub    $0x4,%esp
f01068dd:	68 dc 5b 12 f0       	push   $0xf0125bdc
f01068e2:	68 9e 02 00 00       	push   $0x29e
f01068e7:	68 c3 57 12 f0       	push   $0xf01257c3
f01068ec:	e8 48 9a ff ff       	call   f0100339 <_panic>

f01068f1 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f01068f1:	55                   	push   %ebp
f01068f2:	89 e5                	mov    %esp,%ebp
f01068f4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068f7:	83 ec 04             	sub    $0x4,%esp
f01068fa:	68 dc 5b 12 f0       	push   $0xf0125bdc
f01068ff:	68 a6 02 00 00       	push   $0x2a6
f0106904:	68 c3 57 12 f0       	push   $0xf01257c3
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>

f010690e <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f010690e:	55                   	push   %ebp
f010690f:	89 e5                	mov    %esp,%ebp
f0106911:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106914:	83 ec 04             	sub    $0x4,%esp
f0106917:	68 dc 5b 12 f0       	push   $0xf0125bdc
f010691c:	68 ae 02 00 00       	push   $0x2ae
f0106921:	68 c3 57 12 f0       	push   $0xf01257c3
f0106926:	e8 0e 9a ff ff       	call   f0100339 <_panic>

f010692b <get_load_average>:
}
int get_load_average()
{
f010692b:	55                   	push   %ebp
f010692c:	89 e5                	mov    %esp,%ebp
f010692e:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106931:	83 ec 04             	sub    $0x4,%esp
f0106934:	68 dc 5b 12 f0       	push   $0xf0125bdc
f0106939:	68 b6 02 00 00       	push   $0x2b6
f010693e:	68 c3 57 12 f0       	push   $0xf01257c3
f0106943:	e8 f1 99 ff ff       	call   f0100339 <_panic>

f0106948 <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f0106948:	55                   	push   %ebp
f0106949:	89 e5                	mov    %esp,%ebp
f010694b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - env_set_priority

	//Get the process of the given ID
	struct Env* proc ;
	envid2env(envID, &proc, 0);
f010694e:	83 ec 04             	sub    $0x4,%esp
f0106951:	6a 00                	push   $0x0
f0106953:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0106956:	50                   	push   %eax
f0106957:	ff 75 08             	pushl  0x8(%ebp)
f010695a:	e8 16 54 00 00       	call   f010bd75 <envid2env>
f010695f:	83 c4 10             	add    $0x10,%esp

	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106962:	83 ec 04             	sub    $0x4,%esp
f0106965:	68 dc 5b 12 f0       	push   $0xf0125bdc
f010696a:	68 c8 02 00 00       	push   $0x2c8
f010696f:	68 c3 57 12 f0       	push   $0xf01257c3
f0106974:	e8 c0 99 ff ff       	call   f0100339 <_panic>

f0106979 <sched_set_starv_thresh>:
}

void sched_set_starv_thresh(uint32 starvThresh)
{
f0106979:	55                   	push   %ebp
f010697a:	89 e5                	mov    %esp,%ebp
f010697c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - sched_set_starv_thresh
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010697f:	83 ec 04             	sub    $0x4,%esp
f0106982:	68 dc 5b 12 f0       	push   $0xf0125bdc
f0106987:	68 d0 02 00 00       	push   $0x2d0
f010698c:	68 c3 57 12 f0       	push   $0xf01257c3
f0106991:	e8 a3 99 ff ff       	call   f0100339 <_panic>

f0106996 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0106996:	55                   	push   %ebp
f0106997:	89 e5                	mov    %esp,%ebp
f0106999:	a1 14 d7 b5 f0       	mov    0xf0b5d714,%eax
f010699e:	85 c0                	test   %eax,%eax
f01069a0:	0f 94 c0             	sete   %al
f01069a3:	0f b6 c0             	movzbl %al,%eax
f01069a6:	5d                   	pop    %ebp
f01069a7:	c3                   	ret    

f01069a8 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f01069a8:	55                   	push   %ebp
f01069a9:	89 e5                	mov    %esp,%ebp
f01069ab:	a1 14 d7 b5 f0       	mov    0xf0b5d714,%eax
f01069b0:	83 f8 01             	cmp    $0x1,%eax
f01069b3:	0f 94 c0             	sete   %al
f01069b6:	0f b6 c0             	movzbl %al,%eax
f01069b9:	5d                   	pop    %ebp
f01069ba:	c3                   	ret    

f01069bb <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f01069bb:	55                   	push   %ebp
f01069bc:	89 e5                	mov    %esp,%ebp
f01069be:	a1 14 d7 b5 f0       	mov    0xf0b5d714,%eax
f01069c3:	83 f8 02             	cmp    $0x2,%eax
f01069c6:	0f 94 c0             	sete   %al
f01069c9:	0f b6 c0             	movzbl %al,%eax
f01069cc:	5d                   	pop    %ebp
f01069cd:	c3                   	ret    

f01069ce <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f01069ce:	55                   	push   %ebp
f01069cf:	89 e5                	mov    %esp,%ebp
f01069d1:	a1 14 d7 b5 f0       	mov    0xf0b5d714,%eax
f01069d6:	83 f8 03             	cmp    $0x3,%eax
f01069d9:	0f 94 c0             	sete   %al
f01069dc:	0f b6 c0             	movzbl %al,%eax
f01069df:	5d                   	pop    %ebp
f01069e0:	c3                   	ret    

f01069e1 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01069e1:	55                   	push   %ebp
f01069e2:	89 e5                	mov    %esp,%ebp
f01069e4:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01069e7:	c7 05 f8 d3 b5 f0 00 	movl   $0x0,0xf0b5d3f8
f01069ee:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01069f1:	83 ec 0c             	sub    $0xc,%esp
f01069f4:	6a 0a                	push   $0xa
f01069f6:	e8 66 02 00 00       	call   f0106c61 <sched_init_RR>
f01069fb:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	68 90 d2 75 f0       	push   $0xf075d290
f0106a06:	e8 4c e7 ff ff       	call   f0105157 <init_queue>
f0106a0b:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0106a0e:	83 ec 0c             	sub    $0xc,%esp
f0106a11:	68 a0 d2 75 f0       	push   $0xf075d2a0
f0106a16:	e8 3c e7 ff ff       	call   f0105157 <init_queue>
f0106a1b:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0106a1e:	e8 14 0a 00 00       	call   f0107437 <mycpu>
f0106a23:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a2a:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106a2d:	83 ec 08             	sub    $0x8,%esp
f0106a30:	68 f0 5b 12 f0       	push   $0xf0125bf0
f0106a35:	68 20 d2 75 f0       	push   $0xf075d220
f0106a3a:	e8 fe 95 00 00       	call   f011003d <init_spinlock>
f0106a3f:	83 c4 10             	add    $0x10,%esp
}
f0106a42:	90                   	nop
f0106a43:	c9                   	leave  
f0106a44:	c3                   	ret    

f0106a45 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106a45:	55                   	push   %ebp
f0106a46:	89 e5                	mov    %esp,%ebp
f0106a48:	53                   	push   %ebx
f0106a49:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106a4c:	9c                   	pushf  
f0106a4d:	58                   	pop    %eax
f0106a4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0106a51:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0106a54:	25 00 02 00 00       	and    $0x200,%eax
f0106a59:	85 c0                	test   %eax,%eax
f0106a5b:	74 14                	je     f0106a71 <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f0106a5d:	83 ec 04             	sub    $0x4,%esp
f0106a60:	68 04 5c 12 f0       	push   $0xf0125c04
f0106a65:	6a 3a                	push   $0x3a
f0106a67:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106a6c:	e8 c8 98 ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f0106a71:	e8 c1 09 00 00       	call   f0107437 <mycpu>
f0106a76:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106a79:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a7c:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0106a83:	00 00 00 

	chk1();
f0106a86:	e8 4d 87 01 00       	call   f011f1d8 <chk1>
	c->scheduler_status = SCH_STARTED;
f0106a8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a8e:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106a95:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106a98:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f0106a9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106aa6:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106aa7:	83 ec 0c             	sub    $0xc,%esp
f0106aaa:	68 20 d2 75 f0       	push   $0xf075d220
f0106aaf:	e8 ba 95 00 00       	call   f011006e <acquire_spinlock>
f0106ab4:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106ab7:	a1 14 d7 b5 f0       	mov    0xf0b5d714,%eax
f0106abc:	8b 04 85 7c 09 18 f0 	mov    -0xfe7f684(,%eax,4),%eax
f0106ac3:	ff d0                	call   *%eax
f0106ac5:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106ac8:	e8 58 52 00 00       	call   f010bd25 <get_cpu_proc>
f0106acd:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f0106ad0:	83 ec 0c             	sub    $0xc,%esp
f0106ad3:	ff 75 e8             	pushl  -0x18(%ebp)
f0106ad6:	e8 73 52 00 00       	call   f010bd4e <set_cpu_proc>
f0106adb:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f0106ade:	83 ec 0c             	sub    $0xc,%esp
f0106ae1:	ff 75 e8             	pushl  -0x18(%ebp)
f0106ae4:	e8 f5 86 01 00       	call   f011f1de <chk2>
f0106ae9:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106aec:	83 ec 0c             	sub    $0xc,%esp
f0106aef:	ff 75 e0             	pushl  -0x20(%ebp)
f0106af2:	e8 57 52 00 00       	call   f010bd4e <set_cpu_proc>
f0106af7:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106afa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106afe:	0f 84 dc 00 00 00    	je     f0106be0 <fos_scheduler+0x19b>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106b04:	83 ec 0c             	sub    $0xc,%esp
f0106b07:	ff 75 e8             	pushl  -0x18(%ebp)
f0106b0a:	e8 3f 52 00 00       	call   f010bd4e <set_cpu_proc>
f0106b0f:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f0106b12:	83 ec 0c             	sub    $0xc,%esp
f0106b15:	ff 75 e8             	pushl  -0x18(%ebp)
f0106b18:	e8 ac 54 00 00       	call   f010bfc9 <switchuvm>
f0106b1d:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f0106b20:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106b23:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106b2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106b2d:	8b 40 04             	mov    0x4(%eax),%eax
f0106b30:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b33:	83 c2 04             	add    $0x4,%edx
f0106b36:	83 ec 08             	sub    $0x8,%esp
f0106b39:	50                   	push   %eax
f0106b3a:	52                   	push   %edx
f0106b3b:	e8 1f e2 ff ff       	call   f0104d5f <context_switch>
f0106b40:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106b43:	9c                   	pushf  
f0106b44:	58                   	pop    %eax
f0106b45:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106b48:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106b4b:	25 00 02 00 00       	and    $0x200,%eax
f0106b50:	85 c0                	test   %eax,%eax
f0106b52:	74 14                	je     f0106b68 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f0106b54:	83 ec 04             	sub    $0x4,%esp
f0106b57:	68 4c 5c 12 f0       	push   $0xf0125c4c
f0106b5c:	6a 77                	push   $0x77
f0106b5e:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106b63:	e8 d1 97 ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f0106b68:	e8 3b e3 ff ff       	call   f0104ea8 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f0106b6d:	e8 b3 51 00 00       	call   f010bd25 <get_cpu_proc>
f0106b72:	89 c2                	mov    %eax,%edx
f0106b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b77:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106b7d:	39 c2                	cmp    %eax,%edx
f0106b7f:	74 19                	je     f0106b9a <fos_scheduler+0x155>
f0106b81:	68 83 5c 12 f0       	push   $0xf0125c83
f0106b86:	68 9d 5c 12 f0       	push   $0xf0125c9d
f0106b8b:	68 80 00 00 00       	push   $0x80
f0106b90:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106b95:	e8 9f 97 ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f0106b9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b9d:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106ba3:	8b 40 18             	mov    0x18(%eax),%eax
f0106ba6:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106ba9:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106bad:	75 19                	jne    f0106bc8 <fos_scheduler+0x183>
f0106baf:	68 b2 5c 12 f0       	push   $0xf0125cb2
f0106bb4:	68 9d 5c 12 f0       	push   $0xf0125c9d
f0106bb9:	68 82 00 00 00       	push   $0x82
f0106bbe:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106bc3:	e8 71 97 ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f0106bc8:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106bcc:	74 12                	je     f0106be0 <fos_scheduler+0x19b>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106bce:	e8 df 53 00 00       	call   f010bfb2 <switchkvm>
					set_cpu_proc(NULL);
f0106bd3:	83 ec 0c             	sub    $0xc,%esp
f0106bd6:	6a 00                	push   $0x0
f0106bd8:	e8 71 51 00 00       	call   f010bd4e <set_cpu_proc>
f0106bdd:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106be0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106be4:	0f 85 cd fe ff ff    	jne    f0106ab7 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106bea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106bf1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106bf8:	eb 3e                	jmp    f0106c38 <fos_scheduler+0x1f3>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106bfa:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f0106c00:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106c03:	89 d0                	mov    %edx,%eax
f0106c05:	c1 e0 03             	shl    $0x3,%eax
f0106c08:	01 d0                	add    %edx,%eax
f0106c0a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106c11:	01 d8                	add    %ebx,%eax
f0106c13:	01 c0                	add    %eax,%eax
f0106c15:	01 d0                	add    %edx,%eax
f0106c17:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106c1e:	01 d8                	add    %ebx,%eax
f0106c20:	01 d0                	add    %edx,%eax
f0106c22:	01 c8                	add    %ecx,%eax
f0106c24:	8b 40 18             	mov    0x18(%eax),%eax
f0106c27:	83 f8 03             	cmp    $0x3,%eax
f0106c2a:	75 09                	jne    f0106c35 <fos_scheduler+0x1f0>
			{
				is_any_blocked = 1;
f0106c2c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106c33:	eb 0d                	jmp    f0106c42 <fos_scheduler+0x1fd>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0106c35:	ff 45 f0             	incl   -0x10(%ebp)
f0106c38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106c3b:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106c40:	76 b8                	jbe    f0106bfa <fos_scheduler+0x1b5>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106c42:	83 ec 0c             	sub    $0xc,%esp
f0106c45:	68 20 d2 75 f0       	push   $0xf075d220
f0106c4a:	e8 a6 94 00 00       	call   f01100f5 <release_spinlock>
f0106c4f:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106c52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c56:	0f 8f 4a fe ff ff    	jg     f0106aa6 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0106c5c:	e8 61 b1 ff ff       	call   f0101dc2 <get_into_prompt>

f0106c61 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0106c61:	55                   	push   %ebp
f0106c62:	89 e5                	mov    %esp,%ebp
f0106c64:	83 ec 28             	sub    $0x28,%esp
f0106c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0106c6a:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0106c6d:	c6 05 e4 d9 f5 f0 01 	movb   $0x1,0xf0f5d9e4
#if USE_KHEAP
	sched_delete_ready_queues();
f0106c74:	e8 8e e7 ff ff       	call   f0105407 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0106c79:	83 ec 0c             	sub    $0xc,%esp
f0106c7c:	6a 10                	push   $0x10
f0106c7e:	e8 4c 2b 00 00       	call   f01097cf <kmalloc>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	a3 b0 d2 75 f0       	mov    %eax,0xf075d2b0
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106c8b:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f0106c90:	0f b6 c0             	movzbl %al,%eax
f0106c93:	83 ec 0c             	sub    $0xc,%esp
f0106c96:	50                   	push   %eax
f0106c97:	e8 33 2b 00 00       	call   f01097cf <kmalloc>
f0106c9c:	83 c4 10             	add    $0x10,%esp
f0106c9f:	a3 e4 d5 b5 f0       	mov    %eax,0xf0b5d5e4
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f0106ca4:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f0106ca9:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0106cac:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106cae:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f0106cb3:	8a 00                	mov    (%eax),%al
f0106cb5:	0f b6 c0             	movzbl %al,%eax
f0106cb8:	83 ec 0c             	sub    $0xc,%esp
f0106cbb:	50                   	push   %eax
f0106cbc:	e8 b0 e2 ff ff       	call   f0104f71 <kclock_set_quantum>
f0106cc1:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106cc4:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106cc9:	83 ec 0c             	sub    $0xc,%esp
f0106ccc:	50                   	push   %eax
f0106ccd:	e8 85 e4 ff ff       	call   f0105157 <init_queue>
f0106cd2:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106cd5:	e8 f6 e3 ff ff       	call   f01050d0 <kclock_read_cnt0_latch>
f0106cda:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106cde:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106ce2:	83 ec 08             	sub    $0x8,%esp
f0106ce5:	50                   	push   %eax
f0106ce6:	68 c8 5c 12 f0       	push   $0xf0125cc8
f0106ceb:	e8 9b a2 ff ff       	call   f0100f8b <cprintf>
f0106cf0:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106cf3:	e8 3f 07 00 00       	call   f0107437 <mycpu>
f0106cf8:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106cff:	00 00 00 
	scheduler_method = SCH_RR;
f0106d02:	c7 05 14 d7 b5 f0 00 	movl   $0x0,0xf0b5d714
f0106d09:	00 00 00 
	//=========================================
	//=========================================
}
f0106d0c:	90                   	nop
f0106d0d:	c9                   	leave  
f0106d0e:	c3                   	ret    

f0106d0f <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106d0f:	55                   	push   %ebp
f0106d10:	89 e5                	mov    %esp,%ebp
f0106d12:	83 ec 18             	sub    $0x18,%esp
f0106d15:	8b 45 08             	mov    0x8(%ebp),%eax
f0106d18:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106d1b:	e8 e7 e6 ff ff       	call   f0105407 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d20:	83 ec 04             	sub    $0x4,%esp
f0106d23:	68 f0 5c 12 f0       	push   $0xf0125cf0
f0106d28:	68 d1 00 00 00       	push   $0xd1
f0106d2d:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106d32:	e8 02 96 ff ff       	call   f0100339 <_panic>

f0106d37 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106d37:	55                   	push   %ebp
f0106d38:	89 e5                	mov    %esp,%ebp
f0106d3a:	83 ec 18             	sub    $0x18,%esp
f0106d3d:	8b 55 08             	mov    0x8(%ebp),%edx
f0106d40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106d43:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106d46:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d49:	83 ec 04             	sub    $0x4,%esp
f0106d4c:	68 f0 5c 12 f0       	push   $0xf0125cf0
f0106d51:	68 e7 00 00 00       	push   $0xe7
f0106d56:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106d5b:	e8 d9 95 ff ff       	call   f0100339 <_panic>

f0106d60 <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0106d60:	55                   	push   %ebp
f0106d61:	89 e5                	mov    %esp,%ebp
f0106d63:	83 ec 18             	sub    $0x18,%esp
f0106d66:	8b 55 08             	mov    0x8(%ebp),%edx
f0106d69:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106d6c:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106d6f:	88 45 f0             	mov    %al,-0x10(%ebp)
	//TODO: [PROJECT'24.MS3 - #07] [3] PRIORITY RR Scheduler - sched_init_PRIRR
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106d72:	83 ec 04             	sub    $0x4,%esp
f0106d75:	68 f0 5c 12 f0       	push   $0xf0125cf0
f0106d7a:	68 fc 00 00 00       	push   $0xfc
f0106d7f:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106d84:	e8 b0 95 ff ff       	call   f0100339 <_panic>

f0106d89 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106d89:	55                   	push   %ebp
f0106d8a:	89 e5                	mov    %esp,%ebp
f0106d8c:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106d8f:	83 ec 0c             	sub    $0xc,%esp
f0106d92:	68 20 d2 75 f0       	push   $0xf075d220
f0106d97:	e8 eb 94 00 00       	call   f0110287 <holding_spinlock>
f0106d9c:	83 c4 10             	add    $0x10,%esp
f0106d9f:	85 c0                	test   %eax,%eax
f0106da1:	75 17                	jne    f0106dba <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106da3:	83 ec 04             	sub    $0x4,%esp
f0106da6:	68 04 5d 12 f0       	push   $0xf0125d04
f0106dab:	68 1c 01 00 00       	push   $0x11c
f0106db0:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106db5:	e8 7f 95 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106dba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106dc1:	e8 5f 4f 00 00       	call   f010bd25 <get_cpu_proc>
f0106dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106dc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106dcd:	74 14                	je     f0106de3 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106dcf:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106dd4:	83 ec 08             	sub    $0x8,%esp
f0106dd7:	ff 75 f0             	pushl  -0x10(%ebp)
f0106dda:	50                   	push   %eax
f0106ddb:	e8 b8 e3 ff ff       	call   f0105198 <enqueue>
f0106de0:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106de3:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f0106de8:	83 ec 0c             	sub    $0xc,%esp
f0106deb:	50                   	push   %eax
f0106dec:	e8 38 e4 ff ff       	call   f0105229 <dequeue>
f0106df1:	83 c4 10             	add    $0x10,%esp
f0106df4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106df7:	a1 e4 d5 b5 f0       	mov    0xf0b5d5e4,%eax
f0106dfc:	8a 00                	mov    (%eax),%al
f0106dfe:	0f b6 c0             	movzbl %al,%eax
f0106e01:	83 ec 0c             	sub    $0xc,%esp
f0106e04:	50                   	push   %eax
f0106e05:	e8 67 e1 ff ff       	call   f0104f71 <kclock_set_quantum>
f0106e0a:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106e10:	c9                   	leave  
f0106e11:	c3                   	ret    

f0106e12 <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106e12:	55                   	push   %ebp
f0106e13:	89 e5                	mov    %esp,%ebp
f0106e15:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106e18:	83 ec 0c             	sub    $0xc,%esp
f0106e1b:	68 20 d2 75 f0       	push   $0xf075d220
f0106e20:	e8 62 94 00 00       	call   f0110287 <holding_spinlock>
f0106e25:	83 c4 10             	add    $0x10,%esp
f0106e28:	85 c0                	test   %eax,%eax
f0106e2a:	75 17                	jne    f0106e43 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106e2c:	83 ec 04             	sub    $0x4,%esp
f0106e2f:	68 50 5d 12 f0       	push   $0xf0125d50
f0106e34:	68 3b 01 00 00       	push   $0x13b
f0106e39:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106e3e:	e8 f6 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e43:	83 ec 04             	sub    $0x4,%esp
f0106e46:	68 f0 5c 12 f0       	push   $0xf0125cf0
f0106e4b:	68 41 01 00 00       	push   $0x141
f0106e50:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106e55:	e8 df 94 ff ff       	call   f0100339 <_panic>

f0106e5a <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106e5a:	55                   	push   %ebp
f0106e5b:	89 e5                	mov    %esp,%ebp
f0106e5d:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106e60:	83 ec 0c             	sub    $0xc,%esp
f0106e63:	68 20 d2 75 f0       	push   $0xf075d220
f0106e68:	e8 1a 94 00 00       	call   f0110287 <holding_spinlock>
f0106e6d:	83 c4 10             	add    $0x10,%esp
f0106e70:	85 c0                	test   %eax,%eax
f0106e72:	75 17                	jne    f0106e8b <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106e74:	83 ec 04             	sub    $0x4,%esp
f0106e77:	68 a0 5d 12 f0       	push   $0xf0125da0
f0106e7c:	68 4c 01 00 00       	push   $0x14c
f0106e81:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106e86:	e8 ae 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e8b:	83 ec 04             	sub    $0x4,%esp
f0106e8e:	68 f0 5c 12 f0       	push   $0xf0125cf0
f0106e93:	68 52 01 00 00       	push   $0x152
f0106e98:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106e9d:	e8 97 94 ff ff       	call   f0100339 <_panic>

f0106ea2 <fos_scheduler_PRIRR>:
}
//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f0106ea2:	55                   	push   %ebp
f0106ea3:	89 e5                	mov    %esp,%ebp
f0106ea5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106ea8:	83 ec 0c             	sub    $0xc,%esp
f0106eab:	68 20 d2 75 f0       	push   $0xf075d220
f0106eb0:	e8 d2 93 00 00       	call   f0110287 <holding_spinlock>
f0106eb5:	83 c4 10             	add    $0x10,%esp
f0106eb8:	85 c0                	test   %eax,%eax
f0106eba:	75 17                	jne    f0106ed3 <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f0106ebc:	83 ec 04             	sub    $0x4,%esp
f0106ebf:	68 f0 5d 12 f0       	push   $0xf0125df0
f0106ec4:	68 5c 01 00 00       	push   $0x15c
f0106ec9:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106ece:	e8 66 94 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	//TODO: [PROJECT'24.MS3 - #08] [3] PRIORITY RR Scheduler - fos_scheduler_PRIRR
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ed3:	83 ec 04             	sub    $0x4,%esp
f0106ed6:	68 f0 5c 12 f0       	push   $0xf0125cf0
f0106edb:	68 61 01 00 00       	push   $0x161
f0106ee0:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106ee5:	e8 4f 94 ff ff       	call   f0100339 <_panic>

f0106eea <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106eea:	55                   	push   %ebp
f0106eeb:	89 e5                	mov    %esp,%ebp
f0106eed:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0106ef0:	e8 d9 fa ff ff       	call   f01069ce <isSchedMethodPRIRR>
f0106ef5:	85 c0                	test   %eax,%eax
f0106ef7:	74 17                	je     f0106f10 <clock_interrupt_handler+0x26>
	{
		//TODO: [PROJECT'24.MS3 - #09] [3] PRIORITY RR Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106ef9:	83 ec 04             	sub    $0x4,%esp
f0106efc:	68 f0 5c 12 f0       	push   $0xf0125cf0
f0106f01:	68 6f 01 00 00       	push   $0x16f
f0106f06:	68 3a 5c 12 f0       	push   $0xf0125c3a
f0106f0b:	e8 29 94 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106f10:	a1 c8 d8 b5 f0       	mov    0xf0b5d8c8,%eax
f0106f15:	8b 15 cc d8 b5 f0    	mov    0xf0b5d8cc,%edx
f0106f1b:	83 c0 01             	add    $0x1,%eax
f0106f1e:	83 d2 00             	adc    $0x0,%edx
f0106f21:	a3 c8 d8 b5 f0       	mov    %eax,0xf0b5d8c8
f0106f26:	89 15 cc d8 b5 f0    	mov    %edx,0xf0b5d8cc
	struct Env* p = get_cpu_proc();
f0106f2c:	e8 f4 4d 00 00       	call   f010bd25 <get_cpu_proc>
f0106f31:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106f34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f38:	74 30                	je     f0106f6a <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f3d:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106f43:	8d 50 01             	lea    0x1(%eax),%edx
f0106f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f49:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106f4f:	83 ec 0c             	sub    $0xc,%esp
f0106f52:	6a 01                	push   $0x1
f0106f54:	e8 da 8a 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f0106f59:	83 c4 10             	add    $0x10,%esp
f0106f5c:	85 c0                	test   %eax,%eax
f0106f5e:	74 05                	je     f0106f65 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106f60:	e8 08 00 00 00       	call   f0106f6d <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106f65:	e8 dd 4e 00 00       	call   f010be47 <yield>
	}
	/*****************************************/
}
f0106f6a:	90                   	nop
f0106f6b:	c9                   	leave  
f0106f6c:	c3                   	ret    

f0106f6d <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106f6d:	55                   	push   %ebp
f0106f6e:	89 e5                	mov    %esp,%ebp
f0106f70:	53                   	push   %ebx
f0106f71:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106f74:	e8 ac 4d 00 00       	call   f010bd25 <get_cpu_proc>
f0106f79:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106f7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106f80:	0f 84 a1 01 00 00    	je     f0107127 <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106f86:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f89:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106f8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f92:	eb 78                	jmp    f010700c <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f97:	8b 00                	mov    (%eax),%eax
f0106f99:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106f9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f9f:	8b 40 64             	mov    0x64(%eax),%eax
f0106fa2:	83 ec 08             	sub    $0x8,%esp
f0106fa5:	ff 75 e8             	pushl  -0x18(%ebp)
f0106fa8:	50                   	push   %eax
f0106fa9:	e8 bf 30 00 00       	call   f010a06d <pt_get_page_permissions>
f0106fae:	83 c4 10             	add    $0x10,%esp
f0106fb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	8b 40 08             	mov    0x8(%eax),%eax
f0106fba:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106fbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106fc0:	83 e0 20             	and    $0x20,%eax
f0106fc3:	85 c0                	test   %eax,%eax
f0106fc5:	74 2b                	je     f0106ff2 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106fc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106fca:	c1 e8 02             	shr    $0x2,%eax
f0106fcd:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106fd2:	89 c2                	mov    %eax,%edx
f0106fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fd7:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106fda:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106fdd:	8b 40 64             	mov    0x64(%eax),%eax
f0106fe0:	6a 20                	push   $0x20
f0106fe2:	6a 00                	push   $0x0
f0106fe4:	ff 75 e8             	pushl  -0x18(%ebp)
f0106fe7:	50                   	push   %eax
f0106fe8:	e8 bc 2f 00 00       	call   f0109fa9 <pt_set_page_permissions>
f0106fed:	83 c4 10             	add    $0x10,%esp
f0106ff0:	eb 0e                	jmp    f0107000 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106ff2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106ff5:	c1 e8 02             	shr    $0x2,%eax
f0106ff8:	89 c2                	mov    %eax,%edx
f0106ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ffd:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0107000:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107003:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0107009:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010700c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107010:	74 08                	je     f010701a <update_WS_time_stamps+0xad>
f0107012:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107015:	8b 40 10             	mov    0x10(%eax),%eax
f0107018:	eb 05                	jmp    f010701f <update_WS_time_stamps+0xb2>
f010701a:	b8 00 00 00 00       	mov    $0x0,%eax
f010701f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107022:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0107028:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010702b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0107031:	85 c0                	test   %eax,%eax
f0107033:	0f 85 5b ff ff ff    	jne    f0106f94 <update_WS_time_stamps+0x27>
f0107039:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010703d:	0f 85 51 ff ff ff    	jne    f0106f94 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0107043:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010704a:	e9 ce 00 00 00       	jmp    f010711d <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f010704f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107052:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107055:	89 d0                	mov    %edx,%eax
f0107057:	01 c0                	add    %eax,%eax
f0107059:	01 d0                	add    %edx,%eax
f010705b:	c1 e0 03             	shl    $0x3,%eax
f010705e:	01 c8                	add    %ecx,%eax
f0107060:	05 b0 00 00 00       	add    $0xb0,%eax
f0107065:	8a 00                	mov    (%eax),%al
f0107067:	3c 01                	cmp    $0x1,%al
f0107069:	0f 84 ab 00 00 00    	je     f010711a <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f010706f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107072:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107075:	89 d0                	mov    %edx,%eax
f0107077:	01 c0                	add    %eax,%eax
f0107079:	01 d0                	add    %edx,%eax
f010707b:	c1 e0 03             	shl    $0x3,%eax
f010707e:	01 c8                	add    %ecx,%eax
f0107080:	05 ac 00 00 00       	add    $0xac,%eax
f0107085:	8b 00                	mov    (%eax),%eax
f0107087:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f010708a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010708d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107090:	89 d0                	mov    %edx,%eax
f0107092:	01 c0                	add    %eax,%eax
f0107094:	01 d0                	add    %edx,%eax
f0107096:	c1 e0 03             	shl    $0x3,%eax
f0107099:	01 c8                	add    %ecx,%eax
f010709b:	05 b4 00 00 00       	add    $0xb4,%eax
f01070a0:	8b 00                	mov    (%eax),%eax
f01070a2:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f01070a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01070a8:	8b 40 64             	mov    0x64(%eax),%eax
f01070ab:	83 ec 08             	sub    $0x8,%esp
f01070ae:	ff 75 dc             	pushl  -0x24(%ebp)
f01070b1:	50                   	push   %eax
f01070b2:	e8 92 30 00 00       	call   f010a149 <pd_is_table_used>
f01070b7:	83 c4 10             	add    $0x10,%esp
f01070ba:	85 c0                	test   %eax,%eax
f01070bc:	74 3c                	je     f01070fa <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f01070be:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01070c1:	c1 e8 02             	shr    $0x2,%eax
f01070c4:	0d 00 00 00 80       	or     $0x80000000,%eax
f01070c9:	89 c1                	mov    %eax,%ecx
f01070cb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01070ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01070d1:	89 d0                	mov    %edx,%eax
f01070d3:	01 c0                	add    %eax,%eax
f01070d5:	01 d0                	add    %edx,%eax
f01070d7:	c1 e0 03             	shl    $0x3,%eax
f01070da:	01 d8                	add    %ebx,%eax
f01070dc:	05 b4 00 00 00       	add    $0xb4,%eax
f01070e1:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f01070e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01070e6:	8b 40 64             	mov    0x64(%eax),%eax
f01070e9:	83 ec 08             	sub    $0x8,%esp
f01070ec:	ff 75 dc             	pushl  -0x24(%ebp)
f01070ef:	50                   	push   %eax
f01070f0:	e8 78 30 00 00       	call   f010a16d <pd_set_table_unused>
f01070f5:	83 c4 10             	add    $0x10,%esp
f01070f8:	eb 20                	jmp    f010711a <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f01070fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01070fd:	c1 e8 02             	shr    $0x2,%eax
f0107100:	89 c1                	mov    %eax,%ecx
f0107102:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0107105:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107108:	89 d0                	mov    %edx,%eax
f010710a:	01 c0                	add    %eax,%eax
f010710c:	01 d0                	add    %edx,%eax
f010710e:	c1 e0 03             	shl    $0x3,%eax
f0107111:	01 d8                	add    %ebx,%eax
f0107113:	05 b4 00 00 00       	add    $0xb4,%eax
f0107118:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f010711a:	ff 45 f0             	incl   -0x10(%ebp)
f010711d:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0107121:	0f 8e 28 ff ff ff    	jle    f010704f <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0107127:	90                   	nop
f0107128:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010712b:	c9                   	leave  
f010712c:	c3                   	ret    

f010712d <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f010712d:	55                   	push   %ebp
f010712e:	89 e5                	mov    %esp,%ebp
f0107130:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0107133:	c7 05 2c 47 73 f0 01 	movl   $0x1,0xf073472c
f010713a:	00 00 00 
f010713d:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0107144:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107148:	8a 45 b2             	mov    -0x4e(%ebp),%al
f010714b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010714e:	ee                   	out    %al,(%dx)
f010714f:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0107156:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f010715a:	8a 45 b3             	mov    -0x4d(%ebp),%al
f010715d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107160:	ee                   	out    %al,(%dx)
f0107161:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0107168:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f010716c:	8a 45 b4             	mov    -0x4c(%ebp),%al
f010716f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107172:	ee                   	out    %al,(%dx)
f0107173:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f010717a:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f010717e:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0107181:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107184:	ee                   	out    %al,(%dx)
f0107185:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f010718c:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0107190:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0107193:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107196:	ee                   	out    %al,(%dx)
f0107197:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f010719e:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f01071a2:	8a 45 b7             	mov    -0x49(%ebp),%al
f01071a5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01071a8:	ee                   	out    %al,(%dx)
f01071a9:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f01071b0:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f01071b4:	8a 45 b8             	mov    -0x48(%ebp),%al
f01071b7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01071ba:	ee                   	out    %al,(%dx)
f01071bb:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f01071c2:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f01071c6:	8a 45 b9             	mov    -0x47(%ebp),%al
f01071c9:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01071cc:	ee                   	out    %al,(%dx)
f01071cd:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f01071d4:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f01071d8:	8a 45 ba             	mov    -0x46(%ebp),%al
f01071db:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01071de:	ee                   	out    %al,(%dx)
f01071df:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f01071e6:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f01071ea:	8a 45 bb             	mov    -0x45(%ebp),%al
f01071ed:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01071f0:	ee                   	out    %al,(%dx)
f01071f1:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f01071f8:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f01071fc:	8a 45 bc             	mov    -0x44(%ebp),%al
f01071ff:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0107202:	ee                   	out    %al,(%dx)
f0107203:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f010720a:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f010720e:	8a 45 bd             	mov    -0x43(%ebp),%al
f0107211:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0107214:	ee                   	out    %al,(%dx)
f0107215:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f010721c:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0107220:	8a 45 be             	mov    -0x42(%ebp),%al
f0107223:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0107226:	ee                   	out    %al,(%dx)
f0107227:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f010722e:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0107232:	8a 45 bf             	mov    -0x41(%ebp),%al
f0107235:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0107238:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0107239:	66 a1 8c 09 18 f0    	mov    0xf018098c,%ax
f010723f:	66 83 f8 ff          	cmp    $0xffff,%ax
f0107243:	74 15                	je     f010725a <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0107245:	66 a1 8c 09 18 f0    	mov    0xf018098c,%ax
f010724b:	0f b7 c0             	movzwl %ax,%eax
f010724e:	83 ec 0c             	sub    $0xc,%esp
f0107251:	50                   	push   %eax
f0107252:	e8 06 00 00 00       	call   f010725d <irq_setmask_8259A>
f0107257:	83 c4 10             	add    $0x10,%esp
}
f010725a:	90                   	nop
f010725b:	c9                   	leave  
f010725c:	c3                   	ret    

f010725d <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f010725d:	55                   	push   %ebp
f010725e:	89 e5                	mov    %esp,%ebp
f0107260:	83 ec 14             	sub    $0x14,%esp
f0107263:	8b 45 08             	mov    0x8(%ebp),%eax
f0107266:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f010726a:	a1 2c 47 73 f0       	mov    0xf073472c,%eax
f010726f:	85 c0                	test   %eax,%eax
f0107271:	74 34                	je     f01072a7 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0107273:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107276:	0f b6 c0             	movzbl %al,%eax
f0107279:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0107280:	88 45 f6             	mov    %al,-0xa(%ebp)
f0107283:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107286:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107289:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f010728a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010728d:	66 c1 e8 08          	shr    $0x8,%ax
f0107291:	0f b6 c0             	movzbl %al,%eax
f0107294:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f010729b:	88 45 f7             	mov    %al,-0x9(%ebp)
f010729e:	8a 45 f7             	mov    -0x9(%ebp),%al
f01072a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01072a4:	ee                   	out    %al,(%dx)
f01072a5:	eb 01                	jmp    f01072a8 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f01072a7:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f01072a8:	c9                   	leave  
f01072a9:	c3                   	ret    

f01072aa <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f01072aa:	55                   	push   %ebp
f01072ab:	89 e5                	mov    %esp,%ebp
f01072ad:	53                   	push   %ebx
f01072ae:	83 ec 14             	sub    $0x14,%esp
f01072b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01072b4:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01072b7:	a1 2c 47 73 f0       	mov    0xf073472c,%eax
f01072bc:	85 c0                	test   %eax,%eax
f01072be:	74 58                	je     f0107318 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01072c0:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01072c4:	77 08                	ja     f01072ce <irq_set_mask+0x24>
		port = PIC1_DATA;
f01072c6:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01072cc:	eb 0a                	jmp    f01072d8 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f01072ce:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01072d4:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f01072d8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01072dc:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01072df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e2:	89 c2                	mov    %eax,%edx
f01072e4:	ec                   	in     (%dx),%al
f01072e5:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f01072e8:	8a 45 ee             	mov    -0x12(%ebp),%al
f01072eb:	88 c2                	mov    %al,%dl
f01072ed:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01072f1:	bb 01 00 00 00       	mov    $0x1,%ebx
f01072f6:	88 c1                	mov    %al,%cl
f01072f8:	d3 e3                	shl    %cl,%ebx
f01072fa:	89 d8                	mov    %ebx,%eax
f01072fc:	09 d0                	or     %edx,%eax
f01072fe:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107301:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107305:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107309:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010730c:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010730f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107312:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107315:	ee                   	out    %al,(%dx)
f0107316:	eb 01                	jmp    f0107319 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107318:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0107319:	83 c4 14             	add    $0x14,%esp
f010731c:	5b                   	pop    %ebx
f010731d:	5d                   	pop    %ebp
f010731e:	c3                   	ret    

f010731f <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f010731f:	55                   	push   %ebp
f0107320:	89 e5                	mov    %esp,%ebp
f0107322:	53                   	push   %ebx
f0107323:	83 ec 14             	sub    $0x14,%esp
f0107326:	8b 45 08             	mov    0x8(%ebp),%eax
f0107329:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f010732c:	a1 2c 47 73 f0       	mov    0xf073472c,%eax
f0107331:	85 c0                	test   %eax,%eax
f0107333:	74 5a                	je     f010738f <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107335:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107339:	77 08                	ja     f0107343 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f010733b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107341:	eb 0a                	jmp    f010734d <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107343:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107349:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f010734d:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107351:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107354:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107357:	89 c2                	mov    %eax,%edx
f0107359:	ec                   	in     (%dx),%al
f010735a:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f010735d:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107360:	88 c2                	mov    %al,%dl
f0107362:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107366:	bb 01 00 00 00       	mov    $0x1,%ebx
f010736b:	88 c1                	mov    %al,%cl
f010736d:	d3 e3                	shl    %cl,%ebx
f010736f:	89 d8                	mov    %ebx,%eax
f0107371:	f7 d0                	not    %eax
f0107373:	21 d0                	and    %edx,%eax
f0107375:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107378:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f010737c:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107380:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107383:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107386:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107389:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010738c:	ee                   	out    %al,(%dx)
f010738d:	eb 01                	jmp    f0107390 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f010738f:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107390:	83 c4 14             	add    $0x14,%esp
f0107393:	5b                   	pop    %ebx
f0107394:	5d                   	pop    %ebp
f0107395:	c3                   	ret    

f0107396 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107396:	55                   	push   %ebp
f0107397:	89 e5                	mov    %esp,%ebp
f0107399:	53                   	push   %ebx
f010739a:	83 ec 14             	sub    $0x14,%esp
f010739d:	8b 45 08             	mov    0x8(%ebp),%eax
f01073a0:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01073a3:	a1 2c 47 73 f0       	mov    0xf073472c,%eax
f01073a8:	85 c0                	test   %eax,%eax
f01073aa:	75 07                	jne    f01073b3 <irq_get_mask+0x1d>
		return -1;
f01073ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01073b1:	eb 45                	jmp    f01073f8 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01073b3:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01073b7:	77 08                	ja     f01073c1 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f01073b9:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01073bf:	eb 0a                	jmp    f01073cb <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f01073c1:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01073c7:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01073cb:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01073cf:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01073d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d5:	89 c2                	mov    %eax,%edx
f01073d7:	ec                   	in     (%dx),%al
f01073d8:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01073db:	8a 45 f3             	mov    -0xd(%ebp),%al
f01073de:	88 c2                	mov    %al,%dl
f01073e0:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01073e4:	bb 01 00 00 00       	mov    $0x1,%ebx
f01073e9:	88 c1                	mov    %al,%cl
f01073eb:	d3 e3                	shl    %cl,%ebx
f01073ed:	89 d8                	mov    %ebx,%eax
f01073ef:	21 d0                	and    %edx,%eax
f01073f1:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01073f4:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01073f8:	83 c4 14             	add    $0x14,%esp
f01073fb:	5b                   	pop    %ebx
f01073fc:	5d                   	pop    %ebp
f01073fd:	c3                   	ret    

f01073fe <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01073fe:	55                   	push   %ebp
f01073ff:	89 e5                	mov    %esp,%ebp
f0107401:	83 ec 14             	sub    $0x14,%esp
f0107404:	8b 45 08             	mov    0x8(%ebp),%eax
f0107407:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f010740a:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f010740e:	76 12                	jbe    f0107422 <pic_sendEOI+0x24>
f0107410:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107417:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010741b:	8a 45 f7             	mov    -0x9(%ebp),%al
f010741e:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107421:	ee                   	out    %al,(%dx)
f0107422:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107429:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f010742d:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107430:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107433:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107434:	90                   	nop
f0107435:	c9                   	leave  
f0107436:	c3                   	ret    

f0107437 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0107437:	55                   	push   %ebp
f0107438:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010743a:	b8 00 d4 b5 f0       	mov    $0xf0b5d400,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f010743f:	5d                   	pop    %ebp
f0107440:	c3                   	ret    

f0107441 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107441:	55                   	push   %ebp
f0107442:	89 e5                	mov    %esp,%ebp
f0107444:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0107447:	e8 eb ff ff ff       	call   f0107437 <mycpu>
f010744c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f010744f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107452:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107459:	00 00 00 
  c->ncli = 0;
f010745c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010745f:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107466:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107469:	9c                   	pushf  
f010746a:	58                   	pop    %eax
f010746b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010746e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107471:	25 00 02 00 00       	and    $0x200,%eax
f0107476:	85 c0                	test   %eax,%eax
f0107478:	0f 95 c0             	setne  %al
f010747b:	0f b6 d0             	movzbl %al,%edx
f010747e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107481:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107487:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107491:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107494:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f010749b:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f010749e:	8b 45 08             	mov    0x8(%ebp),%eax
f01074a1:	40                   	inc    %eax
f01074a2:	c1 e0 0f             	shl    $0xf,%eax
f01074a5:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01074aa:	29 c2                	sub    %eax,%edx
f01074ac:	89 d0                	mov    %edx,%eax
f01074ae:	89 c2                	mov    %eax,%edx
f01074b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b3:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f01074b6:	e8 18 01 00 00       	call   f01075d3 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f01074bb:	e8 35 5f 00 00       	call   f010d3f5 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f01074c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c3:	83 c0 0c             	add    $0xc,%eax
f01074c6:	83 ec 04             	sub    $0x4,%esp
f01074c9:	6a 68                	push   $0x68
f01074cb:	6a 00                	push   $0x0
f01074cd:	50                   	push   %eax
f01074ce:	e8 37 8d 01 00       	call   f012020a <memset>
f01074d3:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01074d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d9:	05 a4 00 00 00       	add    $0xa4,%eax
f01074de:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01074e1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01074e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01074eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01074ee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01074f1:	f0 87 02             	lock xchg %eax,(%edx)
f01074f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01074f7:	90                   	nop
f01074f8:	c9                   	leave  
f01074f9:	c3                   	ret    

f01074fa <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01074fa:	55                   	push   %ebp
f01074fb:	89 e5                	mov    %esp,%ebp
f01074fd:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107500:	9c                   	pushf  
f0107501:	58                   	pop    %eax
f0107502:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f0107505:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0107508:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010750b:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f010750c:	e8 26 ff ff ff       	call   f0107437 <mycpu>
f0107511:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f0107514:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107517:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010751d:	85 c0                	test   %eax,%eax
f010751f:	75 13                	jne    f0107534 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f0107521:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107524:	25 00 02 00 00       	and    $0x200,%eax
f0107529:	89 c2                	mov    %eax,%edx
f010752b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107534:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107537:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010753d:	8d 50 01             	lea    0x1(%eax),%edx
f0107540:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107543:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0107549:	90                   	nop
f010754a:	c9                   	leave  
f010754b:	c3                   	ret    

f010754c <popcli>:

void popcli(void)
{
f010754c:	55                   	push   %ebp
f010754d:	89 e5                	mov    %esp,%ebp
f010754f:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107552:	9c                   	pushf  
f0107553:	58                   	pop    %eax
f0107554:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107557:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010755a:	25 00 02 00 00       	and    $0x200,%eax
f010755f:	85 c0                	test   %eax,%eax
f0107561:	74 14                	je     f0107577 <popcli+0x2b>
    panic("popcli - interruptible");
f0107563:	83 ec 04             	sub    $0x4,%esp
f0107566:	68 3f 5e 12 f0       	push   $0xf0125e3f
f010756b:	6a 5e                	push   $0x5e
f010756d:	68 56 5e 12 f0       	push   $0xf0125e56
f0107572:	e8 c2 8d ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f0107577:	e8 bb fe ff ff       	call   f0107437 <mycpu>
f010757c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f010757f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107582:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107588:	8d 50 ff             	lea    -0x1(%eax),%edx
f010758b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010758e:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010759d:	85 c0                	test   %eax,%eax
f010759f:	79 14                	jns    f01075b5 <popcli+0x69>
    panic("popcli");
f01075a1:	83 ec 04             	sub    $0x4,%esp
f01075a4:	68 65 5e 12 f0       	push   $0xf0125e65
f01075a9:	6a 61                	push   $0x61
f01075ab:	68 56 5e 12 f0       	push   $0xf0125e56
f01075b0:	e8 84 8d ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f01075b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075b8:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01075be:	85 c0                	test   %eax,%eax
f01075c0:	75 0e                	jne    f01075d0 <popcli+0x84>
f01075c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075c5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01075cb:	85 c0                	test   %eax,%eax
f01075cd:	74 01                	je     f01075d0 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01075cf:	fb                   	sti    
    sti();
}
f01075d0:	90                   	nop
f01075d1:	c9                   	leave  
f01075d2:	c3                   	ret    

f01075d3 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01075d3:	55                   	push   %ebp
f01075d4:	89 e5                	mov    %esp,%ebp
f01075d6:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01075d9:	e8 1c ff ff ff       	call   f01074fa <pushcli>

	c = mycpu();
f01075de:	e8 54 fe ff ff       	call   f0107437 <mycpu>
f01075e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01075e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075e9:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01075f0:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01075f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075fa:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0107609:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760c:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0107613:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107616:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010761c:	83 e2 f0             	and    $0xfffffff0,%edx
f010761f:	83 ca 0a             	or     $0xa,%edx
f0107622:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107628:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010762b:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107631:	83 ca 10             	or     $0x10,%edx
f0107634:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010763a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010763d:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107643:	83 e2 9f             	and    $0xffffff9f,%edx
f0107646:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010764c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010764f:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107655:	83 ca 80             	or     $0xffffff80,%edx
f0107658:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010765e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107661:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107667:	83 ca 0f             	or     $0xf,%edx
f010766a:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107670:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107673:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107679:	83 e2 ef             	and    $0xffffffef,%edx
f010767c:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107682:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107685:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010768b:	83 e2 df             	and    $0xffffffdf,%edx
f010768e:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107694:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107697:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010769d:	83 ca 40             	or     $0x40,%edx
f01076a0:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01076a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076a9:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01076af:	83 ca 80             	or     $0xffffff80,%edx
f01076b2:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01076b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076bb:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01076c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076c5:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01076cc:	ff ff 
f01076ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d1:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01076d8:	00 00 
f01076da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076dd:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01076e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076e7:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01076ed:	83 e2 f0             	and    $0xfffffff0,%edx
f01076f0:	83 ca 02             	or     $0x2,%edx
f01076f3:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01076f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076fc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107702:	83 ca 10             	or     $0x10,%edx
f0107705:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010770b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010770e:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107714:	83 e2 9f             	and    $0xffffff9f,%edx
f0107717:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010771d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107720:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107726:	83 ca 80             	or     $0xffffff80,%edx
f0107729:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010772f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107732:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107738:	83 ca 0f             	or     $0xf,%edx
f010773b:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107741:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107744:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010774a:	83 e2 ef             	and    $0xffffffef,%edx
f010774d:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107753:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107756:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010775c:	83 e2 df             	and    $0xffffffdf,%edx
f010775f:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107765:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107768:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010776e:	83 ca 40             	or     $0x40,%edx
f0107771:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107777:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010777a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107780:	83 ca 80             	or     $0xffffff80,%edx
f0107783:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107789:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010778c:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107793:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107796:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f010779d:	ff ff 
f010779f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077a2:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f01077a9:	00 00 
f01077ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077ae:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f01077b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077b8:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077be:	83 e2 f0             	and    $0xfffffff0,%edx
f01077c1:	83 ca 0a             	or     $0xa,%edx
f01077c4:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077cd:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077d3:	83 ca 10             	or     $0x10,%edx
f01077d6:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077df:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077e5:	83 ca 60             	or     $0x60,%edx
f01077e8:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01077ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077f1:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01077f7:	83 ca 80             	or     $0xffffff80,%edx
f01077fa:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107800:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107803:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107809:	83 ca 0f             	or     $0xf,%edx
f010780c:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107812:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107815:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010781b:	83 e2 ef             	and    $0xffffffef,%edx
f010781e:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107824:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107827:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010782d:	83 e2 df             	and    $0xffffffdf,%edx
f0107830:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107836:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107839:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010783f:	83 ca 40             	or     $0x40,%edx
f0107842:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107848:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010784b:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107851:	83 ca 80             	or     $0xffffff80,%edx
f0107854:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010785a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010785d:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107864:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107867:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f010786e:	ff ff 
f0107870:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107873:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010787a:	00 00 
f010787c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010787f:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f0107886:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107889:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010788f:	83 e2 f0             	and    $0xfffffff0,%edx
f0107892:	83 ca 02             	or     $0x2,%edx
f0107895:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010789b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010789e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078a4:	83 ca 10             	or     $0x10,%edx
f01078a7:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078b0:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078b6:	83 ca 60             	or     $0x60,%edx
f01078b9:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078c2:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01078c8:	83 ca 80             	or     $0xffffff80,%edx
f01078cb:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01078d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078d4:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078da:	83 ca 0f             	or     $0xf,%edx
f01078dd:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01078e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078e6:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078ec:	83 e2 ef             	and    $0xffffffef,%edx
f01078ef:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01078f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078f8:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01078fe:	83 e2 df             	and    $0xffffffdf,%edx
f0107901:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107907:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010790a:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107910:	83 ca 40             	or     $0x40,%edx
f0107913:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107919:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010791c:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107922:	83 ca 80             	or     $0xffffff80,%edx
f0107925:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010792b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010792e:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f0107935:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107938:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010793f:	00 00 00 
f0107942:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0107949:	00 00 00 

	popcli();	//enable interrupt
f010794c:	e8 fb fb ff ff       	call   f010754c <popcli>


}
f0107951:	90                   	nop
f0107952:	c9                   	leave  
f0107953:	c3                   	ret    

f0107954 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107954:	55                   	push   %ebp
f0107955:	89 e5                	mov    %esp,%ebp
f0107957:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010795a:	83 ec 08             	sub    $0x8,%esp
f010795d:	68 00 10 00 00       	push   $0x1000
f0107962:	68 00 10 00 00       	push   $0x1000
f0107967:	e8 42 02 00 00       	call   f0107bae <boot_allocate_space>
f010796c:	83 c4 10             	add    $0x10,%esp
f010796f:	a3 54 d9 f5 f0       	mov    %eax,0xf0f5d954
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107974:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107979:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010797c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107983:	77 14                	ja     f0107999 <initialize_kernel_VM+0x45>
f0107985:	ff 75 e0             	pushl  -0x20(%ebp)
f0107988:	68 6c 5e 12 f0       	push   $0xf0125e6c
f010798d:	6a 57                	push   $0x57
f010798f:	68 a0 5e 12 f0       	push   $0xf0125ea0
f0107994:	e8 a0 89 ff ff       	call   f0100339 <_panic>
f0107999:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010799c:	05 00 00 00 10       	add    $0x10000000,%eax
f01079a1:	a3 84 da f5 f0       	mov    %eax,0xf0f5da84
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f01079a6:	c7 45 dc 00 80 17 f0 	movl   $0xf0178000,-0x24(%ebp)
f01079ad:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01079b4:	77 14                	ja     f01079ca <initialize_kernel_VM+0x76>
f01079b6:	ff 75 dc             	pushl  -0x24(%ebp)
f01079b9:	68 6c 5e 12 f0       	push   $0xf0125e6c
f01079be:	6a 63                	push   $0x63
f01079c0:	68 a0 5e 12 f0       	push   $0xf0125ea0
f01079c5:	e8 6f 89 ff ff       	call   f0100339 <_panic>
f01079ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01079cd:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01079d3:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01079d8:	83 ec 0c             	sub    $0xc,%esp
f01079db:	6a 02                	push   $0x2
f01079dd:	52                   	push   %edx
f01079de:	68 00 80 00 00       	push   $0x8000
f01079e3:	68 00 80 bf ef       	push   $0xefbf8000
f01079e8:	50                   	push   %eax
f01079e9:	e8 34 02 00 00       	call   f0107c22 <boot_map_range>
f01079ee:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01079f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01079f8:	eb 24                	jmp    f0107a1e <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01079fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079fd:	40                   	inc    %eax
f01079fe:	c1 e0 0f             	shl    $0xf,%eax
f0107a01:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107a06:	29 c2                	sub    %eax,%edx
f0107a08:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107a0d:	6a 01                	push   $0x1
f0107a0f:	6a 00                	push   $0x0
f0107a11:	52                   	push   %edx
f0107a12:	50                   	push   %eax
f0107a13:	e8 91 25 00 00       	call   f0109fa9 <pt_set_page_permissions>
f0107a18:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107a1b:	ff 45 f4             	incl   -0xc(%ebp)
f0107a1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107a22:	7e d6                	jle    f01079fa <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f0107a24:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107a2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107a32:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107a39:	eb 25                	jmp    f0107a60 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107a3b:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107a3e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107a41:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107a46:	83 ec 04             	sub    $0x4,%esp
f0107a49:	6a 01                	push   $0x1
f0107a4b:	52                   	push   %edx
f0107a4c:	50                   	push   %eax
f0107a4d:	e8 44 02 00 00       	call   f0107c96 <boot_get_page_table>
f0107a52:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107a55:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107a5c:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107a60:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107a64:	72 d5                	jb     f0107a3b <initialize_kernel_VM+0xe7>
f0107a66:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107a6a:	77 06                	ja     f0107a72 <initialize_kernel_VM+0x11e>
f0107a6c:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107a70:	76 c9                	jbe    f0107a3b <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107a72:	8b 15 b8 d4 b5 f0    	mov    0xf0b5d4b8,%edx
f0107a78:	89 d0                	mov    %edx,%eax
f0107a7a:	01 c0                	add    %eax,%eax
f0107a7c:	01 d0                	add    %edx,%eax
f0107a7e:	c1 e0 03             	shl    $0x3,%eax
f0107a81:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107a84:	83 ec 08             	sub    $0x8,%esp
f0107a87:	68 00 10 00 00       	push   $0x1000
f0107a8c:	ff 75 d8             	pushl  -0x28(%ebp)
f0107a8f:	e8 1a 01 00 00       	call   f0107bae <boot_allocate_space>
f0107a94:	83 c4 10             	add    $0x10,%esp
f0107a97:	a3 20 d7 b5 f0       	mov    %eax,0xf0b5d720
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107a9c:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107aa3:	83 ec 08             	sub    $0x8,%esp
f0107aa6:	68 00 10 00 00       	push   $0x1000
f0107aab:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107aae:	e8 fb 00 00 00       	call   f0107bae <boot_allocate_space>
f0107ab3:	83 c4 10             	add    $0x10,%esp
f0107ab6:	a3 e0 cf 75 f0       	mov    %eax,0xf075cfe0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107abb:	e8 05 05 00 00       	call   f0107fc5 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107ac0:	83 ec 0c             	sub    $0xc,%esp
f0107ac3:	68 ca 02 00 00       	push   $0x2ca
f0107ac8:	e8 ad 6a 01 00       	call   f011e57a <nearest_pow2_ceil>
f0107acd:	83 c4 10             	add    $0x10,%esp
f0107ad0:	83 ec 04             	sub    $0x4,%esp
f0107ad3:	50                   	push   %eax
f0107ad4:	68 ca 02 00 00       	push   $0x2ca
f0107ad9:	68 c0 5e 12 f0       	push   $0xf0125ec0
f0107ade:	e8 a8 94 ff ff       	call   f0100f8b <cprintf>
f0107ae3:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0107ae6:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107aed:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107af0:	83 ec 08             	sub    $0x8,%esp
f0107af3:	68 00 10 00 00       	push   $0x1000
f0107af8:	50                   	push   %eax
f0107af9:	e8 b0 00 00 00       	call   f0107bae <boot_allocate_space>
f0107afe:	83 c4 10             	add    $0x10,%esp
f0107b01:	a3 30 47 73 f0       	mov    %eax,0xf0734730
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0107b06:	a1 30 47 73 f0       	mov    0xf0734730,%eax
f0107b0b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0107b0e:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f0107b15:	77 17                	ja     f0107b2e <initialize_kernel_VM+0x1da>
f0107b17:	ff 75 cc             	pushl  -0x34(%ebp)
f0107b1a:	68 6c 5e 12 f0       	push   $0xf0125e6c
f0107b1f:	68 b1 00 00 00       	push   $0xb1
f0107b24:	68 a0 5e 12 f0       	push   $0xf0125ea0
f0107b29:	e8 0b 88 ff ff       	call   f0100339 <_panic>
f0107b2e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107b31:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0107b37:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107b3a:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107b3f:	83 ec 0c             	sub    $0xc,%esp
f0107b42:	6a 04                	push   $0x4
f0107b44:	51                   	push   %ecx
f0107b45:	52                   	push   %edx
f0107b46:	68 00 00 c0 ee       	push   $0xeec00000
f0107b4b:	50                   	push   %eax
f0107b4c:	e8 d1 00 00 00       	call   f0107c22 <boot_map_range>
f0107b51:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107b54:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107b59:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107b5e:	8b 15 54 d9 f5 f0    	mov    0xf0f5d954,%edx
f0107b64:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f0107b6a:	8b 12                	mov    (%edx),%edx
f0107b6c:	83 ca 05             	or     $0x5,%edx
f0107b6f:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107b71:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f0107b76:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107b7c:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107b81:	83 ec 0c             	sub    $0xc,%esp
f0107b84:	6a 02                	push   $0x2
f0107b86:	6a 00                	push   $0x0
f0107b88:	52                   	push   %edx
f0107b89:	68 00 00 00 f0       	push   $0xf0000000
f0107b8e:	50                   	push   %eax
f0107b8f:	e8 8e 00 00 00       	call   f0107c22 <boot_map_range>
f0107b94:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107b97:	e8 b1 79 01 00       	call   f011f54d <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107b9c:	c7 05 f0 d3 b5 f0 19 	movl   $0x19,0xf0b5d3f0
f0107ba3:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107ba6:	e8 e6 02 00 00       	call   f0107e91 <turn_on_paging>
}
f0107bab:	90                   	nop
f0107bac:	c9                   	leave  
f0107bad:	c3                   	ret    

f0107bae <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107bae:	55                   	push   %ebp
f0107baf:	89 e5                	mov    %esp,%ebp
f0107bb1:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107bb4:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f0107bb9:	85 c0                	test   %eax,%eax
f0107bbb:	75 0a                	jne    f0107bc7 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107bbd:	c7 05 50 d9 f5 f0 70 	movl   $0xf26f0470,0xf0f5d950
f0107bc4:	04 6f f2 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107bca:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107bcd:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f0107bd2:	89 c2                	mov    %eax,%edx
f0107bd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bd7:	01 d0                	add    %edx,%eax
f0107bd9:	48                   	dec    %eax
f0107bda:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107bdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107be0:	ba 00 00 00 00       	mov    $0x0,%edx
f0107be5:	f7 75 f4             	divl   -0xc(%ebp)
f0107be8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107beb:	29 d0                	sub    %edx,%eax
f0107bed:	a3 50 d9 f5 f0       	mov    %eax,0xf0f5d950

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0107bf2:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f0107bf7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0107bfa:	8b 15 50 d9 f5 f0    	mov    0xf0f5d950,%edx
f0107c00:	8b 45 08             	mov    0x8(%ebp),%eax
f0107c03:	01 d0                	add    %edx,%eax
f0107c05:	a3 50 d9 f5 f0       	mov    %eax,0xf0f5d950

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0107c0a:	83 ec 04             	sub    $0x4,%esp
f0107c0d:	ff 75 08             	pushl  0x8(%ebp)
f0107c10:	6a 00                	push   $0x0
f0107c12:	ff 75 ec             	pushl  -0x14(%ebp)
f0107c15:	e8 f0 85 01 00       	call   f012020a <memset>
f0107c1a:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0107c1d:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0107c20:	c9                   	leave  
f0107c21:	c3                   	ret    

f0107c22 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0107c22:	55                   	push   %ebp
f0107c23:	89 e5                	mov    %esp,%ebp
f0107c25:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0107c28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107c2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107c36:	eb 53                	jmp    f0107c8b <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f0107c38:	83 ec 04             	sub    $0x4,%esp
f0107c3b:	6a 01                	push   $0x1
f0107c3d:	ff 75 0c             	pushl  0xc(%ebp)
f0107c40:	ff 75 08             	pushl  0x8(%ebp)
f0107c43:	e8 4e 00 00 00       	call   f0107c96 <boot_get_page_table>
f0107c48:	83 c4 10             	add    $0x10,%esp
f0107c4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107c51:	c1 e8 0c             	shr    $0xc,%eax
f0107c54:	25 ff 03 00 00       	and    $0x3ff,%eax
f0107c59:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c5f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107c66:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107c69:	01 c2                	add    %eax,%edx
f0107c6b:	8b 45 18             	mov    0x18(%ebp),%eax
f0107c6e:	0b 45 14             	or     0x14(%ebp),%eax
f0107c71:	83 c8 01             	or     $0x1,%eax
f0107c74:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0107c76:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107c7d:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107c84:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107c8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c8e:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107c91:	72 a5                	jb     f0107c38 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107c93:	90                   	nop
f0107c94:	c9                   	leave  
f0107c95:	c3                   	ret    

f0107c96 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0107c96:	55                   	push   %ebp
f0107c97:	89 e5                	mov    %esp,%ebp
f0107c99:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107c9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107c9f:	c1 e8 16             	shr    $0x16,%eax
f0107ca2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f0107ca5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ca8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107caf:	8b 45 08             	mov    0x8(%ebp),%eax
f0107cb2:	01 d0                	add    %edx,%eax
f0107cb4:	8b 00                	mov    (%eax),%eax
f0107cb6:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107cb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107cbc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107cc1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107cc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107cc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107cca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107ccd:	c1 e8 0c             	shr    $0xc,%eax
f0107cd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107cd3:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0107cd8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107cdb:	72 17                	jb     f0107cf4 <boot_get_page_table+0x5e>
f0107cdd:	ff 75 e8             	pushl  -0x18(%ebp)
f0107ce0:	68 e8 5e 12 f0       	push   $0xf0125ee8
f0107ce5:	68 33 01 00 00       	push   $0x133
f0107cea:	68 a0 5e 12 f0       	push   $0xf0125ea0
f0107cef:	e8 45 86 ff ff       	call   f0100339 <_panic>
f0107cf4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107cf7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0107cfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0107cff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107d03:	75 72                	jne    f0107d77 <boot_get_page_table+0xe1>
	{
		if (create)
f0107d05:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107d09:	74 65                	je     f0107d70 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0107d0b:	83 ec 08             	sub    $0x8,%esp
f0107d0e:	68 00 10 00 00       	push   $0x1000
f0107d13:	68 00 10 00 00       	push   $0x1000
f0107d18:	e8 91 fe ff ff       	call   f0107bae <boot_allocate_space>
f0107d1d:	83 c4 10             	add    $0x10,%esp
f0107d20:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f0107d23:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d26:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107d29:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107d30:	77 17                	ja     f0107d49 <boot_get_page_table+0xb3>
f0107d32:	ff 75 dc             	pushl  -0x24(%ebp)
f0107d35:	68 6c 5e 12 f0       	push   $0xf0125e6c
f0107d3a:	68 39 01 00 00       	push   $0x139
f0107d3f:	68 a0 5e 12 f0       	push   $0xf0125ea0
f0107d44:	e8 f0 85 ff ff       	call   f0100339 <_panic>
f0107d49:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d4c:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d51:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107d57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107d5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d61:	01 d0                	add    %edx,%eax
f0107d63:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107d66:	83 ca 03             	or     $0x3,%edx
f0107d69:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107d6b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d6e:	eb 0a                	jmp    f0107d7a <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107d70:	b8 00 00 00 00       	mov    $0x0,%eax
f0107d75:	eb 03                	jmp    f0107d7a <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107d77:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107d7a:	c9                   	leave  
f0107d7b:	c3                   	ret    

f0107d7c <nvram_read>:


int nvram_read(int r)
{
f0107d7c:	55                   	push   %ebp
f0107d7d:	89 e5                	mov    %esp,%ebp
f0107d7f:	53                   	push   %ebx
f0107d80:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107d83:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d86:	83 ec 0c             	sub    $0xc,%esp
f0107d89:	50                   	push   %eax
f0107d8a:	e8 eb cf ff ff       	call   f0104d7a <mc146818_read>
f0107d8f:	83 c4 10             	add    $0x10,%esp
f0107d92:	89 c3                	mov    %eax,%ebx
f0107d94:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d97:	40                   	inc    %eax
f0107d98:	83 ec 0c             	sub    $0xc,%esp
f0107d9b:	50                   	push   %eax
f0107d9c:	e8 d9 cf ff ff       	call   f0104d7a <mc146818_read>
f0107da1:	83 c4 10             	add    $0x10,%esp
f0107da4:	c1 e0 08             	shl    $0x8,%eax
f0107da7:	09 d8                	or     %ebx,%eax
}
f0107da9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107dac:	c9                   	leave  
f0107dad:	c3                   	ret    

f0107dae <detect_memory>:

void detect_memory()
{
f0107dae:	55                   	push   %ebp
f0107daf:	89 e5                	mov    %esp,%ebp
f0107db1:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107db4:	83 ec 0c             	sub    $0xc,%esp
f0107db7:	6a 15                	push   $0x15
f0107db9:	e8 be ff ff ff       	call   f0107d7c <nvram_read>
f0107dbe:	83 c4 10             	add    $0x10,%esp
f0107dc1:	c1 e0 0a             	shl    $0xa,%eax
f0107dc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107dc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107dca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107dcf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107dd2:	83 ec 0c             	sub    $0xc,%esp
f0107dd5:	6a 17                	push   $0x17
f0107dd7:	e8 a0 ff ff ff       	call   f0107d7c <nvram_read>
f0107ddc:	83 c4 10             	add    $0x10,%esp
f0107ddf:	c1 e0 0a             	shl    $0xa,%eax
f0107de2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107de5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107de8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ded:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107df0:	83 ec 0c             	sub    $0xc,%esp
f0107df3:	6a 34                	push   $0x34
f0107df5:	e8 82 ff ff ff       	call   f0107d7c <nvram_read>
f0107dfa:	83 c4 10             	add    $0x10,%esp
f0107dfd:	c1 e0 10             	shl    $0x10,%eax
f0107e00:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107e03:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107e06:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107e0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107e0e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107e12:	74 18                	je     f0107e2c <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107e14:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107e17:	05 00 00 00 01       	add    $0x1000000,%eax
f0107e1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107e1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e22:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107e27:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107e2a:	eb 19                	jmp    f0107e45 <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107e30:	74 0d                	je     f0107e3f <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107e32:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e35:	05 00 00 10 00       	add    $0x100000,%eax
f0107e3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107e3d:	eb 06                	jmp    f0107e45 <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107e3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e42:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107e45:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107e4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e4f:	c1 e8 0c             	shr    $0xc,%eax
f0107e52:	a3 b8 d4 b5 f0       	mov    %eax,0xf0b5d4b8

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e5a:	c1 e8 0a             	shr    $0xa,%eax
f0107e5d:	83 ec 08             	sub    $0x8,%esp
f0107e60:	50                   	push   %eax
f0107e61:	68 18 5f 12 f0       	push   $0xf0125f18
f0107e66:	e8 20 91 ff ff       	call   f0100f8b <cprintf>
f0107e6b:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107e6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e71:	c1 e8 0a             	shr    $0xa,%eax
f0107e74:	89 c2                	mov    %eax,%edx
f0107e76:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107e79:	c1 e8 0a             	shr    $0xa,%eax
f0107e7c:	83 ec 04             	sub    $0x4,%esp
f0107e7f:	52                   	push   %edx
f0107e80:	50                   	push   %eax
f0107e81:	68 3b 5f 12 f0       	push   $0xf0125f3b
f0107e86:	e8 00 91 ff ff       	call   f0100f8b <cprintf>
f0107e8b:	83 c4 10             	add    $0x10,%esp
}
f0107e8e:	90                   	nop
f0107e8f:	c9                   	leave  
f0107e90:	c3                   	ret    

f0107e91 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107e91:	55                   	push   %ebp
f0107e92:	89 e5                	mov    %esp,%ebp
f0107e94:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107e97:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107e9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107ea5:	eb 24                	jmp    f0107ecb <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107ea7:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107eac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107eaf:	c1 e2 02             	shl    $0x2,%edx
f0107eb2:	01 c2                	add    %eax,%edx
f0107eb4:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107eb9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107ebc:	c1 e1 02             	shl    $0x2,%ecx
f0107ebf:	01 c8                	add    %ecx,%eax
f0107ec1:	8b 00                	mov    (%eax),%eax
f0107ec3:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107ec5:	ff 45 f4             	incl   -0xc(%ebp)
f0107ec8:	ff 45 f0             	incl   -0x10(%ebp)
f0107ecb:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f0107ed0:	c1 e8 16             	shr    $0x16,%eax
f0107ed3:	89 c2                	mov    %eax,%edx
f0107ed5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ed8:	39 c2                	cmp    %eax,%edx
f0107eda:	77 cb                	ja     f0107ea7 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107edc:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f0107ee1:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107ee4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107ee7:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107eea:	0f 20 c0             	mov    %cr0,%eax
f0107eed:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107ef0:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107ef3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107ef6:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107efd:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107f01:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107f04:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107f07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107f0a:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107f0d:	e8 e8 f5 ff ff       	call   f01074fa <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107f12:	e8 20 f5 ff ff       	call   f0107437 <mycpu>
f0107f17:	83 c0 74             	add    $0x74,%eax
f0107f1a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107f1d:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107f24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107f27:	48                   	dec    %eax
f0107f28:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107f2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107f2f:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107f33:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107f36:	c1 e8 10             	shr    $0x10,%eax
f0107f39:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107f3d:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107f40:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107f43:	e8 04 f6 ff ff       	call   f010754c <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107f48:	b8 23 00 00 00       	mov    $0x23,%eax
f0107f4d:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107f4f:	b8 23 00 00 00       	mov    $0x23,%eax
f0107f54:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107f56:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f5b:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107f5d:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f62:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107f64:	b8 10 00 00 00       	mov    $0x10,%eax
f0107f69:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107f6b:	ea 72 7f 10 f0 08 00 	ljmp   $0x8,$0xf0107f72
	asm volatile("lldt %%ax" :: "a" (0));
f0107f72:	b8 00 00 00 00       	mov    $0x0,%eax
f0107f77:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107f7a:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107f81:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107f88:	eb 19                	jmp    f0107fa3 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107f8a:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107f8f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107f92:	c1 e2 02             	shl    $0x2,%edx
f0107f95:	01 d0                	add    %edx,%eax
f0107f97:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107f9d:	ff 45 ec             	incl   -0x14(%ebp)
f0107fa0:	ff 45 e8             	incl   -0x18(%ebp)
f0107fa3:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f0107fa8:	c1 e8 16             	shr    $0x16,%eax
f0107fab:	89 c2                	mov    %eax,%edx
f0107fad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107fb0:	39 c2                	cmp    %eax,%edx
f0107fb2:	77 d6                	ja     f0107f8a <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107fb4:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f0107fb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107fbf:	0f 22 d8             	mov    %eax,%cr3

}
f0107fc2:	90                   	nop
f0107fc3:	c9                   	leave  
f0107fc4:	c3                   	ret    

f0107fc5 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107fc5:	55                   	push   %ebp
f0107fc6:	89 e5                	mov    %esp,%ebp
f0107fc8:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107fcb:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0107fd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107fd3:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107fda:	77 17                	ja     f0107ff3 <setup_listing_to_all_page_tables_entries+0x2e>
f0107fdc:	ff 75 f4             	pushl  -0xc(%ebp)
f0107fdf:	68 6c 5e 12 f0       	push   $0xf0125e6c
f0107fe4:	68 cf 01 00 00       	push   $0x1cf
f0107fe9:	68 a0 5e 12 f0       	push   $0xf0125ea0
f0107fee:	e8 46 83 ff ff       	call   f0100339 <_panic>
f0107ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ff6:	05 00 00 00 10       	add    $0x10000000,%eax
f0107ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107ffe:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0108003:	05 fc 0e 00 00       	add    $0xefc,%eax
f0108008:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010800b:	83 ca 03             	or     $0x3,%edx
f010800e:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0108010:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0108015:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010801b:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0108020:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108023:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f010802a:	77 17                	ja     f0108043 <setup_listing_to_all_page_tables_entries+0x7e>
f010802c:	ff 75 ec             	pushl  -0x14(%ebp)
f010802f:	68 6c 5e 12 f0       	push   $0xf0125e6c
f0108034:	68 d4 01 00 00       	push   $0x1d4
f0108039:	68 a0 5e 12 f0       	push   $0xf0125ea0
f010803e:	e8 f6 82 ff ff       	call   f0100339 <_panic>
f0108043:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108046:	05 00 00 00 10       	add    $0x10000000,%eax
f010804b:	83 c8 05             	or     $0x5,%eax
f010804e:	89 02                	mov    %eax,(%edx)

}
f0108050:	90                   	nop
f0108051:	c9                   	leave  
f0108052:	c3                   	ret    

f0108053 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108053:	55                   	push   %ebp
f0108054:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108056:	8b 45 08             	mov    0x8(%ebp),%eax
f0108059:	8b 15 20 d7 b5 f0    	mov    0xf0b5d720,%edx
f010805f:	29 d0                	sub    %edx,%eax
f0108061:	c1 f8 03             	sar    $0x3,%eax
f0108064:	89 c2                	mov    %eax,%edx
f0108066:	89 d0                	mov    %edx,%eax
f0108068:	c1 e0 02             	shl    $0x2,%eax
f010806b:	01 d0                	add    %edx,%eax
f010806d:	c1 e0 02             	shl    $0x2,%eax
f0108070:	01 d0                	add    %edx,%eax
f0108072:	c1 e0 02             	shl    $0x2,%eax
f0108075:	01 d0                	add    %edx,%eax
f0108077:	89 c1                	mov    %eax,%ecx
f0108079:	c1 e1 08             	shl    $0x8,%ecx
f010807c:	01 c8                	add    %ecx,%eax
f010807e:	89 c1                	mov    %eax,%ecx
f0108080:	c1 e1 10             	shl    $0x10,%ecx
f0108083:	01 c8                	add    %ecx,%eax
f0108085:	01 c0                	add    %eax,%eax
f0108087:	01 d0                	add    %edx,%eax
}
f0108089:	5d                   	pop    %ebp
f010808a:	c3                   	ret    

f010808b <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010808b:	55                   	push   %ebp
f010808c:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010808e:	ff 75 08             	pushl  0x8(%ebp)
f0108091:	e8 bd ff ff ff       	call   f0108053 <to_frame_number>
f0108096:	83 c4 04             	add    $0x4,%esp
f0108099:	c1 e0 0c             	shl    $0xc,%eax
}
f010809c:	c9                   	leave  
f010809d:	c3                   	ret    

f010809e <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010809e:	55                   	push   %ebp
f010809f:	89 e5                	mov    %esp,%ebp
f01080a1:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f01080a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01080a7:	c1 e8 0c             	shr    $0xc,%eax
f01080aa:	89 c2                	mov    %eax,%edx
f01080ac:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f01080b1:	39 c2                	cmp    %eax,%edx
f01080b3:	72 14                	jb     f01080c9 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f01080b5:	83 ec 04             	sub    $0x4,%esp
f01080b8:	68 58 5f 12 f0       	push   $0xf0125f58
f01080bd:	6a 56                	push   $0x56
f01080bf:	68 7d 5f 12 f0       	push   $0xf0125f7d
f01080c4:	e8 70 82 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f01080c9:	8b 15 20 d7 b5 f0    	mov    0xf0b5d720,%edx
f01080cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01080d2:	c1 e8 0c             	shr    $0xc,%eax
f01080d5:	89 c1                	mov    %eax,%ecx
f01080d7:	89 c8                	mov    %ecx,%eax
f01080d9:	01 c0                	add    %eax,%eax
f01080db:	01 c8                	add    %ecx,%eax
f01080dd:	c1 e0 03             	shl    $0x3,%eax
f01080e0:	01 d0                	add    %edx,%eax
}
f01080e2:	c9                   	leave  
f01080e3:	c3                   	ret    

f01080e4 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f01080e4:	55                   	push   %ebp
f01080e5:	89 e5                	mov    %esp,%ebp
f01080e7:	83 ec 10             	sub    $0x10,%esp
f01080ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01080ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f01080f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01080f3:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f01080f6:	90                   	nop
f01080f7:	c9                   	leave  
f01080f8:	c3                   	ret    

f01080f9 <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f01080f9:	55                   	push   %ebp
f01080fa:	89 e5                	mov    %esp,%ebp
f01080fc:	53                   	push   %ebx
f01080fd:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0108100:	c7 05 c0 d2 b5 f0 00 	movl   $0x0,0xf0b5d2c0
f0108107:	00 00 00 
f010810a:	c7 05 c4 d2 b5 f0 00 	movl   $0x0,0xf0b5d2c4
f0108111:	00 00 00 
f0108114:	c7 05 cc d2 b5 f0 00 	movl   $0x0,0xf0b5d2cc
f010811b:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f010811e:	c7 05 d0 d2 b5 f0 00 	movl   $0x0,0xf0b5d2d0
f0108125:	00 00 00 
f0108128:	c7 05 d4 d2 b5 f0 00 	movl   $0x0,0xf0b5d2d4
f010812f:	00 00 00 
f0108132:	c7 05 dc d2 b5 f0 00 	movl   $0x0,0xf0b5d2dc
f0108139:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f010813c:	83 ec 08             	sub    $0x8,%esp
f010813f:	68 97 5f 12 f0       	push   $0xf0125f97
f0108144:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f0108149:	e8 ef 7e 00 00       	call   f011003d <init_spinlock>
f010814e:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0108151:	a1 20 d7 b5 f0       	mov    0xf0b5d720,%eax
f0108156:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f010815c:	a1 20 d7 b5 f0       	mov    0xf0b5d720,%eax
f0108161:	83 c0 18             	add    $0x18,%eax
f0108164:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f010816a:	a1 20 d7 b5 f0       	mov    0xf0b5d720,%eax
f010816f:	83 c0 30             	add    $0x30,%eax
f0108172:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0108178:	c7 05 bc d7 b5 f0 00 	movl   $0xf0001000,0xf0b5d7bc
f010817f:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0108182:	c7 05 ec d9 f5 f0 00 	movl   $0xf0002000,0xf0f5d9ec
f0108189:	20 00 f0 
	i =0;
f010818c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0108193:	eb 1f                	jmp    f01081b4 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0108195:	8b 15 bc d7 b5 f0    	mov    0xf0b5d7bc,%edx
f010819b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010819e:	01 d0                	add    %edx,%eax
f01081a0:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f01081a3:	8b 15 ec d9 f5 f0    	mov    0xf0f5d9ec,%edx
f01081a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081ac:	01 d0                	add    %edx,%eax
f01081ae:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f01081b1:	ff 45 f4             	incl   -0xc(%ebp)
f01081b4:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01081bb:	7e d8                	jle    f0108195 <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f01081bd:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01081c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01081c7:	05 ff ff 09 00       	add    $0x9ffff,%eax
f01081cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01081cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01081d2:	ba 00 00 00 00       	mov    $0x0,%edx
f01081d7:	f7 75 f0             	divl   -0x10(%ebp)
f01081da:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01081dd:	29 d0                	sub    %edx,%eax
f01081df:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01081e2:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f01081e9:	e9 e8 00 00 00       	jmp    f01082d6 <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f01081ee:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f01081f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01081f7:	89 d0                	mov    %edx,%eax
f01081f9:	01 c0                	add    %eax,%eax
f01081fb:	01 d0                	add    %edx,%eax
f01081fd:	c1 e0 03             	shl    $0x3,%eax
f0108200:	01 c8                	add    %ecx,%eax
f0108202:	83 ec 0c             	sub    $0xc,%esp
f0108205:	50                   	push   %eax
f0108206:	e8 b7 02 00 00       	call   f01084c2 <initialize_frame_info>
f010820b:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f010820e:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f0108214:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108217:	89 d0                	mov    %edx,%eax
f0108219:	01 c0                	add    %eax,%eax
f010821b:	01 d0                	add    %edx,%eax
f010821d:	c1 e0 03             	shl    $0x3,%eax
f0108220:	01 c8                	add    %ecx,%eax
f0108222:	85 c0                	test   %eax,%eax
f0108224:	75 14                	jne    f010823a <initialize_paging+0x141>
f0108226:	83 ec 04             	sub    $0x4,%esp
f0108229:	68 a8 5f 12 f0       	push   $0xf0125fa8
f010822e:	6a 60                	push   $0x60
f0108230:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108235:	e8 ff 80 ff ff       	call   f0100339 <_panic>
f010823a:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f0108240:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108243:	89 d0                	mov    %edx,%eax
f0108245:	01 c0                	add    %eax,%eax
f0108247:	01 d0                	add    %edx,%eax
f0108249:	c1 e0 03             	shl    $0x3,%eax
f010824c:	01 c8                	add    %ecx,%eax
f010824e:	8b 15 c0 d2 b5 f0    	mov    0xf0b5d2c0,%edx
f0108254:	89 10                	mov    %edx,(%eax)
f0108256:	8b 00                	mov    (%eax),%eax
f0108258:	85 c0                	test   %eax,%eax
f010825a:	74 1f                	je     f010827b <initialize_paging+0x182>
f010825c:	8b 15 c0 d2 b5 f0    	mov    0xf0b5d2c0,%edx
f0108262:	8b 1d 20 d7 b5 f0    	mov    0xf0b5d720,%ebx
f0108268:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010826b:	89 c8                	mov    %ecx,%eax
f010826d:	01 c0                	add    %eax,%eax
f010826f:	01 c8                	add    %ecx,%eax
f0108271:	c1 e0 03             	shl    $0x3,%eax
f0108274:	01 d8                	add    %ebx,%eax
f0108276:	89 42 04             	mov    %eax,0x4(%edx)
f0108279:	eb 19                	jmp    f0108294 <initialize_paging+0x19b>
f010827b:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f0108281:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108284:	89 d0                	mov    %edx,%eax
f0108286:	01 c0                	add    %eax,%eax
f0108288:	01 d0                	add    %edx,%eax
f010828a:	c1 e0 03             	shl    $0x3,%eax
f010828d:	01 c8                	add    %ecx,%eax
f010828f:	a3 c4 d2 b5 f0       	mov    %eax,0xf0b5d2c4
f0108294:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f010829a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010829d:	89 d0                	mov    %edx,%eax
f010829f:	01 c0                	add    %eax,%eax
f01082a1:	01 d0                	add    %edx,%eax
f01082a3:	c1 e0 03             	shl    $0x3,%eax
f01082a6:	01 c8                	add    %ecx,%eax
f01082a8:	a3 c0 d2 b5 f0       	mov    %eax,0xf0b5d2c0
f01082ad:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f01082b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01082b6:	89 d0                	mov    %edx,%eax
f01082b8:	01 c0                	add    %eax,%eax
f01082ba:	01 d0                	add    %edx,%eax
f01082bc:	c1 e0 03             	shl    $0x3,%eax
f01082bf:	01 c8                	add    %ecx,%eax
f01082c1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082c8:	a1 cc d2 b5 f0       	mov    0xf0b5d2cc,%eax
f01082cd:	40                   	inc    %eax
f01082ce:	a3 cc d2 b5 f0       	mov    %eax,0xf0b5d2cc
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f01082d3:	ff 45 f4             	incl   -0xc(%ebp)
f01082d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01082d9:	85 c0                	test   %eax,%eax
f01082db:	79 05                	jns    f01082e2 <initialize_paging+0x1e9>
f01082dd:	05 ff 0f 00 00       	add    $0xfff,%eax
f01082e2:	c1 f8 0c             	sar    $0xc,%eax
f01082e5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01082e8:	0f 8f 00 ff ff ff    	jg     f01081ee <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f01082ee:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f01082f5:	eb 1d                	jmp    f0108314 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f01082f7:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f01082fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108300:	89 d0                	mov    %edx,%eax
f0108302:	01 c0                	add    %eax,%eax
f0108304:	01 d0                	add    %edx,%eax
f0108306:	c1 e0 03             	shl    $0x3,%eax
f0108309:	01 c8                	add    %ecx,%eax
f010830b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108311:	ff 45 f4             	incl   -0xc(%ebp)
f0108314:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010831b:	7e da                	jle    f01082f7 <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f010831d:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108324:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f0108329:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010832c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108333:	77 14                	ja     f0108349 <initialize_paging+0x250>
f0108335:	ff 75 e0             	pushl  -0x20(%ebp)
f0108338:	68 e8 5f 12 f0       	push   $0xf0125fe8
f010833d:	6a 68                	push   $0x68
f010833f:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108344:	e8 f0 7f ff ff       	call   f0100339 <_panic>
f0108349:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010834c:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108352:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108355:	01 d0                	add    %edx,%eax
f0108357:	48                   	dec    %eax
f0108358:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010835b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010835e:	ba 00 00 00 00       	mov    $0x0,%edx
f0108363:	f7 75 e4             	divl   -0x1c(%ebp)
f0108366:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108369:	29 d0                	sub    %edx,%eax
f010836b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f010836e:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108375:	eb 1d                	jmp    f0108394 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f0108377:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f010837d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108380:	89 d0                	mov    %edx,%eax
f0108382:	01 c0                	add    %eax,%eax
f0108384:	01 d0                	add    %edx,%eax
f0108386:	c1 e0 03             	shl    $0x3,%eax
f0108389:	01 c8                	add    %ecx,%eax
f010838b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108391:	ff 45 f4             	incl   -0xc(%ebp)
f0108394:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108397:	85 c0                	test   %eax,%eax
f0108399:	79 05                	jns    f01083a0 <initialize_paging+0x2a7>
f010839b:	05 ff 0f 00 00       	add    $0xfff,%eax
f01083a0:	c1 f8 0c             	sar    $0xc,%eax
f01083a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01083a6:	7f cf                	jg     f0108377 <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f01083a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01083ab:	85 c0                	test   %eax,%eax
f01083ad:	79 05                	jns    f01083b4 <initialize_paging+0x2bb>
f01083af:	05 ff 0f 00 00       	add    $0xfff,%eax
f01083b4:	c1 f8 0c             	sar    $0xc,%eax
f01083b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01083ba:	e9 e8 00 00 00       	jmp    f01084a7 <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f01083bf:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f01083c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01083c8:	89 d0                	mov    %edx,%eax
f01083ca:	01 c0                	add    %eax,%eax
f01083cc:	01 d0                	add    %edx,%eax
f01083ce:	c1 e0 03             	shl    $0x3,%eax
f01083d1:	01 c8                	add    %ecx,%eax
f01083d3:	83 ec 0c             	sub    $0xc,%esp
f01083d6:	50                   	push   %eax
f01083d7:	e8 e6 00 00 00       	call   f01084c2 <initialize_frame_info>
f01083dc:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01083df:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f01083e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01083e8:	89 d0                	mov    %edx,%eax
f01083ea:	01 c0                	add    %eax,%eax
f01083ec:	01 d0                	add    %edx,%eax
f01083ee:	c1 e0 03             	shl    $0x3,%eax
f01083f1:	01 c8                	add    %ecx,%eax
f01083f3:	85 c0                	test   %eax,%eax
f01083f5:	75 14                	jne    f010840b <initialize_paging+0x312>
f01083f7:	83 ec 04             	sub    $0x4,%esp
f01083fa:	68 a8 5f 12 f0       	push   $0xf0125fa8
f01083ff:	6a 74                	push   $0x74
f0108401:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108406:	e8 2e 7f ff ff       	call   f0100339 <_panic>
f010840b:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f0108411:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108414:	89 d0                	mov    %edx,%eax
f0108416:	01 c0                	add    %eax,%eax
f0108418:	01 d0                	add    %edx,%eax
f010841a:	c1 e0 03             	shl    $0x3,%eax
f010841d:	01 c8                	add    %ecx,%eax
f010841f:	8b 15 c0 d2 b5 f0    	mov    0xf0b5d2c0,%edx
f0108425:	89 10                	mov    %edx,(%eax)
f0108427:	8b 00                	mov    (%eax),%eax
f0108429:	85 c0                	test   %eax,%eax
f010842b:	74 1f                	je     f010844c <initialize_paging+0x353>
f010842d:	8b 15 c0 d2 b5 f0    	mov    0xf0b5d2c0,%edx
f0108433:	8b 1d 20 d7 b5 f0    	mov    0xf0b5d720,%ebx
f0108439:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010843c:	89 c8                	mov    %ecx,%eax
f010843e:	01 c0                	add    %eax,%eax
f0108440:	01 c8                	add    %ecx,%eax
f0108442:	c1 e0 03             	shl    $0x3,%eax
f0108445:	01 d8                	add    %ebx,%eax
f0108447:	89 42 04             	mov    %eax,0x4(%edx)
f010844a:	eb 19                	jmp    f0108465 <initialize_paging+0x36c>
f010844c:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f0108452:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108455:	89 d0                	mov    %edx,%eax
f0108457:	01 c0                	add    %eax,%eax
f0108459:	01 d0                	add    %edx,%eax
f010845b:	c1 e0 03             	shl    $0x3,%eax
f010845e:	01 c8                	add    %ecx,%eax
f0108460:	a3 c4 d2 b5 f0       	mov    %eax,0xf0b5d2c4
f0108465:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f010846b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010846e:	89 d0                	mov    %edx,%eax
f0108470:	01 c0                	add    %eax,%eax
f0108472:	01 d0                	add    %edx,%eax
f0108474:	c1 e0 03             	shl    $0x3,%eax
f0108477:	01 c8                	add    %ecx,%eax
f0108479:	a3 c0 d2 b5 f0       	mov    %eax,0xf0b5d2c0
f010847e:	8b 0d 20 d7 b5 f0    	mov    0xf0b5d720,%ecx
f0108484:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108487:	89 d0                	mov    %edx,%eax
f0108489:	01 c0                	add    %eax,%eax
f010848b:	01 d0                	add    %edx,%eax
f010848d:	c1 e0 03             	shl    $0x3,%eax
f0108490:	01 c8                	add    %ecx,%eax
f0108492:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108499:	a1 cc d2 b5 f0       	mov    0xf0b5d2cc,%eax
f010849e:	40                   	inc    %eax
f010849f:	a3 cc d2 b5 f0       	mov    %eax,0xf0b5d2cc
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f01084a4:	ff 45 f4             	incl   -0xc(%ebp)
f01084a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01084aa:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f01084af:	39 c2                	cmp    %eax,%edx
f01084b1:	0f 82 08 ff ff ff    	jb     f01083bf <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f01084b7:	e8 c9 b9 ff ff       	call   f0103e85 <initialize_disk_page_file>
}
f01084bc:	90                   	nop
f01084bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01084c0:	c9                   	leave  
f01084c1:	c3                   	ret    

f01084c2 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f01084c2:	55                   	push   %ebp
f01084c3:	89 e5                	mov    %esp,%ebp
f01084c5:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f01084c8:	83 ec 04             	sub    $0x4,%esp
f01084cb:	6a 18                	push   $0x18
f01084cd:	6a 00                	push   $0x0
f01084cf:	ff 75 08             	pushl  0x8(%ebp)
f01084d2:	e8 33 7d 01 00       	call   f012020a <memset>
f01084d7:	83 c4 10             	add    $0x10,%esp
}
f01084da:	90                   	nop
f01084db:	c9                   	leave  
f01084dc:	c3                   	ret    

f01084dd <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01084dd:	55                   	push   %ebp
f01084de:	89 e5                	mov    %esp,%ebp
f01084e0:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01084e3:	83 ec 0c             	sub    $0xc,%esp
f01084e6:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f01084eb:	e8 97 7d 00 00       	call   f0110287 <holding_spinlock>
f01084f0:	83 c4 10             	add    $0x10,%esp
f01084f3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01084f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01084fa:	75 10                	jne    f010850c <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01084fc:	83 ec 0c             	sub    $0xc,%esp
f01084ff:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f0108504:	e8 65 7b 00 00       	call   f011006e <acquire_spinlock>
f0108509:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f010850c:	8b 15 c0 d2 b5 f0    	mov    0xf0b5d2c0,%edx
f0108512:	8b 45 08             	mov    0x8(%ebp),%eax
f0108515:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0108517:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f010851e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108521:	8b 00                	mov    (%eax),%eax
f0108523:	85 c0                	test   %eax,%eax
f0108525:	75 17                	jne    f010853e <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0108527:	83 ec 04             	sub    $0x4,%esp
f010852a:	68 1c 60 12 f0       	push   $0xf012601c
f010852f:	68 a2 00 00 00       	push   $0xa2
f0108534:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108539:	e8 fb 7d ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f010853e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108541:	8b 00                	mov    (%eax),%eax
f0108543:	85 c0                	test   %eax,%eax
f0108545:	75 17                	jne    f010855e <allocate_frame+0x81>
f0108547:	83 ec 04             	sub    $0x4,%esp
f010854a:	68 69 60 12 f0       	push   $0xf0126069
f010854f:	68 a8 00 00 00       	push   $0xa8
f0108554:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108559:	e8 db 7d ff ff       	call   f0100339 <_panic>
f010855e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108561:	8b 00                	mov    (%eax),%eax
f0108563:	8b 00                	mov    (%eax),%eax
f0108565:	85 c0                	test   %eax,%eax
f0108567:	74 14                	je     f010857d <allocate_frame+0xa0>
f0108569:	8b 45 08             	mov    0x8(%ebp),%eax
f010856c:	8b 00                	mov    (%eax),%eax
f010856e:	8b 00                	mov    (%eax),%eax
f0108570:	8b 55 08             	mov    0x8(%ebp),%edx
f0108573:	8b 12                	mov    (%edx),%edx
f0108575:	8b 52 04             	mov    0x4(%edx),%edx
f0108578:	89 50 04             	mov    %edx,0x4(%eax)
f010857b:	eb 0d                	jmp    f010858a <allocate_frame+0xad>
f010857d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108580:	8b 00                	mov    (%eax),%eax
f0108582:	8b 40 04             	mov    0x4(%eax),%eax
f0108585:	a3 c4 d2 b5 f0       	mov    %eax,0xf0b5d2c4
f010858a:	8b 45 08             	mov    0x8(%ebp),%eax
f010858d:	8b 00                	mov    (%eax),%eax
f010858f:	8b 40 04             	mov    0x4(%eax),%eax
f0108592:	85 c0                	test   %eax,%eax
f0108594:	74 13                	je     f01085a9 <allocate_frame+0xcc>
f0108596:	8b 45 08             	mov    0x8(%ebp),%eax
f0108599:	8b 00                	mov    (%eax),%eax
f010859b:	8b 40 04             	mov    0x4(%eax),%eax
f010859e:	8b 55 08             	mov    0x8(%ebp),%edx
f01085a1:	8b 12                	mov    (%edx),%edx
f01085a3:	8b 12                	mov    (%edx),%edx
f01085a5:	89 10                	mov    %edx,(%eax)
f01085a7:	eb 0c                	jmp    f01085b5 <allocate_frame+0xd8>
f01085a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01085ac:	8b 00                	mov    (%eax),%eax
f01085ae:	8b 00                	mov    (%eax),%eax
f01085b0:	a3 c0 d2 b5 f0       	mov    %eax,0xf0b5d2c0
f01085b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01085b8:	8b 00                	mov    (%eax),%eax
f01085ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01085c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01085c3:	8b 00                	mov    (%eax),%eax
f01085c5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01085cc:	a1 cc d2 b5 f0       	mov    0xf0b5d2cc,%eax
f01085d1:	48                   	dec    %eax
f01085d2:	a3 cc d2 b5 f0       	mov    %eax,0xf0b5d2cc

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01085d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01085da:	8b 00                	mov    (%eax),%eax
f01085dc:	8a 40 14             	mov    0x14(%eax),%al
f01085df:	84 c0                	test   %al,%al
f01085e1:	74 20                	je     f0108603 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01085e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01085e6:	8b 00                	mov    (%eax),%eax
f01085e8:	8b 50 10             	mov    0x10(%eax),%edx
f01085eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01085ee:	8b 00                	mov    (%eax),%eax
f01085f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01085f3:	8b 40 64             	mov    0x64(%eax),%eax
f01085f6:	83 ec 08             	sub    $0x8,%esp
f01085f9:	52                   	push   %edx
f01085fa:	50                   	push   %eax
f01085fb:	e8 b6 1a 00 00       	call   f010a0b6 <pt_clear_page_table_entry>
f0108600:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f0108603:	8b 45 08             	mov    0x8(%ebp),%eax
f0108606:	8b 00                	mov    (%eax),%eax
f0108608:	83 ec 0c             	sub    $0xc,%esp
f010860b:	50                   	push   %eax
f010860c:	e8 b1 fe ff ff       	call   f01084c2 <initialize_frame_info>
f0108611:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0108614:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108618:	75 10                	jne    f010862a <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010861a:	83 ec 0c             	sub    $0xc,%esp
f010861d:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f0108622:	e8 ce 7a 00 00       	call   f01100f5 <release_spinlock>
f0108627:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010862a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010862f:	c9                   	leave  
f0108630:	c3                   	ret    

f0108631 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108631:	55                   	push   %ebp
f0108632:	89 e5                	mov    %esp,%ebp
f0108634:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f0108637:	83 ec 0c             	sub    $0xc,%esp
f010863a:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f010863f:	e8 43 7c 00 00       	call   f0110287 <holding_spinlock>
f0108644:	83 c4 10             	add    $0x10,%esp
f0108647:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010864a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010864e:	75 10                	jne    f0108660 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108650:	83 ec 0c             	sub    $0xc,%esp
f0108653:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f0108658:	e8 11 7a 00 00       	call   f011006e <acquire_spinlock>
f010865d:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108660:	83 ec 0c             	sub    $0xc,%esp
f0108663:	ff 75 08             	pushl  0x8(%ebp)
f0108666:	e8 57 fe ff ff       	call   f01084c2 <initialize_frame_info>
f010866b:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f010866e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108672:	75 17                	jne    f010868b <free_frame+0x5a>
f0108674:	83 ec 04             	sub    $0x4,%esp
f0108677:	68 a8 5f 12 f0       	push   $0xf0125fa8
f010867c:	68 cf 00 00 00       	push   $0xcf
f0108681:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108686:	e8 ae 7c ff ff       	call   f0100339 <_panic>
f010868b:	8b 15 c0 d2 b5 f0    	mov    0xf0b5d2c0,%edx
f0108691:	8b 45 08             	mov    0x8(%ebp),%eax
f0108694:	89 10                	mov    %edx,(%eax)
f0108696:	8b 45 08             	mov    0x8(%ebp),%eax
f0108699:	8b 00                	mov    (%eax),%eax
f010869b:	85 c0                	test   %eax,%eax
f010869d:	74 0d                	je     f01086ac <free_frame+0x7b>
f010869f:	a1 c0 d2 b5 f0       	mov    0xf0b5d2c0,%eax
f01086a4:	8b 55 08             	mov    0x8(%ebp),%edx
f01086a7:	89 50 04             	mov    %edx,0x4(%eax)
f01086aa:	eb 08                	jmp    f01086b4 <free_frame+0x83>
f01086ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01086af:	a3 c4 d2 b5 f0       	mov    %eax,0xf0b5d2c4
f01086b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01086b7:	a3 c0 d2 b5 f0       	mov    %eax,0xf0b5d2c0
f01086bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01086bf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01086c6:	a1 cc d2 b5 f0       	mov    0xf0b5d2cc,%eax
f01086cb:	40                   	inc    %eax
f01086cc:	a3 cc d2 b5 f0       	mov    %eax,0xf0b5d2cc
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01086d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01086d5:	75 10                	jne    f01086e7 <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01086d7:	83 ec 0c             	sub    $0xc,%esp
f01086da:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f01086df:	e8 11 7a 00 00       	call   f01100f5 <release_spinlock>
f01086e4:	83 c4 10             	add    $0x10,%esp
	}
}
f01086e7:	90                   	nop
f01086e8:	c9                   	leave  
f01086e9:	c3                   	ret    

f01086ea <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01086ea:	55                   	push   %ebp
f01086eb:	89 e5                	mov    %esp,%ebp
f01086ed:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01086f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01086f3:	8b 40 08             	mov    0x8(%eax),%eax
f01086f6:	48                   	dec    %eax
f01086f7:	8b 55 08             	mov    0x8(%ebp),%edx
f01086fa:	66 89 42 08          	mov    %ax,0x8(%edx)
f01086fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0108701:	8b 40 08             	mov    0x8(%eax),%eax
f0108704:	66 85 c0             	test   %ax,%ax
f0108707:	75 0e                	jne    f0108717 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0108709:	83 ec 0c             	sub    $0xc,%esp
f010870c:	ff 75 08             	pushl  0x8(%ebp)
f010870f:	e8 1d ff ff ff       	call   f0108631 <free_frame>
f0108714:	83 c4 10             	add    $0x10,%esp
}
f0108717:	90                   	nop
f0108718:	c9                   	leave  
f0108719:	c3                   	ret    

f010871a <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f010871a:	55                   	push   %ebp
f010871b:	89 e5                	mov    %esp,%ebp
f010871d:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108720:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108723:	c1 e8 16             	shr    $0x16,%eax
f0108726:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010872d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0108737:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010873a:	83 e0 01             	and    $0x1,%eax
f010873d:	85 c0                	test   %eax,%eax
f010873f:	74 74                	je     f01087b5 <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108741:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108748:	77 1d                	ja     f0108767 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010874a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010874d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108752:	83 ec 0c             	sub    $0xc,%esp
f0108755:	50                   	push   %eax
f0108756:	e8 b7 14 00 00       	call   f0109c12 <kheap_virtual_address>
f010875b:	83 c4 10             	add    $0x10,%esp
f010875e:	89 c2                	mov    %eax,%edx
f0108760:	8b 45 10             	mov    0x10(%ebp),%eax
f0108763:	89 10                	mov    %edx,(%eax)
f0108765:	eb 44                	jmp    f01087ab <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108767:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010876a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010876f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108772:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108775:	c1 e8 0c             	shr    $0xc,%eax
f0108778:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010877b:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0108780:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108783:	72 17                	jb     f010879c <get_page_table+0x82>
f0108785:	ff 75 f0             	pushl  -0x10(%ebp)
f0108788:	68 88 60 12 f0       	push   $0xf0126088
f010878d:	68 fb 00 00 00       	push   $0xfb
f0108792:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108797:	e8 9d 7b ff ff       	call   f0100339 <_panic>
f010879c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010879f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01087a4:	89 c2                	mov    %eax,%edx
f01087a6:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a9:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f01087ab:	b8 00 00 00 00       	mov    $0x0,%eax
f01087b0:	e9 b9 00 00 00       	jmp    f010886e <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01087b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01087b9:	0f 84 a1 00 00 00    	je     f0108860 <get_page_table+0x146>
f01087bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087c2:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f01087c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01087c8:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01087cb:	83 ec 0c             	sub    $0xc,%esp
f01087ce:	6a 00                	push   $0x0
f01087d0:	e8 43 73 00 00       	call   f010fb18 <fault_handler>
f01087d5:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01087d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087db:	c1 e8 16             	shr    $0x16,%eax
f01087de:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01087e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01087e8:	01 d0                	add    %edx,%eax
f01087ea:	8b 00                	mov    (%eax),%eax
f01087ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01087ef:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01087f6:	77 1d                	ja     f0108815 <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01087f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087fb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108800:	83 ec 0c             	sub    $0xc,%esp
f0108803:	50                   	push   %eax
f0108804:	e8 09 14 00 00       	call   f0109c12 <kheap_virtual_address>
f0108809:	83 c4 10             	add    $0x10,%esp
f010880c:	89 c2                	mov    %eax,%edx
f010880e:	8b 45 10             	mov    0x10(%ebp),%eax
f0108811:	89 10                	mov    %edx,(%eax)
f0108813:	eb 44                	jmp    f0108859 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108815:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108818:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010881d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108820:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108823:	c1 e8 0c             	shr    $0xc,%eax
f0108826:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108829:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f010882e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108831:	72 17                	jb     f010884a <get_page_table+0x130>
f0108833:	ff 75 e8             	pushl  -0x18(%ebp)
f0108836:	68 88 60 12 f0       	push   $0xf0126088
f010883b:	68 13 01 00 00       	push   $0x113
f0108840:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108845:	e8 ef 7a ff ff       	call   f0100339 <_panic>
f010884a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010884d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108852:	89 c2                	mov    %eax,%edx
f0108854:	8b 45 10             	mov    0x10(%ebp),%eax
f0108857:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0108859:	b8 00 00 00 00       	mov    $0x0,%eax
f010885e:	eb 0e                	jmp    f010886e <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108860:	8b 45 10             	mov    0x10(%ebp),%eax
f0108863:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f0108869:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f010886e:	c9                   	leave  
f010886f:	c3                   	ret    

f0108870 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108870:	55                   	push   %ebp
f0108871:	89 e5                	mov    %esp,%ebp
f0108873:	53                   	push   %ebx
f0108874:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f0108877:	83 ec 0c             	sub    $0xc,%esp
f010887a:	68 00 10 00 00       	push   $0x1000
f010887f:	e8 4b 0f 00 00       	call   f01097cf <kmalloc>
f0108884:	83 c4 10             	add    $0x10,%esp
f0108887:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010888a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010888e:	75 17                	jne    f01088a7 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108890:	83 ec 04             	sub    $0x4,%esp
f0108893:	68 b7 60 12 f0       	push   $0xf01260b7
f0108898:	68 33 01 00 00       	push   $0x133
f010889d:	68 cb 5f 12 f0       	push   $0xf0125fcb
f01088a2:	e8 92 7a ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01088a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088aa:	c1 e8 16             	shr    $0x16,%eax
f01088ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088b7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01088ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088bd:	83 ec 0c             	sub    $0xc,%esp
f01088c0:	50                   	push   %eax
f01088c1:	e8 ef 12 00 00       	call   f0109bb5 <kheap_physical_address>
f01088c6:	83 c4 10             	add    $0x10,%esp
f01088c9:	83 c8 07             	or     $0x7,%eax
f01088cc:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01088ce:	83 ec 04             	sub    $0x4,%esp
f01088d1:	68 00 10 00 00       	push   $0x1000
f01088d6:	6a 00                	push   $0x0
f01088d8:	ff 75 f4             	pushl  -0xc(%ebp)
f01088db:	e8 2a 79 01 00       	call   f012020a <memset>
f01088e0:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01088e3:	0f 20 d8             	mov    %cr3,%eax
f01088e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01088e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01088ec:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01088ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01088f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01088f5:	c9                   	leave  
f01088f6:	c3                   	ret    

f01088f7 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01088f7:	55                   	push   %ebp
f01088f8:	89 e5                	mov    %esp,%ebp
f01088fa:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01088fd:	83 ec 0c             	sub    $0xc,%esp
f0108900:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0108903:	50                   	push   %eax
f0108904:	e8 d4 fb ff ff       	call   f01084dd <allocate_frame>
f0108909:	83 c4 10             	add    $0x10,%esp
f010890c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f010890f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108912:	83 ec 0c             	sub    $0xc,%esp
f0108915:	50                   	push   %eax
f0108916:	e8 70 f7 ff ff       	call   f010808b <to_physical_address>
f010891b:	83 c4 10             	add    $0x10,%esp
f010891e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0108921:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108924:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108927:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010892a:	c1 e8 0c             	shr    $0xc,%eax
f010892d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108930:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0108935:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108938:	72 17                	jb     f0108951 <__static_cpt+0x5a>
f010893a:	ff 75 ec             	pushl  -0x14(%ebp)
f010893d:	68 88 60 12 f0       	push   $0xf0126088
f0108942:	68 4e 01 00 00       	push   $0x14e
f0108947:	68 cb 5f 12 f0       	push   $0xf0125fcb
f010894c:	e8 e8 79 ff ff       	call   f0100339 <_panic>
f0108951:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108954:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108959:	89 c2                	mov    %eax,%edx
f010895b:	8b 45 10             	mov    0x10(%ebp),%eax
f010895e:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108960:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108963:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0108969:	8b 45 0c             	mov    0xc(%ebp),%eax
f010896c:	c1 e8 16             	shr    $0x16,%eax
f010896f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108976:	8b 45 08             	mov    0x8(%ebp),%eax
f0108979:	01 d0                	add    %edx,%eax
f010897b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010897e:	83 ca 07             	or     $0x7,%edx
f0108981:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108983:	8b 45 10             	mov    0x10(%ebp),%eax
f0108986:	8b 00                	mov    (%eax),%eax
f0108988:	83 ec 04             	sub    $0x4,%esp
f010898b:	68 00 10 00 00       	push   $0x1000
f0108990:	6a 00                	push   $0x0
f0108992:	50                   	push   %eax
f0108993:	e8 72 78 01 00       	call   f012020a <memset>
f0108998:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010899b:	0f 20 d8             	mov    %cr3,%eax
f010899e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01089a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089a4:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01089a7:	90                   	nop
f01089a8:	c9                   	leave  
f01089a9:	c3                   	ret    

f01089aa <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01089aa:	55                   	push   %ebp
f01089ab:	89 e5                	mov    %esp,%ebp
f01089ad:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01089b0:	ff 75 0c             	pushl  0xc(%ebp)
f01089b3:	e8 d3 f6 ff ff       	call   f010808b <to_physical_address>
f01089b8:	83 c4 04             	add    $0x4,%esp
f01089bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01089be:	83 ec 04             	sub    $0x4,%esp
f01089c1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f01089c4:	50                   	push   %eax
f01089c5:	ff 75 10             	pushl  0x10(%ebp)
f01089c8:	ff 75 08             	pushl  0x8(%ebp)
f01089cb:	e8 4a fd ff ff       	call   f010871a <get_page_table>
f01089d0:	83 c4 10             	add    $0x10,%esp
f01089d3:	83 f8 01             	cmp    $0x1,%eax
f01089d6:	75 1b                	jne    f01089f3 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01089d8:	83 ec 08             	sub    $0x8,%esp
f01089db:	ff 75 10             	pushl  0x10(%ebp)
f01089de:	ff 75 08             	pushl  0x8(%ebp)
f01089e1:	e8 8a fe ff ff       	call   f0108870 <create_page_table>
f01089e6:	83 c4 10             	add    $0x10,%esp
f01089e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01089ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01089f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089f6:	8b 55 10             	mov    0x10(%ebp),%edx
f01089f9:	c1 ea 0c             	shr    $0xc,%edx
f01089fc:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a02:	c1 e2 02             	shl    $0x2,%edx
f0108a05:	01 d0                	add    %edx,%eax
f0108a07:	8b 00                	mov    (%eax),%eax
f0108a09:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108a0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108a0f:	83 e0 01             	and    $0x1,%eax
f0108a12:	85 c0                	test   %eax,%eax
f0108a14:	74 25                	je     f0108a3b <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0108a16:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108a19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108a1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108a21:	75 07                	jne    f0108a2a <map_frame+0x80>
			return 0;
f0108a23:	b8 00 00 00 00       	mov    $0x0,%eax
f0108a28:	eb 68                	jmp    f0108a92 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108a2a:	83 ec 08             	sub    $0x8,%esp
f0108a2d:	ff 75 10             	pushl  0x10(%ebp)
f0108a30:	ff 75 08             	pushl  0x8(%ebp)
f0108a33:	e8 d2 00 00 00       	call   f0108b0a <unmap_frame>
f0108a38:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a3e:	8b 40 08             	mov    0x8(%eax),%eax
f0108a41:	40                   	inc    %eax
f0108a42:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108a45:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108a49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a4c:	8b 55 10             	mov    0x10(%ebp),%edx
f0108a4f:	c1 ea 0c             	shr    $0xc,%edx
f0108a52:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a58:	c1 e2 02             	shl    $0x2,%edx
f0108a5b:	01 d0                	add    %edx,%eax
f0108a5d:	8b 00                	mov    (%eax),%eax
f0108a5f:	25 00 0e 00 00       	and    $0xe00,%eax
f0108a64:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f0108a67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a6a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108a6d:	c1 ea 0c             	shr    $0xc,%edx
f0108a70:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108a76:	c1 e2 02             	shl    $0x2,%edx
f0108a79:	01 c2                	add    %eax,%edx
f0108a7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a7e:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108a81:	89 c1                	mov    %eax,%ecx
f0108a83:	8b 45 14             	mov    0x14(%ebp),%eax
f0108a86:	09 c8                	or     %ecx,%eax
f0108a88:	83 c8 01             	or     $0x1,%eax
f0108a8b:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108a8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108a92:	c9                   	leave  
f0108a93:	c3                   	ret    

f0108a94 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108a94:	55                   	push   %ebp
f0108a95:	89 e5                	mov    %esp,%ebp
f0108a97:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0108a9a:	83 ec 04             	sub    $0x4,%esp
f0108a9d:	ff 75 10             	pushl  0x10(%ebp)
f0108aa0:	ff 75 0c             	pushl  0xc(%ebp)
f0108aa3:	ff 75 08             	pushl  0x8(%ebp)
f0108aa6:	e8 6f fc ff ff       	call   f010871a <get_page_table>
f0108aab:	83 c4 10             	add    $0x10,%esp
f0108aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108ab1:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ab4:	8b 00                	mov    (%eax),%eax
f0108ab6:	85 c0                	test   %eax,%eax
f0108ab8:	74 49                	je     f0108b03 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f0108aba:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108abd:	c1 e8 0c             	shr    $0xc,%eax
f0108ac0:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108ac5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0108ac8:	8b 45 10             	mov    0x10(%ebp),%eax
f0108acb:	8b 00                	mov    (%eax),%eax
f0108acd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108ad0:	c1 e2 02             	shl    $0x2,%edx
f0108ad3:	01 d0                	add    %edx,%eax
f0108ad5:	8b 00                	mov    (%eax),%eax
f0108ad7:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108ada:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108add:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ae2:	85 c0                	test   %eax,%eax
f0108ae4:	74 16                	je     f0108afc <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f0108ae6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ae9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108aee:	83 ec 0c             	sub    $0xc,%esp
f0108af1:	50                   	push   %eax
f0108af2:	e8 a7 f5 ff ff       	call   f010809e <to_frame_info>
f0108af7:	83 c4 10             	add    $0x10,%esp
f0108afa:	eb 0c                	jmp    f0108b08 <get_frame_info+0x74>
		}
		return 0;
f0108afc:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b01:	eb 05                	jmp    f0108b08 <get_frame_info+0x74>
	}
	return 0;
f0108b03:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108b08:	c9                   	leave  
f0108b09:	c3                   	ret    

f0108b0a <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108b0a:	55                   	push   %ebp
f0108b0b:	89 e5                	mov    %esp,%ebp
f0108b0d:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0108b10:	83 ec 04             	sub    $0x4,%esp
f0108b13:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0108b16:	50                   	push   %eax
f0108b17:	ff 75 0c             	pushl  0xc(%ebp)
f0108b1a:	ff 75 08             	pushl  0x8(%ebp)
f0108b1d:	e8 72 ff ff ff       	call   f0108a94 <get_frame_info>
f0108b22:	83 c4 10             	add    $0x10,%esp
f0108b25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0108b28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108b2c:	74 7d                	je     f0108bab <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b31:	8a 40 14             	mov    0x14(%eax),%al
f0108b34:	84 c0                	test   %al,%al
f0108b36:	74 1c                	je     f0108b54 <unmap_frame+0x4a>
f0108b38:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108b3f:	77 13                	ja     f0108b54 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108b41:	83 ec 08             	sub    $0x8,%esp
f0108b44:	ff 75 0c             	pushl  0xc(%ebp)
f0108b47:	68 d4 60 12 f0       	push   $0xf01260d4
f0108b4c:	e8 3a 84 ff ff       	call   f0100f8b <cprintf>
f0108b51:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108b54:	83 ec 0c             	sub    $0xc,%esp
f0108b57:	ff 75 f4             	pushl  -0xc(%ebp)
f0108b5a:	e8 8b fb ff ff       	call   f01086ea <decrement_references>
f0108b5f:	83 c4 10             	add    $0x10,%esp
		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108b62:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b65:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b68:	c1 ea 0c             	shr    $0xc,%edx
f0108b6b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b71:	c1 e2 02             	shl    $0x2,%edx
f0108b74:	01 d0                	add    %edx,%eax
f0108b76:	8b 00                	mov    (%eax),%eax
f0108b78:	25 00 0e 00 00       	and    $0xe00,%eax
f0108b7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108b80:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b83:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b86:	c1 ea 0c             	shr    $0xc,%edx
f0108b89:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108b8f:	c1 e2 02             	shl    $0x2,%edx
f0108b92:	01 c2                	add    %eax,%edx
f0108b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b97:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f0108b99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108b9c:	83 ec 08             	sub    $0x8,%esp
f0108b9f:	50                   	push   %eax
f0108ba0:	ff 75 08             	pushl  0x8(%ebp)
f0108ba3:	e8 3c f5 ff ff       	call   f01080e4 <tlb_invalidate>
f0108ba8:	83 c4 10             	add    $0x10,%esp
	}
}
f0108bab:	90                   	nop
f0108bac:	c9                   	leave  
f0108bad:	c3                   	ret    

f0108bae <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108bae:	55                   	push   %ebp
f0108baf:	89 e5                	mov    %esp,%ebp
f0108bb1:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108bb4:	ff 75 0c             	pushl  0xc(%ebp)
f0108bb7:	e8 cf f4 ff ff       	call   f010808b <to_physical_address>
f0108bbc:	83 c4 04             	add    $0x4,%esp
f0108bbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108bc2:	8b 45 10             	mov    0x10(%ebp),%eax
f0108bc5:	c1 e8 16             	shr    $0x16,%eax
f0108bc8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108bcf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bd2:	01 d0                	add    %edx,%eax
f0108bd4:	8b 00                	mov    (%eax),%eax
f0108bd6:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108bd9:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108be0:	77 19                	ja     f0108bfb <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108be2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108be5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108bea:	83 ec 0c             	sub    $0xc,%esp
f0108bed:	50                   	push   %eax
f0108bee:	e8 1f 10 00 00       	call   f0109c12 <kheap_virtual_address>
f0108bf3:	83 c4 10             	add    $0x10,%esp
f0108bf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108bf9:	eb 40                	jmp    f0108c3b <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108bfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108bfe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108c03:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108c06:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c09:	c1 e8 0c             	shr    $0xc,%eax
f0108c0c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108c0f:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0108c14:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108c17:	72 17                	jb     f0108c30 <loadtime_map_frame+0x82>
f0108c19:	ff 75 e8             	pushl  -0x18(%ebp)
f0108c1c:	68 88 60 12 f0       	push   $0xf0126088
f0108c21:	68 f9 01 00 00       	push   $0x1f9
f0108c26:	68 cb 5f 12 f0       	push   $0xf0125fcb
f0108c2b:	e8 09 77 ff ff       	call   f0100339 <_panic>
f0108c30:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c33:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108c38:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108c3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108c3f:	75 14                	jne    f0108c55 <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108c41:	83 ec 08             	sub    $0x8,%esp
f0108c44:	ff 75 10             	pushl  0x10(%ebp)
f0108c47:	ff 75 08             	pushl  0x8(%ebp)
f0108c4a:	e8 21 fc ff ff       	call   f0108870 <create_page_table>
f0108c4f:	83 c4 10             	add    $0x10,%esp
f0108c52:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f0108c55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c58:	8b 40 08             	mov    0x8(%eax),%eax
f0108c5b:	40                   	inc    %eax
f0108c5c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c5f:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108c63:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c66:	c1 e8 0c             	shr    $0xc,%eax
f0108c69:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108c6e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c78:	01 c2                	add    %eax,%edx
f0108c7a:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c7d:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108c80:	83 c8 01             	or     $0x1,%eax
f0108c83:	89 02                	mov    %eax,(%edx)

	return 0;
f0108c85:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c8a:	c9                   	leave  
f0108c8b:	c3                   	ret    

f0108c8c <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108c8c:	55                   	push   %ebp
f0108c8d:	89 e5                	mov    %esp,%ebp
f0108c8f:	57                   	push   %edi
f0108c90:	56                   	push   %esi
f0108c91:	53                   	push   %ebx
f0108c92:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f0108c95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108c9c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108ca3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0108caa:	83 ec 0c             	sub    $0xc,%esp
f0108cad:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f0108cb2:	e8 d0 75 00 00       	call   f0110287 <holding_spinlock>
f0108cb7:	83 c4 10             	add    $0x10,%esp
f0108cba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108cbd:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108cc1:	75 10                	jne    f0108cd3 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108cc3:	83 ec 0c             	sub    $0xc,%esp
f0108cc6:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f0108ccb:	e8 9e 73 00 00       	call   f011006e <acquire_spinlock>
f0108cd0:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108cd3:	a1 c0 d2 b5 f0       	mov    0xf0b5d2c0,%eax
f0108cd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108cdb:	eb 1a                	jmp    f0108cf7 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0108cdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108ce0:	8a 40 14             	mov    0x14(%eax),%al
f0108ce3:	84 c0                	test   %al,%al
f0108ce5:	74 05                	je     f0108cec <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0108ce7:	ff 45 dc             	incl   -0x24(%ebp)
f0108cea:	eb 03                	jmp    f0108cef <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0108cec:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108cef:	a1 c8 d2 b5 f0       	mov    0xf0b5d2c8,%eax
f0108cf4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108cf7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108cfb:	74 07                	je     f0108d04 <calculate_available_frames+0x78>
f0108cfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108d00:	8b 00                	mov    (%eax),%eax
f0108d02:	eb 05                	jmp    f0108d09 <calculate_available_frames+0x7d>
f0108d04:	b8 00 00 00 00       	mov    $0x0,%eax
f0108d09:	a3 c8 d2 b5 f0       	mov    %eax,0xf0b5d2c8
f0108d0e:	a1 c8 d2 b5 f0       	mov    0xf0b5d2c8,%eax
f0108d13:	85 c0                	test   %eax,%eax
f0108d15:	75 c6                	jne    f0108cdd <calculate_available_frames+0x51>
f0108d17:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108d1b:	75 c0                	jne    f0108cdd <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108d1d:	a1 dc d2 b5 f0       	mov    0xf0b5d2dc,%eax
f0108d22:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0108d25:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108d29:	75 10                	jne    f0108d3b <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108d2b:	83 ec 0c             	sub    $0xc,%esp
f0108d2e:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f0108d33:	e8 bd 73 00 00       	call   f01100f5 <release_spinlock>
f0108d38:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108d3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108d3e:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108d41:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d44:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108d47:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108d4a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108d4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d50:	89 c3                	mov    %eax,%ebx
f0108d52:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108d55:	ba 03 00 00 00       	mov    $0x3,%edx
f0108d5a:	89 df                	mov    %ebx,%edi
f0108d5c:	89 c6                	mov    %eax,%esi
f0108d5e:	89 d1                	mov    %edx,%ecx
f0108d60:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108d62:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d65:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108d68:	5b                   	pop    %ebx
f0108d69:	5e                   	pop    %esi
f0108d6a:	5f                   	pop    %edi
f0108d6b:	5d                   	pop    %ebp
f0108d6c:	c2 04 00             	ret    $0x4

f0108d6f <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108d6f:	55                   	push   %ebp
f0108d70:	89 e5                	mov    %esp,%ebp
f0108d72:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108d75:	c7 05 80 d1 75 f0 00 	movl   $0x0,0xf075d180
f0108d7c:	00 00 00 
f0108d7f:	c7 05 84 d1 75 f0 00 	movl   $0x0,0xf075d184
f0108d86:	00 00 00 
f0108d89:	c7 05 8c d1 75 f0 00 	movl   $0x0,0xf075d18c
f0108d90:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108d93:	83 ec 08             	sub    $0x8,%esp
f0108d96:	68 04 61 12 f0       	push   $0xf0126104
f0108d9b:	68 90 d1 75 f0       	push   $0xf075d190
f0108da0:	e8 98 72 00 00       	call   f011003d <init_spinlock>
f0108da5:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108da8:	90                   	nop
f0108da9:	c9                   	leave  
f0108daa:	c3                   	ret    

f0108dab <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108dab:	55                   	push   %ebp
f0108dac:	89 e5                	mov    %esp,%ebp
f0108dae:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108db1:	83 ec 08             	sub    $0x8,%esp
f0108db4:	ff 75 0c             	pushl  0xc(%ebp)
f0108db7:	ff 75 08             	pushl  0x8(%ebp)
f0108dba:	e8 4b 01 00 00       	call   f0108f0a <get_share>
f0108dbf:	83 c4 10             	add    $0x10,%esp
f0108dc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108dc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108dc9:	75 07                	jne    f0108dd2 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108dcb:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108dd0:	eb 06                	jmp    f0108dd8 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108dd5:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108dd8:	c9                   	leave  
f0108dd9:	c3                   	ret    

f0108dda <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108dda:	55                   	push   %ebp
f0108ddb:	89 e5                	mov    %esp,%ebp
f0108ddd:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108de0:	8b 15 cc d2 b5 f0    	mov    0xf0b5d2cc,%edx
f0108de6:	8b 45 08             	mov    0x8(%ebp),%eax
f0108de9:	39 c2                	cmp    %eax,%edx
f0108deb:	73 07                	jae    f0108df4 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ded:	b8 00 00 00 00       	mov    $0x0,%eax
f0108df2:	eb 3c                	jmp    f0108e30 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108df4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108df7:	c1 e0 02             	shl    $0x2,%eax
f0108dfa:	83 ec 0c             	sub    $0xc,%esp
f0108dfd:	50                   	push   %eax
f0108dfe:	e8 cc 09 00 00       	call   f01097cf <kmalloc>
f0108e03:	83 c4 10             	add    $0x10,%esp
f0108e06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108e09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108e0d:	75 07                	jne    f0108e16 <create_frames_storage+0x3c>
f0108e0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e14:	eb 1a                	jmp    f0108e30 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108e16:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e19:	c1 e0 02             	shl    $0x2,%eax
f0108e1c:	83 ec 04             	sub    $0x4,%esp
f0108e1f:	50                   	push   %eax
f0108e20:	6a 00                	push   $0x0
f0108e22:	ff 75 f4             	pushl  -0xc(%ebp)
f0108e25:	e8 e0 73 01 00       	call   f012020a <memset>
f0108e2a:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108e2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108e30:	c9                   	leave  
f0108e31:	c3                   	ret    

f0108e32 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108e32:	55                   	push   %ebp
f0108e33:	89 e5                	mov    %esp,%ebp
f0108e35:	83 ec 28             	sub    $0x28,%esp
f0108e38:	8b 45 14             	mov    0x14(%ebp),%eax
f0108e3b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108e3e:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108e45:	8b 55 10             	mov    0x10(%ebp),%edx
f0108e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e4b:	01 d0                	add    %edx,%eax
f0108e4d:	48                   	dec    %eax
f0108e4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108e51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e54:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e59:	f7 75 f4             	divl   -0xc(%ebp)
f0108e5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e5f:	29 d0                	sub    %edx,%eax
f0108e61:	c1 e8 0c             	shr    $0xc,%eax
f0108e64:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108e67:	83 ec 0c             	sub    $0xc,%esp
f0108e6a:	6a 60                	push   $0x60
f0108e6c:	e8 5e 09 00 00       	call   f01097cf <kmalloc>
f0108e71:	83 c4 10             	add    $0x10,%esp
f0108e74:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108e77:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108e7b:	75 0a                	jne    f0108e87 <create_share+0x55>
f0108e7d:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e82:	e9 81 00 00 00       	jmp    f0108f08 <create_share+0xd6>
	created_share->references=1;
f0108e87:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e8a:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108e91:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e94:	01 c0                	add    %eax,%eax
f0108e96:	d1 f8                	sar    %eax
f0108e98:	89 c2                	mov    %eax,%edx
f0108e9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e9d:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108e9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ea2:	83 ec 0c             	sub    $0xc,%esp
f0108ea5:	50                   	push   %eax
f0108ea6:	e8 2f ff ff ff       	call   f0108dda <create_frames_storage>
f0108eab:	83 c4 10             	add    $0x10,%esp
f0108eae:	89 c2                	mov    %eax,%edx
f0108eb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eb3:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eb9:	8b 40 54             	mov    0x54(%eax),%eax
f0108ebc:	85 c0                	test   %eax,%eax
f0108ebe:	75 15                	jne    f0108ed5 <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108ec0:	83 ec 0c             	sub    $0xc,%esp
f0108ec3:	ff 75 e8             	pushl  -0x18(%ebp)
f0108ec6:	e8 c4 0b 00 00       	call   f0109a8f <kfree>
f0108ecb:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ece:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ed3:	eb 33                	jmp    f0108f08 <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108ed5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ed8:	8b 55 08             	mov    0x8(%ebp),%edx
f0108edb:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ee1:	83 c0 08             	add    $0x8,%eax
f0108ee4:	83 ec 08             	sub    $0x8,%esp
f0108ee7:	ff 75 0c             	pushl  0xc(%ebp)
f0108eea:	50                   	push   %eax
f0108eeb:	e8 7b 71 01 00       	call   f012006b <strcpy>
f0108ef0:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108ef3:	8b 55 10             	mov    0x10(%ebp),%edx
f0108ef6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ef9:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108efc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108eff:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108f02:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108f05:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108f08:	c9                   	leave  
f0108f09:	c3                   	ret    

f0108f0a <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108f0a:	55                   	push   %ebp
f0108f0b:	89 e5                	mov    %esp,%ebp
f0108f0d:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108f10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108f17:	83 ec 0c             	sub    $0xc,%esp
f0108f1a:	68 90 d1 75 f0       	push   $0xf075d190
f0108f1f:	e8 4a 71 00 00       	call   f011006e <acquire_spinlock>
f0108f24:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108f27:	a1 80 d1 75 f0       	mov    0xf075d180,%eax
f0108f2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f2f:	eb 41                	jmp    f0108f72 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f34:	8b 40 04             	mov    0x4(%eax),%eax
f0108f37:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108f3a:	75 2e                	jne    f0108f6a <get_share+0x60>
f0108f3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f3f:	83 c0 08             	add    $0x8,%eax
f0108f42:	83 ec 08             	sub    $0x8,%esp
f0108f45:	ff 75 0c             	pushl  0xc(%ebp)
f0108f48:	50                   	push   %eax
f0108f49:	e8 da 71 01 00       	call   f0120128 <strcmp>
f0108f4e:	83 c4 10             	add    $0x10,%esp
f0108f51:	85 c0                	test   %eax,%eax
f0108f53:	75 15                	jne    f0108f6a <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108f55:	83 ec 0c             	sub    $0xc,%esp
f0108f58:	68 90 d1 75 f0       	push   $0xf075d190
f0108f5d:	e8 93 71 00 00       	call   f01100f5 <release_spinlock>
f0108f62:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108f65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f68:	eb 44                	jmp    f0108fae <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108f6a:	a1 88 d1 75 f0       	mov    0xf075d188,%eax
f0108f6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108f76:	74 08                	je     f0108f80 <get_share+0x76>
f0108f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f7b:	8b 40 58             	mov    0x58(%eax),%eax
f0108f7e:	eb 05                	jmp    f0108f85 <get_share+0x7b>
f0108f80:	b8 00 00 00 00       	mov    $0x0,%eax
f0108f85:	a3 88 d1 75 f0       	mov    %eax,0xf075d188
f0108f8a:	a1 88 d1 75 f0       	mov    0xf075d188,%eax
f0108f8f:	85 c0                	test   %eax,%eax
f0108f91:	75 9e                	jne    f0108f31 <get_share+0x27>
f0108f93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108f97:	75 98                	jne    f0108f31 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108f99:	83 ec 0c             	sub    $0xc,%esp
f0108f9c:	68 90 d1 75 f0       	push   $0xf075d190
f0108fa1:	e8 4f 71 00 00       	call   f01100f5 <release_spinlock>
f0108fa6:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108fa9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108fae:	c9                   	leave  
f0108faf:	c3                   	ret    

f0108fb0 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108fb0:	55                   	push   %ebp
f0108fb1:	89 e5                	mov    %esp,%ebp
f0108fb3:	83 ec 48             	sub    $0x48,%esp
f0108fb6:	8b 45 14             	mov    0x14(%ebp),%eax
f0108fb9:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108fbc:	e8 64 2d 00 00       	call   f010bd25 <get_cpu_proc>
f0108fc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108fc4:	83 ec 08             	sub    $0x8,%esp
f0108fc7:	ff 75 0c             	pushl  0xc(%ebp)
f0108fca:	ff 75 08             	pushl  0x8(%ebp)
f0108fcd:	e8 38 ff ff ff       	call   f0108f0a <get_share>
f0108fd2:	83 c4 10             	add    $0x10,%esp
f0108fd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108fd8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108fdc:	74 0a                	je     f0108fe8 <createSharedObject+0x38>
f0108fde:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108fe3:	e9 59 01 00 00       	jmp    f0109141 <createSharedObject+0x191>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108fe8:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108fec:	50                   	push   %eax
f0108fed:	ff 75 10             	pushl  0x10(%ebp)
f0108ff0:	ff 75 0c             	pushl  0xc(%ebp)
f0108ff3:	ff 75 08             	pushl  0x8(%ebp)
f0108ff6:	e8 37 fe ff ff       	call   f0108e32 <create_share>
f0108ffb:	83 c4 10             	add    $0x10,%esp
f0108ffe:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0109001:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109005:	75 0a                	jne    f0109011 <createSharedObject+0x61>
f0109007:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010900c:	e9 30 01 00 00       	jmp    f0109141 <createSharedObject+0x191>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0109011:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0109018:	8b 55 10             	mov    0x10(%ebp),%edx
f010901b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010901e:	01 d0                	add    %edx,%eax
f0109020:	48                   	dec    %eax
f0109021:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0109024:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109027:	ba 00 00 00 00       	mov    $0x0,%edx
f010902c:	f7 75 e4             	divl   -0x1c(%ebp)
f010902f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109032:	29 d0                	sub    %edx,%eax
f0109034:	c1 e8 0c             	shr    $0xc,%eax
f0109037:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (int k = 0; k < num_pages; k++)
f010903a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109041:	eb 6c                	jmp    f01090af <createSharedObject+0xff>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0109043:	83 ec 0c             	sub    $0xc,%esp
f0109046:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0109049:	50                   	push   %eax
f010904a:	e8 8e f4 ff ff       	call   f01084dd <allocate_frame>
f010904f:	83 c4 10             	add    $0x10,%esp
f0109052:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0109055:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0109059:	75 3d                	jne    f0109098 <createSharedObject+0xe8>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f010905b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010905e:	c1 e0 0c             	shl    $0xc,%eax
f0109061:	89 c2                	mov    %eax,%edx
f0109063:	8b 45 18             	mov    0x18(%ebp),%eax
f0109066:	01 d0                	add    %edx,%eax
f0109068:	89 c1                	mov    %eax,%ecx
f010906a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010906d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109070:	8b 40 64             	mov    0x64(%eax),%eax
f0109073:	6a 06                	push   $0x6
f0109075:	51                   	push   %ecx
f0109076:	52                   	push   %edx
f0109077:	50                   	push   %eax
f0109078:	e8 2d f9 ff ff       	call   f01089aa <map_frame>
f010907d:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0109080:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109083:	8b 40 54             	mov    0x54(%eax),%eax
f0109086:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109089:	c1 e2 02             	shl    $0x2,%edx
f010908c:	01 c2                	add    %eax,%edx
f010908e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109091:	89 02                	mov    %eax,(%edx)
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f0109093:	ff 45 f4             	incl   -0xc(%ebp)
f0109096:	eb 17                	jmp    f01090af <createSharedObject+0xff>
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
			created_share->framesStorage[k] = ptr_frame_info;
		}
		else
		{
			panic("No Memory");
f0109098:	83 ec 04             	sub    $0x4,%esp
f010909b:	68 10 61 12 f0       	push   $0xf0126110
f01090a0:	68 a5 00 00 00       	push   $0xa5
f01090a5:	68 1c 61 12 f0       	push   $0xf012611c
f01090aa:	e8 8a 72 ff ff       	call   f0100339 <_panic>
	struct Share* existed = get_share(ownerID,shareName);
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
	for (int k = 0; k < num_pages; k++)
f01090af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090b2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01090b5:	72 8c                	jb     f0109043 <createSharedObject+0x93>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f01090b7:	83 ec 0c             	sub    $0xc,%esp
f01090ba:	68 90 d1 75 f0       	push   $0xf075d190
f01090bf:	e8 aa 6f 00 00       	call   f011006e <acquire_spinlock>
f01090c4:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f01090c7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01090cb:	75 17                	jne    f01090e4 <createSharedObject+0x134>
f01090cd:	83 ec 04             	sub    $0x4,%esp
f01090d0:	68 40 61 12 f0       	push   $0xf0126140
f01090d5:	68 aa 00 00 00       	push   $0xaa
f01090da:	68 1c 61 12 f0       	push   $0xf012611c
f01090df:	e8 55 72 ff ff       	call   f0100339 <_panic>
f01090e4:	8b 15 84 d1 75 f0    	mov    0xf075d184,%edx
f01090ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01090ed:	89 50 5c             	mov    %edx,0x5c(%eax)
f01090f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01090f3:	8b 40 5c             	mov    0x5c(%eax),%eax
f01090f6:	85 c0                	test   %eax,%eax
f01090f8:	74 0d                	je     f0109107 <createSharedObject+0x157>
f01090fa:	a1 84 d1 75 f0       	mov    0xf075d184,%eax
f01090ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0109102:	89 50 58             	mov    %edx,0x58(%eax)
f0109105:	eb 08                	jmp    f010910f <createSharedObject+0x15f>
f0109107:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010910a:	a3 80 d1 75 f0       	mov    %eax,0xf075d180
f010910f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109112:	a3 84 d1 75 f0       	mov    %eax,0xf075d184
f0109117:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010911a:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0109121:	a1 8c d1 75 f0       	mov    0xf075d18c,%eax
f0109126:	40                   	inc    %eax
f0109127:	a3 8c d1 75 f0       	mov    %eax,0xf075d18c
	release_spinlock(&AllShares.shareslock);
f010912c:	83 ec 0c             	sub    $0xc,%esp
f010912f:	68 90 d1 75 f0       	push   $0xf075d190
f0109134:	e8 bc 6f 00 00       	call   f01100f5 <release_spinlock>
f0109139:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f010913c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010913f:	8b 00                	mov    (%eax),%eax
}
f0109141:	c9                   	leave  
f0109142:	c3                   	ret    

f0109143 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0109143:	55                   	push   %ebp
f0109144:	89 e5                	mov    %esp,%ebp
f0109146:	53                   	push   %ebx
f0109147:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f010914a:	e8 d6 2b 00 00       	call   f010bd25 <get_cpu_proc>
f010914f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0109152:	83 ec 08             	sub    $0x8,%esp
f0109155:	ff 75 0c             	pushl  0xc(%ebp)
f0109158:	ff 75 08             	pushl  0x8(%ebp)
f010915b:	e8 aa fd ff ff       	call   f0108f0a <get_share>
f0109160:	83 c4 10             	add    $0x10,%esp
f0109163:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0109166:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010916a:	75 0a                	jne    f0109176 <getSharedObject+0x33>
f010916c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0109171:	e9 a0 00 00 00       	jmp    f0109216 <getSharedObject+0xd3>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0109176:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010917d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109180:	8b 40 48             	mov    0x48(%eax),%eax
f0109183:	89 c2                	mov    %eax,%edx
f0109185:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109188:	01 d0                	add    %edx,%eax
f010918a:	48                   	dec    %eax
f010918b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010918e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109191:	ba 00 00 00 00       	mov    $0x0,%edx
f0109196:	f7 75 e8             	divl   -0x18(%ebp)
f0109199:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010919c:	29 d0                	sub    %edx,%eax
f010919e:	85 c0                	test   %eax,%eax
f01091a0:	79 05                	jns    f01091a7 <getSharedObject+0x64>
f01091a2:	05 ff 0f 00 00       	add    $0xfff,%eax
f01091a7:	c1 f8 0c             	sar    $0xc,%eax
f01091aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f01091ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01091b4:	eb 44                	jmp    f01091fa <getSharedObject+0xb7>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f01091b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091b9:	8a 40 50             	mov    0x50(%eax),%al
f01091bc:	0f b6 c0             	movzbl %al,%eax
f01091bf:	01 c0                	add    %eax,%eax
f01091c1:	83 c8 04             	or     $0x4,%eax
f01091c4:	89 c3                	mov    %eax,%ebx
f01091c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091c9:	c1 e0 0c             	shl    $0xc,%eax
f01091cc:	89 c2                	mov    %eax,%edx
f01091ce:	8b 45 10             	mov    0x10(%ebp),%eax
f01091d1:	01 d0                	add    %edx,%eax
f01091d3:	89 c1                	mov    %eax,%ecx
f01091d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091d8:	8b 40 54             	mov    0x54(%eax),%eax
f01091db:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01091de:	c1 e2 02             	shl    $0x2,%edx
f01091e1:	01 d0                	add    %edx,%eax
f01091e3:	8b 10                	mov    (%eax),%edx
f01091e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091e8:	8b 40 64             	mov    0x64(%eax),%eax
f01091eb:	53                   	push   %ebx
f01091ec:	51                   	push   %ecx
f01091ed:	52                   	push   %edx
f01091ee:	50                   	push   %eax
f01091ef:	e8 b6 f7 ff ff       	call   f01089aa <map_frame>
f01091f4:	83 c4 10             	add    $0x10,%esp

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f01091f7:	ff 45 f4             	incl   -0xc(%ebp)
f01091fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091fd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0109200:	72 b4                	jb     f01091b6 <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
	}
	shared_obj->references++;
f0109202:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109205:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109208:	8d 50 01             	lea    0x1(%eax),%edx
f010920b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010920e:	89 50 4c             	mov    %edx,0x4c(%eax)
	return shared_obj->ID;
f0109211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109214:	8b 00                	mov    (%eax),%eax
}
f0109216:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109219:	c9                   	leave  
f010921a:	c3                   	ret    

f010921b <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f010921b:	55                   	push   %ebp
f010921c:	89 e5                	mov    %esp,%ebp
f010921e:	83 ec 08             	sub    $0x8,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0109221:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109225:	0f 84 ca 00 00 00    	je     f01092f5 <free_share+0xda>
    acquire_spinlock(&AllShares.shareslock);
f010922b:	83 ec 0c             	sub    $0xc,%esp
f010922e:	68 90 d1 75 f0       	push   $0xf075d190
f0109233:	e8 36 6e 00 00       	call   f011006e <acquire_spinlock>
f0109238:	83 c4 10             	add    $0x10,%esp
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
f010923b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010923f:	75 17                	jne    f0109258 <free_share+0x3d>
f0109241:	83 ec 04             	sub    $0x4,%esp
f0109244:	68 63 61 12 f0       	push   $0xf0126163
f0109249:	68 d7 00 00 00       	push   $0xd7
f010924e:	68 1c 61 12 f0       	push   $0xf012611c
f0109253:	e8 e1 70 ff ff       	call   f0100339 <_panic>
f0109258:	8b 45 08             	mov    0x8(%ebp),%eax
f010925b:	8b 40 58             	mov    0x58(%eax),%eax
f010925e:	85 c0                	test   %eax,%eax
f0109260:	74 11                	je     f0109273 <free_share+0x58>
f0109262:	8b 45 08             	mov    0x8(%ebp),%eax
f0109265:	8b 40 58             	mov    0x58(%eax),%eax
f0109268:	8b 55 08             	mov    0x8(%ebp),%edx
f010926b:	8b 52 5c             	mov    0x5c(%edx),%edx
f010926e:	89 50 5c             	mov    %edx,0x5c(%eax)
f0109271:	eb 0b                	jmp    f010927e <free_share+0x63>
f0109273:	8b 45 08             	mov    0x8(%ebp),%eax
f0109276:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109279:	a3 84 d1 75 f0       	mov    %eax,0xf075d184
f010927e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109281:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109284:	85 c0                	test   %eax,%eax
f0109286:	74 11                	je     f0109299 <free_share+0x7e>
f0109288:	8b 45 08             	mov    0x8(%ebp),%eax
f010928b:	8b 40 5c             	mov    0x5c(%eax),%eax
f010928e:	8b 55 08             	mov    0x8(%ebp),%edx
f0109291:	8b 52 58             	mov    0x58(%edx),%edx
f0109294:	89 50 58             	mov    %edx,0x58(%eax)
f0109297:	eb 0b                	jmp    f01092a4 <free_share+0x89>
f0109299:	8b 45 08             	mov    0x8(%ebp),%eax
f010929c:	8b 40 58             	mov    0x58(%eax),%eax
f010929f:	a3 80 d1 75 f0       	mov    %eax,0xf075d180
f01092a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01092a7:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f01092ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01092b1:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f01092b8:	a1 8c d1 75 f0       	mov    0xf075d18c,%eax
f01092bd:	48                   	dec    %eax
f01092be:	a3 8c d1 75 f0       	mov    %eax,0xf075d18c
    release_spinlock(&AllShares.shareslock);
f01092c3:	83 ec 0c             	sub    $0xc,%esp
f01092c6:	68 90 d1 75 f0       	push   $0xf075d190
f01092cb:	e8 25 6e 00 00       	call   f01100f5 <release_spinlock>
f01092d0:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare->framesStorage);
f01092d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01092d6:	8b 40 54             	mov    0x54(%eax),%eax
f01092d9:	83 ec 0c             	sub    $0xc,%esp
f01092dc:	50                   	push   %eax
f01092dd:	e8 ad 07 00 00       	call   f0109a8f <kfree>
f01092e2:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare);
f01092e5:	83 ec 0c             	sub    $0xc,%esp
f01092e8:	ff 75 08             	pushl  0x8(%ebp)
f01092eb:	e8 9f 07 00 00       	call   f0109a8f <kfree>
f01092f0:	83 c4 10             	add    $0x10,%esp
f01092f3:	eb 01                	jmp    f01092f6 <free_share+0xdb>
{
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f01092f5:	90                   	nop
    acquire_spinlock(&AllShares.shareslock);
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
    release_spinlock(&AllShares.shareslock);
    kfree((void*)ptrShare->framesStorage);
    kfree((void*)ptrShare);
}
f01092f6:	c9                   	leave  
f01092f7:	c3                   	ret    

f01092f8 <get_Share_id>:
//========================
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
f01092f8:	55                   	push   %ebp
f01092f9:	89 e5                	mov    %esp,%ebp
f01092fb:	83 ec 18             	sub    $0x18,%esp
    struct Share* founded = NULL;
f01092fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        acquire_spinlock(&AllShares.shareslock);
f0109305:	83 ec 0c             	sub    $0xc,%esp
f0109308:	68 90 d1 75 f0       	push   $0xf075d190
f010930d:	e8 5c 6d 00 00       	call   f011006e <acquire_spinlock>
f0109312:	83 c4 10             	add    $0x10,%esp
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109315:	a1 80 d1 75 f0       	mov    0xf075d180,%eax
f010931a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010931d:	eb 27                	jmp    f0109346 <get_Share_id+0x4e>
            if(founded->ID == sharedObjectID)
f010931f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109322:	8b 00                	mov    (%eax),%eax
f0109324:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109327:	75 15                	jne    f010933e <get_Share_id+0x46>
            {
                release_spinlock(&AllShares.shareslock);
f0109329:	83 ec 0c             	sub    $0xc,%esp
f010932c:	68 90 d1 75 f0       	push   $0xf075d190
f0109331:	e8 bf 6d 00 00       	call   f01100f5 <release_spinlock>
f0109336:	83 c4 10             	add    $0x10,%esp
                return founded;
f0109339:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010933c:	eb 44                	jmp    f0109382 <get_Share_id+0x8a>
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
    struct Share* founded = NULL;
        acquire_spinlock(&AllShares.shareslock);
        LIST_FOREACH(founded, &AllShares.shares_list) {
f010933e:	a1 88 d1 75 f0       	mov    0xf075d188,%eax
f0109343:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109346:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010934a:	74 08                	je     f0109354 <get_Share_id+0x5c>
f010934c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010934f:	8b 40 58             	mov    0x58(%eax),%eax
f0109352:	eb 05                	jmp    f0109359 <get_Share_id+0x61>
f0109354:	b8 00 00 00 00       	mov    $0x0,%eax
f0109359:	a3 88 d1 75 f0       	mov    %eax,0xf075d188
f010935e:	a1 88 d1 75 f0       	mov    0xf075d188,%eax
f0109363:	85 c0                	test   %eax,%eax
f0109365:	75 b8                	jne    f010931f <get_Share_id+0x27>
f0109367:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010936b:	75 b2                	jne    f010931f <get_Share_id+0x27>
            {
                release_spinlock(&AllShares.shareslock);
                return founded;
            }
        }
        release_spinlock(&AllShares.shareslock);
f010936d:	83 ec 0c             	sub    $0xc,%esp
f0109370:	68 90 d1 75 f0       	push   $0xf075d190
f0109375:	e8 7b 6d 00 00       	call   f01100f5 <release_spinlock>
f010937a:	83 c4 10             	add    $0x10,%esp
        return NULL;
f010937d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109382:	c9                   	leave  
f0109383:	c3                   	ret    

f0109384 <freeSharedObject>:

int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0109384:	55                   	push   %ebp
f0109385:	89 e5                	mov    %esp,%ebp
f0109387:	83 ec 38             	sub    $0x38,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
    //panic("freeSharedObject is not implemented yet");
    //Your Code is Here...
		struct Env* myenv = get_cpu_proc();
f010938a:	e8 96 29 00 00       	call   f010bd25 <get_cpu_proc>
f010938f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
f0109392:	83 ec 08             	sub    $0x8,%esp
f0109395:	ff 75 0c             	pushl  0xc(%ebp)
f0109398:	ff 75 08             	pushl  0x8(%ebp)
f010939b:	e8 58 ff ff ff       	call   f01092f8 <get_Share_id>
f01093a0:	83 c4 10             	add    $0x10,%esp
f01093a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(ptr_share == NULL) return -1;
f01093a6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01093aa:	75 0a                	jne    f01093b6 <freeSharedObject+0x32>
f01093ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01093b1:	e9 43 01 00 00       	jmp    f01094f9 <freeSharedObject+0x175>
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
f01093b6:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01093bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01093c0:	8b 40 48             	mov    0x48(%eax),%eax
f01093c3:	89 c2                	mov    %eax,%edx
f01093c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01093c8:	01 d0                	add    %edx,%eax
f01093ca:	48                   	dec    %eax
f01093cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01093ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093d1:	ba 00 00 00 00       	mov    $0x0,%edx
f01093d6:	f7 75 e0             	divl   -0x20(%ebp)
f01093d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093dc:	29 d0                	sub    %edx,%eax
f01093de:	85 c0                	test   %eax,%eax
f01093e0:	79 05                	jns    f01093e7 <freeSharedObject+0x63>
f01093e2:	05 ff 0f 00 00       	add    $0xfff,%eax
f01093e7:	c1 f8 0c             	sar    $0xc,%eax
f01093ea:	89 45 d8             	mov    %eax,-0x28(%ebp)
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01093ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01093f4:	e9 bc 00 00 00       	jmp    f01094b5 <freeSharedObject+0x131>
		{

			int ret = get_page_table(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)), &ptr_page_table);
f01093f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093fc:	c1 e0 0c             	shl    $0xc,%eax
f01093ff:	89 c2                	mov    %eax,%edx
f0109401:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109404:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109407:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010940a:	8b 40 64             	mov    0x64(%eax),%eax
f010940d:	83 ec 04             	sub    $0x4,%esp
f0109410:	8d 55 cc             	lea    -0x34(%ebp),%edx
f0109413:	52                   	push   %edx
f0109414:	51                   	push   %ecx
f0109415:	50                   	push   %eax
f0109416:	e8 ff f2 ff ff       	call   f010871a <get_page_table>
f010941b:	83 c4 10             	add    $0x10,%esp
f010941e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			unmap_frame(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)));
f0109421:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109424:	c1 e0 0c             	shl    $0xc,%eax
f0109427:	89 c2                	mov    %eax,%edx
f0109429:	8b 45 0c             	mov    0xc(%ebp),%eax
f010942c:	01 c2                	add    %eax,%edx
f010942e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109431:	8b 40 64             	mov    0x64(%eax),%eax
f0109434:	83 ec 08             	sub    $0x8,%esp
f0109437:	52                   	push   %edx
f0109438:	50                   	push   %eax
f0109439:	e8 cc f6 ff ff       	call   f0108b0a <unmap_frame>
f010943e:	83 c4 10             	add    $0x10,%esp
			bool isFree = 1;
f0109441:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			for(int i=0;i<1024;i++)
f0109448:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010944f:	eb 22                	jmp    f0109473 <freeSharedObject+0xef>
			{

				if((EXTRACT_ADDRESS(ptr_page_table[i])) != 0){
f0109451:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109454:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109457:	c1 e2 02             	shl    $0x2,%edx
f010945a:	01 d0                	add    %edx,%eax
f010945c:	8b 00                	mov    (%eax),%eax
f010945e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109463:	85 c0                	test   %eax,%eax
f0109465:	74 09                	je     f0109470 <freeSharedObject+0xec>
					isFree = 0;
f0109467:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					break;
f010946e:	eb 0c                	jmp    f010947c <freeSharedObject+0xf8>
		{

			int ret = get_page_table(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)), &ptr_page_table);
			unmap_frame(myenv->env_page_directory, (uint32)((uint32)startVA + (k*PAGE_SIZE)));
			bool isFree = 1;
			for(int i=0;i<1024;i++)
f0109470:	ff 45 ec             	incl   -0x14(%ebp)
f0109473:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010947a:	7e d5                	jle    f0109451 <freeSharedObject+0xcd>
					isFree = 0;
					break;
				}
			}

			if(isFree)
f010947c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109480:	74 30                	je     f01094b2 <freeSharedObject+0x12e>
			{
				kfree((void*)ptr_page_table);
f0109482:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109485:	83 ec 0c             	sub    $0xc,%esp
f0109488:	50                   	push   %eax
f0109489:	e8 01 06 00 00       	call   f0109a8f <kfree>
f010948e:	83 c4 10             	add    $0x10,%esp
				myenv->env_page_directory[PDX((uint32)((uint32)startVA+ (k*PAGE_SIZE)))] = 0;
f0109491:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109494:	8b 40 64             	mov    0x64(%eax),%eax
f0109497:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010949a:	c1 e2 0c             	shl    $0xc,%edx
f010949d:	89 d1                	mov    %edx,%ecx
f010949f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01094a2:	01 ca                	add    %ecx,%edx
f01094a4:	c1 ea 16             	shr    $0x16,%edx
f01094a7:	c1 e2 02             	shl    $0x2,%edx
f01094aa:	01 d0                	add    %edx,%eax
f01094ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
        if(ptr_share == NULL) return -1;
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
        uint32* ptr_page_table;

        for(int k = 0;k<no_of_pages;k++)
f01094b2:	ff 45 f4             	incl   -0xc(%ebp)
f01094b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094b8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01094bb:	0f 82 38 ff ff ff    	jb     f01093f9 <freeSharedObject+0x75>
			}




        ptr_share->references--;
f01094c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094c4:	8b 40 4c             	mov    0x4c(%eax),%eax
f01094c7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01094ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094cd:	89 50 4c             	mov    %edx,0x4c(%eax)

        if(ptr_share->references < 1){
f01094d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094d3:	8b 40 4c             	mov    0x4c(%eax),%eax
f01094d6:	85 c0                	test   %eax,%eax
f01094d8:	75 0e                	jne    f01094e8 <freeSharedObject+0x164>
            free_share(ptr_share);
f01094da:	83 ec 0c             	sub    $0xc,%esp
f01094dd:	ff 75 e4             	pushl  -0x1c(%ebp)
f01094e0:	e8 36 fd ff ff       	call   f010921b <free_share>
f01094e5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01094e8:	0f 20 d8             	mov    %cr3,%eax
f01094eb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01094ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01094f1:	0f 22 d8             	mov    %eax,%cr3
        }
        tlbflush();
        return 0;
f01094f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01094f9:	c9                   	leave  
f01094fa:	c3                   	ret    

f01094fb <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01094fb:	55                   	push   %ebp
f01094fc:	89 e5                	mov    %esp,%ebp
f01094fe:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f0109503:	83 f8 01             	cmp    $0x1,%eax
f0109506:	75 04                	jne    f010950c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0109508:	b0 01                	mov    $0x1,%al
f010950a:	eb 02                	jmp    f010950e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010950c:	b0 00                	mov    $0x0,%al
f010950e:	5d                   	pop    %ebp
f010950f:	c3                   	ret    

f0109510 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0109510:	55                   	push   %ebp
f0109511:	89 e5                	mov    %esp,%ebp
f0109513:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f0109518:	83 f8 02             	cmp    $0x2,%eax
f010951b:	75 04                	jne    f0109521 <isKHeapPlacementStrategyBESTFIT+0x11>
f010951d:	b0 01                	mov    $0x1,%al
f010951f:	eb 02                	jmp    f0109523 <isKHeapPlacementStrategyBESTFIT+0x13>
f0109521:	b0 00                	mov    $0x0,%al
f0109523:	5d                   	pop    %ebp
f0109524:	c3                   	ret    

f0109525 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0109525:	55                   	push   %ebp
f0109526:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0109528:	8b 45 08             	mov    0x8(%ebp),%eax
f010952b:	8b 15 20 d7 b5 f0    	mov    0xf0b5d720,%edx
f0109531:	29 d0                	sub    %edx,%eax
f0109533:	c1 f8 03             	sar    $0x3,%eax
f0109536:	89 c2                	mov    %eax,%edx
f0109538:	89 d0                	mov    %edx,%eax
f010953a:	c1 e0 02             	shl    $0x2,%eax
f010953d:	01 d0                	add    %edx,%eax
f010953f:	c1 e0 02             	shl    $0x2,%eax
f0109542:	01 d0                	add    %edx,%eax
f0109544:	c1 e0 02             	shl    $0x2,%eax
f0109547:	01 d0                	add    %edx,%eax
f0109549:	89 c1                	mov    %eax,%ecx
f010954b:	c1 e1 08             	shl    $0x8,%ecx
f010954e:	01 c8                	add    %ecx,%eax
f0109550:	89 c1                	mov    %eax,%ecx
f0109552:	c1 e1 10             	shl    $0x10,%ecx
f0109555:	01 c8                	add    %ecx,%eax
f0109557:	01 c0                	add    %eax,%eax
f0109559:	01 d0                	add    %edx,%eax
}
f010955b:	5d                   	pop    %ebp
f010955c:	c3                   	ret    

f010955d <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010955d:	55                   	push   %ebp
f010955e:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109560:	ff 75 08             	pushl  0x8(%ebp)
f0109563:	e8 bd ff ff ff       	call   f0109525 <to_frame_number>
f0109568:	83 c4 04             	add    $0x4,%esp
f010956b:	c1 e0 0c             	shl    $0xc,%eax
}
f010956e:	c9                   	leave  
f010956f:	c3                   	ret    

f0109570 <initialize_kheap_dynamic_allocator>:




int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0109570:	55                   	push   %ebp
f0109571:	89 e5                	mov    %esp,%ebp
f0109573:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");

	init_spinlock(&kheaplock,"kheaplock");
f0109576:	83 ec 08             	sub    $0x8,%esp
f0109579:	68 84 61 12 f0       	push   $0xf0126184
f010957e:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109583:	e8 b5 6a 00 00       	call   f011003d <init_spinlock>
f0109588:	83 c4 10             	add    $0x10,%esp

	start = daStart;
f010958b:	8b 45 08             	mov    0x8(%ebp),%eax
f010958e:	a3 e8 d9 f5 f0       	mov    %eax,0xf0f5d9e8
	hard_limit = daLimit;
f0109593:	8b 45 10             	mov    0x10(%ebp),%eax
f0109596:	a3 b4 d7 b5 f0       	mov    %eax,0xf0b5d7b4
	brk = daStart + initSizeToAllocate;
f010959b:	8b 55 08             	mov    0x8(%ebp),%edx
f010959e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095a1:	01 d0                	add    %edx,%eax
f01095a3:	a3 e0 d9 f5 f0       	mov    %eax,0xf0f5d9e0

	if(brk > daLimit) panic("exceeds Limit");
f01095a8:	a1 e0 d9 f5 f0       	mov    0xf0f5d9e0,%eax
f01095ad:	3b 45 10             	cmp    0x10(%ebp),%eax
f01095b0:	76 14                	jbe    f01095c6 <initialize_kheap_dynamic_allocator+0x56>
f01095b2:	83 ec 04             	sub    $0x4,%esp
f01095b5:	68 8e 61 12 f0       	push   $0xf012618e
f01095ba:	6a 1e                	push   $0x1e
f01095bc:	68 9c 61 12 f0       	push   $0xf012619c
f01095c1:	e8 73 6d ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f01095c6:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f01095cd:	8b 45 10             	mov    0x10(%ebp),%eax
f01095d0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f01095d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f01095d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095dc:	c1 e8 0c             	shr    $0xc,%eax
f01095df:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f01095e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01095e9:	e9 8a 00 00 00       	jmp    f0109678 <initialize_kheap_dynamic_allocator+0x108>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f01095ee:	83 ec 0c             	sub    $0xc,%esp
f01095f1:	8d 45 d8             	lea    -0x28(%ebp),%eax
f01095f4:	50                   	push   %eax
f01095f5:	e8 e3 ee ff ff       	call   f01084dd <allocate_frame>
f01095fa:	83 c4 10             	add    $0x10,%esp
f01095fd:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f0109600:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f0109604:	74 5e                	je     f0109664 <initialize_kheap_dynamic_allocator+0xf4>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f0109606:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109609:	c1 e0 0c             	shl    $0xc,%eax
f010960c:	89 c2                	mov    %eax,%edx
f010960e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109611:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109614:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0109617:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f010961c:	6a 02                	push   $0x2
f010961e:	51                   	push   %ecx
f010961f:	52                   	push   %edx
f0109620:	50                   	push   %eax
f0109621:	e8 84 f3 ff ff       	call   f01089aa <map_frame>
f0109626:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f0109629:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010962c:	c1 e0 0c             	shl    $0xc,%eax
f010962f:	89 c2                	mov    %eax,%edx
f0109631:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109634:	01 d0                	add    %edx,%eax
f0109636:	83 ec 0c             	sub    $0xc,%esp
f0109639:	50                   	push   %eax
f010963a:	e8 76 05 00 00       	call   f0109bb5 <kheap_physical_address>
f010963f:	83 c4 10             	add    $0x10,%esp
f0109642:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f0109645:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109648:	c1 e8 0c             	shr    $0xc,%eax
f010964b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010964e:	c1 e2 0c             	shl    $0xc,%edx
f0109651:	89 d1                	mov    %edx,%ecx
f0109653:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109656:	01 ca                	add    %ecx,%edx
f0109658:	89 14 85 e0 d8 b5 f0 	mov    %edx,-0xf4a2720(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f010965f:	ff 45 f4             	incl   -0xc(%ebp)
f0109662:	eb 14                	jmp    f0109678 <initialize_kheap_dynamic_allocator+0x108>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f0109664:	83 ec 04             	sub    $0x4,%esp
f0109667:	68 ad 61 12 f0       	push   $0xf01261ad
f010966c:	6a 33                	push   $0x33
f010966e:	68 9c 61 12 f0       	push   $0xf012619c
f0109673:	e8 c1 6c ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109678:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010967b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010967e:	0f 82 6a ff ff ff    	jb     f01095ee <initialize_kheap_dynamic_allocator+0x7e>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f0109684:	83 ec 08             	sub    $0x8,%esp
f0109687:	ff 75 0c             	pushl  0xc(%ebp)
f010968a:	ff 75 08             	pushl  0x8(%ebp)
f010968d:	e8 59 75 01 00       	call   f0120beb <initialize_dynamic_allocator>
f0109692:	83 c4 10             	add    $0x10,%esp

	return 0;
f0109695:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010969a:	c9                   	leave  
f010969b:	c3                   	ret    

f010969c <sbrk>:

void* sbrk(int numOfPages)
{
f010969c:	55                   	push   %ebp
f010969d:	89 e5                	mov    %esp,%ebp
f010969f:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f01096a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01096a6:	0f 8e d6 00 00 00    	jle    f0109782 <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f01096ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01096af:	c1 e0 0c             	shl    $0xc,%eax
f01096b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f01096b5:	a1 e0 d9 f5 f0       	mov    0xf0f5d9e0,%eax
f01096ba:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f01096bd:	8b 15 e0 d9 f5 f0    	mov    0xf0f5d9e0,%edx
f01096c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096c6:	01 c2                	add    %eax,%edx
f01096c8:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f01096cd:	39 c2                	cmp    %eax,%edx
f01096cf:	76 0a                	jbe    f01096db <sbrk+0x3f>
f01096d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01096d6:	e9 b9 00 00 00       	jmp    f0109794 <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f01096db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01096e2:	eb 7d                	jmp    f0109761 <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f01096e4:	83 ec 0c             	sub    $0xc,%esp
f01096e7:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01096ea:	50                   	push   %eax
f01096eb:	e8 ed ed ff ff       	call   f01084dd <allocate_frame>
f01096f0:	83 c4 10             	add    $0x10,%esp
f01096f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f01096f6:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01096fa:	74 5e                	je     f010975a <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f01096fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01096ff:	c1 e0 0c             	shl    $0xc,%eax
f0109702:	89 c2                	mov    %eax,%edx
f0109704:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109707:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010970a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010970d:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0109712:	6a 02                	push   $0x2
f0109714:	51                   	push   %ecx
f0109715:	52                   	push   %edx
f0109716:	50                   	push   %eax
f0109717:	e8 8e f2 ff ff       	call   f01089aa <map_frame>
f010971c:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f010971f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109722:	c1 e0 0c             	shl    $0xc,%eax
f0109725:	89 c2                	mov    %eax,%edx
f0109727:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010972a:	01 d0                	add    %edx,%eax
f010972c:	83 ec 0c             	sub    $0xc,%esp
f010972f:	50                   	push   %eax
f0109730:	e8 80 04 00 00       	call   f0109bb5 <kheap_physical_address>
f0109735:	83 c4 10             	add    $0x10,%esp
f0109738:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f010973b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010973e:	c1 e8 0c             	shr    $0xc,%eax
f0109741:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109744:	c1 e2 0c             	shl    $0xc,%edx
f0109747:	89 d1                	mov    %edx,%ecx
f0109749:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010974c:	01 ca                	add    %ecx,%edx
f010974e:	89 14 85 e0 d8 b5 f0 	mov    %edx,-0xf4a2720(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109755:	ff 45 f4             	incl   -0xc(%ebp)
f0109758:	eb 07                	jmp    f0109761 <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f010975a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010975f:	eb 33                	jmp    f0109794 <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109761:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109764:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109767:	0f 8c 77 ff ff ff    	jl     f01096e4 <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f010976d:	8b 15 e0 d9 f5 f0    	mov    0xf0f5d9e0,%edx
f0109773:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109776:	01 d0                	add    %edx,%eax
f0109778:	a3 e0 d9 f5 f0       	mov    %eax,0xf0f5d9e0
		return (void *)prev_brk;
f010977d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109780:	eb 12                	jmp    f0109794 <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f0109782:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109786:	75 07                	jne    f010978f <sbrk+0xf3>
	{
		return (void *) brk;
f0109788:	a1 e0 d9 f5 f0       	mov    0xf0f5d9e0,%eax
f010978d:	eb 05                	jmp    f0109794 <sbrk+0xf8>
	}

	return (void *)-1;
f010978f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0109794:	c9                   	leave  
f0109795:	c3                   	ret    

f0109796 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f0109796:	55                   	push   %ebp
f0109797:	89 e5                	mov    %esp,%ebp
f0109799:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f010979c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f01097a3:	83 ec 04             	sub    $0x4,%esp
f01097a6:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01097a9:	50                   	push   %eax
f01097aa:	ff 75 0c             	pushl  0xc(%ebp)
f01097ad:	ff 75 08             	pushl  0x8(%ebp)
f01097b0:	e8 df f2 ff ff       	call   f0108a94 <get_frame_info>
f01097b5:	83 c4 10             	add    $0x10,%esp
f01097b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f01097bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01097bf:	75 07                	jne    f01097c8 <isPageAllocated+0x32>
f01097c1:	b8 00 00 00 00       	mov    $0x0,%eax
f01097c6:	eb 05                	jmp    f01097cd <isPageAllocated+0x37>
	return 1;
f01097c8:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01097cd:	c9                   	leave  
f01097ce:	c3                   	ret    

f01097cf <kmalloc>:




void *kmalloc(unsigned int size)
{
f01097cf:	55                   	push   %ebp
f01097d0:	89 e5                	mov    %esp,%ebp
f01097d2:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f01097d5:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01097dc:	8b 55 08             	mov    0x8(%ebp),%edx
f01097df:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01097e2:	01 d0                	add    %edx,%eax
f01097e4:	48                   	dec    %eax
f01097e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01097e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01097eb:	ba 00 00 00 00       	mov    $0x0,%edx
f01097f0:	f7 75 d8             	divl   -0x28(%ebp)
f01097f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01097f6:	29 d0                	sub    %edx,%eax
f01097f8:	c1 e8 0c             	shr    $0xc,%eax
f01097fb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f01097fe:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0109805:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f010980a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010980d:	29 c2                	sub    %eax,%edx
f010980f:	89 d0                	mov    %edx,%eax
f0109811:	48                   	dec    %eax
f0109812:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0109815:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109818:	ba 00 00 00 00       	mov    $0x0,%edx
f010981d:	f7 75 cc             	divl   -0x34(%ebp)
f0109820:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109823:	29 d0                	sub    %edx,%eax
f0109825:	c1 e8 0c             	shr    $0xc,%eax
f0109828:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f010982b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&kheaplock);
f0109832:	83 ec 0c             	sub    $0xc,%esp
f0109835:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f010983a:	e8 2f 68 00 00       	call   f011006e <acquire_spinlock>
f010983f:	83 c4 10             	add    $0x10,%esp
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109842:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109849:	77 42                	ja     f010988d <kmalloc+0xbe>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f010984b:	e8 ab fc ff ff       	call   f01094fb <isKHeapPlacementStrategyFIRSTFIT>
f0109850:	84 c0                	test   %al,%al
f0109852:	74 16                	je     f010986a <kmalloc+0x9b>
			ptr = alloc_block_FF(size);
f0109854:	83 ec 0c             	sub    $0xc,%esp
f0109857:	ff 75 08             	pushl  0x8(%ebp)
f010985a:	e8 a8 75 01 00       	call   f0120e07 <alloc_block_FF>
f010985f:	83 c4 10             	add    $0x10,%esp
f0109862:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109865:	e9 10 02 00 00       	jmp    f0109a7a <kmalloc+0x2ab>
		else if (isKHeapPlacementStrategyBESTFIT())
f010986a:	e8 a1 fc ff ff       	call   f0109510 <isKHeapPlacementStrategyBESTFIT>
f010986f:	84 c0                	test   %al,%al
f0109871:	0f 84 03 02 00 00    	je     f0109a7a <kmalloc+0x2ab>
			ptr = alloc_block_BF(size);
f0109877:	83 ec 0c             	sub    $0xc,%esp
f010987a:	ff 75 08             	pushl  0x8(%ebp)
f010987d:	e8 41 7a 01 00       	call   f01212c3 <alloc_block_BF>
f0109882:	83 c4 10             	add    $0x10,%esp
f0109885:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109888:	e9 ed 01 00 00       	jmp    f0109a7a <kmalloc+0x2ab>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f010988d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109890:	48                   	dec    %eax
f0109891:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109894:	0f 86 c9 01 00 00    	jbe    f0109a63 <kmalloc+0x294>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f010989a:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f010989f:	05 00 10 00 00       	add    $0x1000,%eax
f01098a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f01098a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f01098ae:	e9 96 00 00 00       	jmp    f0109949 <kmalloc+0x17a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f01098b3:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01098b8:	83 ec 08             	sub    $0x8,%esp
f01098bb:	ff 75 f0             	pushl  -0x10(%ebp)
f01098be:	50                   	push   %eax
f01098bf:	e8 d2 fe ff ff       	call   f0109796 <isPageAllocated>
f01098c4:	83 c4 10             	add    $0x10,%esp
f01098c7:	85 c0                	test   %eax,%eax
f01098c9:	75 71                	jne    f010993c <kmalloc+0x16d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f01098cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098ce:	05 00 10 00 00       	add    $0x1000,%eax
f01098d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f01098d6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f01098dd:	eb 4d                	jmp    f010992c <kmalloc+0x15d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) {release_spinlock(&kheaplock); return NULL;}
f01098df:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f01098e6:	76 1a                	jbe    f0109902 <kmalloc+0x133>
f01098e8:	83 ec 0c             	sub    $0xc,%esp
f01098eb:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f01098f0:	e8 00 68 00 00       	call   f01100f5 <release_spinlock>
f01098f5:	83 c4 10             	add    $0x10,%esp
f01098f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01098fd:	e9 8b 01 00 00       	jmp    f0109a8d <kmalloc+0x2be>
					if (isPageAllocated(ptr_page_directory, j))
f0109902:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0109907:	83 ec 08             	sub    $0x8,%esp
f010990a:	ff 75 e8             	pushl  -0x18(%ebp)
f010990d:	50                   	push   %eax
f010990e:	e8 83 fe ff ff       	call   f0109796 <isPageAllocated>
f0109913:	83 c4 10             	add    $0x10,%esp
f0109916:	85 c0                	test   %eax,%eax
f0109918:	74 08                	je     f0109922 <kmalloc+0x153>
					{

						i = j;
f010991a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010991d:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f0109920:	eb 1a                	jmp    f010993c <kmalloc+0x16d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f0109922:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f0109929:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f010992c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010992f:	48                   	dec    %eax
f0109930:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109933:	77 aa                	ja     f01098df <kmalloc+0x110>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f0109935:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f010993c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109940:	75 16                	jne    f0109958 <kmalloc+0x189>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f0109942:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109949:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f0109950:	0f 86 5d ff ff ff    	jbe    f01098b3 <kmalloc+0xe4>
f0109956:	eb 01                	jmp    f0109959 <kmalloc+0x18a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109958:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) {release_spinlock(&kheaplock); return NULL;}
f0109959:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010995d:	75 1a                	jne    f0109979 <kmalloc+0x1aa>
f010995f:	83 ec 0c             	sub    $0xc,%esp
f0109962:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109967:	e8 89 67 00 00       	call   f01100f5 <release_spinlock>
f010996c:	83 c4 10             	add    $0x10,%esp
f010996f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109974:	e9 14 01 00 00       	jmp    f0109a8d <kmalloc+0x2be>
		for (int k = 0; k < num_pages; k++)
f0109979:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109980:	eb 67                	jmp    f01099e9 <kmalloc+0x21a>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f0109982:	83 ec 0c             	sub    $0xc,%esp
f0109985:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0109988:	50                   	push   %eax
f0109989:	e8 4f eb ff ff       	call   f01084dd <allocate_frame>
f010998e:	83 c4 10             	add    $0x10,%esp
f0109991:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (ret != E_NO_MEM)
f0109994:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f0109998:	74 28                	je     f01099c2 <kmalloc+0x1f3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
f010999a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010999d:	c1 e0 0c             	shl    $0xc,%eax
f01099a0:	89 c2                	mov    %eax,%edx
f01099a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099a5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01099a8:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01099ab:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01099b0:	6a 02                	push   $0x2
f01099b2:	51                   	push   %ecx
f01099b3:	52                   	push   %edx
f01099b4:	50                   	push   %eax
f01099b5:	e8 f0 ef ff ff       	call   f01089aa <map_frame>
f01099ba:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) {release_spinlock(&kheaplock); return NULL;}
		for (int k = 0; k < num_pages; k++)
f01099bd:	ff 45 e0             	incl   -0x20(%ebp)
f01099c0:	eb 27                	jmp    f01099e9 <kmalloc+0x21a>
				//cprintf("kmalloc Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)i + (k * PAGE_SIZE)))]);
				//cprintf("kmalloc Index1 : %d\n",PDX((uint32)((uint32)i + (k * PAGE_SIZE))));
			}
			else
			{
				release_spinlock(&kheaplock);
f01099c2:	83 ec 0c             	sub    $0xc,%esp
f01099c5:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f01099ca:	e8 26 67 00 00       	call   f01100f5 <release_spinlock>
f01099cf:	83 c4 10             	add    $0x10,%esp
				panic("No Memory");
f01099d2:	83 ec 04             	sub    $0x4,%esp
f01099d5:	68 ad 61 12 f0       	push   $0xf01261ad
f01099da:	68 c1 00 00 00       	push   $0xc1
f01099df:	68 9c 61 12 f0       	push   $0xf012619c
f01099e4:	e8 50 69 ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) {release_spinlock(&kheaplock); return NULL;}
		for (int k = 0; k < num_pages; k++)
f01099e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099ec:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01099ef:	72 91                	jb     f0109982 <kmalloc+0x1b3>
			{
				release_spinlock(&kheaplock);
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f01099f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01099f4:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f01099f7:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f01099fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01099ff:	29 c2                	sub    %eax,%edx
f0109a01:	89 d0                	mov    %edx,%eax
f0109a03:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109a08:	c1 e8 0c             	shr    $0xc,%eax
f0109a0b:	89 c2                	mov    %eax,%edx
f0109a0d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109a10:	89 04 95 c0 d2 75 f0 	mov    %eax,-0xf8a2d40(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f0109a17:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109a1e:	eb 39                	jmp    f0109a59 <kmalloc+0x28a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f0109a20:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a23:	c1 e0 0c             	shl    $0xc,%eax
f0109a26:	89 c2                	mov    %eax,%edx
f0109a28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109a2b:	01 d0                	add    %edx,%eax
f0109a2d:	83 ec 0c             	sub    $0xc,%esp
f0109a30:	50                   	push   %eax
f0109a31:	e8 7f 01 00 00       	call   f0109bb5 <kheap_physical_address>
f0109a36:	83 c4 10             	add    $0x10,%esp
f0109a39:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f0109a3c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0109a3f:	c1 e8 0c             	shr    $0xc,%eax
f0109a42:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109a45:	c1 e2 0c             	shl    $0xc,%edx
f0109a48:	89 d1                	mov    %edx,%ecx
f0109a4a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109a4d:	01 ca                	add    %ecx,%edx
f0109a4f:	89 14 85 e0 d8 b5 f0 	mov    %edx,-0xf4a2720(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f0109a56:	ff 45 dc             	incl   -0x24(%ebp)
f0109a59:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a5c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109a5f:	72 bf                	jb     f0109a20 <kmalloc+0x251>
f0109a61:	eb 17                	jmp    f0109a7a <kmalloc+0x2ab>
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
		}
	}
	else
	{
		release_spinlock(&kheaplock);
f0109a63:	83 ec 0c             	sub    $0xc,%esp
f0109a66:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109a6b:	e8 85 66 00 00       	call   f01100f5 <release_spinlock>
f0109a70:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0109a73:	b8 00 00 00 00       	mov    $0x0,%eax
f0109a78:	eb 13                	jmp    f0109a8d <kmalloc+0x2be>
	}
	release_spinlock(&kheaplock);
f0109a7a:	83 ec 0c             	sub    $0xc,%esp
f0109a7d:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109a82:	e8 6e 66 00 00       	call   f01100f5 <release_spinlock>
f0109a87:	83 c4 10             	add    $0x10,%esp
	return ptr;
f0109a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109a8d:	c9                   	leave  
f0109a8e:	c3                   	ret    

f0109a8f <kfree>:

void kfree(void *va)
{
f0109a8f:	55                   	push   %ebp
f0109a90:	89 e5                	mov    %esp,%ebp
f0109a92:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
	acquire_spinlock(&kheaplock);
f0109a95:	83 ec 0c             	sub    $0xc,%esp
f0109a98:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109a9d:	e8 cc 65 00 00       	call   f011006e <acquire_spinlock>
f0109aa2:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109aa5:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f0109aaa:	05 00 10 00 00       	add    $0x1000,%eax
f0109aaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f0109ab2:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ab5:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f0109aba:	39 c2                	cmp    %eax,%edx
f0109abc:	73 23                	jae    f0109ae1 <kfree+0x52>

        free_block(va);
f0109abe:	83 ec 0c             	sub    $0xc,%esp
f0109ac1:	ff 75 08             	pushl  0x8(%ebp)
f0109ac4:	e8 df 81 01 00       	call   f0121ca8 <free_block>
f0109ac9:	83 c4 10             	add    $0x10,%esp
        release_spinlock(&kheaplock);
f0109acc:	83 ec 0c             	sub    $0xc,%esp
f0109acf:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109ad4:	e8 1c 66 00 00       	call   f01100f5 <release_spinlock>
f0109ad9:	83 c4 10             	add    $0x10,%esp
    else{
    	release_spinlock(&kheaplock);
        panic("kfree: The virtual Address is invalid");
    }

}
f0109adc:	e9 d2 00 00 00       	jmp    f0109bb3 <kfree+0x124>
    if((uint32)va < hard_limit){

        free_block(va);
        release_spinlock(&kheaplock);
    }
    else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ae4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109ae7:	0f 82 9f 00 00 00    	jb     f0109b8c <kfree+0xfd>
f0109aed:	8b 45 08             	mov    0x8(%ebp),%eax
f0109af0:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109af5:	0f 87 91 00 00 00    	ja     f0109b8c <kfree+0xfd>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f0109afb:	8b 55 08             	mov    0x8(%ebp),%edx
f0109afe:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f0109b03:	29 c2                	sub    %eax,%edx
f0109b05:	89 d0                	mov    %edx,%eax
f0109b07:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109b0c:	c1 e8 0c             	shr    $0xc,%eax
f0109b0f:	8b 04 85 c0 d2 75 f0 	mov    -0xf8a2d40(,%eax,4),%eax
f0109b16:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f0109b19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109b20:	eb 4f                	jmp    f0109b71 <kfree+0xe2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f0109b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b25:	c1 e0 0c             	shl    $0xc,%eax
f0109b28:	89 c2                	mov    %eax,%edx
f0109b2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b2d:	01 d0                	add    %edx,%eax
f0109b2f:	83 ec 0c             	sub    $0xc,%esp
f0109b32:	50                   	push   %eax
f0109b33:	e8 7d 00 00 00       	call   f0109bb5 <kheap_physical_address>
f0109b38:	83 c4 10             	add    $0x10,%esp
f0109b3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f0109b3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109b41:	c1 e8 0c             	shr    $0xc,%eax
f0109b44:	c7 04 85 e0 d8 b5 f0 	movl   $0x0,-0xf4a2720(,%eax,4)
f0109b4b:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f0109b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b52:	c1 e0 0c             	shl    $0xc,%eax
f0109b55:	89 c2                	mov    %eax,%edx
f0109b57:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b5a:	01 c2                	add    %eax,%edx
f0109b5c:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0109b61:	83 ec 08             	sub    $0x8,%esp
f0109b64:	52                   	push   %edx
f0109b65:	50                   	push   %eax
f0109b66:	e8 9f ef ff ff       	call   f0108b0a <unmap_frame>
f0109b6b:	83 c4 10             	add    $0x10,%esp
        free_block(va);
        release_spinlock(&kheaplock);
    }
    else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f0109b6e:	ff 45 f4             	incl   -0xc(%ebp)
f0109b71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b74:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109b77:	72 a9                	jb     f0109b22 <kfree+0x93>
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
			//isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
			//cprintf("kfree Page Index1 : %d\n",isTableExist[PDX((uint32)((uint32)va + (i * PAGE_SIZE)))]);
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
		release_spinlock(&kheaplock);
f0109b79:	83 ec 0c             	sub    $0xc,%esp
f0109b7c:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109b81:	e8 6f 65 00 00       	call   f01100f5 <release_spinlock>
f0109b86:	83 c4 10             	add    $0x10,%esp
    if((uint32)va < hard_limit){

        free_block(va);
        release_spinlock(&kheaplock);
    }
    else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109b89:	90                   	nop
    else{
    	release_spinlock(&kheaplock);
        panic("kfree: The virtual Address is invalid");
    }

}
f0109b8a:	eb 27                	jmp    f0109bb3 <kfree+0x124>
			//cprintf(" kfree Index1 : %d\n",PDX((uint32)((uint32)va + (i * PAGE_SIZE))));
		}
		release_spinlock(&kheaplock);
    }
    else{
    	release_spinlock(&kheaplock);
f0109b8c:	83 ec 0c             	sub    $0xc,%esp
f0109b8f:	68 e0 d8 f5 f0       	push   $0xf0f5d8e0
f0109b94:	e8 5c 65 00 00       	call   f01100f5 <release_spinlock>
f0109b99:	83 c4 10             	add    $0x10,%esp
        panic("kfree: The virtual Address is invalid");
f0109b9c:	83 ec 04             	sub    $0x4,%esp
f0109b9f:	68 b8 61 12 f0       	push   $0xf01261b8
f0109ba4:	68 f3 00 00 00       	push   $0xf3
f0109ba9:	68 9c 61 12 f0       	push   $0xf012619c
f0109bae:	e8 86 67 ff ff       	call   f0100339 <_panic>
    }

}
f0109bb3:	c9                   	leave  
f0109bb4:	c3                   	ret    

f0109bb5 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f0109bb5:	55                   	push   %ebp
f0109bb6:	89 e5                	mov    %esp,%ebp
f0109bb8:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109bbb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f0109bc2:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0109bc7:	83 ec 04             	sub    $0x4,%esp
f0109bca:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0109bcd:	52                   	push   %edx
f0109bce:	ff 75 08             	pushl  0x8(%ebp)
f0109bd1:	50                   	push   %eax
f0109bd2:	e8 bd ee ff ff       	call   f0108a94 <get_frame_info>
f0109bd7:	83 c4 10             	add    $0x10,%esp
f0109bda:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f0109bdd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109be1:	75 07                	jne    f0109bea <kheap_physical_address+0x35>
		return 0;
f0109be3:	b8 00 00 00 00       	mov    $0x0,%eax
f0109be8:	eb 26                	jmp    f0109c10 <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f0109bea:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bed:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109bf2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f0109bf5:	83 ec 0c             	sub    $0xc,%esp
f0109bf8:	ff 75 f4             	pushl  -0xc(%ebp)
f0109bfb:	e8 5d f9 ff ff       	call   f010955d <to_physical_address>
f0109c00:	83 c4 10             	add    $0x10,%esp
f0109c03:	89 c2                	mov    %eax,%edx
f0109c05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c08:	01 d0                	add    %edx,%eax
f0109c0a:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f0109c0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0109c10:	c9                   	leave  
f0109c11:	c3                   	ret    

f0109c12 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109c12:	55                   	push   %ebp
f0109c13:	89 e5                	mov    %esp,%ebp
f0109c15:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f0109c18:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c1b:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109c20:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f0109c23:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c26:	c1 e8 0c             	shr    $0xc,%eax
f0109c29:	8b 04 85 e0 d8 b5 f0 	mov    -0xf4a2720(,%eax,4),%eax
f0109c30:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f0109c33:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0109c37:	74 06                	je     f0109c3f <kheap_virtual_address+0x2d>
f0109c39:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0109c3c:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f0109c3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0109c42:	c9                   	leave  
f0109c43:	c3                   	ret    

f0109c44 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *va, uint32 new_size)
{
f0109c44:	55                   	push   %ebp
f0109c45:	89 e5                	mov    %esp,%ebp
f0109c47:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	//return NULL;
//	panic("krealloc() is not implemented yet...!!");
	void *ptr = NULL;
f0109c4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(va == NULL){
f0109c51:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109c55:	75 16                	jne    f0109c6d <krealloc+0x29>
		ptr = kmalloc(new_size);
f0109c57:	83 ec 0c             	sub    $0xc,%esp
f0109c5a:	ff 75 0c             	pushl  0xc(%ebp)
f0109c5d:	e8 6d fb ff ff       	call   f01097cf <kmalloc>
f0109c62:	83 c4 10             	add    $0x10,%esp
f0109c65:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109c68:	e9 37 03 00 00       	jmp    f0109fa4 <krealloc+0x360>
	} else if(new_size == 0){
f0109c6d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0109c71:	75 13                	jne    f0109c86 <krealloc+0x42>
		kfree(va);
f0109c73:	83 ec 0c             	sub    $0xc,%esp
f0109c76:	ff 75 08             	pushl  0x8(%ebp)
f0109c79:	e8 11 fe ff ff       	call   f0109a8f <kfree>
f0109c7e:	83 c4 10             	add    $0x10,%esp
f0109c81:	e9 1e 03 00 00       	jmp    f0109fa4 <krealloc+0x360>
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109c86:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f0109c8b:	05 00 10 00 00       	add    $0x1000,%eax
f0109c90:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)va < hard_limit){
f0109c93:	8b 55 08             	mov    0x8(%ebp),%edx
f0109c96:	a1 b4 d7 b5 f0       	mov    0xf0b5d7b4,%eax
f0109c9b:	39 c2                	cmp    %eax,%edx
f0109c9d:	73 19                	jae    f0109cb8 <krealloc+0x74>
			ptr = realloc_block_FF(va, new_size);
f0109c9f:	83 ec 08             	sub    $0x8,%esp
f0109ca2:	ff 75 0c             	pushl  0xc(%ebp)
f0109ca5:	ff 75 08             	pushl  0x8(%ebp)
f0109ca8:	e8 fb 80 01 00       	call   f0121da8 <realloc_block_FF>
f0109cad:	83 c4 10             	add    $0x10,%esp
f0109cb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109cb3:	e9 ec 02 00 00       	jmp    f0109fa4 <krealloc+0x360>
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109cb8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cbb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0109cbe:	0f 82 c8 02 00 00    	jb     f0109f8c <krealloc+0x348>
f0109cc4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cc7:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109ccc:	0f 87 ba 02 00 00    	ja     f0109f8c <krealloc+0x348>
			uint32 num_pages = ROUNDUP(new_size ,PAGE_SIZE) / PAGE_SIZE;
f0109cd2:	c7 45 d4 00 10 00 00 	movl   $0x1000,-0x2c(%ebp)
f0109cd9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109cdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109cdf:	01 d0                	add    %edx,%eax
f0109ce1:	48                   	dec    %eax
f0109ce2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109ce5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109ce8:	ba 00 00 00 00       	mov    $0x0,%edx
f0109ced:	f7 75 d4             	divl   -0x2c(%ebp)
f0109cf0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109cf3:	29 d0                	sub    %edx,%eax
f0109cf5:	c1 e8 0c             	shr    $0xc,%eax
f0109cf8:	89 45 cc             	mov    %eax,-0x34(%ebp)
			uint32 num_old_pages = no_pages_alloc[(uint32)va / PAGE_SIZE];
f0109cfb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cfe:	c1 e8 0c             	shr    $0xc,%eax
f0109d01:	8b 04 85 c0 d2 75 f0 	mov    -0xf8a2d40(,%eax,4),%eax
f0109d08:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if(num_pages <= num_old_pages){
f0109d0b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109d0e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0109d11:	0f 87 ee 00 00 00    	ja     f0109e05 <krealloc+0x1c1>
				if (new_size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109d17:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
f0109d1e:	77 63                	ja     f0109d83 <krealloc+0x13f>
				{
					if (isKHeapPlacementStrategyFIRSTFIT())
f0109d20:	e8 d6 f7 ff ff       	call   f01094fb <isKHeapPlacementStrategyFIRSTFIT>
f0109d25:	84 c0                	test   %al,%al
f0109d27:	74 13                	je     f0109d3c <krealloc+0xf8>
						ptr = alloc_block_FF(new_size);
f0109d29:	83 ec 0c             	sub    $0xc,%esp
f0109d2c:	ff 75 0c             	pushl  0xc(%ebp)
f0109d2f:	e8 d3 70 01 00       	call   f0120e07 <alloc_block_FF>
f0109d34:	83 c4 10             	add    $0x10,%esp
f0109d37:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109d3a:	eb 1a                	jmp    f0109d56 <krealloc+0x112>
					else if (isKHeapPlacementStrategyBESTFIT())
f0109d3c:	e8 cf f7 ff ff       	call   f0109510 <isKHeapPlacementStrategyBESTFIT>
f0109d41:	84 c0                	test   %al,%al
f0109d43:	74 11                	je     f0109d56 <krealloc+0x112>
						ptr = alloc_block_BF(new_size);
f0109d45:	83 ec 0c             	sub    $0xc,%esp
f0109d48:	ff 75 0c             	pushl  0xc(%ebp)
f0109d4b:	e8 73 75 01 00       	call   f01212c3 <alloc_block_BF>
f0109d50:	83 c4 10             	add    $0x10,%esp
f0109d53:	89 45 f4             	mov    %eax,-0xc(%ebp)
					if(ptr != NULL) memcpy(ptr, va, new_size);
f0109d56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109d5a:	74 14                	je     f0109d70 <krealloc+0x12c>
f0109d5c:	83 ec 04             	sub    $0x4,%esp
f0109d5f:	ff 75 0c             	pushl  0xc(%ebp)
f0109d62:	ff 75 08             	pushl  0x8(%ebp)
f0109d65:	ff 75 f4             	pushl  -0xc(%ebp)
f0109d68:	e8 cd 64 01 00       	call   f012023a <memcpy>
f0109d6d:	83 c4 10             	add    $0x10,%esp
					kfree(va);
f0109d70:	83 ec 0c             	sub    $0xc,%esp
f0109d73:	ff 75 08             	pushl  0x8(%ebp)
f0109d76:	e8 14 fd ff ff       	call   f0109a8f <kfree>
f0109d7b:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109d7e:	e9 20 02 00 00       	jmp    f0109fa3 <krealloc+0x35f>
					else if (isKHeapPlacementStrategyBESTFIT())
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
f0109d83:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109d86:	c1 e0 0c             	shl    $0xc,%eax
f0109d89:	89 c2                	mov    %eax,%edx
f0109d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d8e:	01 d0                	add    %edx,%eax
f0109d90:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109d93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109d9a:	eb 4f                	jmp    f0109deb <krealloc+0x1a7>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
f0109d9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d9f:	c1 e0 0c             	shl    $0xc,%eax
f0109da2:	89 c2                	mov    %eax,%edx
f0109da4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109da7:	01 d0                	add    %edx,%eax
f0109da9:	83 ec 0c             	sub    $0xc,%esp
f0109dac:	50                   	push   %eax
f0109dad:	e8 03 fe ff ff       	call   f0109bb5 <kheap_physical_address>
f0109db2:	83 c4 10             	add    $0x10,%esp
f0109db5:	89 45 c0             	mov    %eax,-0x40(%ebp)
						to_virtual[pa / PAGE_SIZE] = 0;
f0109db8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109dbb:	c1 e8 0c             	shr    $0xc,%eax
f0109dbe:	c7 04 85 e0 d8 b5 f0 	movl   $0x0,-0xf4a2720(,%eax,4)
f0109dc5:	00 00 00 00 
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
f0109dc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109dcc:	c1 e0 0c             	shl    $0xc,%eax
f0109dcf:	89 c2                	mov    %eax,%edx
f0109dd1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109dd4:	01 c2                	add    %eax,%edx
f0109dd6:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0109ddb:	83 ec 08             	sub    $0x8,%esp
f0109dde:	52                   	push   %edx
f0109ddf:	50                   	push   %eax
f0109de0:	e8 25 ed ff ff       	call   f0108b0a <unmap_frame>
f0109de5:	83 c4 10             	add    $0x10,%esp
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109de8:	ff 45 f0             	incl   -0x10(%ebp)
f0109deb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109dee:	2b 45 cc             	sub    -0x34(%ebp),%eax
f0109df1:	89 c2                	mov    %eax,%edx
f0109df3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109df6:	39 c2                	cmp    %eax,%edx
f0109df8:	77 a2                	ja     f0109d9c <krealloc+0x158>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
						to_virtual[pa / PAGE_SIZE] = 0;
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
f0109dfa:	8b 45 08             	mov    0x8(%ebp),%eax
f0109dfd:	89 45 f4             	mov    %eax,-0xc(%ebp)
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109e00:	e9 9e 01 00 00       	jmp    f0109fa3 <krealloc+0x35f>
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
f0109e05:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109e08:	c1 e0 0c             	shl    $0xc,%eax
f0109e0b:	89 c2                	mov    %eax,%edx
f0109e0d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e10:	01 d0                	add    %edx,%eax
f0109e12:	89 45 ec             	mov    %eax,-0x14(%ebp)
				uint32 cnt = 0;
f0109e15:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				bool found_free_pages = 0;
f0109e1c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < (num_pages - num_old_pages))
f0109e23:	eb 33                	jmp    f0109e58 <krealloc+0x214>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
f0109e25:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f0109e2c:	0f 87 19 01 00 00    	ja     f0109f4b <krealloc+0x307>
f0109e32:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0109e37:	83 ec 08             	sub    $0x8,%esp
f0109e3a:	ff 75 ec             	pushl  -0x14(%ebp)
f0109e3d:	50                   	push   %eax
f0109e3e:	e8 53 f9 ff ff       	call   f0109796 <isPageAllocated>
f0109e43:	83 c4 10             	add    $0x10,%esp
f0109e46:	85 c0                	test   %eax,%eax
f0109e48:	0f 85 fd 00 00 00    	jne    f0109f4b <krealloc+0x307>
					j += (uint32)PAGE_SIZE;
f0109e4e:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
					cnt++;
f0109e55:	ff 45 e8             	incl   -0x18(%ebp)
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
				uint32 cnt = 0;
				bool found_free_pages = 0;
				while(cnt < (num_pages - num_old_pages))
f0109e58:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109e5b:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109e5e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109e61:	77 c2                	ja     f0109e25 <krealloc+0x1e1>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
f0109e63:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109e6a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109e71:	eb 5c                	jmp    f0109ecf <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
f0109e73:	83 ec 0c             	sub    $0xc,%esp
f0109e76:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0109e79:	50                   	push   %eax
f0109e7a:	e8 5e e6 ff ff       	call   f01084dd <allocate_frame>
f0109e7f:	83 c4 10             	add    $0x10,%esp
f0109e82:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
f0109e85:	83 7d bc fc          	cmpl   $0xfffffffc,-0x44(%ebp)
f0109e89:	74 2d                	je     f0109eb8 <krealloc+0x274>
f0109e8b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109e8e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109e91:	01 d0                	add    %edx,%eax
f0109e93:	c1 e0 0c             	shl    $0xc,%eax
f0109e96:	89 c2                	mov    %eax,%edx
f0109e98:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e9b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109e9e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0109ea1:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0109ea6:	6a 02                	push   $0x2
f0109ea8:	51                   	push   %ecx
f0109ea9:	52                   	push   %edx
f0109eaa:	50                   	push   %eax
f0109eab:	e8 fa ea ff ff       	call   f01089aa <map_frame>
f0109eb0:	83 c4 10             	add    $0x10,%esp
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109eb3:	ff 45 e0             	incl   -0x20(%ebp)
f0109eb6:	eb 17                	jmp    f0109ecf <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
f0109eb8:	83 ec 04             	sub    $0x4,%esp
f0109ebb:	68 ad 61 12 f0       	push   $0xf01261ad
f0109ec0:	68 61 01 00 00       	push   $0x161
f0109ec5:	68 9c 61 12 f0       	push   $0xf012619c
f0109eca:	e8 6a 64 ff ff       	call   f0100339 <_panic>
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109ecf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ed2:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109ed5:	89 c2                	mov    %eax,%edx
f0109ed7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109eda:	39 c2                	cmp    %eax,%edx
f0109edc:	77 95                	ja     f0109e73 <krealloc+0x22f>
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
f0109ede:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ee1:	c1 e8 0c             	shr    $0xc,%eax
f0109ee4:	89 c2                	mov    %eax,%edx
f0109ee6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ee9:	89 04 95 c0 d2 75 f0 	mov    %eax,-0xf8a2d40(,%edx,4)
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109ef0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109ef7:	eb 43                	jmp    f0109f3c <krealloc+0x2f8>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
f0109ef9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109efc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109eff:	01 d0                	add    %edx,%eax
f0109f01:	c1 e0 0c             	shl    $0xc,%eax
f0109f04:	89 c2                	mov    %eax,%edx
f0109f06:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f09:	01 d0                	add    %edx,%eax
f0109f0b:	83 ec 0c             	sub    $0xc,%esp
f0109f0e:	50                   	push   %eax
f0109f0f:	e8 a1 fc ff ff       	call   f0109bb5 <kheap_physical_address>
f0109f14:	83 c4 10             	add    $0x10,%esp
f0109f17:	89 45 b8             	mov    %eax,-0x48(%ebp)
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
f0109f1a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109f1d:	c1 e8 0c             	shr    $0xc,%eax
f0109f20:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0109f23:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0109f26:	01 ca                	add    %ecx,%edx
f0109f28:	89 d1                	mov    %edx,%ecx
f0109f2a:	c1 e1 0c             	shl    $0xc,%ecx
f0109f2d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109f30:	01 ca                	add    %ecx,%edx
f0109f32:	89 14 85 e0 d8 b5 f0 	mov    %edx,-0xf4a2720(,%eax,4)
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109f39:	ff 45 dc             	incl   -0x24(%ebp)
f0109f3c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109f3f:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109f42:	89 c2                	mov    %eax,%edx
f0109f44:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f47:	39 c2                	cmp    %eax,%edx
f0109f49:	77 ae                	ja     f0109ef9 <krealloc+0x2b5>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
				}
				sayed:
					if(!found_free_pages){
f0109f4b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109f4f:	75 52                	jne    f0109fa3 <krealloc+0x35f>
						ptr = kmalloc(new_size);
f0109f51:	83 ec 0c             	sub    $0xc,%esp
f0109f54:	ff 75 0c             	pushl  0xc(%ebp)
f0109f57:	e8 73 f8 ff ff       	call   f01097cf <kmalloc>
f0109f5c:	83 c4 10             	add    $0x10,%esp
f0109f5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
						if(ptr != NULL) memcpy(ptr, va, new_size);
f0109f62:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109f66:	74 14                	je     f0109f7c <krealloc+0x338>
f0109f68:	83 ec 04             	sub    $0x4,%esp
f0109f6b:	ff 75 0c             	pushl  0xc(%ebp)
f0109f6e:	ff 75 08             	pushl  0x8(%ebp)
f0109f71:	ff 75 f4             	pushl  -0xc(%ebp)
f0109f74:	e8 c1 62 01 00       	call   f012023a <memcpy>
f0109f79:	83 c4 10             	add    $0x10,%esp
						kfree(va);
f0109f7c:	83 ec 0c             	sub    $0xc,%esp
f0109f7f:	ff 75 08             	pushl  0x8(%ebp)
f0109f82:	e8 08 fb ff ff       	call   f0109a8f <kfree>
f0109f87:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109f8a:	eb 17                	jmp    f0109fa3 <krealloc+0x35f>
						if(ptr != NULL) memcpy(ptr, va, new_size);
						kfree(va);
					}
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
f0109f8c:	83 ec 04             	sub    $0x4,%esp
f0109f8f:	68 e0 61 12 f0       	push   $0xf01261e0
f0109f94:	68 70 01 00 00       	push   $0x170
f0109f99:	68 9c 61 12 f0       	push   $0xf012619c
f0109f9e:	e8 96 63 ff ff       	call   f0100339 <_panic>
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109fa3:	90                   	nop
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
		}
	}
	return ptr;
f0109fa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109fa7:	c9                   	leave  
f0109fa8:	c3                   	ret    

f0109fa9 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109fa9:	55                   	push   %ebp
f0109faa:	89 e5                	mov    %esp,%ebp
f0109fac:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109faf:	83 ec 04             	sub    $0x4,%esp
f0109fb2:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109fb5:	50                   	push   %eax
f0109fb6:	ff 75 0c             	pushl  0xc(%ebp)
f0109fb9:	ff 75 08             	pushl  0x8(%ebp)
f0109fbc:	e8 59 e7 ff ff       	call   f010871a <get_page_table>
f0109fc1:	83 c4 10             	add    $0x10,%esp
f0109fc4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109fc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fca:	85 c0                	test   %eax,%eax
f0109fcc:	74 64                	je     f010a032 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109fce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fd1:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109fd4:	c1 ea 0c             	shr    $0xc,%edx
f0109fd7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109fdd:	c1 e2 02             	shl    $0x2,%edx
f0109fe0:	01 c2                	add    %eax,%edx
f0109fe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fe5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109fe8:	c1 e9 0c             	shr    $0xc,%ecx
f0109feb:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109ff1:	c1 e1 02             	shl    $0x2,%ecx
f0109ff4:	01 c8                	add    %ecx,%eax
f0109ff6:	8b 00                	mov    (%eax),%eax
f0109ff8:	0b 45 10             	or     0x10(%ebp),%eax
f0109ffb:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109ffd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a000:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a003:	c1 ea 0c             	shr    $0xc,%edx
f010a006:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a00c:	c1 e2 02             	shl    $0x2,%edx
f010a00f:	01 d0                	add    %edx,%eax
f010a011:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a014:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a017:	c1 e9 0c             	shr    $0xc,%ecx
f010a01a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a020:	c1 e1 02             	shl    $0x2,%ecx
f010a023:	01 ca                	add    %ecx,%edx
f010a025:	8b 12                	mov    (%edx),%edx
f010a027:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010a02a:	f7 d1                	not    %ecx
f010a02c:	21 ca                	and    %ecx,%edx
f010a02e:	89 10                	mov    %edx,(%eax)
f010a030:	eb 27                	jmp    f010a059 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f010a032:	83 ec 08             	sub    $0x8,%esp
f010a035:	ff 75 0c             	pushl  0xc(%ebp)
f010a038:	68 0c 62 12 f0       	push   $0xf012620c
f010a03d:	e8 49 6f ff ff       	call   f0100f8b <cprintf>
f010a042:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010a045:	83 ec 04             	sub    $0x4,%esp
f010a048:	68 34 62 12 f0       	push   $0xf0126234
f010a04d:	6a 1c                	push   $0x1c
f010a04f:	68 a8 62 12 f0       	push   $0xf01262a8
f010a054:	e8 e0 62 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a059:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a05c:	83 ec 08             	sub    $0x8,%esp
f010a05f:	50                   	push   %eax
f010a060:	6a 00                	push   $0x0
f010a062:	e8 7d e0 ff ff       	call   f01080e4 <tlb_invalidate>
f010a067:	83 c4 10             	add    $0x10,%esp
}
f010a06a:	90                   	nop
f010a06b:	c9                   	leave  
f010a06c:	c3                   	ret    

f010a06d <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f010a06d:	55                   	push   %ebp
f010a06e:	89 e5                	mov    %esp,%ebp
f010a070:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a073:	83 ec 04             	sub    $0x4,%esp
f010a076:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a079:	50                   	push   %eax
f010a07a:	ff 75 0c             	pushl  0xc(%ebp)
f010a07d:	ff 75 08             	pushl  0x8(%ebp)
f010a080:	e8 95 e6 ff ff       	call   f010871a <get_page_table>
f010a085:	83 c4 10             	add    $0x10,%esp
f010a088:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f010a08b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a08e:	85 c0                	test   %eax,%eax
f010a090:	74 1d                	je     f010a0af <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f010a092:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a095:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a098:	c1 ea 0c             	shr    $0xc,%edx
f010a09b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a0a1:	c1 e2 02             	shl    $0x2,%edx
f010a0a4:	01 d0                	add    %edx,%eax
f010a0a6:	8b 00                	mov    (%eax),%eax
f010a0a8:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a0ad:	eb 05                	jmp    f010a0b4 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f010a0af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f010a0b4:	c9                   	leave  
f010a0b5:	c3                   	ret    

f010a0b6 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f010a0b6:	55                   	push   %ebp
f010a0b7:	89 e5                	mov    %esp,%ebp
f010a0b9:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a0bc:	83 ec 04             	sub    $0x4,%esp
f010a0bf:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a0c2:	50                   	push   %eax
f010a0c3:	ff 75 0c             	pushl  0xc(%ebp)
f010a0c6:	ff 75 08             	pushl  0x8(%ebp)
f010a0c9:	e8 4c e6 ff ff       	call   f010871a <get_page_table>
f010a0ce:	83 c4 10             	add    $0x10,%esp
f010a0d1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010a0d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0d7:	85 c0                	test   %eax,%eax
f010a0d9:	74 46                	je     f010a121 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f010a0db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0de:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a0e1:	c1 ea 0c             	shr    $0xc,%edx
f010a0e4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a0ea:	c1 e2 02             	shl    $0x2,%edx
f010a0ed:	01 d0                	add    %edx,%eax
f010a0ef:	8b 00                	mov    (%eax),%eax
f010a0f1:	83 ec 04             	sub    $0x4,%esp
f010a0f4:	50                   	push   %eax
f010a0f5:	ff 75 0c             	pushl  0xc(%ebp)
f010a0f8:	68 c4 62 12 f0       	push   $0xf01262c4
f010a0fd:	e8 89 6e ff ff       	call   f0100f8b <cprintf>
f010a102:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f010a105:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a108:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a10b:	c1 ea 0c             	shr    $0xc,%edx
f010a10e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a114:	c1 e2 02             	shl    $0x2,%edx
f010a117:	01 d0                	add    %edx,%eax
f010a119:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a11f:	eb 14                	jmp    f010a135 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010a121:	83 ec 04             	sub    $0x4,%esp
f010a124:	68 ec 62 12 f0       	push   $0xf01262ec
f010a129:	6a 47                	push   $0x47
f010a12b:	68 a8 62 12 f0       	push   $0xf01262a8
f010a130:	e8 04 62 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a135:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a138:	83 ec 08             	sub    $0x8,%esp
f010a13b:	50                   	push   %eax
f010a13c:	6a 00                	push   $0x0
f010a13e:	e8 a1 df ff ff       	call   f01080e4 <tlb_invalidate>
f010a143:	83 c4 10             	add    $0x10,%esp
}
f010a146:	90                   	nop
f010a147:	c9                   	leave  
f010a148:	c3                   	ret    

f010a149 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f010a149:	55                   	push   %ebp
f010a14a:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f010a14c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a14f:	c1 e8 16             	shr    $0x16,%eax
f010a152:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a159:	8b 45 08             	mov    0x8(%ebp),%eax
f010a15c:	01 d0                	add    %edx,%eax
f010a15e:	8b 00                	mov    (%eax),%eax
f010a160:	83 e0 20             	and    $0x20,%eax
f010a163:	85 c0                	test   %eax,%eax
f010a165:	0f 95 c0             	setne  %al
f010a168:	0f b6 c0             	movzbl %al,%eax
}
f010a16b:	5d                   	pop    %ebp
f010a16c:	c3                   	ret    

f010a16d <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f010a16d:	55                   	push   %ebp
f010a16e:	89 e5                	mov    %esp,%ebp
f010a170:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f010a173:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a176:	c1 e8 16             	shr    $0x16,%eax
f010a179:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a180:	8b 45 08             	mov    0x8(%ebp),%eax
f010a183:	01 d0                	add    %edx,%eax
f010a185:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a188:	c1 ea 16             	shr    $0x16,%edx
f010a18b:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f010a192:	8b 55 08             	mov    0x8(%ebp),%edx
f010a195:	01 ca                	add    %ecx,%edx
f010a197:	8b 12                	mov    (%edx),%edx
f010a199:	83 e2 df             	and    $0xffffffdf,%edx
f010a19c:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a19e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a1a1:	83 ec 08             	sub    $0x8,%esp
f010a1a4:	50                   	push   %eax
f010a1a5:	6a 00                	push   $0x0
f010a1a7:	e8 38 df ff ff       	call   f01080e4 <tlb_invalidate>
f010a1ac:	83 c4 10             	add    $0x10,%esp
}
f010a1af:	90                   	nop
f010a1b0:	c9                   	leave  
f010a1b1:	c3                   	ret    

f010a1b2 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f010a1b2:	55                   	push   %ebp
f010a1b3:	89 e5                	mov    %esp,%ebp
f010a1b5:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f010a1b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a1bb:	c1 e8 16             	shr    $0x16,%eax
f010a1be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a1c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c8:	01 d0                	add    %edx,%eax
f010a1ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010a1d0:	0f 20 d8             	mov    %cr3,%eax
f010a1d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010a1d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a1d9:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010a1dc:	90                   	nop
f010a1dd:	c9                   	leave  
f010a1de:	c3                   	ret    

f010a1df <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f010a1df:	55                   	push   %ebp
f010a1e0:	89 e5                	mov    %esp,%ebp
f010a1e2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f010a1e5:	83 ec 0c             	sub    $0xc,%esp
f010a1e8:	6a 18                	push   $0x18
f010a1ea:	e8 e0 f5 ff ff       	call   f01097cf <kmalloc>
f010a1ef:	83 c4 10             	add    $0x10,%esp
f010a1f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f010a1f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a1f9:	75 14                	jne    f010a20f <env_page_ws_list_create_element+0x30>
f010a1fb:	83 ec 04             	sub    $0x4,%esp
f010a1fe:	68 64 63 12 f0       	push   $0xf0126364
f010a203:	6a 19                	push   $0x19
f010a205:	68 94 63 12 f0       	push   $0xf0126394
f010a20a:	e8 2a 61 ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f010a20f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a212:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f010a215:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a218:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a21b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a21e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a223:	89 c2                	mov    %eax,%edx
f010a225:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a228:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f010a22a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a22d:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f010a231:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a234:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f010a23b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a23e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f010a245:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f010a248:	c9                   	leave  
f010a249:	c3                   	ret    

f010a24a <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a24a:	55                   	push   %ebp
f010a24b:	89 e5                	mov    %esp,%ebp
f010a24d:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a250:	83 ec 0c             	sub    $0xc,%esp
f010a253:	6a 02                	push   $0x2
f010a255:	e8 d9 57 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010a25a:	83 c4 10             	add    $0x10,%esp
f010a25d:	85 c0                	test   %eax,%eax
f010a25f:	0f 84 e5 03 00 00    	je     f010a64a <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010a265:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010a26c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a273:	8b 45 08             	mov    0x8(%ebp),%eax
f010a276:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a27c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a27f:	e9 3b 02 00 00       	jmp    f010a4bf <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a284:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a287:	8b 00                	mov    (%eax),%eax
f010a289:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a28c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a28f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a294:	89 c2                	mov    %eax,%edx
f010a296:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a299:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010a29c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a29f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a2a4:	39 c2                	cmp    %eax,%edx
f010a2a6:	0f 85 07 02 00 00    	jne    f010a4b3 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f010a2ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2af:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a2b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a2b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2bb:	8b 10                	mov    (%eax),%edx
f010a2bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2c0:	8b 40 64             	mov    0x64(%eax),%eax
f010a2c3:	83 ec 08             	sub    $0x8,%esp
f010a2c6:	52                   	push   %edx
f010a2c7:	50                   	push   %eax
f010a2c8:	e8 3d e8 ff ff       	call   f0108b0a <unmap_frame>
f010a2cd:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a2d0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a2d4:	75 14                	jne    f010a2ea <env_page_ws_invalidate+0xa0>
f010a2d6:	83 ec 04             	sub    $0x4,%esp
f010a2d9:	68 b3 63 12 f0       	push   $0xf01263b3
f010a2de:	6a 2f                	push   $0x2f
f010a2e0:	68 94 63 12 f0       	push   $0xf0126394
f010a2e5:	e8 4f 60 ff ff       	call   f0100339 <_panic>
f010a2ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2ed:	8b 40 10             	mov    0x10(%eax),%eax
f010a2f0:	85 c0                	test   %eax,%eax
f010a2f2:	74 11                	je     f010a305 <env_page_ws_invalidate+0xbb>
f010a2f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2f7:	8b 40 10             	mov    0x10(%eax),%eax
f010a2fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2fd:	8b 52 14             	mov    0x14(%edx),%edx
f010a300:	89 50 14             	mov    %edx,0x14(%eax)
f010a303:	eb 0f                	jmp    f010a314 <env_page_ws_invalidate+0xca>
f010a305:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a308:	8b 50 14             	mov    0x14(%eax),%edx
f010a30b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a30e:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a314:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a317:	8b 40 14             	mov    0x14(%eax),%eax
f010a31a:	85 c0                	test   %eax,%eax
f010a31c:	74 11                	je     f010a32f <env_page_ws_invalidate+0xe5>
f010a31e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a321:	8b 40 14             	mov    0x14(%eax),%eax
f010a324:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a327:	8b 52 10             	mov    0x10(%edx),%edx
f010a32a:	89 50 10             	mov    %edx,0x10(%eax)
f010a32d:	eb 0f                	jmp    f010a33e <env_page_ws_invalidate+0xf4>
f010a32f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a332:	8b 50 10             	mov    0x10(%eax),%edx
f010a335:	8b 45 08             	mov    0x8(%ebp),%eax
f010a338:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a33e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a341:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a348:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a34b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a352:	8b 45 08             	mov    0x8(%ebp),%eax
f010a355:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a35b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a35e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a361:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a367:	83 ec 0c             	sub    $0xc,%esp
f010a36a:	ff 75 f0             	pushl  -0x10(%ebp)
f010a36d:	e8 1d f7 ff ff       	call   f0109a8f <kfree>
f010a372:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a375:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a379:	0f 84 2b 01 00 00    	je     f010a4aa <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a37f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a383:	75 14                	jne    f010a399 <env_page_ws_invalidate+0x14f>
f010a385:	83 ec 04             	sub    $0x4,%esp
f010a388:	68 b3 63 12 f0       	push   $0xf01263b3
f010a38d:	6a 35                	push   $0x35
f010a38f:	68 94 63 12 f0       	push   $0xf0126394
f010a394:	e8 a0 5f ff ff       	call   f0100339 <_panic>
f010a399:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a39c:	8b 40 10             	mov    0x10(%eax),%eax
f010a39f:	85 c0                	test   %eax,%eax
f010a3a1:	74 11                	je     f010a3b4 <env_page_ws_invalidate+0x16a>
f010a3a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3a6:	8b 40 10             	mov    0x10(%eax),%eax
f010a3a9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3ac:	8b 52 14             	mov    0x14(%edx),%edx
f010a3af:	89 50 14             	mov    %edx,0x14(%eax)
f010a3b2:	eb 0f                	jmp    f010a3c3 <env_page_ws_invalidate+0x179>
f010a3b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3b7:	8b 50 14             	mov    0x14(%eax),%edx
f010a3ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3bd:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a3c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3c6:	8b 40 14             	mov    0x14(%eax),%eax
f010a3c9:	85 c0                	test   %eax,%eax
f010a3cb:	74 11                	je     f010a3de <env_page_ws_invalidate+0x194>
f010a3cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3d0:	8b 40 14             	mov    0x14(%eax),%eax
f010a3d3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a3d6:	8b 52 10             	mov    0x10(%edx),%edx
f010a3d9:	89 50 10             	mov    %edx,0x10(%eax)
f010a3dc:	eb 0f                	jmp    f010a3ed <env_page_ws_invalidate+0x1a3>
f010a3de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3e1:	8b 50 10             	mov    0x10(%eax),%edx
f010a3e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3e7:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a3ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3f0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a3f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a3fa:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a401:	8b 45 08             	mov    0x8(%ebp),%eax
f010a404:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a40a:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a40d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a410:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a416:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a41a:	75 14                	jne    f010a430 <env_page_ws_invalidate+0x1e6>
f010a41c:	83 ec 04             	sub    $0x4,%esp
f010a41f:	68 d4 63 12 f0       	push   $0xf01263d4
f010a424:	6a 36                	push   $0x36
f010a426:	68 94 63 12 f0       	push   $0xf0126394
f010a42b:	e8 09 5f ff ff       	call   f0100339 <_panic>
f010a430:	8b 45 08             	mov    0x8(%ebp),%eax
f010a433:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a439:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a43c:	89 50 14             	mov    %edx,0x14(%eax)
f010a43f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a442:	8b 40 14             	mov    0x14(%eax),%eax
f010a445:	85 c0                	test   %eax,%eax
f010a447:	74 11                	je     f010a45a <env_page_ws_invalidate+0x210>
f010a449:	8b 45 08             	mov    0x8(%ebp),%eax
f010a44c:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a452:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a455:	89 50 10             	mov    %edx,0x10(%eax)
f010a458:	eb 0c                	jmp    f010a466 <env_page_ws_invalidate+0x21c>
f010a45a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a45d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a460:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a466:	8b 45 08             	mov    0x8(%ebp),%eax
f010a469:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a46c:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a472:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a475:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a47c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a47f:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a485:	8d 50 01             	lea    0x1(%eax),%edx
f010a488:	8b 45 08             	mov    0x8(%ebp),%eax
f010a48b:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a491:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a494:	8b 10                	mov    (%eax),%edx
f010a496:	8b 45 08             	mov    0x8(%ebp),%eax
f010a499:	8b 40 64             	mov    0x64(%eax),%eax
f010a49c:	6a 00                	push   $0x0
f010a49e:	6a 01                	push   $0x1
f010a4a0:	52                   	push   %edx
f010a4a1:	50                   	push   %eax
f010a4a2:	e8 02 fb ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010a4a7:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a4aa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a4b1:	eb 43                	jmp    f010a4f6 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a4b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4b6:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a4bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a4bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4c3:	74 08                	je     f010a4cd <env_page_ws_invalidate+0x283>
f010a4c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4c8:	8b 40 10             	mov    0x10(%eax),%eax
f010a4cb:	eb 05                	jmp    f010a4d2 <env_page_ws_invalidate+0x288>
f010a4cd:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4d2:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4d5:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a4db:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4de:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a4e4:	85 c0                	test   %eax,%eax
f010a4e6:	0f 85 98 fd ff ff    	jne    f010a284 <env_page_ws_invalidate+0x3a>
f010a4ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a4f0:	0f 85 8e fd ff ff    	jne    f010a284 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a4f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a4fa:	0f 85 a4 02 00 00    	jne    f010a7a4 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a500:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a507:	8b 45 08             	mov    0x8(%ebp),%eax
f010a50a:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a510:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a513:	e9 f6 00 00 00       	jmp    f010a60e <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a518:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a51b:	8b 00                	mov    (%eax),%eax
f010a51d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a520:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a523:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a528:	89 c2                	mov    %eax,%edx
f010a52a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a52d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a530:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a533:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a538:	39 c2                	cmp    %eax,%edx
f010a53a:	0f 85 c2 00 00 00    	jne    f010a602 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a540:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a543:	8b 10                	mov    (%eax),%edx
f010a545:	8b 45 08             	mov    0x8(%ebp),%eax
f010a548:	8b 40 64             	mov    0x64(%eax),%eax
f010a54b:	83 ec 08             	sub    $0x8,%esp
f010a54e:	52                   	push   %edx
f010a54f:	50                   	push   %eax
f010a550:	e8 b5 e5 ff ff       	call   f0108b0a <unmap_frame>
f010a555:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a558:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a55c:	75 14                	jne    f010a572 <env_page_ws_invalidate+0x328>
f010a55e:	83 ec 04             	sub    $0x4,%esp
f010a561:	68 b3 63 12 f0       	push   $0xf01263b3
f010a566:	6a 46                	push   $0x46
f010a568:	68 94 63 12 f0       	push   $0xf0126394
f010a56d:	e8 c7 5d ff ff       	call   f0100339 <_panic>
f010a572:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a575:	8b 40 10             	mov    0x10(%eax),%eax
f010a578:	85 c0                	test   %eax,%eax
f010a57a:	74 11                	je     f010a58d <env_page_ws_invalidate+0x343>
f010a57c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a57f:	8b 40 10             	mov    0x10(%eax),%eax
f010a582:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a585:	8b 52 14             	mov    0x14(%edx),%edx
f010a588:	89 50 14             	mov    %edx,0x14(%eax)
f010a58b:	eb 0f                	jmp    f010a59c <env_page_ws_invalidate+0x352>
f010a58d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a590:	8b 50 14             	mov    0x14(%eax),%edx
f010a593:	8b 45 08             	mov    0x8(%ebp),%eax
f010a596:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a59c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a59f:	8b 40 14             	mov    0x14(%eax),%eax
f010a5a2:	85 c0                	test   %eax,%eax
f010a5a4:	74 11                	je     f010a5b7 <env_page_ws_invalidate+0x36d>
f010a5a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5a9:	8b 40 14             	mov    0x14(%eax),%eax
f010a5ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a5af:	8b 52 10             	mov    0x10(%edx),%edx
f010a5b2:	89 50 10             	mov    %edx,0x10(%eax)
f010a5b5:	eb 0f                	jmp    f010a5c6 <env_page_ws_invalidate+0x37c>
f010a5b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5ba:	8b 50 10             	mov    0x10(%eax),%edx
f010a5bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5c0:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a5c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5c9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a5d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5d3:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a5da:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5dd:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a5e3:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a5e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e9:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f010a5ef:	83 ec 0c             	sub    $0xc,%esp
f010a5f2:	ff 75 f0             	pushl  -0x10(%ebp)
f010a5f5:	e8 95 f4 ff ff       	call   f0109a8f <kfree>
f010a5fa:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a5fd:	e9 a2 01 00 00       	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a602:	8b 45 08             	mov    0x8(%ebp),%eax
f010a605:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a60b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a60e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a612:	74 08                	je     f010a61c <env_page_ws_invalidate+0x3d2>
f010a614:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a617:	8b 40 10             	mov    0x10(%eax),%eax
f010a61a:	eb 05                	jmp    f010a621 <env_page_ws_invalidate+0x3d7>
f010a61c:	b8 00 00 00 00       	mov    $0x0,%eax
f010a621:	8b 55 08             	mov    0x8(%ebp),%edx
f010a624:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a62a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a62d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a633:	85 c0                	test   %eax,%eax
f010a635:	0f 85 dd fe ff ff    	jne    f010a518 <env_page_ws_invalidate+0x2ce>
f010a63b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a63f:	0f 85 d3 fe ff ff    	jne    f010a518 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a645:	e9 5a 01 00 00       	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a64a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a64d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a653:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a656:	e9 10 01 00 00       	jmp    f010a76b <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a65b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a65e:	8b 00                	mov    (%eax),%eax
f010a660:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a663:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a666:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a66b:	89 c2                	mov    %eax,%edx
f010a66d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a670:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a673:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a676:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a67b:	39 c2                	cmp    %eax,%edx
f010a67d:	0f 85 dc 00 00 00    	jne    f010a75f <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a683:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a686:	8b 10                	mov    (%eax),%edx
f010a688:	8b 45 08             	mov    0x8(%ebp),%eax
f010a68b:	8b 40 64             	mov    0x64(%eax),%eax
f010a68e:	83 ec 08             	sub    $0x8,%esp
f010a691:	52                   	push   %edx
f010a692:	50                   	push   %eax
f010a693:	e8 72 e4 ff ff       	call   f0108b0a <unmap_frame>
f010a698:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a69b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a69e:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a6a4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a6a7:	75 0f                	jne    f010a6b8 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a6a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6ac:	8b 50 10             	mov    0x10(%eax),%edx
f010a6af:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6b2:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a6b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a6bc:	75 14                	jne    f010a6d2 <env_page_ws_invalidate+0x488>
f010a6be:	83 ec 04             	sub    $0x4,%esp
f010a6c1:	68 b3 63 12 f0       	push   $0xf01263b3
f010a6c6:	6a 5c                	push   $0x5c
f010a6c8:	68 94 63 12 f0       	push   $0xf0126394
f010a6cd:	e8 67 5c ff ff       	call   f0100339 <_panic>
f010a6d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6d5:	8b 40 10             	mov    0x10(%eax),%eax
f010a6d8:	85 c0                	test   %eax,%eax
f010a6da:	74 11                	je     f010a6ed <env_page_ws_invalidate+0x4a3>
f010a6dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6df:	8b 40 10             	mov    0x10(%eax),%eax
f010a6e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a6e5:	8b 52 14             	mov    0x14(%edx),%edx
f010a6e8:	89 50 14             	mov    %edx,0x14(%eax)
f010a6eb:	eb 0f                	jmp    f010a6fc <env_page_ws_invalidate+0x4b2>
f010a6ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6f0:	8b 50 14             	mov    0x14(%eax),%edx
f010a6f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6f6:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a6fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a6ff:	8b 40 14             	mov    0x14(%eax),%eax
f010a702:	85 c0                	test   %eax,%eax
f010a704:	74 11                	je     f010a717 <env_page_ws_invalidate+0x4cd>
f010a706:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a709:	8b 40 14             	mov    0x14(%eax),%eax
f010a70c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a70f:	8b 52 10             	mov    0x10(%edx),%edx
f010a712:	89 50 10             	mov    %edx,0x10(%eax)
f010a715:	eb 0f                	jmp    f010a726 <env_page_ws_invalidate+0x4dc>
f010a717:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a71a:	8b 50 10             	mov    0x10(%eax),%edx
f010a71d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a720:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a726:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a729:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a730:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a733:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a73a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a73d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a743:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a746:	8b 45 08             	mov    0x8(%ebp),%eax
f010a749:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a74f:	83 ec 0c             	sub    $0xc,%esp
f010a752:	ff 75 ec             	pushl  -0x14(%ebp)
f010a755:	e8 35 f3 ff ff       	call   f0109a8f <kfree>
f010a75a:	83 c4 10             	add    $0x10,%esp

				break;
f010a75d:	eb 45                	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a75f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a762:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a768:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a76b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a76f:	74 08                	je     f010a779 <env_page_ws_invalidate+0x52f>
f010a771:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a774:	8b 40 10             	mov    0x10(%eax),%eax
f010a777:	eb 05                	jmp    f010a77e <env_page_ws_invalidate+0x534>
f010a779:	b8 00 00 00 00       	mov    $0x0,%eax
f010a77e:	8b 55 08             	mov    0x8(%ebp),%edx
f010a781:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a787:	8b 45 08             	mov    0x8(%ebp),%eax
f010a78a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a790:	85 c0                	test   %eax,%eax
f010a792:	0f 85 c3 fe ff ff    	jne    f010a65b <env_page_ws_invalidate+0x411>
f010a798:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a79c:	0f 85 b9 fe ff ff    	jne    f010a65b <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a7a2:	eb 00                	jmp    f010a7a4 <env_page_ws_invalidate+0x55a>
f010a7a4:	90                   	nop
f010a7a5:	c9                   	leave  
f010a7a6:	c3                   	ret    

f010a7a7 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a7a7:	55                   	push   %ebp
f010a7a8:	89 e5                	mov    %esp,%ebp
f010a7aa:	53                   	push   %ebx
f010a7ab:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a7ae:	83 ec 0c             	sub    $0xc,%esp
f010a7b1:	6a 02                	push   $0x2
f010a7b3:	e8 7b 52 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010a7b8:	83 c4 10             	add    $0x10,%esp
f010a7bb:	85 c0                	test   %eax,%eax
f010a7bd:	0f 84 fe 00 00 00    	je     f010a8c1 <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a7c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a7ca:	83 ec 0c             	sub    $0xc,%esp
f010a7cd:	68 f7 63 12 f0       	push   $0xf01263f7
f010a7d2:	e8 b4 67 ff ff       	call   f0100f8b <cprintf>
f010a7d7:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a7da:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7dd:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a7e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a7e6:	eb 2c                	jmp    f010a814 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a7e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a7eb:	8b 10                	mov    (%eax),%edx
f010a7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7f0:	8d 48 01             	lea    0x1(%eax),%ecx
f010a7f3:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a7f6:	83 ec 04             	sub    $0x4,%esp
f010a7f9:	52                   	push   %edx
f010a7fa:	50                   	push   %eax
f010a7fb:	68 11 64 12 f0       	push   $0xf0126411
f010a800:	e8 86 67 ff ff       	call   f0100f8b <cprintf>
f010a805:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a808:	8b 45 08             	mov    0x8(%ebp),%eax
f010a80b:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a811:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a814:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a818:	74 08                	je     f010a822 <env_page_ws_print+0x7b>
f010a81a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a81d:	8b 40 10             	mov    0x10(%eax),%eax
f010a820:	eb 05                	jmp    f010a827 <env_page_ws_print+0x80>
f010a822:	b8 00 00 00 00       	mov    $0x0,%eax
f010a827:	8b 55 08             	mov    0x8(%ebp),%edx
f010a82a:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a830:	8b 45 08             	mov    0x8(%ebp),%eax
f010a833:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a839:	85 c0                	test   %eax,%eax
f010a83b:	75 ab                	jne    f010a7e8 <env_page_ws_print+0x41>
f010a83d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a841:	75 a5                	jne    f010a7e8 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a843:	83 ec 0c             	sub    $0xc,%esp
f010a846:	68 19 64 12 f0       	push   $0xf0126419
f010a84b:	e8 3b 67 ff ff       	call   f0100f8b <cprintf>
f010a850:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a853:	8b 45 08             	mov    0x8(%ebp),%eax
f010a856:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a85c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a85f:	eb 2c                	jmp    f010a88d <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a861:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a864:	8b 10                	mov    (%eax),%edx
f010a866:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a869:	8d 48 01             	lea    0x1(%eax),%ecx
f010a86c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a86f:	83 ec 04             	sub    $0x4,%esp
f010a872:	52                   	push   %edx
f010a873:	50                   	push   %eax
f010a874:	68 11 64 12 f0       	push   $0xf0126411
f010a879:	e8 0d 67 ff ff       	call   f0100f8b <cprintf>
f010a87e:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a881:	8b 45 08             	mov    0x8(%ebp),%eax
f010a884:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a88a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a88d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a891:	74 08                	je     f010a89b <env_page_ws_print+0xf4>
f010a893:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a896:	8b 40 10             	mov    0x10(%eax),%eax
f010a899:	eb 05                	jmp    f010a8a0 <env_page_ws_print+0xf9>
f010a89b:	b8 00 00 00 00       	mov    $0x0,%eax
f010a8a0:	8b 55 08             	mov    0x8(%ebp),%edx
f010a8a3:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a8a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8ac:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a8b2:	85 c0                	test   %eax,%eax
f010a8b4:	75 ab                	jne    f010a861 <env_page_ws_print+0xba>
f010a8b6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a8ba:	75 a5                	jne    f010a861 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a8bc:	e9 5a 01 00 00       	jmp    f010aa1b <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a8c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a8c8:	83 ec 0c             	sub    $0xc,%esp
f010a8cb:	68 34 64 12 f0       	push   $0xf0126434
f010a8d0:	e8 b6 66 ff ff       	call   f0100f8b <cprintf>
f010a8d5:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a8d8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a8df:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8e2:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a8e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a8eb:	e9 d1 00 00 00       	jmp    f010a9c1 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a8f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a8f3:	8b 00                	mov    (%eax),%eax
f010a8f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a8f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a8fb:	8b 40 08             	mov    0x8(%eax),%eax
f010a8fe:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a901:	8b 45 08             	mov    0x8(%ebp),%eax
f010a904:	8b 40 64             	mov    0x64(%eax),%eax
f010a907:	83 ec 08             	sub    $0x8,%esp
f010a90a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a90d:	50                   	push   %eax
f010a90e:	e8 5a f7 ff ff       	call   f010a06d <pt_get_page_permissions>
f010a913:	83 c4 10             	add    $0x10,%esp
f010a916:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a919:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a91c:	83 e0 40             	and    $0x40,%eax
f010a91f:	85 c0                	test   %eax,%eax
f010a921:	0f 95 c0             	setne  %al
f010a924:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a927:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a92a:	83 e0 20             	and    $0x20,%eax
f010a92d:	85 c0                	test   %eax,%eax
f010a92f:	0f 95 c0             	setne  %al
f010a932:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a935:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a938:	25 00 02 00 00       	and    $0x200,%eax
f010a93d:	85 c0                	test   %eax,%eax
f010a93f:	0f 95 c0             	setne  %al
f010a942:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a945:	83 ec 04             	sub    $0x4,%esp
f010a948:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a94b:	ff 75 ec             	pushl  -0x14(%ebp)
f010a94e:	68 3e 64 12 f0       	push   $0xf012643e
f010a953:	e8 33 66 ff ff       	call   f0100f8b <cprintf>
f010a958:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a95b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a95e:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a961:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a965:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a969:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a96d:	83 ec 08             	sub    $0x8,%esp
f010a970:	53                   	push   %ebx
f010a971:	ff 75 e0             	pushl  -0x20(%ebp)
f010a974:	51                   	push   %ecx
f010a975:	52                   	push   %edx
f010a976:	50                   	push   %eax
f010a977:	68 48 64 12 f0       	push   $0xf0126448
f010a97c:	e8 0a 66 ff ff       	call   f0100f8b <cprintf>
f010a981:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a984:	8b 45 08             	mov    0x8(%ebp),%eax
f010a987:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a98d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a990:	75 10                	jne    f010a9a2 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a992:	83 ec 0c             	sub    $0xc,%esp
f010a995:	68 8f 64 12 f0       	push   $0xf012648f
f010a99a:	e8 ec 65 ff ff       	call   f0100f8b <cprintf>
f010a99f:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a9a2:	83 ec 0c             	sub    $0xc,%esp
f010a9a5:	68 94 64 12 f0       	push   $0xf0126494
f010a9aa:	e8 dc 65 ff ff       	call   f0100f8b <cprintf>
f010a9af:	83 c4 10             	add    $0x10,%esp
			i++;
f010a9b2:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a9b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9b8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a9be:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a9c1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a9c5:	74 08                	je     f010a9cf <env_page_ws_print+0x228>
f010a9c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a9ca:	8b 40 10             	mov    0x10(%eax),%eax
f010a9cd:	eb 05                	jmp    f010a9d4 <env_page_ws_print+0x22d>
f010a9cf:	b8 00 00 00 00       	mov    $0x0,%eax
f010a9d4:	8b 55 08             	mov    0x8(%ebp),%edx
f010a9d7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a9dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9e0:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a9e6:	85 c0                	test   %eax,%eax
f010a9e8:	0f 85 02 ff ff ff    	jne    f010a8f0 <env_page_ws_print+0x149>
f010a9ee:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a9f2:	0f 85 f8 fe ff ff    	jne    f010a8f0 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a9f8:	eb 13                	jmp    f010aa0d <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a9fa:	83 ec 0c             	sub    $0xc,%esp
f010a9fd:	68 96 64 12 f0       	push   $0xf0126496
f010aa02:	e8 84 65 ff ff       	call   f0100f8b <cprintf>
f010aa07:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010aa0a:	ff 45 ec             	incl   -0x14(%ebp)
f010aa0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa10:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010aa16:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010aa19:	77 df                	ja     f010a9fa <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010aa1b:	90                   	nop
f010aa1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010aa1f:	c9                   	leave  
f010aa20:	c3                   	ret    

f010aa21 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010aa21:	55                   	push   %ebp
f010aa22:	89 e5                	mov    %esp,%ebp
f010aa24:	53                   	push   %ebx
f010aa25:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010aa28:	83 ec 0c             	sub    $0xc,%esp
f010aa2b:	68 a8 64 12 f0       	push   $0xf01264a8
f010aa30:	e8 56 65 ff ff       	call   f0100f8b <cprintf>
f010aa35:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010aa38:	83 ec 0c             	sub    $0xc,%esp
f010aa3b:	68 dd 64 12 f0       	push   $0xf01264dd
f010aa40:	e8 46 65 ff ff       	call   f0100f8b <cprintf>
f010aa45:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010aa48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010aa4f:	e9 16 01 00 00       	jmp    f010ab6a <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010aa54:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa57:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa5a:	89 d0                	mov    %edx,%eax
f010aa5c:	01 c0                	add    %eax,%eax
f010aa5e:	01 d0                	add    %edx,%eax
f010aa60:	c1 e0 03             	shl    $0x3,%eax
f010aa63:	01 c8                	add    %ecx,%eax
f010aa65:	05 b0 00 00 00       	add    $0xb0,%eax
f010aa6a:	8a 00                	mov    (%eax),%al
f010aa6c:	84 c0                	test   %al,%al
f010aa6e:	74 43                	je     f010aab3 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010aa70:	83 ec 0c             	sub    $0xc,%esp
f010aa73:	68 e8 64 12 f0       	push   $0xf01264e8
f010aa78:	e8 0e 65 ff ff       	call   f0100f8b <cprintf>
f010aa7d:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010aa80:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa83:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010aa89:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010aa8c:	75 10                	jne    f010aa9e <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010aa8e:	83 ec 0c             	sub    $0xc,%esp
f010aa91:	68 f7 64 12 f0       	push   $0xf01264f7
f010aa96:	e8 f0 64 ff ff       	call   f0100f8b <cprintf>
f010aa9b:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010aa9e:	83 ec 0c             	sub    $0xc,%esp
f010aaa1:	68 94 64 12 f0       	push   $0xf0126494
f010aaa6:	e8 e0 64 ff ff       	call   f0100f8b <cprintf>
f010aaab:	83 c4 10             	add    $0x10,%esp
			continue;
f010aaae:	e9 b4 00 00 00       	jmp    f010ab67 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010aab3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aab6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aab9:	89 d0                	mov    %edx,%eax
f010aabb:	01 c0                	add    %eax,%eax
f010aabd:	01 d0                	add    %edx,%eax
f010aabf:	c1 e0 03             	shl    $0x3,%eax
f010aac2:	01 c8                	add    %ecx,%eax
f010aac4:	05 ac 00 00 00       	add    $0xac,%eax
f010aac9:	8b 00                	mov    (%eax),%eax
f010aacb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010aace:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aad1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aad4:	89 d0                	mov    %edx,%eax
f010aad6:	01 c0                	add    %eax,%eax
f010aad8:	01 d0                	add    %edx,%eax
f010aada:	c1 e0 03             	shl    $0x3,%eax
f010aadd:	01 c8                	add    %ecx,%eax
f010aadf:	05 ac 00 00 00       	add    $0xac,%eax
f010aae4:	8b 00                	mov    (%eax),%eax
f010aae6:	83 ec 04             	sub    $0x4,%esp
f010aae9:	50                   	push   %eax
f010aaea:	ff 75 f4             	pushl  -0xc(%ebp)
f010aaed:	68 fd 64 12 f0       	push   $0xf01264fd
f010aaf2:	e8 94 64 ff ff       	call   f0100f8b <cprintf>
f010aaf7:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010aafa:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aafd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ab00:	89 d0                	mov    %edx,%eax
f010ab02:	01 c0                	add    %eax,%eax
f010ab04:	01 d0                	add    %edx,%eax
f010ab06:	c1 e0 03             	shl    $0x3,%eax
f010ab09:	01 c8                	add    %ecx,%eax
f010ab0b:	05 b4 00 00 00       	add    $0xb4,%eax
f010ab10:	8b 18                	mov    (%eax),%ebx
f010ab12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab15:	8b 40 64             	mov    0x64(%eax),%eax
f010ab18:	83 ec 08             	sub    $0x8,%esp
f010ab1b:	ff 75 f0             	pushl  -0x10(%ebp)
f010ab1e:	50                   	push   %eax
f010ab1f:	e8 25 f6 ff ff       	call   f010a149 <pd_is_table_used>
f010ab24:	83 c4 10             	add    $0x10,%esp
f010ab27:	83 ec 04             	sub    $0x4,%esp
f010ab2a:	53                   	push   %ebx
f010ab2b:	50                   	push   %eax
f010ab2c:	68 14 65 12 f0       	push   $0xf0126514
f010ab31:	e8 55 64 ff ff       	call   f0100f8b <cprintf>
f010ab36:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010ab39:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab3c:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010ab42:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ab45:	75 10                	jne    f010ab57 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010ab47:	83 ec 0c             	sub    $0xc,%esp
f010ab4a:	68 8f 64 12 f0       	push   $0xf012648f
f010ab4f:	e8 37 64 ff ff       	call   f0100f8b <cprintf>
f010ab54:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010ab57:	83 ec 0c             	sub    $0xc,%esp
f010ab5a:	68 94 64 12 f0       	push   $0xf0126494
f010ab5f:	e8 27 64 ff ff       	call   f0100f8b <cprintf>
f010ab64:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010ab67:	ff 45 f4             	incl   -0xc(%ebp)
f010ab6a:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ab6e:	0f 86 e0 fe ff ff    	jbe    f010aa54 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010ab74:	90                   	nop
f010ab75:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ab78:	c9                   	leave  
f010ab79:	c3                   	ret    

f010ab7a <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010ab7a:	55                   	push   %ebp
f010ab7b:	89 e5                	mov    %esp,%ebp
f010ab7d:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010ab80:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010ab87:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010ab8e:	eb 22                	jmp    f010abb2 <env_table_ws_get_size+0x38>
f010ab90:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab93:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ab96:	89 d0                	mov    %edx,%eax
f010ab98:	01 c0                	add    %eax,%eax
f010ab9a:	01 d0                	add    %edx,%eax
f010ab9c:	c1 e0 03             	shl    $0x3,%eax
f010ab9f:	01 c8                	add    %ecx,%eax
f010aba1:	05 b0 00 00 00       	add    $0xb0,%eax
f010aba6:	8a 00                	mov    (%eax),%al
f010aba8:	84 c0                	test   %al,%al
f010abaa:	75 03                	jne    f010abaf <env_table_ws_get_size+0x35>
f010abac:	ff 45 f8             	incl   -0x8(%ebp)
f010abaf:	ff 45 fc             	incl   -0x4(%ebp)
f010abb2:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010abb6:	7e d8                	jle    f010ab90 <env_table_ws_get_size+0x16>
	return counter;
f010abb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010abbb:	c9                   	leave  
f010abbc:	c3                   	ret    

f010abbd <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010abbd:	55                   	push   %ebp
f010abbe:	89 e5                	mov    %esp,%ebp
f010abc0:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010abc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010abca:	eb 4e                	jmp    f010ac1a <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010abcc:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abcf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010abd2:	89 d0                	mov    %edx,%eax
f010abd4:	01 c0                	add    %eax,%eax
f010abd6:	01 d0                	add    %edx,%eax
f010abd8:	c1 e0 03             	shl    $0x3,%eax
f010abdb:	01 c8                	add    %ecx,%eax
f010abdd:	05 ac 00 00 00       	add    $0xac,%eax
f010abe2:	8b 00                	mov    (%eax),%eax
f010abe4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010abe7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010abea:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010abef:	89 c2                	mov    %eax,%edx
f010abf1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010abf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010abf7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010abfa:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010abff:	39 c2                	cmp    %eax,%edx
f010ac01:	75 14                	jne    f010ac17 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010ac03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac06:	83 ec 08             	sub    $0x8,%esp
f010ac09:	50                   	push   %eax
f010ac0a:	ff 75 08             	pushl  0x8(%ebp)
f010ac0d:	e8 bc 00 00 00       	call   f010acce <env_table_ws_clear_entry>
f010ac12:	83 c4 10             	add    $0x10,%esp
			break;
f010ac15:	eb 09                	jmp    f010ac20 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010ac17:	ff 45 f4             	incl   -0xc(%ebp)
f010ac1a:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ac1e:	7e ac                	jle    f010abcc <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010ac20:	90                   	nop
f010ac21:	c9                   	leave  
f010ac22:	c3                   	ret    

f010ac23 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010ac23:	55                   	push   %ebp
f010ac24:	89 e5                	mov    %esp,%ebp
f010ac26:	53                   	push   %ebx
f010ac27:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ac2a:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ac2e:	76 19                	jbe    f010ac49 <env_table_ws_set_entry+0x26>
f010ac30:	68 38 65 12 f0       	push   $0xf0126538
f010ac35:	68 69 65 12 f0       	push   $0xf0126569
f010ac3a:	68 3f 01 00 00       	push   $0x13f
f010ac3f:	68 94 63 12 f0       	push   $0xf0126394
f010ac44:	e8 f0 56 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010ac49:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010ac50:	76 19                	jbe    f010ac6b <env_table_ws_set_entry+0x48>
f010ac52:	68 80 65 12 f0       	push   $0xf0126580
f010ac57:	68 69 65 12 f0       	push   $0xf0126569
f010ac5c:	68 40 01 00 00       	push   $0x140
f010ac61:	68 94 63 12 f0       	push   $0xf0126394
f010ac66:	e8 ce 56 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010ac6b:	8b 45 10             	mov    0x10(%ebp),%eax
f010ac6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ac71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac74:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010ac79:	89 c1                	mov    %eax,%ecx
f010ac7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ac7e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac81:	89 d0                	mov    %edx,%eax
f010ac83:	01 c0                	add    %eax,%eax
f010ac85:	01 d0                	add    %edx,%eax
f010ac87:	c1 e0 03             	shl    $0x3,%eax
f010ac8a:	01 d8                	add    %ebx,%eax
f010ac8c:	05 ac 00 00 00       	add    $0xac,%eax
f010ac91:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010ac93:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac96:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac99:	89 d0                	mov    %edx,%eax
f010ac9b:	01 c0                	add    %eax,%eax
f010ac9d:	01 d0                	add    %edx,%eax
f010ac9f:	c1 e0 03             	shl    $0x3,%eax
f010aca2:	01 c8                	add    %ecx,%eax
f010aca4:	05 b0 00 00 00       	add    $0xb0,%eax
f010aca9:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010acac:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010acaf:	8b 55 0c             	mov    0xc(%ebp),%edx
f010acb2:	89 d0                	mov    %edx,%eax
f010acb4:	01 c0                	add    %eax,%eax
f010acb6:	01 d0                	add    %edx,%eax
f010acb8:	c1 e0 03             	shl    $0x3,%eax
f010acbb:	01 c8                	add    %ecx,%eax
f010acbd:	05 b4 00 00 00       	add    $0xb4,%eax
f010acc2:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010acc8:	90                   	nop
}
f010acc9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010accc:	c9                   	leave  
f010accd:	c3                   	ret    

f010acce <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010acce:	55                   	push   %ebp
f010accf:	89 e5                	mov    %esp,%ebp
f010acd1:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010acd4:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010acd8:	76 19                	jbe    f010acf3 <env_table_ws_clear_entry+0x25>
f010acda:	68 38 65 12 f0       	push   $0xf0126538
f010acdf:	68 69 65 12 f0       	push   $0xf0126569
f010ace4:	68 4b 01 00 00       	push   $0x14b
f010ace9:	68 94 63 12 f0       	push   $0xf0126394
f010acee:	e8 46 56 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010acf3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010acf6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010acf9:	89 d0                	mov    %edx,%eax
f010acfb:	01 c0                	add    %eax,%eax
f010acfd:	01 d0                	add    %edx,%eax
f010acff:	c1 e0 03             	shl    $0x3,%eax
f010ad02:	01 c8                	add    %ecx,%eax
f010ad04:	05 ac 00 00 00       	add    $0xac,%eax
f010ad09:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010ad0f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad12:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad15:	89 d0                	mov    %edx,%eax
f010ad17:	01 c0                	add    %eax,%eax
f010ad19:	01 d0                	add    %edx,%eax
f010ad1b:	c1 e0 03             	shl    $0x3,%eax
f010ad1e:	01 c8                	add    %ecx,%eax
f010ad20:	05 b0 00 00 00       	add    $0xb0,%eax
f010ad25:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010ad28:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad2b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad2e:	89 d0                	mov    %edx,%eax
f010ad30:	01 c0                	add    %eax,%eax
f010ad32:	01 d0                	add    %edx,%eax
f010ad34:	c1 e0 03             	shl    $0x3,%eax
f010ad37:	01 c8                	add    %ecx,%eax
f010ad39:	05 b4 00 00 00       	add    $0xb4,%eax
f010ad3e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010ad44:	90                   	nop
f010ad45:	c9                   	leave  
f010ad46:	c3                   	ret    

f010ad47 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010ad47:	55                   	push   %ebp
f010ad48:	89 e5                	mov    %esp,%ebp
f010ad4a:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ad4d:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ad51:	76 19                	jbe    f010ad6c <env_table_ws_get_virtual_address+0x25>
f010ad53:	68 38 65 12 f0       	push   $0xf0126538
f010ad58:	68 69 65 12 f0       	push   $0xf0126569
f010ad5d:	68 53 01 00 00       	push   $0x153
f010ad62:	68 94 63 12 f0       	push   $0xf0126394
f010ad67:	e8 cd 55 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010ad6c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad6f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ad72:	89 d0                	mov    %edx,%eax
f010ad74:	01 c0                	add    %eax,%eax
f010ad76:	01 d0                	add    %edx,%eax
f010ad78:	c1 e0 03             	shl    $0x3,%eax
f010ad7b:	01 c8                	add    %ecx,%eax
f010ad7d:	05 ac 00 00 00       	add    $0xac,%eax
f010ad82:	8b 00                	mov    (%eax),%eax
f010ad84:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ad87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad8a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010ad8f:	c9                   	leave  
f010ad90:	c3                   	ret    

f010ad91 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010ad91:	55                   	push   %ebp
f010ad92:	89 e5                	mov    %esp,%ebp
f010ad94:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ad97:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ad9b:	76 19                	jbe    f010adb6 <env_table_ws_get_time_stamp+0x25>
f010ad9d:	68 38 65 12 f0       	push   $0xf0126538
f010ada2:	68 69 65 12 f0       	push   $0xf0126569
f010ada7:	68 5a 01 00 00       	push   $0x15a
f010adac:	68 94 63 12 f0       	push   $0xf0126394
f010adb1:	e8 83 55 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010adb6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010adb9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010adbc:	89 d0                	mov    %edx,%eax
f010adbe:	01 c0                	add    %eax,%eax
f010adc0:	01 d0                	add    %edx,%eax
f010adc2:	c1 e0 03             	shl    $0x3,%eax
f010adc5:	01 c8                	add    %ecx,%eax
f010adc7:	05 b4 00 00 00       	add    $0xb4,%eax
f010adcc:	8b 00                	mov    (%eax),%eax
}
f010adce:	c9                   	leave  
f010adcf:	c3                   	ret    

f010add0 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010add0:	55                   	push   %ebp
f010add1:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010add3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010add6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010add9:	89 d0                	mov    %edx,%eax
f010addb:	01 c0                	add    %eax,%eax
f010addd:	01 d0                	add    %edx,%eax
f010addf:	c1 e0 03             	shl    $0x3,%eax
f010ade2:	01 c8                	add    %ecx,%eax
f010ade4:	05 b0 00 00 00       	add    $0xb0,%eax
f010ade9:	8a 00                	mov    (%eax),%al
f010adeb:	0f b6 c0             	movzbl %al,%eax
}
f010adee:	5d                   	pop    %ebp
f010adef:	c3                   	ret    

f010adf0 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010adf0:	55                   	push   %ebp
f010adf1:	89 e5                	mov    %esp,%ebp
f010adf3:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010adf6:	83 ec 04             	sub    $0x4,%esp
f010adf9:	68 b3 65 12 f0       	push   $0xf01265b3
f010adfe:	68 6a 01 00 00       	push   $0x16a
f010ae03:	68 94 63 12 f0       	push   $0xf0126394
f010ae08:	e8 2c 55 ff ff       	call   f0100339 <_panic>

f010ae0d <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010ae0d:	55                   	push   %ebp
f010ae0e:	89 e5                	mov    %esp,%ebp
f010ae10:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ae13:	83 ec 04             	sub    $0x4,%esp
f010ae16:	68 b3 65 12 f0       	push   $0xf01265b3
f010ae1b:	68 6f 01 00 00       	push   $0x16f
f010ae20:	68 94 63 12 f0       	push   $0xf0126394
f010ae25:	e8 0f 55 ff ff       	call   f0100339 <_panic>

f010ae2a <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ae2a:	55                   	push   %ebp
f010ae2b:	89 e5                	mov    %esp,%ebp
f010ae2d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010ae30:	83 ec 04             	sub    $0x4,%esp
f010ae33:	68 c4 65 12 f0       	push   $0xf01265c4
f010ae38:	6a 22                	push   $0x22
f010ae3a:	68 f2 65 12 f0       	push   $0xf01265f2
f010ae3f:	e8 f5 54 ff ff       	call   f0100339 <_panic>

f010ae44 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ae44:	55                   	push   %ebp
f010ae45:	89 e5                	mov    %esp,%ebp
f010ae47:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ae4a:	83 ec 04             	sub    $0x4,%esp
f010ae4d:	68 10 66 12 f0       	push   $0xf0126610
f010ae52:	6a 35                	push   $0x35
f010ae54:	68 f2 65 12 f0       	push   $0xf01265f2
f010ae59:	e8 db 54 ff ff       	call   f0100339 <_panic>

f010ae5e <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010ae5e:	55                   	push   %ebp
f010ae5f:	89 e5                	mov    %esp,%ebp
f010ae61:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010ae64:	83 ec 04             	sub    $0x4,%esp
f010ae67:	68 40 66 12 f0       	push   $0xf0126640
f010ae6c:	6a 45                	push   $0x45
f010ae6e:	68 f2 65 12 f0       	push   $0xf01265f2
f010ae73:	e8 c1 54 ff ff       	call   f0100339 <_panic>

f010ae78 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010ae78:	55                   	push   %ebp
f010ae79:	89 e5                	mov    %esp,%ebp
f010ae7b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010ae7e:	83 ec 04             	sub    $0x4,%esp
f010ae81:	68 6c 66 12 f0       	push   $0xf012666c
f010ae86:	6a 53                	push   $0x53
f010ae88:	68 f2 65 12 f0       	push   $0xf01265f2
f010ae8d:	e8 a7 54 ff ff       	call   f0100339 <_panic>

f010ae92 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010ae92:	55                   	push   %ebp
f010ae93:	89 e5                	mov    %esp,%ebp
f010ae95:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ae98:	83 ec 04             	sub    $0x4,%esp
f010ae9b:	68 9c 66 12 f0       	push   $0xf012669c
f010aea0:	6a 5d                	push   $0x5d
f010aea2:	68 f2 65 12 f0       	push   $0xf01265f2
f010aea7:	e8 8d 54 ff ff       	call   f0100339 <_panic>

f010aeac <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010aeac:	55                   	push   %ebp
f010aead:	89 e5                	mov    %esp,%ebp
f010aeaf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010aeb2:	83 ec 04             	sub    $0x4,%esp
f010aeb5:	68 d4 66 12 f0       	push   $0xf01266d4
f010aeba:	6a 6a                	push   $0x6a
f010aebc:	68 f2 65 12 f0       	push   $0xf01265f2
f010aec1:	e8 73 54 ff ff       	call   f0100339 <_panic>

f010aec6 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010aec6:	55                   	push   %ebp
f010aec7:	89 e5                	mov    %esp,%ebp
f010aec9:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010aecc:	e8 54 0e 00 00       	call   f010bd25 <get_cpu_proc>
f010aed1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010aed4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010aed8:	7e 61                	jle    f010af3b <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010aeda:	8b 45 08             	mov    0x8(%ebp),%eax
f010aedd:	c1 e0 0c             	shl    $0xc,%eax
f010aee0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010aee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aee6:	8b 40 7c             	mov    0x7c(%eax),%eax
f010aee9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010aeec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aeef:	8b 50 7c             	mov    0x7c(%eax),%edx
f010aef2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010aef5:	01 c2                	add    %eax,%edx
f010aef7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aefa:	8b 40 78             	mov    0x78(%eax),%eax
f010aefd:	39 c2                	cmp    %eax,%edx
f010aeff:	77 09                	ja     f010af0a <sys_sbrk+0x44>
f010af01:	a1 cc d2 b5 f0       	mov    0xf0b5d2cc,%eax
f010af06:	85 c0                	test   %eax,%eax
f010af08:	75 07                	jne    f010af11 <sys_sbrk+0x4b>
f010af0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010af0f:	eb 3d                	jmp    f010af4e <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010af11:	83 ec 04             	sub    $0x4,%esp
f010af14:	ff 75 f0             	pushl  -0x10(%ebp)
f010af17:	ff 75 ec             	pushl  -0x14(%ebp)
f010af1a:	ff 75 f4             	pushl  -0xc(%ebp)
f010af1d:	e8 2e 00 00 00       	call   f010af50 <allocate_user_mem>
f010af22:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010af25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af28:	8b 50 7c             	mov    0x7c(%eax),%edx
f010af2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010af2e:	01 c2                	add    %eax,%edx
f010af30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af33:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010af36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010af39:	eb 13                	jmp    f010af4e <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010af3b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010af3f:	75 08                	jne    f010af49 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010af41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af44:	8b 40 7c             	mov    0x7c(%eax),%eax
f010af47:	eb 05                	jmp    f010af4e <sys_sbrk+0x88>
	}

	return (void *)-1;
f010af49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010af4e:	c9                   	leave  
f010af4f:	c3                   	ret    

f010af50 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010af50:	55                   	push   %ebp
f010af51:	89 e5                	mov    %esp,%ebp
f010af53:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010af56:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010af5d:	8b 55 10             	mov    0x10(%ebp),%edx
f010af60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010af63:	01 d0                	add    %edx,%eax
f010af65:	48                   	dec    %eax
f010af66:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010af69:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010af6c:	ba 00 00 00 00       	mov    $0x0,%edx
f010af71:	f7 75 f0             	divl   -0x10(%ebp)
f010af74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010af77:	29 d0                	sub    %edx,%eax
f010af79:	c1 e8 0c             	shr    $0xc,%eax
f010af7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010af7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010af86:	eb 78                	jmp    f010b000 <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010af88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af8b:	c1 e0 0c             	shl    $0xc,%eax
f010af8e:	89 c2                	mov    %eax,%edx
f010af90:	8b 45 0c             	mov    0xc(%ebp),%eax
f010af93:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010af96:	8b 45 08             	mov    0x8(%ebp),%eax
f010af99:	8b 40 64             	mov    0x64(%eax),%eax
f010af9c:	83 ec 04             	sub    $0x4,%esp
f010af9f:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010afa2:	52                   	push   %edx
f010afa3:	51                   	push   %ecx
f010afa4:	50                   	push   %eax
f010afa5:	e8 70 d7 ff ff       	call   f010871a <get_page_table>
f010afaa:	83 c4 10             	add    $0x10,%esp
f010afad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010afb0:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010afb4:	75 23                	jne    f010afd9 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010afb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afb9:	c1 e0 0c             	shl    $0xc,%eax
f010afbc:	89 c2                	mov    %eax,%edx
f010afbe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010afc1:	01 c2                	add    %eax,%edx
f010afc3:	8b 45 08             	mov    0x8(%ebp),%eax
f010afc6:	8b 40 64             	mov    0x64(%eax),%eax
f010afc9:	83 ec 08             	sub    $0x8,%esp
f010afcc:	52                   	push   %edx
f010afcd:	50                   	push   %eax
f010afce:	e8 9d d8 ff ff       	call   f0108870 <create_page_table>
f010afd3:	83 c4 10             	add    $0x10,%esp
f010afd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010afd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afdc:	c1 e0 0c             	shl    $0xc,%eax
f010afdf:	89 c2                	mov    %eax,%edx
f010afe1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010afe4:	01 c2                	add    %eax,%edx
f010afe6:	8b 45 08             	mov    0x8(%ebp),%eax
f010afe9:	8b 40 64             	mov    0x64(%eax),%eax
f010afec:	6a 00                	push   $0x0
f010afee:	68 00 02 00 00       	push   $0x200
f010aff3:	52                   	push   %edx
f010aff4:	50                   	push   %eax
f010aff5:	e8 af ef ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010affa:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010affd:	ff 45 f4             	incl   -0xc(%ebp)
f010b000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b003:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010b006:	72 80                	jb     f010af88 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010b008:	90                   	nop
f010b009:	c9                   	leave  
f010b00a:	c3                   	ret    

f010b00b <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010b00b:	55                   	push   %ebp
f010b00c:	89 e5                	mov    %esp,%ebp
f010b00e:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010b011:	8b 45 10             	mov    0x10(%ebp),%eax
f010b014:	c1 e0 0c             	shl    $0xc,%eax
f010b017:	89 c2                	mov    %eax,%edx
f010b019:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b01c:	01 c2                	add    %eax,%edx
f010b01e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b021:	8b 40 64             	mov    0x64(%eax),%eax
f010b024:	68 00 02 00 00       	push   $0x200
f010b029:	6a 00                	push   $0x0
f010b02b:	52                   	push   %edx
f010b02c:	50                   	push   %eax
f010b02d:	e8 77 ef ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010b032:	83 c4 10             	add    $0x10,%esp
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
f010b035:	8b 45 10             	mov    0x10(%ebp),%eax
f010b038:	c1 e0 0c             	shl    $0xc,%eax
f010b03b:	89 c2                	mov    %eax,%edx
f010b03d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b040:	01 d0                	add    %edx,%eax
f010b042:	83 ec 08             	sub    $0x8,%esp
f010b045:	50                   	push   %eax
f010b046:	ff 75 08             	pushl  0x8(%ebp)
f010b049:	e8 81 96 ff ff       	call   f01046cf <pf_read_env_page>
f010b04e:	83 c4 10             	add    $0x10,%esp
f010b051:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
f010b054:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%ebp)
f010b058:	75 1e                	jne    f010b078 <free_user_mem+0x6d>
f010b05a:	8b 45 10             	mov    0x10(%ebp),%eax
f010b05d:	c1 e0 0c             	shl    $0xc,%eax
f010b060:	89 c2                	mov    %eax,%edx
f010b062:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b065:	01 d0                	add    %edx,%eax
f010b067:	83 ec 08             	sub    $0x8,%esp
f010b06a:	50                   	push   %eax
f010b06b:	ff 75 08             	pushl  0x8(%ebp)
f010b06e:	e8 d7 f1 ff ff       	call   f010a24a <env_page_ws_invalidate>
f010b073:	83 c4 10             	add    $0x10,%esp
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);


}
f010b076:	eb 1c                	jmp    f010b094 <free_user_mem+0x89>
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem

		pt_set_page_permissions(e->env_page_directory,(size*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
		int ret = pf_read_env_page(e,(void*)((size*PAGE_SIZE)+virtual_address));
		if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (size*PAGE_SIZE)+virtual_address);
		else pf_remove_env_page(e, (size*PAGE_SIZE)+virtual_address);
f010b078:	8b 45 10             	mov    0x10(%ebp),%eax
f010b07b:	c1 e0 0c             	shl    $0xc,%eax
f010b07e:	89 c2                	mov    %eax,%edx
f010b080:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b083:	01 d0                	add    %edx,%eax
f010b085:	83 ec 08             	sub    $0x8,%esp
f010b088:	50                   	push   %eax
f010b089:	ff 75 08             	pushl  0x8(%ebp)
f010b08c:	e8 01 97 ff ff       	call   f0104792 <pf_remove_env_page>
f010b091:	83 c4 10             	add    $0x10,%esp


}
f010b094:	90                   	nop
f010b095:	c9                   	leave  
f010b096:	c3                   	ret    

f010b097 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010b097:	55                   	push   %ebp
f010b098:	89 e5                	mov    %esp,%ebp
f010b09a:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010b09d:	83 ec 04             	sub    $0x4,%esp
f010b0a0:	68 0c 67 12 f0       	push   $0xf012670c
f010b0a5:	68 de 00 00 00       	push   $0xde
f010b0aa:	68 f2 65 12 f0       	push   $0xf01265f2
f010b0af:	e8 85 52 ff ff       	call   f0100339 <_panic>

f010b0b4 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010b0b4:	55                   	push   %ebp
f010b0b5:	89 e5                	mov    %esp,%ebp
f010b0b7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010b0ba:	83 ec 04             	sub    $0x4,%esp
f010b0bd:	68 4c 67 12 f0       	push   $0xf012674c
f010b0c2:	68 e8 00 00 00       	push   $0xe8
f010b0c7:	68 f2 65 12 f0       	push   $0xf01265f2
f010b0cc:	e8 68 52 ff ff       	call   f0100339 <_panic>

f010b0d1 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010b0d1:	55                   	push   %ebp
f010b0d2:	89 e5                	mov    %esp,%ebp
f010b0d4:	56                   	push   %esi
f010b0d5:	53                   	push   %ebx
f010b0d6:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010b0d9:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010b0e0:	e9 b0 01 00 00       	jmp    f010b295 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010b0e5:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f010b0eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b0ee:	89 d0                	mov    %edx,%eax
f010b0f0:	c1 e0 03             	shl    $0x3,%eax
f010b0f3:	01 d0                	add    %edx,%eax
f010b0f5:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b0fc:	01 d8                	add    %ebx,%eax
f010b0fe:	01 c0                	add    %eax,%eax
f010b100:	01 d0                	add    %edx,%eax
f010b102:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b109:	01 d8                	add    %ebx,%eax
f010b10b:	01 d0                	add    %edx,%eax
f010b10d:	01 c8                	add    %ecx,%eax
f010b10f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010b116:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f010b11c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b11f:	89 d0                	mov    %edx,%eax
f010b121:	c1 e0 03             	shl    $0x3,%eax
f010b124:	01 d0                	add    %edx,%eax
f010b126:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b12d:	01 d8                	add    %ebx,%eax
f010b12f:	01 c0                	add    %eax,%eax
f010b131:	01 d0                	add    %edx,%eax
f010b133:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b13a:	01 d8                	add    %ebx,%eax
f010b13c:	01 d0                	add    %edx,%eax
f010b13e:	01 c8                	add    %ecx,%eax
f010b140:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010b147:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f010b14d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b150:	89 d0                	mov    %edx,%eax
f010b152:	c1 e0 03             	shl    $0x3,%eax
f010b155:	01 d0                	add    %edx,%eax
f010b157:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b15e:	01 d8                	add    %ebx,%eax
f010b160:	01 c0                	add    %eax,%eax
f010b162:	01 d0                	add    %edx,%eax
f010b164:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b16b:	01 d8                	add    %ebx,%eax
f010b16d:	01 d0                	add    %edx,%eax
f010b16f:	01 c8                	add    %ecx,%eax
f010b171:	85 c0                	test   %eax,%eax
f010b173:	75 14                	jne    f010b189 <env_init+0xb8>
f010b175:	83 ec 04             	sub    $0x4,%esp
f010b178:	68 78 67 12 f0       	push   $0xf0126778
f010b17d:	6a 65                	push   $0x65
f010b17f:	68 9b 67 12 f0       	push   $0xf012679b
f010b184:	e8 b0 51 ff ff       	call   f0100339 <_panic>
f010b189:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f010b18f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b192:	89 d0                	mov    %edx,%eax
f010b194:	c1 e0 03             	shl    $0x3,%eax
f010b197:	01 d0                	add    %edx,%eax
f010b199:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b1a0:	01 d8                	add    %ebx,%eax
f010b1a2:	01 c0                	add    %eax,%eax
f010b1a4:	01 d0                	add    %edx,%eax
f010b1a6:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b1ad:	01 d8                	add    %ebx,%eax
f010b1af:	01 d0                	add    %edx,%eax
f010b1b1:	01 c8                	add    %ecx,%eax
f010b1b3:	8b 15 34 47 73 f0    	mov    0xf0734734,%edx
f010b1b9:	89 50 08             	mov    %edx,0x8(%eax)
f010b1bc:	8b 40 08             	mov    0x8(%eax),%eax
f010b1bf:	85 c0                	test   %eax,%eax
f010b1c1:	74 35                	je     f010b1f8 <env_init+0x127>
f010b1c3:	8b 0d 34 47 73 f0    	mov    0xf0734734,%ecx
f010b1c9:	8b 1d 30 47 73 f0    	mov    0xf0734730,%ebx
f010b1cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1d2:	89 d0                	mov    %edx,%eax
f010b1d4:	c1 e0 03             	shl    $0x3,%eax
f010b1d7:	01 d0                	add    %edx,%eax
f010b1d9:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010b1e0:	01 f0                	add    %esi,%eax
f010b1e2:	01 c0                	add    %eax,%eax
f010b1e4:	01 d0                	add    %edx,%eax
f010b1e6:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010b1ed:	01 f0                	add    %esi,%eax
f010b1ef:	01 d0                	add    %edx,%eax
f010b1f1:	01 d8                	add    %ebx,%eax
f010b1f3:	89 41 0c             	mov    %eax,0xc(%ecx)
f010b1f6:	eb 2f                	jmp    f010b227 <env_init+0x156>
f010b1f8:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f010b1fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b201:	89 d0                	mov    %edx,%eax
f010b203:	c1 e0 03             	shl    $0x3,%eax
f010b206:	01 d0                	add    %edx,%eax
f010b208:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b20f:	01 d8                	add    %ebx,%eax
f010b211:	01 c0                	add    %eax,%eax
f010b213:	01 d0                	add    %edx,%eax
f010b215:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b21c:	01 d8                	add    %ebx,%eax
f010b21e:	01 d0                	add    %edx,%eax
f010b220:	01 c8                	add    %ecx,%eax
f010b222:	a3 38 47 73 f0       	mov    %eax,0xf0734738
f010b227:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f010b22d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b230:	89 d0                	mov    %edx,%eax
f010b232:	c1 e0 03             	shl    $0x3,%eax
f010b235:	01 d0                	add    %edx,%eax
f010b237:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b23e:	01 d8                	add    %ebx,%eax
f010b240:	01 c0                	add    %eax,%eax
f010b242:	01 d0                	add    %edx,%eax
f010b244:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b24b:	01 d8                	add    %ebx,%eax
f010b24d:	01 d0                	add    %edx,%eax
f010b24f:	01 c8                	add    %ecx,%eax
f010b251:	a3 34 47 73 f0       	mov    %eax,0xf0734734
f010b256:	8b 0d 30 47 73 f0    	mov    0xf0734730,%ecx
f010b25c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b25f:	89 d0                	mov    %edx,%eax
f010b261:	c1 e0 03             	shl    $0x3,%eax
f010b264:	01 d0                	add    %edx,%eax
f010b266:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b26d:	01 d8                	add    %ebx,%eax
f010b26f:	01 c0                	add    %eax,%eax
f010b271:	01 d0                	add    %edx,%eax
f010b273:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010b27a:	01 d8                	add    %ebx,%eax
f010b27c:	01 d0                	add    %edx,%eax
f010b27e:	01 c8                	add    %ecx,%eax
f010b280:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b287:	a1 40 47 73 f0       	mov    0xf0734740,%eax
f010b28c:	40                   	inc    %eax
f010b28d:	a3 40 47 73 f0       	mov    %eax,0xf0734740
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010b292:	ff 4d f4             	decl   -0xc(%ebp)
f010b295:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b299:	0f 89 46 fe ff ff    	jns    f010b0e5 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010b29f:	90                   	nop
f010b2a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b2a3:	5b                   	pop    %ebx
f010b2a4:	5e                   	pop    %esi
f010b2a5:	5d                   	pop    %ebp
f010b2a6:	c3                   	ret    

f010b2a7 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010b2a7:	55                   	push   %ebp
f010b2a8:	89 e5                	mov    %esp,%ebp
f010b2aa:	57                   	push   %edi
f010b2ab:	56                   	push   %esi
f010b2ac:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010b2b2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010b2b9:	83 ec 0c             	sub    $0xc,%esp
f010b2bc:	ff 75 08             	pushl  0x8(%ebp)
f010b2bf:	e8 b8 1e 00 00       	call   f010d17c <get_user_program_info>
f010b2c4:	83 c4 10             	add    $0x10,%esp
f010b2c7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010b2ca:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b2ce:	75 0a                	jne    f010b2da <env_create+0x33>
	{
		return NULL;
f010b2d0:	b8 00 00 00 00       	mov    $0x0,%eax
f010b2d5:	e9 aa 09 00 00       	jmp    f010bc84 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010b2da:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b2dd:	8b 40 08             	mov    0x8(%eax),%eax
f010b2e0:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010b2e3:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010b2ea:	00 00 00 
	if(allocate_environment(&e) < 0)
f010b2ed:	83 ec 0c             	sub    $0xc,%esp
f010b2f0:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010b2f6:	50                   	push   %eax
f010b2f7:	e8 96 0e 00 00       	call   f010c192 <allocate_environment>
f010b2fc:	83 c4 10             	add    $0x10,%esp
f010b2ff:	85 c0                	test   %eax,%eax
f010b301:	79 0a                	jns    f010b30d <env_create+0x66>
	{
		return NULL;
f010b303:	b8 00 00 00 00       	mov    $0x0,%eax
f010b308:	e9 77 09 00 00       	jmp    f010bc84 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010b30d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b310:	8b 00                	mov    (%eax),%eax
f010b312:	83 ec 0c             	sub    $0xc,%esp
f010b315:	50                   	push   %eax
f010b316:	e8 01 4d 01 00       	call   f012001c <strlen>
f010b31b:	83 c4 10             	add    $0x10,%esp
f010b31e:	83 f8 3f             	cmp    $0x3f,%eax
f010b321:	7f 1d                	jg     f010b340 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010b323:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b326:	8b 00                	mov    (%eax),%eax
f010b328:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b32e:	83 c2 20             	add    $0x20,%edx
f010b331:	83 ec 08             	sub    $0x8,%esp
f010b334:	50                   	push   %eax
f010b335:	52                   	push   %edx
f010b336:	e8 30 4d 01 00       	call   f012006b <strcpy>
f010b33b:	83 c4 10             	add    $0x10,%esp
f010b33e:	eb 1d                	jmp    f010b35d <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010b340:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b343:	8b 00                	mov    (%eax),%eax
f010b345:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b34b:	83 c2 20             	add    $0x20,%edx
f010b34e:	83 ec 04             	sub    $0x4,%esp
f010b351:	6a 3f                	push   $0x3f
f010b353:	50                   	push   %eax
f010b354:	52                   	push   %edx
f010b355:	e8 3f 4d 01 00       	call   f0120099 <strncpy>
f010b35a:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010b35d:	e8 fc 13 00 00       	call   f010c75e <create_user_directory>
f010b362:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b365:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b368:	83 ec 0c             	sub    $0xc,%esp
f010b36b:	50                   	push   %eax
f010b36c:	e8 44 e8 ff ff       	call   f0109bb5 <kheap_physical_address>
f010b371:	83 c4 10             	add    $0x10,%esp
f010b374:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010b377:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b37d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b380:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b386:	83 ec 0c             	sub    $0xc,%esp
f010b389:	6a 02                	push   $0x2
f010b38b:	e8 a3 46 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010b390:	83 c4 10             	add    $0x10,%esp
f010b393:	85 c0                	test   %eax,%eax
f010b395:	74 21                	je     f010b3b8 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010b397:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b39d:	8b 55 10             	mov    0x10(%ebp),%edx
f010b3a0:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b3a6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3ac:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b3af:	2b 55 10             	sub    0x10(%ebp),%edx
f010b3b2:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b3b8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b3bc:	75 12                	jne    f010b3d0 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b3be:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3c4:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010b3cb:	00 00 00 
f010b3ce:	eb 0f                	jmp    f010b3df <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b3d0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3d6:	8b 55 14             	mov    0x14(%ebp),%edx
f010b3d9:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b3df:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3e5:	83 ec 04             	sub    $0x4,%esp
f010b3e8:	ff 75 bc             	pushl  -0x44(%ebp)
f010b3eb:	ff 75 c0             	pushl  -0x40(%ebp)
f010b3ee:	50                   	push   %eax
f010b3ef:	e8 c8 14 00 00       	call   f010c8bc <initialize_environment>
f010b3f4:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b3f7:	e8 fe c0 ff ff       	call   f01074fa <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b3fc:	0f 20 d8             	mov    %cr3,%eax
f010b3ff:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b402:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b405:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b408:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b40e:	8b 40 68             	mov    0x68(%eax),%eax
f010b411:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b417:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b41d:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b420:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b427:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b42e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b434:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b43a:	48                   	dec    %eax
f010b43b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b43e:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b445:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b448:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b44e:	83 ec 08             	sub    $0x8,%esp
f010b451:	ff 75 c8             	pushl  -0x38(%ebp)
f010b454:	50                   	push   %eax
f010b455:	e8 34 1a 00 00       	call   f010ce8e <PROGRAM_SEGMENT_FIRST>
f010b45a:	83 c4 0c             	add    $0xc,%esp
f010b45d:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b463:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b469:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b46e:	89 c7                	mov    %eax,%edi
f010b470:	89 d6                	mov    %edx,%esi
f010b472:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b474:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b47a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b47d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b480:	8b 40 10             	mov    0x10(%eax),%eax
f010b483:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b486:	75 07                	jne    f010b48f <env_create+0x1e8>
f010b488:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b48f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b492:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b495:	e9 fa 02 00 00       	jmp    f010b794 <env_create+0x4ed>
		{
			segment_counter++;
f010b49a:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b49d:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b4a4:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b4a7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b4ad:	83 ec 0c             	sub    $0xc,%esp
f010b4b0:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b4b6:	52                   	push   %edx
f010b4b7:	ff 75 ec             	pushl  -0x14(%ebp)
f010b4ba:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b4c0:	52                   	push   %edx
f010b4c1:	ff 75 f4             	pushl  -0xc(%ebp)
f010b4c4:	50                   	push   %eax
f010b4c5:	e8 86 0d 00 00       	call   f010c250 <program_segment_alloc_map_copy_workingset>
f010b4ca:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b4cd:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b4d3:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b4d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4d9:	8b 00                	mov    (%eax),%eax
f010b4db:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b4de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4e1:	8b 40 0c             	mov    0xc(%eax),%eax
f010b4e4:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b4e7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b4ea:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b4ed:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b4f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b4f5:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b4f8:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b4ff:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b502:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b505:	01 d0                	add    %edx,%eax
f010b507:	48                   	dec    %eax
f010b508:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b50b:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b50e:	ba 00 00 00 00       	mov    $0x0,%edx
f010b513:	f7 75 9c             	divl   -0x64(%ebp)
f010b516:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b519:	29 d0                	sub    %edx,%eax
f010b51b:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b51e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b521:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b524:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b527:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b52a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b52d:	8b 15 ec d9 f5 f0    	mov    0xf0f5d9ec,%edx
f010b533:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b536:	01 d0                	add    %edx,%eax
f010b538:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b53b:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b53f:	74 73                	je     f010b5b4 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b541:	a1 ec d9 f5 f0       	mov    0xf0f5d9ec,%eax
f010b546:	83 ec 04             	sub    $0x4,%esp
f010b549:	68 00 10 00 00       	push   $0x1000
f010b54e:	6a 00                	push   $0x0
f010b550:	50                   	push   %eax
f010b551:	e8 b4 4c 01 00       	call   f012020a <memset>
f010b556:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b559:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b55c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b55f:	eb 13                	jmp    f010b574 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b561:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b564:	8a 10                	mov    (%eax),%dl
f010b566:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b569:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b56b:	ff 45 dc             	incl   -0x24(%ebp)
f010b56e:	ff 45 e4             	incl   -0x1c(%ebp)
f010b571:	ff 45 e0             	incl   -0x20(%ebp)
f010b574:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b577:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b57a:	72 e5                	jb     f010b561 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b57c:	8b 15 ec d9 f5 f0    	mov    0xf0f5d9ec,%edx
f010b582:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b588:	83 ec 04             	sub    $0x4,%esp
f010b58b:	52                   	push   %edx
f010b58c:	ff 75 a0             	pushl  -0x60(%ebp)
f010b58f:	50                   	push   %eax
f010b590:	e8 90 8e ff ff       	call   f0104425 <pf_add_env_page>
f010b595:	83 c4 10             	add    $0x10,%esp
f010b598:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b59b:	75 17                	jne    f010b5b4 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b59d:	83 ec 04             	sub    $0x4,%esp
f010b5a0:	68 b8 67 12 f0       	push   $0xf01267b8
f010b5a5:	68 f5 00 00 00       	push   $0xf5
f010b5aa:	68 9b 67 12 f0       	push   $0xf012679b
f010b5af:	e8 85 4d ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b5b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5b7:	8b 50 04             	mov    0x4(%eax),%edx
f010b5ba:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b5bd:	01 d0                	add    %edx,%eax
f010b5bf:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b5c2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b5c5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b5ca:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b5cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5d0:	8b 50 04             	mov    0x4(%eax),%edx
f010b5d3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b5d6:	01 d0                	add    %edx,%eax
f010b5d8:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b5db:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b5de:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b5e1:	eb 43                	jmp    f010b626 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b5e3:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b5e6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5ec:	83 ec 04             	sub    $0x4,%esp
f010b5ef:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b5f2:	52                   	push   %edx
f010b5f3:	50                   	push   %eax
f010b5f4:	e8 2c 8e ff ff       	call   f0104425 <pf_add_env_page>
f010b5f9:	83 c4 10             	add    $0x10,%esp
f010b5fc:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b5ff:	75 17                	jne    f010b618 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b601:	83 ec 04             	sub    $0x4,%esp
f010b604:	68 b8 67 12 f0       	push   $0xf01267b8
f010b609:	68 02 01 00 00       	push   $0x102
f010b60e:	68 9b 67 12 f0       	push   $0xf012679b
f010b613:	e8 21 4d ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b618:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b61f:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b626:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b629:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b62c:	72 b5                	jb     f010b5e3 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b62e:	a1 ec d9 f5 f0       	mov    0xf0f5d9ec,%eax
f010b633:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b636:	83 ec 04             	sub    $0x4,%esp
f010b639:	68 00 10 00 00       	push   $0x1000
f010b63e:	6a 00                	push   $0x0
f010b640:	ff 75 e0             	pushl  -0x20(%ebp)
f010b643:	e8 c2 4b 01 00       	call   f012020a <memset>
f010b648:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b64b:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b64e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b651:	eb 13                	jmp    f010b666 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b653:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b656:	8a 10                	mov    (%eax),%dl
f010b658:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b65b:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b65d:	ff 45 dc             	incl   -0x24(%ebp)
f010b660:	ff 45 e4             	incl   -0x1c(%ebp)
f010b663:	ff 45 e0             	incl   -0x20(%ebp)
f010b666:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b669:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b66c:	72 e5                	jb     f010b653 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b66e:	8b 15 ec d9 f5 f0    	mov    0xf0f5d9ec,%edx
f010b674:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b67a:	83 ec 04             	sub    $0x4,%esp
f010b67d:	52                   	push   %edx
f010b67e:	ff 75 88             	pushl  -0x78(%ebp)
f010b681:	50                   	push   %eax
f010b682:	e8 9e 8d ff ff       	call   f0104425 <pf_add_env_page>
f010b687:	83 c4 10             	add    $0x10,%esp
f010b68a:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b68d:	75 17                	jne    f010b6a6 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b68f:	83 ec 04             	sub    $0x4,%esp
f010b692:	68 b8 67 12 f0       	push   $0xf01267b8
f010b697:	68 11 01 00 00       	push   $0x111
f010b69c:	68 9b 67 12 f0       	push   $0xf012679b
f010b6a1:	e8 93 4c ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b6a6:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b6ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6b0:	8b 50 04             	mov    0x4(%eax),%edx
f010b6b3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b6b6:	01 c2                	add    %eax,%edx
f010b6b8:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b6bb:	01 d0                	add    %edx,%eax
f010b6bd:	48                   	dec    %eax
f010b6be:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b6c4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b6ca:	ba 00 00 00 00       	mov    $0x0,%edx
f010b6cf:	f7 75 80             	divl   -0x80(%ebp)
f010b6d2:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b6d8:	29 d0                	sub    %edx,%eax
f010b6da:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b6dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6e0:	8b 50 08             	mov    0x8(%eax),%edx
f010b6e3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b6e6:	01 d0                	add    %edx,%eax
f010b6e8:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b6eb:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b6f1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b6f8:	eb 41                	jmp    f010b73b <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b6fa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b700:	83 ec 04             	sub    $0x4,%esp
f010b703:	6a 01                	push   $0x1
f010b705:	ff 75 d8             	pushl  -0x28(%ebp)
f010b708:	50                   	push   %eax
f010b709:	e8 e6 8b ff ff       	call   f01042f4 <pf_add_empty_env_page>
f010b70e:	83 c4 10             	add    $0x10,%esp
f010b711:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b714:	75 17                	jne    f010b72d <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b716:	83 ec 04             	sub    $0x4,%esp
f010b719:	68 b8 67 12 f0       	push   $0xf01267b8
f010b71e:	68 1e 01 00 00       	push   $0x11e
f010b723:	68 9b 67 12 f0       	push   $0xf012679b
f010b728:	e8 0c 4c ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b72d:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b734:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b73b:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b742:	10 00 00 
f010b745:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b74b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b751:	01 d0                	add    %edx,%eax
f010b753:	48                   	dec    %eax
f010b754:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b75a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b760:	ba 00 00 00 00       	mov    $0x0,%edx
f010b765:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b76b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b771:	29 d0                	sub    %edx,%eax
f010b773:	89 c2                	mov    %eax,%edx
f010b775:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b778:	39 c2                	cmp    %eax,%edx
f010b77a:	0f 87 7a ff ff ff    	ja     f010b6fa <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b780:	83 ec 08             	sub    $0x8,%esp
f010b783:	ff 75 c8             	pushl  -0x38(%ebp)
f010b786:	ff 75 f4             	pushl  -0xc(%ebp)
f010b789:	e8 f5 15 00 00       	call   f010cd83 <PROGRAM_SEGMENT_NEXT>
f010b78e:	83 c4 10             	add    $0x10,%esp
f010b791:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b794:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b798:	0f 85 fc fc ff ff    	jne    f010b49a <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b79e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7a4:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b7aa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b7ad:	eb 77                	jmp    f010b826 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b7af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7b2:	8b 00                	mov    (%eax),%eax
f010b7b4:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b7ba:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7c0:	8b 40 64             	mov    0x64(%eax),%eax
f010b7c3:	83 ec 04             	sub    $0x4,%esp
f010b7c6:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b7cc:	52                   	push   %edx
f010b7cd:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b7d3:	50                   	push   %eax
f010b7d4:	e8 41 cf ff ff       	call   f010871a <get_page_table>
f010b7d9:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b7dc:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010b7e2:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010b7e8:	c1 ea 0c             	shr    $0xc,%edx
f010b7eb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b7f1:	c1 e2 02             	shl    $0x2,%edx
f010b7f4:	01 d0                	add    %edx,%eax
f010b7f6:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010b7fc:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010b802:	c1 e9 0c             	shr    $0xc,%ecx
f010b805:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b80b:	c1 e1 02             	shl    $0x2,%ecx
f010b80e:	01 ca                	add    %ecx,%edx
f010b810:	8b 12                	mov    (%edx),%edx
f010b812:	83 e2 bf             	and    $0xffffffbf,%edx
f010b815:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b817:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b81d:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b823:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b826:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b82c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b830:	74 08                	je     f010b83a <env_create+0x593>
f010b832:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b835:	8b 52 10             	mov    0x10(%edx),%edx
f010b838:	eb 05                	jmp    f010b83f <env_create+0x598>
f010b83a:	ba 00 00 00 00       	mov    $0x0,%edx
f010b83f:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010b845:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b84b:	85 c0                	test   %eax,%eax
f010b84d:	0f 85 5c ff ff ff    	jne    f010b7af <env_create+0x508>
f010b853:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b857:	0f 85 52 ff ff ff    	jne    f010b7af <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b85d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b860:	8b 50 08             	mov    0x8(%eax),%edx
f010b863:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b869:	83 ec 08             	sub    $0x8,%esp
f010b86c:	52                   	push   %edx
f010b86d:	50                   	push   %eax
f010b86e:	e8 d0 14 00 00       	call   f010cd43 <set_environment_entry_point>
f010b873:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b876:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b87c:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b883:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010b88a:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b88d:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b894:	e9 42 03 00 00       	jmp    f010bbdb <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b899:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010b8a0:	00 00 00 
			allocate_frame(&pp);
f010b8a3:	83 ec 0c             	sub    $0xc,%esp
f010b8a6:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010b8ac:	50                   	push   %eax
f010b8ad:	e8 2b cc ff ff       	call   f01084dd <allocate_frame>
f010b8b2:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b8b5:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010b8bb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8c1:	8b 40 64             	mov    0x64(%eax),%eax
f010b8c4:	6a 06                	push   $0x6
f010b8c6:	ff 75 d0             	pushl  -0x30(%ebp)
f010b8c9:	52                   	push   %edx
f010b8ca:	50                   	push   %eax
f010b8cb:	e8 de d2 ff ff       	call   f0108bae <loadtime_map_frame>
f010b8d0:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b8d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b8d6:	83 ec 04             	sub    $0x4,%esp
f010b8d9:	68 00 10 00 00       	push   $0x1000
f010b8de:	6a 00                	push   $0x0
f010b8e0:	50                   	push   %eax
f010b8e1:	e8 24 49 01 00       	call   f012020a <memset>
f010b8e6:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b8e9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8ef:	83 ec 08             	sub    $0x8,%esp
f010b8f2:	ff 75 d0             	pushl  -0x30(%ebp)
f010b8f5:	50                   	push   %eax
f010b8f6:	e8 e4 e8 ff ff       	call   f010a1df <env_page_ws_list_create_element>
f010b8fb:	83 c4 10             	add    $0x10,%esp
f010b8fe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b901:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b905:	75 17                	jne    f010b91e <env_create+0x677>
f010b907:	83 ec 04             	sub    $0x4,%esp
f010b90a:	68 00 68 12 f0       	push   $0xf0126800
f010b90f:	68 5d 01 00 00       	push   $0x15d
f010b914:	68 9b 67 12 f0       	push   $0xf012679b
f010b919:	e8 1b 4a ff ff       	call   f0100339 <_panic>
f010b91e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b924:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b92a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b92d:	89 50 14             	mov    %edx,0x14(%eax)
f010b930:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b933:	8b 40 14             	mov    0x14(%eax),%eax
f010b936:	85 c0                	test   %eax,%eax
f010b938:	74 14                	je     f010b94e <env_create+0x6a7>
f010b93a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b940:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b946:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b949:	89 50 10             	mov    %edx,0x10(%eax)
f010b94c:	eb 0f                	jmp    f010b95d <env_create+0x6b6>
f010b94e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b954:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b957:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b95d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b963:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b966:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b96c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b96f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b976:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b97c:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b982:	42                   	inc    %edx
f010b983:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b989:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b98f:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b995:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b99b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b9a1:	39 c2                	cmp    %eax,%edx
f010b9a3:	75 1a                	jne    f010b9bf <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b9a5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9ab:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b9b1:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b9b7:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b9bd:	eb 10                	jmp    f010b9cf <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b9bf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9c5:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b9cc:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b9cf:	83 ec 0c             	sub    $0xc,%esp
f010b9d2:	6a 02                	push   $0x2
f010b9d4:	e8 5a 40 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010b9d9:	83 c4 10             	add    $0x10,%esp
f010b9dc:	85 c0                	test   %eax,%eax
f010b9de:	0f 84 d3 01 00 00    	je     f010bbb7 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b9e4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b9e8:	75 17                	jne    f010ba01 <env_create+0x75a>
f010b9ea:	83 ec 04             	sub    $0x4,%esp
f010b9ed:	68 23 68 12 f0       	push   $0xf0126823
f010b9f2:	68 6a 01 00 00       	push   $0x16a
f010b9f7:	68 9b 67 12 f0       	push   $0xf012679b
f010b9fc:	e8 38 49 ff ff       	call   f0100339 <_panic>
f010ba01:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba04:	8b 40 10             	mov    0x10(%eax),%eax
f010ba07:	85 c0                	test   %eax,%eax
f010ba09:	74 11                	je     f010ba1c <env_create+0x775>
f010ba0b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba0e:	8b 40 10             	mov    0x10(%eax),%eax
f010ba11:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba14:	8b 52 14             	mov    0x14(%edx),%edx
f010ba17:	89 50 14             	mov    %edx,0x14(%eax)
f010ba1a:	eb 12                	jmp    f010ba2e <env_create+0x787>
f010ba1c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba22:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba25:	8b 52 14             	mov    0x14(%edx),%edx
f010ba28:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010ba2e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba31:	8b 40 14             	mov    0x14(%eax),%eax
f010ba34:	85 c0                	test   %eax,%eax
f010ba36:	74 11                	je     f010ba49 <env_create+0x7a2>
f010ba38:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba3b:	8b 40 14             	mov    0x14(%eax),%eax
f010ba3e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba41:	8b 52 10             	mov    0x10(%edx),%edx
f010ba44:	89 50 10             	mov    %edx,0x10(%eax)
f010ba47:	eb 12                	jmp    f010ba5b <env_create+0x7b4>
f010ba49:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba4f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba52:	8b 52 10             	mov    0x10(%edx),%edx
f010ba55:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010ba5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba5e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010ba65:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ba68:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba6f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba75:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010ba7b:	4a                   	dec    %edx
f010ba7c:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010ba82:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba88:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010ba8e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba94:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010ba9a:	39 c2                	cmp    %eax,%edx
f010ba9c:	0f 83 8d 00 00 00    	jae    f010bb2f <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010baa2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010baa6:	75 17                	jne    f010babf <env_create+0x818>
f010baa8:	83 ec 04             	sub    $0x4,%esp
f010baab:	68 78 67 12 f0       	push   $0xf0126778
f010bab0:	68 6f 01 00 00       	push   $0x16f
f010bab5:	68 9b 67 12 f0       	push   $0xf012679b
f010baba:	e8 7a 48 ff ff       	call   f0100339 <_panic>
f010babf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bac5:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010bacb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bace:	89 50 10             	mov    %edx,0x10(%eax)
f010bad1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bad4:	8b 40 10             	mov    0x10(%eax),%eax
f010bad7:	85 c0                	test   %eax,%eax
f010bad9:	74 14                	je     f010baef <env_create+0x848>
f010badb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bae1:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010bae7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010baea:	89 50 14             	mov    %edx,0x14(%eax)
f010baed:	eb 0f                	jmp    f010bafe <env_create+0x857>
f010baef:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010baf5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010baf8:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010bafe:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb04:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb07:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010bb0d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb10:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bb17:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb1d:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010bb23:	42                   	inc    %edx
f010bb24:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010bb2a:	e9 88 00 00 00       	jmp    f010bbb7 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010bb2f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010bb33:	75 17                	jne    f010bb4c <env_create+0x8a5>
f010bb35:	83 ec 04             	sub    $0x4,%esp
f010bb38:	68 78 67 12 f0       	push   $0xf0126778
f010bb3d:	68 73 01 00 00       	push   $0x173
f010bb42:	68 9b 67 12 f0       	push   $0xf012679b
f010bb47:	e8 ed 47 ff ff       	call   f0100339 <_panic>
f010bb4c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb52:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010bb58:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb5b:	89 50 10             	mov    %edx,0x10(%eax)
f010bb5e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb61:	8b 40 10             	mov    0x10(%eax),%eax
f010bb64:	85 c0                	test   %eax,%eax
f010bb66:	74 14                	je     f010bb7c <env_create+0x8d5>
f010bb68:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb6e:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010bb74:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb77:	89 50 14             	mov    %edx,0x14(%eax)
f010bb7a:	eb 0f                	jmp    f010bb8b <env_create+0x8e4>
f010bb7c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb82:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb85:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010bb8b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb91:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb94:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010bb9a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb9d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bba4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbaa:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010bbb0:	42                   	inc    %edx
f010bbb1:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010bbb7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbbd:	83 ec 04             	sub    $0x4,%esp
f010bbc0:	6a 01                	push   $0x1
f010bbc2:	ff 75 d0             	pushl  -0x30(%ebp)
f010bbc5:	50                   	push   %eax
f010bbc6:	e8 29 87 ff ff       	call   f01042f4 <pf_add_empty_env_page>
f010bbcb:	83 c4 10             	add    $0x10,%esp
f010bbce:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010bbd4:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010bbdb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bbde:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010bbe4:	0f 83 af fc ff ff    	jae    f010b899 <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010bbea:	83 ec 0c             	sub    $0xc,%esp
f010bbed:	6a 02                	push   $0x2
f010bbef:	e8 3f 3e 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010bbf4:	83 c4 10             	add    $0x10,%esp
f010bbf7:	85 c0                	test   %eax,%eax
f010bbf9:	74 72                	je     f010bc6d <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010bbfb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010bc02:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc08:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010bc0e:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010bc11:	eb 2b                	jmp    f010bc3e <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010bc13:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bc16:	8b 10                	mov    (%eax),%edx
f010bc18:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc1e:	8b 40 64             	mov    0x64(%eax),%eax
f010bc21:	6a 01                	push   $0x1
f010bc23:	6a 00                	push   $0x0
f010bc25:	52                   	push   %edx
f010bc26:	50                   	push   %eax
f010bc27:	e8 7d e3 ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010bc2c:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010bc2f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc35:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010bc3b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010bc3e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc44:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bc48:	74 08                	je     f010bc52 <env_create+0x9ab>
f010bc4a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bc4d:	8b 52 10             	mov    0x10(%edx),%edx
f010bc50:	eb 05                	jmp    f010bc57 <env_create+0x9b0>
f010bc52:	ba 00 00 00 00       	mov    $0x0,%edx
f010bc57:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010bc5d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010bc63:	85 c0                	test   %eax,%eax
f010bc65:	75 ac                	jne    f010bc13 <env_create+0x96c>
f010bc67:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bc6b:	75 a6                	jne    f010bc13 <env_create+0x96c>
f010bc6d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010bc70:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010bc73:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010bc76:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010bc79:	e8 ce b8 ff ff       	call   f010754c <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010bc7e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010bc84:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010bc87:	5e                   	pop    %esi
f010bc88:	5f                   	pop    %edi
f010bc89:	5d                   	pop    %ebp
f010bc8a:	c3                   	ret    

f010bc8b <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010bc8b:	55                   	push   %ebp
f010bc8c:	89 e5                	mov    %esp,%ebp
f010bc8e:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010bc91:	83 ec 0c             	sub    $0xc,%esp
f010bc94:	68 20 d2 75 f0       	push   $0xf075d220
f010bc99:	e8 57 44 00 00       	call   f01100f5 <release_spinlock>
f010bc9e:	83 c4 10             	add    $0x10,%esp

	if (first)
f010bca1:	a1 94 09 18 f0       	mov    0xf0180994,%eax
f010bca6:	85 c0                	test   %eax,%eax
f010bca8:	74 30                	je     f010bcda <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010bcaa:	e8 76 00 00 00       	call   f010bd25 <get_cpu_proc>
f010bcaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010bcb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bcb5:	8b 40 10             	mov    0x10(%eax),%eax
f010bcb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcbb:	83 c2 20             	add    $0x20,%edx
f010bcbe:	83 ec 04             	sub    $0x4,%esp
f010bcc1:	50                   	push   %eax
f010bcc2:	52                   	push   %edx
f010bcc3:	68 41 68 12 f0       	push   $0xf0126841
f010bcc8:	e8 be 52 ff ff       	call   f0100f8b <cprintf>
f010bccd:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010bcd0:	c7 05 94 09 18 f0 00 	movl   $0x0,0xf0180994
f010bcd7:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010bcda:	90                   	nop
f010bcdb:	c9                   	leave  
f010bcdc:	c3                   	ret    

f010bcdd <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010bcdd:	55                   	push   %ebp
f010bcde:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010bce0:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010bce1:	5d                   	pop    %ebp
f010bce2:	c3                   	ret    

f010bce3 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010bce3:	55                   	push   %ebp
f010bce4:	89 e5                	mov    %esp,%ebp
f010bce6:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010bce9:	e8 37 00 00 00       	call   f010bd25 <get_cpu_proc>
f010bcee:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010bcf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bcf5:	75 19                	jne    f010bd10 <env_exit+0x2d>
f010bcf7:	68 57 68 12 f0       	push   $0xf0126857
f010bcfc:	68 67 68 12 f0       	push   $0xf0126867
f010bd01:	68 ed 01 00 00       	push   $0x1ed
f010bd06:	68 9b 67 12 f0       	push   $0xf012679b
f010bd0b:	e8 29 46 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010bd10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd13:	8b 40 10             	mov    0x10(%eax),%eax
f010bd16:	83 ec 0c             	sub    $0xc,%esp
f010bd19:	50                   	push   %eax
f010bd1a:	e8 75 9d ff ff       	call   f0105a94 <sched_exit_env>
f010bd1f:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010bd22:	90                   	nop
f010bd23:	c9                   	leave  
f010bd24:	c3                   	ret    

f010bd25 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010bd25:	55                   	push   %ebp
f010bd26:	89 e5                	mov    %esp,%ebp
f010bd28:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010bd2b:	e8 ca b7 ff ff       	call   f01074fa <pushcli>
	c = mycpu();
f010bd30:	e8 02 b7 ff ff       	call   f0107437 <mycpu>
f010bd35:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010bd38:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd3b:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bd41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010bd44:	e8 03 b8 ff ff       	call   f010754c <popcli>
	return p;
f010bd49:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010bd4c:	c9                   	leave  
f010bd4d:	c3                   	ret    

f010bd4e <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010bd4e:	55                   	push   %ebp
f010bd4f:	89 e5                	mov    %esp,%ebp
f010bd51:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010bd54:	e8 a1 b7 ff ff       	call   f01074fa <pushcli>
	c = mycpu();
f010bd59:	e8 d9 b6 ff ff       	call   f0107437 <mycpu>
f010bd5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010bd61:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd64:	8b 55 08             	mov    0x8(%ebp),%edx
f010bd67:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010bd6d:	e8 da b7 ff ff       	call   f010754c <popcli>
}
f010bd72:	90                   	nop
f010bd73:	c9                   	leave  
f010bd74:	c3                   	ret    

f010bd75 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010bd75:	55                   	push   %ebp
f010bd76:	89 e5                	mov    %esp,%ebp
f010bd78:	53                   	push   %ebx
f010bd79:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010bd7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bd80:	75 16                	jne    f010bd98 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010bd82:	e8 9e ff ff ff       	call   f010bd25 <get_cpu_proc>
f010bd87:	89 c2                	mov    %eax,%edx
f010bd89:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd8c:	89 10                	mov    %edx,(%eax)
		return 0;
f010bd8e:	b8 00 00 00 00       	mov    $0x0,%eax
f010bd93:	e9 aa 00 00 00       	jmp    f010be42 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010bd98:	8b 1d 30 47 73 f0    	mov    0xf0734730,%ebx
f010bd9e:	83 ec 0c             	sub    $0xc,%esp
f010bda1:	68 ca 02 00 00       	push   $0x2ca
f010bda6:	e8 cf 27 01 00       	call   f011e57a <nearest_pow2_ceil>
f010bdab:	83 c4 10             	add    $0x10,%esp
f010bdae:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bdb1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdb4:	21 c2                	and    %eax,%edx
f010bdb6:	89 d0                	mov    %edx,%eax
f010bdb8:	c1 e0 03             	shl    $0x3,%eax
f010bdbb:	01 d0                	add    %edx,%eax
f010bdbd:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bdc4:	01 c8                	add    %ecx,%eax
f010bdc6:	01 c0                	add    %eax,%eax
f010bdc8:	01 d0                	add    %edx,%eax
f010bdca:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bdd1:	01 c8                	add    %ecx,%eax
f010bdd3:	01 d0                	add    %edx,%eax
f010bdd5:	01 d8                	add    %ebx,%eax
f010bdd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bdda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bddd:	8b 40 18             	mov    0x18(%eax),%eax
f010bde0:	85 c0                	test   %eax,%eax
f010bde2:	74 0b                	je     f010bdef <envid2env+0x7a>
f010bde4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde7:	8b 40 10             	mov    0x10(%eax),%eax
f010bdea:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bded:	74 10                	je     f010bdff <envid2env+0x8a>
		*env_store = 0;
f010bdef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bdf2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bdf8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bdfd:	eb 43                	jmp    f010be42 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010bdff:	e8 21 ff ff ff       	call   f010bd25 <get_cpu_proc>
f010be04:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010be07:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010be0b:	74 28                	je     f010be35 <envid2env+0xc0>
f010be0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be10:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010be13:	74 20                	je     f010be35 <envid2env+0xc0>
f010be15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be18:	8b 50 14             	mov    0x14(%eax),%edx
f010be1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010be1e:	8b 40 10             	mov    0x10(%eax),%eax
f010be21:	39 c2                	cmp    %eax,%edx
f010be23:	74 10                	je     f010be35 <envid2env+0xc0>
		*env_store = 0;
f010be25:	8b 45 0c             	mov    0xc(%ebp),%eax
f010be28:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010be2e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010be33:	eb 0d                	jmp    f010be42 <envid2env+0xcd>
	}

	*env_store = e;
f010be35:	8b 45 0c             	mov    0xc(%ebp),%eax
f010be38:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be3b:	89 10                	mov    %edx,(%eax)
	return 0;
f010be3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010be42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010be45:	c9                   	leave  
f010be46:	c3                   	ret    

f010be47 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010be47:	55                   	push   %ebp
f010be48:	89 e5                	mov    %esp,%ebp
f010be4a:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010be4d:	83 ec 0c             	sub    $0xc,%esp
f010be50:	68 20 d2 75 f0       	push   $0xf075d220
f010be55:	e8 14 42 00 00       	call   f011006e <acquire_spinlock>
f010be5a:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010be5d:	e8 c3 fe ff ff       	call   f010bd25 <get_cpu_proc>
f010be62:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010be65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be69:	75 19                	jne    f010be84 <yield+0x3d>
f010be6b:	68 7c 68 12 f0       	push   $0xf012687c
f010be70:	68 67 68 12 f0       	push   $0xf0126867
f010be75:	68 4c 02 00 00       	push   $0x24c
f010be7a:	68 9b 67 12 f0       	push   $0xf012679b
f010be7f:	e8 b5 44 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010be84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be87:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010be8e:	e8 13 00 00 00       	call   f010bea6 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010be93:	83 ec 0c             	sub    $0xc,%esp
f010be96:	68 20 d2 75 f0       	push   $0xf075d220
f010be9b:	e8 55 42 00 00       	call   f01100f5 <release_spinlock>
f010bea0:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bea3:	90                   	nop
f010bea4:	c9                   	leave  
f010bea5:	c3                   	ret    

f010bea6 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bea6:	55                   	push   %ebp
f010bea7:	89 e5                	mov    %esp,%ebp
f010bea9:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010beac:	e8 74 fe ff ff       	call   f010bd25 <get_cpu_proc>
f010beb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010beb4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010beb8:	75 19                	jne    f010bed3 <sched+0x2d>
f010beba:	68 7c 68 12 f0       	push   $0xf012687c
f010bebf:	68 67 68 12 f0       	push   $0xf0126867
f010bec4:	68 60 02 00 00       	push   $0x260
f010bec9:	68 9b 67 12 f0       	push   $0xf012679b
f010bece:	e8 66 44 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010bed3:	83 ec 0c             	sub    $0xc,%esp
f010bed6:	68 20 d2 75 f0       	push   $0xf075d220
f010bedb:	e8 a7 43 00 00       	call   f0110287 <holding_spinlock>
f010bee0:	83 c4 10             	add    $0x10,%esp
f010bee3:	85 c0                	test   %eax,%eax
f010bee5:	75 17                	jne    f010befe <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bee7:	83 ec 04             	sub    $0x4,%esp
f010beea:	68 88 68 12 f0       	push   $0xf0126888
f010beef:	68 64 02 00 00       	push   $0x264
f010bef4:	68 9b 67 12 f0       	push   $0xf012679b
f010bef9:	e8 3b 44 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010befe:	e8 34 b5 ff ff       	call   f0107437 <mycpu>
f010bf03:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bf09:	83 f8 01             	cmp    $0x1,%eax
f010bf0c:	74 20                	je     f010bf2e <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bf0e:	e8 24 b5 ff ff       	call   f0107437 <mycpu>
f010bf13:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bf19:	50                   	push   %eax
f010bf1a:	68 ca 68 12 f0       	push   $0xf01268ca
f010bf1f:	68 67 02 00 00       	push   $0x267
f010bf24:	68 9b 67 12 f0       	push   $0xf012679b
f010bf29:	e8 0b 44 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bf2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf31:	8b 40 18             	mov    0x18(%eax),%eax
f010bf34:	83 f8 02             	cmp    $0x2,%eax
f010bf37:	75 17                	jne    f010bf50 <sched+0xaa>
		panic("sched a running process");
f010bf39:	83 ec 04             	sub    $0x4,%esp
f010bf3c:	68 e1 68 12 f0       	push   $0xf01268e1
f010bf41:	68 6a 02 00 00       	push   $0x26a
f010bf46:	68 9b 67 12 f0       	push   $0xf012679b
f010bf4b:	e8 e9 43 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bf50:	9c                   	pushf  
f010bf51:	58                   	pop    %eax
f010bf52:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bf55:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bf58:	25 00 02 00 00       	and    $0x200,%eax
f010bf5d:	85 c0                	test   %eax,%eax
f010bf5f:	74 17                	je     f010bf78 <sched+0xd2>
		panic("sched is interruptible!");
f010bf61:	83 ec 04             	sub    $0x4,%esp
f010bf64:	68 f9 68 12 f0       	push   $0xf01268f9
f010bf69:	68 6c 02 00 00       	push   $0x26c
f010bf6e:	68 9b 67 12 f0       	push   $0xf012679b
f010bf73:	e8 c1 43 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010bf78:	e8 ba b4 ff ff       	call   f0107437 <mycpu>
f010bf7d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bf83:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bf86:	e8 ac b4 ff ff       	call   f0107437 <mycpu>
f010bf8b:	8b 40 04             	mov    0x4(%eax),%eax
f010bf8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf91:	83 c2 04             	add    $0x4,%edx
f010bf94:	83 ec 08             	sub    $0x8,%esp
f010bf97:	50                   	push   %eax
f010bf98:	52                   	push   %edx
f010bf99:	e8 c1 8d ff ff       	call   f0104d5f <context_switch>
f010bf9e:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bfa1:	e8 91 b4 ff ff       	call   f0107437 <mycpu>
f010bfa6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bfa9:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bfaf:	90                   	nop
f010bfb0:	c9                   	leave  
f010bfb1:	c3                   	ret    

f010bfb2 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bfb2:	55                   	push   %ebp
f010bfb3:	89 e5                	mov    %esp,%ebp
f010bfb5:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bfb8:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f010bfbd:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bfc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bfc3:	0f 22 d8             	mov    %eax,%cr3
}
f010bfc6:	90                   	nop
f010bfc7:	c9                   	leave  
f010bfc8:	c3                   	ret    

f010bfc9 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bfc9:	55                   	push   %ebp
f010bfca:	89 e5                	mov    %esp,%ebp
f010bfcc:	53                   	push   %ebx
f010bfcd:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bfd0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bfd4:	75 17                	jne    f010bfed <switchuvm+0x24>
		panic("switchuvm: no process");
f010bfd6:	83 ec 04             	sub    $0x4,%esp
f010bfd9:	68 11 69 12 f0       	push   $0xf0126911
f010bfde:	68 81 02 00 00       	push   $0x281
f010bfe3:	68 9b 67 12 f0       	push   $0xf012679b
f010bfe8:	e8 4c 43 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010bfed:	8b 45 08             	mov    0x8(%ebp),%eax
f010bff0:	8b 40 70             	mov    0x70(%eax),%eax
f010bff3:	85 c0                	test   %eax,%eax
f010bff5:	75 17                	jne    f010c00e <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bff7:	83 ec 04             	sub    $0x4,%esp
f010bffa:	68 27 69 12 f0       	push   $0xf0126927
f010bfff:	68 83 02 00 00       	push   $0x283
f010c004:	68 9b 67 12 f0       	push   $0xf012679b
f010c009:	e8 2b 43 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010c00e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c011:	8b 40 64             	mov    0x64(%eax),%eax
f010c014:	85 c0                	test   %eax,%eax
f010c016:	75 17                	jne    f010c02f <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010c018:	83 ec 04             	sub    $0x4,%esp
f010c01b:	68 3c 69 12 f0       	push   $0xf012693c
f010c020:	68 85 02 00 00       	push   $0x285
f010c025:	68 9b 67 12 f0       	push   $0xf012679b
f010c02a:	e8 0a 43 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010c02f:	e8 c6 b4 ff ff       	call   f01074fa <pushcli>
	struct cpu* c = mycpu();
f010c034:	e8 fe b3 ff ff       	call   f0107437 <mycpu>
f010c039:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010c03c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c03f:	8b 55 08             	mov    0x8(%ebp),%edx
f010c042:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c048:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c04b:	83 c0 0c             	add    $0xc,%eax
f010c04e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c051:	83 c2 0c             	add    $0xc,%edx
f010c054:	c1 ea 10             	shr    $0x10,%edx
f010c057:	88 d3                	mov    %dl,%bl
f010c059:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c05c:	83 c2 0c             	add    $0xc,%edx
f010c05f:	c1 ea 18             	shr    $0x18,%edx
f010c062:	88 d1                	mov    %dl,%cl
f010c064:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c067:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c06e:	68 00 
f010c070:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c073:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c07a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c07d:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c083:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c086:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c08c:	83 e2 f0             	and    $0xfffffff0,%edx
f010c08f:	83 ca 09             	or     $0x9,%edx
f010c092:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c098:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c09b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0a1:	83 ca 10             	or     $0x10,%edx
f010c0a4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0ad:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0b3:	83 e2 9f             	and    $0xffffff9f,%edx
f010c0b6:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0bf:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c0c5:	83 ca 80             	or     $0xffffff80,%edx
f010c0c8:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c0ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0d1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c0d7:	83 e2 f0             	and    $0xfffffff0,%edx
f010c0da:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c0e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0e3:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c0e9:	83 e2 ef             	and    $0xffffffef,%edx
f010c0ec:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c0f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0f5:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c0fb:	83 e2 df             	and    $0xffffffdf,%edx
f010c0fe:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c104:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c107:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c10d:	83 ca 40             	or     $0x40,%edx
f010c110:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c116:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c119:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c11f:	83 e2 7f             	and    $0x7f,%edx
f010c122:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c128:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c12b:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c134:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c13a:	83 e2 ef             	and    $0xffffffef,%edx
f010c13d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010c143:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c146:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c14c:	8b 40 70             	mov    0x70(%eax),%eax
f010c14f:	05 00 80 00 00       	add    $0x8000,%eax
f010c154:	89 c2                	mov    %eax,%edx
f010c156:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c159:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c15c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c15f:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010c165:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c16b:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c16f:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010c172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c175:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c17b:	8b 40 68             	mov    0x68(%eax),%eax
f010c17e:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010c181:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c184:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010c187:	e8 c0 b3 ff ff       	call   f010754c <popcli>
}
f010c18c:	90                   	nop
f010c18d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c190:	c9                   	leave  
f010c191:	c3                   	ret    

f010c192 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010c192:	55                   	push   %ebp
f010c193:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010c195:	8b 15 34 47 73 f0    	mov    0xf0734734,%edx
f010c19b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c19e:	89 10                	mov    %edx,(%eax)
f010c1a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1a3:	8b 00                	mov    (%eax),%eax
f010c1a5:	85 c0                	test   %eax,%eax
f010c1a7:	75 07                	jne    f010c1b0 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010c1a9:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010c1ae:	eb 11                	jmp    f010c1c1 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010c1b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b3:	8b 00                	mov    (%eax),%eax
f010c1b5:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010c1bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c1c1:	5d                   	pop    %ebp
f010c1c2:	c3                   	ret    

f010c1c3 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010c1c3:	55                   	push   %ebp
f010c1c4:	89 e5                	mov    %esp,%ebp
f010c1c6:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010c1c9:	83 ec 04             	sub    $0x4,%esp
f010c1cc:	68 bc 05 00 00       	push   $0x5bc
f010c1d1:	6a 00                	push   $0x0
f010c1d3:	ff 75 08             	pushl  0x8(%ebp)
f010c1d6:	e8 2f 40 01 00       	call   f012020a <memset>
f010c1db:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010c1de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e1:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010c1e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c1ec:	75 17                	jne    f010c205 <free_environment+0x42>
f010c1ee:	83 ec 04             	sub    $0x4,%esp
f010c1f1:	68 78 67 12 f0       	push   $0xf0126778
f010c1f6:	68 c0 02 00 00       	push   $0x2c0
f010c1fb:	68 9b 67 12 f0       	push   $0xf012679b
f010c200:	e8 34 41 ff ff       	call   f0100339 <_panic>
f010c205:	8b 15 34 47 73 f0    	mov    0xf0734734,%edx
f010c20b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c20e:	89 50 08             	mov    %edx,0x8(%eax)
f010c211:	8b 45 08             	mov    0x8(%ebp),%eax
f010c214:	8b 40 08             	mov    0x8(%eax),%eax
f010c217:	85 c0                	test   %eax,%eax
f010c219:	74 0d                	je     f010c228 <free_environment+0x65>
f010c21b:	a1 34 47 73 f0       	mov    0xf0734734,%eax
f010c220:	8b 55 08             	mov    0x8(%ebp),%edx
f010c223:	89 50 0c             	mov    %edx,0xc(%eax)
f010c226:	eb 08                	jmp    f010c230 <free_environment+0x6d>
f010c228:	8b 45 08             	mov    0x8(%ebp),%eax
f010c22b:	a3 38 47 73 f0       	mov    %eax,0xf0734738
f010c230:	8b 45 08             	mov    0x8(%ebp),%eax
f010c233:	a3 34 47 73 f0       	mov    %eax,0xf0734734
f010c238:	8b 45 08             	mov    0x8(%ebp),%eax
f010c23b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c242:	a1 40 47 73 f0       	mov    0xf0734740,%eax
f010c247:	40                   	inc    %eax
f010c248:	a3 40 47 73 f0       	mov    %eax,0xf0734740
}
f010c24d:	90                   	nop
f010c24e:	c9                   	leave  
f010c24f:	c3                   	ret    

f010c250 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010c250:	55                   	push   %ebp
f010c251:	89 e5                	mov    %esp,%ebp
f010c253:	53                   	push   %ebx
f010c254:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010c257:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c25a:	8b 40 0c             	mov    0xc(%eax),%eax
f010c25d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010c260:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c263:	8b 40 08             	mov    0x8(%eax),%eax
f010c266:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010c269:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010c270:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010c273:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c276:	01 c2                	add    %eax,%edx
f010c278:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c27b:	01 d0                	add    %edx,%eax
f010c27d:	48                   	dec    %eax
f010c27e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c281:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c284:	ba 00 00 00 00       	mov    $0x0,%edx
f010c289:	f7 75 dc             	divl   -0x24(%ebp)
f010c28c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c28f:	29 d0                	sub    %edx,%eax
f010c291:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010c294:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c297:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010c29a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c29d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c2a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010c2a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010c2ac:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010c2b3:	8b 45 10             	mov    0x10(%ebp),%eax
f010c2b6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010c2bc:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010c2c3:	0f 85 f5 03 00 00    	jne    f010c6be <program_segment_alloc_map_copy_workingset+0x46e>
f010c2c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2cc:	83 c0 20             	add    $0x20,%eax
f010c2cf:	83 ec 08             	sub    $0x8,%esp
f010c2d2:	68 50 69 12 f0       	push   $0xf0126950
f010c2d7:	50                   	push   %eax
f010c2d8:	e8 4b 3e 01 00       	call   f0120128 <strcmp>
f010c2dd:	83 c4 10             	add    $0x10,%esp
f010c2e0:	85 c0                	test   %eax,%eax
f010c2e2:	0f 84 d6 03 00 00    	je     f010c6be <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010c2e8:	8b 45 14             	mov    0x14(%ebp),%eax
f010c2eb:	83 f8 06             	cmp    $0x6,%eax
f010c2ee:	76 05                	jbe    f010c2f5 <program_segment_alloc_map_copy_workingset+0xa5>
f010c2f0:	b8 06 00 00 00       	mov    $0x6,%eax
f010c2f5:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c2f8:	e9 c1 03 00 00       	jmp    f010c6be <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010c2fd:	83 ec 0c             	sub    $0xc,%esp
f010c300:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010c303:	50                   	push   %eax
f010c304:	e8 d4 c1 ff ff       	call   f01084dd <allocate_frame>
f010c309:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010c30c:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010c30f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c312:	8b 40 64             	mov    0x64(%eax),%eax
f010c315:	6a 06                	push   $0x6
f010c317:	ff 75 f4             	pushl  -0xc(%ebp)
f010c31a:	52                   	push   %edx
f010c31b:	50                   	push   %eax
f010c31c:	e8 8d c8 ff ff       	call   f0108bae <loadtime_map_frame>
f010c321:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c324:	83 ec 08             	sub    $0x8,%esp
f010c327:	ff 75 f4             	pushl  -0xc(%ebp)
f010c32a:	ff 75 08             	pushl  0x8(%ebp)
f010c32d:	e8 ad de ff ff       	call   f010a1df <env_page_ws_list_create_element>
f010c332:	83 c4 10             	add    $0x10,%esp
f010c335:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c338:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c33b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c342:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c346:	75 17                	jne    f010c35f <program_segment_alloc_map_copy_workingset+0x10f>
f010c348:	83 ec 04             	sub    $0x4,%esp
f010c34b:	68 00 68 12 f0       	push   $0xf0126800
f010c350:	68 ea 02 00 00       	push   $0x2ea
f010c355:	68 9b 67 12 f0       	push   $0xf012679b
f010c35a:	e8 da 3f ff ff       	call   f0100339 <_panic>
f010c35f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c362:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010c368:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c36b:	89 50 14             	mov    %edx,0x14(%eax)
f010c36e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c371:	8b 40 14             	mov    0x14(%eax),%eax
f010c374:	85 c0                	test   %eax,%eax
f010c376:	74 11                	je     f010c389 <program_segment_alloc_map_copy_workingset+0x139>
f010c378:	8b 45 08             	mov    0x8(%ebp),%eax
f010c37b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010c381:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c384:	89 50 10             	mov    %edx,0x10(%eax)
f010c387:	eb 0c                	jmp    f010c395 <program_segment_alloc_map_copy_workingset+0x145>
f010c389:	8b 45 08             	mov    0x8(%ebp),%eax
f010c38c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c38f:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c395:	8b 45 08             	mov    0x8(%ebp),%eax
f010c398:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c39b:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c3a1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c3a4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c3ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ae:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c3b4:	8d 50 01             	lea    0x1(%eax),%edx
f010c3b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ba:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c3c0:	83 ec 0c             	sub    $0xc,%esp
f010c3c3:	6a 02                	push   $0x2
f010c3c5:	e8 69 36 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010c3ca:	83 c4 10             	add    $0x10,%esp
f010c3cd:	85 c0                	test   %eax,%eax
f010c3cf:	0f 84 b3 01 00 00    	je     f010c588 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c3d5:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c3d9:	75 17                	jne    f010c3f2 <program_segment_alloc_map_copy_workingset+0x1a2>
f010c3db:	83 ec 04             	sub    $0x4,%esp
f010c3de:	68 23 68 12 f0       	push   $0xf0126823
f010c3e3:	68 f6 02 00 00       	push   $0x2f6
f010c3e8:	68 9b 67 12 f0       	push   $0xf012679b
f010c3ed:	e8 47 3f ff ff       	call   f0100339 <_panic>
f010c3f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c3f5:	8b 40 10             	mov    0x10(%eax),%eax
f010c3f8:	85 c0                	test   %eax,%eax
f010c3fa:	74 11                	je     f010c40d <program_segment_alloc_map_copy_workingset+0x1bd>
f010c3fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c3ff:	8b 40 10             	mov    0x10(%eax),%eax
f010c402:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c405:	8b 52 14             	mov    0x14(%edx),%edx
f010c408:	89 50 14             	mov    %edx,0x14(%eax)
f010c40b:	eb 0f                	jmp    f010c41c <program_segment_alloc_map_copy_workingset+0x1cc>
f010c40d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c410:	8b 50 14             	mov    0x14(%eax),%edx
f010c413:	8b 45 08             	mov    0x8(%ebp),%eax
f010c416:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c41c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c41f:	8b 40 14             	mov    0x14(%eax),%eax
f010c422:	85 c0                	test   %eax,%eax
f010c424:	74 11                	je     f010c437 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c426:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c429:	8b 40 14             	mov    0x14(%eax),%eax
f010c42c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c42f:	8b 52 10             	mov    0x10(%edx),%edx
f010c432:	89 50 10             	mov    %edx,0x10(%eax)
f010c435:	eb 0f                	jmp    f010c446 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c437:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c43a:	8b 50 10             	mov    0x10(%eax),%edx
f010c43d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c440:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c446:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c449:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c450:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c453:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c45a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c45d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c463:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c466:	8b 45 08             	mov    0x8(%ebp),%eax
f010c469:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c46f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c472:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010c478:	8b 45 08             	mov    0x8(%ebp),%eax
f010c47b:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c481:	48                   	dec    %eax
f010c482:	39 c2                	cmp    %eax,%edx
f010c484:	0f 83 80 00 00 00    	jae    f010c50a <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c48a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c48e:	75 17                	jne    f010c4a7 <program_segment_alloc_map_copy_workingset+0x257>
f010c490:	83 ec 04             	sub    $0x4,%esp
f010c493:	68 78 67 12 f0       	push   $0xf0126778
f010c498:	68 fa 02 00 00       	push   $0x2fa
f010c49d:	68 9b 67 12 f0       	push   $0xf012679b
f010c4a2:	e8 92 3e ff ff       	call   f0100339 <_panic>
f010c4a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4aa:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c4b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c4b3:	89 50 10             	mov    %edx,0x10(%eax)
f010c4b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c4b9:	8b 40 10             	mov    0x10(%eax),%eax
f010c4bc:	85 c0                	test   %eax,%eax
f010c4be:	74 11                	je     f010c4d1 <program_segment_alloc_map_copy_workingset+0x281>
f010c4c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4c3:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c4c9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4cc:	89 50 14             	mov    %edx,0x14(%eax)
f010c4cf:	eb 0c                	jmp    f010c4dd <program_segment_alloc_map_copy_workingset+0x28d>
f010c4d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4d4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4d7:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c4dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c4e3:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010c4e9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c4ec:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c4f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4f6:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010c4fc:	8d 50 01             	lea    0x1(%eax),%edx
f010c4ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010c502:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c508:	eb 7e                	jmp    f010c588 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c50a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c50e:	75 17                	jne    f010c527 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c510:	83 ec 04             	sub    $0x4,%esp
f010c513:	68 78 67 12 f0       	push   $0xf0126778
f010c518:	68 ff 02 00 00       	push   $0x2ff
f010c51d:	68 9b 67 12 f0       	push   $0xf012679b
f010c522:	e8 12 3e ff ff       	call   f0100339 <_panic>
f010c527:	8b 45 08             	mov    0x8(%ebp),%eax
f010c52a:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c530:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c533:	89 50 10             	mov    %edx,0x10(%eax)
f010c536:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c539:	8b 40 10             	mov    0x10(%eax),%eax
f010c53c:	85 c0                	test   %eax,%eax
f010c53e:	74 11                	je     f010c551 <program_segment_alloc_map_copy_workingset+0x301>
f010c540:	8b 45 08             	mov    0x8(%ebp),%eax
f010c543:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c549:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c54c:	89 50 14             	mov    %edx,0x14(%eax)
f010c54f:	eb 0c                	jmp    f010c55d <program_segment_alloc_map_copy_workingset+0x30d>
f010c551:	8b 45 08             	mov    0x8(%ebp),%eax
f010c554:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c557:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c55d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c560:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c563:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c569:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c56c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c573:	8b 45 08             	mov    0x8(%ebp),%eax
f010c576:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010c57c:	8d 50 01             	lea    0x1(%eax),%edx
f010c57f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c582:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c588:	8b 45 08             	mov    0x8(%ebp),%eax
f010c58b:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c591:	8b 45 08             	mov    0x8(%ebp),%eax
f010c594:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c59a:	39 c2                	cmp    %eax,%edx
f010c59c:	75 14                	jne    f010c5b2 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c59e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5a1:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c5a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5aa:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c5b0:	eb 0d                	jmp    f010c5bf <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c5b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5b5:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c5bc:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c5bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5c2:	c1 e8 16             	shr    $0x16,%eax
f010c5c5:	89 c2                	mov    %eax,%edx
f010c5c7:	8b 45 18             	mov    0x18(%ebp),%eax
f010c5ca:	8b 00                	mov    (%eax),%eax
f010c5cc:	39 c2                	cmp    %eax,%edx
f010c5ce:	0f 84 d3 00 00 00    	je     f010c6a7 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c5d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5d7:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c5dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5e0:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c5e3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c5e6:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c5eb:	89 c1                	mov    %eax,%ecx
f010c5ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c5f0:	89 d0                	mov    %edx,%eax
f010c5f2:	01 c0                	add    %eax,%eax
f010c5f4:	01 d0                	add    %edx,%eax
f010c5f6:	c1 e0 03             	shl    $0x3,%eax
f010c5f9:	01 d8                	add    %ebx,%eax
f010c5fb:	05 ac 00 00 00       	add    $0xac,%eax
f010c600:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c602:	8b 45 08             	mov    0x8(%ebp),%eax
f010c605:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c60b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c60e:	89 d0                	mov    %edx,%eax
f010c610:	01 c0                	add    %eax,%eax
f010c612:	01 d0                	add    %edx,%eax
f010c614:	c1 e0 03             	shl    $0x3,%eax
f010c617:	01 c8                	add    %ecx,%eax
f010c619:	05 b0 00 00 00       	add    $0xb0,%eax
f010c61e:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c621:	8b 45 08             	mov    0x8(%ebp),%eax
f010c624:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c62a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c62d:	89 d0                	mov    %edx,%eax
f010c62f:	01 c0                	add    %eax,%eax
f010c631:	01 d0                	add    %edx,%eax
f010c633:	c1 e0 03             	shl    $0x3,%eax
f010c636:	01 c8                	add    %ecx,%eax
f010c638:	05 b4 00 00 00       	add    $0xb4,%eax
f010c63d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c643:	8b 45 08             	mov    0x8(%ebp),%eax
f010c646:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c64c:	8d 50 01             	lea    0x1(%eax),%edx
f010c64f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c652:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c658:	8b 45 08             	mov    0x8(%ebp),%eax
f010c65b:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c661:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c666:	ba 00 00 00 00       	mov    $0x0,%edx
f010c66b:	f7 f1                	div    %ecx
f010c66d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c670:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010c676:	8b 45 08             	mov    0x8(%ebp),%eax
f010c679:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c67f:	85 c0                	test   %eax,%eax
f010c681:	75 17                	jne    f010c69a <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c683:	83 ec 04             	sub    $0x4,%esp
f010c686:	68 54 69 12 f0       	push   $0xf0126954
f010c68b:	68 27 03 00 00       	push   $0x327
f010c690:	68 9b 67 12 f0       	push   $0xf012679b
f010c695:	e8 9f 3c ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c69a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c69d:	c1 e8 16             	shr    $0x16,%eax
f010c6a0:	89 c2                	mov    %eax,%edx
f010c6a2:	8b 45 18             	mov    0x18(%ebp),%eax
f010c6a5:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c6a7:	8b 45 10             	mov    0x10(%ebp),%eax
f010c6aa:	8b 00                	mov    (%eax),%eax
f010c6ac:	8d 50 01             	lea    0x1(%eax),%edx
f010c6af:	8b 45 10             	mov    0x10(%ebp),%eax
f010c6b2:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c6b4:	ff 45 f0             	incl   -0x10(%ebp)
f010c6b7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c6be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6c1:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c6c4:	73 0c                	jae    f010c6d2 <program_segment_alloc_map_copy_workingset+0x482>
f010c6c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c6c9:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c6cc:	0f 82 2b fc ff ff    	jb     f010c2fd <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c6d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c6d5:	8b 00                	mov    (%eax),%eax
f010c6d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c6da:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c6dd:	8b 40 0c             	mov    0xc(%eax),%eax
f010c6e0:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c6e3:	eb 10                	jmp    f010c6f5 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c6e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c6e8:	8a 10                	mov    (%eax),%dl
f010c6ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c6ed:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c6ef:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c6f2:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c6f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c6f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c6fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c6fe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c703:	89 c2                	mov    %eax,%edx
f010c705:	8b 45 10             	mov    0x10(%ebp),%eax
f010c708:	8b 00                	mov    (%eax),%eax
f010c70a:	c1 e0 0c             	shl    $0xc,%eax
f010c70d:	01 c2                	add    %eax,%edx
f010c70f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c712:	39 c2                	cmp    %eax,%edx
f010c714:	76 1d                	jbe    f010c733 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c716:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c719:	8b 50 04             	mov    0x4(%eax),%edx
f010c71c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c71f:	01 c2                	add    %eax,%edx
f010c721:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c724:	39 c2                	cmp    %eax,%edx
f010c726:	77 bd                	ja     f010c6e5 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c728:	eb 09                	jmp    f010c733 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c72a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c72d:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c730:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c733:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c736:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c739:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c73c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c741:	89 c2                	mov    %eax,%edx
f010c743:	8b 45 10             	mov    0x10(%ebp),%eax
f010c746:	8b 00                	mov    (%eax),%eax
f010c748:	c1 e0 0c             	shl    $0xc,%eax
f010c74b:	01 c2                	add    %eax,%edx
f010c74d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c750:	39 c2                	cmp    %eax,%edx
f010c752:	77 d6                	ja     f010c72a <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c754:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c759:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c75c:	c9                   	leave  
f010c75d:	c3                   	ret    

f010c75e <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c75e:	55                   	push   %ebp
f010c75f:	89 e5                	mov    %esp,%ebp
f010c761:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c764:	83 ec 0c             	sub    $0xc,%esp
f010c767:	68 00 10 00 00       	push   $0x1000
f010c76c:	e8 5e d0 ff ff       	call   f01097cf <kmalloc>
f010c771:	83 c4 10             	add    $0x10,%esp
f010c774:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c777:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c77b:	75 17                	jne    f010c794 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c77d:	83 ec 04             	sub    $0x4,%esp
f010c780:	68 f7 69 12 f0       	push   $0xf01269f7
f010c785:	68 57 03 00 00       	push   $0x357
f010c78a:	68 9b 67 12 f0       	push   $0xf012679b
f010c78f:	e8 a5 3b ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c794:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c797:	c9                   	leave  
f010c798:	c3                   	ret    

f010c799 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c799:	55                   	push   %ebp
f010c79a:	89 e5                	mov    %esp,%ebp
f010c79c:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010c79f:	83 ec 0c             	sub    $0xc,%esp
f010c7a2:	68 00 80 00 00       	push   $0x8000
f010c7a7:	e8 23 d0 ff ff       	call   f01097cf <kmalloc>
f010c7ac:	83 c4 10             	add    $0x10,%esp
f010c7af:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010c7b2:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010c7b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c7bc:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010c7c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c7c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c7c7:	ba 00 00 00 00       	mov    $0x0,%edx
f010c7cc:	f7 75 ec             	divl   -0x14(%ebp)
f010c7cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c7d2:	29 d0                	sub    %edx,%eax
f010c7d4:	85 c0                	test   %eax,%eax
f010c7d6:	79 05                	jns    f010c7dd <create_user_kern_stack+0x44>
f010c7d8:	05 ff 0f 00 00       	add    $0xfff,%eax
f010c7dd:	c1 f8 0c             	sar    $0xc,%eax
f010c7e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010c7e3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010c7ea:	eb 72                	jmp    f010c85e <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010c7ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010c7f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c7f6:	c1 e0 0c             	shl    $0xc,%eax
f010c7f9:	89 c2                	mov    %eax,%edx
f010c7fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c7fe:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010c801:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f010c806:	83 ec 04             	sub    $0x4,%esp
f010c809:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010c80c:	52                   	push   %edx
f010c80d:	51                   	push   %ecx
f010c80e:	50                   	push   %eax
f010c80f:	e8 80 c2 ff ff       	call   f0108a94 <get_frame_info>
f010c814:	83 c4 10             	add    $0x10,%esp
f010c817:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010c81a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c81d:	c1 e0 0c             	shl    $0xc,%eax
f010c820:	89 c2                	mov    %eax,%edx
f010c822:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c825:	01 d0                	add    %edx,%eax
f010c827:	6a 01                	push   $0x1
f010c829:	50                   	push   %eax
f010c82a:	ff 75 e0             	pushl  -0x20(%ebp)
f010c82d:	ff 75 08             	pushl  0x8(%ebp)
f010c830:	e8 75 c1 ff ff       	call   f01089aa <map_frame>
f010c835:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010c838:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c83c:	75 1d                	jne    f010c85b <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010c83e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c841:	c1 e0 0c             	shl    $0xc,%eax
f010c844:	89 c2                	mov    %eax,%edx
f010c846:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c849:	01 d0                	add    %edx,%eax
f010c84b:	6a 01                	push   $0x1
f010c84d:	6a 00                	push   $0x0
f010c84f:	50                   	push   %eax
f010c850:	ff 75 08             	pushl  0x8(%ebp)
f010c853:	e8 51 d7 ff ff       	call   f0109fa9 <pt_set_page_permissions>
f010c858:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010c85b:	ff 45 f4             	incl   -0xc(%ebp)
f010c85e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c861:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010c864:	72 86                	jb     f010c7ec <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010c866:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010c869:	c9                   	leave  
f010c86a:	c3                   	ret    

f010c86b <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c86b:	55                   	push   %ebp
f010c86c:	89 e5                	mov    %esp,%ebp
f010c86e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c871:	83 ec 04             	sub    $0x4,%esp
f010c874:	68 14 6a 12 f0       	push   $0xf0126a14
f010c879:	68 8e 03 00 00       	push   $0x38e
f010c87e:	68 9b 67 12 f0       	push   $0xf012679b
f010c883:	e8 b1 3a ff ff       	call   f0100339 <_panic>

f010c888 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010c888:	55                   	push   %ebp
f010c889:	89 e5                	mov    %esp,%ebp
f010c88b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010c88e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c891:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c894:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010c897:	8b 45 08             	mov    0x8(%ebp),%eax
f010c89a:	8b 55 10             	mov    0x10(%ebp),%edx
f010c89d:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010c8a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8a3:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c8a6:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010c8a9:	83 ec 08             	sub    $0x8,%esp
f010c8ac:	6a 00                	push   $0x0
f010c8ae:	ff 75 0c             	pushl  0xc(%ebp)
f010c8b1:	e8 35 43 01 00       	call   f0120beb <initialize_dynamic_allocator>
f010c8b6:	83 c4 10             	add    $0x10,%esp
}
f010c8b9:	90                   	nop
f010c8ba:	c9                   	leave  
f010c8bb:	c3                   	ret    

f010c8bc <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c8bc:	55                   	push   %ebp
f010c8bd:	89 e5                	mov    %esp,%ebp
f010c8bf:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c8c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8c5:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c8c8:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c8cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8ce:	8b 55 10             	mov    0x10(%ebp),%edx
f010c8d1:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c8d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c8db:	eb 17                	jmp    f010c8f4 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c8dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e0:	8b 40 64             	mov    0x64(%eax),%eax
f010c8e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c8e6:	c1 e2 02             	shl    $0x2,%edx
f010c8e9:	01 d0                	add    %edx,%eax
f010c8eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c8f1:	ff 45 f4             	incl   -0xc(%ebp)
f010c8f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8f7:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c8fc:	76 df                	jbe    f010c8dd <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c8fe:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c905:	eb 22                	jmp    f010c929 <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c907:	8b 45 08             	mov    0x8(%ebp),%eax
f010c90a:	8b 40 64             	mov    0x64(%eax),%eax
f010c90d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c910:	c1 e2 02             	shl    $0x2,%edx
f010c913:	01 c2                	add    %eax,%edx
f010c915:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f010c91a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c91d:	c1 e1 02             	shl    $0x2,%ecx
f010c920:	01 c8                	add    %ecx,%eax
f010c922:	8b 00                	mov    (%eax),%eax
f010c924:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c926:	ff 45 f4             	incl   -0xc(%ebp)
f010c929:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c930:	7e d5                	jle    f010c907 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c932:	8b 45 08             	mov    0x8(%ebp),%eax
f010c935:	8b 40 64             	mov    0x64(%eax),%eax
f010c938:	83 ec 0c             	sub    $0xc,%esp
f010c93b:	50                   	push   %eax
f010c93c:	e8 58 fe ff ff       	call   f010c799 <create_user_kern_stack>
f010c941:	83 c4 10             	add    $0x10,%esp
f010c944:	89 c2                	mov    %eax,%edx
f010c946:	8b 45 08             	mov    0x8(%ebp),%eax
f010c949:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c94c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c94f:	8b 40 70             	mov    0x70(%eax),%eax
f010c952:	05 00 80 00 00       	add    $0x8000,%eax
f010c957:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c95a:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c95e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c961:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c964:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c966:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c96a:	ba aa e9 10 f0       	mov    $0xf010e9aa,%edx
f010c96f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c972:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c974:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c978:	8b 45 08             	mov    0x8(%ebp),%eax
f010c97b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c97e:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c981:	8b 45 08             	mov    0x8(%ebp),%eax
f010c984:	8b 40 04             	mov    0x4(%eax),%eax
f010c987:	83 ec 04             	sub    $0x4,%esp
f010c98a:	6a 20                	push   $0x20
f010c98c:	6a 00                	push   $0x0
f010c98e:	50                   	push   %eax
f010c98f:	e8 76 38 01 00       	call   f012020a <memset>
f010c994:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c997:	8b 45 08             	mov    0x8(%ebp),%eax
f010c99a:	8b 40 04             	mov    0x4(%eax),%eax
f010c99d:	ba 8b bc 10 f0       	mov    $0xf010bc8b,%edx
f010c9a2:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c9a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9a8:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c9af:	00 00 00 
f010c9b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9b5:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c9bc:	00 00 00 
f010c9bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9c2:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c9c9:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c9cc:	83 ec 0c             	sub    $0xc,%esp
f010c9cf:	6a 02                	push   $0x2
f010c9d1:	e8 5d 30 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010c9d6:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c9d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c9e0:	eb 54                	jmp    f010ca36 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c9e2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c9e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c9e8:	89 d0                	mov    %edx,%eax
f010c9ea:	01 c0                	add    %eax,%eax
f010c9ec:	01 d0                	add    %edx,%eax
f010c9ee:	c1 e0 03             	shl    $0x3,%eax
f010c9f1:	01 c8                	add    %ecx,%eax
f010c9f3:	05 ac 00 00 00       	add    $0xac,%eax
f010c9f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c9fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ca01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca04:	89 d0                	mov    %edx,%eax
f010ca06:	01 c0                	add    %eax,%eax
f010ca08:	01 d0                	add    %edx,%eax
f010ca0a:	c1 e0 03             	shl    $0x3,%eax
f010ca0d:	01 c8                	add    %ecx,%eax
f010ca0f:	05 b0 00 00 00       	add    $0xb0,%eax
f010ca14:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010ca17:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ca1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca1d:	89 d0                	mov    %edx,%eax
f010ca1f:	01 c0                	add    %eax,%eax
f010ca21:	01 d0                	add    %edx,%eax
f010ca23:	c1 e0 03             	shl    $0x3,%eax
f010ca26:	01 c8                	add    %ecx,%eax
f010ca28:	05 b4 00 00 00       	add    $0xb4,%eax
f010ca2d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010ca33:	ff 45 f4             	incl   -0xc(%ebp)
f010ca36:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ca3a:	7e a6                	jle    f010c9e2 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010ca3c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca3f:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010ca46:	00 00 00 

	e->pageFaultsCounter=0;
f010ca49:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca4c:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010ca53:	00 00 00 
	e->tableFaultsCounter=0;
f010ca56:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca59:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010ca60:	00 00 00 

	e->freeingFullWSCounter = 0;
f010ca63:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca66:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010ca6d:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010ca70:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca73:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010ca7a:	00 00 00 

	e->nModifiedPages=0;
f010ca7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca80:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010ca87:	00 00 00 
	e->nNotModifiedPages=0;
f010ca8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca8d:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010ca94:	00 00 00 
	e->nClocks = 0;
f010ca97:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca9a:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010caa1:	00 00 00 

	//2020
	e->nPageIn = 0;
f010caa4:	8b 45 08             	mov    0x8(%ebp),%eax
f010caa7:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010caae:	00 00 00 
	e->nPageOut = 0;
f010cab1:	8b 45 08             	mov    0x8(%ebp),%eax
f010cab4:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010cabb:	00 00 00 
	e->nNewPageAdded = 0;
f010cabe:	8b 45 08             	mov    0x8(%ebp),%eax
f010cac1:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010cac8:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010cacb:	83 ec 04             	sub    $0x4,%esp
f010cace:	68 00 00 00 82       	push   $0x82000000
f010cad3:	68 00 00 00 80       	push   $0x80000000
f010cad8:	ff 75 08             	pushl  0x8(%ebp)
f010cadb:	e8 a8 fd ff ff       	call   f010c888 <initialize_uheap_dynamic_allocator>
f010cae0:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010cae3:	83 ec 0c             	sub    $0xc,%esp
f010cae6:	ff 75 08             	pushl  0x8(%ebp)
f010cae9:	e8 06 00 00 00       	call   f010caf4 <complete_environment_initialization>
f010caee:	83 c4 10             	add    $0x10,%esp
}
f010caf1:	90                   	nop
f010caf2:	c9                   	leave  
f010caf3:	c3                   	ret    

f010caf4 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010caf4:	55                   	push   %ebp
f010caf5:	89 e5                	mov    %esp,%ebp
f010caf7:	53                   	push   %ebx
f010caf8:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010cafb:	8b 45 08             	mov    0x8(%ebp),%eax
f010cafe:	8b 40 64             	mov    0x64(%eax),%eax
f010cb01:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010cb07:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb0a:	8b 40 68             	mov    0x68(%eax),%eax
f010cb0d:	83 c8 03             	or     $0x3,%eax
f010cb10:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010cb12:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb15:	8b 40 64             	mov    0x64(%eax),%eax
f010cb18:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010cb1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb21:	8b 40 68             	mov    0x68(%eax),%eax
f010cb24:	83 c8 05             	or     $0x5,%eax
f010cb27:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010cb29:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb2c:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010cb33:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010cb36:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb39:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010cb40:	00 00 00 
	e->disk_env_tabledir = 0;
f010cb43:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb46:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010cb4d:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010cb50:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb53:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010cb5a:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010cb5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb60:	8b 58 10             	mov    0x10(%eax),%ebx
f010cb63:	83 ec 0c             	sub    $0xc,%esp
f010cb66:	68 ca 02 00 00       	push   $0x2ca
f010cb6b:	e8 3f 1a 01 00       	call   f011e5af <log2_ceil>
f010cb70:	83 c4 10             	add    $0x10,%esp
f010cb73:	ba 01 00 00 00       	mov    $0x1,%edx
f010cb78:	88 c1                	mov    %al,%cl
f010cb7a:	d3 e2                	shl    %cl,%edx
f010cb7c:	89 d0                	mov    %edx,%eax
f010cb7e:	01 d8                	add    %ebx,%eax
f010cb80:	89 c3                	mov    %eax,%ebx
f010cb82:	83 ec 0c             	sub    $0xc,%esp
f010cb85:	68 ca 02 00 00       	push   $0x2ca
f010cb8a:	e8 eb 19 01 00       	call   f011e57a <nearest_pow2_ceil>
f010cb8f:	83 c4 10             	add    $0x10,%esp
f010cb92:	f7 d8                	neg    %eax
f010cb94:	21 d8                	and    %ebx,%eax
f010cb96:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010cb99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cb9d:	7f 1e                	jg     f010cbbd <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010cb9f:	83 ec 0c             	sub    $0xc,%esp
f010cba2:	68 ca 02 00 00       	push   $0x2ca
f010cba7:	e8 03 1a 01 00       	call   f011e5af <log2_ceil>
f010cbac:	83 c4 10             	add    $0x10,%esp
f010cbaf:	ba 01 00 00 00       	mov    $0x1,%edx
f010cbb4:	88 c1                	mov    %al,%cl
f010cbb6:	d3 e2                	shl    %cl,%edx
f010cbb8:	89 d0                	mov    %edx,%eax
f010cbba:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010cbbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbc0:	8b 15 30 47 73 f0    	mov    0xf0734730,%edx
f010cbc6:	29 d0                	sub    %edx,%eax
f010cbc8:	c1 f8 02             	sar    $0x2,%eax
f010cbcb:	89 c2                	mov    %eax,%edx
f010cbcd:	89 d0                	mov    %edx,%eax
f010cbcf:	c1 e0 03             	shl    $0x3,%eax
f010cbd2:	01 d0                	add    %edx,%eax
f010cbd4:	c1 e0 03             	shl    $0x3,%eax
f010cbd7:	01 d0                	add    %edx,%eax
f010cbd9:	c1 e0 02             	shl    $0x2,%eax
f010cbdc:	01 d0                	add    %edx,%eax
f010cbde:	01 c0                	add    %eax,%eax
f010cbe0:	01 d0                	add    %edx,%eax
f010cbe2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010cbe9:	01 c8                	add    %ecx,%eax
f010cbeb:	c1 e0 02             	shl    $0x2,%eax
f010cbee:	01 d0                	add    %edx,%eax
f010cbf0:	c1 e0 03             	shl    $0x3,%eax
f010cbf3:	01 d0                	add    %edx,%eax
f010cbf5:	c1 e0 05             	shl    $0x5,%eax
f010cbf8:	29 d0                	sub    %edx,%eax
f010cbfa:	c1 e0 02             	shl    $0x2,%eax
f010cbfd:	01 d0                	add    %edx,%eax
f010cbff:	01 c0                	add    %eax,%eax
f010cc01:	01 d0                	add    %edx,%eax
f010cc03:	c1 e0 03             	shl    $0x3,%eax
f010cc06:	01 d0                	add    %edx,%eax
f010cc08:	c1 e0 04             	shl    $0x4,%eax
f010cc0b:	29 d0                	sub    %edx,%eax
f010cc0d:	0b 45 f4             	or     -0xc(%ebp),%eax
f010cc10:	89 c2                	mov    %eax,%edx
f010cc12:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc15:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010cc18:	e8 08 f1 ff ff       	call   f010bd25 <get_cpu_proc>
f010cc1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010cc20:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010cc24:	75 0c                	jne    f010cc32 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010cc26:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc29:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010cc30:	eb 0c                	jmp    f010cc3e <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010cc32:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cc35:	8b 50 10             	mov    0x10(%eax),%edx
f010cc38:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc3b:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010cc3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc41:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010cc48:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc4b:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010cc52:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010cc55:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc58:	8b 00                	mov    (%eax),%eax
f010cc5a:	83 ec 04             	sub    $0x4,%esp
f010cc5d:	6a 44                	push   $0x44
f010cc5f:	6a 00                	push   $0x0
f010cc61:	50                   	push   %eax
f010cc62:	e8 a3 35 01 00       	call   f012020a <memset>
f010cc67:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010cc6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc6d:	8b 00                	mov    (%eax),%eax
f010cc6f:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010cc75:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc78:	8b 00                	mov    (%eax),%eax
f010cc7a:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010cc80:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc83:	8b 00                	mov    (%eax),%eax
f010cc85:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010cc8b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc8e:	8b 00                	mov    (%eax),%eax
f010cc90:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010cc97:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc9a:	8b 00                	mov    (%eax),%eax
f010cc9c:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010cca2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cca5:	8b 00                	mov    (%eax),%eax
f010cca7:	8b 55 08             	mov    0x8(%ebp),%edx
f010ccaa:	8b 12                	mov    (%edx),%edx
f010ccac:	8b 52 38             	mov    0x38(%edx),%edx
f010ccaf:	80 ce 02             	or     $0x2,%dh
f010ccb2:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010ccb5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ccb9:	75 17                	jne    f010ccd2 <complete_environment_initialization+0x1de>
f010ccbb:	83 ec 04             	sub    $0x4,%esp
f010ccbe:	68 23 68 12 f0       	push   $0xf0126823
f010ccc3:	68 67 04 00 00       	push   $0x467
f010ccc8:	68 9b 67 12 f0       	push   $0xf012679b
f010cccd:	e8 67 36 ff ff       	call   f0100339 <_panic>
f010ccd2:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccd5:	8b 40 08             	mov    0x8(%eax),%eax
f010ccd8:	85 c0                	test   %eax,%eax
f010ccda:	74 11                	je     f010cced <complete_environment_initialization+0x1f9>
f010ccdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccdf:	8b 40 08             	mov    0x8(%eax),%eax
f010cce2:	8b 55 08             	mov    0x8(%ebp),%edx
f010cce5:	8b 52 0c             	mov    0xc(%edx),%edx
f010cce8:	89 50 0c             	mov    %edx,0xc(%eax)
f010cceb:	eb 0b                	jmp    f010ccf8 <complete_environment_initialization+0x204>
f010cced:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccf0:	8b 40 0c             	mov    0xc(%eax),%eax
f010ccf3:	a3 38 47 73 f0       	mov    %eax,0xf0734738
f010ccf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccfb:	8b 40 0c             	mov    0xc(%eax),%eax
f010ccfe:	85 c0                	test   %eax,%eax
f010cd00:	74 11                	je     f010cd13 <complete_environment_initialization+0x21f>
f010cd02:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd05:	8b 40 0c             	mov    0xc(%eax),%eax
f010cd08:	8b 55 08             	mov    0x8(%ebp),%edx
f010cd0b:	8b 52 08             	mov    0x8(%edx),%edx
f010cd0e:	89 50 08             	mov    %edx,0x8(%eax)
f010cd11:	eb 0b                	jmp    f010cd1e <complete_environment_initialization+0x22a>
f010cd13:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd16:	8b 40 08             	mov    0x8(%eax),%eax
f010cd19:	a3 34 47 73 f0       	mov    %eax,0xf0734734
f010cd1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd21:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010cd28:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd2b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010cd32:	a1 40 47 73 f0       	mov    0xf0734740,%eax
f010cd37:	48                   	dec    %eax
f010cd38:	a3 40 47 73 f0       	mov    %eax,0xf0734740
	return ;
f010cd3d:	90                   	nop
}
f010cd3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cd41:	c9                   	leave  
f010cd42:	c3                   	ret    

f010cd43 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010cd43:	55                   	push   %ebp
f010cd44:	89 e5                	mov    %esp,%ebp
f010cd46:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cd49:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cd4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd52:	8b 00                	mov    (%eax),%eax
f010cd54:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cd59:	74 17                	je     f010cd72 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010cd5b:	83 ec 04             	sub    $0x4,%esp
f010cd5e:	68 49 6a 12 f0       	push   $0xf0126a49
f010cd63:	68 73 04 00 00       	push   $0x473
f010cd68:	68 9b 67 12 f0       	push   $0xf012679b
f010cd6d:	e8 c7 35 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010cd72:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd75:	8b 00                	mov    (%eax),%eax
f010cd77:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd7a:	8b 52 18             	mov    0x18(%edx),%edx
f010cd7d:	89 50 30             	mov    %edx,0x30(%eax)
}
f010cd80:	90                   	nop
f010cd81:	c9                   	leave  
f010cd82:	c3                   	ret    

f010cd83 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010cd83:	55                   	push   %ebp
f010cd84:	89 e5                	mov    %esp,%ebp
f010cd86:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010cd89:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd8c:	8b 40 10             	mov    0x10(%eax),%eax
f010cd8f:	8d 48 01             	lea    0x1(%eax),%ecx
f010cd92:	8b 55 08             	mov    0x8(%ebp),%edx
f010cd95:	89 4a 10             	mov    %ecx,0x10(%edx)
f010cd98:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cd9b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cda1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cda4:	8b 00                	mov    (%eax),%eax
f010cda6:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cdab:	74 17                	je     f010cdc4 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010cdad:	83 ec 04             	sub    $0x4,%esp
f010cdb0:	68 49 6a 12 f0       	push   $0xf0126a49
f010cdb5:	68 81 04 00 00       	push   $0x481
f010cdba:	68 9b 67 12 f0       	push   $0xf012679b
f010cdbf:	e8 75 35 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cdc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cdc7:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cdca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cdcd:	01 d0                	add    %edx,%eax
f010cdcf:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010cdd2:	eb 0f                	jmp    f010cde3 <PROGRAM_SEGMENT_NEXT+0x60>
f010cdd4:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdd7:	8b 40 10             	mov    0x10(%eax),%eax
f010cdda:	8d 50 01             	lea    0x1(%eax),%edx
f010cddd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cde0:	89 50 10             	mov    %edx,0x10(%eax)
f010cde3:	8b 45 08             	mov    0x8(%ebp),%eax
f010cde6:	8b 40 10             	mov    0x10(%eax),%eax
f010cde9:	c1 e0 05             	shl    $0x5,%eax
f010cdec:	89 c2                	mov    %eax,%edx
f010cdee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cdf1:	01 d0                	add    %edx,%eax
f010cdf3:	8b 00                	mov    (%eax),%eax
f010cdf5:	83 f8 01             	cmp    $0x1,%eax
f010cdf8:	74 13                	je     f010ce0d <PROGRAM_SEGMENT_NEXT+0x8a>
f010cdfa:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdfd:	8b 50 10             	mov    0x10(%eax),%edx
f010ce00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ce03:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ce06:	0f b7 c0             	movzwl %ax,%eax
f010ce09:	39 c2                	cmp    %eax,%edx
f010ce0b:	72 c7                	jb     f010cdd4 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010ce0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce10:	8b 40 10             	mov    0x10(%eax),%eax
f010ce13:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010ce16:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ce19:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ce1c:	0f b7 c0             	movzwl %ax,%eax
f010ce1f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ce22:	7e 63                	jle    f010ce87 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010ce24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce27:	c1 e0 05             	shl    $0x5,%eax
f010ce2a:	89 c2                	mov    %eax,%edx
f010ce2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce2f:	01 d0                	add    %edx,%eax
f010ce31:	8b 50 04             	mov    0x4(%eax),%edx
f010ce34:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ce37:	01 c2                	add    %eax,%edx
f010ce39:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce3c:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010ce3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce41:	c1 e0 05             	shl    $0x5,%eax
f010ce44:	89 c2                	mov    %eax,%edx
f010ce46:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce49:	01 d0                	add    %edx,%eax
f010ce4b:	8b 50 14             	mov    0x14(%eax),%edx
f010ce4e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce51:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010ce54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce57:	c1 e0 05             	shl    $0x5,%eax
f010ce5a:	89 c2                	mov    %eax,%edx
f010ce5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce5f:	01 d0                	add    %edx,%eax
f010ce61:	8b 50 10             	mov    0x10(%eax),%edx
f010ce64:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce67:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010ce6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce6d:	c1 e0 05             	shl    $0x5,%eax
f010ce70:	89 c2                	mov    %eax,%edx
f010ce72:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ce75:	01 d0                	add    %edx,%eax
f010ce77:	8b 40 08             	mov    0x8(%eax),%eax
f010ce7a:	89 c2                	mov    %eax,%edx
f010ce7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce7f:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010ce82:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce85:	eb 05                	jmp    f010ce8c <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010ce87:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ce8c:	c9                   	leave  
f010ce8d:	c3                   	ret    

f010ce8e <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010ce8e:	55                   	push   %ebp
f010ce8f:	89 e5                	mov    %esp,%ebp
f010ce91:	57                   	push   %edi
f010ce92:	56                   	push   %esi
f010ce93:	53                   	push   %ebx
f010ce94:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010ce97:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ce9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cea1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cea4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cea7:	8b 00                	mov    (%eax),%eax
f010cea9:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ceae:	74 17                	je     f010cec7 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010ceb0:	83 ec 04             	sub    $0x4,%esp
f010ceb3:	68 49 6a 12 f0       	push   $0xf0126a49
f010ceb8:	68 9d 04 00 00       	push   $0x49d
f010cebd:	68 9b 67 12 f0       	push   $0xf012679b
f010cec2:	e8 72 34 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cec7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ceca:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cecd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ced0:	01 d0                	add    %edx,%eax
f010ced2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010ced5:	eb 07                	jmp    f010cede <PROGRAM_SEGMENT_FIRST+0x50>
f010ced7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ceda:	40                   	inc    %eax
f010cedb:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cede:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cee1:	c1 e0 05             	shl    $0x5,%eax
f010cee4:	89 c2                	mov    %eax,%edx
f010cee6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cee9:	01 d0                	add    %edx,%eax
f010ceeb:	8b 00                	mov    (%eax),%eax
f010ceed:	83 f8 01             	cmp    $0x1,%eax
f010cef0:	74 10                	je     f010cf02 <PROGRAM_SEGMENT_FIRST+0x74>
f010cef2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010cef5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cef8:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cefb:	0f b7 c0             	movzwl %ax,%eax
f010cefe:	39 c2                	cmp    %eax,%edx
f010cf00:	72 d5                	jb     f010ced7 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cf02:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cf05:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cf08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cf0b:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cf0e:	0f b7 c0             	movzwl %ax,%eax
f010cf11:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cf14:	7e 68                	jle    f010cf7e <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cf16:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf19:	c1 e0 05             	shl    $0x5,%eax
f010cf1c:	89 c2                	mov    %eax,%edx
f010cf1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf21:	01 d0                	add    %edx,%eax
f010cf23:	8b 50 04             	mov    0x4(%eax),%edx
f010cf26:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cf29:	01 d0                	add    %edx,%eax
f010cf2b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cf2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf31:	c1 e0 05             	shl    $0x5,%eax
f010cf34:	89 c2                	mov    %eax,%edx
f010cf36:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf39:	01 d0                	add    %edx,%eax
f010cf3b:	8b 40 14             	mov    0x14(%eax),%eax
f010cf3e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cf41:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf44:	c1 e0 05             	shl    $0x5,%eax
f010cf47:	89 c2                	mov    %eax,%edx
f010cf49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf4c:	01 d0                	add    %edx,%eax
f010cf4e:	8b 40 10             	mov    0x10(%eax),%eax
f010cf51:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cf54:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cf57:	c1 e0 05             	shl    $0x5,%eax
f010cf5a:	89 c2                	mov    %eax,%edx
f010cf5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cf5f:	01 d0                	add    %edx,%eax
f010cf61:	8b 40 08             	mov    0x8(%eax),%eax
f010cf64:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cf67:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf6a:	89 c3                	mov    %eax,%ebx
f010cf6c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cf6f:	ba 05 00 00 00       	mov    $0x5,%edx
f010cf74:	89 df                	mov    %ebx,%edi
f010cf76:	89 c6                	mov    %eax,%esi
f010cf78:	89 d1                	mov    %edx,%ecx
f010cf7a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cf7c:	eb 1c                	jmp    f010cf9a <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cf7e:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cf85:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf88:	89 c3                	mov    %eax,%ebx
f010cf8a:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cf8d:	ba 05 00 00 00       	mov    $0x5,%edx
f010cf92:	89 df                	mov    %ebx,%edi
f010cf94:	89 c6                	mov    %eax,%esi
f010cf96:	89 d1                	mov    %edx,%ecx
f010cf98:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cf9a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cfa0:	5b                   	pop    %ebx
f010cfa1:	5e                   	pop    %esi
f010cfa2:	5f                   	pop    %edi
f010cfa3:	5d                   	pop    %ebp
f010cfa4:	c2 04 00             	ret    $0x4

f010cfa7 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cfa7:	55                   	push   %ebp
f010cfa8:	89 e5                	mov    %esp,%ebp
f010cfaa:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cfad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010cfb4:	83 ec 0c             	sub    $0xc,%esp
f010cfb7:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f010cfbc:	e8 ad 30 00 00       	call   f011006e <acquire_spinlock>
f010cfc1:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cfc4:	a1 d0 d2 b5 f0       	mov    0xf0b5d2d0,%eax
f010cfc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cfcc:	e9 c3 00 00 00       	jmp    f010d094 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010cfd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfd4:	8b 40 0c             	mov    0xc(%eax),%eax
f010cfd7:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cfda:	0f 85 ac 00 00 00    	jne    f010d08c <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010cfe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfe3:	8b 50 10             	mov    0x10(%eax),%edx
f010cfe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfe9:	8b 40 0c             	mov    0xc(%eax),%eax
f010cfec:	8b 40 64             	mov    0x64(%eax),%eax
f010cfef:	83 ec 08             	sub    $0x8,%esp
f010cff2:	52                   	push   %edx
f010cff3:	50                   	push   %eax
f010cff4:	e8 bd d0 ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f010cff9:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cffc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d000:	75 17                	jne    f010d019 <cleanup_buffers+0x72>
f010d002:	83 ec 04             	sub    $0x4,%esp
f010d005:	68 23 68 12 f0       	push   $0xf0126823
f010d00a:	68 c6 04 00 00       	push   $0x4c6
f010d00f:	68 9b 67 12 f0       	push   $0xf012679b
f010d014:	e8 20 33 ff ff       	call   f0100339 <_panic>
f010d019:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d01c:	8b 00                	mov    (%eax),%eax
f010d01e:	85 c0                	test   %eax,%eax
f010d020:	74 10                	je     f010d032 <cleanup_buffers+0x8b>
f010d022:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d025:	8b 00                	mov    (%eax),%eax
f010d027:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d02a:	8b 52 04             	mov    0x4(%edx),%edx
f010d02d:	89 50 04             	mov    %edx,0x4(%eax)
f010d030:	eb 0b                	jmp    f010d03d <cleanup_buffers+0x96>
f010d032:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d035:	8b 40 04             	mov    0x4(%eax),%eax
f010d038:	a3 d4 d2 b5 f0       	mov    %eax,0xf0b5d2d4
f010d03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d040:	8b 40 04             	mov    0x4(%eax),%eax
f010d043:	85 c0                	test   %eax,%eax
f010d045:	74 0f                	je     f010d056 <cleanup_buffers+0xaf>
f010d047:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d04a:	8b 40 04             	mov    0x4(%eax),%eax
f010d04d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d050:	8b 12                	mov    (%edx),%edx
f010d052:	89 10                	mov    %edx,(%eax)
f010d054:	eb 0a                	jmp    f010d060 <cleanup_buffers+0xb9>
f010d056:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d059:	8b 00                	mov    (%eax),%eax
f010d05b:	a3 d0 d2 b5 f0       	mov    %eax,0xf0b5d2d0
f010d060:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d063:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010d069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d06c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010d073:	a1 dc d2 b5 f0       	mov    0xf0b5d2dc,%eax
f010d078:	48                   	dec    %eax
f010d079:	a3 dc d2 b5 f0       	mov    %eax,0xf0b5d2dc

				free_frame(ptr_fi);
f010d07e:	83 ec 0c             	sub    $0xc,%esp
f010d081:	ff 75 f4             	pushl  -0xc(%ebp)
f010d084:	e8 a8 b5 ff ff       	call   f0108631 <free_frame>
f010d089:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010d08c:	a1 d8 d2 b5 f0       	mov    0xf0b5d2d8,%eax
f010d091:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d094:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d098:	74 07                	je     f010d0a1 <cleanup_buffers+0xfa>
f010d09a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d09d:	8b 00                	mov    (%eax),%eax
f010d09f:	eb 05                	jmp    f010d0a6 <cleanup_buffers+0xff>
f010d0a1:	b8 00 00 00 00       	mov    $0x0,%eax
f010d0a6:	a3 d8 d2 b5 f0       	mov    %eax,0xf0b5d2d8
f010d0ab:	a1 d8 d2 b5 f0       	mov    0xf0b5d2d8,%eax
f010d0b0:	85 c0                	test   %eax,%eax
f010d0b2:	0f 85 19 ff ff ff    	jne    f010cfd1 <cleanup_buffers+0x2a>
f010d0b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d0bc:	0f 85 0f ff ff ff    	jne    f010cfd1 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010d0c2:	83 ec 0c             	sub    $0xc,%esp
f010d0c5:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f010d0ca:	e8 26 30 00 00       	call   f01100f5 <release_spinlock>
f010d0cf:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010d0d2:	90                   	nop
f010d0d3:	c9                   	leave  
f010d0d4:	c3                   	ret    

f010d0d5 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010d0d5:	55                   	push   %ebp
f010d0d6:	89 e5                	mov    %esp,%ebp
f010d0d8:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010d0db:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010d0df:	7e 06                	jle    f010d0e7 <set_program_priority+0x12>
f010d0e1:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d0e5:	7e 14                	jle    f010d0fb <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010d0e7:	83 ec 04             	sub    $0x4,%esp
f010d0ea:	68 60 6a 12 f0       	push   $0xf0126a60
f010d0ef:	6a 10                	push   $0x10
f010d0f1:	68 84 6a 12 f0       	push   $0xf0126a84
f010d0f6:	e8 3e 32 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010d0fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d0ff:	74 78                	je     f010d179 <set_program_priority+0xa4>
		return;
	switch(priority)
f010d101:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d105:	77 56                	ja     f010d15d <set_program_priority+0x88>
f010d107:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d10a:	c1 e0 02             	shl    $0x2,%eax
f010d10d:	05 c0 6a 12 f0       	add    $0xf0126ac0,%eax
f010d112:	8b 00                	mov    (%eax),%eax
f010d114:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010d116:	83 ec 08             	sub    $0x8,%esp
f010d119:	6a 01                	push   $0x1
f010d11b:	ff 75 08             	pushl  0x8(%ebp)
f010d11e:	e8 ea dc ff ff       	call   f010ae0d <half_WS_Size>
f010d123:	83 c4 10             	add    $0x10,%esp
			break;
f010d126:	eb 35                	jmp    f010d15d <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010d128:	83 ec 08             	sub    $0x8,%esp
f010d12b:	6a 00                	push   $0x0
f010d12d:	ff 75 08             	pushl  0x8(%ebp)
f010d130:	e8 d8 dc ff ff       	call   f010ae0d <half_WS_Size>
f010d135:	83 c4 10             	add    $0x10,%esp
			break;
f010d138:	eb 23                	jmp    f010d15d <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010d13a:	83 ec 08             	sub    $0x8,%esp
f010d13d:	6a 01                	push   $0x1
f010d13f:	ff 75 08             	pushl  0x8(%ebp)
f010d142:	e8 a9 dc ff ff       	call   f010adf0 <double_WS_Size>
f010d147:	83 c4 10             	add    $0x10,%esp
			break;
f010d14a:	eb 11                	jmp    f010d15d <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010d14c:	83 ec 08             	sub    $0x8,%esp
f010d14f:	6a 00                	push   $0x0
f010d151:	ff 75 08             	pushl  0x8(%ebp)
f010d154:	e8 97 dc ff ff       	call   f010adf0 <double_WS_Size>
f010d159:	83 c4 10             	add    $0x10,%esp
			break;
f010d15c:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010d15d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d160:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d166:	83 ec 08             	sub    $0x8,%esp
f010d169:	50                   	push   %eax
f010d16a:	68 a1 6a 12 f0       	push   $0xf0126aa1
f010d16f:	e8 17 3e ff ff       	call   f0100f8b <cprintf>
f010d174:	83 c4 10             	add    $0x10,%esp
f010d177:	eb 01                	jmp    f010d17a <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010d179:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010d17a:	c9                   	leave  
f010d17b:	c3                   	ret    

f010d17c <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010d17c:	55                   	push   %ebp
f010d17d:	89 e5                	mov    %esp,%ebp
f010d17f:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d182:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d189:	eb 29                	jmp    f010d1b4 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010d18b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d18e:	89 d0                	mov    %edx,%eax
f010d190:	01 c0                	add    %eax,%eax
f010d192:	01 d0                	add    %edx,%eax
f010d194:	c1 e0 02             	shl    $0x2,%eax
f010d197:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
f010d19c:	8b 00                	mov    (%eax),%eax
f010d19e:	83 ec 08             	sub    $0x8,%esp
f010d1a1:	50                   	push   %eax
f010d1a2:	ff 75 08             	pushl  0x8(%ebp)
f010d1a5:	e8 7e 2f 01 00       	call   f0120128 <strcmp>
f010d1aa:	83 c4 10             	add    $0x10,%esp
f010d1ad:	85 c0                	test   %eax,%eax
f010d1af:	74 0f                	je     f010d1c0 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d1b1:	ff 45 f4             	incl   -0xc(%ebp)
f010d1b4:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d1b9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d1bc:	7c cd                	jl     f010d18b <get_user_program_info+0xf>
f010d1be:	eb 01                	jmp    f010d1c1 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010d1c0:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d1c1:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d1c6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d1c9:	75 1a                	jne    f010d1e5 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010d1cb:	83 ec 08             	sub    $0x8,%esp
f010d1ce:	ff 75 08             	pushl  0x8(%ebp)
f010d1d1:	68 bd 79 12 f0       	push   $0xf01279bd
f010d1d6:	e8 b0 3d ff ff       	call   f0100f8b <cprintf>
f010d1db:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d1de:	b8 00 00 00 00       	mov    $0x0,%eax
f010d1e3:	eb 11                	jmp    f010d1f6 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010d1e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d1e8:	89 d0                	mov    %edx,%eax
f010d1ea:	01 c0                	add    %eax,%eax
f010d1ec:	01 d0                	add    %edx,%eax
f010d1ee:	c1 e0 02             	shl    $0x2,%eax
f010d1f1:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
}
f010d1f6:	c9                   	leave  
f010d1f7:	c3                   	ret    

f010d1f8 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010d1f8:	55                   	push   %ebp
f010d1f9:	89 e5                	mov    %esp,%ebp
f010d1fb:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d1fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d205:	eb 2d                	jmp    f010d234 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010d207:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d20a:	89 d0                	mov    %edx,%eax
f010d20c:	01 c0                	add    %eax,%eax
f010d20e:	01 d0                	add    %edx,%eax
f010d210:	c1 e0 02             	shl    $0x2,%eax
f010d213:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
f010d218:	8b 00                	mov    (%eax),%eax
f010d21a:	8b 55 08             	mov    0x8(%ebp),%edx
f010d21d:	83 c2 20             	add    $0x20,%edx
f010d220:	83 ec 08             	sub    $0x8,%esp
f010d223:	50                   	push   %eax
f010d224:	52                   	push   %edx
f010d225:	e8 fe 2e 01 00       	call   f0120128 <strcmp>
f010d22a:	83 c4 10             	add    $0x10,%esp
f010d22d:	85 c0                	test   %eax,%eax
f010d22f:	74 0f                	je     f010d240 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d231:	ff 45 f4             	incl   -0xc(%ebp)
f010d234:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d239:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d23c:	7c c9                	jl     f010d207 <get_user_program_info_by_env+0xf>
f010d23e:	eb 01                	jmp    f010d241 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010d240:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d241:	a1 4c 0d 18 f0       	mov    0xf0180d4c,%eax
f010d246:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d249:	75 17                	jne    f010d262 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010d24b:	83 ec 0c             	sub    $0xc,%esp
f010d24e:	68 d8 79 12 f0       	push   $0xf01279d8
f010d253:	e8 33 3d ff ff       	call   f0100f8b <cprintf>
f010d258:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d25b:	b8 00 00 00 00       	mov    $0x0,%eax
f010d260:	eb 11                	jmp    f010d273 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010d262:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d265:	89 d0                	mov    %edx,%eax
f010d267:	01 c0                	add    %eax,%eax
f010d269:	01 d0                	add    %edx,%eax
f010d26b:	c1 e0 02             	shl    $0x2,%eax
f010d26e:	05 a0 09 18 f0       	add    $0xf01809a0,%eax
}
f010d273:	c9                   	leave  
f010d274:	c3                   	ret    

f010d275 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010d275:	55                   	push   %ebp
f010d276:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010d278:	8b 45 08             	mov    0x8(%ebp),%eax
f010d27b:	83 f8 13             	cmp    $0x13,%eax
f010d27e:	77 0c                	ja     f010d28c <trapname+0x17>
		return excnames[trapno];
f010d280:	8b 45 08             	mov    0x8(%ebp),%eax
f010d283:	8b 04 85 c0 7d 12 f0 	mov    -0xfed8240(,%eax,4),%eax
f010d28a:	eb 2c                	jmp    f010d2b8 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010d28c:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010d290:	75 07                	jne    f010d299 <trapname+0x24>
		return "System call";
f010d292:	b8 00 7a 12 f0       	mov    $0xf0127a00,%eax
f010d297:	eb 1f                	jmp    f010d2b8 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010d299:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010d29d:	75 07                	jne    f010d2a6 <trapname+0x31>
		return "Clock Interrupt";
f010d29f:	b8 0c 7a 12 f0       	mov    $0xf0127a0c,%eax
f010d2a4:	eb 12                	jmp    f010d2b8 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010d2a6:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010d2aa:	75 07                	jne    f010d2b3 <trapname+0x3e>
		return "Keyboard Interrupt";
f010d2ac:	b8 1c 7a 12 f0       	mov    $0xf0127a1c,%eax
f010d2b1:	eb 05                	jmp    f010d2b8 <trapname+0x43>
	return "(unknown trap)";
f010d2b3:	b8 2f 7a 12 f0       	mov    $0xf0127a2f,%eax
}
f010d2b8:	5d                   	pop    %ebp
f010d2b9:	c3                   	ret    

f010d2ba <ts_init>:


void ts_init(void)
{
f010d2ba:	55                   	push   %ebp
f010d2bb:	89 e5                	mov    %esp,%ebp
f010d2bd:	53                   	push   %ebx
f010d2be:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010d2c1:	e8 34 a2 ff ff       	call   f01074fa <pushcli>

	struct cpu* c = mycpu();
f010d2c6:	e8 6c a1 ff ff       	call   f0107437 <mycpu>
f010d2cb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010d2ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2d1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010d2d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2db:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010d2e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d2e4:	83 c0 0c             	add    $0xc,%eax
f010d2e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d2ea:	83 c2 0c             	add    $0xc,%edx
f010d2ed:	c1 ea 10             	shr    $0x10,%edx
f010d2f0:	88 d3                	mov    %dl,%bl
f010d2f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d2f5:	83 c2 0c             	add    $0xc,%edx
f010d2f8:	c1 ea 18             	shr    $0x18,%edx
f010d2fb:	88 d1                	mov    %dl,%cl
f010d2fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d300:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d307:	68 00 
f010d309:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d30c:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d313:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d316:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d31c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d31f:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d325:	83 e2 f0             	and    $0xfffffff0,%edx
f010d328:	83 ca 09             	or     $0x9,%edx
f010d32b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d331:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d334:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d33a:	83 ca 10             	or     $0x10,%edx
f010d33d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d343:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d346:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d34c:	83 e2 9f             	and    $0xffffff9f,%edx
f010d34f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d355:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d358:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d35e:	83 ca 80             	or     $0xffffff80,%edx
f010d361:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d367:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d36a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d370:	83 e2 f0             	and    $0xfffffff0,%edx
f010d373:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d379:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d37c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d382:	83 e2 ef             	and    $0xffffffef,%edx
f010d385:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d38b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d38e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d394:	83 e2 df             	and    $0xffffffdf,%edx
f010d397:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d39d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3a0:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d3a6:	83 ca 40             	or     $0x40,%edx
f010d3a9:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d3af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3b2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d3b8:	83 e2 7f             	and    $0x7f,%edx
f010d3bb:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d3c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3c4:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d3ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d3cd:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d3d3:	83 e2 ef             	and    $0xffffffef,%edx
f010d3d6:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d3dc:	e8 6b a1 ff ff       	call   f010754c <popcli>
f010d3e1:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d3e7:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d3eb:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d3ee:	90                   	nop
f010d3ef:	83 c4 14             	add    $0x14,%esp
f010d3f2:	5b                   	pop    %ebx
f010d3f3:	5d                   	pop    %ebp
f010d3f4:	c3                   	ret    

f010d3f5 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d3f5:	55                   	push   %ebp
f010d3f6:	89 e5                	mov    %esp,%ebp
f010d3f8:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d3fb:	b8 a4 e8 10 f0       	mov    $0xf010e8a4,%eax
f010d400:	66 a3 a0 47 73 f0    	mov    %ax,0xf07347a0
f010d406:	66 c7 05 a2 47 73 f0 	movw   $0x8,0xf07347a2
f010d40d:	08 00 
f010d40f:	a0 a4 47 73 f0       	mov    0xf07347a4,%al
f010d414:	83 e0 e0             	and    $0xffffffe0,%eax
f010d417:	a2 a4 47 73 f0       	mov    %al,0xf07347a4
f010d41c:	a0 a4 47 73 f0       	mov    0xf07347a4,%al
f010d421:	83 e0 1f             	and    $0x1f,%eax
f010d424:	a2 a4 47 73 f0       	mov    %al,0xf07347a4
f010d429:	a0 a5 47 73 f0       	mov    0xf07347a5,%al
f010d42e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d431:	83 c8 0e             	or     $0xe,%eax
f010d434:	a2 a5 47 73 f0       	mov    %al,0xf07347a5
f010d439:	a0 a5 47 73 f0       	mov    0xf07347a5,%al
f010d43e:	83 e0 ef             	and    $0xffffffef,%eax
f010d441:	a2 a5 47 73 f0       	mov    %al,0xf07347a5
f010d446:	a0 a5 47 73 f0       	mov    0xf07347a5,%al
f010d44b:	83 e0 9f             	and    $0xffffff9f,%eax
f010d44e:	a2 a5 47 73 f0       	mov    %al,0xf07347a5
f010d453:	a0 a5 47 73 f0       	mov    0xf07347a5,%al
f010d458:	83 c8 80             	or     $0xffffff80,%eax
f010d45b:	a2 a5 47 73 f0       	mov    %al,0xf07347a5
f010d460:	b8 a4 e8 10 f0       	mov    $0xf010e8a4,%eax
f010d465:	c1 e8 10             	shr    $0x10,%eax
f010d468:	66 a3 a6 47 73 f0    	mov    %ax,0xf07347a6
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d46e:	b8 ac e8 10 f0       	mov    $0xf010e8ac,%eax
f010d473:	66 a3 d0 47 73 f0    	mov    %ax,0xf07347d0
f010d479:	66 c7 05 d2 47 73 f0 	movw   $0x8,0xf07347d2
f010d480:	08 00 
f010d482:	a0 d4 47 73 f0       	mov    0xf07347d4,%al
f010d487:	83 e0 e0             	and    $0xffffffe0,%eax
f010d48a:	a2 d4 47 73 f0       	mov    %al,0xf07347d4
f010d48f:	a0 d4 47 73 f0       	mov    0xf07347d4,%al
f010d494:	83 e0 1f             	and    $0x1f,%eax
f010d497:	a2 d4 47 73 f0       	mov    %al,0xf07347d4
f010d49c:	a0 d5 47 73 f0       	mov    0xf07347d5,%al
f010d4a1:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4a4:	83 c8 0e             	or     $0xe,%eax
f010d4a7:	a2 d5 47 73 f0       	mov    %al,0xf07347d5
f010d4ac:	a0 d5 47 73 f0       	mov    0xf07347d5,%al
f010d4b1:	83 e0 ef             	and    $0xffffffef,%eax
f010d4b4:	a2 d5 47 73 f0       	mov    %al,0xf07347d5
f010d4b9:	a0 d5 47 73 f0       	mov    0xf07347d5,%al
f010d4be:	83 e0 9f             	and    $0xffffff9f,%eax
f010d4c1:	a2 d5 47 73 f0       	mov    %al,0xf07347d5
f010d4c6:	a0 d5 47 73 f0       	mov    0xf07347d5,%al
f010d4cb:	83 c8 80             	or     $0xffffff80,%eax
f010d4ce:	a2 d5 47 73 f0       	mov    %al,0xf07347d5
f010d4d3:	b8 ac e8 10 f0       	mov    $0xf010e8ac,%eax
f010d4d8:	c1 e8 10             	shr    $0x10,%eax
f010d4db:	66 a3 d6 47 73 f0    	mov    %ax,0xf07347d6
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d4e1:	b8 b4 e8 10 f0       	mov    $0xf010e8b4,%eax
f010d4e6:	66 a3 60 48 73 f0    	mov    %ax,0xf0734860
f010d4ec:	66 c7 05 62 48 73 f0 	movw   $0x8,0xf0734862
f010d4f3:	08 00 
f010d4f5:	a0 64 48 73 f0       	mov    0xf0734864,%al
f010d4fa:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4fd:	a2 64 48 73 f0       	mov    %al,0xf0734864
f010d502:	a0 64 48 73 f0       	mov    0xf0734864,%al
f010d507:	83 e0 1f             	and    $0x1f,%eax
f010d50a:	a2 64 48 73 f0       	mov    %al,0xf0734864
f010d50f:	a0 65 48 73 f0       	mov    0xf0734865,%al
f010d514:	83 e0 f0             	and    $0xfffffff0,%eax
f010d517:	83 c8 0e             	or     $0xe,%eax
f010d51a:	a2 65 48 73 f0       	mov    %al,0xf0734865
f010d51f:	a0 65 48 73 f0       	mov    0xf0734865,%al
f010d524:	83 e0 ef             	and    $0xffffffef,%eax
f010d527:	a2 65 48 73 f0       	mov    %al,0xf0734865
f010d52c:	a0 65 48 73 f0       	mov    0xf0734865,%al
f010d531:	83 c8 60             	or     $0x60,%eax
f010d534:	a2 65 48 73 f0       	mov    %al,0xf0734865
f010d539:	a0 65 48 73 f0       	mov    0xf0734865,%al
f010d53e:	83 c8 80             	or     $0xffffff80,%eax
f010d541:	a2 65 48 73 f0       	mov    %al,0xf0734865
f010d546:	b8 b4 e8 10 f0       	mov    $0xf010e8b4,%eax
f010d54b:	c1 e8 10             	shr    $0x10,%eax
f010d54e:	66 a3 66 48 73 f0    	mov    %ax,0xf0734866
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d554:	b8 be e8 10 f0       	mov    $0xf010e8be,%eax
f010d559:	66 a3 68 48 73 f0    	mov    %ax,0xf0734868
f010d55f:	66 c7 05 6a 48 73 f0 	movw   $0x8,0xf073486a
f010d566:	08 00 
f010d568:	a0 6c 48 73 f0       	mov    0xf073486c,%al
f010d56d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d570:	a2 6c 48 73 f0       	mov    %al,0xf073486c
f010d575:	a0 6c 48 73 f0       	mov    0xf073486c,%al
f010d57a:	83 e0 1f             	and    $0x1f,%eax
f010d57d:	a2 6c 48 73 f0       	mov    %al,0xf073486c
f010d582:	a0 6d 48 73 f0       	mov    0xf073486d,%al
f010d587:	83 e0 f0             	and    $0xfffffff0,%eax
f010d58a:	83 c8 0e             	or     $0xe,%eax
f010d58d:	a2 6d 48 73 f0       	mov    %al,0xf073486d
f010d592:	a0 6d 48 73 f0       	mov    0xf073486d,%al
f010d597:	83 e0 ef             	and    $0xffffffef,%eax
f010d59a:	a2 6d 48 73 f0       	mov    %al,0xf073486d
f010d59f:	a0 6d 48 73 f0       	mov    0xf073486d,%al
f010d5a4:	83 c8 60             	or     $0x60,%eax
f010d5a7:	a2 6d 48 73 f0       	mov    %al,0xf073486d
f010d5ac:	a0 6d 48 73 f0       	mov    0xf073486d,%al
f010d5b1:	83 c8 80             	or     $0xffffff80,%eax
f010d5b4:	a2 6d 48 73 f0       	mov    %al,0xf073486d
f010d5b9:	b8 be e8 10 f0       	mov    $0xf010e8be,%eax
f010d5be:	c1 e8 10             	shr    $0x10,%eax
f010d5c1:	66 a3 6e 48 73 f0    	mov    %ax,0xf073486e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d5c7:	b8 c8 e8 10 f0       	mov    $0xf010e8c8,%eax
f010d5cc:	66 a3 e0 48 73 f0    	mov    %ax,0xf07348e0
f010d5d2:	66 c7 05 e2 48 73 f0 	movw   $0x8,0xf07348e2
f010d5d9:	08 00 
f010d5db:	a0 e4 48 73 f0       	mov    0xf07348e4,%al
f010d5e0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5e3:	a2 e4 48 73 f0       	mov    %al,0xf07348e4
f010d5e8:	a0 e4 48 73 f0       	mov    0xf07348e4,%al
f010d5ed:	83 e0 1f             	and    $0x1f,%eax
f010d5f0:	a2 e4 48 73 f0       	mov    %al,0xf07348e4
f010d5f5:	a0 e5 48 73 f0       	mov    0xf07348e5,%al
f010d5fa:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5fd:	83 c8 0e             	or     $0xe,%eax
f010d600:	a2 e5 48 73 f0       	mov    %al,0xf07348e5
f010d605:	a0 e5 48 73 f0       	mov    0xf07348e5,%al
f010d60a:	83 e0 ef             	and    $0xffffffef,%eax
f010d60d:	a2 e5 48 73 f0       	mov    %al,0xf07348e5
f010d612:	a0 e5 48 73 f0       	mov    0xf07348e5,%al
f010d617:	83 c8 60             	or     $0x60,%eax
f010d61a:	a2 e5 48 73 f0       	mov    %al,0xf07348e5
f010d61f:	a0 e5 48 73 f0       	mov    0xf07348e5,%al
f010d624:	83 c8 80             	or     $0xffffff80,%eax
f010d627:	a2 e5 48 73 f0       	mov    %al,0xf07348e5
f010d62c:	b8 c8 e8 10 f0       	mov    $0xf010e8c8,%eax
f010d631:	c1 e8 10             	shr    $0x10,%eax
f010d634:	66 a3 e6 48 73 f0    	mov    %ax,0xf07348e6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d63a:	b8 d2 e8 10 f0       	mov    $0xf010e8d2,%eax
f010d63f:	66 a3 60 47 73 f0    	mov    %ax,0xf0734760
f010d645:	66 c7 05 62 47 73 f0 	movw   $0x8,0xf0734762
f010d64c:	08 00 
f010d64e:	a0 64 47 73 f0       	mov    0xf0734764,%al
f010d653:	83 e0 e0             	and    $0xffffffe0,%eax
f010d656:	a2 64 47 73 f0       	mov    %al,0xf0734764
f010d65b:	a0 64 47 73 f0       	mov    0xf0734764,%al
f010d660:	83 e0 1f             	and    $0x1f,%eax
f010d663:	a2 64 47 73 f0       	mov    %al,0xf0734764
f010d668:	a0 65 47 73 f0       	mov    0xf0734765,%al
f010d66d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d670:	83 c8 0e             	or     $0xe,%eax
f010d673:	a2 65 47 73 f0       	mov    %al,0xf0734765
f010d678:	a0 65 47 73 f0       	mov    0xf0734765,%al
f010d67d:	83 e0 ef             	and    $0xffffffef,%eax
f010d680:	a2 65 47 73 f0       	mov    %al,0xf0734765
f010d685:	a0 65 47 73 f0       	mov    0xf0734765,%al
f010d68a:	83 c8 60             	or     $0x60,%eax
f010d68d:	a2 65 47 73 f0       	mov    %al,0xf0734765
f010d692:	a0 65 47 73 f0       	mov    0xf0734765,%al
f010d697:	83 c8 80             	or     $0xffffff80,%eax
f010d69a:	a2 65 47 73 f0       	mov    %al,0xf0734765
f010d69f:	b8 d2 e8 10 f0       	mov    $0xf010e8d2,%eax
f010d6a4:	c1 e8 10             	shr    $0x10,%eax
f010d6a7:	66 a3 66 47 73 f0    	mov    %ax,0xf0734766
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d6ad:	b8 dc e8 10 f0       	mov    $0xf010e8dc,%eax
f010d6b2:	66 a3 68 47 73 f0    	mov    %ax,0xf0734768
f010d6b8:	66 c7 05 6a 47 73 f0 	movw   $0x8,0xf073476a
f010d6bf:	08 00 
f010d6c1:	a0 6c 47 73 f0       	mov    0xf073476c,%al
f010d6c6:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6c9:	a2 6c 47 73 f0       	mov    %al,0xf073476c
f010d6ce:	a0 6c 47 73 f0       	mov    0xf073476c,%al
f010d6d3:	83 e0 1f             	and    $0x1f,%eax
f010d6d6:	a2 6c 47 73 f0       	mov    %al,0xf073476c
f010d6db:	a0 6d 47 73 f0       	mov    0xf073476d,%al
f010d6e0:	83 c8 0f             	or     $0xf,%eax
f010d6e3:	a2 6d 47 73 f0       	mov    %al,0xf073476d
f010d6e8:	a0 6d 47 73 f0       	mov    0xf073476d,%al
f010d6ed:	83 e0 ef             	and    $0xffffffef,%eax
f010d6f0:	a2 6d 47 73 f0       	mov    %al,0xf073476d
f010d6f5:	a0 6d 47 73 f0       	mov    0xf073476d,%al
f010d6fa:	83 c8 60             	or     $0x60,%eax
f010d6fd:	a2 6d 47 73 f0       	mov    %al,0xf073476d
f010d702:	a0 6d 47 73 f0       	mov    0xf073476d,%al
f010d707:	83 c8 80             	or     $0xffffff80,%eax
f010d70a:	a2 6d 47 73 f0       	mov    %al,0xf073476d
f010d70f:	b8 dc e8 10 f0       	mov    $0xf010e8dc,%eax
f010d714:	c1 e8 10             	shr    $0x10,%eax
f010d717:	66 a3 6e 47 73 f0    	mov    %ax,0xf073476e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d71d:	b8 e6 e8 10 f0       	mov    $0xf010e8e6,%eax
f010d722:	66 a3 70 47 73 f0    	mov    %ax,0xf0734770
f010d728:	66 c7 05 72 47 73 f0 	movw   $0x8,0xf0734772
f010d72f:	08 00 
f010d731:	a0 74 47 73 f0       	mov    0xf0734774,%al
f010d736:	83 e0 e0             	and    $0xffffffe0,%eax
f010d739:	a2 74 47 73 f0       	mov    %al,0xf0734774
f010d73e:	a0 74 47 73 f0       	mov    0xf0734774,%al
f010d743:	83 e0 1f             	and    $0x1f,%eax
f010d746:	a2 74 47 73 f0       	mov    %al,0xf0734774
f010d74b:	a0 75 47 73 f0       	mov    0xf0734775,%al
f010d750:	83 e0 f0             	and    $0xfffffff0,%eax
f010d753:	83 c8 0e             	or     $0xe,%eax
f010d756:	a2 75 47 73 f0       	mov    %al,0xf0734775
f010d75b:	a0 75 47 73 f0       	mov    0xf0734775,%al
f010d760:	83 e0 ef             	and    $0xffffffef,%eax
f010d763:	a2 75 47 73 f0       	mov    %al,0xf0734775
f010d768:	a0 75 47 73 f0       	mov    0xf0734775,%al
f010d76d:	83 c8 60             	or     $0x60,%eax
f010d770:	a2 75 47 73 f0       	mov    %al,0xf0734775
f010d775:	a0 75 47 73 f0       	mov    0xf0734775,%al
f010d77a:	83 c8 80             	or     $0xffffff80,%eax
f010d77d:	a2 75 47 73 f0       	mov    %al,0xf0734775
f010d782:	b8 e6 e8 10 f0       	mov    $0xf010e8e6,%eax
f010d787:	c1 e8 10             	shr    $0x10,%eax
f010d78a:	66 a3 76 47 73 f0    	mov    %ax,0xf0734776
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d790:	b8 f0 e8 10 f0       	mov    $0xf010e8f0,%eax
f010d795:	66 a3 78 47 73 f0    	mov    %ax,0xf0734778
f010d79b:	66 c7 05 7a 47 73 f0 	movw   $0x8,0xf073477a
f010d7a2:	08 00 
f010d7a4:	a0 7c 47 73 f0       	mov    0xf073477c,%al
f010d7a9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7ac:	a2 7c 47 73 f0       	mov    %al,0xf073477c
f010d7b1:	a0 7c 47 73 f0       	mov    0xf073477c,%al
f010d7b6:	83 e0 1f             	and    $0x1f,%eax
f010d7b9:	a2 7c 47 73 f0       	mov    %al,0xf073477c
f010d7be:	a0 7d 47 73 f0       	mov    0xf073477d,%al
f010d7c3:	83 c8 0f             	or     $0xf,%eax
f010d7c6:	a2 7d 47 73 f0       	mov    %al,0xf073477d
f010d7cb:	a0 7d 47 73 f0       	mov    0xf073477d,%al
f010d7d0:	83 e0 ef             	and    $0xffffffef,%eax
f010d7d3:	a2 7d 47 73 f0       	mov    %al,0xf073477d
f010d7d8:	a0 7d 47 73 f0       	mov    0xf073477d,%al
f010d7dd:	83 c8 60             	or     $0x60,%eax
f010d7e0:	a2 7d 47 73 f0       	mov    %al,0xf073477d
f010d7e5:	a0 7d 47 73 f0       	mov    0xf073477d,%al
f010d7ea:	83 c8 80             	or     $0xffffff80,%eax
f010d7ed:	a2 7d 47 73 f0       	mov    %al,0xf073477d
f010d7f2:	b8 f0 e8 10 f0       	mov    $0xf010e8f0,%eax
f010d7f7:	c1 e8 10             	shr    $0x10,%eax
f010d7fa:	66 a3 7e 47 73 f0    	mov    %ax,0xf073477e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d800:	b8 fa e8 10 f0       	mov    $0xf010e8fa,%eax
f010d805:	66 a3 80 47 73 f0    	mov    %ax,0xf0734780
f010d80b:	66 c7 05 82 47 73 f0 	movw   $0x8,0xf0734782
f010d812:	08 00 
f010d814:	a0 84 47 73 f0       	mov    0xf0734784,%al
f010d819:	83 e0 e0             	and    $0xffffffe0,%eax
f010d81c:	a2 84 47 73 f0       	mov    %al,0xf0734784
f010d821:	a0 84 47 73 f0       	mov    0xf0734784,%al
f010d826:	83 e0 1f             	and    $0x1f,%eax
f010d829:	a2 84 47 73 f0       	mov    %al,0xf0734784
f010d82e:	a0 85 47 73 f0       	mov    0xf0734785,%al
f010d833:	83 c8 0f             	or     $0xf,%eax
f010d836:	a2 85 47 73 f0       	mov    %al,0xf0734785
f010d83b:	a0 85 47 73 f0       	mov    0xf0734785,%al
f010d840:	83 e0 ef             	and    $0xffffffef,%eax
f010d843:	a2 85 47 73 f0       	mov    %al,0xf0734785
f010d848:	a0 85 47 73 f0       	mov    0xf0734785,%al
f010d84d:	83 c8 60             	or     $0x60,%eax
f010d850:	a2 85 47 73 f0       	mov    %al,0xf0734785
f010d855:	a0 85 47 73 f0       	mov    0xf0734785,%al
f010d85a:	83 c8 80             	or     $0xffffff80,%eax
f010d85d:	a2 85 47 73 f0       	mov    %al,0xf0734785
f010d862:	b8 fa e8 10 f0       	mov    $0xf010e8fa,%eax
f010d867:	c1 e8 10             	shr    $0x10,%eax
f010d86a:	66 a3 86 47 73 f0    	mov    %ax,0xf0734786
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d870:	b8 04 e9 10 f0       	mov    $0xf010e904,%eax
f010d875:	66 a3 88 47 73 f0    	mov    %ax,0xf0734788
f010d87b:	66 c7 05 8a 47 73 f0 	movw   $0x8,0xf073478a
f010d882:	08 00 
f010d884:	a0 8c 47 73 f0       	mov    0xf073478c,%al
f010d889:	83 e0 e0             	and    $0xffffffe0,%eax
f010d88c:	a2 8c 47 73 f0       	mov    %al,0xf073478c
f010d891:	a0 8c 47 73 f0       	mov    0xf073478c,%al
f010d896:	83 e0 1f             	and    $0x1f,%eax
f010d899:	a2 8c 47 73 f0       	mov    %al,0xf073478c
f010d89e:	a0 8d 47 73 f0       	mov    0xf073478d,%al
f010d8a3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8a6:	83 c8 0e             	or     $0xe,%eax
f010d8a9:	a2 8d 47 73 f0       	mov    %al,0xf073478d
f010d8ae:	a0 8d 47 73 f0       	mov    0xf073478d,%al
f010d8b3:	83 e0 ef             	and    $0xffffffef,%eax
f010d8b6:	a2 8d 47 73 f0       	mov    %al,0xf073478d
f010d8bb:	a0 8d 47 73 f0       	mov    0xf073478d,%al
f010d8c0:	83 c8 60             	or     $0x60,%eax
f010d8c3:	a2 8d 47 73 f0       	mov    %al,0xf073478d
f010d8c8:	a0 8d 47 73 f0       	mov    0xf073478d,%al
f010d8cd:	83 c8 80             	or     $0xffffff80,%eax
f010d8d0:	a2 8d 47 73 f0       	mov    %al,0xf073478d
f010d8d5:	b8 04 e9 10 f0       	mov    $0xf010e904,%eax
f010d8da:	c1 e8 10             	shr    $0x10,%eax
f010d8dd:	66 a3 8e 47 73 f0    	mov    %ax,0xf073478e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d8e3:	b8 0e e9 10 f0       	mov    $0xf010e90e,%eax
f010d8e8:	66 a3 90 47 73 f0    	mov    %ax,0xf0734790
f010d8ee:	66 c7 05 92 47 73 f0 	movw   $0x8,0xf0734792
f010d8f5:	08 00 
f010d8f7:	a0 94 47 73 f0       	mov    0xf0734794,%al
f010d8fc:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8ff:	a2 94 47 73 f0       	mov    %al,0xf0734794
f010d904:	a0 94 47 73 f0       	mov    0xf0734794,%al
f010d909:	83 e0 1f             	and    $0x1f,%eax
f010d90c:	a2 94 47 73 f0       	mov    %al,0xf0734794
f010d911:	a0 95 47 73 f0       	mov    0xf0734795,%al
f010d916:	83 e0 f0             	and    $0xfffffff0,%eax
f010d919:	83 c8 0e             	or     $0xe,%eax
f010d91c:	a2 95 47 73 f0       	mov    %al,0xf0734795
f010d921:	a0 95 47 73 f0       	mov    0xf0734795,%al
f010d926:	83 e0 ef             	and    $0xffffffef,%eax
f010d929:	a2 95 47 73 f0       	mov    %al,0xf0734795
f010d92e:	a0 95 47 73 f0       	mov    0xf0734795,%al
f010d933:	83 c8 60             	or     $0x60,%eax
f010d936:	a2 95 47 73 f0       	mov    %al,0xf0734795
f010d93b:	a0 95 47 73 f0       	mov    0xf0734795,%al
f010d940:	83 c8 80             	or     $0xffffff80,%eax
f010d943:	a2 95 47 73 f0       	mov    %al,0xf0734795
f010d948:	b8 0e e9 10 f0       	mov    $0xf010e90e,%eax
f010d94d:	c1 e8 10             	shr    $0x10,%eax
f010d950:	66 a3 96 47 73 f0    	mov    %ax,0xf0734796
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d956:	b8 18 e9 10 f0       	mov    $0xf010e918,%eax
f010d95b:	66 a3 98 47 73 f0    	mov    %ax,0xf0734798
f010d961:	66 c7 05 9a 47 73 f0 	movw   $0x8,0xf073479a
f010d968:	08 00 
f010d96a:	a0 9c 47 73 f0       	mov    0xf073479c,%al
f010d96f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d972:	a2 9c 47 73 f0       	mov    %al,0xf073479c
f010d977:	a0 9c 47 73 f0       	mov    0xf073479c,%al
f010d97c:	83 e0 1f             	and    $0x1f,%eax
f010d97f:	a2 9c 47 73 f0       	mov    %al,0xf073479c
f010d984:	a0 9d 47 73 f0       	mov    0xf073479d,%al
f010d989:	83 e0 f0             	and    $0xfffffff0,%eax
f010d98c:	83 c8 0e             	or     $0xe,%eax
f010d98f:	a2 9d 47 73 f0       	mov    %al,0xf073479d
f010d994:	a0 9d 47 73 f0       	mov    0xf073479d,%al
f010d999:	83 e0 ef             	and    $0xffffffef,%eax
f010d99c:	a2 9d 47 73 f0       	mov    %al,0xf073479d
f010d9a1:	a0 9d 47 73 f0       	mov    0xf073479d,%al
f010d9a6:	83 c8 60             	or     $0x60,%eax
f010d9a9:	a2 9d 47 73 f0       	mov    %al,0xf073479d
f010d9ae:	a0 9d 47 73 f0       	mov    0xf073479d,%al
f010d9b3:	83 c8 80             	or     $0xffffff80,%eax
f010d9b6:	a2 9d 47 73 f0       	mov    %al,0xf073479d
f010d9bb:	b8 18 e9 10 f0       	mov    $0xf010e918,%eax
f010d9c0:	c1 e8 10             	shr    $0x10,%eax
f010d9c3:	66 a3 9e 47 73 f0    	mov    %ax,0xf073479e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d9c9:	b8 1e e9 10 f0       	mov    $0xf010e91e,%eax
f010d9ce:	66 a3 b0 47 73 f0    	mov    %ax,0xf07347b0
f010d9d4:	66 c7 05 b2 47 73 f0 	movw   $0x8,0xf07347b2
f010d9db:	08 00 
f010d9dd:	a0 b4 47 73 f0       	mov    0xf07347b4,%al
f010d9e2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9e5:	a2 b4 47 73 f0       	mov    %al,0xf07347b4
f010d9ea:	a0 b4 47 73 f0       	mov    0xf07347b4,%al
f010d9ef:	83 e0 1f             	and    $0x1f,%eax
f010d9f2:	a2 b4 47 73 f0       	mov    %al,0xf07347b4
f010d9f7:	a0 b5 47 73 f0       	mov    0xf07347b5,%al
f010d9fc:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9ff:	83 c8 0e             	or     $0xe,%eax
f010da02:	a2 b5 47 73 f0       	mov    %al,0xf07347b5
f010da07:	a0 b5 47 73 f0       	mov    0xf07347b5,%al
f010da0c:	83 e0 ef             	and    $0xffffffef,%eax
f010da0f:	a2 b5 47 73 f0       	mov    %al,0xf07347b5
f010da14:	a0 b5 47 73 f0       	mov    0xf07347b5,%al
f010da19:	83 c8 60             	or     $0x60,%eax
f010da1c:	a2 b5 47 73 f0       	mov    %al,0xf07347b5
f010da21:	a0 b5 47 73 f0       	mov    0xf07347b5,%al
f010da26:	83 c8 80             	or     $0xffffff80,%eax
f010da29:	a2 b5 47 73 f0       	mov    %al,0xf07347b5
f010da2e:	b8 1e e9 10 f0       	mov    $0xf010e91e,%eax
f010da33:	c1 e8 10             	shr    $0x10,%eax
f010da36:	66 a3 b6 47 73 f0    	mov    %ax,0xf07347b6
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010da3c:	b8 22 e9 10 f0       	mov    $0xf010e922,%eax
f010da41:	66 a3 b8 47 73 f0    	mov    %ax,0xf07347b8
f010da47:	66 c7 05 ba 47 73 f0 	movw   $0x8,0xf07347ba
f010da4e:	08 00 
f010da50:	a0 bc 47 73 f0       	mov    0xf07347bc,%al
f010da55:	83 e0 e0             	and    $0xffffffe0,%eax
f010da58:	a2 bc 47 73 f0       	mov    %al,0xf07347bc
f010da5d:	a0 bc 47 73 f0       	mov    0xf07347bc,%al
f010da62:	83 e0 1f             	and    $0x1f,%eax
f010da65:	a2 bc 47 73 f0       	mov    %al,0xf07347bc
f010da6a:	a0 bd 47 73 f0       	mov    0xf07347bd,%al
f010da6f:	83 e0 f0             	and    $0xfffffff0,%eax
f010da72:	83 c8 0e             	or     $0xe,%eax
f010da75:	a2 bd 47 73 f0       	mov    %al,0xf07347bd
f010da7a:	a0 bd 47 73 f0       	mov    0xf07347bd,%al
f010da7f:	83 e0 ef             	and    $0xffffffef,%eax
f010da82:	a2 bd 47 73 f0       	mov    %al,0xf07347bd
f010da87:	a0 bd 47 73 f0       	mov    0xf07347bd,%al
f010da8c:	83 c8 60             	or     $0x60,%eax
f010da8f:	a2 bd 47 73 f0       	mov    %al,0xf07347bd
f010da94:	a0 bd 47 73 f0       	mov    0xf07347bd,%al
f010da99:	83 c8 80             	or     $0xffffff80,%eax
f010da9c:	a2 bd 47 73 f0       	mov    %al,0xf07347bd
f010daa1:	b8 22 e9 10 f0       	mov    $0xf010e922,%eax
f010daa6:	c1 e8 10             	shr    $0x10,%eax
f010daa9:	66 a3 be 47 73 f0    	mov    %ax,0xf07347be
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010daaf:	b8 26 e9 10 f0       	mov    $0xf010e926,%eax
f010dab4:	66 a3 c0 47 73 f0    	mov    %ax,0xf07347c0
f010daba:	66 c7 05 c2 47 73 f0 	movw   $0x8,0xf07347c2
f010dac1:	08 00 
f010dac3:	a0 c4 47 73 f0       	mov    0xf07347c4,%al
f010dac8:	83 e0 e0             	and    $0xffffffe0,%eax
f010dacb:	a2 c4 47 73 f0       	mov    %al,0xf07347c4
f010dad0:	a0 c4 47 73 f0       	mov    0xf07347c4,%al
f010dad5:	83 e0 1f             	and    $0x1f,%eax
f010dad8:	a2 c4 47 73 f0       	mov    %al,0xf07347c4
f010dadd:	a0 c5 47 73 f0       	mov    0xf07347c5,%al
f010dae2:	83 e0 f0             	and    $0xfffffff0,%eax
f010dae5:	83 c8 0e             	or     $0xe,%eax
f010dae8:	a2 c5 47 73 f0       	mov    %al,0xf07347c5
f010daed:	a0 c5 47 73 f0       	mov    0xf07347c5,%al
f010daf2:	83 e0 ef             	and    $0xffffffef,%eax
f010daf5:	a2 c5 47 73 f0       	mov    %al,0xf07347c5
f010dafa:	a0 c5 47 73 f0       	mov    0xf07347c5,%al
f010daff:	83 c8 60             	or     $0x60,%eax
f010db02:	a2 c5 47 73 f0       	mov    %al,0xf07347c5
f010db07:	a0 c5 47 73 f0       	mov    0xf07347c5,%al
f010db0c:	83 c8 80             	or     $0xffffff80,%eax
f010db0f:	a2 c5 47 73 f0       	mov    %al,0xf07347c5
f010db14:	b8 26 e9 10 f0       	mov    $0xf010e926,%eax
f010db19:	c1 e8 10             	shr    $0x10,%eax
f010db1c:	66 a3 c6 47 73 f0    	mov    %ax,0xf07347c6
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010db22:	b8 2a e9 10 f0       	mov    $0xf010e92a,%eax
f010db27:	66 a3 c8 47 73 f0    	mov    %ax,0xf07347c8
f010db2d:	66 c7 05 ca 47 73 f0 	movw   $0x8,0xf07347ca
f010db34:	08 00 
f010db36:	a0 cc 47 73 f0       	mov    0xf07347cc,%al
f010db3b:	83 e0 e0             	and    $0xffffffe0,%eax
f010db3e:	a2 cc 47 73 f0       	mov    %al,0xf07347cc
f010db43:	a0 cc 47 73 f0       	mov    0xf07347cc,%al
f010db48:	83 e0 1f             	and    $0x1f,%eax
f010db4b:	a2 cc 47 73 f0       	mov    %al,0xf07347cc
f010db50:	a0 cd 47 73 f0       	mov    0xf07347cd,%al
f010db55:	83 e0 f0             	and    $0xfffffff0,%eax
f010db58:	83 c8 0e             	or     $0xe,%eax
f010db5b:	a2 cd 47 73 f0       	mov    %al,0xf07347cd
f010db60:	a0 cd 47 73 f0       	mov    0xf07347cd,%al
f010db65:	83 e0 ef             	and    $0xffffffef,%eax
f010db68:	a2 cd 47 73 f0       	mov    %al,0xf07347cd
f010db6d:	a0 cd 47 73 f0       	mov    0xf07347cd,%al
f010db72:	83 c8 60             	or     $0x60,%eax
f010db75:	a2 cd 47 73 f0       	mov    %al,0xf07347cd
f010db7a:	a0 cd 47 73 f0       	mov    0xf07347cd,%al
f010db7f:	83 c8 80             	or     $0xffffff80,%eax
f010db82:	a2 cd 47 73 f0       	mov    %al,0xf07347cd
f010db87:	b8 2a e9 10 f0       	mov    $0xf010e92a,%eax
f010db8c:	c1 e8 10             	shr    $0x10,%eax
f010db8f:	66 a3 ce 47 73 f0    	mov    %ax,0xf07347ce
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010db95:	b8 2e e9 10 f0       	mov    $0xf010e92e,%eax
f010db9a:	66 a3 e0 47 73 f0    	mov    %ax,0xf07347e0
f010dba0:	66 c7 05 e2 47 73 f0 	movw   $0x8,0xf07347e2
f010dba7:	08 00 
f010dba9:	a0 e4 47 73 f0       	mov    0xf07347e4,%al
f010dbae:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbb1:	a2 e4 47 73 f0       	mov    %al,0xf07347e4
f010dbb6:	a0 e4 47 73 f0       	mov    0xf07347e4,%al
f010dbbb:	83 e0 1f             	and    $0x1f,%eax
f010dbbe:	a2 e4 47 73 f0       	mov    %al,0xf07347e4
f010dbc3:	a0 e5 47 73 f0       	mov    0xf07347e5,%al
f010dbc8:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbcb:	83 c8 0e             	or     $0xe,%eax
f010dbce:	a2 e5 47 73 f0       	mov    %al,0xf07347e5
f010dbd3:	a0 e5 47 73 f0       	mov    0xf07347e5,%al
f010dbd8:	83 e0 ef             	and    $0xffffffef,%eax
f010dbdb:	a2 e5 47 73 f0       	mov    %al,0xf07347e5
f010dbe0:	a0 e5 47 73 f0       	mov    0xf07347e5,%al
f010dbe5:	83 c8 60             	or     $0x60,%eax
f010dbe8:	a2 e5 47 73 f0       	mov    %al,0xf07347e5
f010dbed:	a0 e5 47 73 f0       	mov    0xf07347e5,%al
f010dbf2:	83 c8 80             	or     $0xffffff80,%eax
f010dbf5:	a2 e5 47 73 f0       	mov    %al,0xf07347e5
f010dbfa:	b8 2e e9 10 f0       	mov    $0xf010e92e,%eax
f010dbff:	c1 e8 10             	shr    $0x10,%eax
f010dc02:	66 a3 e6 47 73 f0    	mov    %ax,0xf07347e6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010dc08:	b8 34 e9 10 f0       	mov    $0xf010e934,%eax
f010dc0d:	66 a3 e8 47 73 f0    	mov    %ax,0xf07347e8
f010dc13:	66 c7 05 ea 47 73 f0 	movw   $0x8,0xf07347ea
f010dc1a:	08 00 
f010dc1c:	a0 ec 47 73 f0       	mov    0xf07347ec,%al
f010dc21:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc24:	a2 ec 47 73 f0       	mov    %al,0xf07347ec
f010dc29:	a0 ec 47 73 f0       	mov    0xf07347ec,%al
f010dc2e:	83 e0 1f             	and    $0x1f,%eax
f010dc31:	a2 ec 47 73 f0       	mov    %al,0xf07347ec
f010dc36:	a0 ed 47 73 f0       	mov    0xf07347ed,%al
f010dc3b:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc3e:	83 c8 0e             	or     $0xe,%eax
f010dc41:	a2 ed 47 73 f0       	mov    %al,0xf07347ed
f010dc46:	a0 ed 47 73 f0       	mov    0xf07347ed,%al
f010dc4b:	83 e0 ef             	and    $0xffffffef,%eax
f010dc4e:	a2 ed 47 73 f0       	mov    %al,0xf07347ed
f010dc53:	a0 ed 47 73 f0       	mov    0xf07347ed,%al
f010dc58:	83 c8 60             	or     $0x60,%eax
f010dc5b:	a2 ed 47 73 f0       	mov    %al,0xf07347ed
f010dc60:	a0 ed 47 73 f0       	mov    0xf07347ed,%al
f010dc65:	83 c8 80             	or     $0xffffff80,%eax
f010dc68:	a2 ed 47 73 f0       	mov    %al,0xf07347ed
f010dc6d:	b8 34 e9 10 f0       	mov    $0xf010e934,%eax
f010dc72:	c1 e8 10             	shr    $0x10,%eax
f010dc75:	66 a3 ee 47 73 f0    	mov    %ax,0xf07347ee
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010dc7b:	b8 38 e9 10 f0       	mov    $0xf010e938,%eax
f010dc80:	66 a3 f0 47 73 f0    	mov    %ax,0xf07347f0
f010dc86:	66 c7 05 f2 47 73 f0 	movw   $0x8,0xf07347f2
f010dc8d:	08 00 
f010dc8f:	a0 f4 47 73 f0       	mov    0xf07347f4,%al
f010dc94:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc97:	a2 f4 47 73 f0       	mov    %al,0xf07347f4
f010dc9c:	a0 f4 47 73 f0       	mov    0xf07347f4,%al
f010dca1:	83 e0 1f             	and    $0x1f,%eax
f010dca4:	a2 f4 47 73 f0       	mov    %al,0xf07347f4
f010dca9:	a0 f5 47 73 f0       	mov    0xf07347f5,%al
f010dcae:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcb1:	83 c8 0e             	or     $0xe,%eax
f010dcb4:	a2 f5 47 73 f0       	mov    %al,0xf07347f5
f010dcb9:	a0 f5 47 73 f0       	mov    0xf07347f5,%al
f010dcbe:	83 e0 ef             	and    $0xffffffef,%eax
f010dcc1:	a2 f5 47 73 f0       	mov    %al,0xf07347f5
f010dcc6:	a0 f5 47 73 f0       	mov    0xf07347f5,%al
f010dccb:	83 c8 60             	or     $0x60,%eax
f010dcce:	a2 f5 47 73 f0       	mov    %al,0xf07347f5
f010dcd3:	a0 f5 47 73 f0       	mov    0xf07347f5,%al
f010dcd8:	83 c8 80             	or     $0xffffff80,%eax
f010dcdb:	a2 f5 47 73 f0       	mov    %al,0xf07347f5
f010dce0:	b8 38 e9 10 f0       	mov    $0xf010e938,%eax
f010dce5:	c1 e8 10             	shr    $0x10,%eax
f010dce8:	66 a3 f6 47 73 f0    	mov    %ax,0xf07347f6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010dcee:	b8 3e e9 10 f0       	mov    $0xf010e93e,%eax
f010dcf3:	66 a3 f8 47 73 f0    	mov    %ax,0xf07347f8
f010dcf9:	66 c7 05 fa 47 73 f0 	movw   $0x8,0xf07347fa
f010dd00:	08 00 
f010dd02:	a0 fc 47 73 f0       	mov    0xf07347fc,%al
f010dd07:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd0a:	a2 fc 47 73 f0       	mov    %al,0xf07347fc
f010dd0f:	a0 fc 47 73 f0       	mov    0xf07347fc,%al
f010dd14:	83 e0 1f             	and    $0x1f,%eax
f010dd17:	a2 fc 47 73 f0       	mov    %al,0xf07347fc
f010dd1c:	a0 fd 47 73 f0       	mov    0xf07347fd,%al
f010dd21:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd24:	83 c8 0e             	or     $0xe,%eax
f010dd27:	a2 fd 47 73 f0       	mov    %al,0xf07347fd
f010dd2c:	a0 fd 47 73 f0       	mov    0xf07347fd,%al
f010dd31:	83 e0 ef             	and    $0xffffffef,%eax
f010dd34:	a2 fd 47 73 f0       	mov    %al,0xf07347fd
f010dd39:	a0 fd 47 73 f0       	mov    0xf07347fd,%al
f010dd3e:	83 c8 60             	or     $0x60,%eax
f010dd41:	a2 fd 47 73 f0       	mov    %al,0xf07347fd
f010dd46:	a0 fd 47 73 f0       	mov    0xf07347fd,%al
f010dd4b:	83 c8 80             	or     $0xffffff80,%eax
f010dd4e:	a2 fd 47 73 f0       	mov    %al,0xf07347fd
f010dd53:	b8 3e e9 10 f0       	mov    $0xf010e93e,%eax
f010dd58:	c1 e8 10             	shr    $0x10,%eax
f010dd5b:	66 a3 fe 47 73 f0    	mov    %ax,0xf07347fe

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010dd61:	b8 44 e9 10 f0       	mov    $0xf010e944,%eax
f010dd66:	66 a3 70 48 73 f0    	mov    %ax,0xf0734870
f010dd6c:	66 c7 05 72 48 73 f0 	movw   $0x8,0xf0734872
f010dd73:	08 00 
f010dd75:	a0 74 48 73 f0       	mov    0xf0734874,%al
f010dd7a:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd7d:	a2 74 48 73 f0       	mov    %al,0xf0734874
f010dd82:	a0 74 48 73 f0       	mov    0xf0734874,%al
f010dd87:	83 e0 1f             	and    $0x1f,%eax
f010dd8a:	a2 74 48 73 f0       	mov    %al,0xf0734874
f010dd8f:	a0 75 48 73 f0       	mov    0xf0734875,%al
f010dd94:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd97:	83 c8 0e             	or     $0xe,%eax
f010dd9a:	a2 75 48 73 f0       	mov    %al,0xf0734875
f010dd9f:	a0 75 48 73 f0       	mov    0xf0734875,%al
f010dda4:	83 e0 ef             	and    $0xffffffef,%eax
f010dda7:	a2 75 48 73 f0       	mov    %al,0xf0734875
f010ddac:	a0 75 48 73 f0       	mov    0xf0734875,%al
f010ddb1:	83 c8 60             	or     $0x60,%eax
f010ddb4:	a2 75 48 73 f0       	mov    %al,0xf0734875
f010ddb9:	a0 75 48 73 f0       	mov    0xf0734875,%al
f010ddbe:	83 c8 80             	or     $0xffffff80,%eax
f010ddc1:	a2 75 48 73 f0       	mov    %al,0xf0734875
f010ddc6:	b8 44 e9 10 f0       	mov    $0xf010e944,%eax
f010ddcb:	c1 e8 10             	shr    $0x10,%eax
f010ddce:	66 a3 76 48 73 f0    	mov    %ax,0xf0734876
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010ddd4:	b8 4a e9 10 f0       	mov    $0xf010e94a,%eax
f010ddd9:	66 a3 78 48 73 f0    	mov    %ax,0xf0734878
f010dddf:	66 c7 05 7a 48 73 f0 	movw   $0x8,0xf073487a
f010dde6:	08 00 
f010dde8:	a0 7c 48 73 f0       	mov    0xf073487c,%al
f010dded:	83 e0 e0             	and    $0xffffffe0,%eax
f010ddf0:	a2 7c 48 73 f0       	mov    %al,0xf073487c
f010ddf5:	a0 7c 48 73 f0       	mov    0xf073487c,%al
f010ddfa:	83 e0 1f             	and    $0x1f,%eax
f010ddfd:	a2 7c 48 73 f0       	mov    %al,0xf073487c
f010de02:	a0 7d 48 73 f0       	mov    0xf073487d,%al
f010de07:	83 e0 f0             	and    $0xfffffff0,%eax
f010de0a:	83 c8 0e             	or     $0xe,%eax
f010de0d:	a2 7d 48 73 f0       	mov    %al,0xf073487d
f010de12:	a0 7d 48 73 f0       	mov    0xf073487d,%al
f010de17:	83 e0 ef             	and    $0xffffffef,%eax
f010de1a:	a2 7d 48 73 f0       	mov    %al,0xf073487d
f010de1f:	a0 7d 48 73 f0       	mov    0xf073487d,%al
f010de24:	83 c8 60             	or     $0x60,%eax
f010de27:	a2 7d 48 73 f0       	mov    %al,0xf073487d
f010de2c:	a0 7d 48 73 f0       	mov    0xf073487d,%al
f010de31:	83 c8 80             	or     $0xffffff80,%eax
f010de34:	a2 7d 48 73 f0       	mov    %al,0xf073487d
f010de39:	b8 4a e9 10 f0       	mov    $0xf010e94a,%eax
f010de3e:	c1 e8 10             	shr    $0x10,%eax
f010de41:	66 a3 7e 48 73 f0    	mov    %ax,0xf073487e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010de47:	b8 50 e9 10 f0       	mov    $0xf010e950,%eax
f010de4c:	66 a3 80 48 73 f0    	mov    %ax,0xf0734880
f010de52:	66 c7 05 82 48 73 f0 	movw   $0x8,0xf0734882
f010de59:	08 00 
f010de5b:	a0 84 48 73 f0       	mov    0xf0734884,%al
f010de60:	83 e0 e0             	and    $0xffffffe0,%eax
f010de63:	a2 84 48 73 f0       	mov    %al,0xf0734884
f010de68:	a0 84 48 73 f0       	mov    0xf0734884,%al
f010de6d:	83 e0 1f             	and    $0x1f,%eax
f010de70:	a2 84 48 73 f0       	mov    %al,0xf0734884
f010de75:	a0 85 48 73 f0       	mov    0xf0734885,%al
f010de7a:	83 e0 f0             	and    $0xfffffff0,%eax
f010de7d:	83 c8 0e             	or     $0xe,%eax
f010de80:	a2 85 48 73 f0       	mov    %al,0xf0734885
f010de85:	a0 85 48 73 f0       	mov    0xf0734885,%al
f010de8a:	83 e0 ef             	and    $0xffffffef,%eax
f010de8d:	a2 85 48 73 f0       	mov    %al,0xf0734885
f010de92:	a0 85 48 73 f0       	mov    0xf0734885,%al
f010de97:	83 c8 60             	or     $0x60,%eax
f010de9a:	a2 85 48 73 f0       	mov    %al,0xf0734885
f010de9f:	a0 85 48 73 f0       	mov    0xf0734885,%al
f010dea4:	83 c8 80             	or     $0xffffff80,%eax
f010dea7:	a2 85 48 73 f0       	mov    %al,0xf0734885
f010deac:	b8 50 e9 10 f0       	mov    $0xf010e950,%eax
f010deb1:	c1 e8 10             	shr    $0x10,%eax
f010deb4:	66 a3 86 48 73 f0    	mov    %ax,0xf0734886
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010deba:	b8 56 e9 10 f0       	mov    $0xf010e956,%eax
f010debf:	66 a3 88 48 73 f0    	mov    %ax,0xf0734888
f010dec5:	66 c7 05 8a 48 73 f0 	movw   $0x8,0xf073488a
f010decc:	08 00 
f010dece:	a0 8c 48 73 f0       	mov    0xf073488c,%al
f010ded3:	83 e0 e0             	and    $0xffffffe0,%eax
f010ded6:	a2 8c 48 73 f0       	mov    %al,0xf073488c
f010dedb:	a0 8c 48 73 f0       	mov    0xf073488c,%al
f010dee0:	83 e0 1f             	and    $0x1f,%eax
f010dee3:	a2 8c 48 73 f0       	mov    %al,0xf073488c
f010dee8:	a0 8d 48 73 f0       	mov    0xf073488d,%al
f010deed:	83 e0 f0             	and    $0xfffffff0,%eax
f010def0:	83 c8 0e             	or     $0xe,%eax
f010def3:	a2 8d 48 73 f0       	mov    %al,0xf073488d
f010def8:	a0 8d 48 73 f0       	mov    0xf073488d,%al
f010defd:	83 e0 ef             	and    $0xffffffef,%eax
f010df00:	a2 8d 48 73 f0       	mov    %al,0xf073488d
f010df05:	a0 8d 48 73 f0       	mov    0xf073488d,%al
f010df0a:	83 c8 60             	or     $0x60,%eax
f010df0d:	a2 8d 48 73 f0       	mov    %al,0xf073488d
f010df12:	a0 8d 48 73 f0       	mov    0xf073488d,%al
f010df17:	83 c8 80             	or     $0xffffff80,%eax
f010df1a:	a2 8d 48 73 f0       	mov    %al,0xf073488d
f010df1f:	b8 56 e9 10 f0       	mov    $0xf010e956,%eax
f010df24:	c1 e8 10             	shr    $0x10,%eax
f010df27:	66 a3 8e 48 73 f0    	mov    %ax,0xf073488e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010df2d:	b8 5c e9 10 f0       	mov    $0xf010e95c,%eax
f010df32:	66 a3 90 48 73 f0    	mov    %ax,0xf0734890
f010df38:	66 c7 05 92 48 73 f0 	movw   $0x8,0xf0734892
f010df3f:	08 00 
f010df41:	a0 94 48 73 f0       	mov    0xf0734894,%al
f010df46:	83 e0 e0             	and    $0xffffffe0,%eax
f010df49:	a2 94 48 73 f0       	mov    %al,0xf0734894
f010df4e:	a0 94 48 73 f0       	mov    0xf0734894,%al
f010df53:	83 e0 1f             	and    $0x1f,%eax
f010df56:	a2 94 48 73 f0       	mov    %al,0xf0734894
f010df5b:	a0 95 48 73 f0       	mov    0xf0734895,%al
f010df60:	83 e0 f0             	and    $0xfffffff0,%eax
f010df63:	83 c8 0e             	or     $0xe,%eax
f010df66:	a2 95 48 73 f0       	mov    %al,0xf0734895
f010df6b:	a0 95 48 73 f0       	mov    0xf0734895,%al
f010df70:	83 e0 ef             	and    $0xffffffef,%eax
f010df73:	a2 95 48 73 f0       	mov    %al,0xf0734895
f010df78:	a0 95 48 73 f0       	mov    0xf0734895,%al
f010df7d:	83 c8 60             	or     $0x60,%eax
f010df80:	a2 95 48 73 f0       	mov    %al,0xf0734895
f010df85:	a0 95 48 73 f0       	mov    0xf0734895,%al
f010df8a:	83 c8 80             	or     $0xffffff80,%eax
f010df8d:	a2 95 48 73 f0       	mov    %al,0xf0734895
f010df92:	b8 5c e9 10 f0       	mov    $0xf010e95c,%eax
f010df97:	c1 e8 10             	shr    $0x10,%eax
f010df9a:	66 a3 96 48 73 f0    	mov    %ax,0xf0734896
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dfa0:	b8 62 e9 10 f0       	mov    $0xf010e962,%eax
f010dfa5:	66 a3 98 48 73 f0    	mov    %ax,0xf0734898
f010dfab:	66 c7 05 9a 48 73 f0 	movw   $0x8,0xf073489a
f010dfb2:	08 00 
f010dfb4:	a0 9c 48 73 f0       	mov    0xf073489c,%al
f010dfb9:	83 e0 e0             	and    $0xffffffe0,%eax
f010dfbc:	a2 9c 48 73 f0       	mov    %al,0xf073489c
f010dfc1:	a0 9c 48 73 f0       	mov    0xf073489c,%al
f010dfc6:	83 e0 1f             	and    $0x1f,%eax
f010dfc9:	a2 9c 48 73 f0       	mov    %al,0xf073489c
f010dfce:	a0 9d 48 73 f0       	mov    0xf073489d,%al
f010dfd3:	83 e0 f0             	and    $0xfffffff0,%eax
f010dfd6:	83 c8 0e             	or     $0xe,%eax
f010dfd9:	a2 9d 48 73 f0       	mov    %al,0xf073489d
f010dfde:	a0 9d 48 73 f0       	mov    0xf073489d,%al
f010dfe3:	83 e0 ef             	and    $0xffffffef,%eax
f010dfe6:	a2 9d 48 73 f0       	mov    %al,0xf073489d
f010dfeb:	a0 9d 48 73 f0       	mov    0xf073489d,%al
f010dff0:	83 c8 60             	or     $0x60,%eax
f010dff3:	a2 9d 48 73 f0       	mov    %al,0xf073489d
f010dff8:	a0 9d 48 73 f0       	mov    0xf073489d,%al
f010dffd:	83 c8 80             	or     $0xffffff80,%eax
f010e000:	a2 9d 48 73 f0       	mov    %al,0xf073489d
f010e005:	b8 62 e9 10 f0       	mov    $0xf010e962,%eax
f010e00a:	c1 e8 10             	shr    $0x10,%eax
f010e00d:	66 a3 9e 48 73 f0    	mov    %ax,0xf073489e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010e013:	b8 68 e9 10 f0       	mov    $0xf010e968,%eax
f010e018:	66 a3 a0 48 73 f0    	mov    %ax,0xf07348a0
f010e01e:	66 c7 05 a2 48 73 f0 	movw   $0x8,0xf07348a2
f010e025:	08 00 
f010e027:	a0 a4 48 73 f0       	mov    0xf07348a4,%al
f010e02c:	83 e0 e0             	and    $0xffffffe0,%eax
f010e02f:	a2 a4 48 73 f0       	mov    %al,0xf07348a4
f010e034:	a0 a4 48 73 f0       	mov    0xf07348a4,%al
f010e039:	83 e0 1f             	and    $0x1f,%eax
f010e03c:	a2 a4 48 73 f0       	mov    %al,0xf07348a4
f010e041:	a0 a5 48 73 f0       	mov    0xf07348a5,%al
f010e046:	83 e0 f0             	and    $0xfffffff0,%eax
f010e049:	83 c8 0e             	or     $0xe,%eax
f010e04c:	a2 a5 48 73 f0       	mov    %al,0xf07348a5
f010e051:	a0 a5 48 73 f0       	mov    0xf07348a5,%al
f010e056:	83 e0 ef             	and    $0xffffffef,%eax
f010e059:	a2 a5 48 73 f0       	mov    %al,0xf07348a5
f010e05e:	a0 a5 48 73 f0       	mov    0xf07348a5,%al
f010e063:	83 c8 60             	or     $0x60,%eax
f010e066:	a2 a5 48 73 f0       	mov    %al,0xf07348a5
f010e06b:	a0 a5 48 73 f0       	mov    0xf07348a5,%al
f010e070:	83 c8 80             	or     $0xffffff80,%eax
f010e073:	a2 a5 48 73 f0       	mov    %al,0xf07348a5
f010e078:	b8 68 e9 10 f0       	mov    $0xf010e968,%eax
f010e07d:	c1 e8 10             	shr    $0x10,%eax
f010e080:	66 a3 a6 48 73 f0    	mov    %ax,0xf07348a6
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010e086:	b8 6e e9 10 f0       	mov    $0xf010e96e,%eax
f010e08b:	66 a3 a8 48 73 f0    	mov    %ax,0xf07348a8
f010e091:	66 c7 05 aa 48 73 f0 	movw   $0x8,0xf07348aa
f010e098:	08 00 
f010e09a:	a0 ac 48 73 f0       	mov    0xf07348ac,%al
f010e09f:	83 e0 e0             	and    $0xffffffe0,%eax
f010e0a2:	a2 ac 48 73 f0       	mov    %al,0xf07348ac
f010e0a7:	a0 ac 48 73 f0       	mov    0xf07348ac,%al
f010e0ac:	83 e0 1f             	and    $0x1f,%eax
f010e0af:	a2 ac 48 73 f0       	mov    %al,0xf07348ac
f010e0b4:	a0 ad 48 73 f0       	mov    0xf07348ad,%al
f010e0b9:	83 e0 f0             	and    $0xfffffff0,%eax
f010e0bc:	83 c8 0e             	or     $0xe,%eax
f010e0bf:	a2 ad 48 73 f0       	mov    %al,0xf07348ad
f010e0c4:	a0 ad 48 73 f0       	mov    0xf07348ad,%al
f010e0c9:	83 e0 ef             	and    $0xffffffef,%eax
f010e0cc:	a2 ad 48 73 f0       	mov    %al,0xf07348ad
f010e0d1:	a0 ad 48 73 f0       	mov    0xf07348ad,%al
f010e0d6:	83 c8 60             	or     $0x60,%eax
f010e0d9:	a2 ad 48 73 f0       	mov    %al,0xf07348ad
f010e0de:	a0 ad 48 73 f0       	mov    0xf07348ad,%al
f010e0e3:	83 c8 80             	or     $0xffffff80,%eax
f010e0e6:	a2 ad 48 73 f0       	mov    %al,0xf07348ad
f010e0eb:	b8 6e e9 10 f0       	mov    $0xf010e96e,%eax
f010e0f0:	c1 e8 10             	shr    $0x10,%eax
f010e0f3:	66 a3 ae 48 73 f0    	mov    %ax,0xf07348ae
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010e0f9:	b8 74 e9 10 f0       	mov    $0xf010e974,%eax
f010e0fe:	66 a3 b0 48 73 f0    	mov    %ax,0xf07348b0
f010e104:	66 c7 05 b2 48 73 f0 	movw   $0x8,0xf07348b2
f010e10b:	08 00 
f010e10d:	a0 b4 48 73 f0       	mov    0xf07348b4,%al
f010e112:	83 e0 e0             	and    $0xffffffe0,%eax
f010e115:	a2 b4 48 73 f0       	mov    %al,0xf07348b4
f010e11a:	a0 b4 48 73 f0       	mov    0xf07348b4,%al
f010e11f:	83 e0 1f             	and    $0x1f,%eax
f010e122:	a2 b4 48 73 f0       	mov    %al,0xf07348b4
f010e127:	a0 b5 48 73 f0       	mov    0xf07348b5,%al
f010e12c:	83 e0 f0             	and    $0xfffffff0,%eax
f010e12f:	83 c8 0e             	or     $0xe,%eax
f010e132:	a2 b5 48 73 f0       	mov    %al,0xf07348b5
f010e137:	a0 b5 48 73 f0       	mov    0xf07348b5,%al
f010e13c:	83 e0 ef             	and    $0xffffffef,%eax
f010e13f:	a2 b5 48 73 f0       	mov    %al,0xf07348b5
f010e144:	a0 b5 48 73 f0       	mov    0xf07348b5,%al
f010e149:	83 c8 60             	or     $0x60,%eax
f010e14c:	a2 b5 48 73 f0       	mov    %al,0xf07348b5
f010e151:	a0 b5 48 73 f0       	mov    0xf07348b5,%al
f010e156:	83 c8 80             	or     $0xffffff80,%eax
f010e159:	a2 b5 48 73 f0       	mov    %al,0xf07348b5
f010e15e:	b8 74 e9 10 f0       	mov    $0xf010e974,%eax
f010e163:	c1 e8 10             	shr    $0x10,%eax
f010e166:	66 a3 b6 48 73 f0    	mov    %ax,0xf07348b6
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010e16c:	b8 7a e9 10 f0       	mov    $0xf010e97a,%eax
f010e171:	66 a3 b8 48 73 f0    	mov    %ax,0xf07348b8
f010e177:	66 c7 05 ba 48 73 f0 	movw   $0x8,0xf07348ba
f010e17e:	08 00 
f010e180:	a0 bc 48 73 f0       	mov    0xf07348bc,%al
f010e185:	83 e0 e0             	and    $0xffffffe0,%eax
f010e188:	a2 bc 48 73 f0       	mov    %al,0xf07348bc
f010e18d:	a0 bc 48 73 f0       	mov    0xf07348bc,%al
f010e192:	83 e0 1f             	and    $0x1f,%eax
f010e195:	a2 bc 48 73 f0       	mov    %al,0xf07348bc
f010e19a:	a0 bd 48 73 f0       	mov    0xf07348bd,%al
f010e19f:	83 e0 f0             	and    $0xfffffff0,%eax
f010e1a2:	83 c8 0e             	or     $0xe,%eax
f010e1a5:	a2 bd 48 73 f0       	mov    %al,0xf07348bd
f010e1aa:	a0 bd 48 73 f0       	mov    0xf07348bd,%al
f010e1af:	83 e0 ef             	and    $0xffffffef,%eax
f010e1b2:	a2 bd 48 73 f0       	mov    %al,0xf07348bd
f010e1b7:	a0 bd 48 73 f0       	mov    0xf07348bd,%al
f010e1bc:	83 c8 60             	or     $0x60,%eax
f010e1bf:	a2 bd 48 73 f0       	mov    %al,0xf07348bd
f010e1c4:	a0 bd 48 73 f0       	mov    0xf07348bd,%al
f010e1c9:	83 c8 80             	or     $0xffffff80,%eax
f010e1cc:	a2 bd 48 73 f0       	mov    %al,0xf07348bd
f010e1d1:	b8 7a e9 10 f0       	mov    $0xf010e97a,%eax
f010e1d6:	c1 e8 10             	shr    $0x10,%eax
f010e1d9:	66 a3 be 48 73 f0    	mov    %ax,0xf07348be
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010e1df:	b8 80 e9 10 f0       	mov    $0xf010e980,%eax
f010e1e4:	66 a3 c0 48 73 f0    	mov    %ax,0xf07348c0
f010e1ea:	66 c7 05 c2 48 73 f0 	movw   $0x8,0xf07348c2
f010e1f1:	08 00 
f010e1f3:	a0 c4 48 73 f0       	mov    0xf07348c4,%al
f010e1f8:	83 e0 e0             	and    $0xffffffe0,%eax
f010e1fb:	a2 c4 48 73 f0       	mov    %al,0xf07348c4
f010e200:	a0 c4 48 73 f0       	mov    0xf07348c4,%al
f010e205:	83 e0 1f             	and    $0x1f,%eax
f010e208:	a2 c4 48 73 f0       	mov    %al,0xf07348c4
f010e20d:	a0 c5 48 73 f0       	mov    0xf07348c5,%al
f010e212:	83 e0 f0             	and    $0xfffffff0,%eax
f010e215:	83 c8 0e             	or     $0xe,%eax
f010e218:	a2 c5 48 73 f0       	mov    %al,0xf07348c5
f010e21d:	a0 c5 48 73 f0       	mov    0xf07348c5,%al
f010e222:	83 e0 ef             	and    $0xffffffef,%eax
f010e225:	a2 c5 48 73 f0       	mov    %al,0xf07348c5
f010e22a:	a0 c5 48 73 f0       	mov    0xf07348c5,%al
f010e22f:	83 c8 60             	or     $0x60,%eax
f010e232:	a2 c5 48 73 f0       	mov    %al,0xf07348c5
f010e237:	a0 c5 48 73 f0       	mov    0xf07348c5,%al
f010e23c:	83 c8 80             	or     $0xffffff80,%eax
f010e23f:	a2 c5 48 73 f0       	mov    %al,0xf07348c5
f010e244:	b8 80 e9 10 f0       	mov    $0xf010e980,%eax
f010e249:	c1 e8 10             	shr    $0x10,%eax
f010e24c:	66 a3 c6 48 73 f0    	mov    %ax,0xf07348c6
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010e252:	b8 86 e9 10 f0       	mov    $0xf010e986,%eax
f010e257:	66 a3 c8 48 73 f0    	mov    %ax,0xf07348c8
f010e25d:	66 c7 05 ca 48 73 f0 	movw   $0x8,0xf07348ca
f010e264:	08 00 
f010e266:	a0 cc 48 73 f0       	mov    0xf07348cc,%al
f010e26b:	83 e0 e0             	and    $0xffffffe0,%eax
f010e26e:	a2 cc 48 73 f0       	mov    %al,0xf07348cc
f010e273:	a0 cc 48 73 f0       	mov    0xf07348cc,%al
f010e278:	83 e0 1f             	and    $0x1f,%eax
f010e27b:	a2 cc 48 73 f0       	mov    %al,0xf07348cc
f010e280:	a0 cd 48 73 f0       	mov    0xf07348cd,%al
f010e285:	83 e0 f0             	and    $0xfffffff0,%eax
f010e288:	83 c8 0e             	or     $0xe,%eax
f010e28b:	a2 cd 48 73 f0       	mov    %al,0xf07348cd
f010e290:	a0 cd 48 73 f0       	mov    0xf07348cd,%al
f010e295:	83 e0 ef             	and    $0xffffffef,%eax
f010e298:	a2 cd 48 73 f0       	mov    %al,0xf07348cd
f010e29d:	a0 cd 48 73 f0       	mov    0xf07348cd,%al
f010e2a2:	83 c8 60             	or     $0x60,%eax
f010e2a5:	a2 cd 48 73 f0       	mov    %al,0xf07348cd
f010e2aa:	a0 cd 48 73 f0       	mov    0xf07348cd,%al
f010e2af:	83 c8 80             	or     $0xffffff80,%eax
f010e2b2:	a2 cd 48 73 f0       	mov    %al,0xf07348cd
f010e2b7:	b8 86 e9 10 f0       	mov    $0xf010e986,%eax
f010e2bc:	c1 e8 10             	shr    $0x10,%eax
f010e2bf:	66 a3 ce 48 73 f0    	mov    %ax,0xf07348ce
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010e2c5:	b8 8c e9 10 f0       	mov    $0xf010e98c,%eax
f010e2ca:	66 a3 d0 48 73 f0    	mov    %ax,0xf07348d0
f010e2d0:	66 c7 05 d2 48 73 f0 	movw   $0x8,0xf07348d2
f010e2d7:	08 00 
f010e2d9:	a0 d4 48 73 f0       	mov    0xf07348d4,%al
f010e2de:	83 e0 e0             	and    $0xffffffe0,%eax
f010e2e1:	a2 d4 48 73 f0       	mov    %al,0xf07348d4
f010e2e6:	a0 d4 48 73 f0       	mov    0xf07348d4,%al
f010e2eb:	83 e0 1f             	and    $0x1f,%eax
f010e2ee:	a2 d4 48 73 f0       	mov    %al,0xf07348d4
f010e2f3:	a0 d5 48 73 f0       	mov    0xf07348d5,%al
f010e2f8:	83 e0 f0             	and    $0xfffffff0,%eax
f010e2fb:	83 c8 0e             	or     $0xe,%eax
f010e2fe:	a2 d5 48 73 f0       	mov    %al,0xf07348d5
f010e303:	a0 d5 48 73 f0       	mov    0xf07348d5,%al
f010e308:	83 e0 ef             	and    $0xffffffef,%eax
f010e30b:	a2 d5 48 73 f0       	mov    %al,0xf07348d5
f010e310:	a0 d5 48 73 f0       	mov    0xf07348d5,%al
f010e315:	83 c8 60             	or     $0x60,%eax
f010e318:	a2 d5 48 73 f0       	mov    %al,0xf07348d5
f010e31d:	a0 d5 48 73 f0       	mov    0xf07348d5,%al
f010e322:	83 c8 80             	or     $0xffffff80,%eax
f010e325:	a2 d5 48 73 f0       	mov    %al,0xf07348d5
f010e32a:	b8 8c e9 10 f0       	mov    $0xf010e98c,%eax
f010e32f:	c1 e8 10             	shr    $0x10,%eax
f010e332:	66 a3 d6 48 73 f0    	mov    %ax,0xf07348d6
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010e338:	b8 92 e9 10 f0       	mov    $0xf010e992,%eax
f010e33d:	66 a3 d8 48 73 f0    	mov    %ax,0xf07348d8
f010e343:	66 c7 05 da 48 73 f0 	movw   $0x8,0xf07348da
f010e34a:	08 00 
f010e34c:	a0 dc 48 73 f0       	mov    0xf07348dc,%al
f010e351:	83 e0 e0             	and    $0xffffffe0,%eax
f010e354:	a2 dc 48 73 f0       	mov    %al,0xf07348dc
f010e359:	a0 dc 48 73 f0       	mov    0xf07348dc,%al
f010e35e:	83 e0 1f             	and    $0x1f,%eax
f010e361:	a2 dc 48 73 f0       	mov    %al,0xf07348dc
f010e366:	a0 dd 48 73 f0       	mov    0xf07348dd,%al
f010e36b:	83 e0 f0             	and    $0xfffffff0,%eax
f010e36e:	83 c8 0e             	or     $0xe,%eax
f010e371:	a2 dd 48 73 f0       	mov    %al,0xf07348dd
f010e376:	a0 dd 48 73 f0       	mov    0xf07348dd,%al
f010e37b:	83 e0 ef             	and    $0xffffffef,%eax
f010e37e:	a2 dd 48 73 f0       	mov    %al,0xf07348dd
f010e383:	a0 dd 48 73 f0       	mov    0xf07348dd,%al
f010e388:	83 c8 60             	or     $0x60,%eax
f010e38b:	a2 dd 48 73 f0       	mov    %al,0xf07348dd
f010e390:	a0 dd 48 73 f0       	mov    0xf07348dd,%al
f010e395:	83 c8 80             	or     $0xffffff80,%eax
f010e398:	a2 dd 48 73 f0       	mov    %al,0xf07348dd
f010e39d:	b8 92 e9 10 f0       	mov    $0xf010e992,%eax
f010e3a2:	c1 e8 10             	shr    $0x10,%eax
f010e3a5:	66 a3 de 48 73 f0    	mov    %ax,0xf07348de
f010e3ab:	c7 45 fc 60 47 73 f0 	movl   $0xf0734760,-0x4(%ebp)
f010e3b2:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e3b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e3bc:	48                   	dec    %eax
f010e3bd:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e3c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e3c4:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e3c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e3cb:	c1 e8 10             	shr    $0x10,%eax
f010e3ce:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e3d2:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e3d5:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e3d8:	90                   	nop
f010e3d9:	c9                   	leave  
f010e3da:	c3                   	ret    

f010e3db <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e3db:	55                   	push   %ebp
f010e3dc:	89 e5                	mov    %esp,%ebp
f010e3de:	53                   	push   %ebx
f010e3df:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e3e2:	83 ec 08             	sub    $0x8,%esp
f010e3e5:	ff 75 08             	pushl  0x8(%ebp)
f010e3e8:	68 3e 7a 12 f0       	push   $0xf0127a3e
f010e3ed:	e8 99 2b ff ff       	call   f0100f8b <cprintf>
f010e3f2:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e3f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3f8:	83 ec 0c             	sub    $0xc,%esp
f010e3fb:	50                   	push   %eax
f010e3fc:	e8 fd 00 00 00       	call   f010e4fe <print_regs>
f010e401:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e404:	8b 45 08             	mov    0x8(%ebp),%eax
f010e407:	8b 40 20             	mov    0x20(%eax),%eax
f010e40a:	0f b7 c0             	movzwl %ax,%eax
f010e40d:	83 ec 08             	sub    $0x8,%esp
f010e410:	50                   	push   %eax
f010e411:	68 50 7a 12 f0       	push   $0xf0127a50
f010e416:	e8 70 2b ff ff       	call   f0100f8b <cprintf>
f010e41b:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e41e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e421:	8b 40 24             	mov    0x24(%eax),%eax
f010e424:	0f b7 c0             	movzwl %ax,%eax
f010e427:	83 ec 08             	sub    $0x8,%esp
f010e42a:	50                   	push   %eax
f010e42b:	68 63 7a 12 f0       	push   $0xf0127a63
f010e430:	e8 56 2b ff ff       	call   f0100f8b <cprintf>
f010e435:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e438:	8b 45 08             	mov    0x8(%ebp),%eax
f010e43b:	8b 58 28             	mov    0x28(%eax),%ebx
f010e43e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e441:	8b 40 28             	mov    0x28(%eax),%eax
f010e444:	83 ec 0c             	sub    $0xc,%esp
f010e447:	50                   	push   %eax
f010e448:	e8 28 ee ff ff       	call   f010d275 <trapname>
f010e44d:	83 c4 10             	add    $0x10,%esp
f010e450:	89 c2                	mov    %eax,%edx
f010e452:	8b 45 08             	mov    0x8(%ebp),%eax
f010e455:	8b 40 28             	mov    0x28(%eax),%eax
f010e458:	53                   	push   %ebx
f010e459:	52                   	push   %edx
f010e45a:	50                   	push   %eax
f010e45b:	68 76 7a 12 f0       	push   $0xf0127a76
f010e460:	e8 26 2b ff ff       	call   f0100f8b <cprintf>
f010e465:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e468:	8b 45 08             	mov    0x8(%ebp),%eax
f010e46b:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e46e:	83 ec 08             	sub    $0x8,%esp
f010e471:	50                   	push   %eax
f010e472:	68 8d 7a 12 f0       	push   $0xf0127a8d
f010e477:	e8 0f 2b ff ff       	call   f0100f8b <cprintf>
f010e47c:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e47f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e482:	8b 40 30             	mov    0x30(%eax),%eax
f010e485:	83 ec 08             	sub    $0x8,%esp
f010e488:	50                   	push   %eax
f010e489:	68 9c 7a 12 f0       	push   $0xf0127a9c
f010e48e:	e8 f8 2a ff ff       	call   f0100f8b <cprintf>
f010e493:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e496:	8b 45 08             	mov    0x8(%ebp),%eax
f010e499:	8b 40 34             	mov    0x34(%eax),%eax
f010e49c:	0f b7 c0             	movzwl %ax,%eax
f010e49f:	83 ec 08             	sub    $0x8,%esp
f010e4a2:	50                   	push   %eax
f010e4a3:	68 ab 7a 12 f0       	push   $0xf0127aab
f010e4a8:	e8 de 2a ff ff       	call   f0100f8b <cprintf>
f010e4ad:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e4b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4b3:	8b 40 38             	mov    0x38(%eax),%eax
f010e4b6:	83 ec 08             	sub    $0x8,%esp
f010e4b9:	50                   	push   %eax
f010e4ba:	68 be 7a 12 f0       	push   $0xf0127abe
f010e4bf:	e8 c7 2a ff ff       	call   f0100f8b <cprintf>
f010e4c4:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e4c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4ca:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e4cd:	83 ec 08             	sub    $0x8,%esp
f010e4d0:	50                   	push   %eax
f010e4d1:	68 cd 7a 12 f0       	push   $0xf0127acd
f010e4d6:	e8 b0 2a ff ff       	call   f0100f8b <cprintf>
f010e4db:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e4de:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4e1:	8b 40 40             	mov    0x40(%eax),%eax
f010e4e4:	0f b7 c0             	movzwl %ax,%eax
f010e4e7:	83 ec 08             	sub    $0x8,%esp
f010e4ea:	50                   	push   %eax
f010e4eb:	68 dc 7a 12 f0       	push   $0xf0127adc
f010e4f0:	e8 96 2a ff ff       	call   f0100f8b <cprintf>
f010e4f5:	83 c4 10             	add    $0x10,%esp
}
f010e4f8:	90                   	nop
f010e4f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e4fc:	c9                   	leave  
f010e4fd:	c3                   	ret    

f010e4fe <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e4fe:	55                   	push   %ebp
f010e4ff:	89 e5                	mov    %esp,%ebp
f010e501:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e504:	8b 45 08             	mov    0x8(%ebp),%eax
f010e507:	8b 00                	mov    (%eax),%eax
f010e509:	83 ec 08             	sub    $0x8,%esp
f010e50c:	50                   	push   %eax
f010e50d:	68 ef 7a 12 f0       	push   $0xf0127aef
f010e512:	e8 74 2a ff ff       	call   f0100f8b <cprintf>
f010e517:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e51a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e51d:	8b 40 04             	mov    0x4(%eax),%eax
f010e520:	83 ec 08             	sub    $0x8,%esp
f010e523:	50                   	push   %eax
f010e524:	68 fe 7a 12 f0       	push   $0xf0127afe
f010e529:	e8 5d 2a ff ff       	call   f0100f8b <cprintf>
f010e52e:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e531:	8b 45 08             	mov    0x8(%ebp),%eax
f010e534:	8b 40 08             	mov    0x8(%eax),%eax
f010e537:	83 ec 08             	sub    $0x8,%esp
f010e53a:	50                   	push   %eax
f010e53b:	68 0d 7b 12 f0       	push   $0xf0127b0d
f010e540:	e8 46 2a ff ff       	call   f0100f8b <cprintf>
f010e545:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e548:	8b 45 08             	mov    0x8(%ebp),%eax
f010e54b:	8b 40 0c             	mov    0xc(%eax),%eax
f010e54e:	83 ec 08             	sub    $0x8,%esp
f010e551:	50                   	push   %eax
f010e552:	68 1c 7b 12 f0       	push   $0xf0127b1c
f010e557:	e8 2f 2a ff ff       	call   f0100f8b <cprintf>
f010e55c:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e55f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e562:	8b 40 10             	mov    0x10(%eax),%eax
f010e565:	83 ec 08             	sub    $0x8,%esp
f010e568:	50                   	push   %eax
f010e569:	68 2b 7b 12 f0       	push   $0xf0127b2b
f010e56e:	e8 18 2a ff ff       	call   f0100f8b <cprintf>
f010e573:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e576:	8b 45 08             	mov    0x8(%ebp),%eax
f010e579:	8b 40 14             	mov    0x14(%eax),%eax
f010e57c:	83 ec 08             	sub    $0x8,%esp
f010e57f:	50                   	push   %eax
f010e580:	68 3a 7b 12 f0       	push   $0xf0127b3a
f010e585:	e8 01 2a ff ff       	call   f0100f8b <cprintf>
f010e58a:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e58d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e590:	8b 40 18             	mov    0x18(%eax),%eax
f010e593:	83 ec 08             	sub    $0x8,%esp
f010e596:	50                   	push   %eax
f010e597:	68 49 7b 12 f0       	push   $0xf0127b49
f010e59c:	e8 ea 29 ff ff       	call   f0100f8b <cprintf>
f010e5a1:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e5a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5a7:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e5aa:	83 ec 08             	sub    $0x8,%esp
f010e5ad:	50                   	push   %eax
f010e5ae:	68 58 7b 12 f0       	push   $0xf0127b58
f010e5b3:	e8 d3 29 ff ff       	call   f0100f8b <cprintf>
f010e5b8:	83 c4 10             	add    $0x10,%esp
}
f010e5bb:	90                   	nop
f010e5bc:	c9                   	leave  
f010e5bd:	c3                   	ret    

f010e5be <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e5be:	55                   	push   %ebp
f010e5bf:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e5c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5c4:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e5c7:	89 14 85 60 4f 73 f0 	mov    %edx,-0xf8cb0a0(,%eax,4)
}
f010e5ce:	90                   	nop
f010e5cf:	5d                   	pop    %ebp
f010e5d0:	c3                   	ret    

f010e5d1 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e5d1:	55                   	push   %ebp
f010e5d2:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e5d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5d7:	c7 04 85 60 4f 73 f0 	movl   $0x0,-0xf8cb0a0(,%eax,4)
f010e5de:	00 00 00 00 
}
f010e5e2:	90                   	nop
f010e5e3:	5d                   	pop    %ebp
f010e5e4:	c3                   	ret    

f010e5e5 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e5e5:	55                   	push   %ebp
f010e5e6:	89 e5                	mov    %esp,%ebp
f010e5e8:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e5eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5ee:	8b 40 28             	mov    0x28(%eax),%eax
f010e5f1:	83 e8 20             	sub    $0x20,%eax
f010e5f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e5f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5fa:	8b 04 85 60 4f 73 f0 	mov    -0xf8cb0a0(,%eax,4),%eax
f010e601:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e604:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e608:	74 0e                	je     f010e618 <irq_dispatch+0x33>
	{
		handler(tf);
f010e60a:	83 ec 0c             	sub    $0xc,%esp
f010e60d:	ff 75 08             	pushl  0x8(%ebp)
f010e610:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e613:	ff d0                	call   *%eax
f010e615:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e618:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e61b:	0f b6 c0             	movzbl %al,%eax
f010e61e:	83 ec 0c             	sub    $0xc,%esp
f010e621:	50                   	push   %eax
f010e622:	e8 d7 8d ff ff       	call   f01073fe <pic_sendEOI>
f010e627:	83 c4 10             	add    $0x10,%esp
}
f010e62a:	90                   	nop
f010e62b:	c9                   	leave  
f010e62c:	c3                   	ret    

f010e62d <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e62d:	55                   	push   %ebp
f010e62e:	89 e5                	mov    %esp,%ebp
f010e630:	57                   	push   %edi
f010e631:	56                   	push   %esi
f010e632:	53                   	push   %ebx
f010e633:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e636:	8b 45 08             	mov    0x8(%ebp),%eax
f010e639:	8b 40 28             	mov    0x28(%eax),%eax
f010e63c:	83 f8 0e             	cmp    $0xe,%eax
f010e63f:	75 51                	jne    f010e692 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e641:	a0 a0 4f 73 f0       	mov    0xf0734fa0,%al
f010e646:	84 c0                	test   %al,%al
f010e648:	74 1f                	je     f010e669 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e64a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e64d:	8b 40 30             	mov    0x30(%eax),%eax
f010e650:	89 c2                	mov    %eax,%edx
f010e652:	a0 a0 4f 73 f0       	mov    0xf0734fa0,%al
f010e657:	0f b6 c0             	movzbl %al,%eax
f010e65a:	01 d0                	add    %edx,%eax
f010e65c:	89 c2                	mov    %eax,%edx
f010e65e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e661:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e664:	e9 0c 01 00 00       	jmp    f010e775 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e669:	83 ec 0c             	sub    $0xc,%esp
f010e66c:	6a 01                	push   $0x1
f010e66e:	e8 c0 13 00 00       	call   f010fa33 <isPageReplacmentAlgorithmLRU>
f010e673:	83 c4 10             	add    $0x10,%esp
f010e676:	85 c0                	test   %eax,%eax
f010e678:	74 05                	je     f010e67f <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e67a:	e8 ee 88 ff ff       	call   f0106f6d <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e67f:	83 ec 0c             	sub    $0xc,%esp
f010e682:	ff 75 08             	pushl  0x8(%ebp)
f010e685:	e8 8e 14 00 00       	call   f010fb18 <fault_handler>
f010e68a:	83 c4 10             	add    $0x10,%esp
f010e68d:	e9 e3 00 00 00       	jmp    f010e775 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e692:	8b 45 08             	mov    0x8(%ebp),%eax
f010e695:	8b 40 28             	mov    0x28(%eax),%eax
f010e698:	83 f8 30             	cmp    $0x30,%eax
f010e69b:	75 6e                	jne    f010e70b <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e69d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6a0:	8b 40 38             	mov    0x38(%eax),%eax
f010e6a3:	25 00 02 00 00       	and    $0x200,%eax
f010e6a8:	85 c0                	test   %eax,%eax
f010e6aa:	74 06                	je     f010e6b2 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e6ac:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e6ad:	e8 1e 68 ff ff       	call   f0104ed0 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e6b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6b5:	8b 78 04             	mov    0x4(%eax),%edi
f010e6b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6bb:	8b 30                	mov    (%eax),%esi
f010e6bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6c0:	8b 58 10             	mov    0x10(%eax),%ebx
f010e6c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6c6:	8b 48 18             	mov    0x18(%eax),%ecx
f010e6c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6cc:	8b 50 14             	mov    0x14(%eax),%edx
f010e6cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6d2:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e6d5:	83 ec 08             	sub    $0x8,%esp
f010e6d8:	57                   	push   %edi
f010e6d9:	56                   	push   %esi
f010e6da:	53                   	push   %ebx
f010e6db:	51                   	push   %ecx
f010e6dc:	52                   	push   %edx
f010e6dd:	50                   	push   %eax
f010e6de:	e8 0d 0a 00 00       	call   f010f0f0 <syscall>
f010e6e3:	83 c4 20             	add    $0x20,%esp
f010e6e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e6e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6ec:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e6ef:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e6f2:	9c                   	pushf  
f010e6f3:	58                   	pop    %eax
f010e6f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e6f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e6fa:	25 00 02 00 00       	and    $0x200,%eax
f010e6ff:	85 c0                	test   %eax,%eax
f010e701:	74 72                	je     f010e775 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e703:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e704:	e8 9f 67 ff ff       	call   f0104ea8 <kclock_stop>
f010e709:	eb 6a                	jmp    f010e775 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e70b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e70e:	8b 40 28             	mov    0x28(%eax),%eax
f010e711:	83 f8 08             	cmp    $0x8,%eax
f010e714:	75 17                	jne    f010e72d <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e716:	83 ec 04             	sub    $0x4,%esp
f010e719:	68 67 7b 12 f0       	push   $0xf0127b67
f010e71e:	68 22 01 00 00       	push   $0x122
f010e723:	68 76 7b 12 f0       	push   $0xf0127b76
f010e728:	e8 0c 1c ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e72d:	83 ec 0c             	sub    $0xc,%esp
f010e730:	ff 75 08             	pushl  0x8(%ebp)
f010e733:	e8 a3 fc ff ff       	call   f010e3db <print_trapframe>
f010e738:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e73b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e73e:	8b 40 34             	mov    0x34(%eax),%eax
f010e741:	66 83 f8 08          	cmp    $0x8,%ax
f010e745:	75 17                	jne    f010e75e <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e747:	83 ec 04             	sub    $0x4,%esp
f010e74a:	68 87 7b 12 f0       	push   $0xf0127b87
f010e74f:	68 2a 01 00 00       	push   $0x12a
f010e754:	68 76 7b 12 f0       	push   $0xf0127b76
f010e759:	e8 db 1b ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e75e:	83 ec 04             	sub    $0x4,%esp
f010e761:	68 a0 7b 12 f0       	push   $0xf0127ba0
f010e766:	68 2f 01 00 00       	push   $0x12f
f010e76b:	68 76 7b 12 f0       	push   $0xf0127b76
f010e770:	e8 c4 1b ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e775:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e778:	5b                   	pop    %ebx
f010e779:	5e                   	pop    %esi
f010e77a:	5f                   	pop    %edi
f010e77b:	5d                   	pop    %ebp
f010e77c:	c3                   	ret    

f010e77d <trap>:

void trap(struct Trapframe *tf)
{
f010e77d:	55                   	push   %ebp
f010e77e:	89 e5                	mov    %esp,%ebp
f010e780:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e783:	e8 20 67 ff ff       	call   f0104ea8 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e788:	9c                   	pushf  
f010e789:	58                   	pop    %eax
f010e78a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e78d:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e790:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e793:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e796:	25 00 02 00 00       	and    $0x200,%eax
f010e79b:	85 c0                	test   %eax,%eax
f010e79d:	74 25                	je     f010e7c4 <trap+0x47>
	{
		print_trapframe(tf);
f010e79f:	83 ec 0c             	sub    $0xc,%esp
f010e7a2:	ff 75 08             	pushl  0x8(%ebp)
f010e7a5:	e8 31 fc ff ff       	call   f010e3db <print_trapframe>
f010e7aa:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e7ad:	83 ec 04             	sub    $0x4,%esp
f010e7b0:	68 c0 7b 12 f0       	push   $0xf0127bc0
f010e7b5:	68 45 01 00 00       	push   $0x145
f010e7ba:	68 76 7b 12 f0       	push   $0xf0127b76
f010e7bf:	e8 75 1b ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e7c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e7cb:	e8 55 d5 ff ff       	call   f010bd25 <get_cpu_proc>
f010e7d0:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e7d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7d6:	8b 40 34             	mov    0x34(%eax),%eax
f010e7d9:	0f b7 c0             	movzwl %ax,%eax
f010e7dc:	83 e0 03             	and    $0x3,%eax
f010e7df:	83 f8 03             	cmp    $0x3,%eax
f010e7e2:	75 54                	jne    f010e838 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e7e4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e7e8:	74 0b                	je     f010e7f5 <trap+0x78>
f010e7ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e7ed:	8b 40 18             	mov    0x18(%eax),%eax
f010e7f0:	83 f8 02             	cmp    $0x2,%eax
f010e7f3:	74 19                	je     f010e80e <trap+0x91>
f010e7f5:	68 04 7c 12 f0       	push   $0xf0127c04
f010e7fa:	68 32 7c 12 f0       	push   $0xf0127c32
f010e7ff:	68 4d 01 00 00       	push   $0x14d
f010e804:	68 76 7b 12 f0       	push   $0xf0127b76
f010e809:	e8 2b 1b ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e80e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e811:	8b 00                	mov    (%eax),%eax
f010e813:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e816:	74 19                	je     f010e831 <trap+0xb4>
f010e818:	68 47 7c 12 f0       	push   $0xf0127c47
f010e81d:	68 32 7c 12 f0       	push   $0xf0127c32
f010e822:	68 4f 01 00 00       	push   $0x14f
f010e827:	68 76 7b 12 f0       	push   $0xf0127b76
f010e82c:	e8 08 1b ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010e831:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e838:	8b 45 08             	mov    0x8(%ebp),%eax
f010e83b:	8b 40 28             	mov    0x28(%eax),%eax
f010e83e:	83 f8 1f             	cmp    $0x1f,%eax
f010e841:	76 1b                	jbe    f010e85e <trap+0xe1>
f010e843:	8b 45 08             	mov    0x8(%ebp),%eax
f010e846:	8b 40 28             	mov    0x28(%eax),%eax
f010e849:	83 f8 2f             	cmp    $0x2f,%eax
f010e84c:	77 10                	ja     f010e85e <trap+0xe1>
	{
		irq_dispatch(tf);
f010e84e:	83 ec 0c             	sub    $0xc,%esp
f010e851:	ff 75 08             	pushl  0x8(%ebp)
f010e854:	e8 8c fd ff ff       	call   f010e5e5 <irq_dispatch>
f010e859:	83 c4 10             	add    $0x10,%esp
f010e85c:	eb 0e                	jmp    f010e86c <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010e85e:	83 ec 0c             	sub    $0xc,%esp
f010e861:	ff 75 08             	pushl  0x8(%ebp)
f010e864:	e8 c4 fd ff ff       	call   f010e62d <trap_dispatch>
f010e869:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e86c:	9c                   	pushf  
f010e86d:	58                   	pop    %eax
f010e86e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010e871:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e874:	25 00 02 00 00       	and    $0x200,%eax
f010e879:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010e87c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e880:	74 19                	je     f010e89b <trap+0x11e>
f010e882:	68 5d 7c 12 f0       	push   $0xf0127c5d
f010e887:	68 32 7c 12 f0       	push   $0xf0127c32
f010e88c:	68 66 01 00 00       	push   $0x166
f010e891:	68 76 7b 12 f0       	push   $0xf0127b76
f010e896:	e8 9e 1a ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e89b:	e8 30 66 ff ff       	call   f0104ed0 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e8a0:	90                   	nop
f010e8a1:	c9                   	leave  
f010e8a2:	c3                   	ret    
f010e8a3:	90                   	nop

f010e8a4 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e8a4:	6a 08                	push   $0x8
f010e8a6:	e9 ed 00 00 00       	jmp    f010e998 <_alltraps>
f010e8ab:	90                   	nop

f010e8ac <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e8ac:	6a 0e                	push   $0xe
f010e8ae:	e9 e5 00 00 00       	jmp    f010e998 <_alltraps>
f010e8b3:	90                   	nop

f010e8b4 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e8b4:	6a 00                	push   $0x0
f010e8b6:	6a 20                	push   $0x20
f010e8b8:	e9 db 00 00 00       	jmp    f010e998 <_alltraps>
f010e8bd:	90                   	nop

f010e8be <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e8be:	6a 00                	push   $0x0
f010e8c0:	6a 21                	push   $0x21
f010e8c2:	e9 d1 00 00 00       	jmp    f010e998 <_alltraps>
f010e8c7:	90                   	nop

f010e8c8 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e8c8:	6a 00                	push   $0x0
f010e8ca:	6a 30                	push   $0x30
f010e8cc:	e9 c7 00 00 00       	jmp    f010e998 <_alltraps>
f010e8d1:	90                   	nop

f010e8d2 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e8d2:	6a 00                	push   $0x0
f010e8d4:	6a 00                	push   $0x0
f010e8d6:	e9 bd 00 00 00       	jmp    f010e998 <_alltraps>
f010e8db:	90                   	nop

f010e8dc <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e8dc:	6a 00                	push   $0x0
f010e8de:	6a 01                	push   $0x1
f010e8e0:	e9 b3 00 00 00       	jmp    f010e998 <_alltraps>
f010e8e5:	90                   	nop

f010e8e6 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e8e6:	6a 00                	push   $0x0
f010e8e8:	6a 02                	push   $0x2
f010e8ea:	e9 a9 00 00 00       	jmp    f010e998 <_alltraps>
f010e8ef:	90                   	nop

f010e8f0 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e8f0:	6a 00                	push   $0x0
f010e8f2:	6a 03                	push   $0x3
f010e8f4:	e9 9f 00 00 00       	jmp    f010e998 <_alltraps>
f010e8f9:	90                   	nop

f010e8fa <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e8fa:	6a 00                	push   $0x0
f010e8fc:	6a 04                	push   $0x4
f010e8fe:	e9 95 00 00 00       	jmp    f010e998 <_alltraps>
f010e903:	90                   	nop

f010e904 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e904:	6a 00                	push   $0x0
f010e906:	6a 05                	push   $0x5
f010e908:	e9 8b 00 00 00       	jmp    f010e998 <_alltraps>
f010e90d:	90                   	nop

f010e90e <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e90e:	6a 00                	push   $0x0
f010e910:	6a 06                	push   $0x6
f010e912:	e9 81 00 00 00       	jmp    f010e998 <_alltraps>
f010e917:	90                   	nop

f010e918 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e918:	6a 00                	push   $0x0
f010e91a:	6a 07                	push   $0x7
f010e91c:	eb 7a                	jmp    f010e998 <_alltraps>

f010e91e <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e91e:	6a 0a                	push   $0xa
f010e920:	eb 76                	jmp    f010e998 <_alltraps>

f010e922 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e922:	6a 0b                	push   $0xb
f010e924:	eb 72                	jmp    f010e998 <_alltraps>

f010e926 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e926:	6a 0c                	push   $0xc
f010e928:	eb 6e                	jmp    f010e998 <_alltraps>

f010e92a <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e92a:	6a 0d                	push   $0xd
f010e92c:	eb 6a                	jmp    f010e998 <_alltraps>

f010e92e <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e92e:	6a 00                	push   $0x0
f010e930:	6a 10                	push   $0x10
f010e932:	eb 64                	jmp    f010e998 <_alltraps>

f010e934 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e934:	6a 11                	push   $0x11
f010e936:	eb 60                	jmp    f010e998 <_alltraps>

f010e938 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e938:	6a 00                	push   $0x0
f010e93a:	6a 12                	push   $0x12
f010e93c:	eb 5a                	jmp    f010e998 <_alltraps>

f010e93e <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e93e:	6a 00                	push   $0x0
f010e940:	6a 13                	push   $0x13
f010e942:	eb 54                	jmp    f010e998 <_alltraps>

f010e944 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e944:	6a 00                	push   $0x0
f010e946:	6a 22                	push   $0x22
f010e948:	eb 4e                	jmp    f010e998 <_alltraps>

f010e94a <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e94a:	6a 00                	push   $0x0
f010e94c:	6a 23                	push   $0x23
f010e94e:	eb 48                	jmp    f010e998 <_alltraps>

f010e950 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e950:	6a 00                	push   $0x0
f010e952:	6a 24                	push   $0x24
f010e954:	eb 42                	jmp    f010e998 <_alltraps>

f010e956 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e956:	6a 00                	push   $0x0
f010e958:	6a 25                	push   $0x25
f010e95a:	eb 3c                	jmp    f010e998 <_alltraps>

f010e95c <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e95c:	6a 00                	push   $0x0
f010e95e:	6a 26                	push   $0x26
f010e960:	eb 36                	jmp    f010e998 <_alltraps>

f010e962 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e962:	6a 00                	push   $0x0
f010e964:	6a 27                	push   $0x27
f010e966:	eb 30                	jmp    f010e998 <_alltraps>

f010e968 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e968:	6a 00                	push   $0x0
f010e96a:	6a 28                	push   $0x28
f010e96c:	eb 2a                	jmp    f010e998 <_alltraps>

f010e96e <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e96e:	6a 00                	push   $0x0
f010e970:	6a 29                	push   $0x29
f010e972:	eb 24                	jmp    f010e998 <_alltraps>

f010e974 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e974:	6a 00                	push   $0x0
f010e976:	6a 2a                	push   $0x2a
f010e978:	eb 1e                	jmp    f010e998 <_alltraps>

f010e97a <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e97a:	6a 00                	push   $0x0
f010e97c:	6a 2b                	push   $0x2b
f010e97e:	eb 18                	jmp    f010e998 <_alltraps>

f010e980 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e980:	6a 00                	push   $0x0
f010e982:	6a 2c                	push   $0x2c
f010e984:	eb 12                	jmp    f010e998 <_alltraps>

f010e986 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e986:	6a 00                	push   $0x0
f010e988:	6a 2d                	push   $0x2d
f010e98a:	eb 0c                	jmp    f010e998 <_alltraps>

f010e98c <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e98c:	6a 00                	push   $0x0
f010e98e:	6a 2e                	push   $0x2e
f010e990:	eb 06                	jmp    f010e998 <_alltraps>

f010e992 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e992:	6a 00                	push   $0x0
f010e994:	6a 2f                	push   $0x2f
f010e996:	eb 00                	jmp    f010e998 <_alltraps>

f010e998 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e998:	1e                   	push   %ds
push 	%es
f010e999:	06                   	push   %es
pushal
f010e99a:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e99b:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e99f:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e9a1:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e9a3:	54                   	push   %esp
call 	trap
f010e9a4:	e8 d4 fd ff ff       	call   f010e77d <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e9a9:	59                   	pop    %ecx

f010e9aa <trapret>:
.globl trapret
trapret:
popal
f010e9aa:	61                   	popa   
pop 	%es
f010e9ab:	07                   	pop    %es
pop 	%ds
f010e9ac:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e9ad:	83 c4 08             	add    $0x8,%esp
iret
f010e9b0:	cf                   	iret   

f010e9b1 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e9b1:	55                   	push   %ebp
f010e9b2:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e9b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9b7:	8b 15 20 d7 b5 f0    	mov    0xf0b5d720,%edx
f010e9bd:	29 d0                	sub    %edx,%eax
f010e9bf:	c1 f8 03             	sar    $0x3,%eax
f010e9c2:	89 c2                	mov    %eax,%edx
f010e9c4:	89 d0                	mov    %edx,%eax
f010e9c6:	c1 e0 02             	shl    $0x2,%eax
f010e9c9:	01 d0                	add    %edx,%eax
f010e9cb:	c1 e0 02             	shl    $0x2,%eax
f010e9ce:	01 d0                	add    %edx,%eax
f010e9d0:	c1 e0 02             	shl    $0x2,%eax
f010e9d3:	01 d0                	add    %edx,%eax
f010e9d5:	89 c1                	mov    %eax,%ecx
f010e9d7:	c1 e1 08             	shl    $0x8,%ecx
f010e9da:	01 c8                	add    %ecx,%eax
f010e9dc:	89 c1                	mov    %eax,%ecx
f010e9de:	c1 e1 10             	shl    $0x10,%ecx
f010e9e1:	01 c8                	add    %ecx,%eax
f010e9e3:	01 c0                	add    %eax,%eax
f010e9e5:	01 d0                	add    %edx,%eax
}
f010e9e7:	5d                   	pop    %ebp
f010e9e8:	c3                   	ret    

f010e9e9 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e9e9:	55                   	push   %ebp
f010e9ea:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e9ec:	ff 75 08             	pushl  0x8(%ebp)
f010e9ef:	e8 bd ff ff ff       	call   f010e9b1 <to_frame_number>
f010e9f4:	83 c4 04             	add    $0x4,%esp
f010e9f7:	c1 e0 0c             	shl    $0xc,%eax
}
f010e9fa:	c9                   	leave  
f010e9fb:	c3                   	ret    

f010e9fc <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e9fc:	55                   	push   %ebp
f010e9fd:	89 e5                	mov    %esp,%ebp
f010e9ff:	83 ec 18             	sub    $0x18,%esp
f010ea02:	8b 45 10             	mov    0x10(%ebp),%eax
f010ea05:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010ea08:	e8 ed 8a ff ff       	call   f01074fa <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010ea0d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010ea11:	74 23                	je     f010ea36 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010ea13:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ea18:	8b 40 10             	mov    0x10(%eax),%eax
f010ea1b:	8b 15 80 bf 6e f2    	mov    0xf26ebf80,%edx
f010ea21:	83 c2 20             	add    $0x20,%edx
f010ea24:	83 ec 04             	sub    $0x4,%esp
f010ea27:	50                   	push   %eax
f010ea28:	52                   	push   %edx
f010ea29:	68 10 7e 12 f0       	push   $0xf0127e10
f010ea2e:	e8 58 25 ff ff       	call   f0100f8b <cprintf>
f010ea33:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010ea36:	83 ec 04             	sub    $0x4,%esp
f010ea39:	ff 75 08             	pushl  0x8(%ebp)
f010ea3c:	ff 75 0c             	pushl  0xc(%ebp)
f010ea3f:	68 19 7e 12 f0       	push   $0xf0127e19
f010ea44:	e8 42 25 ff ff       	call   f0100f8b <cprintf>
f010ea49:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010ea4c:	e8 fb 8a ff ff       	call   f010754c <popcli>
}
f010ea51:	90                   	nop
f010ea52:	c9                   	leave  
f010ea53:	c3                   	ret    

f010ea54 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010ea54:	55                   	push   %ebp
f010ea55:	89 e5                	mov    %esp,%ebp
f010ea57:	83 ec 18             	sub    $0x18,%esp
f010ea5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea5d:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010ea60:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010ea64:	83 ec 08             	sub    $0x8,%esp
f010ea67:	50                   	push   %eax
f010ea68:	68 1e 7e 12 f0       	push   $0xf0127e1e
f010ea6d:	e8 19 25 ff ff       	call   f0100f8b <cprintf>
f010ea72:	83 c4 10             	add    $0x10,%esp
}
f010ea75:	90                   	nop
f010ea76:	c9                   	leave  
f010ea77:	c3                   	ret    

f010ea78 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010ea78:	55                   	push   %ebp
f010ea79:	89 e5                	mov    %esp,%ebp
f010ea7b:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ea7e:	9c                   	pushf  
f010ea7f:	58                   	pop    %eax
f010ea80:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010ea83:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010ea86:	25 00 02 00 00       	and    $0x200,%eax
f010ea8b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010ea8e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ea92:	74 10                	je     f010eaa4 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010ea94:	e8 2b 23 ff ff       	call   f0100dc4 <cons_getc2>
f010ea99:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ea9c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eaa0:	74 f2                	je     f010ea94 <sys_cgetc+0x1c>
f010eaa2:	eb 0e                	jmp    f010eab2 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010eaa4:	e8 c0 22 ff ff       	call   f0100d69 <cons_getc>
f010eaa9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eaac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eab0:	74 f2                	je     f010eaa4 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010eab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eab5:	c9                   	leave  
f010eab6:	c3                   	ret    

f010eab7 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010eab7:	55                   	push   %ebp
f010eab8:	89 e5                	mov    %esp,%ebp
f010eaba:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010eabd:	e8 ee 23 ff ff       	call   f0100eb0 <cons_lock>
}
f010eac2:	90                   	nop
f010eac3:	c9                   	leave  
f010eac4:	c3                   	ret    

f010eac5 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010eac5:	55                   	push   %ebp
f010eac6:	89 e5                	mov    %esp,%ebp
f010eac8:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010eacb:	e8 27 24 ff ff       	call   f0100ef7 <cons_unlock>
}
f010ead0:	90                   	nop
f010ead1:	c9                   	leave  
f010ead2:	c3                   	ret    

f010ead3 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010ead3:	55                   	push   %ebp
f010ead4:	89 e5                	mov    %esp,%ebp
f010ead6:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010ead9:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010eade:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010eae1:	83 ec 0c             	sub    $0xc,%esp
f010eae4:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010eae7:	50                   	push   %eax
f010eae8:	e8 f0 99 ff ff       	call   f01084dd <allocate_frame>
f010eaed:	83 c4 10             	add    $0x10,%esp
f010eaf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010eaf3:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010eaf7:	75 08                	jne    f010eb01 <__sys_allocate_page+0x2e>
		return r ;
f010eaf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eafc:	e9 e9 00 00 00       	jmp    f010ebea <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010eb01:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb04:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010eb09:	77 0c                	ja     f010eb17 <__sys_allocate_page+0x44>
f010eb0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb0e:	25 ff 0f 00 00       	and    $0xfff,%eax
f010eb13:	85 c0                	test   %eax,%eax
f010eb15:	74 0a                	je     f010eb21 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010eb17:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010eb1c:	e9 c9 00 00 00       	jmp    f010ebea <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010eb21:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb24:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010eb29:	83 f8 04             	cmp    $0x4,%eax
f010eb2c:	74 0a                	je     f010eb38 <__sys_allocate_page+0x65>
		return E_INVAL;
f010eb2e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010eb33:	e9 b2 00 00 00       	jmp    f010ebea <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010eb38:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eb3b:	83 ec 0c             	sub    $0xc,%esp
f010eb3e:	50                   	push   %eax
f010eb3f:	e8 a5 fe ff ff       	call   f010e9e9 <to_physical_address>
f010eb44:	83 c4 10             	add    $0x10,%esp
f010eb47:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010eb4a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eb4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eb50:	8b 40 64             	mov    0x64(%eax),%eax
f010eb53:	6a 02                	push   $0x2
f010eb55:	68 00 00 80 ef       	push   $0xef800000
f010eb5a:	52                   	push   %edx
f010eb5b:	50                   	push   %eax
f010eb5c:	e8 49 9e ff ff       	call   f01089aa <map_frame>
f010eb61:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010eb64:	83 ec 04             	sub    $0x4,%esp
f010eb67:	68 00 10 00 00       	push   $0x1000
f010eb6c:	6a 00                	push   $0x0
f010eb6e:	68 00 00 80 ef       	push   $0xef800000
f010eb73:	e8 92 16 01 00       	call   f012020a <memset>
f010eb78:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010eb7b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eb7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eb81:	8b 40 08             	mov    0x8(%eax),%eax
f010eb84:	40                   	inc    %eax
f010eb85:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010eb89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eb8c:	8b 40 64             	mov    0x64(%eax),%eax
f010eb8f:	83 ec 08             	sub    $0x8,%esp
f010eb92:	68 00 00 80 ef       	push   $0xef800000
f010eb97:	50                   	push   %eax
f010eb98:	e8 6d 9f ff ff       	call   f0108b0a <unmap_frame>
f010eb9d:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010eba0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eba3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eba6:	8b 40 08             	mov    0x8(%eax),%eax
f010eba9:	48                   	dec    %eax
f010ebaa:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010ebae:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ebb1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ebb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ebb7:	8b 40 64             	mov    0x64(%eax),%eax
f010ebba:	ff 75 0c             	pushl  0xc(%ebp)
f010ebbd:	51                   	push   %ecx
f010ebbe:	52                   	push   %edx
f010ebbf:	50                   	push   %eax
f010ebc0:	e8 e5 9d ff ff       	call   f01089aa <map_frame>
f010ebc5:	83 c4 10             	add    $0x10,%esp
f010ebc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010ebcb:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010ebcf:	75 14                	jne    f010ebe5 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010ebd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ebd4:	83 ec 0c             	sub    $0xc,%esp
f010ebd7:	50                   	push   %eax
f010ebd8:	e8 0d 9b ff ff       	call   f01086ea <decrement_references>
f010ebdd:	83 c4 10             	add    $0x10,%esp
		return r;
f010ebe0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ebe3:	eb 05                	jmp    f010ebea <__sys_allocate_page+0x117>
	}
	return 0 ;
f010ebe5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ebea:	c9                   	leave  
f010ebeb:	c3                   	ret    

f010ebec <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010ebec:	55                   	push   %ebp
f010ebed:	89 e5                	mov    %esp,%ebp
f010ebef:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010ebf2:	83 ec 04             	sub    $0x4,%esp
f010ebf5:	68 21 7e 12 f0       	push   $0xf0127e21
f010ebfa:	68 dc 00 00 00       	push   $0xdc
f010ebff:	68 3f 7e 12 f0       	push   $0xf0127e3f
f010ec04:	e8 30 17 ff ff       	call   f0100339 <_panic>

f010ec09 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010ec09:	55                   	push   %ebp
f010ec0a:	89 e5                	mov    %esp,%ebp
f010ec0c:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010ec0f:	83 ec 04             	sub    $0x4,%esp
f010ec12:	68 54 7e 12 f0       	push   $0xf0127e54
f010ec17:	68 ed 00 00 00       	push   $0xed
f010ec1c:	68 3f 7e 12 f0       	push   $0xf0127e3f
f010ec21:	e8 13 17 ff ff       	call   f0100339 <_panic>

f010ec26 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010ec26:	55                   	push   %ebp
f010ec27:	89 e5                	mov    %esp,%ebp
f010ec29:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010ec2c:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ec31:	8b 40 64             	mov    0x64(%eax),%eax
f010ec34:	83 ec 04             	sub    $0x4,%esp
f010ec37:	ff 75 0c             	pushl  0xc(%ebp)
f010ec3a:	ff 75 08             	pushl  0x8(%ebp)
f010ec3d:	50                   	push   %eax
f010ec3e:	e8 69 c2 ff ff       	call   f010aeac <calculate_required_frames>
f010ec43:	83 c4 10             	add    $0x10,%esp
}
f010ec46:	c9                   	leave  
f010ec47:	c3                   	ret    

f010ec48 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010ec48:	55                   	push   %ebp
f010ec49:	89 e5                	mov    %esp,%ebp
f010ec4b:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ec4e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ec51:	83 ec 0c             	sub    $0xc,%esp
f010ec54:	50                   	push   %eax
f010ec55:	e8 32 a0 ff ff       	call   f0108c8c <calculate_available_frames>
f010ec5a:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010ec5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ec60:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec63:	01 d0                	add    %edx,%eax
}
f010ec65:	c9                   	leave  
f010ec66:	c3                   	ret    

f010ec67 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010ec67:	55                   	push   %ebp
f010ec68:	89 e5                	mov    %esp,%ebp
f010ec6a:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ec6d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ec70:	83 ec 0c             	sub    $0xc,%esp
f010ec73:	50                   	push   %eax
f010ec74:	e8 13 a0 ff ff       	call   f0108c8c <calculate_available_frames>
f010ec79:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010ec7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ec7f:	c9                   	leave  
f010ec80:	c3                   	ret    

f010ec81 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010ec81:	55                   	push   %ebp
f010ec82:	89 e5                	mov    %esp,%ebp
f010ec84:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ec87:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ec8a:	83 ec 0c             	sub    $0xc,%esp
f010ec8d:	50                   	push   %eax
f010ec8e:	e8 f9 9f ff ff       	call   f0108c8c <calculate_available_frames>
f010ec93:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010ec96:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010ec99:	c9                   	leave  
f010ec9a:	c3                   	ret    

f010ec9b <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010ec9b:	55                   	push   %ebp
f010ec9c:	89 e5                	mov    %esp,%ebp
f010ec9e:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010eca1:	83 ec 0c             	sub    $0xc,%esp
f010eca4:	ff 75 08             	pushl  0x8(%ebp)
f010eca7:	e8 07 01 01 00       	call   f011edb3 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010ecac:	83 c4 10             	add    $0x10,%esp
}
f010ecaf:	c9                   	leave  
f010ecb0:	c3                   	ret    

f010ecb1 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010ecb1:	55                   	push   %ebp
f010ecb2:	89 e5                	mov    %esp,%ebp
f010ecb4:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010ecb7:	e8 22 00 01 00       	call   f011ecde <scarce_memory>
}
f010ecbc:	90                   	nop
f010ecbd:	c9                   	leave  
f010ecbe:	c3                   	ret    

f010ecbf <sys_clearFFL>:

void sys_clearFFL()
{
f010ecbf:	55                   	push   %ebp
f010ecc0:	89 e5                	mov    %esp,%ebp
f010ecc2:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010ecc5:	83 ec 0c             	sub    $0xc,%esp
f010ecc8:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f010eccd:	e8 9c 13 00 00       	call   f011006e <acquire_spinlock>
f010ecd2:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010ecd5:	a1 cc d2 b5 f0       	mov    0xf0b5d2cc,%eax
f010ecda:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ecdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ece4:	eb 12                	jmp    f010ecf8 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010ece6:	83 ec 0c             	sub    $0xc,%esp
f010ece9:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ecec:	50                   	push   %eax
f010eced:	e8 eb 97 ff ff       	call   f01084dd <allocate_frame>
f010ecf2:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ecf5:	ff 45 f4             	incl   -0xc(%ebp)
f010ecf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecfb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ecfe:	7c e6                	jl     f010ece6 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010ed00:	83 ec 0c             	sub    $0xc,%esp
f010ed03:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f010ed08:	e8 e8 13 00 00       	call   f01100f5 <release_spinlock>
f010ed0d:	83 c4 10             	add    $0x10,%esp
}
f010ed10:	90                   	nop
f010ed11:	c9                   	leave  
f010ed12:	c3                   	ret    

f010ed13 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010ed13:	55                   	push   %ebp
f010ed14:	89 e5                	mov    %esp,%ebp
f010ed16:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010ed19:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ed1e:	83 ec 0c             	sub    $0xc,%esp
f010ed21:	50                   	push   %eax
f010ed22:	e8 c6 5c ff ff       	call   f01049ed <pf_calculate_allocated_pages>
f010ed27:	83 c4 10             	add    $0x10,%esp
}
f010ed2a:	c9                   	leave  
f010ed2b:	c3                   	ret    

f010ed2c <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010ed2c:	55                   	push   %ebp
f010ed2d:	89 e5                	mov    %esp,%ebp
f010ed2f:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010ed32:	e8 bf 0d 00 00       	call   f010faf6 <isBufferingEnabled>
f010ed37:	84 c0                	test   %al,%al
f010ed39:	74 19                	je     f010ed54 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010ed3b:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ed40:	83 ec 04             	sub    $0x4,%esp
f010ed43:	ff 75 0c             	pushl  0xc(%ebp)
f010ed46:	ff 75 08             	pushl  0x8(%ebp)
f010ed49:	50                   	push   %eax
f010ed4a:	e8 48 c3 ff ff       	call   f010b097 <__free_user_mem_with_buffering>
f010ed4f:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ed52:	eb 18                	jmp    f010ed6c <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010ed54:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ed59:	83 ec 04             	sub    $0x4,%esp
f010ed5c:	ff 75 0c             	pushl  0xc(%ebp)
f010ed5f:	ff 75 08             	pushl  0x8(%ebp)
f010ed62:	50                   	push   %eax
f010ed63:	e8 a3 c2 ff ff       	call   f010b00b <free_user_mem>
f010ed68:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ed6b:	90                   	nop
}
f010ed6c:	c9                   	leave  
f010ed6d:	c3                   	ret    

f010ed6e <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010ed6e:	55                   	push   %ebp
f010ed6f:	89 e5                	mov    %esp,%ebp
f010ed71:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010ed74:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ed78:	75 07                	jne    f010ed81 <check_Param+0x13>
	{
		env_exit();
f010ed7a:	e8 64 cf ff ff       	call   f010bce3 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ed7f:	eb 25                	jmp    f010eda6 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010ed81:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010ed88:	77 07                	ja     f010ed91 <check_Param+0x23>
f010ed8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed8d:	85 c0                	test   %eax,%eax
f010ed8f:	78 07                	js     f010ed98 <check_Param+0x2a>
	{
		env_exit();
f010ed91:	e8 4d cf ff ff       	call   f010bce3 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010ed96:	eb 0e                	jmp    f010eda6 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010ed98:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010ed9f:	76 05                	jbe    f010eda6 <check_Param+0x38>
	{
		env_exit();
f010eda1:	e8 3d cf ff ff       	call   f010bce3 <env_exit>
	}
}
f010eda6:	90                   	nop
f010eda7:	c9                   	leave  
f010eda8:	c3                   	ret    

f010eda9 <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010eda9:	55                   	push   %ebp
f010edaa:	89 e5                	mov    %esp,%ebp
f010edac:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010edaf:	83 ec 0c             	sub    $0xc,%esp
f010edb2:	ff 75 08             	pushl  0x8(%ebp)
f010edb5:	e8 b4 ff ff ff       	call   f010ed6e <check_Param>
f010edba:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010edbd:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010edc2:	83 ec 04             	sub    $0x4,%esp
f010edc5:	ff 75 0c             	pushl  0xc(%ebp)
f010edc8:	ff 75 08             	pushl  0x8(%ebp)
f010edcb:	50                   	push   %eax
f010edcc:	e8 7f c1 ff ff       	call   f010af50 <allocate_user_mem>
f010edd1:	83 c4 10             	add    $0x10,%esp
	return;
f010edd4:	90                   	nop
}
f010edd5:	c9                   	leave  
f010edd6:	c3                   	ret    

f010edd7 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010edd7:	55                   	push   %ebp
f010edd8:	89 e5                	mov    %esp,%ebp
f010edda:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010eddd:	83 ec 0c             	sub    $0xc,%esp
f010ede0:	ff 75 08             	pushl  0x8(%ebp)
f010ede3:	e8 86 ff ff ff       	call   f010ed6e <check_Param>
f010ede8:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010edeb:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010edf0:	8b 40 64             	mov    0x64(%eax),%eax
f010edf3:	ff 75 10             	pushl  0x10(%ebp)
f010edf6:	ff 75 0c             	pushl  0xc(%ebp)
f010edf9:	ff 75 08             	pushl  0x8(%ebp)
f010edfc:	50                   	push   %eax
f010edfd:	e8 76 c0 ff ff       	call   f010ae78 <allocate_chunk>
f010ee02:	83 c4 10             	add    $0x10,%esp
	return;
f010ee05:	90                   	nop
}
f010ee06:	c9                   	leave  
f010ee07:	c3                   	ret    

f010ee08 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ee08:	55                   	push   %ebp
f010ee09:	89 e5                	mov    %esp,%ebp
f010ee0b:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010ee0e:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ee13:	ff 75 10             	pushl  0x10(%ebp)
f010ee16:	ff 75 0c             	pushl  0xc(%ebp)
f010ee19:	ff 75 08             	pushl  0x8(%ebp)
f010ee1c:	50                   	push   %eax
f010ee1d:	e8 92 c2 ff ff       	call   f010b0b4 <move_user_mem>
f010ee22:	83 c4 10             	add    $0x10,%esp
	return;
f010ee25:	90                   	nop
}
f010ee26:	c9                   	leave  
f010ee27:	c3                   	ret    

f010ee28 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010ee28:	55                   	push   %ebp
f010ee29:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010ee2b:	a1 04 d7 b5 f0       	mov    0xf0b5d704,%eax
}
f010ee30:	5d                   	pop    %ebp
f010ee31:	c3                   	ret    

f010ee32 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010ee32:	55                   	push   %ebp
f010ee33:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010ee35:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee38:	a3 04 d7 b5 f0       	mov    %eax,0xf0b5d704
}
f010ee3d:	90                   	nop
f010ee3e:	5d                   	pop    %ebp
f010ee3f:	c3                   	ret    

f010ee40 <sys_get_cpu_process>:
/*******************************/
/* SEMAPHORES SYSTEM CALLS */
/*******************************/
//[PROJECT'24.MS3] ADD SUITABLE CODE HERE
struct Env * sys_get_cpu_process()
{
f010ee40:	55                   	push   %ebp
f010ee41:	89 e5                	mov    %esp,%ebp
    return cur_env;
f010ee43:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
}
f010ee48:	5d                   	pop    %ebp
f010ee49:	c3                   	ret    

f010ee4a <sys_init_queue>:
void sys_init_queue(struct Env_Queue* queue){
f010ee4a:	55                   	push   %ebp
f010ee4b:	89 e5                	mov    %esp,%ebp
f010ee4d:	83 ec 08             	sub    $0x8,%esp
	init_queue(queue);
f010ee50:	83 ec 0c             	sub    $0xc,%esp
f010ee53:	ff 75 08             	pushl  0x8(%ebp)
f010ee56:	e8 fc 62 ff ff       	call   f0105157 <init_queue>
f010ee5b:	83 c4 10             	add    $0x10,%esp
}
f010ee5e:	90                   	nop
f010ee5f:	c9                   	leave  
f010ee60:	c3                   	ret    

f010ee61 <sys_enqueue>:
void sys_enqueue(struct Env_Queue* queue, struct Env* env){
f010ee61:	55                   	push   %ebp
f010ee62:	89 e5                	mov    %esp,%ebp
f010ee64:	83 ec 08             	sub    $0x8,%esp
	enqueue(queue,env);
f010ee67:	83 ec 08             	sub    $0x8,%esp
f010ee6a:	ff 75 0c             	pushl  0xc(%ebp)
f010ee6d:	ff 75 08             	pushl  0x8(%ebp)
f010ee70:	e8 23 63 ff ff       	call   f0105198 <enqueue>
f010ee75:	83 c4 10             	add    $0x10,%esp
}
f010ee78:	90                   	nop
f010ee79:	c9                   	leave  
f010ee7a:	c3                   	ret    

f010ee7b <sys_dequeue>:
struct Env* sys_dequeue(struct Env_Queue* queue)
{
f010ee7b:	55                   	push   %ebp
f010ee7c:	89 e5                	mov    %esp,%ebp
f010ee7e:	83 ec 08             	sub    $0x8,%esp
    return dequeue(queue);
f010ee81:	83 ec 0c             	sub    $0xc,%esp
f010ee84:	ff 75 08             	pushl  0x8(%ebp)
f010ee87:	e8 9d 63 ff ff       	call   f0105229 <dequeue>
f010ee8c:	83 c4 10             	add    $0x10,%esp
}
f010ee8f:	c9                   	leave  
f010ee90:	c3                   	ret    

f010ee91 <sys_sched_insert_ready>:
void sys_sched_insert_ready(struct Env* env){
f010ee91:	55                   	push   %ebp
f010ee92:	89 e5                	mov    %esp,%ebp
f010ee94:	83 ec 08             	sub    $0x8,%esp
	sched_insert_ready(env);
f010ee97:	83 ec 0c             	sub    $0xc,%esp
f010ee9a:	ff 75 08             	pushl  0x8(%ebp)
f010ee9d:	e8 33 66 ff ff       	call   f01054d5 <sched_insert_ready>
f010eea2:	83 c4 10             	add    $0x10,%esp
}
f010eea5:	90                   	nop
f010eea6:	c9                   	leave  
f010eea7:	c3                   	ret    

f010eea8 <sys_createSharedObject>:
/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010eea8:	55                   	push   %ebp
f010eea9:	89 e5                	mov    %esp,%ebp
f010eeab:	83 ec 18             	sub    $0x18,%esp
f010eeae:	8b 45 10             	mov    0x10(%ebp),%eax
f010eeb1:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010eeb4:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010eeb8:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010eebd:	8b 40 10             	mov    0x10(%eax),%eax
f010eec0:	83 ec 0c             	sub    $0xc,%esp
f010eec3:	ff 75 14             	pushl  0x14(%ebp)
f010eec6:	52                   	push   %edx
f010eec7:	ff 75 0c             	pushl  0xc(%ebp)
f010eeca:	ff 75 08             	pushl  0x8(%ebp)
f010eecd:	50                   	push   %eax
f010eece:	e8 dd a0 ff ff       	call   f0108fb0 <createSharedObject>
f010eed3:	83 c4 20             	add    $0x20,%esp
}
f010eed6:	c9                   	leave  
f010eed7:	c3                   	ret    

f010eed8 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010eed8:	55                   	push   %ebp
f010eed9:	89 e5                	mov    %esp,%ebp
f010eedb:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010eede:	83 ec 08             	sub    $0x8,%esp
f010eee1:	ff 75 0c             	pushl  0xc(%ebp)
f010eee4:	ff 75 08             	pushl  0x8(%ebp)
f010eee7:	e8 bf 9e ff ff       	call   f0108dab <getSizeOfSharedObject>
f010eeec:	83 c4 10             	add    $0x10,%esp
}
f010eeef:	c9                   	leave  
f010eef0:	c3                   	ret    

f010eef1 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010eef1:	55                   	push   %ebp
f010eef2:	89 e5                	mov    %esp,%ebp
f010eef4:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010eef7:	83 ec 04             	sub    $0x4,%esp
f010eefa:	ff 75 10             	pushl  0x10(%ebp)
f010eefd:	ff 75 0c             	pushl  0xc(%ebp)
f010ef00:	ff 75 08             	pushl  0x8(%ebp)
f010ef03:	e8 3b a2 ff ff       	call   f0109143 <getSharedObject>
f010ef08:	83 c4 10             	add    $0x10,%esp
}
f010ef0b:	c9                   	leave  
f010ef0c:	c3                   	ret    

f010ef0d <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010ef0d:	55                   	push   %ebp
f010ef0e:	89 e5                	mov    %esp,%ebp
f010ef10:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010ef13:	83 ec 08             	sub    $0x8,%esp
f010ef16:	ff 75 0c             	pushl  0xc(%ebp)
f010ef19:	ff 75 08             	pushl  0x8(%ebp)
f010ef1c:	e8 63 a4 ff ff       	call   f0109384 <freeSharedObject>
f010ef21:	83 c4 10             	add    $0x10,%esp
}
f010ef24:	c9                   	leave  
f010ef25:	c3                   	ret    

f010ef26 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010ef26:	55                   	push   %ebp
f010ef27:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010ef29:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ef2e:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ef31:	5d                   	pop    %ebp
f010ef32:	c3                   	ret    

f010ef33 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010ef33:	55                   	push   %ebp
f010ef34:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010ef36:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ef3b:	89 c2                	mov    %eax,%edx
f010ef3d:	a1 30 47 73 f0       	mov    0xf0734730,%eax
f010ef42:	29 c2                	sub    %eax,%edx
f010ef44:	89 d0                	mov    %edx,%eax
f010ef46:	c1 f8 02             	sar    $0x2,%eax
f010ef49:	89 c2                	mov    %eax,%edx
f010ef4b:	89 d0                	mov    %edx,%eax
f010ef4d:	c1 e0 03             	shl    $0x3,%eax
f010ef50:	01 d0                	add    %edx,%eax
f010ef52:	c1 e0 03             	shl    $0x3,%eax
f010ef55:	01 d0                	add    %edx,%eax
f010ef57:	c1 e0 02             	shl    $0x2,%eax
f010ef5a:	01 d0                	add    %edx,%eax
f010ef5c:	01 c0                	add    %eax,%eax
f010ef5e:	01 d0                	add    %edx,%eax
f010ef60:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ef67:	01 c8                	add    %ecx,%eax
f010ef69:	c1 e0 02             	shl    $0x2,%eax
f010ef6c:	01 d0                	add    %edx,%eax
f010ef6e:	c1 e0 03             	shl    $0x3,%eax
f010ef71:	01 d0                	add    %edx,%eax
f010ef73:	c1 e0 05             	shl    $0x5,%eax
f010ef76:	29 d0                	sub    %edx,%eax
f010ef78:	c1 e0 02             	shl    $0x2,%eax
f010ef7b:	01 d0                	add    %edx,%eax
f010ef7d:	01 c0                	add    %eax,%eax
f010ef7f:	01 d0                	add    %edx,%eax
f010ef81:	c1 e0 03             	shl    $0x3,%eax
f010ef84:	01 d0                	add    %edx,%eax
f010ef86:	c1 e0 04             	shl    $0x4,%eax
f010ef89:	29 d0                	sub    %edx,%eax
}
f010ef8b:	5d                   	pop    %ebp
f010ef8c:	c3                   	ret    

f010ef8d <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ef8d:	55                   	push   %ebp
f010ef8e:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010ef90:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010ef95:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ef98:	5d                   	pop    %ebp
f010ef99:	c3                   	ret    

f010ef9a <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ef9a:	55                   	push   %ebp
f010ef9b:	89 e5                	mov    %esp,%ebp
f010ef9d:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010efa0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010efa4:	75 0a                	jne    f010efb0 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010efa6:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010efab:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010efae:	eb 22                	jmp    f010efd2 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010efb0:	83 ec 04             	sub    $0x4,%esp
f010efb3:	6a 00                	push   $0x0
f010efb5:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010efb8:	50                   	push   %eax
f010efb9:	ff 75 08             	pushl  0x8(%ebp)
f010efbc:	e8 b4 cd ff ff       	call   f010bd75 <envid2env>
f010efc1:	83 c4 10             	add    $0x10,%esp
f010efc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010efc7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010efcb:	79 05                	jns    f010efd2 <sys_destroy_env+0x38>
	{
		return r;
f010efcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010efd0:	eb 5e                	jmp    f010f030 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010efd2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010efd5:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010efda:	39 c2                	cmp    %eax,%edx
f010efdc:	75 1b                	jne    f010eff9 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010efde:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010efe3:	8b 40 10             	mov    0x10(%eax),%eax
f010efe6:	83 ec 08             	sub    $0x8,%esp
f010efe9:	50                   	push   %eax
f010efea:	68 73 7e 12 f0       	push   $0xf0127e73
f010efef:	e8 97 1f ff ff       	call   f0100f8b <cprintf>
f010eff4:	83 c4 10             	add    $0x10,%esp
f010eff7:	eb 20                	jmp    f010f019 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010eff9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010effc:	8b 50 10             	mov    0x10(%eax),%edx
f010efff:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010f004:	8b 40 10             	mov    0x10(%eax),%eax
f010f007:	83 ec 04             	sub    $0x4,%esp
f010f00a:	52                   	push   %edx
f010f00b:	50                   	push   %eax
f010f00c:	68 8e 7e 12 f0       	push   $0xf0127e8e
f010f011:	e8 75 1f ff ff       	call   f0100f8b <cprintf>
f010f016:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010f019:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f01c:	8b 40 10             	mov    0x10(%eax),%eax
f010f01f:	83 ec 0c             	sub    $0xc,%esp
f010f022:	50                   	push   %eax
f010f023:	e8 fb 6c ff ff       	call   f0105d23 <sched_kill_env>
f010f028:	83 c4 10             	add    $0x10,%esp

	return 0;
f010f02b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f030:	c9                   	leave  
f010f031:	c3                   	ret    

f010f032 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010f032:	55                   	push   %ebp
f010f033:	89 e5                	mov    %esp,%ebp
f010f035:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010f038:	e8 a6 cc ff ff       	call   f010bce3 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010f03d:	90                   	nop
f010f03e:	c9                   	leave  
f010f03f:	c3                   	ret    

f010f040 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010f040:	55                   	push   %ebp
f010f041:	89 e5                	mov    %esp,%ebp
f010f043:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010f046:	ff 75 14             	pushl  0x14(%ebp)
f010f049:	ff 75 10             	pushl  0x10(%ebp)
f010f04c:	ff 75 0c             	pushl  0xc(%ebp)
f010f04f:	ff 75 08             	pushl  0x8(%ebp)
f010f052:	e8 50 c2 ff ff       	call   f010b2a7 <env_create>
f010f057:	83 c4 10             	add    $0x10,%esp
f010f05a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010f05d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f061:	75 07                	jne    f010f06a <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010f063:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010f068:	eb 14                	jmp    f010f07e <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010f06a:	83 ec 0c             	sub    $0xc,%esp
f010f06d:	ff 75 f4             	pushl  -0xc(%ebp)
f010f070:	e8 12 69 ff ff       	call   f0105987 <sched_new_env>
f010f075:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010f078:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f07b:	8b 40 10             	mov    0x10(%eax),%eax
}
f010f07e:	c9                   	leave  
f010f07f:	c3                   	ret    

f010f080 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010f080:	55                   	push   %ebp
f010f081:	89 e5                	mov    %esp,%ebp
f010f083:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010f086:	8b 45 08             	mov    0x8(%ebp),%eax
f010f089:	83 ec 0c             	sub    $0xc,%esp
f010f08c:	50                   	push   %eax
f010f08d:	e8 4b 69 ff ff       	call   f01059dd <sched_run_env>
f010f092:	83 c4 10             	add    $0x10,%esp
}
f010f095:	90                   	nop
f010f096:	c9                   	leave  
f010f097:	c3                   	ret    

f010f098 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010f098:	55                   	push   %ebp
f010f099:	89 e5                	mov    %esp,%ebp
f010f09b:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010f09e:	0f 31                	rdtsc  
f010f0a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010f0a3:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010f0a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f0a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f0ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f0af:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010f0b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010f0b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f0b8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f0bb:	89 01                	mov    %eax,(%ecx)
f010f0bd:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010f0c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f0c3:	c9                   	leave  
f010f0c4:	c2 04 00             	ret    $0x4

f010f0c7 <sys_rcr2>:

uint32 sys_rcr2()
{
f010f0c7:	55                   	push   %ebp
f010f0c8:	89 e5                	mov    %esp,%ebp
f010f0ca:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f0cd:	0f 20 d0             	mov    %cr2,%eax
f010f0d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010f0d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010f0d6:	90                   	nop
}
f010f0d7:	c9                   	leave  
f010f0d8:	c3                   	ret    

f010f0d9 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010f0d9:	55                   	push   %ebp
f010f0da:	89 e5                	mov    %esp,%ebp
f010f0dc:	83 ec 04             	sub    $0x4,%esp
f010f0df:	8b 45 08             	mov    0x8(%ebp),%eax
f010f0e2:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010f0e5:	8a 45 fc             	mov    -0x4(%ebp),%al
f010f0e8:	a2 a0 4f 73 f0       	mov    %al,0xf0734fa0
}
f010f0ed:	90                   	nop
f010f0ee:	c9                   	leave  
f010f0ef:	c3                   	ret    

f010f0f0 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010f0f0:	55                   	push   %ebp
f010f0f1:	89 e5                	mov    %esp,%ebp
f010f0f3:	56                   	push   %esi
f010f0f4:	53                   	push   %ebx
f010f0f5:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010f0f8:	e8 28 cc ff ff       	call   f010bd25 <get_cpu_proc>
f010f0fd:	a3 80 bf 6e f2       	mov    %eax,0xf26ebf80
	assert(cur_env != NULL);
f010f102:	a1 80 bf 6e f2       	mov    0xf26ebf80,%eax
f010f107:	85 c0                	test   %eax,%eax
f010f109:	75 19                	jne    f010f124 <syscall+0x34>
f010f10b:	68 a6 7e 12 f0       	push   $0xf0127ea6
f010f110:	68 b6 7e 12 f0       	push   $0xf0127eb6
f010f115:	68 14 02 00 00       	push   $0x214
f010f11a:	68 3f 7e 12 f0       	push   $0xf0127e3f
f010f11f:	e8 15 12 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010f124:	83 7d 08 33          	cmpl   $0x33,0x8(%ebp)
f010f128:	0f 87 70 04 00 00    	ja     f010f59e <syscall+0x4ae>
f010f12e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f131:	c1 e0 02             	shl    $0x2,%eax
f010f134:	05 cc 7e 12 f0       	add    $0xf0127ecc,%eax
f010f139:	8b 00                	mov    (%eax),%eax
f010f13b:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010f13d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f140:	83 ec 0c             	sub    $0xc,%esp
f010f143:	50                   	push   %eax
f010f144:	e8 7d bd ff ff       	call   f010aec6 <sys_sbrk>
f010f149:	83 c4 10             	add    $0x10,%esp
f010f14c:	e9 52 04 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010f151:	83 ec 08             	sub    $0x8,%esp
f010f154:	ff 75 10             	pushl  0x10(%ebp)
f010f157:	ff 75 0c             	pushl  0xc(%ebp)
f010f15a:	e8 cd fb ff ff       	call   f010ed2c <sys_free_user_mem>
f010f15f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f162:	b8 00 00 00 00       	mov    $0x0,%eax
f010f167:	e9 37 04 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010f16c:	83 ec 08             	sub    $0x8,%esp
f010f16f:	ff 75 10             	pushl  0x10(%ebp)
f010f172:	ff 75 0c             	pushl  0xc(%ebp)
f010f175:	e8 2f fc ff ff       	call   f010eda9 <sys_allocate_user_mem>
f010f17a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f17d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f182:	e9 1c 04 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010f187:	8b 45 14             	mov    0x14(%ebp),%eax
f010f18a:	0f b6 d0             	movzbl %al,%edx
f010f18d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f190:	83 ec 04             	sub    $0x4,%esp
f010f193:	52                   	push   %edx
f010f194:	ff 75 10             	pushl  0x10(%ebp)
f010f197:	50                   	push   %eax
f010f198:	e8 5f f8 ff ff       	call   f010e9fc <sys_cputs>
f010f19d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1a0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1a5:	e9 f9 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010f1aa:	e8 c9 f8 ff ff       	call   f010ea78 <sys_cgetc>
f010f1af:	e9 ef 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010f1b4:	e8 fe f8 ff ff       	call   f010eab7 <sys_lock_cons>
		return 0;
f010f1b9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1be:	e9 e0 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010f1c3:	e8 fd f8 ff ff       	call   f010eac5 <sys_unlock_cons>
		return 0;
f010f1c8:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1cd:	e9 d1 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010f1d2:	83 ec 08             	sub    $0x8,%esp
f010f1d5:	ff 75 10             	pushl  0x10(%ebp)
f010f1d8:	ff 75 0c             	pushl  0xc(%ebp)
f010f1db:	e8 46 fa ff ff       	call   f010ec26 <sys_calculate_required_frames>
f010f1e0:	83 c4 10             	add    $0x10,%esp
f010f1e3:	e9 bb 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010f1e8:	e8 5b fa ff ff       	call   f010ec48 <sys_calculate_free_frames>
f010f1ed:	e9 b1 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010f1f2:	e8 70 fa ff ff       	call   f010ec67 <sys_calculate_modified_frames>
f010f1f7:	e9 a7 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010f1fc:	e8 80 fa ff ff       	call   f010ec81 <sys_calculate_notmod_frames>
f010f201:	e9 9d 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010f206:	e8 08 fb ff ff       	call   f010ed13 <sys_pf_calculate_allocated_pages>
f010f20b:	e9 93 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010f210:	83 ec 0c             	sub    $0xc,%esp
f010f213:	ff 75 0c             	pushl  0xc(%ebp)
f010f216:	e8 80 fa ff ff       	call   f010ec9b <sys_calculate_pages_tobe_removed_ready_exit>
f010f21b:	83 c4 10             	add    $0x10,%esp
f010f21e:	e9 80 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010f223:	e8 89 fa ff ff       	call   f010ecb1 <sys_scarce_memory>
		return 0;
f010f228:	b8 00 00 00 00       	mov    $0x0,%eax
f010f22d:	e9 71 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010f232:	83 ec 04             	sub    $0x4,%esp
f010f235:	ff 75 14             	pushl  0x14(%ebp)
f010f238:	ff 75 10             	pushl  0x10(%ebp)
f010f23b:	ff 75 0c             	pushl  0xc(%ebp)
f010f23e:	e8 94 fb ff ff       	call   f010edd7 <sys_allocate_chunk>
f010f243:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f246:	b8 00 00 00 00       	mov    $0x0,%eax
f010f24b:	e9 53 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010f250:	8b 55 10             	mov    0x10(%ebp),%edx
f010f253:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f256:	83 ec 08             	sub    $0x8,%esp
f010f259:	52                   	push   %edx
f010f25a:	50                   	push   %eax
f010f25b:	e8 73 f8 ff ff       	call   f010ead3 <__sys_allocate_page>
f010f260:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f263:	b8 00 00 00 00       	mov    $0x0,%eax
f010f268:	e9 36 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010f26d:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010f270:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f273:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f276:	8b 55 10             	mov    0x10(%ebp),%edx
f010f279:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f27c:	83 ec 0c             	sub    $0xc,%esp
f010f27f:	56                   	push   %esi
f010f280:	53                   	push   %ebx
f010f281:	51                   	push   %ecx
f010f282:	52                   	push   %edx
f010f283:	50                   	push   %eax
f010f284:	e8 63 f9 ff ff       	call   f010ebec <__sys_map_frame>
f010f289:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f28c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f291:	e9 0d 03 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010f296:	8b 55 10             	mov    0x10(%ebp),%edx
f010f299:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f29c:	83 ec 08             	sub    $0x8,%esp
f010f29f:	52                   	push   %edx
f010f2a0:	50                   	push   %eax
f010f2a1:	e8 63 f9 ff ff       	call   f010ec09 <__sys_unmap_frame>
f010f2a6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2a9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2ae:	e9 f0 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010f2b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2b6:	0f be c0             	movsbl %al,%eax
f010f2b9:	83 ec 0c             	sub    $0xc,%esp
f010f2bc:	50                   	push   %eax
f010f2bd:	e8 92 f7 ff ff       	call   f010ea54 <sys_cputc>
f010f2c2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2c5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2ca:	e9 d4 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010f2cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2d2:	0f be c0             	movsbl %al,%eax
f010f2d5:	83 ec 0c             	sub    $0xc,%esp
f010f2d8:	50                   	push   %eax
f010f2d9:	e8 e1 f9 ff ff       	call   f010ecbf <sys_clearFFL>
f010f2de:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2e1:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2e6:	e9 b8 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010f2eb:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f2ee:	8b 45 14             	mov    0x14(%ebp),%eax
f010f2f1:	0f b6 d0             	movzbl %al,%edx
f010f2f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2f7:	51                   	push   %ecx
f010f2f8:	52                   	push   %edx
f010f2f9:	ff 75 10             	pushl  0x10(%ebp)
f010f2fc:	50                   	push   %eax
f010f2fd:	e8 a6 fb ff ff       	call   f010eea8 <sys_createSharedObject>
f010f302:	83 c4 10             	add    $0x10,%esp
f010f305:	e9 99 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010f30a:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f30d:	8b 55 10             	mov    0x10(%ebp),%edx
f010f310:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f313:	83 ec 04             	sub    $0x4,%esp
f010f316:	51                   	push   %ecx
f010f317:	52                   	push   %edx
f010f318:	50                   	push   %eax
f010f319:	e8 d3 fb ff ff       	call   f010eef1 <sys_getSharedObject>
f010f31e:	83 c4 10             	add    $0x10,%esp
f010f321:	e9 7d 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010f326:	8b 55 10             	mov    0x10(%ebp),%edx
f010f329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f32c:	83 ec 08             	sub    $0x8,%esp
f010f32f:	52                   	push   %edx
f010f330:	50                   	push   %eax
f010f331:	e8 d7 fb ff ff       	call   f010ef0d <sys_freeSharedObject>
f010f336:	83 c4 10             	add    $0x10,%esp
f010f339:	e9 65 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010f33e:	8b 55 10             	mov    0x10(%ebp),%edx
f010f341:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f344:	83 ec 08             	sub    $0x8,%esp
f010f347:	52                   	push   %edx
f010f348:	50                   	push   %eax
f010f349:	e8 8a fb ff ff       	call   f010eed8 <sys_getSizeOfSharedObject>
f010f34e:	83 c4 10             	add    $0x10,%esp
f010f351:	e9 4d 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f356:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f359:	ff 75 18             	pushl  0x18(%ebp)
f010f35c:	ff 75 14             	pushl  0x14(%ebp)
f010f35f:	ff 75 10             	pushl  0x10(%ebp)
f010f362:	50                   	push   %eax
f010f363:	e8 d8 fc ff ff       	call   f010f040 <sys_create_env>
f010f368:	83 c4 10             	add    $0x10,%esp
f010f36b:	e9 33 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f370:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f373:	83 ec 0c             	sub    $0xc,%esp
f010f376:	50                   	push   %eax
f010f377:	e8 04 fd ff ff       	call   f010f080 <sys_run_env>
f010f37c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f37f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f384:	e9 1a 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f389:	e8 a5 fb ff ff       	call   f010ef33 <sys_getenvindex>
f010f38e:	e9 10 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f393:	e8 8e fb ff ff       	call   f010ef26 <sys_getenvid>
f010f398:	e9 06 02 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f39d:	e8 eb fb ff ff       	call   f010ef8d <sys_getparentenvid>
f010f3a2:	e9 fc 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f3a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3aa:	83 ec 0c             	sub    $0xc,%esp
f010f3ad:	50                   	push   %eax
f010f3ae:	e8 e7 fb ff ff       	call   f010ef9a <sys_destroy_env>
f010f3b3:	83 c4 10             	add    $0x10,%esp
f010f3b6:	e9 e8 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f3bb:	e8 72 fc ff ff       	call   f010f032 <sys_exit_env>
		return 0;
f010f3c0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3c5:	e9 d9 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f3ca:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010f3cd:	83 ec 0c             	sub    $0xc,%esp
f010f3d0:	50                   	push   %eax
f010f3d1:	e8 c2 fc ff ff       	call   f010f098 <sys_get_virtual_time>
f010f3d6:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f3d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f3df:	8b 45 10             	mov    0x10(%ebp),%eax
f010f3e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010f3e5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f3e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f3eb:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f3ed:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f3f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f3f3:	89 10                	mov    %edx,(%eax)
		return 0;
f010f3f5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3fa:	e9 a4 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f3ff:	83 ec 04             	sub    $0x4,%esp
f010f402:	ff 75 14             	pushl  0x14(%ebp)
f010f405:	ff 75 10             	pushl  0x10(%ebp)
f010f408:	ff 75 0c             	pushl  0xc(%ebp)
f010f40b:	e8 f8 f9 ff ff       	call   f010ee08 <sys_move_user_mem>
f010f410:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f413:	b8 00 00 00 00       	mov    $0x0,%eax
f010f418:	e9 86 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f41d:	e8 a5 fc ff ff       	call   f010f0c7 <sys_rcr2>
f010f422:	e9 7c 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f427:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f42a:	0f b6 c0             	movzbl %al,%eax
f010f42d:	83 ec 0c             	sub    $0xc,%esp
f010f430:	50                   	push   %eax
f010f431:	e8 a3 fc ff ff       	call   f010f0d9 <sys_bypassPageFault>
f010f436:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f439:	b8 00 00 00 00       	mov    $0x0,%eax
f010f43e:	e9 60 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>

	case SYS_rsttst:
		rsttst();
f010f443:	e8 4a ef 00 00       	call   f011e392 <rsttst>
		return 0;
f010f448:	b8 00 00 00 00       	mov    $0x0,%eax
f010f44d:	e9 51 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
	case SYS_inctst:
		inctst();
f010f452:	e8 83 ef 00 00       	call   f011e3da <inctst>
		return 0;
f010f457:	b8 00 00 00 00       	mov    $0x0,%eax
f010f45c:	e9 42 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
	case SYS_chktst:
		chktst(a1);
f010f461:	83 ec 0c             	sub    $0xc,%esp
f010f464:	ff 75 0c             	pushl  0xc(%ebp)
f010f467:	e8 b0 f0 00 00       	call   f011e51c <chktst>
f010f46c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f46f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f474:	e9 2a 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
	case SYS_gettst:
		return gettst();
f010f479:	e8 90 ef 00 00       	call   f011e40e <gettst>
f010f47e:	e9 20 01 00 00       	jmp    f010f5a3 <syscall+0x4b3>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f483:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f486:	8b 45 18             	mov    0x18(%ebp),%eax
f010f489:	0f be c0             	movsbl %al,%eax
f010f48c:	83 ec 0c             	sub    $0xc,%esp
f010f48f:	52                   	push   %edx
f010f490:	50                   	push   %eax
f010f491:	ff 75 14             	pushl  0x14(%ebp)
f010f494:	ff 75 10             	pushl  0x10(%ebp)
f010f497:	ff 75 0c             	pushl  0xc(%ebp)
f010f49a:	e8 79 ef 00 00       	call   f011e418 <tst>
f010f49f:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f4a2:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4a7:	e9 f7 00 00 00       	jmp    f010f5a3 <syscall+0x4b3>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f4ac:	e8 77 f9 ff ff       	call   f010ee28 <sys_get_heap_strategy>
f010f4b1:	e9 ed 00 00 00       	jmp    f010f5a3 <syscall+0x4b3>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f4b6:	83 ec 0c             	sub    $0xc,%esp
f010f4b9:	ff 75 0c             	pushl  0xc(%ebp)
f010f4bc:	e8 71 f9 ff ff       	call   f010ee32 <sys_set_uheap_strategy>
f010f4c1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f4c4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4c9:	e9 d5 00 00 00       	jmp    f010f5a3 <syscall+0x4b3>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f4ce:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f4d1:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f4d4:	8b 55 10             	mov    0x10(%ebp),%edx
f010f4d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4da:	53                   	push   %ebx
f010f4db:	51                   	push   %ecx
f010f4dc:	52                   	push   %edx
f010f4dd:	50                   	push   %eax
f010f4de:	e8 02 1e 00 00       	call   f01112e5 <sys_check_LRU_lists>
f010f4e3:	83 c4 10             	add    $0x10,%esp
f010f4e6:	e9 b8 00 00 00       	jmp    f010f5a3 <syscall+0x4b3>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f4eb:	8b 55 10             	mov    0x10(%ebp),%edx
f010f4ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4f1:	83 ec 08             	sub    $0x8,%esp
f010f4f4:	52                   	push   %edx
f010f4f5:	50                   	push   %eax
f010f4f6:	e8 ac 1f 00 00       	call   f01114a7 <sys_check_LRU_lists_free>
f010f4fb:	83 c4 10             	add    $0x10,%esp
f010f4fe:	e9 a0 00 00 00       	jmp    f010f5a3 <syscall+0x4b3>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f503:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f506:	8b 55 10             	mov    0x10(%ebp),%edx
f010f509:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f50c:	51                   	push   %ecx
f010f50d:	ff 75 14             	pushl  0x14(%ebp)
f010f510:	52                   	push   %edx
f010f511:	50                   	push   %eax
f010f512:	e8 1d 21 00 00       	call   f0111634 <sys_check_WS_list>
f010f517:	83 c4 10             	add    $0x10,%esp
f010f51a:	e9 84 00 00 00       	jmp    f010f5a3 <syscall+0x4b3>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f51f:	8b 55 10             	mov    0x10(%ebp),%edx
f010f522:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f525:	83 ec 08             	sub    $0x8,%esp
f010f528:	52                   	push   %edx
f010f529:	50                   	push   %eax
f010f52a:	e8 ee f1 00 00       	call   f011e71d <sys_utilities>
f010f52f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f532:	b8 00 00 00 00       	mov    $0x0,%eax
f010f537:	eb 6a                	jmp    f010f5a3 <syscall+0x4b3>
	case SYS_get_cpu_process:
		return (uint32)sys_get_cpu_process();
f010f539:	e8 02 f9 ff ff       	call   f010ee40 <sys_get_cpu_process>
f010f53e:	eb 63                	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_init_queue:
		 sys_init_queue((struct Env_Queue*)a1);
f010f540:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f543:	83 ec 0c             	sub    $0xc,%esp
f010f546:	50                   	push   %eax
f010f547:	e8 fe f8 ff ff       	call   f010ee4a <sys_init_queue>
f010f54c:	83 c4 10             	add    $0x10,%esp
		 return 0;
f010f54f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f554:	eb 4d                	jmp    f010f5a3 <syscall+0x4b3>
		 break;
	case SYS_enqueue:
		 sys_enqueue((struct Env_Queue*) a1, (struct Env*) a2);
f010f556:	8b 55 10             	mov    0x10(%ebp),%edx
f010f559:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f55c:	83 ec 08             	sub    $0x8,%esp
f010f55f:	52                   	push   %edx
f010f560:	50                   	push   %eax
f010f561:	e8 fb f8 ff ff       	call   f010ee61 <sys_enqueue>
f010f566:	83 c4 10             	add    $0x10,%esp
		 return 0;
f010f569:	b8 00 00 00 00       	mov    $0x0,%eax
f010f56e:	eb 33                	jmp    f010f5a3 <syscall+0x4b3>
		 break;
	case SYS_sched_insert_ready:
		sys_sched_insert_ready((struct Env*) a1);
f010f570:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f573:	83 ec 0c             	sub    $0xc,%esp
f010f576:	50                   	push   %eax
f010f577:	e8 15 f9 ff ff       	call   f010ee91 <sys_sched_insert_ready>
f010f57c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f57f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f584:	eb 1d                	jmp    f010f5a3 <syscall+0x4b3>
		break;
	case SYS_dequeue:
			return (uint32) sys_dequeue((struct Env_Queue*) a1);
f010f586:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f589:	83 ec 0c             	sub    $0xc,%esp
f010f58c:	50                   	push   %eax
f010f58d:	e8 e9 f8 ff ff       	call   f010ee7b <sys_dequeue>
f010f592:	83 c4 10             	add    $0x10,%esp
f010f595:	eb 0c                	jmp    f010f5a3 <syscall+0x4b3>
			break;
	case NSYSCALLS:
		return 	-E_INVAL;
f010f597:	b8 03 00 00 00       	mov    $0x3,%eax
f010f59c:	eb 05                	jmp    f010f5a3 <syscall+0x4b3>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f59e:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f5a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f5a6:	5b                   	pop    %ebx
f010f5a7:	5e                   	pop    %esi
f010f5a8:	5d                   	pop    %ebp
f010f5a9:	c3                   	ret    

f010f5aa <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f5aa:	55                   	push   %ebp
f010f5ab:	89 e5                	mov    %esp,%ebp
f010f5ad:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f5b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5b3:	8b 00                	mov    (%eax),%eax
f010f5b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f5b8:	8b 45 10             	mov    0x10(%ebp),%eax
f010f5bb:	8b 00                	mov    (%eax),%eax
f010f5bd:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f5c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f5c7:	e9 ca 00 00 00       	jmp    f010f696 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f5cc:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f5cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f5d2:	01 d0                	add    %edx,%eax
f010f5d4:	89 c2                	mov    %eax,%edx
f010f5d6:	c1 ea 1f             	shr    $0x1f,%edx
f010f5d9:	01 d0                	add    %edx,%eax
f010f5db:	d1 f8                	sar    %eax
f010f5dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f5e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f5e3:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f5e6:	eb 03                	jmp    f010f5eb <stab_binsearch+0x41>
			m--;
f010f5e8:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f5eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f5ee:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f5f1:	7c 1e                	jl     f010f611 <stab_binsearch+0x67>
f010f5f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f5f6:	89 d0                	mov    %edx,%eax
f010f5f8:	01 c0                	add    %eax,%eax
f010f5fa:	01 d0                	add    %edx,%eax
f010f5fc:	c1 e0 02             	shl    $0x2,%eax
f010f5ff:	89 c2                	mov    %eax,%edx
f010f601:	8b 45 08             	mov    0x8(%ebp),%eax
f010f604:	01 d0                	add    %edx,%eax
f010f606:	8a 40 04             	mov    0x4(%eax),%al
f010f609:	0f b6 c0             	movzbl %al,%eax
f010f60c:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f60f:	75 d7                	jne    f010f5e8 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f611:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f614:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f617:	7d 09                	jge    f010f622 <stab_binsearch+0x78>
			l = true_m + 1;
f010f619:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f61c:	40                   	inc    %eax
f010f61d:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f620:	eb 74                	jmp    f010f696 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f622:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f629:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f62c:	89 d0                	mov    %edx,%eax
f010f62e:	01 c0                	add    %eax,%eax
f010f630:	01 d0                	add    %edx,%eax
f010f632:	c1 e0 02             	shl    $0x2,%eax
f010f635:	89 c2                	mov    %eax,%edx
f010f637:	8b 45 08             	mov    0x8(%ebp),%eax
f010f63a:	01 d0                	add    %edx,%eax
f010f63c:	8b 40 08             	mov    0x8(%eax),%eax
f010f63f:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f642:	73 11                	jae    f010f655 <stab_binsearch+0xab>
			*region_left = m;
f010f644:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f647:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f64a:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f64c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f64f:	40                   	inc    %eax
f010f650:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f653:	eb 41                	jmp    f010f696 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f655:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f658:	89 d0                	mov    %edx,%eax
f010f65a:	01 c0                	add    %eax,%eax
f010f65c:	01 d0                	add    %edx,%eax
f010f65e:	c1 e0 02             	shl    $0x2,%eax
f010f661:	89 c2                	mov    %eax,%edx
f010f663:	8b 45 08             	mov    0x8(%ebp),%eax
f010f666:	01 d0                	add    %edx,%eax
f010f668:	8b 40 08             	mov    0x8(%eax),%eax
f010f66b:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f66e:	76 14                	jbe    f010f684 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f670:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f673:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f676:	8b 45 10             	mov    0x10(%ebp),%eax
f010f679:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f67b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f67e:	48                   	dec    %eax
f010f67f:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f682:	eb 12                	jmp    f010f696 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f684:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f687:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f68a:	89 10                	mov    %edx,(%eax)
			l = m;
f010f68c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f68f:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f692:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f696:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f699:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f69c:	0f 8e 2a ff ff ff    	jle    f010f5cc <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f6a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f6a6:	75 0f                	jne    f010f6b7 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f6a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6ab:	8b 00                	mov    (%eax),%eax
f010f6ad:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f6b0:	8b 45 10             	mov    0x10(%ebp),%eax
f010f6b3:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f6b5:	eb 3d                	jmp    f010f6f4 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f6b7:	8b 45 10             	mov    0x10(%ebp),%eax
f010f6ba:	8b 00                	mov    (%eax),%eax
f010f6bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f6bf:	eb 03                	jmp    f010f6c4 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f6c1:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f6c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6c7:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f6c9:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f6cc:	7d 1e                	jge    f010f6ec <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f6ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f6d1:	89 d0                	mov    %edx,%eax
f010f6d3:	01 c0                	add    %eax,%eax
f010f6d5:	01 d0                	add    %edx,%eax
f010f6d7:	c1 e0 02             	shl    $0x2,%eax
f010f6da:	89 c2                	mov    %eax,%edx
f010f6dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6df:	01 d0                	add    %edx,%eax
f010f6e1:	8a 40 04             	mov    0x4(%eax),%al
f010f6e4:	0f b6 c0             	movzbl %al,%eax
f010f6e7:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f6ea:	75 d5                	jne    f010f6c1 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f6ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6ef:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f6f2:	89 10                	mov    %edx,(%eax)
	}
}
f010f6f4:	90                   	nop
f010f6f5:	c9                   	leave  
f010f6f6:	c3                   	ret    

f010f6f7 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f6f7:	55                   	push   %ebp
f010f6f8:	89 e5                	mov    %esp,%ebp
f010f6fa:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f6fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f700:	c7 00 9c 7f 12 f0    	movl   $0xf0127f9c,(%eax)
	info->eip_line = 0;
f010f706:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f709:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f710:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f713:	c7 40 08 9c 7f 12 f0 	movl   $0xf0127f9c,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f71a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f71d:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f724:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f727:	8b 55 08             	mov    0x8(%ebp),%edx
f010f72a:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f72d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f730:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f737:	8b 45 08             	mov    0x8(%ebp),%eax
f010f73a:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f73f:	76 1e                	jbe    f010f75f <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f741:	c7 45 f4 c4 1c 13 f0 	movl   $0xf0131cc4,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f748:	c7 45 f0 6c 5c 16 f0 	movl   $0xf0165c6c,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f74f:	c7 45 ec 6d 5c 16 f0 	movl   $0xf0165c6d,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f756:	c7 45 e8 d2 7b 17 f0 	movl   $0xf0177bd2,-0x18(%ebp)
f010f75d:	eb 2a                	jmp    f010f789 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f75f:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f766:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f769:	8b 00                	mov    (%eax),%eax
f010f76b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f76e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f771:	8b 40 04             	mov    0x4(%eax),%eax
f010f774:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f777:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f77a:	8b 40 08             	mov    0x8(%eax),%eax
f010f77d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f780:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f783:	8b 40 0c             	mov    0xc(%eax),%eax
f010f786:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f789:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f78c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f78f:	76 0a                	jbe    f010f79b <debuginfo_eip+0xa4>
f010f791:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f794:	48                   	dec    %eax
f010f795:	8a 00                	mov    (%eax),%al
f010f797:	84 c0                	test   %al,%al
f010f799:	74 0a                	je     f010f7a5 <debuginfo_eip+0xae>
		return -1;
f010f79b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f7a0:	e9 01 02 00 00       	jmp    f010f9a6 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f7a5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f7ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f7af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7b2:	29 c2                	sub    %eax,%edx
f010f7b4:	89 d0                	mov    %edx,%eax
f010f7b6:	c1 f8 02             	sar    $0x2,%eax
f010f7b9:	89 c2                	mov    %eax,%edx
f010f7bb:	89 d0                	mov    %edx,%eax
f010f7bd:	c1 e0 02             	shl    $0x2,%eax
f010f7c0:	01 d0                	add    %edx,%eax
f010f7c2:	c1 e0 02             	shl    $0x2,%eax
f010f7c5:	01 d0                	add    %edx,%eax
f010f7c7:	c1 e0 02             	shl    $0x2,%eax
f010f7ca:	01 d0                	add    %edx,%eax
f010f7cc:	89 c1                	mov    %eax,%ecx
f010f7ce:	c1 e1 08             	shl    $0x8,%ecx
f010f7d1:	01 c8                	add    %ecx,%eax
f010f7d3:	89 c1                	mov    %eax,%ecx
f010f7d5:	c1 e1 10             	shl    $0x10,%ecx
f010f7d8:	01 c8                	add    %ecx,%eax
f010f7da:	01 c0                	add    %eax,%eax
f010f7dc:	01 d0                	add    %edx,%eax
f010f7de:	48                   	dec    %eax
f010f7df:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f7e2:	ff 75 08             	pushl  0x8(%ebp)
f010f7e5:	6a 64                	push   $0x64
f010f7e7:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f7ea:	50                   	push   %eax
f010f7eb:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f7ee:	50                   	push   %eax
f010f7ef:	ff 75 f4             	pushl  -0xc(%ebp)
f010f7f2:	e8 b3 fd ff ff       	call   f010f5aa <stab_binsearch>
f010f7f7:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f7fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f7fd:	85 c0                	test   %eax,%eax
f010f7ff:	75 0a                	jne    f010f80b <debuginfo_eip+0x114>
		return -1;
f010f801:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f806:	e9 9b 01 00 00       	jmp    f010f9a6 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f80b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f80e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f811:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f814:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f817:	ff 75 08             	pushl  0x8(%ebp)
f010f81a:	6a 24                	push   $0x24
f010f81c:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f81f:	50                   	push   %eax
f010f820:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f823:	50                   	push   %eax
f010f824:	ff 75 f4             	pushl  -0xc(%ebp)
f010f827:	e8 7e fd ff ff       	call   f010f5aa <stab_binsearch>
f010f82c:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f82f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f832:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f835:	39 c2                	cmp    %eax,%edx
f010f837:	0f 8f 86 00 00 00    	jg     f010f8c3 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f83d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f840:	89 c2                	mov    %eax,%edx
f010f842:	89 d0                	mov    %edx,%eax
f010f844:	01 c0                	add    %eax,%eax
f010f846:	01 d0                	add    %edx,%eax
f010f848:	c1 e0 02             	shl    $0x2,%eax
f010f84b:	89 c2                	mov    %eax,%edx
f010f84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f850:	01 d0                	add    %edx,%eax
f010f852:	8b 00                	mov    (%eax),%eax
f010f854:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f857:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f85a:	29 d1                	sub    %edx,%ecx
f010f85c:	89 ca                	mov    %ecx,%edx
f010f85e:	39 d0                	cmp    %edx,%eax
f010f860:	73 22                	jae    f010f884 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f862:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f865:	89 c2                	mov    %eax,%edx
f010f867:	89 d0                	mov    %edx,%eax
f010f869:	01 c0                	add    %eax,%eax
f010f86b:	01 d0                	add    %edx,%eax
f010f86d:	c1 e0 02             	shl    $0x2,%eax
f010f870:	89 c2                	mov    %eax,%edx
f010f872:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f875:	01 d0                	add    %edx,%eax
f010f877:	8b 10                	mov    (%eax),%edx
f010f879:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f87c:	01 c2                	add    %eax,%edx
f010f87e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f881:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f884:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f887:	89 c2                	mov    %eax,%edx
f010f889:	89 d0                	mov    %edx,%eax
f010f88b:	01 c0                	add    %eax,%eax
f010f88d:	01 d0                	add    %edx,%eax
f010f88f:	c1 e0 02             	shl    $0x2,%eax
f010f892:	89 c2                	mov    %eax,%edx
f010f894:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f897:	01 d0                	add    %edx,%eax
f010f899:	8b 50 08             	mov    0x8(%eax),%edx
f010f89c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f89f:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f8a2:	8b 55 08             	mov    0x8(%ebp),%edx
f010f8a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8a8:	8b 40 10             	mov    0x10(%eax),%eax
f010f8ab:	29 c2                	sub    %eax,%edx
f010f8ad:	89 d0                	mov    %edx,%eax
f010f8af:	c1 f8 02             	sar    $0x2,%eax
f010f8b2:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f8b5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f8b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f8bb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f8be:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f8c1:	eb 15                	jmp    f010f8d8 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f8c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8c6:	8b 55 08             	mov    0x8(%ebp),%edx
f010f8c9:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f8cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f8cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f8d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f8d5:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f8d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8db:	8b 40 08             	mov    0x8(%eax),%eax
f010f8de:	83 ec 08             	sub    $0x8,%esp
f010f8e1:	6a 3a                	push   $0x3a
f010f8e3:	50                   	push   %eax
f010f8e4:	e8 f5 08 01 00       	call   f01201de <strfind>
f010f8e9:	83 c4 10             	add    $0x10,%esp
f010f8ec:	89 c2                	mov    %eax,%edx
f010f8ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8f1:	8b 40 08             	mov    0x8(%eax),%eax
f010f8f4:	29 c2                	sub    %eax,%edx
f010f8f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8f9:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f8fc:	eb 03                	jmp    f010f901 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f8fe:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f901:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f904:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f907:	7c 4e                	jl     f010f957 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f909:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f90c:	89 d0                	mov    %edx,%eax
f010f90e:	01 c0                	add    %eax,%eax
f010f910:	01 d0                	add    %edx,%eax
f010f912:	c1 e0 02             	shl    $0x2,%eax
f010f915:	89 c2                	mov    %eax,%edx
f010f917:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f91a:	01 d0                	add    %edx,%eax
f010f91c:	8a 40 04             	mov    0x4(%eax),%al
f010f91f:	3c 84                	cmp    $0x84,%al
f010f921:	74 34                	je     f010f957 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f923:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f926:	89 d0                	mov    %edx,%eax
f010f928:	01 c0                	add    %eax,%eax
f010f92a:	01 d0                	add    %edx,%eax
f010f92c:	c1 e0 02             	shl    $0x2,%eax
f010f92f:	89 c2                	mov    %eax,%edx
f010f931:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f934:	01 d0                	add    %edx,%eax
f010f936:	8a 40 04             	mov    0x4(%eax),%al
f010f939:	3c 64                	cmp    $0x64,%al
f010f93b:	75 c1                	jne    f010f8fe <debuginfo_eip+0x207>
f010f93d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f940:	89 d0                	mov    %edx,%eax
f010f942:	01 c0                	add    %eax,%eax
f010f944:	01 d0                	add    %edx,%eax
f010f946:	c1 e0 02             	shl    $0x2,%eax
f010f949:	89 c2                	mov    %eax,%edx
f010f94b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f94e:	01 d0                	add    %edx,%eax
f010f950:	8b 40 08             	mov    0x8(%eax),%eax
f010f953:	85 c0                	test   %eax,%eax
f010f955:	74 a7                	je     f010f8fe <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f957:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f95a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f95d:	7c 42                	jl     f010f9a1 <debuginfo_eip+0x2aa>
f010f95f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f962:	89 d0                	mov    %edx,%eax
f010f964:	01 c0                	add    %eax,%eax
f010f966:	01 d0                	add    %edx,%eax
f010f968:	c1 e0 02             	shl    $0x2,%eax
f010f96b:	89 c2                	mov    %eax,%edx
f010f96d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f970:	01 d0                	add    %edx,%eax
f010f972:	8b 00                	mov    (%eax),%eax
f010f974:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f977:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f97a:	29 d1                	sub    %edx,%ecx
f010f97c:	89 ca                	mov    %ecx,%edx
f010f97e:	39 d0                	cmp    %edx,%eax
f010f980:	73 1f                	jae    f010f9a1 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f982:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f985:	89 d0                	mov    %edx,%eax
f010f987:	01 c0                	add    %eax,%eax
f010f989:	01 d0                	add    %edx,%eax
f010f98b:	c1 e0 02             	shl    $0x2,%eax
f010f98e:	89 c2                	mov    %eax,%edx
f010f990:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f993:	01 d0                	add    %edx,%eax
f010f995:	8b 10                	mov    (%eax),%edx
f010f997:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f99a:	01 c2                	add    %eax,%edx
f010f99c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f99f:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f9a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f9a6:	c9                   	leave  
f010f9a7:	c3                   	ret    

f010f9a8 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f9a8:	55                   	push   %ebp
f010f9a9:	89 e5                	mov    %esp,%ebp
f010f9ab:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f9ae:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f9b2:	74 1c                	je     f010f9d0 <setPageReplacmentAlgorithmLRU+0x28>
f010f9b4:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f9b8:	74 16                	je     f010f9d0 <setPageReplacmentAlgorithmLRU+0x28>
f010f9ba:	68 a8 7f 12 f0       	push   $0xf0127fa8
f010f9bf:	68 f2 7f 12 f0       	push   $0xf0127ff2
f010f9c4:	6a 1a                	push   $0x1a
f010f9c6:	68 07 80 12 f0       	push   $0xf0128007
f010f9cb:	e8 69 09 ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f9d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9d3:	a3 f0 d9 f5 f0       	mov    %eax,0xf0f5d9f0
}
f010f9d8:	90                   	nop
f010f9d9:	c9                   	leave  
f010f9da:	c3                   	ret    

f010f9db <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f9db:	55                   	push   %ebp
f010f9dc:	89 e5                	mov    %esp,%ebp
f010f9de:	c7 05 f0 d9 f5 f0 03 	movl   $0x3,0xf0f5d9f0
f010f9e5:	00 00 00 
f010f9e8:	90                   	nop
f010f9e9:	5d                   	pop    %ebp
f010f9ea:	c3                   	ret    

f010f9eb <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f9eb:	55                   	push   %ebp
f010f9ec:	89 e5                	mov    %esp,%ebp
f010f9ee:	c7 05 f0 d9 f5 f0 04 	movl   $0x4,0xf0f5d9f0
f010f9f5:	00 00 00 
f010f9f8:	90                   	nop
f010f9f9:	5d                   	pop    %ebp
f010f9fa:	c3                   	ret    

f010f9fb <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f9fb:	55                   	push   %ebp
f010f9fc:	89 e5                	mov    %esp,%ebp
f010f9fe:	c7 05 f0 d9 f5 f0 05 	movl   $0x5,0xf0f5d9f0
f010fa05:	00 00 00 
f010fa08:	90                   	nop
f010fa09:	5d                   	pop    %ebp
f010fa0a:	c3                   	ret    

f010fa0b <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010fa0b:	55                   	push   %ebp
f010fa0c:	89 e5                	mov    %esp,%ebp
f010fa0e:	c7 05 f0 d9 f5 f0 07 	movl   $0x7,0xf0f5d9f0
f010fa15:	00 00 00 
f010fa18:	90                   	nop
f010fa19:	5d                   	pop    %ebp
f010fa1a:	c3                   	ret    

f010fa1b <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010fa1b:	55                   	push   %ebp
f010fa1c:	89 e5                	mov    %esp,%ebp
f010fa1e:	c7 05 f0 d9 f5 f0 06 	movl   $0x6,0xf0f5d9f0
f010fa25:	00 00 00 
f010fa28:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa2b:	a3 b4 d2 75 f0       	mov    %eax,0xf075d2b4
f010fa30:	90                   	nop
f010fa31:	5d                   	pop    %ebp
f010fa32:	c3                   	ret    

f010fa33 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010fa33:	55                   	push   %ebp
f010fa34:	89 e5                	mov    %esp,%ebp
f010fa36:	8b 15 f0 d9 f5 f0    	mov    0xf0f5d9f0,%edx
f010fa3c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa3f:	39 c2                	cmp    %eax,%edx
f010fa41:	0f 94 c0             	sete   %al
f010fa44:	0f b6 c0             	movzbl %al,%eax
f010fa47:	5d                   	pop    %ebp
f010fa48:	c3                   	ret    

f010fa49 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010fa49:	55                   	push   %ebp
f010fa4a:	89 e5                	mov    %esp,%ebp
f010fa4c:	a1 f0 d9 f5 f0       	mov    0xf0f5d9f0,%eax
f010fa51:	83 f8 03             	cmp    $0x3,%eax
f010fa54:	75 07                	jne    f010fa5d <isPageReplacmentAlgorithmCLOCK+0x14>
f010fa56:	b8 01 00 00 00       	mov    $0x1,%eax
f010fa5b:	eb 05                	jmp    f010fa62 <isPageReplacmentAlgorithmCLOCK+0x19>
f010fa5d:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa62:	5d                   	pop    %ebp
f010fa63:	c3                   	ret    

f010fa64 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010fa64:	55                   	push   %ebp
f010fa65:	89 e5                	mov    %esp,%ebp
f010fa67:	a1 f0 d9 f5 f0       	mov    0xf0f5d9f0,%eax
f010fa6c:	83 f8 04             	cmp    $0x4,%eax
f010fa6f:	75 07                	jne    f010fa78 <isPageReplacmentAlgorithmFIFO+0x14>
f010fa71:	b8 01 00 00 00       	mov    $0x1,%eax
f010fa76:	eb 05                	jmp    f010fa7d <isPageReplacmentAlgorithmFIFO+0x19>
f010fa78:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa7d:	5d                   	pop    %ebp
f010fa7e:	c3                   	ret    

f010fa7f <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010fa7f:	55                   	push   %ebp
f010fa80:	89 e5                	mov    %esp,%ebp
f010fa82:	a1 f0 d9 f5 f0       	mov    0xf0f5d9f0,%eax
f010fa87:	83 f8 05             	cmp    $0x5,%eax
f010fa8a:	75 07                	jne    f010fa93 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010fa8c:	b8 01 00 00 00       	mov    $0x1,%eax
f010fa91:	eb 05                	jmp    f010fa98 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010fa93:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa98:	5d                   	pop    %ebp
f010fa99:	c3                   	ret    

f010fa9a <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010fa9a:	55                   	push   %ebp
f010fa9b:	89 e5                	mov    %esp,%ebp
f010fa9d:	a1 f0 d9 f5 f0       	mov    0xf0f5d9f0,%eax
f010faa2:	83 f8 07             	cmp    $0x7,%eax
f010faa5:	75 07                	jne    f010faae <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010faa7:	b8 01 00 00 00       	mov    $0x1,%eax
f010faac:	eb 05                	jmp    f010fab3 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010faae:	b8 00 00 00 00       	mov    $0x0,%eax
f010fab3:	5d                   	pop    %ebp
f010fab4:	c3                   	ret    

f010fab5 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010fab5:	55                   	push   %ebp
f010fab6:	89 e5                	mov    %esp,%ebp
f010fab8:	a1 f0 d9 f5 f0       	mov    0xf0f5d9f0,%eax
f010fabd:	83 f8 06             	cmp    $0x6,%eax
f010fac0:	75 07                	jne    f010fac9 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010fac2:	b8 01 00 00 00       	mov    $0x1,%eax
f010fac7:	eb 05                	jmp    f010face <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010fac9:	b8 00 00 00 00       	mov    $0x0,%eax
f010face:	5d                   	pop    %ebp
f010facf:	c3                   	ret    

f010fad0 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010fad0:	55                   	push   %ebp
f010fad1:	89 e5                	mov    %esp,%ebp
f010fad3:	8b 45 08             	mov    0x8(%ebp),%eax
f010fad6:	a3 18 d7 b5 f0       	mov    %eax,0xf0b5d718
f010fadb:	90                   	nop
f010fadc:	5d                   	pop    %ebp
f010fadd:	c3                   	ret    

f010fade <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010fade:	55                   	push   %ebp
f010fadf:	89 e5                	mov    %esp,%ebp
f010fae1:	a1 18 d7 b5 f0       	mov    0xf0b5d718,%eax
f010fae6:	5d                   	pop    %ebp
f010fae7:	c3                   	ret    

f010fae8 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010fae8:	55                   	push   %ebp
f010fae9:	89 e5                	mov    %esp,%ebp
f010faeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010faee:	a3 74 da f5 f0       	mov    %eax,0xf0f5da74
f010faf3:	90                   	nop
f010faf4:	5d                   	pop    %ebp
f010faf5:	c3                   	ret    

f010faf6 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010faf6:	55                   	push   %ebp
f010faf7:	89 e5                	mov    %esp,%ebp
f010faf9:	a1 74 da f5 f0       	mov    0xf0f5da74,%eax
f010fafe:	5d                   	pop    %ebp
f010faff:	c3                   	ret    

f010fb00 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010fb00:	55                   	push   %ebp
f010fb01:	89 e5                	mov    %esp,%ebp
f010fb03:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb06:	a3 10 db f5 f0       	mov    %eax,0xf0f5db10
f010fb0b:	90                   	nop
f010fb0c:	5d                   	pop    %ebp
f010fb0d:	c3                   	ret    

f010fb0e <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010fb0e:	55                   	push   %ebp
f010fb0f:	89 e5                	mov    %esp,%ebp
f010fb11:	a1 10 db f5 f0       	mov    0xf0f5db10,%eax
f010fb16:	5d                   	pop    %ebp
f010fb17:	c3                   	ret    

f010fb18 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010fb18:	55                   	push   %ebp
f010fb19:	89 e5                	mov    %esp,%ebp
f010fb1b:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010fb1e:	0f 20 d0             	mov    %cr2,%eax
f010fb21:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010fb24:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010fb27:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010fb2a:	e8 f6 c1 ff ff       	call   f010bd25 <get_cpu_proc>
f010fb2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010fb32:	a1 ac 4f 73 f0       	mov    0xf0734fac,%eax
f010fb37:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb3a:	75 50                	jne    f010fb8c <fault_handler+0x74>
f010fb3c:	a1 b8 4f 73 f0       	mov    0xf0734fb8,%eax
f010fb41:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010fb44:	75 46                	jne    f010fb8c <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010fb46:	a0 b4 4f 73 f0       	mov    0xf0734fb4,%al
f010fb4b:	40                   	inc    %eax
f010fb4c:	a2 b4 4f 73 f0       	mov    %al,0xf0734fb4
		if (num_repeated_fault == 3)
f010fb51:	a0 b4 4f 73 f0       	mov    0xf0734fb4,%al
f010fb56:	3c 03                	cmp    $0x3,%al
f010fb58:	75 4d                	jne    f010fba7 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010fb5a:	83 ec 0c             	sub    $0xc,%esp
f010fb5d:	ff 75 08             	pushl  0x8(%ebp)
f010fb60:	e8 76 e8 ff ff       	call   f010e3db <print_trapframe>
f010fb65:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010fb68:	8b 15 a8 4f 73 f0    	mov    0xf0734fa8,%edx
f010fb6e:	a1 b0 4f 73 f0       	mov    0xf0734fb0,%eax
f010fb73:	83 ec 08             	sub    $0x8,%esp
f010fb76:	ff 75 ec             	pushl  -0x14(%ebp)
f010fb79:	52                   	push   %edx
f010fb7a:	50                   	push   %eax
f010fb7b:	68 24 80 12 f0       	push   $0xf0128024
f010fb80:	6a 58                	push   $0x58
f010fb82:	68 07 80 12 f0       	push   $0xf0128007
f010fb87:	e8 ad 07 ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010fb8c:	a1 ac 4f 73 f0       	mov    0xf0734fac,%eax
f010fb91:	a3 b0 4f 73 f0       	mov    %eax,0xf0734fb0
		before_last_eip = last_eip;
f010fb96:	a1 a4 4f 73 f0       	mov    0xf0734fa4,%eax
f010fb9b:	a3 a8 4f 73 f0       	mov    %eax,0xf0734fa8
		num_repeated_fault = 0;
f010fba0:	c6 05 b4 4f 73 f0 00 	movb   $0x0,0xf0734fb4
	}
	last_eip = (uint32)tf->tf_eip;
f010fba7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbaa:	8b 40 30             	mov    0x30(%eax),%eax
f010fbad:	a3 a4 4f 73 f0       	mov    %eax,0xf0734fa4
	last_fault_va = fault_va ;
f010fbb2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fbb5:	a3 ac 4f 73 f0       	mov    %eax,0xf0734fac
	last_faulted_env = cur_env;
f010fbba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fbbd:	a3 b8 4f 73 f0       	mov    %eax,0xf0734fb8
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010fbc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010fbc9:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbcc:	8b 40 34             	mov    0x34(%eax),%eax
f010fbcf:	0f b7 c0             	movzwl %ax,%eax
f010fbd2:	83 e0 03             	and    $0x3,%eax
f010fbd5:	83 f8 03             	cmp    $0x3,%eax
f010fbd8:	75 07                	jne    f010fbe1 <fault_handler+0xc9>
		userTrap = 1;
f010fbda:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010fbe1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fbe5:	0f 85 c2 00 00 00    	jne    f010fcad <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010fbeb:	e8 47 78 ff ff       	call   f0107437 <mycpu>
f010fbf0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fbf3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010fbf7:	74 2f                	je     f010fc28 <fault_handler+0x110>
f010fbf9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fbfc:	8b 40 70             	mov    0x70(%eax),%eax
f010fbff:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fc02:	77 24                	ja     f010fc28 <fault_handler+0x110>
f010fc04:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fc07:	8b 40 70             	mov    0x70(%eax),%eax
f010fc0a:	05 00 10 00 00       	add    $0x1000,%eax
f010fc0f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fc12:	76 14                	jbe    f010fc28 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010fc14:	83 ec 04             	sub    $0x4,%esp
f010fc17:	68 94 80 12 f0       	push   $0xf0128094
f010fc1c:	6a 6f                	push   $0x6f
f010fc1e:	68 07 80 12 f0       	push   $0xf0128007
f010fc23:	e8 11 07 ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010fc28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fc2b:	8b 40 08             	mov    0x8(%eax),%eax
f010fc2e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fc31:	77 5d                	ja     f010fc90 <fault_handler+0x178>
f010fc33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fc36:	8b 40 08             	mov    0x8(%eax),%eax
f010fc39:	05 00 10 00 00       	add    $0x1000,%eax
f010fc3e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fc41:	76 4d                	jbe    f010fc90 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010fc43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fc46:	ba 00 d4 b5 f0       	mov    $0xf0b5d400,%edx
f010fc4b:	29 d0                	sub    %edx,%eax
f010fc4d:	c1 f8 03             	sar    $0x3,%eax
f010fc50:	89 c2                	mov    %eax,%edx
f010fc52:	89 d0                	mov    %edx,%eax
f010fc54:	c1 e0 02             	shl    $0x2,%eax
f010fc57:	01 d0                	add    %edx,%eax
f010fc59:	01 c0                	add    %eax,%eax
f010fc5b:	01 d0                	add    %edx,%eax
f010fc5d:	c1 e0 03             	shl    $0x3,%eax
f010fc60:	01 d0                	add    %edx,%eax
f010fc62:	89 c1                	mov    %eax,%ecx
f010fc64:	c1 e1 0b             	shl    $0xb,%ecx
f010fc67:	01 c8                	add    %ecx,%eax
f010fc69:	c1 e0 05             	shl    $0x5,%eax
f010fc6c:	01 d0                	add    %edx,%eax
f010fc6e:	c1 e0 02             	shl    $0x2,%eax
f010fc71:	01 d0                	add    %edx,%eax
f010fc73:	01 c0                	add    %eax,%eax
f010fc75:	01 d0                	add    %edx,%eax
f010fc77:	c1 e0 03             	shl    $0x3,%eax
f010fc7a:	01 d0                	add    %edx,%eax
f010fc7c:	f7 d8                	neg    %eax
f010fc7e:	50                   	push   %eax
f010fc7f:	68 bc 80 12 f0       	push   $0xf01280bc
f010fc84:	6a 71                	push   $0x71
f010fc86:	68 07 80 12 f0       	push   $0xf0128007
f010fc8b:	e8 a9 06 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010fc90:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010fc97:	76 3a                	jbe    f010fcd3 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010fc99:	83 ec 04             	sub    $0x4,%esp
f010fc9c:	68 f0 80 12 f0       	push   $0xf01280f0
f010fca1:	6a 74                	push   $0x74
f010fca3:	68 07 80 12 f0       	push   $0xf0128007
f010fca8:	e8 8c 06 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010fcad:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010fcb4:	76 1d                	jbe    f010fcd3 <fault_handler+0x1bb>
f010fcb6:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010fcbd:	77 14                	ja     f010fcd3 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010fcbf:	83 ec 04             	sub    $0x4,%esp
f010fcc2:	68 14 81 12 f0       	push   $0xf0128114
f010fcc7:	6a 7c                	push   $0x7c
f010fcc9:	68 07 80 12 f0       	push   $0xf0128007
f010fcce:	e8 66 06 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010fcd3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fcd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010fcd9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fcdd:	75 25                	jne    f010fd04 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010fcdf:	83 ec 0c             	sub    $0xc,%esp
f010fce2:	ff 75 08             	pushl  0x8(%ebp)
f010fce5:	e8 f1 e6 ff ff       	call   f010e3db <print_trapframe>
f010fcea:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010fced:	83 ec 04             	sub    $0x4,%esp
f010fcf0:	68 35 81 12 f0       	push   $0xf0128135
f010fcf5:	68 85 00 00 00       	push   $0x85
f010fcfa:	68 07 80 12 f0       	push   $0xf0128007
f010fcff:	e8 35 06 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010fd04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd07:	8b 40 64             	mov    0x64(%eax),%eax
f010fd0a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fd0d:	c1 ea 16             	shr    $0x16,%edx
f010fd10:	c1 e2 02             	shl    $0x2,%edx
f010fd13:	01 d0                	add    %edx,%eax
f010fd15:	8b 00                	mov    (%eax),%eax
f010fd17:	83 e0 01             	and    $0x1,%eax
f010fd1a:	85 c0                	test   %eax,%eax
f010fd1c:	75 2b                	jne    f010fd49 <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010fd1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd21:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010fd27:	8d 50 01             	lea    0x1(%eax),%edx
f010fd2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd2d:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010fd33:	83 ec 08             	sub    $0x8,%esp
f010fd36:	ff 75 ec             	pushl  -0x14(%ebp)
f010fd39:	ff 75 e0             	pushl  -0x20(%ebp)
f010fd3c:	e8 1e 01 00 00       	call   f010fe5f <table_fault_handler>
f010fd41:	83 c4 10             	add    $0x10,%esp
f010fd44:	e9 07 01 00 00       	jmp    f010fe50 <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010fd49:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fd4d:	0f 84 82 00 00 00    	je     f010fdd5 <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010fd53:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010fd5a:	76 07                	jbe    f010fd63 <fault_handler+0x24b>
			{
				env_exit();
f010fd5c:	e8 82 bf ff ff       	call   f010bce3 <env_exit>
f010fd61:	eb 72                	jmp    f010fdd5 <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010fd63:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd66:	8b 40 64             	mov    0x64(%eax),%eax
f010fd69:	83 ec 08             	sub    $0x8,%esp
f010fd6c:	ff 75 ec             	pushl  -0x14(%ebp)
f010fd6f:	50                   	push   %eax
f010fd70:	e8 f8 a2 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fd75:	83 c4 10             	add    $0x10,%esp
f010fd78:	25 00 02 00 00       	and    $0x200,%eax
f010fd7d:	85 c0                	test   %eax,%eax
f010fd7f:	75 17                	jne    f010fd98 <fault_handler+0x280>
f010fd81:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fd84:	85 c0                	test   %eax,%eax
f010fd86:	79 10                	jns    f010fd98 <fault_handler+0x280>
f010fd88:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010fd8f:	77 07                	ja     f010fd98 <fault_handler+0x280>
			{
				env_exit();
f010fd91:	e8 4d bf ff ff       	call   f010bce3 <env_exit>
f010fd96:	eb 3d                	jmp    f010fdd5 <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (!(pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010fd98:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fd9b:	8b 40 64             	mov    0x64(%eax),%eax
f010fd9e:	83 ec 08             	sub    $0x8,%esp
f010fda1:	ff 75 ec             	pushl  -0x14(%ebp)
f010fda4:	50                   	push   %eax
f010fda5:	e8 c3 a2 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fdaa:	83 c4 10             	add    $0x10,%esp
f010fdad:	83 e0 01             	and    $0x1,%eax
f010fdb0:	85 c0                	test   %eax,%eax
f010fdb2:	74 21                	je     f010fdd5 <fault_handler+0x2bd>
f010fdb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fdb7:	8b 40 64             	mov    0x64(%eax),%eax
f010fdba:	83 ec 08             	sub    $0x8,%esp
f010fdbd:	ff 75 ec             	pushl  -0x14(%ebp)
f010fdc0:	50                   	push   %eax
f010fdc1:	e8 a7 a2 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fdc6:	83 c4 10             	add    $0x10,%esp
f010fdc9:	83 e0 02             	and    $0x2,%eax
f010fdcc:	85 c0                	test   %eax,%eax
f010fdce:	75 05                	jne    f010fdd5 <fault_handler+0x2bd>
			{
				env_exit();
f010fdd0:	e8 0e bf ff ff       	call   f010bce3 <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fdd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fdd8:	8b 40 64             	mov    0x64(%eax),%eax
f010fddb:	83 ec 08             	sub    $0x8,%esp
f010fdde:	ff 75 ec             	pushl  -0x14(%ebp)
f010fde1:	50                   	push   %eax
f010fde2:	e8 86 a2 ff ff       	call   f010a06d <pt_get_page_permissions>
f010fde7:	83 c4 10             	add    $0x10,%esp
f010fdea:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fded:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fdf0:	83 e0 01             	and    $0x1,%eax
f010fdf3:	85 c0                	test   %eax,%eax
f010fdf5:	74 17                	je     f010fe0e <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fdf7:	ff 75 ec             	pushl  -0x14(%ebp)
f010fdfa:	68 4c 81 12 f0       	push   $0xf012814c
f010fdff:	68 ad 00 00 00       	push   $0xad
f010fe04:	68 07 80 12 f0       	push   $0xf0128007
f010fe09:	e8 2b 05 ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fe0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fe11:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010fe17:	8d 50 01             	lea    0x1(%eax),%edx
f010fe1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fe1d:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010fe23:	e8 ce fc ff ff       	call   f010faf6 <isBufferingEnabled>
f010fe28:	84 c0                	test   %al,%al
f010fe2a:	74 13                	je     f010fe3f <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fe2c:	83 ec 08             	sub    $0x8,%esp
f010fe2f:	ff 75 ec             	pushl  -0x14(%ebp)
f010fe32:	ff 75 e0             	pushl  -0x20(%ebp)
f010fe35:	e8 e6 01 00 00       	call   f0110020 <__page_fault_handler_with_buffering>
f010fe3a:	83 c4 10             	add    $0x10,%esp
f010fe3d:	eb 11                	jmp    f010fe50 <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010fe3f:	83 ec 08             	sub    $0x8,%esp
f010fe42:	ff 75 ec             	pushl  -0x14(%ebp)
f010fe45:	ff 75 e0             	pushl  -0x20(%ebp)
f010fe48:	e8 33 00 00 00       	call   f010fe80 <page_fault_handler>
f010fe4d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fe50:	0f 20 d8             	mov    %cr3,%eax
f010fe53:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010fe56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe59:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fe5c:	90                   	nop
f010fe5d:	c9                   	leave  
f010fe5e:	c3                   	ret    

f010fe5f <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fe5f:	55                   	push   %ebp
f010fe60:	89 e5                	mov    %esp,%ebp
f010fe62:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fe65:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe68:	8b 40 64             	mov    0x64(%eax),%eax
f010fe6b:	83 ec 08             	sub    $0x8,%esp
f010fe6e:	ff 75 0c             	pushl  0xc(%ebp)
f010fe71:	50                   	push   %eax
f010fe72:	e8 f9 89 ff ff       	call   f0108870 <create_page_table>
f010fe77:	83 c4 10             	add    $0x10,%esp
f010fe7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fe7d:	90                   	nop
f010fe7e:	c9                   	leave  
f010fe7f:	c3                   	ret    

f010fe80 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fe80:	55                   	push   %ebp
f010fe81:	89 e5                	mov    %esp,%ebp
f010fe83:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010fe86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fe8d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe90:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fe96:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010fe99:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe9c:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fea2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fea5:	0f 86 72 01 00 00    	jbe    f011001d <page_fault_handler+0x19d>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010feab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010feae:	83 ec 08             	sub    $0x8,%esp
f010feb1:	50                   	push   %eax
f010feb2:	ff 75 08             	pushl  0x8(%ebp)
f010feb5:	e8 15 48 ff ff       	call   f01046cf <pf_read_env_page>
f010feba:	83 c4 10             	add    $0x10,%esp
f010febd:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010fec0:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010fec4:	75 45                	jne    f010ff0b <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010fec6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fec9:	85 c0                	test   %eax,%eax
f010fecb:	79 09                	jns    f010fed6 <page_fault_handler+0x56>
f010fecd:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010fed4:	76 35                	jbe    f010ff0b <page_fault_handler+0x8b>
f010fed6:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010fedd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fee0:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010fee5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010fee8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010feeb:	ba 00 00 00 00       	mov    $0x0,%edx
f010fef0:	f7 75 e8             	divl   -0x18(%ebp)
f010fef3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fef6:	29 d0                	sub    %edx,%eax
f010fef8:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fefb:	77 09                	ja     f010ff06 <page_fault_handler+0x86>
f010fefd:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010ff04:	76 05                	jbe    f010ff0b <page_fault_handler+0x8b>
			{
				env_exit();
f010ff06:	e8 d8 bd ff ff       	call   f010bce3 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010ff0b:	83 ec 0c             	sub    $0xc,%esp
f010ff0e:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010ff11:	50                   	push   %eax
f010ff12:	e8 c6 85 ff ff       	call   f01084dd <allocate_frame>
f010ff17:	83 c4 10             	add    $0x10,%esp
f010ff1a:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010ff1d:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010ff21:	74 34                	je     f010ff57 <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010ff23:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010ff26:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff29:	8b 40 64             	mov    0x64(%eax),%eax
f010ff2c:	6a 06                	push   $0x6
f010ff2e:	ff 75 0c             	pushl  0xc(%ebp)
f010ff31:	52                   	push   %edx
f010ff32:	50                   	push   %eax
f010ff33:	e8 72 8a ff ff       	call   f01089aa <map_frame>
f010ff38:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010ff3b:	83 ec 08             	sub    $0x8,%esp
f010ff3e:	ff 75 0c             	pushl  0xc(%ebp)
f010ff41:	ff 75 08             	pushl  0x8(%ebp)
f010ff44:	e8 96 a2 ff ff       	call   f010a1df <env_page_ws_list_create_element>
f010ff49:	83 c4 10             	add    $0x10,%esp
f010ff4c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010ff4f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010ff53:	75 30                	jne    f010ff85 <page_fault_handler+0x105>
f010ff55:	eb 17                	jmp    f010ff6e <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010ff57:	83 ec 04             	sub    $0x4,%esp
f010ff5a:	68 90 81 12 f0       	push   $0xf0128190
f010ff5f:	68 03 01 00 00       	push   $0x103
f010ff64:	68 07 80 12 f0       	push   $0xf0128007
f010ff69:	e8 cb 03 ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010ff6e:	83 ec 04             	sub    $0x4,%esp
f010ff71:	68 a8 81 12 f0       	push   $0xf01281a8
f010ff76:	68 05 01 00 00       	push   $0x105
f010ff7b:	68 07 80 12 f0       	push   $0xf0128007
f010ff80:	e8 b4 03 ff ff       	call   f0100339 <_panic>
f010ff85:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff88:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010ff8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff91:	89 50 14             	mov    %edx,0x14(%eax)
f010ff94:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff97:	8b 40 14             	mov    0x14(%eax),%eax
f010ff9a:	85 c0                	test   %eax,%eax
f010ff9c:	74 11                	je     f010ffaf <page_fault_handler+0x12f>
f010ff9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa1:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010ffa7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ffaa:	89 50 10             	mov    %edx,0x10(%eax)
f010ffad:	eb 0c                	jmp    f010ffbb <page_fault_handler+0x13b>
f010ffaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffb2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ffb5:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010ffbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffbe:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ffc1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010ffc7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffca:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010ffd1:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffd4:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010ffda:	8d 50 01             	lea    0x1(%eax),%edx
f010ffdd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffe0:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010ffe6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffe9:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010ffef:	8b 45 08             	mov    0x8(%ebp),%eax
f010fff2:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fff8:	39 c2                	cmp    %eax,%edx
f010fffa:	75 14                	jne    f0110010 <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010fffc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffff:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f0110005:	8b 45 08             	mov    0x8(%ebp),%eax
f0110008:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
//		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f011000e:	eb 0d                	jmp    f011001d <page_fault_handler+0x19d>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f0110010:	8b 45 08             	mov    0x8(%ebp),%eax
f0110013:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f011001a:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
//		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f011001d:	90                   	nop
f011001e:	c9                   	leave  
f011001f:	c3                   	ret    

f0110020 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f0110020:	55                   	push   %ebp
f0110021:	89 e5                	mov    %esp,%ebp
f0110023:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f0110026:	83 ec 04             	sub    $0x4,%esp
f0110029:	68 cc 81 12 f0       	push   $0xf01281cc
f011002e:	68 1d 01 00 00       	push   $0x11d
f0110033:	68 07 80 12 f0       	push   $0xf0128007
f0110038:	e8 fc 02 ff ff       	call   f0100339 <_panic>

f011003d <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f011003d:	55                   	push   %ebp
f011003e:	89 e5                	mov    %esp,%ebp
f0110040:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f0110043:	8b 45 08             	mov    0x8(%ebp),%eax
f0110046:	83 c0 04             	add    $0x4,%eax
f0110049:	83 ec 08             	sub    $0x8,%esp
f011004c:	ff 75 0c             	pushl  0xc(%ebp)
f011004f:	50                   	push   %eax
f0110050:	e8 16 00 01 00       	call   f012006b <strcpy>
f0110055:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f0110058:	8b 45 08             	mov    0x8(%ebp),%eax
f011005b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f0110061:	8b 45 08             	mov    0x8(%ebp),%eax
f0110064:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f011006b:	90                   	nop
f011006c:	c9                   	leave  
f011006d:	c3                   	ret    

f011006e <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f011006e:	55                   	push   %ebp
f011006f:	89 e5                	mov    %esp,%ebp
f0110071:	53                   	push   %ebx
f0110072:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f0110075:	8b 45 08             	mov    0x8(%ebp),%eax
f0110078:	83 ec 0c             	sub    $0xc,%esp
f011007b:	50                   	push   %eax
f011007c:	e8 06 02 00 00       	call   f0110287 <holding_spinlock>
f0110081:	83 c4 10             	add    $0x10,%esp
f0110084:	85 c0                	test   %eax,%eax
f0110086:	74 18                	je     f01100a0 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f0110088:	8b 45 08             	mov    0x8(%ebp),%eax
f011008b:	83 c0 04             	add    $0x4,%eax
f011008e:	50                   	push   %eax
f011008f:	68 10 82 12 f0       	push   $0xf0128210
f0110094:	6a 1f                	push   $0x1f
f0110096:	68 4d 82 12 f0       	push   $0xf012824d
f011009b:	e8 99 02 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f01100a0:	e8 55 74 ff ff       	call   f01074fa <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f01100a5:	90                   	nop
f01100a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01100a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01100ac:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01100b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01100b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01100b9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01100bc:	f0 87 02             	lock xchg %eax,(%edx)
f01100bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f01100c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01100c5:	85 c0                	test   %eax,%eax
f01100c7:	75 dd                	jne    f01100a6 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f01100c9:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f01100ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
f01100d1:	e8 61 73 ff ff       	call   f0107437 <mycpu>
f01100d6:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f01100d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01100dc:	83 c0 48             	add    $0x48,%eax
f01100df:	83 ec 08             	sub    $0x8,%esp
f01100e2:	50                   	push   %eax
f01100e3:	8d 45 08             	lea    0x8(%ebp),%eax
f01100e6:	50                   	push   %eax
f01100e7:	e8 74 00 00 00       	call   f0110160 <getcallerpcs>
f01100ec:	83 c4 10             	add    $0x10,%esp

}
f01100ef:	90                   	nop
f01100f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01100f3:	c9                   	leave  
f01100f4:	c3                   	ret    

f01100f5 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f01100f5:	55                   	push   %ebp
f01100f6:	89 e5                	mov    %esp,%ebp
f01100f8:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f01100fb:	83 ec 0c             	sub    $0xc,%esp
f01100fe:	ff 75 08             	pushl  0x8(%ebp)
f0110101:	e8 81 01 00 00       	call   f0110287 <holding_spinlock>
f0110106:	83 c4 10             	add    $0x10,%esp
f0110109:	85 c0                	test   %eax,%eax
f011010b:	75 26                	jne    f0110133 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f011010d:	83 ec 0c             	sub    $0xc,%esp
f0110110:	ff 75 08             	pushl  0x8(%ebp)
f0110113:	e8 08 01 00 00       	call   f0110220 <printcallstack>
f0110118:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f011011b:	8b 45 08             	mov    0x8(%ebp),%eax
f011011e:	83 c0 04             	add    $0x4,%eax
f0110121:	50                   	push   %eax
f0110122:	68 64 82 12 f0       	push   $0xf0128264
f0110127:	6a 3c                	push   $0x3c
f0110129:	68 4d 82 12 f0       	push   $0xf012824d
f011012e:	e8 06 02 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f0110133:	8b 45 08             	mov    0x8(%ebp),%eax
f0110136:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f011013d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110140:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f0110147:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f011014c:	8b 45 08             	mov    0x8(%ebp),%eax
f011014f:	8b 55 08             	mov    0x8(%ebp),%edx
f0110152:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f0110158:	e8 ef 73 ff ff       	call   f010754c <popcli>
}
f011015d:	90                   	nop
f011015e:	c9                   	leave  
f011015f:	c3                   	ret    

f0110160 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f0110160:	55                   	push   %ebp
f0110161:	89 e5                	mov    %esp,%ebp
f0110163:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f0110166:	e8 ba bb ff ff       	call   f010bd25 <get_cpu_proc>
f011016b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f011016e:	e8 c4 72 ff ff       	call   f0107437 <mycpu>
f0110173:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f0110176:	8b 45 08             	mov    0x8(%ebp),%eax
f0110179:	83 e8 08             	sub    $0x8,%eax
f011017c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f011017f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0110186:	eb 67                	jmp    f01101ef <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f0110188:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011018c:	74 67                	je     f01101f5 <getcallerpcs+0x95>
f011018e:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f0110195:	76 5e                	jbe    f01101f5 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f0110197:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011019a:	8b 40 08             	mov    0x8(%eax),%eax
f011019d:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f01101a2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01101a5:	77 10                	ja     f01101b7 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f01101a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01101aa:	8b 40 08             	mov    0x8(%eax),%eax
f01101ad:	05 00 90 00 00       	add    $0x9000,%eax
f01101b2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01101b5:	77 3e                	ja     f01101f5 <getcallerpcs+0x95>
f01101b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01101bb:	74 10                	je     f01101cd <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f01101bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01101c0:	8b 40 70             	mov    0x70(%eax),%eax
f01101c3:	05 00 80 00 00       	add    $0x8000,%eax
f01101c8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01101cb:	76 28                	jbe    f01101f5 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f01101cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01101d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01101d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101da:	01 c2                	add    %eax,%edx
f01101dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01101df:	8b 40 04             	mov    0x4(%eax),%eax
f01101e2:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f01101e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01101e7:	8b 00                	mov    (%eax),%eax
f01101e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f01101ec:	ff 45 f0             	incl   -0x10(%ebp)
f01101ef:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f01101f3:	7e 93                	jle    f0110188 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f01101f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01101f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f01101fb:	eb 18                	jmp    f0110215 <getcallerpcs+0xb5>
		pcs[i] = 0;
f01101fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110200:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110207:	8b 45 0c             	mov    0xc(%ebp),%eax
f011020a:	01 d0                	add    %edx,%eax
f011020c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f0110212:	ff 45 f0             	incl   -0x10(%ebp)
f0110215:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0110219:	7e e2                	jle    f01101fd <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f011021b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f011021e:	c9                   	leave  
f011021f:	c3                   	ret    

f0110220 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f0110220:	55                   	push   %ebp
f0110221:	89 e5                	mov    %esp,%ebp
f0110223:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f0110226:	83 ec 0c             	sub    $0xc,%esp
f0110229:	68 a2 82 12 f0       	push   $0xf01282a2
f011022e:	e8 58 0d ff ff       	call   f0100f8b <cprintf>
f0110233:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f0110236:	8b 45 08             	mov    0x8(%ebp),%eax
f0110239:	83 c0 48             	add    $0x48,%eax
f011023c:	83 ec 08             	sub    $0x8,%esp
f011023f:	50                   	push   %eax
f0110240:	8d 45 08             	lea    0x8(%ebp),%eax
f0110243:	50                   	push   %eax
f0110244:	e8 17 ff ff ff       	call   f0110160 <getcallerpcs>
f0110249:	83 c4 10             	add    $0x10,%esp
f011024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f011024f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110256:	eb 24                	jmp    f011027c <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f0110258:	8b 45 08             	mov    0x8(%ebp),%eax
f011025b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011025e:	83 c2 10             	add    $0x10,%edx
f0110261:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f0110265:	83 ec 04             	sub    $0x4,%esp
f0110268:	50                   	push   %eax
f0110269:	ff 75 f4             	pushl  -0xc(%ebp)
f011026c:	68 b2 82 12 f0       	push   $0xf01282b2
f0110271:	e8 15 0d ff ff       	call   f0100f8b <cprintf>
f0110276:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f0110279:	ff 45 f4             	incl   -0xc(%ebp)
f011027c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011027f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0110282:	7c d4                	jl     f0110258 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f0110284:	90                   	nop
f0110285:	c9                   	leave  
f0110286:	c3                   	ret    

f0110287 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f0110287:	55                   	push   %ebp
f0110288:	89 e5                	mov    %esp,%ebp
f011028a:	53                   	push   %ebx
f011028b:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f011028e:	e8 67 72 ff ff       	call   f01074fa <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f0110293:	8b 45 08             	mov    0x8(%ebp),%eax
f0110296:	8b 00                	mov    (%eax),%eax
f0110298:	85 c0                	test   %eax,%eax
f011029a:	74 16                	je     f01102b2 <holding_spinlock+0x2b>
f011029c:	8b 45 08             	mov    0x8(%ebp),%eax
f011029f:	8b 58 44             	mov    0x44(%eax),%ebx
f01102a2:	e8 90 71 ff ff       	call   f0107437 <mycpu>
f01102a7:	39 c3                	cmp    %eax,%ebx
f01102a9:	75 07                	jne    f01102b2 <holding_spinlock+0x2b>
f01102ab:	b8 01 00 00 00       	mov    $0x1,%eax
f01102b0:	eb 05                	jmp    f01102b7 <holding_spinlock+0x30>
f01102b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01102b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f01102ba:	e8 8d 72 ff ff       	call   f010754c <popcli>
	return r;
f01102bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01102c2:	83 c4 14             	add    $0x14,%esp
f01102c5:	5b                   	pop    %ebx
f01102c6:	5d                   	pop    %ebp
f01102c7:	c3                   	ret    

f01102c8 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f01102c8:	55                   	push   %ebp
f01102c9:	89 e5                	mov    %esp,%ebp
f01102cb:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f01102ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01102d1:	83 c0 74             	add    $0x74,%eax
f01102d4:	83 ec 08             	sub    $0x8,%esp
f01102d7:	68 c1 82 12 f0       	push   $0xf01282c1
f01102dc:	50                   	push   %eax
f01102dd:	e8 4c 01 00 00       	call   f011042e <init_channel>
f01102e2:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f01102e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01102e8:	83 c0 04             	add    $0x4,%eax
f01102eb:	83 ec 08             	sub    $0x8,%esp
f01102ee:	68 d4 82 12 f0       	push   $0xf01282d4
f01102f3:	50                   	push   %eax
f01102f4:	e8 44 fd ff ff       	call   f011003d <init_spinlock>
f01102f9:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f01102fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01102ff:	05 c4 00 00 00       	add    $0xc4,%eax
f0110304:	83 ec 08             	sub    $0x8,%esp
f0110307:	ff 75 0c             	pushl  0xc(%ebp)
f011030a:	50                   	push   %eax
f011030b:	e8 5b fd 00 00       	call   f012006b <strcpy>
f0110310:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f0110313:	8b 45 08             	mov    0x8(%ebp),%eax
f0110316:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f011031c:	8b 45 08             	mov    0x8(%ebp),%eax
f011031f:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f0110326:	00 00 00 
}
f0110329:	90                   	nop
f011032a:	c9                   	leave  
f011032b:	c3                   	ret    

f011032c <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f011032c:	55                   	push   %ebp
f011032d:	89 e5                	mov    %esp,%ebp
f011032f:	53                   	push   %ebx
f0110330:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f0110333:	8b 45 08             	mov    0x8(%ebp),%eax
f0110336:	83 c0 04             	add    $0x4,%eax
f0110339:	83 ec 0c             	sub    $0xc,%esp
f011033c:	50                   	push   %eax
f011033d:	e8 2c fd ff ff       	call   f011006e <acquire_spinlock>
f0110342:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f0110345:	8b 45 08             	mov    0x8(%ebp),%eax
f0110348:	8b 00                	mov    (%eax),%eax
f011034a:	85 c0                	test   %eax,%eax
f011034c:	74 1c                	je     f011036a <holding_sleeplock+0x3e>
f011034e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110351:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f0110357:	e8 c9 b9 ff ff       	call   f010bd25 <get_cpu_proc>
f011035c:	8b 40 10             	mov    0x10(%eax),%eax
f011035f:	39 c3                	cmp    %eax,%ebx
f0110361:	75 07                	jne    f011036a <holding_sleeplock+0x3e>
f0110363:	b8 01 00 00 00       	mov    $0x1,%eax
f0110368:	eb 05                	jmp    f011036f <holding_sleeplock+0x43>
f011036a:	b8 00 00 00 00       	mov    $0x0,%eax
f011036f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f0110372:	8b 45 08             	mov    0x8(%ebp),%eax
f0110375:	83 c0 04             	add    $0x4,%eax
f0110378:	83 ec 0c             	sub    $0xc,%esp
f011037b:	50                   	push   %eax
f011037c:	e8 74 fd ff ff       	call   f01100f5 <release_spinlock>
f0110381:	83 c4 10             	add    $0x10,%esp
	return r;
f0110384:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110387:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011038a:	c9                   	leave  
f011038b:	c3                   	ret    

f011038c <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f011038c:	55                   	push   %ebp
f011038d:	89 e5                	mov    %esp,%ebp
f011038f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f0110392:	8b 45 08             	mov    0x8(%ebp),%eax
f0110395:	83 c0 04             	add    $0x4,%eax
f0110398:	83 ec 0c             	sub    $0xc,%esp
f011039b:	50                   	push   %eax
f011039c:	e8 cd fc ff ff       	call   f011006e <acquire_spinlock>
f01103a1:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f01103a4:	eb 19                	jmp    f01103bf <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f01103a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01103a9:	8d 50 04             	lea    0x4(%eax),%edx
f01103ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01103af:	83 c0 74             	add    $0x74,%eax
f01103b2:	83 ec 08             	sub    $0x8,%esp
f01103b5:	52                   	push   %edx
f01103b6:	50                   	push   %eax
f01103b7:	e8 9f 00 00 00       	call   f011045b <sleep>
f01103bc:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f01103bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01103c2:	8b 00                	mov    (%eax),%eax
f01103c4:	85 c0                	test   %eax,%eax
f01103c6:	75 de                	jne    f01103a6 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f01103c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01103cb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f01103d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01103d4:	83 c0 04             	add    $0x4,%eax
f01103d7:	83 ec 0c             	sub    $0xc,%esp
f01103da:	50                   	push   %eax
f01103db:	e8 15 fd ff ff       	call   f01100f5 <release_spinlock>
f01103e0:	83 c4 10             	add    $0x10,%esp

}
f01103e3:	90                   	nop
f01103e4:	c9                   	leave  
f01103e5:	c3                   	ret    

f01103e6 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f01103e6:	55                   	push   %ebp
f01103e7:	89 e5                	mov    %esp,%ebp
f01103e9:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f01103ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01103ef:	83 c0 04             	add    $0x4,%eax
f01103f2:	83 ec 0c             	sub    $0xc,%esp
f01103f5:	50                   	push   %eax
f01103f6:	e8 73 fc ff ff       	call   f011006e <acquire_spinlock>
f01103fb:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f01103fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0110401:	83 c0 74             	add    $0x74,%eax
f0110404:	83 ec 0c             	sub    $0xc,%esp
f0110407:	50                   	push   %eax
f0110408:	e8 3f 01 00 00       	call   f011054c <wakeup_all>
f011040d:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f0110410:	8b 45 08             	mov    0x8(%ebp),%eax
f0110413:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f0110419:	8b 45 08             	mov    0x8(%ebp),%eax
f011041c:	83 c0 04             	add    $0x4,%eax
f011041f:	83 ec 0c             	sub    $0xc,%esp
f0110422:	50                   	push   %eax
f0110423:	e8 cd fc ff ff       	call   f01100f5 <release_spinlock>
f0110428:	83 c4 10             	add    $0x10,%esp
}
f011042b:	90                   	nop
f011042c:	c9                   	leave  
f011042d:	c3                   	ret    

f011042e <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f011042e:	55                   	push   %ebp
f011042f:	89 e5                	mov    %esp,%ebp
f0110431:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f0110434:	8b 45 08             	mov    0x8(%ebp),%eax
f0110437:	83 c0 10             	add    $0x10,%eax
f011043a:	83 ec 08             	sub    $0x8,%esp
f011043d:	ff 75 0c             	pushl  0xc(%ebp)
f0110440:	50                   	push   %eax
f0110441:	e8 25 fc 00 00       	call   f012006b <strcpy>
f0110446:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f0110449:	8b 45 08             	mov    0x8(%ebp),%eax
f011044c:	83 ec 0c             	sub    $0xc,%esp
f011044f:	50                   	push   %eax
f0110450:	e8 02 4d ff ff       	call   f0105157 <init_queue>
f0110455:	83 c4 10             	add    $0x10,%esp
}
f0110458:	90                   	nop
f0110459:	c9                   	leave  
f011045a:	c3                   	ret    

f011045b <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f011045b:	55                   	push   %ebp
f011045c:	89 e5                	mov    %esp,%ebp
f011045e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f0110461:	83 ec 0c             	sub    $0xc,%esp
f0110464:	68 20 d2 75 f0       	push   $0xf075d220
f0110469:	e8 00 fc ff ff       	call   f011006e <acquire_spinlock>
f011046e:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f0110471:	e8 af b8 ff ff       	call   f010bd25 <get_cpu_proc>
f0110476:	89 c2                	mov    %eax,%edx
f0110478:	8b 45 08             	mov    0x8(%ebp),%eax
f011047b:	83 ec 08             	sub    $0x8,%esp
f011047e:	52                   	push   %edx
f011047f:	50                   	push   %eax
f0110480:	e8 13 4d ff ff       	call   f0105198 <enqueue>
f0110485:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f0110488:	e8 98 b8 ff ff       	call   f010bd25 <get_cpu_proc>
f011048d:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f0110494:	83 ec 0c             	sub    $0xc,%esp
f0110497:	ff 75 0c             	pushl  0xc(%ebp)
f011049a:	e8 56 fc ff ff       	call   f01100f5 <release_spinlock>
f011049f:	83 c4 10             	add    $0x10,%esp
	sched();
f01104a2:	e8 ff b9 ff ff       	call   f010bea6 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f01104a7:	83 ec 0c             	sub    $0xc,%esp
f01104aa:	68 20 d2 75 f0       	push   $0xf075d220
f01104af:	e8 41 fc ff ff       	call   f01100f5 <release_spinlock>
f01104b4:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f01104b7:	83 ec 0c             	sub    $0xc,%esp
f01104ba:	ff 75 0c             	pushl  0xc(%ebp)
f01104bd:	e8 ac fb ff ff       	call   f011006e <acquire_spinlock>
f01104c2:	83 c4 10             	add    $0x10,%esp
}
f01104c5:	90                   	nop
f01104c6:	c9                   	leave  
f01104c7:	c3                   	ret    

f01104c8 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f01104c8:	55                   	push   %ebp
f01104c9:	89 e5                	mov    %esp,%ebp
f01104cb:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f01104ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01104d1:	83 ec 0c             	sub    $0xc,%esp
f01104d4:	50                   	push   %eax
f01104d5:	e8 a6 4c ff ff       	call   f0105180 <queue_size>
f01104da:	83 c4 10             	add    $0x10,%esp
f01104dd:	85 c0                	test   %eax,%eax
f01104df:	74 68                	je     f0110549 <wakeup_one+0x81>
		bool locked_by_me = 0;
f01104e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f01104e8:	83 ec 0c             	sub    $0xc,%esp
f01104eb:	68 20 d2 75 f0       	push   $0xf075d220
f01104f0:	e8 92 fd ff ff       	call   f0110287 <holding_spinlock>
f01104f5:	83 c4 10             	add    $0x10,%esp
f01104f8:	85 c0                	test   %eax,%eax
f01104fa:	75 17                	jne    f0110513 <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f01104fc:	83 ec 0c             	sub    $0xc,%esp
f01104ff:	68 20 d2 75 f0       	push   $0xf075d220
f0110504:	e8 65 fb ff ff       	call   f011006e <acquire_spinlock>
f0110509:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f011050c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f0110513:	8b 45 08             	mov    0x8(%ebp),%eax
f0110516:	83 ec 0c             	sub    $0xc,%esp
f0110519:	50                   	push   %eax
f011051a:	e8 0a 4d ff ff       	call   f0105229 <dequeue>
f011051f:	83 c4 10             	add    $0x10,%esp
f0110522:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f0110525:	83 ec 0c             	sub    $0xc,%esp
f0110528:	ff 75 f0             	pushl  -0x10(%ebp)
f011052b:	e8 34 4f ff ff       	call   f0105464 <sched_insert_ready0>
f0110530:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f0110533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110537:	74 10                	je     f0110549 <wakeup_one+0x81>
f0110539:	83 ec 0c             	sub    $0xc,%esp
f011053c:	68 20 d2 75 f0       	push   $0xf075d220
f0110541:	e8 af fb ff ff       	call   f01100f5 <release_spinlock>
f0110546:	83 c4 10             	add    $0x10,%esp
	}
}
f0110549:	90                   	nop
f011054a:	c9                   	leave  
f011054b:	c3                   	ret    

f011054c <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f011054c:	55                   	push   %ebp
f011054d:	89 e5                	mov    %esp,%ebp
f011054f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f0110552:	83 ec 0c             	sub    $0xc,%esp
f0110555:	68 20 d2 75 f0       	push   $0xf075d220
f011055a:	e8 0f fb ff ff       	call   f011006e <acquire_spinlock>
f011055f:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f0110562:	eb 0e                	jmp    f0110572 <wakeup_all+0x26>
		wakeup_one(chan);
f0110564:	83 ec 0c             	sub    $0xc,%esp
f0110567:	ff 75 08             	pushl  0x8(%ebp)
f011056a:	e8 59 ff ff ff       	call   f01104c8 <wakeup_one>
f011056f:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f0110572:	8b 45 08             	mov    0x8(%ebp),%eax
f0110575:	83 ec 0c             	sub    $0xc,%esp
f0110578:	50                   	push   %eax
f0110579:	e8 02 4c ff ff       	call   f0105180 <queue_size>
f011057e:	83 c4 10             	add    $0x10,%esp
f0110581:	85 c0                	test   %eax,%eax
f0110583:	75 df                	jne    f0110564 <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f0110585:	83 ec 0c             	sub    $0xc,%esp
f0110588:	68 20 d2 75 f0       	push   $0xf075d220
f011058d:	e8 63 fb ff ff       	call   f01100f5 <release_spinlock>
f0110592:	83 c4 10             	add    $0x10,%esp
}
f0110595:	90                   	nop
f0110596:	c9                   	leave  
f0110597:	c3                   	ret    

f0110598 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f0110598:	55                   	push   %ebp
f0110599:	89 e5                	mov    %esp,%ebp
f011059b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f011059e:	83 ec 04             	sub    $0x4,%esp
f01105a1:	68 e8 82 12 f0       	push   $0xf01282e8
f01105a6:	6a 13                	push   $0x13
f01105a8:	68 0f 83 12 f0       	push   $0xf012830f
f01105ad:	e8 87 fd fe ff       	call   f0100339 <_panic>

f01105b2 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f01105b2:	55                   	push   %ebp
f01105b3:	89 e5                	mov    %esp,%ebp
f01105b5:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f01105b8:	83 ec 04             	sub    $0x4,%esp
f01105bb:	68 28 83 12 f0       	push   $0xf0128328
f01105c0:	6a 1b                	push   $0x1b
f01105c2:	68 0f 83 12 f0       	push   $0xf012830f
f01105c7:	e8 6d fd fe ff       	call   f0100339 <_panic>

f01105cc <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f01105cc:	55                   	push   %ebp
f01105cd:	89 e5                	mov    %esp,%ebp
f01105cf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f01105d2:	83 ec 04             	sub    $0x4,%esp
f01105d5:	68 50 83 12 f0       	push   $0xf0128350
f01105da:	6a 24                	push   $0x24
f01105dc:	68 0f 83 12 f0       	push   $0xf012830f
f01105e1:	e8 53 fd fe ff       	call   f0100339 <_panic>

f01105e6 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f01105e6:	55                   	push   %ebp
f01105e7:	89 e5                	mov    %esp,%ebp
f01105e9:	c7 05 b8 d7 b5 f0 01 	movl   $0x1,0xf0b5d7b8
f01105f0:	00 00 00 
f01105f3:	90                   	nop
f01105f4:	5d                   	pop    %ebp
f01105f5:	c3                   	ret    

f01105f6 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f01105f6:	55                   	push   %ebp
f01105f7:	89 e5                	mov    %esp,%ebp
f01105f9:	c7 05 b8 d7 b5 f0 02 	movl   $0x2,0xf0b5d7b8
f0110600:	00 00 00 
f0110603:	90                   	nop
f0110604:	5d                   	pop    %ebp
f0110605:	c3                   	ret    

f0110606 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0110606:	55                   	push   %ebp
f0110607:	89 e5                	mov    %esp,%ebp
f0110609:	c7 05 b8 d7 b5 f0 03 	movl   $0x3,0xf0b5d7b8
f0110610:	00 00 00 
f0110613:	90                   	nop
f0110614:	5d                   	pop    %ebp
f0110615:	c3                   	ret    

f0110616 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0110616:	55                   	push   %ebp
f0110617:	89 e5                	mov    %esp,%ebp
f0110619:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f011061e:	83 f8 01             	cmp    $0x1,%eax
f0110621:	75 04                	jne    f0110627 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0110623:	b0 01                	mov    $0x1,%al
f0110625:	eb 02                	jmp    f0110629 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0110627:	b0 00                	mov    $0x0,%al
f0110629:	5d                   	pop    %ebp
f011062a:	c3                   	ret    

f011062b <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f011062b:	55                   	push   %ebp
f011062c:	89 e5                	mov    %esp,%ebp
f011062e:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f0110633:	83 f8 02             	cmp    $0x2,%eax
f0110636:	75 04                	jne    f011063c <isKHeapPlacementStrategyBESTFIT+0x11>
f0110638:	b0 01                	mov    $0x1,%al
f011063a:	eb 02                	jmp    f011063e <isKHeapPlacementStrategyBESTFIT+0x13>
f011063c:	b0 00                	mov    $0x0,%al
f011063e:	5d                   	pop    %ebp
f011063f:	c3                   	ret    

f0110640 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0110640:	55                   	push   %ebp
f0110641:	89 e5                	mov    %esp,%ebp
f0110643:	a1 b8 d7 b5 f0       	mov    0xf0b5d7b8,%eax
f0110648:	83 f8 03             	cmp    $0x3,%eax
f011064b:	75 04                	jne    f0110651 <isKHeapPlacementStrategyNEXTFIT+0x11>
f011064d:	b0 01                	mov    $0x1,%al
f011064f:	eb 02                	jmp    f0110653 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0110651:	b0 00                	mov    $0x0,%al
f0110653:	5d                   	pop    %ebp
f0110654:	c3                   	ret    

f0110655 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0110655:	55                   	push   %ebp
f0110656:	89 e5                	mov    %esp,%ebp
f0110658:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f011065b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110662:	eb 26                	jmp    f011068a <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0110664:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110667:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011066e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110671:	01 c2                	add    %eax,%edx
f0110673:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110676:	40                   	inc    %eax
f0110677:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011067e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110681:	01 c8                	add    %ecx,%eax
f0110683:	8b 00                	mov    (%eax),%eax
f0110685:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110687:	ff 45 f4             	incl   -0xc(%ebp)
f011068a:	8b 45 08             	mov    0x8(%ebp),%eax
f011068d:	48                   	dec    %eax
f011068e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110691:	7f d1                	jg     f0110664 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f0110693:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f0110696:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f011069d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01106a4:	eb 35                	jmp    f01106db <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f01106a6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01106a9:	89 d0                	mov    %edx,%eax
f01106ab:	01 c0                	add    %eax,%eax
f01106ad:	01 d0                	add    %edx,%eax
f01106af:	c1 e0 02             	shl    $0x2,%eax
f01106b2:	05 60 0d 18 f0       	add    $0xf0180d60,%eax
f01106b7:	8b 10                	mov    (%eax),%edx
f01106b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106bc:	8b 00                	mov    (%eax),%eax
f01106be:	83 ec 08             	sub    $0x8,%esp
f01106c1:	52                   	push   %edx
f01106c2:	50                   	push   %eax
f01106c3:	e8 60 fa 00 00       	call   f0120128 <strcmp>
f01106c8:	83 c4 10             	add    $0x10,%esp
f01106cb:	85 c0                	test   %eax,%eax
f01106cd:	75 09                	jne    f01106d8 <tst_handler+0x83>
		{
			test_found = 1;
f01106cf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f01106d6:	eb 0f                	jmp    f01106e7 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01106d8:	ff 45 ec             	incl   -0x14(%ebp)
f01106db:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01106de:	a1 14 0e 18 f0       	mov    0xf0180e14,%eax
f01106e3:	39 c2                	cmp    %eax,%edx
f01106e5:	72 bf                	jb     f01106a6 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f01106e7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01106eb:	74 29                	je     f0110716 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f01106ed:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01106f0:	89 d0                	mov    %edx,%eax
f01106f2:	01 c0                	add    %eax,%eax
f01106f4:	01 d0                	add    %edx,%eax
f01106f6:	c1 e0 02             	shl    $0x2,%eax
f01106f9:	05 68 0d 18 f0       	add    $0xf0180d68,%eax
f01106fe:	8b 00                	mov    (%eax),%eax
f0110700:	83 ec 08             	sub    $0x8,%esp
f0110703:	ff 75 0c             	pushl  0xc(%ebp)
f0110706:	ff 75 08             	pushl  0x8(%ebp)
f0110709:	ff d0                	call   *%eax
f011070b:	83 c4 10             	add    $0x10,%esp
f011070e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110711:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110714:	eb 1b                	jmp    f0110731 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f0110716:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110719:	8b 00                	mov    (%eax),%eax
f011071b:	83 ec 08             	sub    $0x8,%esp
f011071e:	50                   	push   %eax
f011071f:	68 90 86 12 f0       	push   $0xf0128690
f0110724:	e8 62 08 ff ff       	call   f0100f8b <cprintf>
f0110729:	83 c4 10             	add    $0x10,%esp
		return 0;
f011072c:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110731:	c9                   	leave  
f0110732:	c3                   	ret    

f0110733 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110733:	55                   	push   %ebp
f0110734:	89 e5                	mov    %esp,%ebp
f0110736:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f0110739:	e8 69 d0 00 00       	call   f011d7a7 <test_three_creation_functions>
	return 0;
f011073e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110743:	c9                   	leave  
f0110744:	c3                   	ret    

f0110745 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f0110745:	55                   	push   %ebp
f0110746:	89 e5                	mov    %esp,%ebp
f0110748:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f011074b:	e8 03 69 00 00       	call   f0117053 <test_priority_normal_and_higher>
	return 0;
f0110750:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110755:	c9                   	leave  
f0110756:	c3                   	ret    

f0110757 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0110757:	55                   	push   %ebp
f0110758:	89 e5                	mov    %esp,%ebp
f011075a:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f011075d:	e8 0b 69 00 00       	call   f011706d <test_priority_normal_and_lower>
	return 0;
f0110762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110767:	c9                   	leave  
f0110768:	c3                   	ret    

f0110769 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f0110769:	55                   	push   %ebp
f011076a:	89 e5                	mov    %esp,%ebp
f011076c:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f011076f:	e8 e6 d1 00 00       	call   f011d95a <test_kfreeall>
	return 0;
f0110774:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110779:	c9                   	leave  
f011077a:	c3                   	ret    

f011077b <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f011077b:	55                   	push   %ebp
f011077c:	89 e5                	mov    %esp,%ebp
f011077e:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0110781:	e8 f1 d1 00 00       	call   f011d977 <test_kexpand>
	return 0;
f0110786:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011078b:	c9                   	leave  
f011078c:	c3                   	ret    

f011078d <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f011078d:	55                   	push   %ebp
f011078e:	89 e5                	mov    %esp,%ebp
f0110790:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f0110793:	e8 fc d1 00 00       	call   f011d994 <test_kshrink>
	return 0;
f0110798:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011079d:	c9                   	leave  
f011079e:	c3                   	ret    

f011079f <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f011079f:	55                   	push   %ebp
f01107a0:	89 e5                	mov    %esp,%ebp
f01107a2:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f01107a5:	e8 07 d2 00 00       	call   f011d9b1 <test_kfreelast>
	return 0;
f01107aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01107af:	c9                   	leave  
f01107b0:	c3                   	ret    

f01107b1 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f01107b1:	55                   	push   %ebp
f01107b2:	89 e5                	mov    %esp,%ebp
f01107b4:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f01107b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107ba:	83 c0 04             	add    $0x4,%eax
f01107bd:	8b 00                	mov    (%eax),%eax
f01107bf:	83 ec 04             	sub    $0x4,%esp
f01107c2:	6a 0a                	push   $0xa
f01107c4:	6a 00                	push   $0x0
f01107c6:	50                   	push   %eax
f01107c7:	e8 b0 fb 00 00       	call   f012037c <strtol>
f01107cc:	83 c4 10             	add    $0x10,%esp
f01107cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f01107d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f01107d9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f01107e0:	83 ec 0c             	sub    $0xc,%esp
f01107e3:	68 20 d2 75 f0       	push   $0xf075d220
f01107e8:	e8 81 f8 ff ff       	call   f011006e <acquire_spinlock>
f01107ed:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f01107f0:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f01107f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01107f8:	eb 3b                	jmp    f0110835 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f01107fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01107fd:	83 c0 20             	add    $0x20,%eax
f0110800:	83 ec 08             	sub    $0x8,%esp
f0110803:	68 a3 86 12 f0       	push   $0xf01286a3
f0110808:	50                   	push   %eax
f0110809:	e8 1a f9 00 00       	call   f0120128 <strcmp>
f011080e:	83 c4 10             	add    $0x10,%esp
f0110811:	85 c0                	test   %eax,%eax
f0110813:	75 12                	jne    f0110827 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f0110815:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110819:	74 07                	je     f0110822 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f011081b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110822:	ff 45 f4             	incl   -0xc(%ebp)
f0110825:	eb 06                	jmp    f011082d <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f0110827:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011082b:	74 31                	je     f011085e <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f011082d:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f0110832:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110835:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110839:	74 08                	je     f0110843 <tst_sc_MLFQ+0x92>
f011083b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011083e:	8b 40 08             	mov    0x8(%eax),%eax
f0110841:	eb 05                	jmp    f0110848 <tst_sc_MLFQ+0x97>
f0110843:	b8 00 00 00 00       	mov    $0x0,%eax
f0110848:	a3 a8 d2 75 f0       	mov    %eax,0xf075d2a8
f011084d:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f0110852:	85 c0                	test   %eax,%eax
f0110854:	75 a4                	jne    f01107fa <tst_sc_MLFQ+0x49>
f0110856:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011085a:	75 9e                	jne    f01107fa <tst_sc_MLFQ+0x49>
f011085c:	eb 01                	jmp    f011085f <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f011085e:	90                   	nop
			}
		if(cnt == numOfSlave2)
f011085f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110862:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0110865:	75 12                	jne    f0110879 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0110867:	83 ec 0c             	sub    $0xc,%esp
f011086a:	68 ac 86 12 f0       	push   $0xf01286ac
f011086f:	e8 17 07 ff ff       	call   f0100f8b <cprintf>
f0110874:	83 c4 10             	add    $0x10,%esp
f0110877:	eb 17                	jmp    f0110890 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f0110879:	83 ec 04             	sub    $0x4,%esp
f011087c:	68 e5 86 12 f0       	push   $0xf01286e5
f0110881:	68 9b 00 00 00       	push   $0x9b
f0110886:	68 fb 86 12 f0       	push   $0xf01286fb
f011088b:	e8 a9 fa fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f0110890:	83 ec 0c             	sub    $0xc,%esp
f0110893:	68 20 d2 75 f0       	push   $0xf075d220
f0110898:	e8 58 f8 ff ff       	call   f01100f5 <release_spinlock>
f011089d:	83 c4 10             	add    $0x10,%esp
	return 0;
f01108a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01108a5:	c9                   	leave  
f01108a6:	c3                   	ret    

f01108a7 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f01108a7:	55                   	push   %ebp
f01108a8:	89 e5                	mov    %esp,%ebp
f01108aa:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f01108ad:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01108b1:	74 17                	je     f01108ca <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f01108b3:	83 ec 0c             	sub    $0xc,%esp
f01108b6:	68 14 87 12 f0       	push   $0xf0128714
f01108bb:	e8 cb 06 ff ff       	call   f0100f8b <cprintf>
f01108c0:	83 c4 10             	add    $0x10,%esp
		return 0;
f01108c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01108c8:	eb 45                	jmp    f011090f <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f01108ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108cd:	83 c0 04             	add    $0x4,%eax
f01108d0:	8b 00                	mov    (%eax),%eax
f01108d2:	83 ec 04             	sub    $0x4,%esp
f01108d5:	6a 0a                	push   $0xa
f01108d7:	6a 00                	push   $0x0
f01108d9:	50                   	push   %eax
f01108da:	e8 9d fa 00 00       	call   f012037c <strtol>
f01108df:	83 c4 10             	add    $0x10,%esp
f01108e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f01108e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01108e8:	83 f8 01             	cmp    $0x1,%eax
f01108eb:	74 10                	je     f01108fd <tst_bsd_nice+0x56>
f01108ed:	83 f8 02             	cmp    $0x2,%eax
f01108f0:	74 12                	je     f0110904 <tst_bsd_nice+0x5d>
f01108f2:	85 c0                	test   %eax,%eax
f01108f4:	75 14                	jne    f011090a <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f01108f6:	e8 b9 d2 00 00       	call   f011dbb4 <test_bsd_nice_0>
		break;
f01108fb:	eb 0d                	jmp    f011090a <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f01108fd:	e8 3c d5 00 00       	call   f011de3e <test_bsd_nice_1>
		break;
f0110902:	eb 06                	jmp    f011090a <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f0110904:	e8 49 d7 00 00       	call   f011e052 <test_bsd_nice_2>
		break;
f0110909:	90                   	nop
	}
	return 0;
f011090a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011090f:	c9                   	leave  
f0110910:	c3                   	ret    

f0110911 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f0110911:	55                   	push   %ebp
f0110912:	89 e5                	mov    %esp,%ebp
f0110914:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f0110917:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011091b:	74 17                	je     f0110934 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f011091d:	83 ec 0c             	sub    $0xc,%esp
f0110920:	68 54 87 12 f0       	push   $0xf0128754
f0110925:	e8 61 06 ff ff       	call   f0100f8b <cprintf>
f011092a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011092d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110932:	eb 0a                	jmp    f011093e <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f0110934:	e8 3f 15 00 00       	call   f0111e78 <test_str2lower_function>
	return 0;
f0110939:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011093e:	c9                   	leave  
f011093f:	c3                   	ret    

f0110940 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f0110940:	55                   	push   %ebp
f0110941:	89 e5                	mov    %esp,%ebp
f0110943:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f0110946:	e8 63 11 00 00       	call   f0111aae <TestAutoCompleteCommand>
f011094b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f011094e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110953:	c9                   	leave  
f0110954:	c3                   	ret    

f0110955 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f0110955:	55                   	push   %ebp
f0110956:	89 e5                	mov    %esp,%ebp
f0110958:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011095b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011095f:	74 1a                	je     f011097b <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f0110961:	83 ec 0c             	sub    $0xc,%esp
f0110964:	68 88 87 12 f0       	push   $0xf0128788
f0110969:	e8 1d 06 ff ff       	call   f0100f8b <cprintf>
f011096e:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110971:	b8 00 00 00 00       	mov    $0x0,%eax
f0110976:	e9 2f 01 00 00       	jmp    f0110aaa <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f011097b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011097e:	83 c0 04             	add    $0x4,%eax
f0110981:	8b 00                	mov    (%eax),%eax
f0110983:	83 ec 08             	sub    $0x8,%esp
f0110986:	68 c5 87 12 f0       	push   $0xf01287c5
f011098b:	50                   	push   %eax
f011098c:	e8 97 f7 00 00       	call   f0120128 <strcmp>
f0110991:	83 c4 10             	add    $0x10,%esp
f0110994:	85 c0                	test   %eax,%eax
f0110996:	75 0a                	jne    f01109a2 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f0110998:	e8 40 08 00 00       	call   f01111dd <test_initialize_dynamic_allocator>
f011099d:	e9 03 01 00 00       	jmp    f0110aa5 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f01109a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109a5:	83 c0 04             	add    $0x4,%eax
f01109a8:	8b 00                	mov    (%eax),%eax
f01109aa:	83 ec 08             	sub    $0x8,%esp
f01109ad:	68 ca 87 12 f0       	push   $0xf01287ca
f01109b2:	50                   	push   %eax
f01109b3:	e8 70 f7 00 00       	call   f0120128 <strcmp>
f01109b8:	83 c4 10             	add    $0x10,%esp
f01109bb:	85 c0                	test   %eax,%eax
f01109bd:	75 0a                	jne    f01109c9 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f01109bf:	e8 4d 08 00 00       	call   f0111211 <test_alloc_block_FF>
f01109c4:	e9 dc 00 00 00       	jmp    f0110aa5 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f01109c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109cc:	83 c0 04             	add    $0x4,%eax
f01109cf:	8b 00                	mov    (%eax),%eax
f01109d1:	83 ec 08             	sub    $0x8,%esp
f01109d4:	68 d2 87 12 f0       	push   $0xf01287d2
f01109d9:	50                   	push   %eax
f01109da:	e8 49 f7 00 00       	call   f0120128 <strcmp>
f01109df:	83 c4 10             	add    $0x10,%esp
f01109e2:	85 c0                	test   %eax,%eax
f01109e4:	75 0a                	jne    f01109f0 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f01109e6:	e8 43 08 00 00       	call   f011122e <test_alloc_block_BF>
f01109eb:	e9 b5 00 00 00       	jmp    f0110aa5 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f01109f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109f3:	83 c0 04             	add    $0x4,%eax
f01109f6:	8b 00                	mov    (%eax),%eax
f01109f8:	83 ec 08             	sub    $0x8,%esp
f01109fb:	68 da 87 12 f0       	push   $0xf01287da
f0110a00:	50                   	push   %eax
f0110a01:	e8 22 f7 00 00       	call   f0120128 <strcmp>
f0110a06:	83 c4 10             	add    $0x10,%esp
f0110a09:	85 c0                	test   %eax,%eax
f0110a0b:	75 0a                	jne    f0110a17 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f0110a0d:	e8 3c 08 00 00       	call   f011124e <test_alloc_block_NF>
f0110a12:	e9 8e 00 00 00       	jmp    f0110aa5 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f0110a17:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a1a:	83 c0 04             	add    $0x4,%eax
f0110a1d:	8b 00                	mov    (%eax),%eax
f0110a1f:	83 ec 08             	sub    $0x8,%esp
f0110a22:	68 e2 87 12 f0       	push   $0xf01287e2
f0110a27:	50                   	push   %eax
f0110a28:	e8 fb f6 00 00       	call   f0120128 <strcmp>
f0110a2d:	83 c4 10             	add    $0x10,%esp
f0110a30:	85 c0                	test   %eax,%eax
f0110a32:	75 07                	jne    f0110a3b <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f0110a34:	e8 1b 08 00 00       	call   f0111254 <test_free_block_FF>
f0110a39:	eb 6a                	jmp    f0110aa5 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f0110a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a3e:	83 c0 04             	add    $0x4,%eax
f0110a41:	8b 00                	mov    (%eax),%eax
f0110a43:	83 ec 08             	sub    $0x8,%esp
f0110a46:	68 e9 87 12 f0       	push   $0xf01287e9
f0110a4b:	50                   	push   %eax
f0110a4c:	e8 d7 f6 00 00       	call   f0120128 <strcmp>
f0110a51:	83 c4 10             	add    $0x10,%esp
f0110a54:	85 c0                	test   %eax,%eax
f0110a56:	75 07                	jne    f0110a5f <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f0110a58:	e8 14 08 00 00       	call   f0111271 <test_free_block_BF>
f0110a5d:	eb 46                	jmp    f0110aa5 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f0110a5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a62:	83 c0 04             	add    $0x4,%eax
f0110a65:	8b 00                	mov    (%eax),%eax
f0110a67:	83 ec 08             	sub    $0x8,%esp
f0110a6a:	68 f0 87 12 f0       	push   $0xf01287f0
f0110a6f:	50                   	push   %eax
f0110a70:	e8 b3 f6 00 00       	call   f0120128 <strcmp>
f0110a75:	83 c4 10             	add    $0x10,%esp
f0110a78:	85 c0                	test   %eax,%eax
f0110a7a:	75 07                	jne    f0110a83 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f0110a7c:	e8 0d 08 00 00       	call   f011128e <test_free_block_NF>
f0110a81:	eb 22                	jmp    f0110aa5 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f0110a83:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a86:	83 c0 04             	add    $0x4,%eax
f0110a89:	8b 00                	mov    (%eax),%eax
f0110a8b:	83 ec 08             	sub    $0x8,%esp
f0110a8e:	68 f7 87 12 f0       	push   $0xf01287f7
f0110a93:	50                   	push   %eax
f0110a94:	e8 8f f6 00 00       	call   f0120128 <strcmp>
f0110a99:	83 c4 10             	add    $0x10,%esp
f0110a9c:	85 c0                	test   %eax,%eax
f0110a9e:	75 05                	jne    f0110aa5 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f0110aa0:	e8 06 08 00 00       	call   f01112ab <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f0110aa5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110aaa:	c9                   	leave  
f0110aab:	c3                   	ret    

f0110aac <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f0110aac:	55                   	push   %ebp
f0110aad:	89 e5                	mov    %esp,%ebp
f0110aaf:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110ab2:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110ab6:	74 1a                	je     f0110ad2 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f0110ab8:	83 ec 0c             	sub    $0xc,%esp
f0110abb:	68 04 88 12 f0       	push   $0xf0128804
f0110ac0:	e8 c6 04 ff ff       	call   f0100f8b <cprintf>
f0110ac5:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110ac8:	b8 00 00 00 00       	mov    $0x0,%eax
f0110acd:	e9 e1 00 00 00       	jmp    f0110bb3 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f0110ad2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ad5:	83 c0 04             	add    $0x4,%eax
f0110ad8:	8b 00                	mov    (%eax),%eax
f0110ada:	83 ec 08             	sub    $0x8,%esp
f0110add:	68 3d 88 12 f0       	push   $0xf012883d
f0110ae2:	50                   	push   %eax
f0110ae3:	e8 40 f6 00 00       	call   f0120128 <strcmp>
f0110ae8:	83 c4 10             	add    $0x10,%esp
f0110aeb:	85 c0                	test   %eax,%eax
f0110aed:	75 0a                	jne    f0110af9 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f0110aef:	e8 97 1c 00 00       	call   f011278b <test_cut_paste_pages>
f0110af4:	e9 b5 00 00 00       	jmp    f0110bae <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f0110af9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110afc:	83 c0 04             	add    $0x4,%eax
f0110aff:	8b 00                	mov    (%eax),%eax
f0110b01:	83 ec 08             	sub    $0x8,%esp
f0110b04:	68 46 88 12 f0       	push   $0xf0128846
f0110b09:	50                   	push   %eax
f0110b0a:	e8 19 f6 00 00       	call   f0120128 <strcmp>
f0110b0f:	83 c4 10             	add    $0x10,%esp
f0110b12:	85 c0                	test   %eax,%eax
f0110b14:	75 0a                	jne    f0110b20 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f0110b16:	e8 bb 26 00 00       	call   f01131d6 <test_copy_paste_chunk>
f0110b1b:	e9 8e 00 00 00       	jmp    f0110bae <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f0110b20:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b23:	83 c0 04             	add    $0x4,%eax
f0110b26:	8b 00                	mov    (%eax),%eax
f0110b28:	83 ec 08             	sub    $0x8,%esp
f0110b2b:	68 50 88 12 f0       	push   $0xf0128850
f0110b30:	50                   	push   %eax
f0110b31:	e8 f2 f5 00 00       	call   f0120128 <strcmp>
f0110b36:	83 c4 10             	add    $0x10,%esp
f0110b39:	85 c0                	test   %eax,%eax
f0110b3b:	75 07                	jne    f0110b44 <tst_chunks+0x98>
	{
		test_share_chunk();
f0110b3d:	e8 92 37 00 00       	call   f01142d4 <test_share_chunk>
f0110b42:	eb 6a                	jmp    f0110bae <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f0110b44:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b47:	83 c0 04             	add    $0x4,%eax
f0110b4a:	8b 00                	mov    (%eax),%eax
f0110b4c:	83 ec 08             	sub    $0x8,%esp
f0110b4f:	68 56 88 12 f0       	push   $0xf0128856
f0110b54:	50                   	push   %eax
f0110b55:	e8 ce f5 00 00       	call   f0120128 <strcmp>
f0110b5a:	83 c4 10             	add    $0x10,%esp
f0110b5d:	85 c0                	test   %eax,%eax
f0110b5f:	75 07                	jne    f0110b68 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110b61:	e8 96 41 00 00       	call   f0114cfc <test_allocate_chunk>
f0110b66:	eb 46                	jmp    f0110bae <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b6b:	83 c0 04             	add    $0x4,%eax
f0110b6e:	8b 00                	mov    (%eax),%eax
f0110b70:	83 ec 08             	sub    $0x8,%esp
f0110b73:	68 5f 88 12 f0       	push   $0xf012885f
f0110b78:	50                   	push   %eax
f0110b79:	e8 aa f5 00 00       	call   f0120128 <strcmp>
f0110b7e:	83 c4 10             	add    $0x10,%esp
f0110b81:	85 c0                	test   %eax,%eax
f0110b83:	75 07                	jne    f0110b8c <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110b85:	e8 79 4a 00 00       	call   f0115603 <test_calculate_required_frames>
f0110b8a:	eb 22                	jmp    f0110bae <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110b8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b8f:	83 c0 04             	add    $0x4,%eax
f0110b92:	8b 00                	mov    (%eax),%eax
f0110b94:	83 ec 08             	sub    $0x8,%esp
f0110b97:	68 6e 88 12 f0       	push   $0xf012886e
f0110b9c:	50                   	push   %eax
f0110b9d:	e8 86 f5 00 00       	call   f0120128 <strcmp>
f0110ba2:	83 c4 10             	add    $0x10,%esp
f0110ba5:	85 c0                	test   %eax,%eax
f0110ba7:	75 05                	jne    f0110bae <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110ba9:	e8 c9 52 00 00       	call   f0115e77 <test_calculate_allocated_space>
	}
	return 0;
f0110bae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110bb3:	c9                   	leave  
f0110bb4:	c3                   	ret    

f0110bb5 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0110bb5:	55                   	push   %ebp
f0110bb6:	89 e5                	mov    %esp,%ebp
f0110bb8:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110bbb:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110bbf:	74 1a                	je     f0110bdb <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f0110bc1:	83 ec 0c             	sub    $0xc,%esp
f0110bc4:	68 80 88 12 f0       	push   $0xf0128880
f0110bc9:	e8 bd 03 ff ff       	call   f0100f8b <cprintf>
f0110bce:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110bd1:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bd6:	e9 ba 00 00 00       	jmp    f0110c95 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110bdb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bde:	83 c0 04             	add    $0x4,%eax
f0110be1:	8b 00                	mov    (%eax),%eax
f0110be3:	83 ec 08             	sub    $0x8,%esp
f0110be6:	68 b6 88 12 f0       	push   $0xf01288b6
f0110beb:	50                   	push   %eax
f0110bec:	e8 37 f5 00 00       	call   f0120128 <strcmp>
f0110bf1:	83 c4 10             	add    $0x10,%esp
f0110bf4:	85 c0                	test   %eax,%eax
f0110bf6:	75 0a                	jne    f0110c02 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f0110bf8:	e8 01 16 00 00       	call   f01121fe <test_pt_set_page_permissions>
f0110bfd:	e9 8e 00 00 00       	jmp    f0110c90 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f0110c02:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c05:	83 c0 04             	add    $0x4,%eax
f0110c08:	8b 00                	mov    (%eax),%eax
f0110c0a:	83 ec 08             	sub    $0x8,%esp
f0110c0d:	68 be 88 12 f0       	push   $0xf01288be
f0110c12:	50                   	push   %eax
f0110c13:	e8 10 f5 00 00       	call   f0120128 <strcmp>
f0110c18:	83 c4 10             	add    $0x10,%esp
f0110c1b:	85 c0                	test   %eax,%eax
f0110c1d:	75 07                	jne    f0110c26 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f0110c1f:	e8 49 18 00 00       	call   f011246d <test_pt_set_page_permissions_invalid_va>
f0110c24:	eb 6a                	jmp    f0110c90 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f0110c26:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c29:	83 c0 04             	add    $0x4,%eax
f0110c2c:	8b 00                	mov    (%eax),%eax
f0110c2e:	83 ec 08             	sub    $0x8,%esp
f0110c31:	68 c6 88 12 f0       	push   $0xf01288c6
f0110c36:	50                   	push   %eax
f0110c37:	e8 ec f4 00 00       	call   f0120128 <strcmp>
f0110c3c:	83 c4 10             	add    $0x10,%esp
f0110c3f:	85 c0                	test   %eax,%eax
f0110c41:	75 07                	jne    f0110c4a <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f0110c43:	e8 6e 18 00 00       	call   f01124b6 <test_pt_get_page_permissions>
f0110c48:	eb 46                	jmp    f0110c90 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f0110c4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c4d:	83 c0 04             	add    $0x4,%eax
f0110c50:	8b 00                	mov    (%eax),%eax
f0110c52:	83 ec 08             	sub    $0x8,%esp
f0110c55:	68 ce 88 12 f0       	push   $0xf01288ce
f0110c5a:	50                   	push   %eax
f0110c5b:	e8 c8 f4 00 00       	call   f0120128 <strcmp>
f0110c60:	83 c4 10             	add    $0x10,%esp
f0110c63:	85 c0                	test   %eax,%eax
f0110c65:	75 07                	jne    f0110c6e <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f0110c67:	e8 8e 19 00 00       	call   f01125fa <test_pt_clear_page_table_entry>
f0110c6c:	eb 22                	jmp    f0110c90 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110c6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c71:	83 c0 04             	add    $0x4,%eax
f0110c74:	8b 00                	mov    (%eax),%eax
f0110c76:	83 ec 08             	sub    $0x8,%esp
f0110c79:	68 d5 88 12 f0       	push   $0xf01288d5
f0110c7e:	50                   	push   %eax
f0110c7f:	e8 a4 f4 00 00       	call   f0120128 <strcmp>
f0110c84:	83 c4 10             	add    $0x10,%esp
f0110c87:	85 c0                	test   %eax,%eax
f0110c89:	75 05                	jne    f0110c90 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110c8b:	e8 c3 1a 00 00       	call   f0112753 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f0110c90:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110c95:	c9                   	leave  
f0110c96:	c3                   	ret    

f0110c97 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f0110c97:	55                   	push   %ebp
f0110c98:	89 e5                	mov    %esp,%ebp
f0110c9a:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110c9d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ca0:	83 c0 08             	add    $0x8,%eax
f0110ca3:	8b 00                	mov    (%eax),%eax
f0110ca5:	83 ec 08             	sub    $0x8,%esp
f0110ca8:	68 dc 88 12 f0       	push   $0xf01288dc
f0110cad:	50                   	push   %eax
f0110cae:	e8 75 f4 00 00       	call   f0120128 <strcmp>
f0110cb3:	83 c4 10             	add    $0x10,%esp
f0110cb6:	85 c0                	test   %eax,%eax
f0110cb8:	75 20                	jne    f0110cda <tst_kheap+0x43>
f0110cba:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110cbe:	74 1a                	je     f0110cda <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f0110cc0:	83 ec 0c             	sub    $0xc,%esp
f0110cc3:	68 e4 88 12 f0       	push   $0xf01288e4
f0110cc8:	e8 be 02 ff ff       	call   f0100f8b <cprintf>
f0110ccd:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110cd0:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cd5:	e9 42 04 00 00       	jmp    f011111c <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110cda:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cdd:	83 c0 08             	add    $0x8,%eax
f0110ce0:	8b 00                	mov    (%eax),%eax
f0110ce2:	83 ec 08             	sub    $0x8,%esp
f0110ce5:	68 dc 88 12 f0       	push   $0xf01288dc
f0110cea:	50                   	push   %eax
f0110ceb:	e8 38 f4 00 00       	call   f0120128 <strcmp>
f0110cf0:	83 c4 10             	add    $0x10,%esp
f0110cf3:	85 c0                	test   %eax,%eax
f0110cf5:	74 43                	je     f0110d3a <tst_kheap+0xa3>
f0110cf7:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0110cfb:	74 3d                	je     f0110d3a <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f0110cfd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d00:	83 c0 08             	add    $0x8,%eax
f0110d03:	8b 00                	mov    (%eax),%eax
f0110d05:	83 ec 08             	sub    $0x8,%esp
f0110d08:	68 34 89 12 f0       	push   $0xf0128934
f0110d0d:	50                   	push   %eax
f0110d0e:	e8 15 f4 00 00       	call   f0120128 <strcmp>
f0110d13:	83 c4 10             	add    $0x10,%esp
f0110d16:	85 c0                	test   %eax,%eax
f0110d18:	74 20                	je     f0110d3a <tst_kheap+0xa3>
f0110d1a:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f0110d1e:	74 1a                	je     f0110d3a <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f0110d20:	83 ec 0c             	sub    $0xc,%esp
f0110d23:	68 40 89 12 f0       	push   $0xf0128940
f0110d28:	e8 5e 02 ff ff       	call   f0100f8b <cprintf>
f0110d2d:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110d30:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d35:	e9 e2 03 00 00       	jmp    f011111c <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f0110d3a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d3d:	83 c0 04             	add    $0x4,%eax
f0110d40:	8b 00                	mov    (%eax),%eax
f0110d42:	83 ec 08             	sub    $0x8,%esp
f0110d45:	68 85 89 12 f0       	push   $0xf0128985
f0110d4a:	50                   	push   %eax
f0110d4b:	e8 d8 f3 00 00       	call   f0120128 <strcmp>
f0110d50:	83 c4 10             	add    $0x10,%esp
f0110d53:	85 c0                	test   %eax,%eax
f0110d55:	74 1d                	je     f0110d74 <tst_kheap+0xdd>
f0110d57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d5a:	83 c0 04             	add    $0x4,%eax
f0110d5d:	8b 00                	mov    (%eax),%eax
f0110d5f:	83 ec 08             	sub    $0x8,%esp
f0110d62:	68 88 89 12 f0       	push   $0xf0128988
f0110d67:	50                   	push   %eax
f0110d68:	e8 bb f3 00 00       	call   f0120128 <strcmp>
f0110d6d:	83 c4 10             	add    $0x10,%esp
f0110d70:	85 c0                	test   %eax,%eax
f0110d72:	75 1a                	jne    f0110d8e <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f0110d74:	e8 6d f8 ff ff       	call   f01105e6 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110d79:	83 ec 0c             	sub    $0xc,%esp
f0110d7c:	68 8c 89 12 f0       	push   $0xf012898c
f0110d81:	e8 05 02 ff ff       	call   f0100f8b <cprintf>
f0110d86:	83 c4 10             	add    $0x10,%esp
f0110d89:	e9 a0 00 00 00       	jmp    f0110e2e <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110d8e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d91:	83 c0 04             	add    $0x4,%eax
f0110d94:	8b 00                	mov    (%eax),%eax
f0110d96:	83 ec 08             	sub    $0x8,%esp
f0110d99:	68 b9 89 12 f0       	push   $0xf01289b9
f0110d9e:	50                   	push   %eax
f0110d9f:	e8 84 f3 00 00       	call   f0120128 <strcmp>
f0110da4:	83 c4 10             	add    $0x10,%esp
f0110da7:	85 c0                	test   %eax,%eax
f0110da9:	74 1d                	je     f0110dc8 <tst_kheap+0x131>
f0110dab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110dae:	83 c0 04             	add    $0x4,%eax
f0110db1:	8b 00                	mov    (%eax),%eax
f0110db3:	83 ec 08             	sub    $0x8,%esp
f0110db6:	68 bc 89 12 f0       	push   $0xf01289bc
f0110dbb:	50                   	push   %eax
f0110dbc:	e8 67 f3 00 00       	call   f0120128 <strcmp>
f0110dc1:	83 c4 10             	add    $0x10,%esp
f0110dc4:	85 c0                	test   %eax,%eax
f0110dc6:	75 17                	jne    f0110ddf <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110dc8:	e8 29 f8 ff ff       	call   f01105f6 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110dcd:	83 ec 0c             	sub    $0xc,%esp
f0110dd0:	68 c0 89 12 f0       	push   $0xf01289c0
f0110dd5:	e8 b1 01 ff ff       	call   f0100f8b <cprintf>
f0110dda:	83 c4 10             	add    $0x10,%esp
f0110ddd:	eb 4f                	jmp    f0110e2e <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110ddf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110de2:	83 c0 04             	add    $0x4,%eax
f0110de5:	8b 00                	mov    (%eax),%eax
f0110de7:	83 ec 08             	sub    $0x8,%esp
f0110dea:	68 ec 89 12 f0       	push   $0xf01289ec
f0110def:	50                   	push   %eax
f0110df0:	e8 33 f3 00 00       	call   f0120128 <strcmp>
f0110df5:	83 c4 10             	add    $0x10,%esp
f0110df8:	85 c0                	test   %eax,%eax
f0110dfa:	74 1d                	je     f0110e19 <tst_kheap+0x182>
f0110dfc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110dff:	83 c0 04             	add    $0x4,%eax
f0110e02:	8b 00                	mov    (%eax),%eax
f0110e04:	83 ec 08             	sub    $0x8,%esp
f0110e07:	68 ef 89 12 f0       	push   $0xf01289ef
f0110e0c:	50                   	push   %eax
f0110e0d:	e8 16 f3 00 00       	call   f0120128 <strcmp>
f0110e12:	83 c4 10             	add    $0x10,%esp
f0110e15:	85 c0                	test   %eax,%eax
f0110e17:	75 15                	jne    f0110e2e <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f0110e19:	e8 e8 f7 ff ff       	call   f0110606 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110e1e:	83 ec 0c             	sub    $0xc,%esp
f0110e21:	68 f4 89 12 f0       	push   $0xf01289f4
f0110e26:	e8 60 01 ff ff       	call   f0100f8b <cprintf>
f0110e2b:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e31:	83 c0 08             	add    $0x8,%eax
f0110e34:	8b 00                	mov    (%eax),%eax
f0110e36:	83 ec 08             	sub    $0x8,%esp
f0110e39:	68 dc 88 12 f0       	push   $0xf01288dc
f0110e3e:	50                   	push   %eax
f0110e3f:	e8 e4 f2 00 00       	call   f0120128 <strcmp>
f0110e44:	83 c4 10             	add    $0x10,%esp
f0110e47:	85 c0                	test   %eax,%eax
f0110e49:	0f 85 13 01 00 00    	jne    f0110f62 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110e4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e52:	83 c0 0c             	add    $0xc,%eax
f0110e55:	8b 00                	mov    (%eax),%eax
f0110e57:	83 ec 04             	sub    $0x4,%esp
f0110e5a:	6a 0a                	push   $0xa
f0110e5c:	6a 00                	push   $0x0
f0110e5e:	50                   	push   %eax
f0110e5f:	e8 18 f5 00 00       	call   f012037c <strtol>
f0110e64:	83 c4 10             	add    $0x10,%esp
f0110e67:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110e6a:	e8 a7 f7 ff ff       	call   f0110616 <isKHeapPlacementStrategyFIRSTFIT>
f0110e6f:	84 c0                	test   %al,%al
f0110e71:	74 54                	je     f0110ec7 <tst_kheap+0x230>
		{
			if (testNum == 0)
f0110e73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110e77:	75 1a                	jne    f0110e93 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110e79:	83 ec 0c             	sub    $0xc,%esp
f0110e7c:	68 20 8a 12 f0       	push   $0xf0128a20
f0110e81:	e8 05 01 ff ff       	call   f0100f8b <cprintf>
f0110e86:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110e89:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e8e:	e9 89 02 00 00       	jmp    f011111c <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f0110e93:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110e97:	75 0a                	jne    f0110ea3 <tst_kheap+0x20c>
				test_kmalloc();
f0110e99:	e8 ec 61 00 00       	call   f011708a <test_kmalloc>
f0110e9e:	e9 b5 00 00 00       	jmp    f0110f58 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110ea3:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110ea7:	75 0a                	jne    f0110eb3 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110ea9:	e8 68 6d 00 00       	call   f0117c16 <test_kmalloc_firstfit1>
f0110eae:	e9 a5 00 00 00       	jmp    f0110f58 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110eb3:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110eb7:	0f 85 9b 00 00 00    	jne    f0110f58 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110ebd:	e8 38 78 00 00       	call   f01186fa <test_kmalloc_firstfit2>
f0110ec2:	e9 91 00 00 00       	jmp    f0110f58 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110ec7:	e8 5f f7 ff ff       	call   f011062b <isKHeapPlacementStrategyBESTFIT>
f0110ecc:	84 c0                	test   %al,%al
f0110ece:	74 47                	je     f0110f17 <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110ed0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110ed4:	75 1a                	jne    f0110ef0 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110ed6:	83 ec 0c             	sub    $0xc,%esp
f0110ed9:	68 70 8a 12 f0       	push   $0xf0128a70
f0110ede:	e8 a8 00 ff ff       	call   f0100f8b <cprintf>
f0110ee3:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110ee6:	b8 00 00 00 00       	mov    $0x0,%eax
f0110eeb:	e9 2c 02 00 00       	jmp    f011111c <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110ef0:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110ef4:	75 07                	jne    f0110efd <tst_kheap+0x266>
				test_kmalloc();
f0110ef6:	e8 8f 61 00 00       	call   f011708a <test_kmalloc>
f0110efb:	eb 5b                	jmp    f0110f58 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110efd:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110f01:	75 07                	jne    f0110f0a <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f0110f03:	e8 2b c8 00 00       	call   f011d733 <test_kmalloc_bestfit1>
f0110f08:	eb 4e                	jmp    f0110f58 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110f0a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110f0e:	75 48                	jne    f0110f58 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0110f10:	e8 3b c8 00 00       	call   f011d750 <test_kmalloc_bestfit2>
f0110f15:	eb 41                	jmp    f0110f58 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f0110f17:	e8 24 f7 ff ff       	call   f0110640 <isKHeapPlacementStrategyNEXTFIT>
f0110f1c:	84 c0                	test   %al,%al
f0110f1e:	74 38                	je     f0110f58 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f0110f20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110f24:	75 1a                	jne    f0110f40 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f0110f26:	83 ec 0c             	sub    $0xc,%esp
f0110f29:	68 c0 8a 12 f0       	push   $0xf0128ac0
f0110f2e:	e8 58 00 ff ff       	call   f0100f8b <cprintf>
f0110f33:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f3b:	e9 dc 01 00 00       	jmp    f011111c <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110f40:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110f44:	75 07                	jne    f0110f4d <tst_kheap+0x2b6>
				test_kmalloc();
f0110f46:	e8 3f 61 00 00       	call   f011708a <test_kmalloc>
f0110f4b:	eb 0b                	jmp    f0110f58 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110f4d:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110f51:	75 05                	jne    f0110f58 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f0110f53:	e8 be c7 00 00       	call   f011d716 <test_kmalloc_nextfit>
		}
		return 0;
f0110f58:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f5d:	e9 ba 01 00 00       	jmp    f011111c <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110f62:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f65:	83 c0 08             	add    $0x8,%eax
f0110f68:	8b 00                	mov    (%eax),%eax
f0110f6a:	83 ec 08             	sub    $0x8,%esp
f0110f6d:	68 0e 8b 12 f0       	push   $0xf0128b0e
f0110f72:	50                   	push   %eax
f0110f73:	e8 b0 f1 00 00       	call   f0120128 <strcmp>
f0110f78:	83 c4 10             	add    $0x10,%esp
f0110f7b:	85 c0                	test   %eax,%eax
f0110f7d:	75 2f                	jne    f0110fae <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110f7f:	e8 92 f6 ff ff       	call   f0110616 <isKHeapPlacementStrategyFIRSTFIT>
f0110f84:	84 c0                	test   %al,%al
f0110f86:	74 0f                	je     f0110f97 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110f88:	e8 74 82 00 00       	call   f0119201 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110f8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f92:	e9 85 01 00 00       	jmp    f011111c <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110f97:	83 ec 04             	sub    $0x4,%esp
f0110f9a:	68 14 8b 12 f0       	push   $0xf0128b14
f0110f9f:	68 ac 01 00 00       	push   $0x1ac
f0110fa4:	68 fb 86 12 f0       	push   $0xf01286fb
f0110fa9:	e8 8b f3 fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110fae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110fb1:	83 c0 08             	add    $0x8,%eax
f0110fb4:	8b 00                	mov    (%eax),%eax
f0110fb6:	83 ec 08             	sub    $0x8,%esp
f0110fb9:	68 55 8b 12 f0       	push   $0xf0128b55
f0110fbe:	50                   	push   %eax
f0110fbf:	e8 64 f1 00 00       	call   f0120128 <strcmp>
f0110fc4:	83 c4 10             	add    $0x10,%esp
f0110fc7:	85 c0                	test   %eax,%eax
f0110fc9:	75 28                	jne    f0110ff3 <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110fcb:	e8 5b f6 ff ff       	call   f011062b <isKHeapPlacementStrategyBESTFIT>
f0110fd0:	84 c0                	test   %al,%al
f0110fd2:	75 09                	jne    f0110fdd <tst_kheap+0x346>
f0110fd4:	e8 3d f6 ff ff       	call   f0110616 <isKHeapPlacementStrategyFIRSTFIT>
f0110fd9:	84 c0                	test   %al,%al
f0110fdb:	74 07                	je     f0110fe4 <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110fdd:	e8 ee 8a 00 00       	call   f0119ad0 <test_kfree_bestfirstfit>
f0110fe2:	eb 05                	jmp    f0110fe9 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f0110fe4:	e8 a1 c7 00 00       	call   f011d78a <test_kfree>
		}
		return 0;
f0110fe9:	b8 00 00 00 00       	mov    $0x0,%eax
f0110fee:	e9 29 01 00 00       	jmp    f011111c <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110ff3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ff6:	83 c0 08             	add    $0x8,%eax
f0110ff9:	8b 00                	mov    (%eax),%eax
f0110ffb:	83 ec 08             	sub    $0x8,%esp
f0110ffe:	68 5b 8b 12 f0       	push   $0xf0128b5b
f0111003:	50                   	push   %eax
f0111004:	e8 1f f1 00 00       	call   f0120128 <strcmp>
f0111009:	83 c4 10             	add    $0x10,%esp
f011100c:	85 c0                	test   %eax,%eax
f011100e:	75 0f                	jne    f011101f <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0111010:	e8 17 a1 00 00       	call   f011b12c <test_kheap_phys_addr>
		return 0;
f0111015:	b8 00 00 00 00       	mov    $0x0,%eax
f011101a:	e9 fd 00 00 00       	jmp    f011111c <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f011101f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111022:	83 c0 08             	add    $0x8,%eax
f0111025:	8b 00                	mov    (%eax),%eax
f0111027:	83 ec 08             	sub    $0x8,%esp
f011102a:	68 65 8b 12 f0       	push   $0xf0128b65
f011102f:	50                   	push   %eax
f0111030:	e8 f3 f0 00 00       	call   f0120128 <strcmp>
f0111035:	83 c4 10             	add    $0x10,%esp
f0111038:	85 c0                	test   %eax,%eax
f011103a:	75 0f                	jne    f011104b <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f011103c:	e8 ce ae 00 00       	call   f011bf0f <test_kheap_virt_addr>
		return 0;
f0111041:	b8 00 00 00 00       	mov    $0x0,%eax
f0111046:	e9 d1 00 00 00       	jmp    f011111c <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f011104b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011104e:	83 c0 08             	add    $0x8,%eax
f0111051:	8b 00                	mov    (%eax),%eax
f0111053:	83 ec 08             	sub    $0x8,%esp
f0111056:	68 34 89 12 f0       	push   $0xf0128934
f011105b:	50                   	push   %eax
f011105c:	e8 c7 f0 00 00       	call   f0120128 <strcmp>
f0111061:	83 c4 10             	add    $0x10,%esp
f0111064:	85 c0                	test   %eax,%eax
f0111066:	0f 85 89 00 00 00    	jne    f01110f5 <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f011106c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011106f:	83 c0 0c             	add    $0xc,%eax
f0111072:	8b 00                	mov    (%eax),%eax
f0111074:	83 ec 04             	sub    $0x4,%esp
f0111077:	6a 0a                	push   $0xa
f0111079:	6a 00                	push   $0x0
f011107b:	50                   	push   %eax
f011107c:	e8 fb f2 00 00       	call   f012037c <strtol>
f0111081:	83 c4 10             	add    $0x10,%esp
f0111084:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0111087:	e8 8a f5 ff ff       	call   f0110616 <isKHeapPlacementStrategyFIRSTFIT>
f011108c:	84 c0                	test   %al,%al
f011108e:	74 42                	je     f01110d2 <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0111090:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111094:	75 17                	jne    f01110ad <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0111096:	83 ec 0c             	sub    $0xc,%esp
f0111099:	68 20 8a 12 f0       	push   $0xf0128a20
f011109e:	e8 e8 fe fe ff       	call   f0100f8b <cprintf>
f01110a3:	83 c4 10             	add    $0x10,%esp
				return 0;
f01110a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01110ab:	eb 6f                	jmp    f011111c <tst_kheap+0x485>
			}
			if (testNum==1)
f01110ad:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01110b1:	75 07                	jne    f01110ba <tst_kheap+0x423>
				test_krealloc_FF1();
f01110b3:	e8 50 c9 00 00       	call   f011da08 <test_krealloc_FF1>
f01110b8:	eb 18                	jmp    f01110d2 <tst_kheap+0x43b>
			else if (testNum==2)
f01110ba:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f01110be:	75 07                	jne    f01110c7 <tst_kheap+0x430>
				test_krealloc_FF2();
f01110c0:	e8 60 c9 00 00       	call   f011da25 <test_krealloc_FF2>
f01110c5:	eb 0b                	jmp    f01110d2 <tst_kheap+0x43b>
			else if (testNum==3)
f01110c7:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01110cb:	75 05                	jne    f01110d2 <tst_kheap+0x43b>
				test_krealloc_FF3();
f01110cd:	e8 70 c9 00 00       	call   f011da42 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f01110d2:	e8 69 f5 ff ff       	call   f0110640 <isKHeapPlacementStrategyNEXTFIT>
f01110d7:	84 c0                	test   %al,%al
f01110d9:	74 05                	je     f01110e0 <tst_kheap+0x449>
		{
			test_krealloc();
f01110db:	e8 ee c8 00 00       	call   f011d9ce <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f01110e0:	e8 46 f5 ff ff       	call   f011062b <isKHeapPlacementStrategyBESTFIT>
f01110e5:	84 c0                	test   %al,%al
f01110e7:	74 05                	je     f01110ee <tst_kheap+0x457>
		{
			test_krealloc_BF();
f01110e9:	e8 fd c8 00 00       	call   f011d9eb <test_krealloc_BF>
		}
		return 0;
f01110ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01110f3:	eb 27                	jmp    f011111c <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f01110f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01110f8:	83 c0 08             	add    $0x8,%eax
f01110fb:	8b 00                	mov    (%eax),%eax
f01110fd:	83 ec 08             	sub    $0x8,%esp
f0111100:	68 6f 8b 12 f0       	push   $0xf0128b6f
f0111105:	50                   	push   %eax
f0111106:	e8 1d f0 00 00       	call   f0120128 <strcmp>
f011110b:	83 c4 10             	add    $0x10,%esp
f011110e:	85 c0                	test   %eax,%eax
f0111110:	75 05                	jne    f0111117 <tst_kheap+0x480>
	{
		test_ksbrk();
f0111112:	e8 1d bb 00 00       	call   f011cc34 <test_ksbrk>
	}
	return 0;
f0111117:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011111c:	c9                   	leave  
f011111d:	c3                   	ret    

f011111e <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f011111e:	55                   	push   %ebp
f011111f:	89 e5                	mov    %esp,%ebp
f0111121:	83 ec 28             	sub    $0x28,%esp
f0111124:	8b 45 14             	mov    0x14(%ebp),%eax
f0111127:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f011112a:	8b 45 08             	mov    0x8(%ebp),%eax
f011112d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111130:	74 1d                	je     f011114f <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0111132:	83 ec 04             	sub    $0x4,%esp
f0111135:	ff 75 08             	pushl  0x8(%ebp)
f0111138:	ff 75 0c             	pushl  0xc(%ebp)
f011113b:	68 74 8b 12 f0       	push   $0xf0128b74
f0111140:	e8 46 fe fe ff       	call   f0100f8b <cprintf>
f0111145:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111148:	b8 00 00 00 00       	mov    $0x0,%eax
f011114d:	eb 55                	jmp    f01111a4 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f011114f:	8b 45 08             	mov    0x8(%ebp),%eax
f0111152:	8b 40 fc             	mov    -0x4(%eax),%eax
f0111155:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0111158:	8b 45 10             	mov    0x10(%ebp),%eax
f011115b:	8d 50 f8             	lea    -0x8(%eax),%edx
f011115e:	8b 45 08             	mov    0x8(%ebp),%eax
f0111161:	01 d0                	add    %edx,%eax
f0111163:	8b 00                	mov    (%eax),%eax
f0111165:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0111168:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f011116c:	0b 45 10             	or     0x10(%ebp),%eax
f011116f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f0111172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111175:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111178:	75 08                	jne    f0111182 <check_block+0x64>
f011117a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011117d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111180:	74 1d                	je     f011119f <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f0111182:	ff 75 f0             	pushl  -0x10(%ebp)
f0111185:	ff 75 f4             	pushl  -0xc(%ebp)
f0111188:	ff 75 ec             	pushl  -0x14(%ebp)
f011118b:	68 a4 8b 12 f0       	push   $0xf0128ba4
f0111190:	e8 f6 fd fe ff       	call   f0100f8b <cprintf>
f0111195:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111198:	b8 00 00 00 00       	mov    $0x0,%eax
f011119d:	eb 05                	jmp    f01111a4 <check_block+0x86>
	}
	return 1;
f011119f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01111a4:	c9                   	leave  
f01111a5:	c3                   	ret    

f01111a6 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f01111a6:	55                   	push   %ebp
f01111a7:	89 e5                	mov    %esp,%ebp
f01111a9:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f01111ac:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01111b1:	3b 45 08             	cmp    0x8(%ebp),%eax
f01111b4:	74 20                	je     f01111d6 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f01111b6:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01111bb:	83 ec 04             	sub    $0x4,%esp
f01111be:	50                   	push   %eax
f01111bf:	ff 75 08             	pushl  0x8(%ebp)
f01111c2:	68 e0 8b 12 f0       	push   $0xf0128be0
f01111c7:	e8 bf fd fe ff       	call   f0100f8b <cprintf>
f01111cc:	83 c4 10             	add    $0x10,%esp
		return 0;
f01111cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01111d4:	eb 05                	jmp    f01111db <check_list_size+0x35>
	}
	return 1;
f01111d6:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01111db:	c9                   	leave  
f01111dc:	c3                   	ret    

f01111dd <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f01111dd:	55                   	push   %ebp
f01111de:	89 e5                	mov    %esp,%ebp
f01111e0:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f01111e3:	83 ec 04             	sub    $0x4,%esp
f01111e6:	68 14 8c 12 f0       	push   $0xf0128c14
f01111eb:	6a 3f                	push   $0x3f
f01111ed:	68 74 8c 12 f0       	push   $0xf0128c74
f01111f2:	e8 42 f1 fe ff       	call   f0100339 <_panic>

f01111f7 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f01111f7:	55                   	push   %ebp
f01111f8:	89 e5                	mov    %esp,%ebp
f01111fa:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01111fd:	83 ec 04             	sub    $0x4,%esp
f0111200:	68 98 8c 12 f0       	push   $0xf0128c98
f0111205:	6a 61                	push   $0x61
f0111207:	68 74 8c 12 f0       	push   $0xf0128c74
f011120c:	e8 28 f1 fe ff       	call   f0100339 <_panic>

f0111211 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f0111211:	55                   	push   %ebp
f0111212:	89 e5                	mov    %esp,%ebp
f0111214:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111217:	83 ec 04             	sub    $0x4,%esp
f011121a:	68 e8 8c 12 f0       	push   $0xf0128ce8
f011121f:	68 e7 00 00 00       	push   $0xe7
f0111224:	68 74 8c 12 f0       	push   $0xf0128c74
f0111229:	e8 0b f1 fe ff       	call   f0100339 <_panic>

f011122e <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f011122e:	55                   	push   %ebp
f011122f:	89 e5                	mov    %esp,%ebp
f0111231:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111237:	83 ec 04             	sub    $0x4,%esp
f011123a:	68 3c 8d 12 f0       	push   $0xf0128d3c
f011123f:	68 88 01 00 00       	push   $0x188
f0111244:	68 74 8c 12 f0       	push   $0xf0128c74
f0111249:	e8 eb f0 fe ff       	call   f0100339 <_panic>

f011124e <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f011124e:	55                   	push   %ebp
f011124f:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0111251:	90                   	nop
f0111252:	5d                   	pop    %ebp
f0111253:	c3                   	ret    

f0111254 <test_free_block_FF>:

void test_free_block_FF()
{
f0111254:	55                   	push   %ebp
f0111255:	89 e5                	mov    %esp,%ebp
f0111257:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011125a:	83 ec 04             	sub    $0x4,%esp
f011125d:	68 90 8d 12 f0       	push   $0xf0128d90
f0111262:	68 4e 02 00 00       	push   $0x24e
f0111267:	68 74 8c 12 f0       	push   $0xf0128c74
f011126c:	e8 c8 f0 fe ff       	call   f0100339 <_panic>

f0111271 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0111271:	55                   	push   %ebp
f0111272:	89 e5                	mov    %esp,%ebp
f0111274:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111277:	83 ec 04             	sub    $0x4,%esp
f011127a:	68 90 8d 12 f0       	push   $0xf0128d90
f011127f:	68 9a 03 00 00       	push   $0x39a
f0111284:	68 74 8c 12 f0       	push   $0xf0128c74
f0111289:	e8 ab f0 fe ff       	call   f0100339 <_panic>

f011128e <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f011128e:	55                   	push   %ebp
f011128f:	89 e5                	mov    %esp,%ebp
f0111291:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0111294:	83 ec 04             	sub    $0x4,%esp
f0111297:	68 dd 8d 12 f0       	push   $0xf0128ddd
f011129c:	68 ba 04 00 00       	push   $0x4ba
f01112a1:	68 74 8c 12 f0       	push   $0xf0128c74
f01112a6:	e8 8e f0 fe ff       	call   f0100339 <_panic>

f01112ab <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f01112ab:	55                   	push   %ebp
f01112ac:	89 e5                	mov    %esp,%ebp
f01112ae:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01112b1:	83 ec 04             	sub    $0x4,%esp
f01112b4:	68 90 8d 12 f0       	push   $0xf0128d90
f01112b9:	68 c0 04 00 00       	push   $0x4c0
f01112be:	68 74 8c 12 f0       	push   $0xf0128c74
f01112c3:	e8 71 f0 fe ff       	call   f0100339 <_panic>

f01112c8 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f01112c8:	55                   	push   %ebp
f01112c9:	89 e5                	mov    %esp,%ebp
f01112cb:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01112ce:	83 ec 04             	sub    $0x4,%esp
f01112d1:	68 90 8d 12 f0       	push   $0xf0128d90
f01112d6:	68 e7 05 00 00       	push   $0x5e7
f01112db:	68 74 8c 12 f0       	push   $0xf0128c74
f01112e0:	e8 54 f0 fe ff       	call   f0100339 <_panic>

f01112e5 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f01112e5:	55                   	push   %ebp
f01112e6:	89 e5                	mov    %esp,%ebp
f01112e8:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f01112eb:	e8 35 aa ff ff       	call   f010bd25 <get_cpu_proc>
f01112f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f01112f3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01112f7:	75 16                	jne    f011130f <sys_check_LRU_lists+0x2a>
f01112f9:	68 f0 8d 12 f0       	push   $0xf0128df0
f01112fe:	68 00 8e 12 f0       	push   $0xf0128e00
f0111303:	6a 10                	push   $0x10
f0111305:	68 15 8e 12 f0       	push   $0xf0128e15
f011130a:	e8 2a f0 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f011130f:	83 ec 0c             	sub    $0xc,%esp
f0111312:	68 34 8e 12 f0       	push   $0xf0128e34
f0111317:	e8 6f fc fe ff       	call   f0100f8b <cprintf>
f011131c:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f011131f:	83 ec 0c             	sub    $0xc,%esp
f0111322:	ff 75 e0             	pushl  -0x20(%ebp)
f0111325:	e8 7d 94 ff ff       	call   f010a7a7 <env_page_ws_print>
f011132a:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f011132d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111330:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0111333:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f011133a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0111341:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0111345:	0f 84 a5 00 00 00    	je     f01113f0 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f011134b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111352:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111355:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f011135b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011135e:	eb 4a                	jmp    f01113aa <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0111360:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111363:	8b 00                	mov    (%eax),%eax
f0111365:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111368:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011136b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111370:	89 c2                	mov    %eax,%edx
f0111372:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111375:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011137c:	8b 45 08             	mov    0x8(%ebp),%eax
f011137f:	01 c8                	add    %ecx,%eax
f0111381:	8b 00                	mov    (%eax),%eax
f0111383:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111386:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111389:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011138e:	39 c2                	cmp    %eax,%edx
f0111390:	74 09                	je     f011139b <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0111392:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111399:	eb 3e                	jmp    f01113d9 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f011139b:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f011139e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01113a1:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01113a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01113aa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01113ae:	74 08                	je     f01113b8 <sys_check_LRU_lists+0xd3>
f01113b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01113b3:	8b 40 10             	mov    0x10(%eax),%eax
f01113b6:	eb 05                	jmp    f01113bd <sys_check_LRU_lists+0xd8>
f01113b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01113bd:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01113c0:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f01113c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01113c9:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01113cf:	85 c0                	test   %eax,%eax
f01113d1:	75 8d                	jne    f0111360 <sys_check_LRU_lists+0x7b>
f01113d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01113d7:	75 87                	jne    f0111360 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f01113d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01113dc:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f01113e2:	8b 45 10             	mov    0x10(%ebp),%eax
f01113e5:	39 c2                	cmp    %eax,%edx
f01113e7:	74 07                	je     f01113f0 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f01113e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f01113f0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01113f4:	0f 84 a5 00 00 00    	je     f011149f <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f01113fa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111401:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111404:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f011140a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011140d:	eb 4a                	jmp    f0111459 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f011140f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111412:	8b 00                	mov    (%eax),%eax
f0111414:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111417:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011141a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011141f:	89 c2                	mov    %eax,%edx
f0111421:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111424:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011142b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011142e:	01 c8                	add    %ecx,%eax
f0111430:	8b 00                	mov    (%eax),%eax
f0111432:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0111435:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111438:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011143d:	39 c2                	cmp    %eax,%edx
f011143f:	74 09                	je     f011144a <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0111441:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f0111448:	eb 3e                	jmp    f0111488 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f011144a:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011144d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111450:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111456:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111459:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011145d:	74 08                	je     f0111467 <sys_check_LRU_lists+0x182>
f011145f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111462:	8b 40 10             	mov    0x10(%eax),%eax
f0111465:	eb 05                	jmp    f011146c <sys_check_LRU_lists+0x187>
f0111467:	b8 00 00 00 00       	mov    $0x0,%eax
f011146c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011146f:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0111475:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111478:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011147e:	85 c0                	test   %eax,%eax
f0111480:	75 8d                	jne    f011140f <sys_check_LRU_lists+0x12a>
f0111482:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111486:	75 87                	jne    f011140f <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0111488:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011148b:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f0111491:	8b 45 14             	mov    0x14(%ebp),%eax
f0111494:	39 c2                	cmp    %eax,%edx
f0111496:	74 07                	je     f011149f <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0111498:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f011149f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01114a2:	23 45 f0             	and    -0x10(%ebp),%eax
}
f01114a5:	c9                   	leave  
f01114a6:	c3                   	ret    

f01114a7 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f01114a7:	55                   	push   %ebp
f01114a8:	89 e5                	mov    %esp,%ebp
f01114aa:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f01114ad:	e8 73 a8 ff ff       	call   f010bd25 <get_cpu_proc>
f01114b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01114b5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01114b9:	75 16                	jne    f01114d1 <sys_check_LRU_lists_free+0x2a>
f01114bb:	68 f0 8d 12 f0       	push   $0xf0128df0
f01114c0:	68 00 8e 12 f0       	push   $0xf0128e00
f01114c5:	6a 45                	push   $0x45
f01114c7:	68 15 8e 12 f0       	push   $0xf0128e15
f01114cc:	e8 68 ee fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f01114d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01114d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f01114d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01114de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01114e1:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f01114e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01114ea:	eb 65                	jmp    f0111551 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f01114ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01114f3:	eb 3a                	jmp    f011152f <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01114f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114f8:	8b 00                	mov    (%eax),%eax
f01114fa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01114fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111500:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111505:	89 c2                	mov    %eax,%edx
f0111507:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011150a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111511:	8b 45 08             	mov    0x8(%ebp),%eax
f0111514:	01 c8                	add    %ecx,%eax
f0111516:	8b 00                	mov    (%eax),%eax
f0111518:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011151b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011151e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111523:	39 c2                	cmp    %eax,%edx
f0111525:	75 05                	jne    f011152c <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0111527:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011152a:	eb 0b                	jmp    f0111537 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f011152c:	ff 45 ec             	incl   -0x14(%ebp)
f011152f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111532:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111535:	7c be                	jl     f01114f5 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111537:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011153b:	7e 08                	jle    f0111545 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f011153d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111540:	e9 ed 00 00 00       	jmp    f0111632 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111545:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111548:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f011154e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111551:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111555:	74 08                	je     f011155f <sys_check_LRU_lists_free+0xb8>
f0111557:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011155a:	8b 40 10             	mov    0x10(%eax),%eax
f011155d:	eb 05                	jmp    f0111564 <sys_check_LRU_lists_free+0xbd>
f011155f:	b8 00 00 00 00       	mov    $0x0,%eax
f0111564:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111567:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f011156d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111570:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111576:	85 c0                	test   %eax,%eax
f0111578:	0f 85 6e ff ff ff    	jne    f01114ec <sys_check_LRU_lists_free+0x45>
f011157e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111582:	0f 85 64 ff ff ff    	jne    f01114ec <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111588:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011158b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111591:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111594:	eb 62                	jmp    f01115f8 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111596:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011159d:	eb 3a                	jmp    f01115d9 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f011159f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115a2:	8b 00                	mov    (%eax),%eax
f01115a4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01115a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01115aa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115af:	89 c2                	mov    %eax,%edx
f01115b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01115b4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01115bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01115be:	01 c8                	add    %ecx,%eax
f01115c0:	8b 00                	mov    (%eax),%eax
f01115c2:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01115c5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01115c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115cd:	39 c2                	cmp    %eax,%edx
f01115cf:	75 05                	jne    f01115d6 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f01115d1:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01115d4:	eb 0b                	jmp    f01115e1 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f01115d6:	ff 45 e8             	incl   -0x18(%ebp)
f01115d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01115dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01115df:	7c be                	jl     f011159f <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01115e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01115e5:	7e 05                	jle    f01115ec <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f01115e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01115ea:	eb 46                	jmp    f0111632 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01115ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01115ef:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01115f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01115fc:	74 08                	je     f0111606 <sys_check_LRU_lists_free+0x15f>
f01115fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111601:	8b 40 10             	mov    0x10(%eax),%eax
f0111604:	eb 05                	jmp    f011160b <sys_check_LRU_lists_free+0x164>
f0111606:	b8 00 00 00 00       	mov    $0x0,%eax
f011160b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011160e:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0111614:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111617:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011161d:	85 c0                	test   %eax,%eax
f011161f:	0f 85 71 ff ff ff    	jne    f0111596 <sys_check_LRU_lists_free+0xef>
f0111625:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111629:	0f 85 67 ff ff ff    	jne    f0111596 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f011162f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0111632:	c9                   	leave  
f0111633:	c3                   	ret    

f0111634 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0111634:	55                   	push   %ebp
f0111635:	89 e5                	mov    %esp,%ebp
f0111637:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f011163a:	e8 e6 a6 ff ff       	call   f010bd25 <get_cpu_proc>
f011163f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0111642:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0111646:	75 16                	jne    f011165e <sys_check_WS_list+0x2a>
f0111648:	68 f0 8d 12 f0       	push   $0xf0128df0
f011164d:	68 00 8e 12 f0       	push   $0xf0128e00
f0111652:	6a 79                	push   $0x79
f0111654:	68 15 8e 12 f0       	push   $0xf0128e15
f0111659:	e8 db ec fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011165e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111661:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0111664:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f011166b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011166f:	74 06                	je     f0111677 <sys_check_WS_list+0x43>
f0111671:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111675:	75 1f                	jne    f0111696 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111677:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011167a:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f0111680:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111683:	39 c2                	cmp    %eax,%edx
f0111685:	74 0f                	je     f0111696 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111687:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011168e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111691:	e9 15 03 00 00       	jmp    f01119ab <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111696:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011169a:	74 39                	je     f01116d5 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f011169c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011169f:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01116a5:	8b 00                	mov    (%eax),%eax
f01116a7:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01116aa:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01116ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116b2:	89 c2                	mov    %eax,%edx
f01116b4:	8b 45 10             	mov    0x10(%ebp),%eax
f01116b7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f01116ba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01116bd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116c2:	39 c2                	cmp    %eax,%edx
f01116c4:	74 0f                	je     f01116d5 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f01116c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01116cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01116d0:	e9 d6 02 00 00       	jmp    f01119ab <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f01116d5:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f01116d9:	0f 85 3c 01 00 00    	jne    f011181b <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f01116df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f01116e6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01116ea:	74 4c                	je     f0111738 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01116ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01116f3:	eb 3b                	jmp    f0111730 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f01116f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01116f8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01116ff:	8b 45 08             	mov    0x8(%ebp),%eax
f0111702:	01 d0                	add    %edx,%eax
f0111704:	8b 00                	mov    (%eax),%eax
f0111706:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0111709:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011170c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111711:	89 c2                	mov    %eax,%edx
f0111713:	8b 45 10             	mov    0x10(%ebp),%eax
f0111716:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0111719:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011171c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111721:	39 c2                	cmp    %eax,%edx
f0111723:	75 08                	jne    f011172d <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0111725:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111728:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f011172b:	eb 0b                	jmp    f0111738 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f011172d:	ff 45 e8             	incl   -0x18(%ebp)
f0111730:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111733:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111736:	7c bd                	jl     f01116f5 <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0111738:	83 ec 08             	sub    $0x8,%esp
f011173b:	ff 75 ec             	pushl  -0x14(%ebp)
f011173e:	68 5c 8e 12 f0       	push   $0xf0128e5c
f0111743:	e8 43 f8 fe ff       	call   f0100f8b <cprintf>
f0111748:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f011174b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011174e:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111754:	85 c0                	test   %eax,%eax
f0111756:	74 0e                	je     f0111766 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0111758:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011175b:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111761:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111764:	eb 0c                	jmp    f0111772 <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111766:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111769:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011176f:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0111772:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111775:	8b 00                	mov    (%eax),%eax
f0111777:	83 ec 08             	sub    $0x8,%esp
f011177a:	50                   	push   %eax
f011177b:	68 7b 8e 12 f0       	push   $0xf0128e7b
f0111780:	e8 06 f8 fe ff       	call   f0100f8b <cprintf>
f0111785:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111788:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011178f:	eb 79                	jmp    f011180a <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0111791:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111794:	8b 00                	mov    (%eax),%eax
f0111796:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111799:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011179c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01117a1:	89 c2                	mov    %eax,%edx
f01117a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01117a6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01117ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01117b0:	01 c8                	add    %ecx,%eax
f01117b2:	8b 00                	mov    (%eax),%eax
f01117b4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01117b7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01117ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01117bf:	39 c2                	cmp    %eax,%edx
f01117c1:	74 0c                	je     f01117cf <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f01117c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01117ca:	e9 d9 01 00 00       	jmp    f01119a8 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f01117cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01117d2:	40                   	inc    %eax
f01117d3:	89 c2                	mov    %eax,%edx
f01117d5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01117d8:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f01117de:	89 d0                	mov    %edx,%eax
f01117e0:	ba 00 00 00 00       	mov    $0x0,%edx
f01117e5:	f7 f1                	div    %ecx
f01117e7:	89 d0                	mov    %edx,%eax
f01117e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f01117ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01117ef:	8b 40 10             	mov    0x10(%eax),%eax
f01117f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f01117f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01117f9:	75 0c                	jne    f0111807 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01117fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01117fe:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111804:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111807:	ff 45 e4             	incl   -0x1c(%ebp)
f011180a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011180d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111810:	0f 8c 7b ff ff ff    	jl     f0111791 <sys_check_WS_list+0x15d>
f0111816:	e9 8d 01 00 00       	jmp    f01119a8 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f011181b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011181f:	74 0a                	je     f011182b <sys_check_WS_list+0x1f7>
f0111821:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0111825:	0f 85 be 00 00 00    	jne    f01118e9 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011182b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0111832:	e9 a1 00 00 00       	jmp    f01118d8 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0111837:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011183e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111841:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111847:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011184a:	eb 47                	jmp    f0111893 <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011184c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011184f:	8b 00                	mov    (%eax),%eax
f0111851:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0111854:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111857:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011185c:	89 c2                	mov    %eax,%edx
f011185e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111861:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111868:	8b 45 08             	mov    0x8(%ebp),%eax
f011186b:	01 c8                	add    %ecx,%eax
f011186d:	8b 00                	mov    (%eax),%eax
f011186f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0111872:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111875:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011187a:	39 c2                	cmp    %eax,%edx
f011187c:	75 09                	jne    f0111887 <sys_check_WS_list+0x253>
				{
					found = 1;
f011187e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0111885:	eb 3b                	jmp    f01118c2 <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111887:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011188a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111890:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111893:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111897:	74 08                	je     f01118a1 <sys_check_WS_list+0x26d>
f0111899:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011189c:	8b 40 10             	mov    0x10(%eax),%eax
f011189f:	eb 05                	jmp    f01118a6 <sys_check_WS_list+0x272>
f01118a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01118a6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01118a9:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f01118af:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01118b2:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01118b8:	85 c0                	test   %eax,%eax
f01118ba:	75 90                	jne    f011184c <sys_check_WS_list+0x218>
f01118bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01118c0:	75 8a                	jne    f011184c <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f01118c2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01118c6:	75 0d                	jne    f01118d5 <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f01118c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01118cf:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01118d0:	e9 d3 00 00 00       	jmp    f01119a8 <sys_check_WS_list+0x374>
f01118d5:	ff 45 e0             	incl   -0x20(%ebp)
f01118d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01118db:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01118de:	0f 8c 53 ff ff ff    	jl     f0111837 <sys_check_WS_list+0x203>
f01118e4:	e9 bf 00 00 00       	jmp    f01119a8 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f01118e9:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f01118ed:	0f 85 b5 00 00 00    	jne    f01119a8 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01118f3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01118fa:	e9 9d 00 00 00       	jmp    f011199c <sys_check_WS_list+0x368>
		{
			bool found = 0;
f01118ff:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111906:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111909:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011190f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111912:	eb 47                	jmp    f011195b <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0111914:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111917:	8b 00                	mov    (%eax),%eax
f0111919:	89 45 b0             	mov    %eax,-0x50(%ebp)
f011191c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011191f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111924:	89 c2                	mov    %eax,%edx
f0111926:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111929:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111930:	8b 45 08             	mov    0x8(%ebp),%eax
f0111933:	01 c8                	add    %ecx,%eax
f0111935:	8b 00                	mov    (%eax),%eax
f0111937:	89 45 ac             	mov    %eax,-0x54(%ebp)
f011193a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011193d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111942:	39 c2                	cmp    %eax,%edx
f0111944:	75 09                	jne    f011194f <sys_check_WS_list+0x31b>
				{
					found = 1;
f0111946:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f011194d:	eb 3b                	jmp    f011198a <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011194f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111952:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111958:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011195b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011195f:	74 08                	je     f0111969 <sys_check_WS_list+0x335>
f0111961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111964:	8b 40 10             	mov    0x10(%eax),%eax
f0111967:	eb 05                	jmp    f011196e <sys_check_WS_list+0x33a>
f0111969:	b8 00 00 00 00       	mov    $0x0,%eax
f011196e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111971:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0111977:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011197a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111980:	85 c0                	test   %eax,%eax
f0111982:	75 90                	jne    f0111914 <sys_check_WS_list+0x2e0>
f0111984:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111988:	75 8a                	jne    f0111914 <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f011198a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011198e:	74 09                	je     f0111999 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0111990:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111997:	eb 0f                	jmp    f01119a8 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111999:	ff 45 d8             	incl   -0x28(%ebp)
f011199c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011199f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01119a2:	0f 8c 57 ff ff ff    	jl     f01118ff <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f01119a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f01119ab:	c9                   	leave  
f01119ac:	c3                   	ret    

f01119ad <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01119ad:	55                   	push   %ebp
f01119ae:	89 e5                	mov    %esp,%ebp
f01119b0:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01119b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f01119ba:	8b 15 04 da f5 f0    	mov    0xf0f5da04,%edx
f01119c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01119c3:	39 c2                	cmp    %eax,%edx
f01119c5:	74 0a                	je     f01119d1 <hasExpectedCommands+0x24>
		return 0;
f01119c7:	b8 00 00 00 00       	mov    $0x0,%eax
f01119cc:	e9 8b 00 00 00       	jmp    f0111a5c <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f01119d1:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f01119d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01119d9:	eb 55                	jmp    f0111a30 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01119db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01119e2:	eb 2a                	jmp    f0111a0e <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f01119e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01119e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01119ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01119f1:	01 d0                	add    %edx,%eax
f01119f3:	8b 10                	mov    (%eax),%edx
f01119f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01119f8:	8b 00                	mov    (%eax),%eax
f01119fa:	83 ec 08             	sub    $0x8,%esp
f01119fd:	52                   	push   %edx
f01119fe:	50                   	push   %eax
f01119ff:	e8 24 e7 00 00       	call   f0120128 <strcmp>
f0111a04:	83 c4 10             	add    $0x10,%esp
f0111a07:	85 c0                	test   %eax,%eax
f0111a09:	74 0d                	je     f0111a18 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111a0b:	ff 45 f0             	incl   -0x10(%ebp)
f0111a0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111a11:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111a14:	7c ce                	jl     f01119e4 <hasExpectedCommands+0x37>
f0111a16:	eb 01                	jmp    f0111a19 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0111a18:	90                   	nop
		if (i == commandsCount)
f0111a19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111a1c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111a1f:	75 07                	jne    f0111a28 <hasExpectedCommands+0x7b>
			return 0;
f0111a21:	b8 00 00 00 00       	mov    $0x0,%eax
f0111a26:	eb 34                	jmp    f0111a5c <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0111a28:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0111a2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111a30:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111a34:	74 08                	je     f0111a3e <hasExpectedCommands+0x91>
f0111a36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111a39:	8b 40 10             	mov    0x10(%eax),%eax
f0111a3c:	eb 05                	jmp    f0111a43 <hasExpectedCommands+0x96>
f0111a3e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111a43:	a3 00 da f5 f0       	mov    %eax,0xf0f5da00
f0111a48:	a1 00 da f5 f0       	mov    0xf0f5da00,%eax
f0111a4d:	85 c0                	test   %eax,%eax
f0111a4f:	75 8a                	jne    f01119db <hasExpectedCommands+0x2e>
f0111a51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111a55:	75 84                	jne    f01119db <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0111a57:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111a5c:	c9                   	leave  
f0111a5d:	c3                   	ret    

f0111a5e <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0111a5e:	55                   	push   %ebp
f0111a5f:	89 e5                	mov    %esp,%ebp
f0111a61:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111a64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111a6b:	eb 2e                	jmp    f0111a9b <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0111a6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111a70:	89 d0                	mov    %edx,%eax
f0111a72:	01 c0                	add    %eax,%eax
f0111a74:	01 d0                	add    %edx,%eax
f0111a76:	c1 e0 03             	shl    $0x3,%eax
f0111a79:	05 40 05 18 f0       	add    $0xf0180540,%eax
f0111a7e:	8b 00                	mov    (%eax),%eax
f0111a80:	83 ec 08             	sub    $0x8,%esp
f0111a83:	ff 75 08             	pushl  0x8(%ebp)
f0111a86:	50                   	push   %eax
f0111a87:	e8 9c e6 00 00       	call   f0120128 <strcmp>
f0111a8c:	83 c4 10             	add    $0x10,%esp
f0111a8f:	85 c0                	test   %eax,%eax
f0111a91:	75 05                	jne    f0111a98 <getIndexOfCommand+0x3a>
			return i;
f0111a93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111a96:	eb 14                	jmp    f0111aac <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111a98:	ff 45 f4             	incl   -0xc(%ebp)
f0111a9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111a9e:	a1 78 09 18 f0       	mov    0xf0180978,%eax
f0111aa3:	39 c2                	cmp    %eax,%edx
f0111aa5:	72 c6                	jb     f0111a6d <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0111aa7:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111aac:	c9                   	leave  
f0111aad:	c3                   	ret    

f0111aae <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111aae:	55                   	push   %ebp
f0111aaf:	89 e5                	mov    %esp,%ebp
f0111ab1:	57                   	push   %edi
f0111ab2:	56                   	push   %esi
f0111ab3:	53                   	push   %ebx
f0111ab4:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111aba:	83 ec 0c             	sub    $0xc,%esp
f0111abd:	68 a0 8e 12 f0       	push   $0xf0128ea0
f0111ac2:	e8 c4 f4 fe ff       	call   f0100f8b <cprintf>
f0111ac7:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111aca:	83 ec 0c             	sub    $0xc,%esp
f0111acd:	68 c4 8e 12 f0       	push   $0xf0128ec4
f0111ad2:	e8 b4 f4 fe ff       	call   f0100f8b <cprintf>
f0111ad7:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111ada:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0111ae1:	c7 45 8c df 8e 12 f0 	movl   $0xf0128edf,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111ae8:	83 ec 08             	sub    $0x8,%esp
f0111aeb:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0111aee:	50                   	push   %eax
f0111aef:	6a 01                	push   $0x1
f0111af1:	e8 da 06 ff ff       	call   f01021d0 <process_command>
f0111af6:	83 c4 10             	add    $0x10,%esp
f0111af9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0111afc:	83 ec 0c             	sub    $0xc,%esp
f0111aff:	68 ec 8e 12 f0       	push   $0xf0128eec
f0111b04:	e8 82 f4 fe ff       	call   f0100f8b <cprintf>
f0111b09:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0111b0c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0111b0f:	83 ec 0c             	sub    $0xc,%esp
f0111b12:	50                   	push   %eax
f0111b13:	e8 46 ff ff ff       	call   f0111a5e <getIndexOfCommand>
f0111b18:	83 c4 10             	add    $0x10,%esp
f0111b1b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111b1e:	75 0f                	jne    f0111b2f <TestAutoCompleteCommand+0x81>
f0111b20:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f0111b25:	85 c0                	test   %eax,%eax
f0111b27:	75 06                	jne    f0111b2f <TestAutoCompleteCommand+0x81>
		eval += 15;
f0111b29:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111b2d:	eb 10                	jmp    f0111b3f <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111b2f:	83 ec 0c             	sub    $0xc,%esp
f0111b32:	68 1c 8f 12 f0       	push   $0xf0128f1c
f0111b37:	e8 4f f4 fe ff       	call   f0100f8b <cprintf>
f0111b3c:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0111b3f:	83 ec 0c             	sub    $0xc,%esp
f0111b42:	68 6c 8f 12 f0       	push   $0xf0128f6c
f0111b47:	e8 3f f4 fe ff       	call   f0100f8b <cprintf>
f0111b4c:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0111b4f:	c7 45 88 92 8f 12 f0 	movl   $0xf0128f92,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0111b56:	83 ec 08             	sub    $0x8,%esp
f0111b59:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111b5c:	50                   	push   %eax
f0111b5d:	6a 01                	push   $0x1
f0111b5f:	e8 6c 06 ff ff       	call   f01021d0 <process_command>
f0111b64:	83 c4 10             	add    $0x10,%esp
f0111b67:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111b6a:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111b6e:	75 30                	jne    f0111ba0 <TestAutoCompleteCommand+0xf2>
f0111b70:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111b73:	bb 70 93 12 f0       	mov    $0xf0129370,%ebx
f0111b78:	ba 03 00 00 00       	mov    $0x3,%edx
f0111b7d:	89 c7                	mov    %eax,%edi
f0111b7f:	89 de                	mov    %ebx,%esi
f0111b81:	89 d1                	mov    %edx,%ecx
f0111b83:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111b85:	83 ec 08             	sub    $0x8,%esp
f0111b88:	6a 03                	push   $0x3
f0111b8a:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111b8d:	50                   	push   %eax
f0111b8e:	e8 1a fe ff ff       	call   f01119ad <hasExpectedCommands>
f0111b93:	83 c4 10             	add    $0x10,%esp
f0111b96:	85 c0                	test   %eax,%eax
f0111b98:	74 06                	je     f0111ba0 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111b9a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111b9e:	eb 10                	jmp    f0111bb0 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111ba0:	83 ec 0c             	sub    $0xc,%esp
f0111ba3:	68 98 8f 12 f0       	push   $0xf0128f98
f0111ba8:	e8 de f3 fe ff       	call   f0100f8b <cprintf>
f0111bad:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111bb0:	83 ec 0c             	sub    $0xc,%esp
f0111bb3:	68 e8 8f 12 f0       	push   $0xf0128fe8
f0111bb8:	e8 ce f3 fe ff       	call   f0100f8b <cprintf>
f0111bbd:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111bc0:	c7 45 84 0d 90 12 f0 	movl   $0xf012900d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0111bc7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111bca:	83 ec 04             	sub    $0x4,%esp
f0111bcd:	50                   	push   %eax
f0111bce:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111bd1:	50                   	push   %eax
f0111bd2:	68 10 90 12 f0       	push   $0xf0129010
f0111bd7:	e8 af f3 fe ff       	call   f0100f8b <cprintf>
f0111bdc:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111bdf:	83 ec 08             	sub    $0x8,%esp
f0111be2:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111be5:	50                   	push   %eax
f0111be6:	6a 01                	push   $0x1
f0111be8:	e8 e3 05 ff ff       	call   f01021d0 <process_command>
f0111bed:	83 c4 10             	add    $0x10,%esp
f0111bf0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f0111bf3:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0111bf7:	75 1b                	jne    f0111c14 <TestAutoCompleteCommand+0x166>
f0111bf9:	83 ec 08             	sub    $0x8,%esp
f0111bfc:	6a 01                	push   $0x1
f0111bfe:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111c01:	50                   	push   %eax
f0111c02:	e8 a6 fd ff ff       	call   f01119ad <hasExpectedCommands>
f0111c07:	83 c4 10             	add    $0x10,%esp
f0111c0a:	85 c0                	test   %eax,%eax
f0111c0c:	74 06                	je     f0111c14 <TestAutoCompleteCommand+0x166>
		eval += 15;
f0111c0e:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111c12:	eb 10                	jmp    f0111c24 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111c14:	83 ec 0c             	sub    $0xc,%esp
f0111c17:	68 30 90 12 f0       	push   $0xf0129030
f0111c1c:	e8 6a f3 fe ff       	call   f0100f8b <cprintf>
f0111c21:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0111c24:	83 ec 0c             	sub    $0xc,%esp
f0111c27:	68 88 90 12 f0       	push   $0xf0129088
f0111c2c:	e8 5a f3 fe ff       	call   f0100f8b <cprintf>
f0111c31:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0111c34:	c7 45 80 ae 90 12 f0 	movl   $0xf01290ae,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111c3b:	83 ec 08             	sub    $0x8,%esp
f0111c3e:	8d 45 80             	lea    -0x80(%ebp),%eax
f0111c41:	50                   	push   %eax
f0111c42:	6a 01                	push   $0x1
f0111c44:	e8 87 05 ff ff       	call   f01021d0 <process_command>
f0111c49:	83 c4 10             	add    $0x10,%esp
f0111c4c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111c4f:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111c53:	75 0f                	jne    f0111c64 <TestAutoCompleteCommand+0x1b6>
f0111c55:	a1 04 da f5 f0       	mov    0xf0f5da04,%eax
f0111c5a:	85 c0                	test   %eax,%eax
f0111c5c:	75 06                	jne    f0111c64 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111c5e:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111c62:	eb 10                	jmp    f0111c74 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111c64:	83 ec 0c             	sub    $0xc,%esp
f0111c67:	68 b4 90 12 f0       	push   $0xf01290b4
f0111c6c:	e8 1a f3 fe ff       	call   f0100f8b <cprintf>
f0111c71:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111c74:	83 ec 0c             	sub    $0xc,%esp
f0111c77:	68 04 91 12 f0       	push   $0xf0129104
f0111c7c:	e8 0a f3 fe ff       	call   f0100f8b <cprintf>
f0111c81:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111c84:	c7 85 7c ff ff ff 29 	movl   $0xf0129129,-0x84(%ebp)
f0111c8b:	91 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111c8e:	83 ec 08             	sub    $0x8,%esp
f0111c91:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f0111c97:	50                   	push   %eax
f0111c98:	6a 01                	push   $0x1
f0111c9a:	e8 31 05 ff ff       	call   f01021d0 <process_command>
f0111c9f:	83 c4 10             	add    $0x10,%esp
f0111ca2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0111ca5:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111ca9:	75 30                	jne    f0111cdb <TestAutoCompleteCommand+0x22d>
f0111cab:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111cae:	bb 00 94 12 f0       	mov    $0xf0129400,%ebx
f0111cb3:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111cb8:	89 c7                	mov    %eax,%edi
f0111cba:	89 de                	mov    %ebx,%esi
f0111cbc:	89 d1                	mov    %edx,%ecx
f0111cbe:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111cc0:	83 ec 08             	sub    $0x8,%esp
f0111cc3:	6a 0c                	push   $0xc
f0111cc5:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111cc8:	50                   	push   %eax
f0111cc9:	e8 df fc ff ff       	call   f01119ad <hasExpectedCommands>
f0111cce:	83 c4 10             	add    $0x10,%esp
f0111cd1:	85 c0                	test   %eax,%eax
f0111cd3:	74 06                	je     f0111cdb <TestAutoCompleteCommand+0x22d>
		eval += 10;
f0111cd5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111cd9:	eb 10                	jmp    f0111ceb <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111cdb:	83 ec 0c             	sub    $0xc,%esp
f0111cde:	68 2c 91 12 f0       	push   $0xf012912c
f0111ce3:	e8 a3 f2 fe ff       	call   f0100f8b <cprintf>
f0111ce8:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111ceb:	83 ec 0c             	sub    $0xc,%esp
f0111cee:	68 84 91 12 f0       	push   $0xf0129184
f0111cf3:	e8 93 f2 fe ff       	call   f0100f8b <cprintf>
f0111cf8:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0111cfb:	c7 85 78 ff ff ff a9 	movl   $0xf01291a9,-0x88(%ebp)
f0111d02:	91 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0111d05:	83 ec 08             	sub    $0x8,%esp
f0111d08:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0111d0e:	50                   	push   %eax
f0111d0f:	6a 01                	push   $0x1
f0111d11:	e8 ba 04 ff ff       	call   f01021d0 <process_command>
f0111d16:	83 c4 10             	add    $0x10,%esp
f0111d19:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0111d1c:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111d20:	75 30                	jne    f0111d52 <TestAutoCompleteCommand+0x2a4>
f0111d22:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111d25:	bb 48 94 12 f0       	mov    $0xf0129448,%ebx
f0111d2a:	ba 05 00 00 00       	mov    $0x5,%edx
f0111d2f:	89 c7                	mov    %eax,%edi
f0111d31:	89 de                	mov    %ebx,%esi
f0111d33:	89 d1                	mov    %edx,%ecx
f0111d35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111d37:	83 ec 08             	sub    $0x8,%esp
f0111d3a:	6a 05                	push   $0x5
f0111d3c:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111d3f:	50                   	push   %eax
f0111d40:	e8 68 fc ff ff       	call   f01119ad <hasExpectedCommands>
f0111d45:	83 c4 10             	add    $0x10,%esp
f0111d48:	85 c0                	test   %eax,%eax
f0111d4a:	74 06                	je     f0111d52 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0111d4c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111d50:	eb 10                	jmp    f0111d62 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111d52:	83 ec 0c             	sub    $0xc,%esp
f0111d55:	68 ac 91 12 f0       	push   $0xf01291ac
f0111d5a:	e8 2c f2 fe ff       	call   f0100f8b <cprintf>
f0111d5f:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111d62:	83 ec 0c             	sub    $0xc,%esp
f0111d65:	68 04 92 12 f0       	push   $0xf0129204
f0111d6a:	e8 1c f2 fe ff       	call   f0100f8b <cprintf>
f0111d6f:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111d72:	c7 85 70 ff ff ff 30 	movl   $0xf0129230,-0x90(%ebp)
f0111d79:	92 12 f0 
f0111d7c:	c7 85 74 ff ff ff 35 	movl   $0xf0129235,-0x8c(%ebp)
f0111d83:	92 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111d86:	83 ec 08             	sub    $0x8,%esp
f0111d89:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111d8f:	50                   	push   %eax
f0111d90:	6a 02                	push   $0x2
f0111d92:	e8 39 04 ff ff       	call   f01021d0 <process_command>
f0111d97:	83 c4 10             	add    $0x10,%esp
f0111d9a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111d9d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111da3:	83 ec 0c             	sub    $0xc,%esp
f0111da6:	50                   	push   %eax
f0111da7:	e8 b2 fc ff ff       	call   f0111a5e <getIndexOfCommand>
f0111dac:	83 c4 10             	add    $0x10,%esp
f0111daf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111db2:	75 0f                	jne    f0111dc3 <TestAutoCompleteCommand+0x315>
f0111db4:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f0111db9:	85 c0                	test   %eax,%eax
f0111dbb:	75 06                	jne    f0111dc3 <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111dbd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111dc1:	eb 10                	jmp    f0111dd3 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111dc3:	83 ec 0c             	sub    $0xc,%esp
f0111dc6:	68 3c 92 12 f0       	push   $0xf012923c
f0111dcb:	e8 bb f1 fe ff       	call   f0100f8b <cprintf>
f0111dd0:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111dd3:	83 ec 0c             	sub    $0xc,%esp
f0111dd6:	68 8c 92 12 f0       	push   $0xf012928c
f0111ddb:	e8 ab f1 fe ff       	call   f0100f8b <cprintf>
f0111de0:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111de3:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111de9:	bb 70 94 12 f0       	mov    $0xf0129470,%ebx
f0111dee:	ba 03 00 00 00       	mov    $0x3,%edx
f0111df3:	89 c7                	mov    %eax,%edi
f0111df5:	89 de                	mov    %ebx,%esi
f0111df7:	89 d1                	mov    %edx,%ecx
f0111df9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111dfb:	83 ec 08             	sub    $0x8,%esp
f0111dfe:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111e04:	50                   	push   %eax
f0111e05:	6a 03                	push   $0x3
f0111e07:	e8 c4 03 ff ff       	call   f01021d0 <process_command>
f0111e0c:	83 c4 10             	add    $0x10,%esp
f0111e0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111e12:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111e18:	83 ec 0c             	sub    $0xc,%esp
f0111e1b:	50                   	push   %eax
f0111e1c:	e8 3d fc ff ff       	call   f0111a5e <getIndexOfCommand>
f0111e21:	83 c4 10             	add    $0x10,%esp
f0111e24:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111e27:	75 0f                	jne    f0111e38 <TestAutoCompleteCommand+0x38a>
f0111e29:	a1 f8 d9 f5 f0       	mov    0xf0f5d9f8,%eax
f0111e2e:	85 c0                	test   %eax,%eax
f0111e30:	75 06                	jne    f0111e38 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111e32:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111e36:	eb 10                	jmp    f0111e48 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111e38:	83 ec 0c             	sub    $0xc,%esp
f0111e3b:	68 c0 92 12 f0       	push   $0xf01292c0
f0111e40:	e8 46 f1 fe ff       	call   f0100f8b <cprintf>
f0111e45:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0111e48:	83 ec 08             	sub    $0x8,%esp
f0111e4b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111e4e:	68 10 93 12 f0       	push   $0xf0129310
f0111e53:	e8 33 f1 fe ff       	call   f0100f8b <cprintf>
f0111e58:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111e5b:	83 ec 0c             	sub    $0xc,%esp
f0111e5e:	68 40 93 12 f0       	push   $0xf0129340
f0111e63:	e8 23 f1 fe ff       	call   f0100f8b <cprintf>
f0111e68:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111e6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111e70:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111e73:	5b                   	pop    %ebx
f0111e74:	5e                   	pop    %esi
f0111e75:	5f                   	pop    %edi
f0111e76:	5d                   	pop    %ebp
f0111e77:	c3                   	ret    

f0111e78 <test_str2lower_function>:

int test_str2lower_function()
{
f0111e78:	55                   	push   %ebp
f0111e79:	89 e5                	mov    %esp,%ebp
f0111e7b:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111e81:	83 ec 0c             	sub    $0xc,%esp
f0111e84:	68 7c 94 12 f0       	push   $0xf012947c
f0111e89:	e8 fd f0 fe ff       	call   f0100f8b <cprintf>
f0111e8e:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111e91:	83 ec 0c             	sub    $0xc,%esp
f0111e94:	68 9d 94 12 f0       	push   $0xf012949d
f0111e99:	e8 ed f0 fe ff       	call   f0100f8b <cprintf>
f0111e9e:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111ea1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111ea8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111eaf:	c7 45 ec b7 94 12 f0 	movl   $0xf01294b7,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111eb6:	83 ec 08             	sub    $0x8,%esp
f0111eb9:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ebc:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111ec2:	50                   	push   %eax
f0111ec3:	e8 3d e8 00 00       	call   f0120705 <str2lower>
f0111ec8:	83 c4 10             	add    $0x10,%esp
f0111ecb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111ece:	83 ec 0c             	sub    $0xc,%esp
f0111ed1:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ed4:	e8 43 e1 00 00       	call   f012001c <strlen>
f0111ed9:	83 c4 10             	add    $0x10,%esp
f0111edc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111edf:	83 ec 08             	sub    $0x8,%esp
f0111ee2:	68 c2 94 12 f0       	push   $0xf01294c2
f0111ee7:	ff 75 e8             	pushl  -0x18(%ebp)
f0111eea:	e8 39 e2 00 00       	call   f0120128 <strcmp>
f0111eef:	83 c4 10             	add    $0x10,%esp
f0111ef2:	85 c0                	test   %eax,%eax
f0111ef4:	75 13                	jne    f0111f09 <test_str2lower_function+0x91>
f0111ef6:	83 ec 0c             	sub    $0xc,%esp
f0111ef9:	ff 75 ec             	pushl  -0x14(%ebp)
f0111efc:	e8 1b e1 00 00       	call   f012001c <strlen>
f0111f01:	83 c4 10             	add    $0x10,%esp
f0111f04:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f07:	74 15                	je     f0111f1e <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111f09:	83 ec 08             	sub    $0x8,%esp
f0111f0c:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f0f:	68 d0 94 12 f0       	push   $0xf01294d0
f0111f14:	e8 72 f0 fe ff       	call   f0100f8b <cprintf>
f0111f19:	83 c4 10             	add    $0x10,%esp
f0111f1c:	eb 04                	jmp    f0111f22 <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111f1e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111f22:	c7 45 e0 32 95 12 f0 	movl   $0xf0129532,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111f29:	83 ec 08             	sub    $0x8,%esp
f0111f2c:	ff 75 e0             	pushl  -0x20(%ebp)
f0111f2f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111f35:	50                   	push   %eax
f0111f36:	e8 ca e7 00 00       	call   f0120705 <str2lower>
f0111f3b:	83 c4 10             	add    $0x10,%esp
f0111f3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111f41:	83 ec 0c             	sub    $0xc,%esp
f0111f44:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f47:	e8 d0 e0 00 00       	call   f012001c <strlen>
f0111f4c:	83 c4 10             	add    $0x10,%esp
f0111f4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111f52:	83 ec 08             	sub    $0x8,%esp
f0111f55:	68 32 95 12 f0       	push   $0xf0129532
f0111f5a:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f5d:	e8 c6 e1 00 00       	call   f0120128 <strcmp>
f0111f62:	83 c4 10             	add    $0x10,%esp
f0111f65:	85 c0                	test   %eax,%eax
f0111f67:	75 13                	jne    f0111f7c <test_str2lower_function+0x104>
f0111f69:	83 ec 0c             	sub    $0xc,%esp
f0111f6c:	ff 75 e0             	pushl  -0x20(%ebp)
f0111f6f:	e8 a8 e0 00 00       	call   f012001c <strlen>
f0111f74:	83 c4 10             	add    $0x10,%esp
f0111f77:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f7a:	74 15                	je     f0111f91 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111f7c:	83 ec 08             	sub    $0x8,%esp
f0111f7f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f82:	68 34 95 12 f0       	push   $0xf0129534
f0111f87:	e8 ff ef fe ff       	call   f0100f8b <cprintf>
f0111f8c:	83 c4 10             	add    $0x10,%esp
f0111f8f:	eb 04                	jmp    f0111f95 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111f91:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111f95:	c7 45 dc 8c 95 12 f0 	movl   $0xf012958c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111f9c:	83 ec 08             	sub    $0x8,%esp
f0111f9f:	ff 75 dc             	pushl  -0x24(%ebp)
f0111fa2:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111fa8:	50                   	push   %eax
f0111fa9:	e8 57 e7 00 00       	call   f0120705 <str2lower>
f0111fae:	83 c4 10             	add    $0x10,%esp
f0111fb1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111fb4:	83 ec 0c             	sub    $0xc,%esp
f0111fb7:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fba:	e8 5d e0 00 00       	call   f012001c <strlen>
f0111fbf:	83 c4 10             	add    $0x10,%esp
f0111fc2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111fc5:	83 ec 08             	sub    $0x8,%esp
f0111fc8:	68 8c 95 12 f0       	push   $0xf012958c
f0111fcd:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fd0:	e8 53 e1 00 00       	call   f0120128 <strcmp>
f0111fd5:	83 c4 10             	add    $0x10,%esp
f0111fd8:	85 c0                	test   %eax,%eax
f0111fda:	75 13                	jne    f0111fef <test_str2lower_function+0x177>
f0111fdc:	83 ec 0c             	sub    $0xc,%esp
f0111fdf:	ff 75 dc             	pushl  -0x24(%ebp)
f0111fe2:	e8 35 e0 00 00       	call   f012001c <strlen>
f0111fe7:	83 c4 10             	add    $0x10,%esp
f0111fea:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111fed:	74 15                	je     f0112004 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111fef:	83 ec 08             	sub    $0x8,%esp
f0111ff2:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ff5:	68 98 95 12 f0       	push   $0xf0129598
f0111ffa:	e8 8c ef fe ff       	call   f0100f8b <cprintf>
f0111fff:	83 c4 10             	add    $0x10,%esp
f0112002:	eb 04                	jmp    f0112008 <test_str2lower_function+0x190>
	else
		eval += 15;
f0112004:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0112008:	c7 45 d8 fb 95 12 f0 	movl   $0xf01295fb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f011200f:	83 ec 08             	sub    $0x8,%esp
f0112012:	ff 75 d8             	pushl  -0x28(%ebp)
f0112015:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f011201b:	50                   	push   %eax
f011201c:	e8 e4 e6 00 00       	call   f0120705 <str2lower>
f0112021:	83 c4 10             	add    $0x10,%esp
f0112024:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0112027:	83 ec 0c             	sub    $0xc,%esp
f011202a:	ff 75 e8             	pushl  -0x18(%ebp)
f011202d:	e8 ea df 00 00       	call   f012001c <strlen>
f0112032:	83 c4 10             	add    $0x10,%esp
f0112035:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0112038:	83 ec 08             	sub    $0x8,%esp
f011203b:	68 fb 95 12 f0       	push   $0xf01295fb
f0112040:	ff 75 e8             	pushl  -0x18(%ebp)
f0112043:	e8 e0 e0 00 00       	call   f0120128 <strcmp>
f0112048:	83 c4 10             	add    $0x10,%esp
f011204b:	85 c0                	test   %eax,%eax
f011204d:	75 13                	jne    f0112062 <test_str2lower_function+0x1ea>
f011204f:	83 ec 0c             	sub    $0xc,%esp
f0112052:	ff 75 d8             	pushl  -0x28(%ebp)
f0112055:	e8 c2 df 00 00       	call   f012001c <strlen>
f011205a:	83 c4 10             	add    $0x10,%esp
f011205d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112060:	74 15                	je     f0112077 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0112062:	83 ec 08             	sub    $0x8,%esp
f0112065:	ff 75 e8             	pushl  -0x18(%ebp)
f0112068:	68 08 96 12 f0       	push   $0xf0129608
f011206d:	e8 19 ef fe ff       	call   f0100f8b <cprintf>
f0112072:	83 c4 10             	add    $0x10,%esp
f0112075:	eb 04                	jmp    f011207b <test_str2lower_function+0x203>
	else
		eval += 15;
f0112077:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f011207b:	c7 45 d4 6a 96 12 f0 	movl   $0xf012966a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0112082:	83 ec 08             	sub    $0x8,%esp
f0112085:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112088:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f011208e:	50                   	push   %eax
f011208f:	e8 71 e6 00 00       	call   f0120705 <str2lower>
f0112094:	83 c4 10             	add    $0x10,%esp
f0112097:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011209a:	83 ec 0c             	sub    $0xc,%esp
f011209d:	ff 75 e8             	pushl  -0x18(%ebp)
f01120a0:	e8 77 df 00 00       	call   f012001c <strlen>
f01120a5:	83 c4 10             	add    $0x10,%esp
f01120a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f01120ab:	83 ec 08             	sub    $0x8,%esp
f01120ae:	68 80 96 12 f0       	push   $0xf0129680
f01120b3:	ff 75 e8             	pushl  -0x18(%ebp)
f01120b6:	e8 6d e0 00 00       	call   f0120128 <strcmp>
f01120bb:	83 c4 10             	add    $0x10,%esp
f01120be:	85 c0                	test   %eax,%eax
f01120c0:	75 13                	jne    f01120d5 <test_str2lower_function+0x25d>
f01120c2:	83 ec 0c             	sub    $0xc,%esp
f01120c5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01120c8:	e8 4f df 00 00       	call   f012001c <strlen>
f01120cd:	83 c4 10             	add    $0x10,%esp
f01120d0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01120d3:	74 15                	je     f01120ea <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f01120d5:	83 ec 08             	sub    $0x8,%esp
f01120d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01120db:	68 98 96 12 f0       	push   $0xf0129698
f01120e0:	e8 a6 ee fe ff       	call   f0100f8b <cprintf>
f01120e5:	83 c4 10             	add    $0x10,%esp
f01120e8:	eb 04                	jmp    f01120ee <test_str2lower_function+0x276>
	else
		eval += 15;
f01120ea:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f01120ee:	c7 45 d0 05 97 12 f0 	movl   $0xf0129705,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f01120f5:	83 ec 08             	sub    $0x8,%esp
f01120f8:	ff 75 d0             	pushl  -0x30(%ebp)
f01120fb:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0112101:	50                   	push   %eax
f0112102:	e8 fe e5 00 00       	call   f0120705 <str2lower>
f0112107:	83 c4 10             	add    $0x10,%esp
f011210a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011210d:	83 ec 0c             	sub    $0xc,%esp
f0112110:	ff 75 e8             	pushl  -0x18(%ebp)
f0112113:	e8 04 df 00 00       	call   f012001c <strlen>
f0112118:	83 c4 10             	add    $0x10,%esp
f011211b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f011211e:	83 ec 08             	sub    $0x8,%esp
f0112121:	68 11 97 12 f0       	push   $0xf0129711
f0112126:	ff 75 e8             	pushl  -0x18(%ebp)
f0112129:	e8 fa df 00 00       	call   f0120128 <strcmp>
f011212e:	83 c4 10             	add    $0x10,%esp
f0112131:	85 c0                	test   %eax,%eax
f0112133:	75 13                	jne    f0112148 <test_str2lower_function+0x2d0>
f0112135:	83 ec 0c             	sub    $0xc,%esp
f0112138:	ff 75 d0             	pushl  -0x30(%ebp)
f011213b:	e8 dc de 00 00       	call   f012001c <strlen>
f0112140:	83 c4 10             	add    $0x10,%esp
f0112143:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112146:	74 15                	je     f011215d <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0112148:	83 ec 08             	sub    $0x8,%esp
f011214b:	ff 75 e8             	pushl  -0x18(%ebp)
f011214e:	68 20 97 12 f0       	push   $0xf0129720
f0112153:	e8 33 ee fe ff       	call   f0100f8b <cprintf>
f0112158:	83 c4 10             	add    $0x10,%esp
f011215b:	eb 04                	jmp    f0112161 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f011215d:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0112161:	c7 45 cc 83 97 12 f0 	movl   $0xf0129783,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0112168:	83 ec 08             	sub    $0x8,%esp
f011216b:	ff 75 cc             	pushl  -0x34(%ebp)
f011216e:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0112174:	50                   	push   %eax
f0112175:	e8 8b e5 00 00       	call   f0120705 <str2lower>
f011217a:	83 c4 10             	add    $0x10,%esp
f011217d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0112180:	83 ec 0c             	sub    $0xc,%esp
f0112183:	ff 75 e8             	pushl  -0x18(%ebp)
f0112186:	e8 91 de 00 00       	call   f012001c <strlen>
f011218b:	83 c4 10             	add    $0x10,%esp
f011218e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0112191:	83 ec 08             	sub    $0x8,%esp
f0112194:	68 9e 97 12 f0       	push   $0xf012979e
f0112199:	ff 75 e8             	pushl  -0x18(%ebp)
f011219c:	e8 87 df 00 00       	call   f0120128 <strcmp>
f01121a1:	83 c4 10             	add    $0x10,%esp
f01121a4:	85 c0                	test   %eax,%eax
f01121a6:	75 13                	jne    f01121bb <test_str2lower_function+0x343>
f01121a8:	83 ec 0c             	sub    $0xc,%esp
f01121ab:	ff 75 cc             	pushl  -0x34(%ebp)
f01121ae:	e8 69 de 00 00       	call   f012001c <strlen>
f01121b3:	83 c4 10             	add    $0x10,%esp
f01121b6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01121b9:	74 15                	je     f01121d0 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f01121bb:	83 ec 08             	sub    $0x8,%esp
f01121be:	ff 75 e8             	pushl  -0x18(%ebp)
f01121c1:	68 bc 97 12 f0       	push   $0xf01297bc
f01121c6:	e8 c0 ed fe ff       	call   f0100f8b <cprintf>
f01121cb:	83 c4 10             	add    $0x10,%esp
f01121ce:	eb 04                	jmp    f01121d4 <test_str2lower_function+0x35c>
	else
		eval += 20;
f01121d0:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f01121d4:	83 ec 08             	sub    $0x8,%esp
f01121d7:	ff 75 f4             	pushl  -0xc(%ebp)
f01121da:	68 30 98 12 f0       	push   $0xf0129830
f01121df:	e8 a7 ed fe ff       	call   f0100f8b <cprintf>
f01121e4:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f01121e7:	83 ec 0c             	sub    $0xc,%esp
f01121ea:	68 40 93 12 f0       	push   $0xf0129340
f01121ef:	e8 97 ed fe ff       	call   f0100f8b <cprintf>
f01121f4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01121f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01121fc:	c9                   	leave  
f01121fd:	c3                   	ret    

f01121fe <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f01121fe:	55                   	push   %ebp
f01121ff:	89 e5                	mov    %esp,%ebp
f0112201:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0112204:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f011220b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0112212:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112219:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011221e:	ff 75 ec             	pushl  -0x14(%ebp)
f0112221:	ff 75 f0             	pushl  -0x10(%ebp)
f0112224:	ff 75 f4             	pushl  -0xc(%ebp)
f0112227:	50                   	push   %eax
f0112228:	e8 7c 7d ff ff       	call   f0109fa9 <pt_set_page_permissions>
f011222d:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112230:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112235:	ff 75 ec             	pushl  -0x14(%ebp)
f0112238:	ff 75 f0             	pushl  -0x10(%ebp)
f011223b:	ff 75 f4             	pushl  -0xc(%ebp)
f011223e:	50                   	push   %eax
f011223f:	e8 74 4b 00 00       	call   f0116db8 <CP>
f0112244:	83 c4 10             	add    $0x10,%esp
f0112247:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011224a:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011224e:	74 17                	je     f0112267 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0112250:	83 ec 04             	sub    $0x4,%esp
f0112253:	68 60 98 12 f0       	push   $0xf0129860
f0112258:	68 23 01 00 00       	push   $0x123
f011225d:	68 82 98 12 f0       	push   $0xf0129882
f0112262:	e8 d2 e0 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0112267:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f011226e:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0112275:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011227c:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112281:	ff 75 ec             	pushl  -0x14(%ebp)
f0112284:	ff 75 f0             	pushl  -0x10(%ebp)
f0112287:	ff 75 f4             	pushl  -0xc(%ebp)
f011228a:	50                   	push   %eax
f011228b:	e8 19 7d ff ff       	call   f0109fa9 <pt_set_page_permissions>
f0112290:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112293:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112298:	ff 75 ec             	pushl  -0x14(%ebp)
f011229b:	ff 75 f0             	pushl  -0x10(%ebp)
f011229e:	ff 75 f4             	pushl  -0xc(%ebp)
f01122a1:	50                   	push   %eax
f01122a2:	e8 11 4b 00 00       	call   f0116db8 <CP>
f01122a7:	83 c4 10             	add    $0x10,%esp
f01122aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01122ad:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01122b1:	74 17                	je     f01122ca <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f01122b3:	83 ec 04             	sub    $0x4,%esp
f01122b6:	68 a0 98 12 f0       	push   $0xf01298a0
f01122bb:	68 2f 01 00 00       	push   $0x12f
f01122c0:	68 82 98 12 f0       	push   $0xf0129882
f01122c5:	e8 6f e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f01122ca:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f01122d1:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f01122d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01122df:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01122e4:	ff 75 ec             	pushl  -0x14(%ebp)
f01122e7:	ff 75 f0             	pushl  -0x10(%ebp)
f01122ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01122ed:	50                   	push   %eax
f01122ee:	e8 b6 7c ff ff       	call   f0109fa9 <pt_set_page_permissions>
f01122f3:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01122f6:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01122fb:	ff 75 ec             	pushl  -0x14(%ebp)
f01122fe:	ff 75 f0             	pushl  -0x10(%ebp)
f0112301:	ff 75 f4             	pushl  -0xc(%ebp)
f0112304:	50                   	push   %eax
f0112305:	e8 ae 4a 00 00       	call   f0116db8 <CP>
f011230a:	83 c4 10             	add    $0x10,%esp
f011230d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112310:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112314:	74 17                	je     f011232d <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0112316:	83 ec 04             	sub    $0x4,%esp
f0112319:	68 c4 98 12 f0       	push   $0xf01298c4
f011231e:	68 3a 01 00 00       	push   $0x13a
f0112323:	68 82 98 12 f0       	push   $0xf0129882
f0112328:	e8 0c e0 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f011232d:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0112334:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f011233b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112342:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112347:	ff 75 ec             	pushl  -0x14(%ebp)
f011234a:	ff 75 f0             	pushl  -0x10(%ebp)
f011234d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112350:	50                   	push   %eax
f0112351:	e8 53 7c ff ff       	call   f0109fa9 <pt_set_page_permissions>
f0112356:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112359:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011235e:	ff 75 ec             	pushl  -0x14(%ebp)
f0112361:	ff 75 f0             	pushl  -0x10(%ebp)
f0112364:	ff 75 f4             	pushl  -0xc(%ebp)
f0112367:	50                   	push   %eax
f0112368:	e8 4b 4a 00 00       	call   f0116db8 <CP>
f011236d:	83 c4 10             	add    $0x10,%esp
f0112370:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112373:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112377:	74 17                	je     f0112390 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0112379:	83 ec 04             	sub    $0x4,%esp
f011237c:	68 e8 98 12 f0       	push   $0xf01298e8
f0112381:	68 46 01 00 00       	push   $0x146
f0112386:	68 82 98 12 f0       	push   $0xf0129882
f011238b:	e8 a9 df fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0112390:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0112397:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f011239e:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01123a5:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01123aa:	ff 75 ec             	pushl  -0x14(%ebp)
f01123ad:	ff 75 f0             	pushl  -0x10(%ebp)
f01123b0:	ff 75 f4             	pushl  -0xc(%ebp)
f01123b3:	50                   	push   %eax
f01123b4:	e8 f0 7b ff ff       	call   f0109fa9 <pt_set_page_permissions>
f01123b9:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01123bc:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01123c1:	ff 75 ec             	pushl  -0x14(%ebp)
f01123c4:	ff 75 f0             	pushl  -0x10(%ebp)
f01123c7:	ff 75 f4             	pushl  -0xc(%ebp)
f01123ca:	50                   	push   %eax
f01123cb:	e8 e8 49 00 00       	call   f0116db8 <CP>
f01123d0:	83 c4 10             	add    $0x10,%esp
f01123d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01123d6:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01123da:	74 17                	je     f01123f3 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f01123dc:	83 ec 04             	sub    $0x4,%esp
f01123df:	68 0c 99 12 f0       	push   $0xf012990c
f01123e4:	68 52 01 00 00       	push   $0x152
f01123e9:	68 82 98 12 f0       	push   $0xf0129882
f01123ee:	e8 46 df fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f01123f3:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01123fa:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0112401:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112408:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011240d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112410:	ff 75 f0             	pushl  -0x10(%ebp)
f0112413:	ff 75 f4             	pushl  -0xc(%ebp)
f0112416:	50                   	push   %eax
f0112417:	e8 8d 7b ff ff       	call   f0109fa9 <pt_set_page_permissions>
f011241c:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011241f:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112424:	ff 75 ec             	pushl  -0x14(%ebp)
f0112427:	ff 75 f0             	pushl  -0x10(%ebp)
f011242a:	ff 75 f4             	pushl  -0xc(%ebp)
f011242d:	50                   	push   %eax
f011242e:	e8 85 49 00 00       	call   f0116db8 <CP>
f0112433:	83 c4 10             	add    $0x10,%esp
f0112436:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112439:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011243d:	74 17                	je     f0112456 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f011243f:	83 ec 04             	sub    $0x4,%esp
f0112442:	68 30 99 12 f0       	push   $0xf0129930
f0112447:	68 5e 01 00 00       	push   $0x15e
f011244c:	68 82 98 12 f0       	push   $0xf0129882
f0112451:	e8 e3 de fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112456:	83 ec 0c             	sub    $0xc,%esp
f0112459:	68 5c 99 12 f0       	push   $0xf012995c
f011245e:	e8 28 eb fe ff       	call   f0100f8b <cprintf>
f0112463:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112466:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011246b:	c9                   	leave  
f011246c:	c3                   	ret    

f011246d <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f011246d:	55                   	push   %ebp
f011246e:	89 e5                	mov    %esp,%ebp
f0112470:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0112473:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f011247a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0112481:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112488:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011248d:	ff 75 ec             	pushl  -0x14(%ebp)
f0112490:	ff 75 f0             	pushl  -0x10(%ebp)
f0112493:	ff 75 f4             	pushl  -0xc(%ebp)
f0112496:	50                   	push   %eax
f0112497:	e8 0d 7b ff ff       	call   f0109fa9 <pt_set_page_permissions>
f011249c:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f011249f:	83 ec 04             	sub    $0x4,%esp
f01124a2:	68 ac 99 12 f0       	push   $0xf01299ac
f01124a7:	68 6b 01 00 00       	push   $0x16b
f01124ac:	68 82 98 12 f0       	push   $0xf0129882
f01124b1:	e8 83 de fe ff       	call   f0100339 <_panic>

f01124b6 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f01124b6:	55                   	push   %ebp
f01124b7:	89 e5                	mov    %esp,%ebp
f01124b9:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f01124bc:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f01124c3:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01124c8:	83 ec 08             	sub    $0x8,%esp
f01124cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01124ce:	50                   	push   %eax
f01124cf:	e8 99 7b ff ff       	call   f010a06d <pt_get_page_permissions>
f01124d4:	83 c4 10             	add    $0x10,%esp
f01124d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f01124da:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f01124de:	74 17                	je     f01124f7 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f01124e0:	83 ec 04             	sub    $0x4,%esp
f01124e3:	68 48 9a 12 f0       	push   $0xf0129a48
f01124e8:	68 79 01 00 00       	push   $0x179
f01124ed:	68 82 98 12 f0       	push   $0xf0129882
f01124f2:	e8 42 de fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01124f7:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01124fe:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112503:	83 ec 08             	sub    $0x8,%esp
f0112506:	ff 75 f4             	pushl  -0xc(%ebp)
f0112509:	50                   	push   %eax
f011250a:	e8 5e 7b ff ff       	call   f010a06d <pt_get_page_permissions>
f011250f:	83 c4 10             	add    $0x10,%esp
f0112512:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0112515:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112519:	74 17                	je     f0112532 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f011251b:	83 ec 04             	sub    $0x4,%esp
f011251e:	68 6c 9a 12 f0       	push   $0xf0129a6c
f0112523:	68 81 01 00 00       	push   $0x181
f0112528:	68 82 98 12 f0       	push   $0xf0129882
f011252d:	e8 07 de fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0112532:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112539:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011253e:	83 ec 08             	sub    $0x8,%esp
f0112541:	ff 75 f4             	pushl  -0xc(%ebp)
f0112544:	50                   	push   %eax
f0112545:	e8 23 7b ff ff       	call   f010a06d <pt_get_page_permissions>
f011254a:	83 c4 10             	add    $0x10,%esp
f011254d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112550:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112554:	74 17                	je     f011256d <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112556:	83 ec 04             	sub    $0x4,%esp
f0112559:	68 90 9a 12 f0       	push   $0xf0129a90
f011255e:	68 89 01 00 00       	push   $0x189
f0112563:	68 82 98 12 f0       	push   $0xf0129882
f0112568:	e8 cc dd fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f011256d:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112574:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112579:	83 ec 08             	sub    $0x8,%esp
f011257c:	ff 75 f4             	pushl  -0xc(%ebp)
f011257f:	50                   	push   %eax
f0112580:	e8 e8 7a ff ff       	call   f010a06d <pt_get_page_permissions>
f0112585:	83 c4 10             	add    $0x10,%esp
f0112588:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011258b:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011258f:	74 17                	je     f01125a8 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0112591:	83 ec 04             	sub    $0x4,%esp
f0112594:	68 b4 9a 12 f0       	push   $0xf0129ab4
f0112599:	68 90 01 00 00       	push   $0x190
f011259e:	68 82 98 12 f0       	push   $0xf0129882
f01125a3:	e8 91 dd fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01125a8:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01125af:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01125b4:	83 ec 08             	sub    $0x8,%esp
f01125b7:	ff 75 f4             	pushl  -0xc(%ebp)
f01125ba:	50                   	push   %eax
f01125bb:	e8 ad 7a ff ff       	call   f010a06d <pt_get_page_permissions>
f01125c0:	83 c4 10             	add    $0x10,%esp
f01125c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f01125c6:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f01125ca:	74 17                	je     f01125e3 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f01125cc:	83 ec 04             	sub    $0x4,%esp
f01125cf:	68 d8 9a 12 f0       	push   $0xf0129ad8
f01125d4:	68 97 01 00 00       	push   $0x197
f01125d9:	68 82 98 12 f0       	push   $0xf0129882
f01125de:	e8 56 dd fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f01125e3:	83 ec 0c             	sub    $0xc,%esp
f01125e6:	68 fc 9a 12 f0       	push   $0xf0129afc
f01125eb:	e8 9b e9 fe ff       	call   f0100f8b <cprintf>
f01125f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01125f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01125f8:	c9                   	leave  
f01125f9:	c3                   	ret    

f01125fa <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f01125fa:	55                   	push   %ebp
f01125fb:	89 e5                	mov    %esp,%ebp
f01125fd:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0112600:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112607:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011260c:	83 ec 08             	sub    $0x8,%esp
f011260f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112612:	50                   	push   %eax
f0112613:	e8 9e 7a ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f0112618:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f011261b:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112620:	83 ec 08             	sub    $0x8,%esp
f0112623:	ff 75 f4             	pushl  -0xc(%ebp)
f0112626:	50                   	push   %eax
f0112627:	e8 e8 46 00 00       	call   f0116d14 <CE>
f011262c:	83 c4 10             	add    $0x10,%esp
f011262f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112632:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112636:	74 17                	je     f011264f <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0112638:	83 ec 04             	sub    $0x4,%esp
f011263b:	68 44 9b 12 f0       	push   $0xf0129b44
f0112640:	68 a7 01 00 00       	push   $0x1a7
f0112645:	68 82 98 12 f0       	push   $0xf0129882
f011264a:	e8 ea dc fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f011264f:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112656:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011265b:	83 ec 08             	sub    $0x8,%esp
f011265e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112661:	50                   	push   %eax
f0112662:	e8 4f 7a ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f0112667:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f011266a:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011266f:	83 ec 08             	sub    $0x8,%esp
f0112672:	ff 75 f4             	pushl  -0xc(%ebp)
f0112675:	50                   	push   %eax
f0112676:	e8 99 46 00 00       	call   f0116d14 <CE>
f011267b:	83 c4 10             	add    $0x10,%esp
f011267e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112681:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112685:	74 17                	je     f011269e <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112687:	83 ec 04             	sub    $0x4,%esp
f011268a:	68 70 9b 12 f0       	push   $0xf0129b70
f011268f:	68 af 01 00 00       	push   $0x1af
f0112694:	68 82 98 12 f0       	push   $0xf0129882
f0112699:	e8 9b dc fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f011269e:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01126a5:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01126aa:	83 ec 08             	sub    $0x8,%esp
f01126ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01126b0:	50                   	push   %eax
f01126b1:	e8 00 7a ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f01126b6:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01126b9:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01126be:	83 ec 08             	sub    $0x8,%esp
f01126c1:	ff 75 f4             	pushl  -0xc(%ebp)
f01126c4:	50                   	push   %eax
f01126c5:	e8 4a 46 00 00       	call   f0116d14 <CE>
f01126ca:	83 c4 10             	add    $0x10,%esp
f01126cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01126d0:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01126d4:	74 17                	je     f01126ed <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f01126d6:	83 ec 04             	sub    $0x4,%esp
f01126d9:	68 9c 9b 12 f0       	push   $0xf0129b9c
f01126de:	68 b7 01 00 00       	push   $0x1b7
f01126e3:	68 82 98 12 f0       	push   $0xf0129882
f01126e8:	e8 4c dc fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f01126ed:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01126f4:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f01126f9:	83 ec 08             	sub    $0x8,%esp
f01126fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01126ff:	50                   	push   %eax
f0112700:	e8 b1 79 ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f0112705:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112708:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011270d:	83 ec 08             	sub    $0x8,%esp
f0112710:	ff 75 f4             	pushl  -0xc(%ebp)
f0112713:	50                   	push   %eax
f0112714:	e8 fb 45 00 00       	call   f0116d14 <CE>
f0112719:	83 c4 10             	add    $0x10,%esp
f011271c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011271f:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112723:	74 17                	je     f011273c <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0112725:	83 ec 04             	sub    $0x4,%esp
f0112728:	68 c8 9b 12 f0       	push   $0xf0129bc8
f011272d:	68 bf 01 00 00       	push   $0x1bf
f0112732:	68 82 98 12 f0       	push   $0xf0129882
f0112737:	e8 fd db fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f011273c:	83 ec 0c             	sub    $0xc,%esp
f011273f:	68 f4 9b 12 f0       	push   $0xf0129bf4
f0112744:	e8 42 e8 fe ff       	call   f0100f8b <cprintf>
f0112749:	83 c4 10             	add    $0x10,%esp
	return 0;
f011274c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112751:	c9                   	leave  
f0112752:	c3                   	ret    

f0112753 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0112753:	55                   	push   %ebp
f0112754:	89 e5                	mov    %esp,%ebp
f0112756:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112759:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112760:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0112765:	83 ec 08             	sub    $0x8,%esp
f0112768:	ff 75 f4             	pushl  -0xc(%ebp)
f011276b:	50                   	push   %eax
f011276c:	e8 45 79 ff ff       	call   f010a0b6 <pt_clear_page_table_entry>
f0112771:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0112774:	83 ec 04             	sub    $0x4,%esp
f0112777:	68 40 9c 12 f0       	push   $0xf0129c40
f011277c:	68 ca 01 00 00       	push   $0x1ca
f0112781:	68 82 98 12 f0       	push   $0xf0129882
f0112786:	e8 ae db fe ff       	call   f0100339 <_panic>

f011278b <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f011278b:	55                   	push   %ebp
f011278c:	89 e5                	mov    %esp,%ebp
f011278e:	57                   	push   %edi
f011278f:	56                   	push   %esi
f0112790:	53                   	push   %ebx
f0112791:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112797:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011279d:	bb 84 9f 12 f0       	mov    $0xf0129f84,%ebx
f01127a2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01127a7:	89 c7                	mov    %eax,%edi
f01127a9:	89 de                	mov    %ebx,%esi
f01127ab:	89 d1                	mov    %edx,%ecx
f01127ad:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01127af:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01127b5:	b9 23 00 00 00       	mov    $0x23,%ecx
f01127ba:	b0 00                	mov    $0x0,%al
f01127bc:	89 d7                	mov    %edx,%edi
f01127be:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01127c0:	6a 00                	push   $0x0
f01127c2:	6a 0a                	push   $0xa
f01127c4:	6a 14                	push   $0x14
f01127c6:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01127cc:	50                   	push   %eax
f01127cd:	e8 d5 8a ff ff       	call   f010b2a7 <env_create>
f01127d2:	83 c4 10             	add    $0x10,%esp
f01127d5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01127d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01127db:	8b 40 64             	mov    0x64(%eax),%eax
f01127de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01127e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01127e4:	8b 40 68             	mov    0x68(%eax),%eax
f01127e7:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01127ea:	8b 45 90             	mov    -0x70(%ebp),%eax
f01127ed:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01127f0:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f01127f7:	75 70 20 
f01127fa:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112801:	00 00 00 
f0112804:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f011280a:	b9 03 00 00 00       	mov    $0x3,%ecx
f011280f:	b8 00 00 00 00       	mov    $0x0,%eax
f0112814:	89 d7                	mov    %edx,%edi
f0112816:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112818:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011281b:	8b 40 10             	mov    0x10(%eax),%eax
f011281e:	83 ec 08             	sub    $0x8,%esp
f0112821:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112827:	52                   	push   %edx
f0112828:	50                   	push   %eax
f0112829:	e8 94 dc 00 00       	call   f01204c2 <ltostr>
f011282e:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112831:	83 ec 04             	sub    $0x4,%esp
f0112834:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011283a:	50                   	push   %eax
f011283b:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0112841:	50                   	push   %eax
f0112842:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112848:	50                   	push   %eax
f0112849:	e8 4d dd 00 00       	call   f012059b <strcconcat>
f011284e:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112851:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0112858:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f011285f:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0112866:	83 ec 0c             	sub    $0xc,%esp
f0112869:	ff 75 d4             	pushl  -0x2c(%ebp)
f011286c:	e8 85 45 00 00       	call   f0116df6 <ClearUserSpace>
f0112871:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0112874:	83 ec 04             	sub    $0x4,%esp
f0112877:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011287d:	50                   	push   %eax
f011287e:	68 d6 9c 12 f0       	push   $0xf0129cd6
f0112883:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112889:	50                   	push   %eax
f011288a:	e8 0c dd 00 00       	call   f012059b <strcconcat>
f011288f:	83 c4 10             	add    $0x10,%esp
f0112892:	83 ec 0c             	sub    $0xc,%esp
f0112895:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f011289b:	50                   	push   %eax
f011289c:	e8 5a f6 fe ff       	call   f0101efb <execute_command>
f01128a1:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01128a4:	83 ec 04             	sub    $0x4,%esp
f01128a7:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01128ad:	50                   	push   %eax
f01128ae:	68 e1 9c 12 f0       	push   $0xf0129ce1
f01128b3:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01128b9:	50                   	push   %eax
f01128ba:	e8 dc dc 00 00       	call   f012059b <strcconcat>
f01128bf:	83 c4 10             	add    $0x10,%esp
f01128c2:	83 ec 0c             	sub    $0xc,%esp
f01128c5:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01128cb:	50                   	push   %eax
f01128cc:	e8 2a f6 fe ff       	call   f0101efb <execute_command>
f01128d1:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f01128d4:	83 ec 04             	sub    $0x4,%esp
f01128d7:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01128dd:	50                   	push   %eax
f01128de:	68 ec 9c 12 f0       	push   $0xf0129cec
f01128e3:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01128e9:	50                   	push   %eax
f01128ea:	e8 ac dc 00 00       	call   f012059b <strcconcat>
f01128ef:	83 c4 10             	add    $0x10,%esp
f01128f2:	83 ec 0c             	sub    $0xc,%esp
f01128f5:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01128fb:	50                   	push   %eax
f01128fc:	e8 fa f5 fe ff       	call   f0101efb <execute_command>
f0112901:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0112904:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f011290b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011290e:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0112911:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0112918:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011291b:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f011291e:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0112925:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112928:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f011292b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011292e:	83 ec 08             	sub    $0x8,%esp
f0112931:	50                   	push   %eax
f0112932:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112935:	e8 9d 44 00 00       	call   f0116dd7 <GP>
f011293a:	83 c4 10             	add    $0x10,%esp
f011293d:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0112940:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0112947:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f011294e:	e8 f5 c2 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112953:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0112956:	83 ec 0c             	sub    $0xc,%esp
f0112959:	68 f8 9c 12 f0       	push   $0xf0129cf8
f011295e:	e8 28 e6 fe ff       	call   f0100f8b <cprintf>
f0112963:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0112966:	6a 03                	push   $0x3
f0112968:	68 00 00 90 02       	push   $0x2900000
f011296d:	68 00 00 80 02       	push   $0x2800000
f0112972:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112975:	e8 b0 84 ff ff       	call   f010ae2a <cut_paste_pages>
f011297a:	83 c4 10             	add    $0x10,%esp
f011297d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112980:	e8 c3 c2 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112985:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112988:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f011298f:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112993:	75 08                	jne    f011299d <test_cut_paste_pages+0x212>
f0112995:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112998:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011299b:	74 2b                	je     f01129c8 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f011299d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01129a0:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01129a3:	83 ec 0c             	sub    $0xc,%esp
f01129a6:	50                   	push   %eax
f01129a7:	ff 75 b4             	pushl  -0x4c(%ebp)
f01129aa:	68 28 9d 12 f0       	push   $0xf0129d28
f01129af:	68 04 02 00 00       	push   $0x204
f01129b4:	68 82 98 12 f0       	push   $0xf0129882
f01129b9:	e8 18 db fe ff       	call   f01004d6 <_warn>
f01129be:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01129c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f01129c8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01129cc:	74 04                	je     f01129d2 <test_cut_paste_pages+0x247>
f01129ce:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01129d2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01129d9:	83 ec 08             	sub    $0x8,%esp
f01129dc:	6a 00                	push   $0x0
f01129de:	6a 01                	push   $0x1
f01129e0:	6a 00                	push   $0x0
f01129e2:	68 ff 0f 00 00       	push   $0xfff
f01129e7:	ff 75 bc             	pushl  -0x44(%ebp)
f01129ea:	6a 01                	push   $0x1
f01129ec:	68 00 30 00 00       	push   $0x3000
f01129f1:	68 00 00 90 02       	push   $0x2900000
f01129f6:	68 00 00 80 02       	push   $0x2800000
f01129fb:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129fe:	e8 27 44 00 00       	call   f0116e2a <CCP>
f0112a03:	83 c4 30             	add    $0x30,%esp
f0112a06:	83 f8 01             	cmp    $0x1,%eax
f0112a09:	74 21                	je     f0112a2c <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112a0b:	83 ec 04             	sub    $0x4,%esp
f0112a0e:	68 7c 9d 12 f0       	push   $0xf0129d7c
f0112a13:	68 0c 02 00 00       	push   $0x20c
f0112a18:	68 82 98 12 f0       	push   $0xf0129882
f0112a1d:	e8 b4 da fe ff       	call   f01004d6 <_warn>
f0112a22:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112a25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112a2c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a30:	74 04                	je     f0112a36 <test_cut_paste_pages+0x2ab>
f0112a32:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0112a36:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0112a3d:	83 ec 04             	sub    $0x4,%esp
f0112a40:	6a 00                	push   $0x0
f0112a42:	68 00 00 90 02       	push   $0x2900000
f0112a47:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a4a:	e8 b7 41 00 00       	call   f0116c06 <CB>
f0112a4f:	83 c4 10             	add    $0x10,%esp
f0112a52:	85 c0                	test   %eax,%eax
f0112a54:	0f 84 f6 00 00 00    	je     f0112b50 <test_cut_paste_pages+0x3c5>
f0112a5a:	83 ec 04             	sub    $0x4,%esp
f0112a5d:	6a 00                	push   $0x0
f0112a5f:	68 00 10 90 02       	push   $0x2901000
f0112a64:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a67:	e8 9a 41 00 00       	call   f0116c06 <CB>
f0112a6c:	83 c4 10             	add    $0x10,%esp
f0112a6f:	85 c0                	test   %eax,%eax
f0112a71:	0f 84 d9 00 00 00    	je     f0112b50 <test_cut_paste_pages+0x3c5>
f0112a77:	83 ec 04             	sub    $0x4,%esp
f0112a7a:	6a 00                	push   $0x0
f0112a7c:	68 00 20 90 02       	push   $0x2902000
f0112a81:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a84:	e8 7d 41 00 00       	call   f0116c06 <CB>
f0112a89:	83 c4 10             	add    $0x10,%esp
f0112a8c:	85 c0                	test   %eax,%eax
f0112a8e:	0f 84 bc 00 00 00    	je     f0112b50 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0112a94:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112a9b:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112aa2:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112aa9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112aac:	8a 00                	mov    (%eax),%al
f0112aae:	3c 61                	cmp    $0x61,%al
f0112ab0:	75 12                	jne    f0112ac4 <test_cut_paste_pages+0x339>
f0112ab2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112ab5:	8a 00                	mov    (%eax),%al
f0112ab7:	3c 62                	cmp    $0x62,%al
f0112ab9:	75 09                	jne    f0112ac4 <test_cut_paste_pages+0x339>
f0112abb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112abe:	8a 00                	mov    (%eax),%al
f0112ac0:	3c 63                	cmp    $0x63,%al
f0112ac2:	74 21                	je     f0112ae5 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112ac4:	83 ec 04             	sub    $0x4,%esp
f0112ac7:	68 c8 9d 12 f0       	push   $0xf0129dc8
f0112acc:	68 19 02 00 00       	push   $0x219
f0112ad1:	68 82 98 12 f0       	push   $0xf0129882
f0112ad6:	e8 fb d9 fe ff       	call   f01004d6 <_warn>
f0112adb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112ade:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112ae5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ae9:	74 04                	je     f0112aef <test_cut_paste_pages+0x364>
f0112aeb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112aef:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0112af6:	83 ec 04             	sub    $0x4,%esp
f0112af9:	6a 01                	push   $0x1
f0112afb:	68 00 10 90 02       	push   $0x2901000
f0112b00:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b03:	e8 fe 40 00 00       	call   f0116c06 <CB>
f0112b08:	83 c4 10             	add    $0x10,%esp
f0112b0b:	85 c0                	test   %eax,%eax
f0112b0d:	74 41                	je     f0112b50 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0112b0f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112b12:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0112b15:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112b18:	8a 00                	mov    (%eax),%al
f0112b1a:	3c 79                	cmp    $0x79,%al
f0112b1c:	74 21                	je     f0112b3f <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112b1e:	83 ec 04             	sub    $0x4,%esp
f0112b21:	68 c8 9d 12 f0       	push   $0xf0129dc8
f0112b26:	68 24 02 00 00       	push   $0x224
f0112b2b:	68 82 98 12 f0       	push   $0xf0129882
f0112b30:	e8 a1 d9 fe ff       	call   f01004d6 <_warn>
f0112b35:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112b38:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112b3f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b43:	74 04                	je     f0112b49 <test_cut_paste_pages+0x3be>
f0112b45:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112b49:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112b50:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112b53:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112b56:	6a 02                	push   $0x2
f0112b58:	68 00 f0 bf 02       	push   $0x2bff000
f0112b5d:	68 00 10 90 02       	push   $0x2901000
f0112b62:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b65:	e8 c0 82 ff ff       	call   f010ae2a <cut_paste_pages>
f0112b6a:	83 c4 10             	add    $0x10,%esp
f0112b6d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112b70:	e8 d3 c0 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112b75:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112b78:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112b7c:	75 0b                	jne    f0112b89 <test_cut_paste_pages+0x3fe>
f0112b7e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112b81:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112b84:	83 f8 01             	cmp    $0x1,%eax
f0112b87:	74 2b                	je     f0112bb4 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112b89:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112b8c:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112b8f:	83 ec 0c             	sub    $0xc,%esp
f0112b92:	50                   	push   %eax
f0112b93:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112b96:	68 28 9d 12 f0       	push   $0xf0129d28
f0112b9b:	68 35 02 00 00       	push   $0x235
f0112ba0:	68 82 98 12 f0       	push   $0xf0129882
f0112ba5:	e8 2c d9 fe ff       	call   f01004d6 <_warn>
f0112baa:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112bad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112bb4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112bb8:	74 04                	je     f0112bbe <test_cut_paste_pages+0x433>
f0112bba:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112bbe:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112bc5:	83 ec 08             	sub    $0x8,%esp
f0112bc8:	6a 00                	push   $0x0
f0112bca:	6a 01                	push   $0x1
f0112bcc:	6a 00                	push   $0x0
f0112bce:	68 ff 0f 00 00       	push   $0xfff
f0112bd3:	ff 75 bc             	pushl  -0x44(%ebp)
f0112bd6:	6a 01                	push   $0x1
f0112bd8:	68 00 20 00 00       	push   $0x2000
f0112bdd:	68 00 f0 bf 02       	push   $0x2bff000
f0112be2:	68 00 10 90 02       	push   $0x2901000
f0112be7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bea:	e8 3b 42 00 00       	call   f0116e2a <CCP>
f0112bef:	83 c4 30             	add    $0x30,%esp
f0112bf2:	83 f8 01             	cmp    $0x1,%eax
f0112bf5:	74 21                	je     f0112c18 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112bf7:	83 ec 04             	sub    $0x4,%esp
f0112bfa:	68 7c 9d 12 f0       	push   $0xf0129d7c
f0112bff:	68 3d 02 00 00       	push   $0x23d
f0112c04:	68 82 98 12 f0       	push   $0xf0129882
f0112c09:	e8 c8 d8 fe ff       	call   f01004d6 <_warn>
f0112c0e:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112c11:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112c18:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c1c:	74 04                	je     f0112c22 <test_cut_paste_pages+0x497>
f0112c1e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112c22:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112c29:	83 ec 04             	sub    $0x4,%esp
f0112c2c:	6a 00                	push   $0x0
f0112c2e:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112c33:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c36:	e8 cb 3f 00 00       	call   f0116c06 <CB>
f0112c3b:	83 c4 10             	add    $0x10,%esp
f0112c3e:	85 c0                	test   %eax,%eax
f0112c40:	74 6b                	je     f0112cad <test_cut_paste_pages+0x522>
f0112c42:	83 ec 04             	sub    $0x4,%esp
f0112c45:	6a 00                	push   $0x0
f0112c47:	68 ff 0f c0 02       	push   $0x2c00fff
f0112c4c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c4f:	e8 b2 3f 00 00       	call   f0116c06 <CB>
f0112c54:	83 c4 10             	add    $0x10,%esp
f0112c57:	85 c0                	test   %eax,%eax
f0112c59:	74 52                	je     f0112cad <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112c5b:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112c62:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112c69:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112c6c:	8a 00                	mov    (%eax),%al
f0112c6e:	3c 79                	cmp    $0x79,%al
f0112c70:	75 09                	jne    f0112c7b <test_cut_paste_pages+0x4f0>
f0112c72:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112c75:	8a 00                	mov    (%eax),%al
f0112c77:	3c 63                	cmp    $0x63,%al
f0112c79:	74 21                	je     f0112c9c <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112c7b:	83 ec 04             	sub    $0x4,%esp
f0112c7e:	68 c8 9d 12 f0       	push   $0xf0129dc8
f0112c83:	68 49 02 00 00       	push   $0x249
f0112c88:	68 82 98 12 f0       	push   $0xf0129882
f0112c8d:	e8 44 d8 fe ff       	call   f01004d6 <_warn>
f0112c92:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112c95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112c9c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ca0:	74 04                	je     f0112ca6 <test_cut_paste_pages+0x51b>
f0112ca2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112ca6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112cad:	83 ec 0c             	sub    $0xc,%esp
f0112cb0:	68 01 9e 12 f0       	push   $0xf0129e01
f0112cb5:	e8 d1 e2 fe ff       	call   f0100f8b <cprintf>
f0112cba:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112cbd:	83 ec 0c             	sub    $0xc,%esp
f0112cc0:	68 10 9e 12 f0       	push   $0xf0129e10
f0112cc5:	e8 c1 e2 fe ff       	call   f0100f8b <cprintf>
f0112cca:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112ccd:	83 ec 04             	sub    $0x4,%esp
f0112cd0:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112cd6:	50                   	push   %eax
f0112cd7:	68 39 9e 12 f0       	push   $0xf0129e39
f0112cdc:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112ce2:	50                   	push   %eax
f0112ce3:	e8 b3 d8 00 00       	call   f012059b <strcconcat>
f0112ce8:	83 c4 10             	add    $0x10,%esp
f0112ceb:	83 ec 0c             	sub    $0xc,%esp
f0112cee:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112cf4:	50                   	push   %eax
f0112cf5:	e8 01 f2 fe ff       	call   f0101efb <execute_command>
f0112cfa:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0112cfd:	83 ec 04             	sub    $0x4,%esp
f0112d00:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112d06:	50                   	push   %eax
f0112d07:	68 44 9e 12 f0       	push   $0xf0129e44
f0112d0c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112d12:	50                   	push   %eax
f0112d13:	e8 83 d8 00 00       	call   f012059b <strcconcat>
f0112d18:	83 c4 10             	add    $0x10,%esp
f0112d1b:	83 ec 0c             	sub    $0xc,%esp
f0112d1e:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112d24:	50                   	push   %eax
f0112d25:	e8 d1 f1 fe ff       	call   f0101efb <execute_command>
f0112d2a:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112d2d:	83 ec 04             	sub    $0x4,%esp
f0112d30:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112d36:	50                   	push   %eax
f0112d37:	68 4f 9e 12 f0       	push   $0xf0129e4f
f0112d3c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112d42:	50                   	push   %eax
f0112d43:	e8 53 d8 00 00       	call   f012059b <strcconcat>
f0112d48:	83 c4 10             	add    $0x10,%esp
f0112d4b:	83 ec 0c             	sub    $0xc,%esp
f0112d4e:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112d54:	50                   	push   %eax
f0112d55:	e8 a1 f1 fe ff       	call   f0101efb <execute_command>
f0112d5a:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112d5d:	83 ec 04             	sub    $0x4,%esp
f0112d60:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112d66:	50                   	push   %eax
f0112d67:	68 5a 9e 12 f0       	push   $0xf0129e5a
f0112d6c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112d72:	50                   	push   %eax
f0112d73:	e8 23 d8 00 00       	call   f012059b <strcconcat>
f0112d78:	83 c4 10             	add    $0x10,%esp
f0112d7b:	83 ec 0c             	sub    $0xc,%esp
f0112d7e:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112d84:	50                   	push   %eax
f0112d85:	e8 71 f1 fe ff       	call   f0101efb <execute_command>
f0112d8a:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112d8d:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112d94:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112d97:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112d9a:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112da1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112da4:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112da7:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112dae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112db1:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112db4:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112dbb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112dbe:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112dc1:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112dc8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112dcb:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112dce:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112dd5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112dd8:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112ddb:	83 ec 08             	sub    $0x8,%esp
f0112dde:	68 00 00 c0 01       	push   $0x1c00000
f0112de3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112de6:	e8 ec 3f 00 00       	call   f0116dd7 <GP>
f0112deb:	83 c4 10             	add    $0x10,%esp
f0112dee:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112df1:	83 ec 08             	sub    $0x8,%esp
f0112df4:	68 00 00 40 01       	push   $0x1400000
f0112df9:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112dfc:	e8 d6 3f 00 00       	call   f0116dd7 <GP>
f0112e01:	83 c4 10             	add    $0x10,%esp
f0112e04:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112e07:	e8 3c be ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112e0c:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112e0f:	6a 01                	push   $0x1
f0112e11:	68 00 00 40 01       	push   $0x1400000
f0112e16:	68 00 00 c0 01       	push   $0x1c00000
f0112e1b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112e1e:	e8 07 80 ff ff       	call   f010ae2a <cut_paste_pages>
f0112e23:	83 c4 10             	add    $0x10,%esp
f0112e26:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112e29:	e8 1a be ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112e2e:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112e31:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112e35:	75 08                	jne    f0112e3f <test_cut_paste_pages+0x6b4>
f0112e37:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112e3a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112e3d:	74 2b                	je     f0112e6a <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112e3f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112e42:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112e45:	83 ec 0c             	sub    $0xc,%esp
f0112e48:	50                   	push   %eax
f0112e49:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112e4c:	68 68 9e 12 f0       	push   $0xf0129e68
f0112e51:	68 6c 02 00 00       	push   $0x26c
f0112e56:	68 82 98 12 f0       	push   $0xf0129882
f0112e5b:	e8 76 d6 fe ff       	call   f01004d6 <_warn>
f0112e60:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112e63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112e6a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112e6e:	74 04                	je     f0112e74 <test_cut_paste_pages+0x6e9>
f0112e70:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112e74:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112e7b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112e82:	83 ec 08             	sub    $0x8,%esp
f0112e85:	6a 00                	push   $0x0
f0112e87:	68 ff 0f 00 00       	push   $0xfff
f0112e8c:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112e8f:	68 ff 0f 00 00       	push   $0xfff
f0112e94:	ff 75 a0             	pushl  -0x60(%ebp)
f0112e97:	6a 01                	push   $0x1
f0112e99:	68 00 10 00 00       	push   $0x1000
f0112e9e:	68 00 00 40 01       	push   $0x1400000
f0112ea3:	68 00 00 c0 01       	push   $0x1c00000
f0112ea8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112eab:	e8 7a 3f 00 00       	call   f0116e2a <CCP>
f0112eb0:	83 c4 30             	add    $0x30,%esp
f0112eb3:	83 f8 01             	cmp    $0x1,%eax
f0112eb6:	74 28                	je     f0112ee0 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112eb8:	83 ec 04             	sub    $0x4,%esp
f0112ebb:	68 7c 9d 12 f0       	push   $0xf0129d7c
f0112ec0:	68 75 02 00 00       	push   $0x275
f0112ec5:	68 82 98 12 f0       	push   $0xf0129882
f0112eca:	e8 07 d6 fe ff       	call   f01004d6 <_warn>
f0112ecf:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112ed2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112ed9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112ee0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ee4:	74 04                	je     f0112eea <test_cut_paste_pages+0x75f>
f0112ee6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112eea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112ef1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112ef5:	0f 84 92 00 00 00    	je     f0112f8d <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0112efb:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112f02:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112f09:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112f10:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112f17:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112f1e:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112f25:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112f28:	8a 00                	mov    (%eax),%al
f0112f2a:	3c 61                	cmp    $0x61,%al
f0112f2c:	75 2d                	jne    f0112f5b <test_cut_paste_pages+0x7d0>
f0112f2e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112f31:	8a 00                	mov    (%eax),%al
f0112f33:	3c 78                	cmp    $0x78,%al
f0112f35:	75 24                	jne    f0112f5b <test_cut_paste_pages+0x7d0>
f0112f37:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112f3a:	8a 00                	mov    (%eax),%al
f0112f3c:	3c 62                	cmp    $0x62,%al
f0112f3e:	75 1b                	jne    f0112f5b <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112f40:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112f43:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112f45:	3c 79                	cmp    $0x79,%al
f0112f47:	75 12                	jne    f0112f5b <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112f49:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112f4c:	8a 00                	mov    (%eax),%al
f0112f4e:	3c 63                	cmp    $0x63,%al
f0112f50:	75 09                	jne    f0112f5b <test_cut_paste_pages+0x7d0>
f0112f52:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112f55:	8a 00                	mov    (%eax),%al
f0112f57:	3c 7a                	cmp    $0x7a,%al
f0112f59:	74 21                	je     f0112f7c <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112f5b:	83 ec 04             	sub    $0x4,%esp
f0112f5e:	68 c8 9d 12 f0       	push   $0xf0129dc8
f0112f63:	68 87 02 00 00       	push   $0x287
f0112f68:	68 82 98 12 f0       	push   $0xf0129882
f0112f6d:	e8 64 d5 fe ff       	call   f01004d6 <_warn>
f0112f72:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112f75:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112f7c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112f80:	74 04                	je     f0112f86 <test_cut_paste_pages+0x7fb>
f0112f82:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112f86:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112f8d:	e8 b6 bc ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112f92:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0112f95:	6a 03                	push   $0x3
f0112f97:	68 00 f0 bf 01       	push   $0x1bff000
f0112f9c:	68 00 00 40 01       	push   $0x1400000
f0112fa1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112fa4:	e8 81 7e ff ff       	call   f010ae2a <cut_paste_pages>
f0112fa9:	83 c4 10             	add    $0x10,%esp
f0112fac:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112faf:	e8 94 bc ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0112fb4:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112fb7:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112fbb:	75 08                	jne    f0112fc5 <test_cut_paste_pages+0x83a>
f0112fbd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112fc0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112fc3:	74 2b                	je     f0112ff0 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112fc5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112fc8:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112fcb:	83 ec 0c             	sub    $0xc,%esp
f0112fce:	50                   	push   %eax
f0112fcf:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112fd2:	68 68 9e 12 f0       	push   $0xf0129e68
f0112fd7:	68 96 02 00 00       	push   $0x296
f0112fdc:	68 82 98 12 f0       	push   $0xf0129882
f0112fe1:	e8 f0 d4 fe ff       	call   f01004d6 <_warn>
f0112fe6:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112fe9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112ff0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ff4:	74 04                	je     f0112ffa <test_cut_paste_pages+0x86f>
f0112ff6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112ffa:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0113001:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0113008:	83 ec 04             	sub    $0x4,%esp
f011300b:	6a 00                	push   $0x0
f011300d:	68 00 00 40 01       	push   $0x1400000
f0113012:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113015:	e8 ec 3b 00 00       	call   f0116c06 <CB>
f011301a:	83 c4 10             	add    $0x10,%esp
f011301d:	83 f8 01             	cmp    $0x1,%eax
f0113020:	0f 85 80 00 00 00    	jne    f01130a6 <test_cut_paste_pages+0x91b>
f0113026:	83 ec 04             	sub    $0x4,%esp
f0113029:	6a 00                	push   $0x0
f011302b:	68 00 10 40 01       	push   $0x1401000
f0113030:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113033:	e8 ce 3b 00 00       	call   f0116c06 <CB>
f0113038:	83 c4 10             	add    $0x10,%esp
f011303b:	83 f8 01             	cmp    $0x1,%eax
f011303e:	75 66                	jne    f01130a6 <test_cut_paste_pages+0x91b>
f0113040:	83 ec 04             	sub    $0x4,%esp
f0113043:	6a 00                	push   $0x0
f0113045:	68 00 20 40 01       	push   $0x1402000
f011304a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011304d:	e8 b4 3b 00 00       	call   f0116c06 <CB>
f0113052:	83 c4 10             	add    $0x10,%esp
f0113055:	83 f8 01             	cmp    $0x1,%eax
f0113058:	75 4c                	jne    f01130a6 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f011305a:	83 ec 04             	sub    $0x4,%esp
f011305d:	6a 00                	push   $0x0
f011305f:	68 00 f0 bf 01       	push   $0x1bff000
f0113064:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113067:	e8 9a 3b 00 00       	call   f0116c06 <CB>
f011306c:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f011306f:	85 c0                	test   %eax,%eax
f0113071:	75 33                	jne    f01130a6 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0113073:	83 ec 04             	sub    $0x4,%esp
f0113076:	6a 00                	push   $0x0
f0113078:	68 00 00 c0 01       	push   $0x1c00000
f011307d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113080:	e8 81 3b 00 00       	call   f0116c06 <CB>
f0113085:	83 c4 10             	add    $0x10,%esp
f0113088:	83 f8 01             	cmp    $0x1,%eax
f011308b:	75 19                	jne    f01130a6 <test_cut_paste_pages+0x91b>
f011308d:	83 ec 04             	sub    $0x4,%esp
f0113090:	6a 00                	push   $0x0
f0113092:	68 00 10 c0 01       	push   $0x1c01000
f0113097:	ff 75 d4             	pushl  -0x2c(%ebp)
f011309a:	e8 67 3b 00 00       	call   f0116c06 <CB>
f011309f:	83 c4 10             	add    $0x10,%esp
f01130a2:	85 c0                	test   %eax,%eax
f01130a4:	74 28                	je     f01130ce <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f01130a6:	83 ec 04             	sub    $0x4,%esp
f01130a9:	68 c8 9e 12 f0       	push   $0xf0129ec8
f01130ae:	68 9f 02 00 00       	push   $0x29f
f01130b3:	68 82 98 12 f0       	push   $0xf0129882
f01130b8:	e8 19 d4 fe ff       	call   f01004d6 <_warn>
f01130bd:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01130c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01130c7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01130ce:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01130d2:	74 04                	je     f01130d8 <test_cut_paste_pages+0x94d>
f01130d4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01130d8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01130df:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01130e3:	0f 84 99 00 00 00    	je     f0113182 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f01130e9:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01130f0:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01130f7:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01130fe:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0113105:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f011310c:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0113113:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113116:	8a 00                	mov    (%eax),%al
f0113118:	3c 61                	cmp    $0x61,%al
f011311a:	75 2d                	jne    f0113149 <test_cut_paste_pages+0x9be>
f011311c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011311f:	8a 00                	mov    (%eax),%al
f0113121:	3c 78                	cmp    $0x78,%al
f0113123:	75 24                	jne    f0113149 <test_cut_paste_pages+0x9be>
f0113125:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113128:	8a 00                	mov    (%eax),%al
f011312a:	3c 62                	cmp    $0x62,%al
f011312c:	75 1b                	jne    f0113149 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011312e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113131:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0113133:	3c 79                	cmp    $0x79,%al
f0113135:	75 12                	jne    f0113149 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113137:	8b 45 98             	mov    -0x68(%ebp),%eax
f011313a:	8a 00                	mov    (%eax),%al
f011313c:	3c 63                	cmp    $0x63,%al
f011313e:	75 09                	jne    f0113149 <test_cut_paste_pages+0x9be>
f0113140:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113143:	8a 00                	mov    (%eax),%al
f0113145:	3c 7a                	cmp    $0x7a,%al
f0113147:	74 28                	je     f0113171 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0113149:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0113150:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0113157:	83 ec 04             	sub    $0x4,%esp
f011315a:	68 c8 9d 12 f0       	push   $0xf0129dc8
f011315f:	68 b3 02 00 00       	push   $0x2b3
f0113164:	68 82 98 12 f0       	push   $0xf0129882
f0113169:	e8 68 d3 fe ff       	call   f01004d6 <_warn>
f011316e:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0113171:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113175:	74 04                	je     f011317b <test_cut_paste_pages+0x9f0>
f0113177:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011317b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0113182:	83 ec 0c             	sub    $0xc,%esp
f0113185:	68 01 9f 12 f0       	push   $0xf0129f01
f011318a:	e8 fc dd fe ff       	call   f0100f8b <cprintf>
f011318f:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0113192:	83 ec 08             	sub    $0x8,%esp
f0113195:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113198:	68 10 9f 12 f0       	push   $0xf0129f10
f011319d:	e8 e9 dd fe ff       	call   f0100f8b <cprintf>
f01131a2:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01131a5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01131a9:	75 10                	jne    f01131bb <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f01131ab:	83 ec 0c             	sub    $0xc,%esp
f01131ae:	68 44 9f 12 f0       	push   $0xf0129f44
f01131b3:	e8 d3 dd fe ff       	call   f0100f8b <cprintf>
f01131b8:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01131bb:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f01131c0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01131c3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01131c6:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01131c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01131ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01131d1:	5b                   	pop    %ebx
f01131d2:	5e                   	pop    %esi
f01131d3:	5f                   	pop    %edi
f01131d4:	5d                   	pop    %ebp
f01131d5:	c3                   	ret    

f01131d6 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f01131d6:	55                   	push   %ebp
f01131d7:	89 e5                	mov    %esp,%ebp
f01131d9:	57                   	push   %edi
f01131da:	56                   	push   %esi
f01131db:	53                   	push   %ebx
f01131dc:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01131e2:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f01131e8:	bb 84 9f 12 f0       	mov    $0xf0129f84,%ebx
f01131ed:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131f2:	89 c7                	mov    %eax,%edi
f01131f4:	89 de                	mov    %ebx,%esi
f01131f6:	89 d1                	mov    %edx,%ecx
f01131f8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01131fa:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0113200:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113205:	b0 00                	mov    $0x0,%al
f0113207:	89 d7                	mov    %edx,%edi
f0113209:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011320b:	6a 00                	push   $0x0
f011320d:	6a 0a                	push   $0xa
f011320f:	6a 14                	push   $0x14
f0113211:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0113217:	50                   	push   %eax
f0113218:	e8 8a 80 ff ff       	call   f010b2a7 <env_create>
f011321d:	83 c4 10             	add    $0x10,%esp
f0113220:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113223:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113226:	8b 40 64             	mov    0x64(%eax),%eax
f0113229:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f011322c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011322f:	8b 40 68             	mov    0x68(%eax),%eax
f0113232:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0113238:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011323e:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0113241:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0113248:	75 70 20 
f011324b:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0113252:	00 00 00 
f0113255:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f011325b:	b9 03 00 00 00       	mov    $0x3,%ecx
f0113260:	b8 00 00 00 00       	mov    $0x0,%eax
f0113265:	89 d7                	mov    %edx,%edi
f0113267:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0113269:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011326c:	8b 40 10             	mov    0x10(%eax),%eax
f011326f:	83 ec 08             	sub    $0x8,%esp
f0113272:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0113278:	52                   	push   %edx
f0113279:	50                   	push   %eax
f011327a:	e8 43 d2 00 00       	call   f01204c2 <ltostr>
f011327f:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0113282:	83 ec 04             	sub    $0x4,%esp
f0113285:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011328b:	50                   	push   %eax
f011328c:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0113292:	50                   	push   %eax
f0113293:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0113299:	50                   	push   %eax
f011329a:	e8 fc d2 00 00       	call   f012059b <strcconcat>
f011329f:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f01132a2:	83 ec 0c             	sub    $0xc,%esp
f01132a5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132a8:	e8 49 3b 00 00       	call   f0116df6 <ClearUserSpace>
f01132ad:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f01132b0:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f01132b7:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f01132be:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01132c5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f01132cc:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01132d3:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f01132da:	83 ec 0c             	sub    $0xc,%esp
f01132dd:	68 b8 9f 12 f0       	push   $0xf0129fb8
f01132e2:	e8 a4 dc fe ff       	call   f0100f8b <cprintf>
f01132e7:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01132ea:	83 ec 04             	sub    $0x4,%esp
f01132ed:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01132f3:	50                   	push   %eax
f01132f4:	68 ee 9f 12 f0       	push   $0xf0129fee
f01132f9:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01132ff:	50                   	push   %eax
f0113300:	e8 96 d2 00 00       	call   f012059b <strcconcat>
f0113305:	83 c4 10             	add    $0x10,%esp
f0113308:	83 ec 0c             	sub    $0xc,%esp
f011330b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113311:	50                   	push   %eax
f0113312:	e8 e4 eb fe ff       	call   f0101efb <execute_command>
f0113317:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f011331a:	83 ec 04             	sub    $0x4,%esp
f011331d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113323:	50                   	push   %eax
f0113324:	68 f3 9f 12 f0       	push   $0xf0129ff3
f0113329:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011332f:	50                   	push   %eax
f0113330:	e8 66 d2 00 00       	call   f012059b <strcconcat>
f0113335:	83 c4 10             	add    $0x10,%esp
f0113338:	83 ec 0c             	sub    $0xc,%esp
f011333b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113341:	50                   	push   %eax
f0113342:	e8 b4 eb fe ff       	call   f0101efb <execute_command>
f0113347:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f011334a:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113350:	bb f9 a2 12 f0       	mov    $0xf012a2f9,%ebx
f0113355:	ba 0f 00 00 00       	mov    $0xf,%edx
f011335a:	89 c7                	mov    %eax,%edi
f011335c:	89 de                	mov    %ebx,%esi
f011335e:	89 d1                	mov    %edx,%ecx
f0113360:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113362:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113368:	b9 55 00 00 00       	mov    $0x55,%ecx
f011336d:	b0 00                	mov    $0x0,%al
f011336f:	89 d7                	mov    %edx,%edi
f0113371:	f3 aa                	rep stos %al,%es:(%edi)
f0113373:	83 ec 0c             	sub    $0xc,%esp
f0113376:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011337c:	50                   	push   %eax
f011337d:	e8 79 eb fe ff       	call   f0101efb <execute_command>
f0113382:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0113385:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011338b:	bb 5d a3 12 f0       	mov    $0xf012a35d,%ebx
f0113390:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113395:	89 c7                	mov    %eax,%edi
f0113397:	89 de                	mov    %ebx,%esi
f0113399:	89 d1                	mov    %edx,%ecx
f011339b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011339d:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01133a3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133a8:	b0 00                	mov    $0x0,%al
f01133aa:	89 d7                	mov    %edx,%edi
f01133ac:	f3 aa                	rep stos %al,%es:(%edi)
f01133ae:	83 ec 0c             	sub    $0xc,%esp
f01133b1:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01133b7:	50                   	push   %eax
f01133b8:	e8 3e eb fe ff       	call   f0101efb <execute_command>
f01133bd:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f01133c0:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01133c6:	bb c1 a3 12 f0       	mov    $0xf012a3c1,%ebx
f01133cb:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133d0:	89 c7                	mov    %eax,%edi
f01133d2:	89 de                	mov    %ebx,%esi
f01133d4:	89 d1                	mov    %edx,%ecx
f01133d6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133d8:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f01133de:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133e3:	b0 00                	mov    $0x0,%al
f01133e5:	89 d7                	mov    %edx,%edi
f01133e7:	f3 aa                	rep stos %al,%es:(%edi)
f01133e9:	83 ec 0c             	sub    $0xc,%esp
f01133ec:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01133f2:	50                   	push   %eax
f01133f3:	e8 03 eb fe ff       	call   f0101efb <execute_command>
f01133f8:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f01133fb:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113401:	bb 25 a4 12 f0       	mov    $0xf012a425,%ebx
f0113406:	ba 0f 00 00 00       	mov    $0xf,%edx
f011340b:	89 c7                	mov    %eax,%edi
f011340d:	89 de                	mov    %ebx,%esi
f011340f:	89 d1                	mov    %edx,%ecx
f0113411:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113413:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113419:	b9 55 00 00 00       	mov    $0x55,%ecx
f011341e:	b0 00                	mov    $0x0,%al
f0113420:	89 d7                	mov    %edx,%edi
f0113422:	f3 aa                	rep stos %al,%es:(%edi)
f0113424:	83 ec 0c             	sub    $0xc,%esp
f0113427:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011342d:	50                   	push   %eax
f011342e:	e8 c8 ea fe ff       	call   f0101efb <execute_command>
f0113433:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0113436:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011343c:	bb 89 a4 12 f0       	mov    $0xf012a489,%ebx
f0113441:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113446:	89 c7                	mov    %eax,%edi
f0113448:	89 de                	mov    %ebx,%esi
f011344a:	89 d1                	mov    %edx,%ecx
f011344c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011344e:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113454:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113459:	b0 00                	mov    $0x0,%al
f011345b:	89 d7                	mov    %edx,%edi
f011345d:	f3 aa                	rep stos %al,%es:(%edi)
f011345f:	83 ec 0c             	sub    $0xc,%esp
f0113462:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113468:	50                   	push   %eax
f0113469:	e8 8d ea fe ff       	call   f0101efb <execute_command>
f011346e:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0113471:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113477:	bb ed a4 12 f0       	mov    $0xf012a4ed,%ebx
f011347c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113481:	89 c7                	mov    %eax,%edi
f0113483:	89 de                	mov    %ebx,%esi
f0113485:	89 d1                	mov    %edx,%ecx
f0113487:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113489:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f011348f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113494:	b0 00                	mov    $0x0,%al
f0113496:	89 d7                	mov    %edx,%edi
f0113498:	f3 aa                	rep stos %al,%es:(%edi)
f011349a:	83 ec 0c             	sub    $0xc,%esp
f011349d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01134a3:	50                   	push   %eax
f01134a4:	e8 52 ea fe ff       	call   f0101efb <execute_command>
f01134a9:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f01134ac:	83 ec 04             	sub    $0x4,%esp
f01134af:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01134b5:	50                   	push   %eax
f01134b6:	68 fb 9f 12 f0       	push   $0xf0129ffb
f01134bb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01134c1:	50                   	push   %eax
f01134c2:	e8 d4 d0 00 00       	call   f012059b <strcconcat>
f01134c7:	83 c4 10             	add    $0x10,%esp
f01134ca:	83 ec 0c             	sub    $0xc,%esp
f01134cd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01134d3:	50                   	push   %eax
f01134d4:	e8 22 ea fe ff       	call   f0101efb <execute_command>
f01134d9:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f01134dc:	83 ec 04             	sub    $0x4,%esp
f01134df:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01134e5:	50                   	push   %eax
f01134e6:	68 05 a0 12 f0       	push   $0xf012a005
f01134eb:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01134f1:	50                   	push   %eax
f01134f2:	e8 a4 d0 00 00       	call   f012059b <strcconcat>
f01134f7:	83 c4 10             	add    $0x10,%esp
f01134fa:	83 ec 0c             	sub    $0xc,%esp
f01134fd:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113503:	50                   	push   %eax
f0113504:	e8 f2 e9 fe ff       	call   f0101efb <execute_command>
f0113509:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f011350c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113512:	bb 51 a5 12 f0       	mov    $0xf012a551,%ebx
f0113517:	ba 0f 00 00 00       	mov    $0xf,%edx
f011351c:	89 c7                	mov    %eax,%edi
f011351e:	89 de                	mov    %ebx,%esi
f0113520:	89 d1                	mov    %edx,%ecx
f0113522:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113524:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011352a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011352f:	b0 00                	mov    $0x0,%al
f0113531:	89 d7                	mov    %edx,%edi
f0113533:	f3 aa                	rep stos %al,%es:(%edi)
f0113535:	83 ec 0c             	sub    $0xc,%esp
f0113538:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011353e:	50                   	push   %eax
f011353f:	e8 b7 e9 fe ff       	call   f0101efb <execute_command>
f0113544:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0113547:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011354d:	bb b5 a5 12 f0       	mov    $0xf012a5b5,%ebx
f0113552:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113557:	89 c7                	mov    %eax,%edi
f0113559:	89 de                	mov    %ebx,%esi
f011355b:	89 d1                	mov    %edx,%ecx
f011355d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011355f:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113565:	b9 55 00 00 00       	mov    $0x55,%ecx
f011356a:	b0 00                	mov    $0x0,%al
f011356c:	89 d7                	mov    %edx,%edi
f011356e:	f3 aa                	rep stos %al,%es:(%edi)
f0113570:	83 ec 0c             	sub    $0xc,%esp
f0113573:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113579:	50                   	push   %eax
f011357a:	e8 7c e9 fe ff       	call   f0101efb <execute_command>
f011357f:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0113582:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113588:	bb 19 a6 12 f0       	mov    $0xf012a619,%ebx
f011358d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113592:	89 c7                	mov    %eax,%edi
f0113594:	89 de                	mov    %ebx,%esi
f0113596:	89 d1                	mov    %edx,%ecx
f0113598:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011359a:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01135a0:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135a5:	b0 00                	mov    $0x0,%al
f01135a7:	89 d7                	mov    %edx,%edi
f01135a9:	f3 aa                	rep stos %al,%es:(%edi)
f01135ab:	83 ec 0c             	sub    $0xc,%esp
f01135ae:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01135b4:	50                   	push   %eax
f01135b5:	e8 41 e9 fe ff       	call   f0101efb <execute_command>
f01135ba:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f01135bd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01135c4:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f01135cb:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f01135d2:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f01135d9:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f01135e0:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f01135e7:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f01135ee:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f01135f5:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f01135fc:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0113603:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f011360a:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0113611:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113614:	8a 00                	mov    (%eax),%al
f0113616:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f011361c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011361f:	8a 00                	mov    (%eax),%al
f0113621:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0113627:	8b 45 90             	mov    -0x70(%ebp),%eax
f011362a:	8a 00                	mov    (%eax),%al
f011362c:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113632:	e8 11 b6 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113637:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f011363a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011363d:	89 d0                	mov    %edx,%eax
f011363f:	01 c0                	add    %eax,%eax
f0113641:	01 d0                	add    %edx,%eax
f0113643:	01 c0                	add    %eax,%eax
f0113645:	50                   	push   %eax
f0113646:	68 00 00 10 00       	push   $0x100000
f011364b:	6a 00                	push   $0x0
f011364d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113650:	e8 ef 77 ff ff       	call   f010ae44 <copy_paste_chunk>
f0113655:	83 c4 10             	add    $0x10,%esp
f0113658:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011365b:	e8 e8 b5 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113660:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113663:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011366a:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f011366e:	75 08                	jne    f0113678 <test_copy_paste_chunk+0x4a2>
f0113670:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113673:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113676:	74 2b                	je     f01136a3 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113678:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011367b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011367e:	83 ec 0c             	sub    $0xc,%esp
f0113681:	50                   	push   %eax
f0113682:	ff 75 88             	pushl  -0x78(%ebp)
f0113685:	68 14 a0 12 f0       	push   $0xf012a014
f011368a:	68 06 03 00 00       	push   $0x306
f011368f:	68 82 98 12 f0       	push   $0xf0129882
f0113694:	e8 3d ce fe ff       	call   f01004d6 <_warn>
f0113699:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011369c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01136a3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01136a7:	74 04                	je     f01136ad <test_copy_paste_chunk+0x4d7>
f01136a9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01136ad:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01136b4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01136b7:	8a 00                	mov    (%eax),%al
f01136b9:	3c 61                	cmp    $0x61,%al
f01136bb:	75 75                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f01136bd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01136c0:	8a 00                	mov    (%eax),%al
f01136c2:	3c 78                	cmp    $0x78,%al
f01136c4:	75 6c                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f01136c6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01136c9:	8a 00                	mov    (%eax),%al
f01136cb:	3c 62                	cmp    $0x62,%al
f01136cd:	75 63                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f01136cf:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01136d2:	8a 00                	mov    (%eax),%al
f01136d4:	3c 79                	cmp    $0x79,%al
f01136d6:	75 5a                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f01136d8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01136db:	8a 00                	mov    (%eax),%al
f01136dd:	3c 63                	cmp    $0x63,%al
f01136df:	75 51                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f01136e1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01136e4:	8a 00                	mov    (%eax),%al
f01136e6:	3c 7a                	cmp    $0x7a,%al
f01136e8:	75 48                	jne    f0113732 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f01136ea:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01136ed:	8a 00                	mov    (%eax),%al
f01136ef:	3c 64                	cmp    $0x64,%al
f01136f1:	75 3f                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f01136f3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01136f6:	8a 10                	mov    (%eax),%dl
f01136f8:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f01136fe:	38 c2                	cmp    %al,%dl
f0113700:	75 30                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f0113702:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113705:	8a 00                	mov    (%eax),%al
f0113707:	3c 65                	cmp    $0x65,%al
f0113709:	75 27                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f011370b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011370e:	8a 10                	mov    (%eax),%dl
f0113710:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0113716:	38 c2                	cmp    %al,%dl
f0113718:	75 18                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f011371a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011371d:	8a 00                	mov    (%eax),%al
f011371f:	3c 66                	cmp    $0x66,%al
f0113721:	75 0f                	jne    f0113732 <test_copy_paste_chunk+0x55c>
f0113723:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113726:	8a 10                	mov    (%eax),%dl
f0113728:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011372e:	38 c2                	cmp    %al,%dl
f0113730:	74 21                	je     f0113753 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113732:	83 ec 04             	sub    $0x4,%esp
f0113735:	68 78 a0 12 f0       	push   $0xf012a078
f011373a:	68 0f 03 00 00       	push   $0x30f
f011373f:	68 82 98 12 f0       	push   $0xf0129882
f0113744:	e8 8d cd fe ff       	call   f01004d6 <_warn>
f0113749:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011374c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113753:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113757:	74 04                	je     f011375d <test_copy_paste_chunk+0x587>
f0113759:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011375d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0113764:	83 ec 0c             	sub    $0xc,%esp
f0113767:	68 b2 a0 12 f0       	push   $0xf012a0b2
f011376c:	e8 1a d8 fe ff       	call   f0100f8b <cprintf>
f0113771:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0113774:	83 ec 0c             	sub    $0xc,%esp
f0113777:	68 c4 a0 12 f0       	push   $0xf012a0c4
f011377c:	e8 0a d8 fe ff       	call   f0100f8b <cprintf>
f0113781:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0113784:	83 ec 04             	sub    $0x4,%esp
f0113787:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011378d:	50                   	push   %eax
f011378e:	68 fa a0 12 f0       	push   $0xf012a0fa
f0113793:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113799:	50                   	push   %eax
f011379a:	e8 fc cd 00 00       	call   f012059b <strcconcat>
f011379f:	83 c4 10             	add    $0x10,%esp
f01137a2:	83 ec 0c             	sub    $0xc,%esp
f01137a5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01137ab:	50                   	push   %eax
f01137ac:	e8 4a e7 fe ff       	call   f0101efb <execute_command>
f01137b1:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01137b4:	83 ec 04             	sub    $0x4,%esp
f01137b7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01137bd:	50                   	push   %eax
f01137be:	68 04 a1 12 f0       	push   $0xf012a104
f01137c3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01137c9:	50                   	push   %eax
f01137ca:	e8 cc cd 00 00       	call   f012059b <strcconcat>
f01137cf:	83 c4 10             	add    $0x10,%esp
f01137d2:	83 ec 0c             	sub    $0xc,%esp
f01137d5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01137db:	50                   	push   %eax
f01137dc:	e8 1a e7 fe ff       	call   f0101efb <execute_command>
f01137e1:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f01137e4:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01137ea:	bb 7d a6 12 f0       	mov    $0xf012a67d,%ebx
f01137ef:	ba 0f 00 00 00       	mov    $0xf,%edx
f01137f4:	89 c7                	mov    %eax,%edi
f01137f6:	89 de                	mov    %ebx,%esi
f01137f8:	89 d1                	mov    %edx,%ecx
f01137fa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01137fc:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113802:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113807:	b0 00                	mov    $0x0,%al
f0113809:	89 d7                	mov    %edx,%edi
f011380b:	f3 aa                	rep stos %al,%es:(%edi)
f011380d:	83 ec 0c             	sub    $0xc,%esp
f0113810:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113816:	50                   	push   %eax
f0113817:	e8 df e6 fe ff       	call   f0101efb <execute_command>
f011381c:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f011381f:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113825:	bb e1 a6 12 f0       	mov    $0xf012a6e1,%ebx
f011382a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011382f:	89 c7                	mov    %eax,%edi
f0113831:	89 de                	mov    %ebx,%esi
f0113833:	89 d1                	mov    %edx,%ecx
f0113835:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113837:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f011383d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113842:	b0 00                	mov    $0x0,%al
f0113844:	89 d7                	mov    %edx,%edi
f0113846:	f3 aa                	rep stos %al,%es:(%edi)
f0113848:	83 ec 0c             	sub    $0xc,%esp
f011384b:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113851:	50                   	push   %eax
f0113852:	e8 a4 e6 fe ff       	call   f0101efb <execute_command>
f0113857:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f011385a:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113860:	bb 45 a7 12 f0       	mov    $0xf012a745,%ebx
f0113865:	ba 0f 00 00 00       	mov    $0xf,%edx
f011386a:	89 c7                	mov    %eax,%edi
f011386c:	89 de                	mov    %ebx,%esi
f011386e:	89 d1                	mov    %edx,%ecx
f0113870:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113872:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113878:	b9 55 00 00 00       	mov    $0x55,%ecx
f011387d:	b0 00                	mov    $0x0,%al
f011387f:	89 d7                	mov    %edx,%edi
f0113881:	f3 aa                	rep stos %al,%es:(%edi)
f0113883:	83 ec 0c             	sub    $0xc,%esp
f0113886:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011388c:	50                   	push   %eax
f011388d:	e8 69 e6 fe ff       	call   f0101efb <execute_command>
f0113892:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0113895:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011389b:	bb a9 a7 12 f0       	mov    $0xf012a7a9,%ebx
f01138a0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138a5:	89 c7                	mov    %eax,%edi
f01138a7:	89 de                	mov    %ebx,%esi
f01138a9:	89 d1                	mov    %edx,%ecx
f01138ab:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138ad:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01138b3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01138b8:	b0 00                	mov    $0x0,%al
f01138ba:	89 d7                	mov    %edx,%edi
f01138bc:	f3 aa                	rep stos %al,%es:(%edi)
f01138be:	83 ec 0c             	sub    $0xc,%esp
f01138c1:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01138c7:	50                   	push   %eax
f01138c8:	e8 2e e6 fe ff       	call   f0101efb <execute_command>
f01138cd:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f01138d0:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01138d6:	bb 0d a8 12 f0       	mov    $0xf012a80d,%ebx
f01138db:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138e0:	89 c7                	mov    %eax,%edi
f01138e2:	89 de                	mov    %ebx,%esi
f01138e4:	89 d1                	mov    %edx,%ecx
f01138e6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138e8:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01138ee:	b9 55 00 00 00       	mov    $0x55,%ecx
f01138f3:	b0 00                	mov    $0x0,%al
f01138f5:	89 d7                	mov    %edx,%edi
f01138f7:	f3 aa                	rep stos %al,%es:(%edi)
f01138f9:	83 ec 0c             	sub    $0xc,%esp
f01138fc:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113902:	50                   	push   %eax
f0113903:	e8 f3 e5 fe ff       	call   f0101efb <execute_command>
f0113908:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f011390b:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113911:	bb 71 a8 12 f0       	mov    $0xf012a871,%ebx
f0113916:	ba 0f 00 00 00       	mov    $0xf,%edx
f011391b:	89 c7                	mov    %eax,%edi
f011391d:	89 de                	mov    %ebx,%esi
f011391f:	89 d1                	mov    %edx,%ecx
f0113921:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113923:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0113929:	b9 55 00 00 00       	mov    $0x55,%ecx
f011392e:	b0 00                	mov    $0x0,%al
f0113930:	89 d7                	mov    %edx,%edi
f0113932:	f3 aa                	rep stos %al,%es:(%edi)
f0113934:	83 ec 0c             	sub    $0xc,%esp
f0113937:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011393d:	50                   	push   %eax
f011393e:	e8 b8 e5 fe ff       	call   f0101efb <execute_command>
f0113943:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0113946:	83 ec 04             	sub    $0x4,%esp
f0113949:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011394f:	50                   	push   %eax
f0113950:	68 0e a1 12 f0       	push   $0xf012a10e
f0113955:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011395b:	50                   	push   %eax
f011395c:	e8 3a cc 00 00       	call   f012059b <strcconcat>
f0113961:	83 c4 10             	add    $0x10,%esp
f0113964:	83 ec 0c             	sub    $0xc,%esp
f0113967:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011396d:	50                   	push   %eax
f011396e:	e8 88 e5 fe ff       	call   f0101efb <execute_command>
f0113973:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113976:	83 ec 04             	sub    $0x4,%esp
f0113979:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011397f:	50                   	push   %eax
f0113980:	68 18 a1 12 f0       	push   $0xf012a118
f0113985:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011398b:	50                   	push   %eax
f011398c:	e8 0a cc 00 00       	call   f012059b <strcconcat>
f0113991:	83 c4 10             	add    $0x10,%esp
f0113994:	83 ec 0c             	sub    $0xc,%esp
f0113997:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011399d:	50                   	push   %eax
f011399e:	e8 58 e5 fe ff       	call   f0101efb <execute_command>
f01139a3:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01139a6:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01139ac:	bb d5 a8 12 f0       	mov    $0xf012a8d5,%ebx
f01139b1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01139b6:	89 c7                	mov    %eax,%edi
f01139b8:	89 de                	mov    %ebx,%esi
f01139ba:	89 d1                	mov    %edx,%ecx
f01139bc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01139be:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01139c4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01139c9:	b0 00                	mov    $0x0,%al
f01139cb:	89 d7                	mov    %edx,%edi
f01139cd:	f3 aa                	rep stos %al,%es:(%edi)
f01139cf:	83 ec 0c             	sub    $0xc,%esp
f01139d2:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01139d8:	50                   	push   %eax
f01139d9:	e8 1d e5 fe ff       	call   f0101efb <execute_command>
f01139de:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f01139e1:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01139e7:	bb 39 a9 12 f0       	mov    $0xf012a939,%ebx
f01139ec:	ba 0f 00 00 00       	mov    $0xf,%edx
f01139f1:	89 c7                	mov    %eax,%edi
f01139f3:	89 de                	mov    %ebx,%esi
f01139f5:	89 d1                	mov    %edx,%ecx
f01139f7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01139f9:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01139ff:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a04:	b0 00                	mov    $0x0,%al
f0113a06:	89 d7                	mov    %edx,%edi
f0113a08:	f3 aa                	rep stos %al,%es:(%edi)
f0113a0a:	83 ec 0c             	sub    $0xc,%esp
f0113a0d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113a13:	50                   	push   %eax
f0113a14:	e8 e2 e4 fe ff       	call   f0101efb <execute_command>
f0113a19:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0113a1c:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113a22:	bb 9d a9 12 f0       	mov    $0xf012a99d,%ebx
f0113a27:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a2c:	89 c7                	mov    %eax,%edi
f0113a2e:	89 de                	mov    %ebx,%esi
f0113a30:	89 d1                	mov    %edx,%ecx
f0113a32:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a34:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113a3a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a3f:	b0 00                	mov    $0x0,%al
f0113a41:	89 d7                	mov    %edx,%edi
f0113a43:	f3 aa                	rep stos %al,%es:(%edi)
f0113a45:	83 ec 0c             	sub    $0xc,%esp
f0113a48:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113a4e:	50                   	push   %eax
f0113a4f:	e8 a7 e4 fe ff       	call   f0101efb <execute_command>
f0113a54:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0113a57:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113a5e:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0113a65:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113a6c:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0113a73:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113a7a:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113a81:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113a88:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113a8f:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113a96:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113a9d:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0113aa4:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113aab:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113aae:	8a 00                	mov    (%eax),%al
f0113ab0:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ab6:	e8 8d b1 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113abb:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113abe:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113ac1:	89 d0                	mov    %edx,%eax
f0113ac3:	01 c0                	add    %eax,%eax
f0113ac5:	01 d0                	add    %edx,%eax
f0113ac7:	01 c0                	add    %eax,%eax
f0113ac9:	50                   	push   %eax
f0113aca:	68 00 00 40 00       	push   $0x400000
f0113acf:	68 00 00 20 00       	push   $0x200000
f0113ad4:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113ad7:	e8 68 73 ff ff       	call   f010ae44 <copy_paste_chunk>
f0113adc:	83 c4 10             	add    $0x10,%esp
f0113adf:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ae2:	e8 61 b1 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113ae7:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113aea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113af1:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113af5:	75 08                	jne    f0113aff <test_copy_paste_chunk+0x929>
f0113af7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113afa:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113afd:	74 2b                	je     f0113b2a <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113aff:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b02:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b05:	83 ec 0c             	sub    $0xc,%esp
f0113b08:	50                   	push   %eax
f0113b09:	ff 75 80             	pushl  -0x80(%ebp)
f0113b0c:	68 24 a1 12 f0       	push   $0xf012a124
f0113b11:	68 3f 03 00 00       	push   $0x33f
f0113b16:	68 82 98 12 f0       	push   $0xf0129882
f0113b1b:	e8 b6 c9 fe ff       	call   f01004d6 <_warn>
f0113b20:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b23:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113b2a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113b2e:	74 04                	je     f0113b34 <test_copy_paste_chunk+0x95e>
f0113b30:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b34:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0113b3b:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113b42:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113b45:	83 ec 08             	sub    $0x8,%esp
f0113b48:	6a 01                	push   $0x1
f0113b4a:	6a 07                	push   $0x7
f0113b4c:	6a 07                	push   $0x7
f0113b4e:	6a 07                	push   $0x7
f0113b50:	6a 07                	push   $0x7
f0113b52:	6a 01                	push   $0x1
f0113b54:	68 00 20 00 00       	push   $0x2000
f0113b59:	68 00 00 40 00       	push   $0x400000
f0113b5e:	68 00 00 20 00       	push   $0x200000
f0113b63:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b66:	e8 bf 32 00 00       	call   f0116e2a <CCP>
f0113b6b:	83 c4 30             	add    $0x30,%esp
f0113b6e:	83 f8 01             	cmp    $0x1,%eax
f0113b71:	74 2b                	je     f0113b9e <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113b73:	83 ec 04             	sub    $0x4,%esp
f0113b76:	68 78 a1 12 f0       	push   $0xf012a178
f0113b7b:	68 48 03 00 00       	push   $0x348
f0113b80:	68 82 98 12 f0       	push   $0xf0129882
f0113b85:	e8 4c c9 fe ff       	call   f01004d6 <_warn>
f0113b8a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113b8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113b94:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113b9b:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113b9e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ba2:	74 04                	je     f0113ba8 <test_copy_paste_chunk+0x9d2>
f0113ba4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113ba8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113baf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113bb2:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0113bb5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113bb8:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113bbb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113bbe:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113bc1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113bc4:	8a 00                	mov    (%eax),%al
f0113bc6:	3c 61                	cmp    $0x61,%al
f0113bc8:	75 69                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113bca:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113bcd:	8a 00                	mov    (%eax),%al
f0113bcf:	3c 61                	cmp    $0x61,%al
f0113bd1:	75 60                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113bd3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113bd6:	8a 00                	mov    (%eax),%al
f0113bd8:	3c 79                	cmp    $0x79,%al
f0113bda:	75 57                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113bdc:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113bdf:	8a 00                	mov    (%eax),%al
f0113be1:	3c 62                	cmp    $0x62,%al
f0113be3:	75 4e                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113be5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113be8:	8a 00                	mov    (%eax),%al
f0113bea:	3c 63                	cmp    $0x63,%al
f0113bec:	75 45                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113bee:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113bf1:	8a 00                	mov    (%eax),%al
f0113bf3:	3c 7a                	cmp    $0x7a,%al
f0113bf5:	75 3c                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0113bf7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113bfa:	8a 00                	mov    (%eax),%al
f0113bfc:	3c 77                	cmp    $0x77,%al
f0113bfe:	75 33                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113c00:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113c03:	8a 00                	mov    (%eax),%al
f0113c05:	3c 64                	cmp    $0x64,%al
f0113c07:	75 2a                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113c09:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113c0c:	8a 00                	mov    (%eax),%al
f0113c0e:	3c 65                	cmp    $0x65,%al
f0113c10:	75 21                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113c12:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113c15:	8a 00                	mov    (%eax),%al
f0113c17:	3c 65                	cmp    $0x65,%al
f0113c19:	75 18                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113c1b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113c1e:	8a 00                	mov    (%eax),%al
f0113c20:	3c 66                	cmp    $0x66,%al
f0113c22:	75 0f                	jne    f0113c33 <test_copy_paste_chunk+0xa5d>
f0113c24:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113c27:	8a 10                	mov    (%eax),%dl
f0113c29:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113c2f:	38 c2                	cmp    %al,%dl
f0113c31:	74 21                	je     f0113c54 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113c33:	83 ec 04             	sub    $0x4,%esp
f0113c36:	68 78 a0 12 f0       	push   $0xf012a078
f0113c3b:	68 56 03 00 00       	push   $0x356
f0113c40:	68 82 98 12 f0       	push   $0xf0129882
f0113c45:	e8 8c c8 fe ff       	call   f01004d6 <_warn>
f0113c4a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c4d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113c54:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c58:	74 04                	je     f0113c5e <test_copy_paste_chunk+0xa88>
f0113c5a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113c5e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113c65:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113c68:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113c6b:	e8 d8 af ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113c70:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113c73:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113c76:	89 c2                	mov    %eax,%edx
f0113c78:	01 d2                	add    %edx,%edx
f0113c7a:	01 d0                	add    %edx,%eax
f0113c7c:	50                   	push   %eax
f0113c7d:	68 00 08 20 00       	push   $0x200800
f0113c82:	68 00 08 40 00       	push   $0x400800
f0113c87:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113c8a:	e8 b5 71 ff ff       	call   f010ae44 <copy_paste_chunk>
f0113c8f:	83 c4 10             	add    $0x10,%esp
f0113c92:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113c95:	e8 ae af ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113c9a:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113c9d:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113ca1:	75 08                	jne    f0113cab <test_copy_paste_chunk+0xad5>
f0113ca3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113ca6:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113ca9:	74 2b                	je     f0113cd6 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113cab:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113cae:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113cb1:	83 ec 0c             	sub    $0xc,%esp
f0113cb4:	50                   	push   %eax
f0113cb5:	ff 75 80             	pushl  -0x80(%ebp)
f0113cb8:	68 24 a1 12 f0       	push   $0xf012a124
f0113cbd:	68 66 03 00 00       	push   $0x366
f0113cc2:	68 82 98 12 f0       	push   $0xf0129882
f0113cc7:	e8 0a c8 fe ff       	call   f01004d6 <_warn>
f0113ccc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113ccf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113cd6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113cda:	74 04                	je     f0113ce0 <test_copy_paste_chunk+0xb0a>
f0113cdc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113ce0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113ce7:	83 ec 08             	sub    $0x8,%esp
f0113cea:	6a 01                	push   $0x1
f0113cec:	6a 07                	push   $0x7
f0113cee:	6a 07                	push   $0x7
f0113cf0:	6a 07                	push   $0x7
f0113cf2:	6a 07                	push   $0x7
f0113cf4:	6a 01                	push   $0x1
f0113cf6:	68 00 20 00 00       	push   $0x2000
f0113cfb:	68 00 00 20 00       	push   $0x200000
f0113d00:	68 00 00 40 00       	push   $0x400000
f0113d05:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d08:	e8 1d 31 00 00       	call   f0116e2a <CCP>
f0113d0d:	83 c4 30             	add    $0x30,%esp
f0113d10:	83 f8 01             	cmp    $0x1,%eax
f0113d13:	74 21                	je     f0113d36 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113d15:	83 ec 04             	sub    $0x4,%esp
f0113d18:	68 c4 a1 12 f0       	push   $0xf012a1c4
f0113d1d:	68 6e 03 00 00       	push   $0x36e
f0113d22:	68 82 98 12 f0       	push   $0xf0129882
f0113d27:	e8 aa c7 fe ff       	call   f01004d6 <_warn>
f0113d2c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d2f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113d36:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113d3a:	74 04                	je     f0113d40 <test_copy_paste_chunk+0xb6a>
f0113d3c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113d40:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113d47:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113d4a:	8a 00                	mov    (%eax),%al
f0113d4c:	3c 61                	cmp    $0x61,%al
f0113d4e:	75 69                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113d50:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113d53:	8a 00                	mov    (%eax),%al
f0113d55:	3c 61                	cmp    $0x61,%al
f0113d57:	75 60                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113d59:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d5c:	8a 00                	mov    (%eax),%al
f0113d5e:	3c 79                	cmp    $0x79,%al
f0113d60:	75 57                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113d62:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113d65:	8a 00                	mov    (%eax),%al
f0113d67:	3c 62                	cmp    $0x62,%al
f0113d69:	75 4e                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113d6b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113d6e:	8a 00                	mov    (%eax),%al
f0113d70:	3c 7a                	cmp    $0x7a,%al
f0113d72:	75 45                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113d74:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d77:	8a 00                	mov    (%eax),%al
f0113d79:	3c 7a                	cmp    $0x7a,%al
f0113d7b:	75 3c                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113d7d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113d80:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113d82:	3c 64                	cmp    $0x64,%al
f0113d84:	75 33                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113d86:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113d89:	8a 00                	mov    (%eax),%al
f0113d8b:	3c 64                	cmp    $0x64,%al
f0113d8d:	75 2a                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113d8f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113d92:	8a 00                	mov    (%eax),%al
f0113d94:	3c 65                	cmp    $0x65,%al
f0113d96:	75 21                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113d98:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113d9b:	8a 00                	mov    (%eax),%al
f0113d9d:	3c 78                	cmp    $0x78,%al
f0113d9f:	75 18                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113da1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113da4:	8a 00                	mov    (%eax),%al
f0113da6:	3c 66                	cmp    $0x66,%al
f0113da8:	75 0f                	jne    f0113db9 <test_copy_paste_chunk+0xbe3>
f0113daa:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113dad:	8a 10                	mov    (%eax),%dl
f0113daf:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113db5:	38 c2                	cmp    %al,%dl
f0113db7:	74 21                	je     f0113dda <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113db9:	83 ec 04             	sub    $0x4,%esp
f0113dbc:	68 78 a0 12 f0       	push   $0xf012a078
f0113dc1:	68 77 03 00 00       	push   $0x377
f0113dc6:	68 82 98 12 f0       	push   $0xf0129882
f0113dcb:	e8 06 c7 fe ff       	call   f01004d6 <_warn>
f0113dd0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113dd3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113dda:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113dde:	74 04                	je     f0113de4 <test_copy_paste_chunk+0xc0e>
f0113de0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113de4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113deb:	83 ec 0c             	sub    $0xc,%esp
f0113dee:	68 0f a2 12 f0       	push   $0xf012a20f
f0113df3:	e8 93 d1 fe ff       	call   f0100f8b <cprintf>
f0113df8:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0113dfb:	83 ec 0c             	sub    $0xc,%esp
f0113dfe:	68 20 a2 12 f0       	push   $0xf012a220
f0113e03:	e8 83 d1 fe ff       	call   f0100f8b <cprintf>
f0113e08:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113e0b:	83 ec 04             	sub    $0x4,%esp
f0113e0e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113e14:	50                   	push   %eax
f0113e15:	68 54 a2 12 f0       	push   $0xf012a254
f0113e1a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113e20:	50                   	push   %eax
f0113e21:	e8 75 c7 00 00       	call   f012059b <strcconcat>
f0113e26:	83 c4 10             	add    $0x10,%esp
f0113e29:	83 ec 0c             	sub    $0xc,%esp
f0113e2c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113e32:	50                   	push   %eax
f0113e33:	e8 c3 e0 fe ff       	call   f0101efb <execute_command>
f0113e38:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113e3b:	83 ec 04             	sub    $0x4,%esp
f0113e3e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113e44:	50                   	push   %eax
f0113e45:	68 5e a2 12 f0       	push   $0xf012a25e
f0113e4a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113e50:	50                   	push   %eax
f0113e51:	e8 45 c7 00 00       	call   f012059b <strcconcat>
f0113e56:	83 c4 10             	add    $0x10,%esp
f0113e59:	83 ec 0c             	sub    $0xc,%esp
f0113e5c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113e62:	50                   	push   %eax
f0113e63:	e8 93 e0 fe ff       	call   f0101efb <execute_command>
f0113e68:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113e6b:	83 ec 04             	sub    $0x4,%esp
f0113e6e:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113e74:	50                   	push   %eax
f0113e75:	68 68 a2 12 f0       	push   $0xf012a268
f0113e7a:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113e80:	50                   	push   %eax
f0113e81:	e8 15 c7 00 00       	call   f012059b <strcconcat>
f0113e86:	83 c4 10             	add    $0x10,%esp
f0113e89:	83 ec 0c             	sub    $0xc,%esp
f0113e8c:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113e92:	50                   	push   %eax
f0113e93:	e8 63 e0 fe ff       	call   f0101efb <execute_command>
f0113e98:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113e9b:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113ea1:	bb 01 aa 12 f0       	mov    $0xf012aa01,%ebx
f0113ea6:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113eab:	89 c7                	mov    %eax,%edi
f0113ead:	89 de                	mov    %ebx,%esi
f0113eaf:	89 d1                	mov    %edx,%ecx
f0113eb1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113eb3:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113eb9:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113ebe:	b0 00                	mov    $0x0,%al
f0113ec0:	89 d7                	mov    %edx,%edi
f0113ec2:	f3 aa                	rep stos %al,%es:(%edi)
f0113ec4:	83 ec 0c             	sub    $0xc,%esp
f0113ec7:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113ecd:	50                   	push   %eax
f0113ece:	e8 28 e0 fe ff       	call   f0101efb <execute_command>
f0113ed3:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113ed6:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113edc:	bb 65 aa 12 f0       	mov    $0xf012aa65,%ebx
f0113ee1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ee6:	89 c7                	mov    %eax,%edi
f0113ee8:	89 de                	mov    %ebx,%esi
f0113eea:	89 d1                	mov    %edx,%ecx
f0113eec:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113eee:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113ef4:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113ef9:	b0 00                	mov    $0x0,%al
f0113efb:	89 d7                	mov    %edx,%edi
f0113efd:	f3 aa                	rep stos %al,%es:(%edi)
f0113eff:	83 ec 0c             	sub    $0xc,%esp
f0113f02:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113f08:	50                   	push   %eax
f0113f09:	e8 ed df fe ff       	call   f0101efb <execute_command>
f0113f0e:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0113f11:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113f17:	bb c9 aa 12 f0       	mov    $0xf012aac9,%ebx
f0113f1c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113f21:	89 c7                	mov    %eax,%edi
f0113f23:	89 de                	mov    %ebx,%esi
f0113f25:	89 d1                	mov    %edx,%ecx
f0113f27:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113f29:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113f2f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113f34:	b0 00                	mov    $0x0,%al
f0113f36:	89 d7                	mov    %edx,%edi
f0113f38:	f3 aa                	rep stos %al,%es:(%edi)
f0113f3a:	83 ec 0c             	sub    $0xc,%esp
f0113f3d:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113f43:	50                   	push   %eax
f0113f44:	e8 b2 df fe ff       	call   f0101efb <execute_command>
f0113f49:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113f4c:	e8 f7 ac ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113f51:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0113f54:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113f57:	89 d0                	mov    %edx,%eax
f0113f59:	01 c0                	add    %eax,%eax
f0113f5b:	01 d0                	add    %edx,%eax
f0113f5d:	c1 e0 02             	shl    $0x2,%eax
f0113f60:	50                   	push   %eax
f0113f61:	68 00 00 90 00       	push   $0x900000
f0113f66:	68 00 00 80 00       	push   $0x800000
f0113f6b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113f6e:	e8 d1 6e ff ff       	call   f010ae44 <copy_paste_chunk>
f0113f73:	83 c4 10             	add    $0x10,%esp
f0113f76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113f7c:	e8 c7 ac ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0113f81:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113f84:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113f8b:	75 0b                	jne    f0113f98 <test_copy_paste_chunk+0xdc2>
f0113f8d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113f90:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113f93:	83 f8 03             	cmp    $0x3,%eax
f0113f96:	74 2e                	je     f0113fc6 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113f98:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113f9b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113f9e:	83 ec 0c             	sub    $0xc,%esp
f0113fa1:	50                   	push   %eax
f0113fa2:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113fa8:	68 24 a1 12 f0       	push   $0xf012a124
f0113fad:	68 95 03 00 00       	push   $0x395
f0113fb2:	68 82 98 12 f0       	push   $0xf0129882
f0113fb7:	e8 1a c5 fe ff       	call   f01004d6 <_warn>
f0113fbc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113fbf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113fc6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113fca:	74 04                	je     f0113fd0 <test_copy_paste_chunk+0xdfa>
f0113fcc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113fd0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113fd7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113fde:	83 ec 08             	sub    $0x8,%esp
f0113fe1:	6a 01                	push   $0x1
f0113fe3:	6a 07                	push   $0x7
f0113fe5:	6a 07                	push   $0x7
f0113fe7:	6a 07                	push   $0x7
f0113fe9:	6a 07                	push   $0x7
f0113feb:	6a 01                	push   $0x1
f0113fed:	68 00 30 00 00       	push   $0x3000
f0113ff2:	68 00 00 90 00       	push   $0x900000
f0113ff7:	68 00 00 80 00       	push   $0x800000
f0113ffc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113fff:	e8 26 2e 00 00       	call   f0116e2a <CCP>
f0114004:	83 c4 30             	add    $0x30,%esp
f0114007:	83 f8 01             	cmp    $0x1,%eax
f011400a:	74 28                	je     f0114034 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f011400c:	83 ec 04             	sub    $0x4,%esp
f011400f:	68 c4 a1 12 f0       	push   $0xf012a1c4
f0114014:	68 9e 03 00 00       	push   $0x39e
f0114019:	68 82 98 12 f0       	push   $0xf0129882
f011401e:	e8 b3 c4 fe ff       	call   f01004d6 <_warn>
f0114023:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114026:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f011402d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0114034:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114038:	74 04                	je     f011403e <test_copy_paste_chunk+0xe68>
f011403a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011403e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0114045:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114049:	0f 84 9e 00 00 00    	je     f01140ed <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f011404f:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0114056:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f011405d:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0114064:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f011406b:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0114072:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0114079:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011407c:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f011407f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114082:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0114085:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114088:	8a 00                	mov    (%eax),%al
f011408a:	3c 61                	cmp    $0x61,%al
f011408c:	75 2d                	jne    f01140bb <test_copy_paste_chunk+0xee5>
f011408e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114091:	8a 00                	mov    (%eax),%al
f0114093:	3c 61                	cmp    $0x61,%al
f0114095:	75 24                	jne    f01140bb <test_copy_paste_chunk+0xee5>
f0114097:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011409a:	8a 00                	mov    (%eax),%al
f011409c:	3c 79                	cmp    $0x79,%al
f011409e:	75 1b                	jne    f01140bb <test_copy_paste_chunk+0xee5>
f01140a0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01140a3:	8a 00                	mov    (%eax),%al
f01140a5:	3c 62                	cmp    $0x62,%al
f01140a7:	75 12                	jne    f01140bb <test_copy_paste_chunk+0xee5>
f01140a9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01140ac:	8a 00                	mov    (%eax),%al
f01140ae:	3c 63                	cmp    $0x63,%al
f01140b0:	75 09                	jne    f01140bb <test_copy_paste_chunk+0xee5>
f01140b2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01140b5:	8a 00                	mov    (%eax),%al
f01140b7:	3c 7a                	cmp    $0x7a,%al
f01140b9:	74 21                	je     f01140dc <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01140bb:	83 ec 04             	sub    $0x4,%esp
f01140be:	68 78 a0 12 f0       	push   $0xf012a078
f01140c3:	68 b0 03 00 00       	push   $0x3b0
f01140c8:	68 82 98 12 f0       	push   $0xf0129882
f01140cd:	e8 04 c4 fe ff       	call   f01004d6 <_warn>
f01140d2:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01140d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f01140dc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01140e0:	74 04                	je     f01140e6 <test_copy_paste_chunk+0xf10>
f01140e2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f01140e6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01140ed:	e8 56 ab ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01140f2:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f01140f5:	6a 00                	push   $0x0
f01140f7:	6a 02                	push   $0x2
f01140f9:	68 00 10 90 00       	push   $0x901000
f01140fe:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114101:	e8 b1 2b 00 00       	call   f0116cb7 <SB>
f0114106:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0114109:	6a 00                	push   $0x0
f011410b:	6a 02                	push   $0x2
f011410d:	68 00 20 90 00       	push   $0x902000
f0114112:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114115:	e8 9d 2b 00 00       	call   f0116cb7 <SB>
f011411a:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f011411d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114120:	c1 e0 03             	shl    $0x3,%eax
f0114123:	50                   	push   %eax
f0114124:	68 00 f0 bf 00       	push   $0xbff000
f0114129:	68 00 10 90 00       	push   $0x901000
f011412e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114131:	e8 0e 6d ff ff       	call   f010ae44 <copy_paste_chunk>
f0114136:	83 c4 10             	add    $0x10,%esp
f0114139:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011413f:	e8 04 ab ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114144:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0114147:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f011414e:	75 0b                	jne    f011415b <test_copy_paste_chunk+0xf85>
f0114150:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114153:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0114156:	83 f8 03             	cmp    $0x3,%eax
f0114159:	74 2e                	je     f0114189 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011415b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011415e:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0114161:	83 ec 0c             	sub    $0xc,%esp
f0114164:	50                   	push   %eax
f0114165:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f011416b:	68 24 a1 12 f0       	push   $0xf012a124
f0114170:	68 c0 03 00 00       	push   $0x3c0
f0114175:	68 82 98 12 f0       	push   $0xf0129882
f011417a:	e8 57 c3 fe ff       	call   f01004d6 <_warn>
f011417f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114182:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0114189:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011418d:	74 04                	je     f0114193 <test_copy_paste_chunk+0xfbd>
f011418f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114193:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f011419a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f01141a1:	83 ec 08             	sub    $0x8,%esp
f01141a4:	6a 01                	push   $0x1
f01141a6:	6a 07                	push   $0x7
f01141a8:	6a 03                	push   $0x3
f01141aa:	6a 07                	push   $0x7
f01141ac:	6a 03                	push   $0x3
f01141ae:	6a 01                	push   $0x1
f01141b0:	68 00 20 00 00       	push   $0x2000
f01141b5:	68 00 f0 bf 00       	push   $0xbff000
f01141ba:	68 00 10 90 00       	push   $0x901000
f01141bf:	ff 75 d4             	pushl  -0x2c(%ebp)
f01141c2:	e8 63 2c 00 00       	call   f0116e2a <CCP>
f01141c7:	83 c4 30             	add    $0x30,%esp
f01141ca:	83 f8 01             	cmp    $0x1,%eax
f01141cd:	74 28                	je     f01141f7 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01141cf:	83 ec 04             	sub    $0x4,%esp
f01141d2:	68 c4 a1 12 f0       	push   $0xf012a1c4
f01141d7:	68 c9 03 00 00       	push   $0x3c9
f01141dc:	68 82 98 12 f0       	push   $0xf0129882
f01141e1:	e8 f0 c2 fe ff       	call   f01004d6 <_warn>
f01141e6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01141e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f01141f0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f01141f7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01141fb:	74 04                	je     f0114201 <test_copy_paste_chunk+0x102b>
f01141fd:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114201:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0114208:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011420c:	74 72                	je     f0114280 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f011420e:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0114215:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f011421c:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0114223:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f011422a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011422d:	8a 00                	mov    (%eax),%al
f011422f:	3c 62                	cmp    $0x62,%al
f0114231:	75 1b                	jne    f011424e <test_copy_paste_chunk+0x1078>
f0114233:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114236:	8a 00                	mov    (%eax),%al
f0114238:	3c 62                	cmp    $0x62,%al
f011423a:	75 12                	jne    f011424e <test_copy_paste_chunk+0x1078>
f011423c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011423f:	8a 00                	mov    (%eax),%al
f0114241:	3c 7a                	cmp    $0x7a,%al
f0114243:	75 09                	jne    f011424e <test_copy_paste_chunk+0x1078>
f0114245:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114248:	8a 00                	mov    (%eax),%al
f011424a:	3c 7a                	cmp    $0x7a,%al
f011424c:	74 21                	je     f011426f <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011424e:	83 ec 04             	sub    $0x4,%esp
f0114251:	68 78 a0 12 f0       	push   $0xf012a078
f0114256:	68 d5 03 00 00       	push   $0x3d5
f011425b:	68 82 98 12 f0       	push   $0xf0129882
f0114260:	e8 71 c2 fe ff       	call   f01004d6 <_warn>
f0114265:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114268:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f011426f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114273:	74 04                	je     f0114279 <test_copy_paste_chunk+0x10a3>
f0114275:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114279:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114280:	83 ec 0c             	sub    $0xc,%esp
f0114283:	68 72 a2 12 f0       	push   $0xf012a272
f0114288:	e8 fe cc fe ff       	call   f0100f8b <cprintf>
f011428d:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0114290:	83 ec 08             	sub    $0x8,%esp
f0114293:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114296:	68 84 a2 12 f0       	push   $0xf012a284
f011429b:	e8 eb cc fe ff       	call   f0100f8b <cprintf>
f01142a0:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01142a3:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01142a7:	75 10                	jne    f01142b9 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f01142a9:	83 ec 0c             	sub    $0xc,%esp
f01142ac:	68 b8 a2 12 f0       	push   $0xf012a2b8
f01142b1:	e8 d5 cc fe ff       	call   f0100f8b <cprintf>
f01142b6:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01142b9:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f01142be:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01142c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01142c4:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01142c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01142cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01142cf:	5b                   	pop    %ebx
f01142d0:	5e                   	pop    %esi
f01142d1:	5f                   	pop    %edi
f01142d2:	5d                   	pop    %ebp
f01142d3:	c3                   	ret    

f01142d4 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f01142d4:	55                   	push   %ebp
f01142d5:	89 e5                	mov    %esp,%ebp
f01142d7:	57                   	push   %edi
f01142d8:	56                   	push   %esi
f01142d9:	53                   	push   %ebx
f01142da:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01142e0:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f01142e6:	bb 84 9f 12 f0       	mov    $0xf0129f84,%ebx
f01142eb:	ba 0f 00 00 00       	mov    $0xf,%edx
f01142f0:	89 c7                	mov    %eax,%edi
f01142f2:	89 de                	mov    %ebx,%esi
f01142f4:	89 d1                	mov    %edx,%ecx
f01142f6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01142f8:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f01142fe:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114303:	b0 00                	mov    $0x0,%al
f0114305:	89 d7                	mov    %edx,%edi
f0114307:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114309:	6a 00                	push   $0x0
f011430b:	6a 0a                	push   $0xa
f011430d:	6a 14                	push   $0x14
f011430f:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0114315:	50                   	push   %eax
f0114316:	e8 8c 6f ff ff       	call   f010b2a7 <env_create>
f011431b:	83 c4 10             	add    $0x10,%esp
f011431e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114321:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114324:	8b 40 64             	mov    0x64(%eax),%eax
f0114327:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f011432a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011432d:	8b 40 68             	mov    0x68(%eax),%eax
f0114330:	89 45 80             	mov    %eax,-0x80(%ebp)
f0114333:	8b 45 80             	mov    -0x80(%ebp),%eax
f0114336:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114339:	83 ec 0c             	sub    $0xc,%esp
f011433c:	ff 75 cc             	pushl  -0x34(%ebp)
f011433f:	e8 b2 2a 00 00       	call   f0116df6 <ClearUserSpace>
f0114344:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114347:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011434e:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114355:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f011435c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0114360:	83 ec 0c             	sub    $0xc,%esp
f0114363:	68 30 ab 12 f0       	push   $0xf012ab30
f0114368:	e8 1e cc fe ff       	call   f0100f8b <cprintf>
f011436d:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0114370:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0114377:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f011437e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114381:	8a 00                	mov    (%eax),%al
f0114383:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0114389:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011438c:	8a 00                	mov    (%eax),%al
f011438e:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114394:	e8 af a8 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114399:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f011439c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011439f:	89 d0                	mov    %edx,%eax
f01143a1:	01 c0                	add    %eax,%eax
f01143a3:	01 d0                	add    %edx,%eax
f01143a5:	01 c0                	add    %eax,%eax
f01143a7:	83 ec 0c             	sub    $0xc,%esp
f01143aa:	6a 02                	push   $0x2
f01143ac:	50                   	push   %eax
f01143ad:	68 00 40 10 f0       	push   $0xf0104000
f01143b2:	68 00 00 10 f0       	push   $0xf0100000
f01143b7:	ff 75 cc             	pushl  -0x34(%ebp)
f01143ba:	e8 9f 6a ff ff       	call   f010ae5e <share_chunk>
f01143bf:	83 c4 20             	add    $0x20,%esp
f01143c2:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01143c5:	e8 7e a8 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01143ca:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01143cd:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01143d1:	75 08                	jne    f01143db <test_share_chunk+0x107>
f01143d3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01143d6:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01143d9:	74 28                	je     f0114403 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f01143db:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01143de:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01143e1:	83 ec 0c             	sub    $0xc,%esp
f01143e4:	50                   	push   %eax
f01143e5:	ff 75 b0             	pushl  -0x50(%ebp)
f01143e8:	68 5c ab 12 f0       	push   $0xf012ab5c
f01143ed:	68 11 04 00 00       	push   $0x411
f01143f2:	68 82 98 12 f0       	push   $0xf0129882
f01143f7:	e8 da c0 fe ff       	call   f01004d6 <_warn>
f01143fc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114403:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114407:	74 04                	je     f011440d <test_share_chunk+0x139>
f0114409:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011440d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0114411:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114414:	c1 e0 03             	shl    $0x3,%eax
f0114417:	83 ec 08             	sub    $0x8,%esp
f011441a:	68 fd 00 00 00       	push   $0xfd
f011441f:	6a 07                	push   $0x7
f0114421:	6a 03                	push   $0x3
f0114423:	6a 07                	push   $0x7
f0114425:	6a 03                	push   $0x3
f0114427:	6a 01                	push   $0x1
f0114429:	50                   	push   %eax
f011442a:	68 00 40 10 f0       	push   $0xf0104000
f011442f:	68 00 00 10 f0       	push   $0xf0100000
f0114434:	ff 75 cc             	pushl  -0x34(%ebp)
f0114437:	e8 ee 29 00 00       	call   f0116e2a <CCP>
f011443c:	83 c4 30             	add    $0x30,%esp
f011443f:	85 c0                	test   %eax,%eax
f0114441:	75 1e                	jne    f0114461 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114443:	83 ec 04             	sub    $0x4,%esp
f0114446:	68 b8 ab 12 f0       	push   $0xf012abb8
f011444b:	68 19 04 00 00       	push   $0x419
f0114450:	68 82 98 12 f0       	push   $0xf0129882
f0114455:	e8 7c c0 fe ff       	call   f01004d6 <_warn>
f011445a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011445d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114461:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114465:	74 04                	je     f011446b <test_share_chunk+0x197>
f0114467:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f011446b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011446e:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0114471:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114474:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0114477:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011447a:	8a 00                	mov    (%eax),%al
f011447c:	3c 41                	cmp    $0x41,%al
f011447e:	75 09                	jne    f0114489 <test_share_chunk+0x1b5>
f0114480:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114483:	8a 00                	mov    (%eax),%al
f0114485:	3c 42                	cmp    $0x42,%al
f0114487:	74 1e                	je     f01144a7 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114489:	83 ec 04             	sub    $0x4,%esp
f011448c:	68 00 ac 12 f0       	push   $0xf012ac00
f0114491:	68 23 04 00 00       	push   $0x423
f0114496:	68 82 98 12 f0       	push   $0xf0129882
f011449b:	e8 36 c0 fe ff       	call   f01004d6 <_warn>
f01144a0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01144a7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144ab:	74 04                	je     f01144b1 <test_share_chunk+0x1dd>
f01144ad:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01144b1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f01144b5:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f01144bb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01144be:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f01144c0:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f01144c6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01144c9:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f01144cb:	83 ec 0c             	sub    $0xc,%esp
f01144ce:	68 35 ac 12 f0       	push   $0xf012ac35
f01144d3:	e8 b3 ca fe ff       	call   f0100f8b <cprintf>
f01144d8:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f01144db:	83 ec 0c             	sub    $0xc,%esp
f01144de:	68 44 ac 12 f0       	push   $0xf012ac44
f01144e3:	e8 a3 ca fe ff       	call   f0100f8b <cprintf>
f01144e8:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01144eb:	e8 58 a7 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01144f0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f01144f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01144f6:	c1 e0 05             	shl    $0x5,%eax
f01144f9:	83 ec 0c             	sub    $0xc,%esp
f01144fc:	68 02 0e 00 00       	push   $0xe02
f0114501:	50                   	push   %eax
f0114502:	68 00 00 00 40       	push   $0x40000000
f0114507:	68 00 00 00 f0       	push   $0xf0000000
f011450c:	ff 75 cc             	pushl  -0x34(%ebp)
f011450f:	e8 4a 69 ff ff       	call   f010ae5e <share_chunk>
f0114514:	83 c4 20             	add    $0x20,%esp
f0114517:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011451a:	e8 29 a7 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011451f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0114522:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114526:	75 1f                	jne    f0114547 <test_share_chunk+0x273>
f0114528:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011452b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011452e:	89 c1                	mov    %eax,%ecx
f0114530:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114533:	c1 e0 05             	shl    $0x5,%eax
f0114536:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114539:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114540:	99                   	cltd   
f0114541:	f7 fb                	idiv   %ebx
f0114543:	39 c1                	cmp    %eax,%ecx
f0114545:	74 28                	je     f011456f <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114547:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011454a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011454d:	83 ec 0c             	sub    $0xc,%esp
f0114550:	50                   	push   %eax
f0114551:	ff 75 a8             	pushl  -0x58(%ebp)
f0114554:	68 80 ac 12 f0       	push   $0xf012ac80
f0114559:	68 3b 04 00 00       	push   $0x43b
f011455e:	68 82 98 12 f0       	push   $0xf0129882
f0114563:	e8 6e bf fe ff       	call   f01004d6 <_warn>
f0114568:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011456b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011456f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114573:	74 04                	je     f0114579 <test_share_chunk+0x2a5>
f0114575:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114579:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011457d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114584:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114587:	c1 e0 05             	shl    $0x5,%eax
f011458a:	83 ec 08             	sub    $0x8,%esp
f011458d:	6a 02                	push   $0x2
f011458f:	6a 07                	push   $0x7
f0114591:	6a 03                	push   $0x3
f0114593:	68 07 0e 00 00       	push   $0xe07
f0114598:	68 03 0e 00 00       	push   $0xe03
f011459d:	6a ff                	push   $0xffffffff
f011459f:	50                   	push   %eax
f01145a0:	68 00 00 00 40       	push   $0x40000000
f01145a5:	68 00 00 00 f0       	push   $0xf0000000
f01145aa:	ff 75 cc             	pushl  -0x34(%ebp)
f01145ad:	e8 78 28 00 00       	call   f0116e2a <CCP>
f01145b2:	83 c4 30             	add    $0x30,%esp
f01145b5:	85 c0                	test   %eax,%eax
f01145b7:	75 25                	jne    f01145de <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01145b9:	83 ec 04             	sub    $0x4,%esp
f01145bc:	68 b8 ab 12 f0       	push   $0xf012abb8
f01145c1:	68 44 04 00 00       	push   $0x444
f01145c6:	68 82 98 12 f0       	push   $0xf0129882
f01145cb:	e8 06 bf fe ff       	call   f01004d6 <_warn>
f01145d0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145d3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01145d7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01145de:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01145e1:	89 d0                	mov    %edx,%eax
f01145e3:	01 c0                	add    %eax,%eax
f01145e5:	01 d0                	add    %edx,%eax
f01145e7:	c1 e0 02             	shl    $0x2,%eax
f01145ea:	83 ec 08             	sub    $0x8,%esp
f01145ed:	6a 02                	push   $0x2
f01145ef:	6a 07                	push   $0x7
f01145f1:	6a 03                	push   $0x3
f01145f3:	68 07 0e 00 00       	push   $0xe07
f01145f8:	68 03 0e 00 00       	push   $0xe03
f01145fd:	6a 02                	push   $0x2
f01145ff:	50                   	push   %eax
f0114600:	68 00 00 00 40       	push   $0x40000000
f0114605:	68 00 00 00 f0       	push   $0xf0000000
f011460a:	ff 75 cc             	pushl  -0x34(%ebp)
f011460d:	e8 18 28 00 00       	call   f0116e2a <CCP>
f0114612:	83 c4 30             	add    $0x30,%esp
f0114615:	85 c0                	test   %eax,%eax
f0114617:	75 1e                	jne    f0114637 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114619:	83 ec 04             	sub    $0x4,%esp
f011461c:	68 b8 ab 12 f0       	push   $0xf012abb8
f0114621:	68 4b 04 00 00       	push   $0x44b
f0114626:	68 82 98 12 f0       	push   $0xf0129882
f011462b:	e8 a6 be fe ff       	call   f01004d6 <_warn>
f0114630:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114633:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114637:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011463b:	74 04                	je     f0114641 <test_share_chunk+0x36d>
f011463d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114641:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0114645:	b8 70 04 6f f2       	mov    $0xf26f0470,%eax
f011464a:	05 00 00 00 10       	add    $0x10000000,%eax
f011464f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114652:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114655:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f011465a:	83 ec 08             	sub    $0x8,%esp
f011465d:	6a 02                	push   $0x2
f011465f:	6a 07                	push   $0x7
f0114661:	6a 03                	push   $0x3
f0114663:	68 07 0e 00 00       	push   $0xe07
f0114668:	68 03 0e 00 00       	push   $0xe03
f011466d:	6a 02                	push   $0x2
f011466f:	50                   	push   %eax
f0114670:	68 00 00 0a 40       	push   $0x400a0000
f0114675:	68 00 00 0a f0       	push   $0xf00a0000
f011467a:	ff 75 cc             	pushl  -0x34(%ebp)
f011467d:	e8 a8 27 00 00       	call   f0116e2a <CCP>
f0114682:	83 c4 30             	add    $0x30,%esp
f0114685:	85 c0                	test   %eax,%eax
f0114687:	75 1e                	jne    f01146a7 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114689:	83 ec 04             	sub    $0x4,%esp
f011468c:	68 b8 ab 12 f0       	push   $0xf012abb8
f0114691:	68 55 04 00 00       	push   $0x455
f0114696:	68 82 98 12 f0       	push   $0xf0129882
f011469b:	e8 36 be fe ff       	call   f01004d6 <_warn>
f01146a0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146a3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01146a7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146ab:	74 04                	je     f01146b1 <test_share_chunk+0x3dd>
f01146ad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01146b1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01146b5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01146b9:	0f 84 a4 00 00 00    	je     f0114763 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f01146bf:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f01146c6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01146c9:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f01146cc:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f01146d3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01146d6:	8a 00                	mov    (%eax),%al
f01146d8:	3c 41                	cmp    $0x41,%al
f01146da:	75 09                	jne    f01146e5 <test_share_chunk+0x411>
f01146dc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01146df:	8a 00                	mov    (%eax),%al
f01146e1:	3c 41                	cmp    $0x41,%al
f01146e3:	74 1e                	je     f0114703 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01146e5:	83 ec 04             	sub    $0x4,%esp
f01146e8:	68 00 ac 12 f0       	push   $0xf012ac00
f01146ed:	68 62 04 00 00       	push   $0x462
f01146f2:	68 82 98 12 f0       	push   $0xf0129882
f01146f7:	e8 da bd fe ff       	call   f01004d6 <_warn>
f01146fc:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01146ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114703:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114707:	74 04                	je     f011470d <test_share_chunk+0x439>
f0114709:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011470d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0114711:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0114718:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011471b:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f011471e:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0114725:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114728:	8a 00                	mov    (%eax),%al
f011472a:	3c 43                	cmp    $0x43,%al
f011472c:	75 09                	jne    f0114737 <test_share_chunk+0x463>
f011472e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114731:	8a 00                	mov    (%eax),%al
f0114733:	3c 43                	cmp    $0x43,%al
f0114735:	74 1e                	je     f0114755 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114737:	83 ec 04             	sub    $0x4,%esp
f011473a:	68 00 ac 12 f0       	push   $0xf012ac00
f011473f:	68 6d 04 00 00       	push   $0x46d
f0114744:	68 82 98 12 f0       	push   $0xf0129882
f0114749:	e8 88 bd fe ff       	call   f01004d6 <_warn>
f011474e:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114751:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114755:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114759:	74 04                	je     f011475f <test_share_chunk+0x48b>
f011475b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011475f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114763:	83 ec 0c             	sub    $0xc,%esp
f0114766:	68 0f a2 12 f0       	push   $0xf012a20f
f011476b:	e8 1b c8 fe ff       	call   f0100f8b <cprintf>
f0114770:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0114773:	83 ec 0c             	sub    $0xc,%esp
f0114776:	68 d0 ac 12 f0       	push   $0xf012acd0
f011477b:	e8 0b c8 fe ff       	call   f0100f8b <cprintf>
f0114780:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114783:	e8 c0 a4 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114788:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f011478b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011478e:	89 d0                	mov    %edx,%eax
f0114790:	c1 e0 03             	shl    $0x3,%eax
f0114793:	01 d0                	add    %edx,%eax
f0114795:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011479c:	01 d0                	add    %edx,%eax
f011479e:	c1 e0 03             	shl    $0x3,%eax
f01147a1:	83 ec 0c             	sub    $0xc,%esp
f01147a4:	6a 06                	push   $0x6
f01147a6:	50                   	push   %eax
f01147a7:	6a 00                	push   $0x0
f01147a9:	68 00 00 00 40       	push   $0x40000000
f01147ae:	ff 75 cc             	pushl  -0x34(%ebp)
f01147b1:	e8 a8 66 ff ff       	call   f010ae5e <share_chunk>
f01147b6:	83 c4 20             	add    $0x20,%esp
f01147b9:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01147bc:	e8 87 a4 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01147c1:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01147c4:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f01147c8:	75 0b                	jne    f01147d5 <test_share_chunk+0x501>
f01147ca:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01147cd:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01147d0:	83 f8 01             	cmp    $0x1,%eax
f01147d3:	74 28                	je     f01147fd <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01147d5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01147d8:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01147db:	83 ec 0c             	sub    $0xc,%esp
f01147de:	50                   	push   %eax
f01147df:	ff 75 a0             	pushl  -0x60(%ebp)
f01147e2:	68 80 ac 12 f0       	push   $0xf012ac80
f01147e7:	68 83 04 00 00       	push   $0x483
f01147ec:	68 82 98 12 f0       	push   $0xf0129882
f01147f1:	e8 e0 bc fe ff       	call   f01004d6 <_warn>
f01147f6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01147f9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147fd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114801:	74 04                	je     f0114807 <test_share_chunk+0x533>
f0114803:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114807:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011480b:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114812:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114815:	05 00 80 02 00       	add    $0x28000,%eax
f011481a:	c1 e0 02             	shl    $0x2,%eax
f011481d:	83 ec 08             	sub    $0x8,%esp
f0114820:	6a 02                	push   $0x2
f0114822:	6a 07                	push   $0x7
f0114824:	6a 03                	push   $0x3
f0114826:	6a 07                	push   $0x7
f0114828:	6a 07                	push   $0x7
f011482a:	6a ff                	push   $0xffffffff
f011482c:	50                   	push   %eax
f011482d:	6a 00                	push   $0x0
f011482f:	68 00 00 00 40       	push   $0x40000000
f0114834:	ff 75 cc             	pushl  -0x34(%ebp)
f0114837:	e8 ee 25 00 00       	call   f0116e2a <CCP>
f011483c:	83 c4 30             	add    $0x30,%esp
f011483f:	85 c0                	test   %eax,%eax
f0114841:	75 25                	jne    f0114868 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114843:	83 ec 04             	sub    $0x4,%esp
f0114846:	68 b8 ab 12 f0       	push   $0xf012abb8
f011484b:	68 8c 04 00 00       	push   $0x48c
f0114850:	68 82 98 12 f0       	push   $0xf0129882
f0114855:	e8 7c bc fe ff       	call   f01004d6 <_warn>
f011485a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011485d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114861:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114868:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011486b:	89 d0                	mov    %edx,%eax
f011486d:	01 c0                	add    %eax,%eax
f011486f:	01 d0                	add    %edx,%eax
f0114871:	c1 e0 02             	shl    $0x2,%eax
f0114874:	83 ec 08             	sub    $0x8,%esp
f0114877:	6a 02                	push   $0x2
f0114879:	6a 07                	push   $0x7
f011487b:	6a 03                	push   $0x3
f011487d:	6a 07                	push   $0x7
f011487f:	6a 07                	push   $0x7
f0114881:	6a 03                	push   $0x3
f0114883:	50                   	push   %eax
f0114884:	6a 00                	push   $0x0
f0114886:	68 00 00 00 40       	push   $0x40000000
f011488b:	ff 75 cc             	pushl  -0x34(%ebp)
f011488e:	e8 97 25 00 00       	call   f0116e2a <CCP>
f0114893:	83 c4 30             	add    $0x30,%esp
f0114896:	85 c0                	test   %eax,%eax
f0114898:	75 1e                	jne    f01148b8 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011489a:	83 ec 04             	sub    $0x4,%esp
f011489d:	68 b8 ab 12 f0       	push   $0xf012abb8
f01148a2:	68 93 04 00 00       	push   $0x493
f01148a7:	68 82 98 12 f0       	push   $0xf0129882
f01148ac:	e8 25 bc fe ff       	call   f01004d6 <_warn>
f01148b1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01148b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01148b8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148bc:	74 04                	je     f01148c2 <test_share_chunk+0x5ee>
f01148be:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01148c2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01148c6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01148c9:	89 d0                	mov    %edx,%eax
f01148cb:	01 c0                	add    %eax,%eax
f01148cd:	01 d0                	add    %edx,%eax
f01148cf:	c1 e0 02             	shl    $0x2,%eax
f01148d2:	f7 d8                	neg    %eax
f01148d4:	05 00 00 0a 00       	add    $0xa0000,%eax
f01148d9:	83 ec 08             	sub    $0x8,%esp
f01148dc:	6a 02                	push   $0x2
f01148de:	6a 07                	push   $0x7
f01148e0:	6a 03                	push   $0x3
f01148e2:	6a 07                	push   $0x7
f01148e4:	6a 07                	push   $0x7
f01148e6:	6a 02                	push   $0x2
f01148e8:	50                   	push   %eax
f01148e9:	68 00 30 00 00       	push   $0x3000
f01148ee:	68 00 30 00 40       	push   $0x40003000
f01148f3:	ff 75 cc             	pushl  -0x34(%ebp)
f01148f6:	e8 2f 25 00 00       	call   f0116e2a <CCP>
f01148fb:	83 c4 30             	add    $0x30,%esp
f01148fe:	85 c0                	test   %eax,%eax
f0114900:	75 1e                	jne    f0114920 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114902:	83 ec 04             	sub    $0x4,%esp
f0114905:	68 b8 ab 12 f0       	push   $0xf012abb8
f011490a:	68 9b 04 00 00       	push   $0x49b
f011490f:	68 82 98 12 f0       	push   $0xf0129882
f0114914:	e8 bd bb fe ff       	call   f01004d6 <_warn>
f0114919:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011491c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114920:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114924:	74 04                	je     f011492a <test_share_chunk+0x656>
f0114926:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011492a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011492e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114931:	c1 e0 02             	shl    $0x2,%eax
f0114934:	83 ec 08             	sub    $0x8,%esp
f0114937:	6a 02                	push   $0x2
f0114939:	6a 07                	push   $0x7
f011493b:	6a 03                	push   $0x3
f011493d:	6a 07                	push   $0x7
f011493f:	6a 07                	push   $0x7
f0114941:	6a 03                	push   $0x3
f0114943:	50                   	push   %eax
f0114944:	68 00 00 0a 00       	push   $0xa0000
f0114949:	68 00 00 0a 40       	push   $0x400a0000
f011494e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114951:	e8 d4 24 00 00       	call   f0116e2a <CCP>
f0114956:	83 c4 30             	add    $0x30,%esp
f0114959:	85 c0                	test   %eax,%eax
f011495b:	75 1e                	jne    f011497b <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011495d:	83 ec 04             	sub    $0x4,%esp
f0114960:	68 b8 ab 12 f0       	push   $0xf012abb8
f0114965:	68 a3 04 00 00       	push   $0x4a3
f011496a:	68 82 98 12 f0       	push   $0xf0129882
f011496f:	e8 62 bb fe ff       	call   f01004d6 <_warn>
f0114974:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114977:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011497b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011497f:	74 04                	je     f0114985 <test_share_chunk+0x6b1>
f0114981:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114985:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114989:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011498d:	0f 84 92 00 00 00    	je     f0114a25 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0114993:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f011499a:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01149a1:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01149a8:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01149af:	8b 45 98             	mov    -0x68(%ebp),%eax
f01149b2:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f01149b5:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f01149bc:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01149c3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01149c6:	8a 00                	mov    (%eax),%al
f01149c8:	3c 41                	cmp    $0x41,%al
f01149ca:	75 2d                	jne    f01149f9 <test_share_chunk+0x725>
f01149cc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01149cf:	8a 00                	mov    (%eax),%al
f01149d1:	3c 41                	cmp    $0x41,%al
f01149d3:	75 24                	jne    f01149f9 <test_share_chunk+0x725>
f01149d5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01149d8:	8a 00                	mov    (%eax),%al
f01149da:	3c 41                	cmp    $0x41,%al
f01149dc:	75 1b                	jne    f01149f9 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01149de:	8b 45 98             	mov    -0x68(%ebp),%eax
f01149e1:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01149e3:	3c 44                	cmp    $0x44,%al
f01149e5:	75 12                	jne    f01149f9 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01149e7:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01149ea:	8a 00                	mov    (%eax),%al
f01149ec:	3c 44                	cmp    $0x44,%al
f01149ee:	75 09                	jne    f01149f9 <test_share_chunk+0x725>
f01149f0:	8b 45 90             	mov    -0x70(%ebp),%eax
f01149f3:	8a 00                	mov    (%eax),%al
f01149f5:	3c 44                	cmp    $0x44,%al
f01149f7:	74 1e                	je     f0114a17 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01149f9:	83 ec 04             	sub    $0x4,%esp
f01149fc:	68 00 ac 12 f0       	push   $0xf012ac00
f0114a01:	68 b5 04 00 00       	push   $0x4b5
f0114a06:	68 82 98 12 f0       	push   $0xf0129882
f0114a0b:	e8 c6 ba fe ff       	call   f01004d6 <_warn>
f0114a10:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114a13:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114a17:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a1b:	74 04                	je     f0114a21 <test_share_chunk+0x74d>
f0114a1d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114a21:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114a25:	83 ec 0c             	sub    $0xc,%esp
f0114a28:	68 72 a2 12 f0       	push   $0xf012a272
f0114a2d:	e8 59 c5 fe ff       	call   f0100f8b <cprintf>
f0114a32:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0114a35:	83 ec 0c             	sub    $0xc,%esp
f0114a38:	68 0c ad 12 f0       	push   $0xf012ad0c
f0114a3d:	e8 49 c5 fe ff       	call   f0100f8b <cprintf>
f0114a42:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114a45:	e8 fe a1 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114a4a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114a4d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a50:	89 d0                	mov    %edx,%eax
f0114a52:	01 c0                	add    %eax,%eax
f0114a54:	01 d0                	add    %edx,%eax
f0114a56:	01 c0                	add    %eax,%eax
f0114a58:	01 d0                	add    %edx,%eax
f0114a5a:	83 ec 0c             	sub    $0xc,%esp
f0114a5d:	6a 04                	push   $0x4
f0114a5f:	50                   	push   %eax
f0114a60:	68 00 fc 3f 00       	push   $0x3ffc00
f0114a65:	68 00 fc 09 00       	push   $0x9fc00
f0114a6a:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a6d:	e8 ec 63 ff ff       	call   f010ae5e <share_chunk>
f0114a72:	83 c4 20             	add    $0x20,%esp
f0114a75:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114a78:	e8 cb a1 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114a7d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114a80:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0114a84:	75 0b                	jne    f0114a91 <test_share_chunk+0x7bd>
f0114a86:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a89:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a8c:	83 f8 01             	cmp    $0x1,%eax
f0114a8f:	74 28                	je     f0114ab9 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114a91:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a94:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a97:	83 ec 0c             	sub    $0xc,%esp
f0114a9a:	50                   	push   %eax
f0114a9b:	ff 75 8c             	pushl  -0x74(%ebp)
f0114a9e:	68 80 ac 12 f0       	push   $0xf012ac80
f0114aa3:	68 cb 04 00 00       	push   $0x4cb
f0114aa8:	68 82 98 12 f0       	push   $0xf0129882
f0114aad:	e8 24 ba fe ff       	call   f01004d6 <_warn>
f0114ab2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ab5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114ab9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114abd:	74 04                	je     f0114ac3 <test_share_chunk+0x7ef>
f0114abf:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114ac3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114ac7:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114ace:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ad1:	89 d0                	mov    %edx,%eax
f0114ad3:	01 c0                	add    %eax,%eax
f0114ad5:	01 d0                	add    %edx,%eax
f0114ad7:	c1 e0 02             	shl    $0x2,%eax
f0114ada:	83 ec 08             	sub    $0x8,%esp
f0114add:	6a 02                	push   $0x2
f0114adf:	6a 07                	push   $0x7
f0114ae1:	6a 07                	push   $0x7
f0114ae3:	6a 07                	push   $0x7
f0114ae5:	6a 05                	push   $0x5
f0114ae7:	6a ff                	push   $0xffffffff
f0114ae9:	50                   	push   %eax
f0114aea:	68 00 f0 3f 00       	push   $0x3ff000
f0114aef:	68 00 f0 09 00       	push   $0x9f000
f0114af4:	ff 75 cc             	pushl  -0x34(%ebp)
f0114af7:	e8 2e 23 00 00       	call   f0116e2a <CCP>
f0114afc:	83 c4 30             	add    $0x30,%esp
f0114aff:	85 c0                	test   %eax,%eax
f0114b01:	75 25                	jne    f0114b28 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114b03:	83 ec 04             	sub    $0x4,%esp
f0114b06:	68 b8 ab 12 f0       	push   $0xf012abb8
f0114b0b:	68 d4 04 00 00       	push   $0x4d4
f0114b10:	68 82 98 12 f0       	push   $0xf0129882
f0114b15:	e8 bc b9 fe ff       	call   f01004d6 <_warn>
f0114b1a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b1d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114b21:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0114b28:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b2c:	74 04                	je     f0114b32 <test_share_chunk+0x85e>
f0114b2e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b32:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114b36:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b39:	c1 e0 02             	shl    $0x2,%eax
f0114b3c:	83 ec 08             	sub    $0x8,%esp
f0114b3f:	6a 02                	push   $0x2
f0114b41:	6a 07                	push   $0x7
f0114b43:	6a 07                	push   $0x7
f0114b45:	6a 07                	push   $0x7
f0114b47:	6a 05                	push   $0x5
f0114b49:	6a 03                	push   $0x3
f0114b4b:	50                   	push   %eax
f0114b4c:	68 00 f0 3f 00       	push   $0x3ff000
f0114b51:	68 00 f0 09 00       	push   $0x9f000
f0114b56:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b59:	e8 cc 22 00 00       	call   f0116e2a <CCP>
f0114b5e:	83 c4 30             	add    $0x30,%esp
f0114b61:	85 c0                	test   %eax,%eax
f0114b63:	75 1e                	jne    f0114b83 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114b65:	83 ec 04             	sub    $0x4,%esp
f0114b68:	68 b8 ab 12 f0       	push   $0xf012abb8
f0114b6d:	68 dd 04 00 00       	push   $0x4dd
f0114b72:	68 82 98 12 f0       	push   $0xf0129882
f0114b77:	e8 5a b9 fe ff       	call   f01004d6 <_warn>
f0114b7c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b7f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b83:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b87:	74 04                	je     f0114b8d <test_share_chunk+0x8b9>
f0114b89:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b8d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114b91:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b94:	c1 e0 03             	shl    $0x3,%eax
f0114b97:	83 ec 08             	sub    $0x8,%esp
f0114b9a:	6a 02                	push   $0x2
f0114b9c:	6a 07                	push   $0x7
f0114b9e:	6a 07                	push   $0x7
f0114ba0:	6a 07                	push   $0x7
f0114ba2:	6a 05                	push   $0x5
f0114ba4:	6a 04                	push   $0x4
f0114ba6:	50                   	push   %eax
f0114ba7:	68 00 00 40 00       	push   $0x400000
f0114bac:	68 00 00 0a 00       	push   $0xa0000
f0114bb1:	ff 75 cc             	pushl  -0x34(%ebp)
f0114bb4:	e8 71 22 00 00       	call   f0116e2a <CCP>
f0114bb9:	83 c4 30             	add    $0x30,%esp
f0114bbc:	85 c0                	test   %eax,%eax
f0114bbe:	75 1e                	jne    f0114bde <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114bc0:	83 ec 04             	sub    $0x4,%esp
f0114bc3:	68 b8 ab 12 f0       	push   $0xf012abb8
f0114bc8:	68 e5 04 00 00       	push   $0x4e5
f0114bcd:	68 82 98 12 f0       	push   $0xf0129882
f0114bd2:	e8 ff b8 fe ff       	call   f01004d6 <_warn>
f0114bd7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114bda:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114bde:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114be2:	74 04                	je     f0114be8 <test_share_chunk+0x914>
f0114be4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114be8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114bec:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114bf0:	0f 84 b2 00 00 00    	je     f0114ca8 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0114bf6:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0114bfd:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0114c04:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0114c0b:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114c12:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0114c19:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114c20:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0114c27:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114c2e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114c31:	8a 00                	mov    (%eax),%al
f0114c33:	3c 44                	cmp    $0x44,%al
f0114c35:	75 45                	jne    f0114c7c <test_share_chunk+0x9a8>
f0114c37:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114c3a:	8a 00                	mov    (%eax),%al
f0114c3c:	3c 44                	cmp    $0x44,%al
f0114c3e:	75 3c                	jne    f0114c7c <test_share_chunk+0x9a8>
f0114c40:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114c43:	8a 00                	mov    (%eax),%al
f0114c45:	3c 44                	cmp    $0x44,%al
f0114c47:	75 33                	jne    f0114c7c <test_share_chunk+0x9a8>
f0114c49:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114c4c:	8a 00                	mov    (%eax),%al
f0114c4e:	3c 44                	cmp    $0x44,%al
f0114c50:	75 2a                	jne    f0114c7c <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114c52:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114c55:	8a 10                	mov    (%eax),%dl
f0114c57:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114c5a:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114c5c:	38 c2                	cmp    %al,%dl
f0114c5e:	75 1c                	jne    f0114c7c <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114c60:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114c63:	8a 10                	mov    (%eax),%dl
f0114c65:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114c68:	8a 00                	mov    (%eax),%al
f0114c6a:	38 c2                	cmp    %al,%dl
f0114c6c:	75 0e                	jne    f0114c7c <test_share_chunk+0x9a8>
f0114c6e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114c71:	8a 10                	mov    (%eax),%dl
f0114c73:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114c76:	8a 00                	mov    (%eax),%al
f0114c78:	38 c2                	cmp    %al,%dl
f0114c7a:	74 1e                	je     f0114c9a <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114c7c:	83 ec 04             	sub    $0x4,%esp
f0114c7f:	68 00 ac 12 f0       	push   $0xf012ac00
f0114c84:	68 fa 04 00 00       	push   $0x4fa
f0114c89:	68 82 98 12 f0       	push   $0xf0129882
f0114c8e:	e8 43 b8 fe ff       	call   f01004d6 <_warn>
f0114c93:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114c96:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114c9a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c9e:	74 04                	je     f0114ca4 <test_share_chunk+0x9d0>
f0114ca0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114ca4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114ca8:	83 ec 0c             	sub    $0xc,%esp
f0114cab:	68 44 ad 12 f0       	push   $0xf012ad44
f0114cb0:	e8 d6 c2 fe ff       	call   f0100f8b <cprintf>
f0114cb5:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114cb8:	83 ec 08             	sub    $0x8,%esp
f0114cbb:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114cbe:	68 54 ad 12 f0       	push   $0xf012ad54
f0114cc3:	e8 c3 c2 fe ff       	call   f0100f8b <cprintf>
f0114cc8:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114ccb:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114ccf:	75 10                	jne    f0114ce1 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114cd1:	83 ec 0c             	sub    $0xc,%esp
f0114cd4:	68 84 ad 12 f0       	push   $0xf012ad84
f0114cd9:	e8 ad c2 fe ff       	call   f0100f8b <cprintf>
f0114cde:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114ce1:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f0114ce6:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114ce9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114cec:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114cef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114cf4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114cf7:	5b                   	pop    %ebx
f0114cf8:	5e                   	pop    %esi
f0114cf9:	5f                   	pop    %edi
f0114cfa:	5d                   	pop    %ebp
f0114cfb:	c3                   	ret    

f0114cfc <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0114cfc:	55                   	push   %ebp
f0114cfd:	89 e5                	mov    %esp,%ebp
f0114cff:	57                   	push   %edi
f0114d00:	56                   	push   %esi
f0114d01:	53                   	push   %ebx
f0114d02:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114d08:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114d0e:	bb 84 9f 12 f0       	mov    $0xf0129f84,%ebx
f0114d13:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114d18:	89 c7                	mov    %eax,%edi
f0114d1a:	89 de                	mov    %ebx,%esi
f0114d1c:	89 d1                	mov    %edx,%ecx
f0114d1e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114d20:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0114d26:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114d2b:	b0 00                	mov    $0x0,%al
f0114d2d:	89 d7                	mov    %edx,%edi
f0114d2f:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114d31:	6a 00                	push   $0x0
f0114d33:	6a 0a                	push   $0xa
f0114d35:	6a 14                	push   $0x14
f0114d37:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114d3d:	50                   	push   %eax
f0114d3e:	e8 64 65 ff ff       	call   f010b2a7 <env_create>
f0114d43:	83 c4 10             	add    $0x10,%esp
f0114d46:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114d49:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114d4c:	8b 40 64             	mov    0x64(%eax),%eax
f0114d4f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114d52:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114d55:	8b 40 68             	mov    0x68(%eax),%eax
f0114d58:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114d5b:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114d5e:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114d61:	83 ec 0c             	sub    $0xc,%esp
f0114d64:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d67:	e8 8a 20 00 00       	call   f0116df6 <ClearUserSpace>
f0114d6c:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114d6f:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114d76:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114d7d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114d84:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114d88:	83 ec 0c             	sub    $0xc,%esp
f0114d8b:	68 c0 ad 12 f0       	push   $0xf012adc0
f0114d90:	e8 f6 c1 fe ff       	call   f0100f8b <cprintf>
f0114d95:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114d98:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114d9f:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114da6:	eb 03                	jmp    f0114dab <test_allocate_chunk+0xaf>
f0114da8:	ff 4d e4             	decl   -0x1c(%ebp)
f0114dab:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114db2:	76 09                	jbe    f0114dbd <test_allocate_chunk+0xc1>
f0114db4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114db7:	8a 00                	mov    (%eax),%al
f0114db9:	84 c0                	test   %al,%al
f0114dbb:	74 eb                	je     f0114da8 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114dbd:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114dc4:	75 06                	jne    f0114dcc <test_allocate_chunk+0xd0>
f0114dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114dc9:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114dcc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114dcf:	8a 00                	mov    (%eax),%al
f0114dd1:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114dd7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114dda:	8a 00                	mov    (%eax),%al
f0114ddc:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0114de2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114de5:	8a 00                	mov    (%eax),%al
f0114de7:	0f be c0             	movsbl %al,%eax
f0114dea:	83 ec 08             	sub    $0x8,%esp
f0114ded:	50                   	push   %eax
f0114dee:	68 ea ad 12 f0       	push   $0xf012adea
f0114df3:	e8 93 c1 fe ff       	call   f0100f8b <cprintf>
f0114df8:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0114dfb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114dfe:	8a 00                	mov    (%eax),%al
f0114e00:	0f be c0             	movsbl %al,%eax
f0114e03:	83 ec 08             	sub    $0x8,%esp
f0114e06:	50                   	push   %eax
f0114e07:	68 f6 ad 12 f0       	push   $0xf012adf6
f0114e0c:	e8 7a c1 fe ff       	call   f0100f8b <cprintf>
f0114e11:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114e14:	83 ec 08             	sub    $0x8,%esp
f0114e17:	68 00 f0 bf ef       	push   $0xefbff000
f0114e1c:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e1f:	e8 b3 1f 00 00       	call   f0116dd7 <GP>
f0114e24:	83 c4 10             	add    $0x10,%esp
f0114e27:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114e2a:	e8 19 9e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114e2f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114e32:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114e35:	c1 e0 02             	shl    $0x2,%eax
f0114e38:	6a 02                	push   $0x2
f0114e3a:	50                   	push   %eax
f0114e3b:	68 00 f0 bf ef       	push   $0xefbff000
f0114e40:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e43:	e8 30 60 ff ff       	call   f010ae78 <allocate_chunk>
f0114e48:	83 c4 10             	add    $0x10,%esp
f0114e4b:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114e4e:	e8 f5 9d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114e53:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114e56:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114e5a:	75 08                	jne    f0114e64 <test_allocate_chunk+0x168>
f0114e5c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e5f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114e62:	74 2a                	je     f0114e8e <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114e64:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e67:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114e6a:	83 ec 08             	sub    $0x8,%esp
f0114e6d:	6a 00                	push   $0x0
f0114e6f:	50                   	push   %eax
f0114e70:	ff 75 b0             	pushl  -0x50(%ebp)
f0114e73:	68 04 ae 12 f0       	push   $0xf012ae04
f0114e78:	68 3a 05 00 00       	push   $0x53a
f0114e7d:	68 82 98 12 f0       	push   $0xf0129882
f0114e82:	e8 4f b6 fe ff       	call   f01004d6 <_warn>
f0114e87:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e8a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114e8e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e92:	74 04                	je     f0114e98 <test_allocate_chunk+0x19c>
f0114e94:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114e98:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114e9c:	e8 a7 9d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114ea1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114ea4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114ea7:	01 c0                	add    %eax,%eax
f0114ea9:	89 c1                	mov    %eax,%ecx
f0114eab:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114eae:	89 d0                	mov    %edx,%eax
f0114eb0:	c1 e0 02             	shl    $0x2,%eax
f0114eb3:	01 d0                	add    %edx,%eax
f0114eb5:	f7 d8                	neg    %eax
f0114eb7:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114ebc:	6a 02                	push   $0x2
f0114ebe:	51                   	push   %ecx
f0114ebf:	50                   	push   %eax
f0114ec0:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ec3:	e8 b0 5f ff ff       	call   f010ae78 <allocate_chunk>
f0114ec8:	83 c4 10             	add    $0x10,%esp
f0114ecb:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ece:	e8 75 9d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114ed3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114ed6:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114eda:	75 08                	jne    f0114ee4 <test_allocate_chunk+0x1e8>
f0114edc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114edf:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114ee2:	74 2a                	je     f0114f0e <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114ee4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ee7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114eea:	83 ec 08             	sub    $0x8,%esp
f0114eed:	6a 00                	push   $0x0
f0114eef:	50                   	push   %eax
f0114ef0:	ff 75 b0             	pushl  -0x50(%ebp)
f0114ef3:	68 04 ae 12 f0       	push   $0xf012ae04
f0114ef8:	68 48 05 00 00       	push   $0x548
f0114efd:	68 82 98 12 f0       	push   $0xf0129882
f0114f02:	e8 cf b5 fe ff       	call   f01004d6 <_warn>
f0114f07:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f0a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114f0e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f12:	74 04                	je     f0114f18 <test_allocate_chunk+0x21c>
f0114f14:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114f18:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0114f1c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114f1f:	c1 e0 02             	shl    $0x2,%eax
f0114f22:	83 ec 08             	sub    $0x8,%esp
f0114f25:	6a 03                	push   $0x3
f0114f27:	6a 00                	push   $0x0
f0114f29:	6a 00                	push   $0x0
f0114f2b:	68 ff 0f 00 00       	push   $0xfff
f0114f30:	ff 75 b8             	pushl  -0x48(%ebp)
f0114f33:	6a 01                	push   $0x1
f0114f35:	50                   	push   %eax
f0114f36:	68 00 f0 bf ef       	push   $0xefbff000
f0114f3b:	6a 00                	push   $0x0
f0114f3d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f40:	e8 e5 1e 00 00       	call   f0116e2a <CCP>
f0114f45:	83 c4 30             	add    $0x30,%esp
f0114f48:	85 c0                	test   %eax,%eax
f0114f4a:	75 1e                	jne    f0114f6a <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114f4c:	83 ec 04             	sub    $0x4,%esp
f0114f4f:	68 6c ae 12 f0       	push   $0xf012ae6c
f0114f54:	68 50 05 00 00       	push   $0x550
f0114f59:	68 82 98 12 f0       	push   $0xf0129882
f0114f5e:	e8 73 b5 fe ff       	call   f01004d6 <_warn>
f0114f63:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114f66:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114f6a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f6e:	74 04                	je     f0114f74 <test_allocate_chunk+0x278>
f0114f70:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114f74:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114f78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f7b:	8a 10                	mov    (%eax),%dl
f0114f7d:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114f83:	38 c2                	cmp    %al,%dl
f0114f85:	75 0f                	jne    f0114f96 <test_allocate_chunk+0x29a>
f0114f87:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114f8a:	8a 10                	mov    (%eax),%dl
f0114f8c:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114f92:	38 c2                	cmp    %al,%dl
f0114f94:	74 1e                	je     f0114fb4 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114f96:	83 ec 04             	sub    $0x4,%esp
f0114f99:	68 b8 ae 12 f0       	push   $0xf012aeb8
f0114f9e:	68 58 05 00 00       	push   $0x558
f0114fa3:	68 82 98 12 f0       	push   $0xf0129882
f0114fa8:	e8 29 b5 fe ff       	call   f01004d6 <_warn>
f0114fad:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114fb0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114fb4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114fb8:	74 04                	je     f0114fbe <test_allocate_chunk+0x2c2>
f0114fba:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114fbe:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114fc2:	83 ec 0c             	sub    $0xc,%esp
f0114fc5:	68 35 ac 12 f0       	push   $0xf012ac35
f0114fca:	e8 bc bf fe ff       	call   f0100f8b <cprintf>
f0114fcf:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0114fd2:	83 ec 0c             	sub    $0xc,%esp
f0114fd5:	68 f0 ae 12 f0       	push   $0xf012aef0
f0114fda:	e8 ac bf fe ff       	call   f0100f8b <cprintf>
f0114fdf:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114fe2:	e8 61 9c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0114fe7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114fea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fed:	c1 e0 05             	shl    $0x5,%eax
f0114ff0:	68 02 0e 00 00       	push   $0xe02
f0114ff5:	50                   	push   %eax
f0114ff6:	6a 00                	push   $0x0
f0114ff8:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ffb:	e8 78 5e ff ff       	call   f010ae78 <allocate_chunk>
f0115000:	83 c4 10             	add    $0x10,%esp
f0115003:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115006:	e8 3d 9c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011500b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f011500e:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0115012:	75 36                	jne    f011504a <test_allocate_chunk+0x34e>
f0115014:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115017:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011501a:	89 c1                	mov    %eax,%ecx
f011501c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011501f:	c1 e0 05             	shl    $0x5,%eax
f0115022:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115025:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011502c:	99                   	cltd   
f011502d:	f7 fe                	idiv   %esi
f011502f:	89 c3                	mov    %eax,%ebx
f0115031:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115034:	c1 e0 05             	shl    $0x5,%eax
f0115037:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011503a:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115041:	99                   	cltd   
f0115042:	f7 fe                	idiv   %esi
f0115044:	01 d8                	add    %ebx,%eax
f0115046:	39 c1                	cmp    %eax,%ecx
f0115048:	74 54                	je     f011509e <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f011504a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011504d:	c1 e0 05             	shl    $0x5,%eax
f0115050:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115053:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011505a:	99                   	cltd   
f011505b:	f7 ff                	idiv   %edi
f011505d:	89 c1                	mov    %eax,%ecx
f011505f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115062:	c1 e0 05             	shl    $0x5,%eax
f0115065:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115068:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011506f:	99                   	cltd   
f0115070:	f7 fe                	idiv   %esi
f0115072:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115075:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115078:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011507b:	83 ec 08             	sub    $0x8,%esp
f011507e:	52                   	push   %edx
f011507f:	50                   	push   %eax
f0115080:	ff 75 a8             	pushl  -0x58(%ebp)
f0115083:	68 30 af 12 f0       	push   $0xf012af30
f0115088:	68 6d 05 00 00       	push   $0x56d
f011508d:	68 82 98 12 f0       	push   $0xf0129882
f0115092:	e8 3f b4 fe ff       	call   f01004d6 <_warn>
f0115097:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011509a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011509e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150a2:	74 04                	je     f01150a8 <test_allocate_chunk+0x3ac>
f01150a4:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01150a8:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01150ac:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01150b3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01150b6:	c1 e0 05             	shl    $0x5,%eax
f01150b9:	83 ec 08             	sub    $0x8,%esp
f01150bc:	6a 03                	push   $0x3
f01150be:	6a 00                	push   $0x0
f01150c0:	6a 00                	push   $0x0
f01150c2:	68 07 0e 00 00       	push   $0xe07
f01150c7:	68 03 0e 00 00       	push   $0xe03
f01150cc:	6a 01                	push   $0x1
f01150ce:	50                   	push   %eax
f01150cf:	6a 00                	push   $0x0
f01150d1:	6a 00                	push   $0x0
f01150d3:	ff 75 cc             	pushl  -0x34(%ebp)
f01150d6:	e8 4f 1d 00 00       	call   f0116e2a <CCP>
f01150db:	83 c4 30             	add    $0x30,%esp
f01150de:	85 c0                	test   %eax,%eax
f01150e0:	75 25                	jne    f0115107 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01150e2:	83 ec 04             	sub    $0x4,%esp
f01150e5:	68 6c ae 12 f0       	push   $0xf012ae6c
f01150ea:	68 76 05 00 00       	push   $0x576
f01150ef:	68 82 98 12 f0       	push   $0xf0129882
f01150f4:	e8 dd b3 fe ff       	call   f01004d6 <_warn>
f01150f9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150fc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115100:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0115107:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011510b:	74 04                	je     f0115111 <test_allocate_chunk+0x415>
f011510d:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115111:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0115115:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0115119:	74 5a                	je     f0115175 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f011511b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011511e:	01 c0                	add    %eax,%eax
f0115120:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0115123:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115126:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0115129:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011512c:	01 c0                	add    %eax,%eax
f011512e:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0115131:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115134:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0115137:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011513a:	8a 00                	mov    (%eax),%al
f011513c:	3c 4b                	cmp    $0x4b,%al
f011513e:	75 09                	jne    f0115149 <test_allocate_chunk+0x44d>
f0115140:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115143:	8a 00                	mov    (%eax),%al
f0115145:	3c 4d                	cmp    $0x4d,%al
f0115147:	74 1e                	je     f0115167 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115149:	83 ec 04             	sub    $0x4,%esp
f011514c:	68 b8 ae 12 f0       	push   $0xf012aeb8
f0115151:	68 84 05 00 00       	push   $0x584
f0115156:	68 82 98 12 f0       	push   $0xf0129882
f011515b:	e8 76 b3 fe ff       	call   f01004d6 <_warn>
f0115160:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115163:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0115167:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011516b:	74 04                	je     f0115171 <test_allocate_chunk+0x475>
f011516d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0115171:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0115175:	83 ec 0c             	sub    $0xc,%esp
f0115178:	68 0f a2 12 f0       	push   $0xf012a20f
f011517d:	e8 09 be fe ff       	call   f0100f8b <cprintf>
f0115182:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0115185:	83 ec 0c             	sub    $0xc,%esp
f0115188:	68 90 af 12 f0       	push   $0xf012af90
f011518d:	e8 f9 bd fe ff       	call   f0100f8b <cprintf>
f0115192:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115195:	e8 ae 9a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011519a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f011519d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151a0:	c1 e0 06             	shl    $0x6,%eax
f01151a3:	89 c2                	mov    %eax,%edx
f01151a5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151a8:	c1 e0 05             	shl    $0x5,%eax
f01151ab:	6a 00                	push   $0x0
f01151ad:	52                   	push   %edx
f01151ae:	50                   	push   %eax
f01151af:	ff 75 cc             	pushl  -0x34(%ebp)
f01151b2:	e8 c1 5c ff ff       	call   f010ae78 <allocate_chunk>
f01151b7:	83 c4 10             	add    $0x10,%esp
f01151ba:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01151bd:	e8 86 9a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01151c2:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f01151c5:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f01151c9:	75 36                	jne    f0115201 <test_allocate_chunk+0x505>
f01151cb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01151ce:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01151d1:	89 c1                	mov    %eax,%ecx
f01151d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151d6:	c1 e0 06             	shl    $0x6,%eax
f01151d9:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01151dc:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01151e3:	99                   	cltd   
f01151e4:	f7 ff                	idiv   %edi
f01151e6:	89 c3                	mov    %eax,%ebx
f01151e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151eb:	c1 e0 06             	shl    $0x6,%eax
f01151ee:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01151f1:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01151f8:	99                   	cltd   
f01151f9:	f7 fe                	idiv   %esi
f01151fb:	01 d8                	add    %ebx,%eax
f01151fd:	39 c1                	cmp    %eax,%ecx
f01151ff:	74 54                	je     f0115255 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0115201:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115204:	c1 e0 06             	shl    $0x6,%eax
f0115207:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011520a:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115211:	99                   	cltd   
f0115212:	f7 fb                	idiv   %ebx
f0115214:	89 c1                	mov    %eax,%ecx
f0115216:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115219:	c1 e0 06             	shl    $0x6,%eax
f011521c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011521f:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0115226:	99                   	cltd   
f0115227:	f7 ff                	idiv   %edi
f0115229:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011522c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011522f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115232:	83 ec 08             	sub    $0x8,%esp
f0115235:	52                   	push   %edx
f0115236:	50                   	push   %eax
f0115237:	ff 75 a4             	pushl  -0x5c(%ebp)
f011523a:	68 30 af 12 f0       	push   $0xf012af30
f011523f:	68 9a 05 00 00       	push   $0x59a
f0115244:	68 82 98 12 f0       	push   $0xf0129882
f0115249:	e8 88 b2 fe ff       	call   f01004d6 <_warn>
f011524e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115251:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0115255:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115259:	74 04                	je     f011525f <test_allocate_chunk+0x563>
f011525b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011525f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115263:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011526a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011526d:	c1 e0 06             	shl    $0x6,%eax
f0115270:	89 c2                	mov    %eax,%edx
f0115272:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115275:	c1 e0 05             	shl    $0x5,%eax
f0115278:	83 ec 08             	sub    $0x8,%esp
f011527b:	6a 03                	push   $0x3
f011527d:	6a 00                	push   $0x0
f011527f:	6a 00                	push   $0x0
f0115281:	68 07 0e 00 00       	push   $0xe07
f0115286:	6a 01                	push   $0x1
f0115288:	6a 01                	push   $0x1
f011528a:	52                   	push   %edx
f011528b:	50                   	push   %eax
f011528c:	6a 00                	push   $0x0
f011528e:	ff 75 cc             	pushl  -0x34(%ebp)
f0115291:	e8 94 1b 00 00       	call   f0116e2a <CCP>
f0115296:	83 c4 30             	add    $0x30,%esp
f0115299:	85 c0                	test   %eax,%eax
f011529b:	75 25                	jne    f01152c2 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011529d:	83 ec 04             	sub    $0x4,%esp
f01152a0:	68 6c ae 12 f0       	push   $0xf012ae6c
f01152a5:	68 a3 05 00 00       	push   $0x5a3
f01152aa:	68 82 98 12 f0       	push   $0xf0129882
f01152af:	e8 22 b2 fe ff       	call   f01004d6 <_warn>
f01152b4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01152b7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01152bb:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f01152c2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01152c6:	74 04                	je     f01152cc <test_allocate_chunk+0x5d0>
f01152c8:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01152cc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f01152d0:	83 ec 0c             	sub    $0xc,%esp
f01152d3:	68 72 a2 12 f0       	push   $0xf012a272
f01152d8:	e8 ae bc fe ff       	call   f0100f8b <cprintf>
f01152dd:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f01152e0:	83 ec 0c             	sub    $0xc,%esp
f01152e3:	68 d0 af 12 f0       	push   $0xf012afd0
f01152e8:	e8 9e bc fe ff       	call   f0100f8b <cprintf>
f01152ed:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01152f0:	e8 53 99 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01152f5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f01152f8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152fb:	c1 e0 06             	shl    $0x6,%eax
f01152fe:	68 06 0e 00 00       	push   $0xe06
f0115303:	50                   	push   %eax
f0115304:	68 00 00 00 80       	push   $0x80000000
f0115309:	ff 75 cc             	pushl  -0x34(%ebp)
f011530c:	e8 67 5b ff ff       	call   f010ae78 <allocate_chunk>
f0115311:	83 c4 10             	add    $0x10,%esp
f0115314:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115317:	e8 2c 99 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011531c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f011531f:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0115323:	75 36                	jne    f011535b <test_allocate_chunk+0x65f>
f0115325:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115328:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011532b:	89 c1                	mov    %eax,%ecx
f011532d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115330:	c1 e0 06             	shl    $0x6,%eax
f0115333:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115336:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011533d:	99                   	cltd   
f011533e:	f7 fb                	idiv   %ebx
f0115340:	89 c3                	mov    %eax,%ebx
f0115342:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115345:	c1 e0 06             	shl    $0x6,%eax
f0115348:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011534b:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115352:	99                   	cltd   
f0115353:	f7 fe                	idiv   %esi
f0115355:	01 d8                	add    %ebx,%eax
f0115357:	39 c1                	cmp    %eax,%ecx
f0115359:	74 54                	je     f01153af <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f011535b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011535e:	c1 e0 06             	shl    $0x6,%eax
f0115361:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115364:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011536b:	99                   	cltd   
f011536c:	f7 ff                	idiv   %edi
f011536e:	89 c1                	mov    %eax,%ecx
f0115370:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115373:	c1 e0 06             	shl    $0x6,%eax
f0115376:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115379:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115380:	99                   	cltd   
f0115381:	f7 fb                	idiv   %ebx
f0115383:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115386:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115389:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011538c:	83 ec 08             	sub    $0x8,%esp
f011538f:	52                   	push   %edx
f0115390:	50                   	push   %eax
f0115391:	ff 75 9c             	pushl  -0x64(%ebp)
f0115394:	68 30 af 12 f0       	push   $0xf012af30
f0115399:	68 b9 05 00 00       	push   $0x5b9
f011539e:	68 82 98 12 f0       	push   $0xf0129882
f01153a3:	e8 2e b1 fe ff       	call   f01004d6 <_warn>
f01153a8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153ab:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01153af:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01153b3:	74 04                	je     f01153b9 <test_allocate_chunk+0x6bd>
f01153b5:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01153b9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01153bd:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01153c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01153c7:	c1 e0 06             	shl    $0x6,%eax
f01153ca:	83 ec 08             	sub    $0x8,%esp
f01153cd:	6a 03                	push   $0x3
f01153cf:	6a 00                	push   $0x0
f01153d1:	6a 00                	push   $0x0
f01153d3:	68 07 0e 00 00       	push   $0xe07
f01153d8:	68 07 0e 00 00       	push   $0xe07
f01153dd:	6a 01                	push   $0x1
f01153df:	50                   	push   %eax
f01153e0:	68 00 00 00 80       	push   $0x80000000
f01153e5:	6a 00                	push   $0x0
f01153e7:	ff 75 cc             	pushl  -0x34(%ebp)
f01153ea:	e8 3b 1a 00 00       	call   f0116e2a <CCP>
f01153ef:	83 c4 30             	add    $0x30,%esp
f01153f2:	85 c0                	test   %eax,%eax
f01153f4:	75 25                	jne    f011541b <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01153f6:	83 ec 04             	sub    $0x4,%esp
f01153f9:	68 6c ae 12 f0       	push   $0xf012ae6c
f01153fe:	68 c2 05 00 00       	push   $0x5c2
f0115403:	68 82 98 12 f0       	push   $0xf0129882
f0115408:	e8 c9 b0 fe ff       	call   f01004d6 <_warn>
f011540d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115410:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115414:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f011541b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011541f:	74 04                	je     f0115425 <test_allocate_chunk+0x729>
f0115421:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115425:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0115429:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011542d:	74 6f                	je     f011549e <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f011542f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115432:	01 c0                	add    %eax,%eax
f0115434:	05 00 00 00 80       	add    $0x80000000,%eax
f0115439:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011543c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011543f:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0115442:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115445:	89 d0                	mov    %edx,%eax
f0115447:	c1 e0 02             	shl    $0x2,%eax
f011544a:	01 d0                	add    %edx,%eax
f011544c:	01 c0                	add    %eax,%eax
f011544e:	01 d0                	add    %edx,%eax
f0115450:	01 c0                	add    %eax,%eax
f0115452:	05 00 00 00 80       	add    $0x80000000,%eax
f0115457:	89 45 bc             	mov    %eax,-0x44(%ebp)
f011545a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011545d:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0115460:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115463:	8a 00                	mov    (%eax),%al
f0115465:	3c 4b                	cmp    $0x4b,%al
f0115467:	75 09                	jne    f0115472 <test_allocate_chunk+0x776>
f0115469:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011546c:	8a 00                	mov    (%eax),%al
f011546e:	3c 4d                	cmp    $0x4d,%al
f0115470:	74 1e                	je     f0115490 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115472:	83 ec 04             	sub    $0x4,%esp
f0115475:	68 b8 ae 12 f0       	push   $0xf012aeb8
f011547a:	68 d0 05 00 00       	push   $0x5d0
f011547f:	68 82 98 12 f0       	push   $0xf0129882
f0115484:	e8 4d b0 fe ff       	call   f01004d6 <_warn>
f0115489:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011548c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0115490:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115494:	74 04                	je     f011549a <test_allocate_chunk+0x79e>
f0115496:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f011549a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f011549e:	83 ec 0c             	sub    $0xc,%esp
f01154a1:	68 44 ad 12 f0       	push   $0xf012ad44
f01154a6:	e8 e0 ba fe ff       	call   f0100f8b <cprintf>
f01154ab:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f01154ae:	83 ec 0c             	sub    $0xc,%esp
f01154b1:	68 0c b0 12 f0       	push   $0xf012b00c
f01154b6:	e8 d0 ba fe ff       	call   f0100f8b <cprintf>
f01154bb:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01154be:	e8 85 97 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01154c3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f01154c6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01154c9:	89 d0                	mov    %edx,%eax
f01154cb:	01 c0                	add    %eax,%eax
f01154cd:	01 d0                	add    %edx,%eax
f01154cf:	01 c0                	add    %eax,%eax
f01154d1:	01 d0                	add    %edx,%eax
f01154d3:	68 04 0e 00 00       	push   $0xe04
f01154d8:	50                   	push   %eax
f01154d9:	68 00 fc 3f 40       	push   $0x403ffc00
f01154de:	ff 75 cc             	pushl  -0x34(%ebp)
f01154e1:	e8 92 59 ff ff       	call   f010ae78 <allocate_chunk>
f01154e6:	83 c4 10             	add    $0x10,%esp
f01154e9:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01154ec:	e8 57 97 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01154f1:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f01154f4:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f01154f8:	75 0b                	jne    f0115505 <test_allocate_chunk+0x809>
f01154fa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01154fd:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115500:	83 f8 05             	cmp    $0x5,%eax
f0115503:	74 2a                	je     f011552f <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0115505:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115508:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011550b:	83 ec 08             	sub    $0x8,%esp
f011550e:	6a 05                	push   $0x5
f0115510:	50                   	push   %eax
f0115511:	ff 75 98             	pushl  -0x68(%ebp)
f0115514:	68 30 af 12 f0       	push   $0xf012af30
f0115519:	68 e7 05 00 00       	push   $0x5e7
f011551e:	68 82 98 12 f0       	push   $0xf0129882
f0115523:	e8 ae af fe ff       	call   f01004d6 <_warn>
f0115528:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011552b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011552f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115533:	74 04                	je     f0115539 <test_allocate_chunk+0x83d>
f0115535:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115539:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f011553d:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0115544:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115547:	89 d0                	mov    %edx,%eax
f0115549:	01 c0                	add    %eax,%eax
f011554b:	01 d0                	add    %edx,%eax
f011554d:	c1 e0 02             	shl    $0x2,%eax
f0115550:	83 ec 08             	sub    $0x8,%esp
f0115553:	6a 03                	push   $0x3
f0115555:	6a 00                	push   $0x0
f0115557:	6a 00                	push   $0x0
f0115559:	68 07 0e 00 00       	push   $0xe07
f011555e:	68 05 0e 00 00       	push   $0xe05
f0115563:	6a 01                	push   $0x1
f0115565:	50                   	push   %eax
f0115566:	68 00 f0 3f 40       	push   $0x403ff000
f011556b:	6a 00                	push   $0x0
f011556d:	ff 75 cc             	pushl  -0x34(%ebp)
f0115570:	e8 b5 18 00 00       	call   f0116e2a <CCP>
f0115575:	83 c4 30             	add    $0x30,%esp
f0115578:	85 c0                	test   %eax,%eax
f011557a:	75 25                	jne    f01155a1 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011557c:	83 ec 04             	sub    $0x4,%esp
f011557f:	68 6c ae 12 f0       	push   $0xf012ae6c
f0115584:	68 f0 05 00 00       	push   $0x5f0
f0115589:	68 82 98 12 f0       	push   $0xf0129882
f011558e:	e8 43 af fe ff       	call   f01004d6 <_warn>
f0115593:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115596:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011559a:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01155a1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01155a5:	74 04                	je     f01155ab <test_allocate_chunk+0x8af>
f01155a7:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01155ab:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01155af:	83 ec 0c             	sub    $0xc,%esp
f01155b2:	68 43 b0 12 f0       	push   $0xf012b043
f01155b7:	e8 cf b9 fe ff       	call   f0100f8b <cprintf>
f01155bc:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f01155bf:	83 ec 08             	sub    $0x8,%esp
f01155c2:	ff 75 e0             	pushl  -0x20(%ebp)
f01155c5:	68 54 b0 12 f0       	push   $0xf012b054
f01155ca:	e8 bc b9 fe ff       	call   f0100f8b <cprintf>
f01155cf:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01155d2:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f01155d6:	75 10                	jne    f01155e8 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f01155d8:	83 ec 0c             	sub    $0xc,%esp
f01155db:	68 88 b0 12 f0       	push   $0xf012b088
f01155e0:	e8 a6 b9 fe ff       	call   f0100f8b <cprintf>
f01155e5:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01155e8:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f01155ed:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01155f0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01155f3:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01155f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01155fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01155fe:	5b                   	pop    %ebx
f01155ff:	5e                   	pop    %esi
f0115600:	5f                   	pop    %edi
f0115601:	5d                   	pop    %ebp
f0115602:	c3                   	ret    

f0115603 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0115603:	55                   	push   %ebp
f0115604:	89 e5                	mov    %esp,%ebp
f0115606:	57                   	push   %edi
f0115607:	56                   	push   %esi
f0115608:	53                   	push   %ebx
f0115609:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011560f:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115612:	bb 84 9f 12 f0       	mov    $0xf0129f84,%ebx
f0115617:	ba 0f 00 00 00       	mov    $0xf,%edx
f011561c:	89 c7                	mov    %eax,%edi
f011561e:	89 de                	mov    %ebx,%esi
f0115620:	89 d1                	mov    %edx,%ecx
f0115622:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115624:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115627:	b9 23 00 00 00       	mov    $0x23,%ecx
f011562c:	b0 00                	mov    $0x0,%al
f011562e:	89 d7                	mov    %edx,%edi
f0115630:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115632:	6a 00                	push   $0x0
f0115634:	6a 0a                	push   $0xa
f0115636:	6a 14                	push   $0x14
f0115638:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011563b:	50                   	push   %eax
f011563c:	e8 66 5c ff ff       	call   f010b2a7 <env_create>
f0115641:	83 c4 10             	add    $0x10,%esp
f0115644:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115647:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011564a:	8b 40 64             	mov    0x64(%eax),%eax
f011564d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115650:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115653:	8b 40 68             	mov    0x68(%eax),%eax
f0115656:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115659:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011565c:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011565f:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115666:	75 70 20 
f0115669:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115670:	00 00 00 
f0115673:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115676:	b9 03 00 00 00       	mov    $0x3,%ecx
f011567b:	b8 00 00 00 00       	mov    $0x0,%eax
f0115680:	89 d7                	mov    %edx,%edi
f0115682:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115684:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115687:	8b 40 10             	mov    0x10(%eax),%eax
f011568a:	83 ec 08             	sub    $0x8,%esp
f011568d:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115693:	52                   	push   %edx
f0115694:	50                   	push   %eax
f0115695:	e8 28 ae 00 00       	call   f01204c2 <ltostr>
f011569a:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011569d:	83 ec 04             	sub    $0x4,%esp
f01156a0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01156a6:	50                   	push   %eax
f01156a7:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01156ad:	50                   	push   %eax
f01156ae:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01156b4:	50                   	push   %eax
f01156b5:	e8 e1 ae 00 00       	call   f012059b <strcconcat>
f01156ba:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01156bd:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01156c4:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01156cb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f01156d2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f01156d9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f01156dd:	83 ec 0c             	sub    $0xc,%esp
f01156e0:	ff 75 d8             	pushl  -0x28(%ebp)
f01156e3:	e8 0e 17 00 00       	call   f0116df6 <ClearUserSpace>
f01156e8:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01156eb:	83 ec 0c             	sub    $0xc,%esp
f01156ee:	68 c8 b0 12 f0       	push   $0xf012b0c8
f01156f3:	e8 93 b8 fe ff       	call   f0100f8b <cprintf>
f01156f8:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01156fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01156fe:	c1 e0 03             	shl    $0x3,%eax
f0115701:	83 ec 04             	sub    $0x4,%esp
f0115704:	50                   	push   %eax
f0115705:	6a 00                	push   $0x0
f0115707:	ff 75 d8             	pushl  -0x28(%ebp)
f011570a:	e8 9d 57 ff ff       	call   f010aeac <calculate_required_frames>
f011570f:	83 c4 10             	add    $0x10,%esp
f0115712:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115715:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115719:	74 23                	je     f011573e <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011571b:	83 ec 0c             	sub    $0xc,%esp
f011571e:	6a 03                	push   $0x3
f0115720:	ff 75 c8             	pushl  -0x38(%ebp)
f0115723:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115728:	68 29 06 00 00       	push   $0x629
f011572d:	68 82 98 12 f0       	push   $0xf0129882
f0115732:	e8 9f ad fe ff       	call   f01004d6 <_warn>
f0115737:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011573a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011573e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115742:	74 04                	je     f0115748 <test_calculate_required_frames+0x145>
f0115744:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115748:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f011574c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011574f:	c1 e0 02             	shl    $0x2,%eax
f0115752:	83 ec 04             	sub    $0x4,%esp
f0115755:	50                   	push   %eax
f0115756:	6a 00                	push   $0x0
f0115758:	ff 75 d8             	pushl  -0x28(%ebp)
f011575b:	e8 4c 57 ff ff       	call   f010aeac <calculate_required_frames>
f0115760:	83 c4 10             	add    $0x10,%esp
f0115763:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0115766:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f011576d:	74 26                	je     f0115795 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f011576f:	83 ec 0c             	sub    $0xc,%esp
f0115772:	68 01 04 00 00       	push   $0x401
f0115777:	ff 75 c8             	pushl  -0x38(%ebp)
f011577a:	68 fc b0 12 f0       	push   $0xf012b0fc
f011577f:	68 33 06 00 00       	push   $0x633
f0115784:	68 82 98 12 f0       	push   $0xf0129882
f0115789:	e8 48 ad fe ff       	call   f01004d6 <_warn>
f011578e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115791:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115795:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115799:	74 04                	je     f011579f <test_calculate_required_frames+0x19c>
f011579b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011579f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01157a3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157a6:	c1 e0 0a             	shl    $0xa,%eax
f01157a9:	83 ec 04             	sub    $0x4,%esp
f01157ac:	50                   	push   %eax
f01157ad:	6a 00                	push   $0x0
f01157af:	ff 75 d8             	pushl  -0x28(%ebp)
f01157b2:	e8 f5 56 ff ff       	call   f010aeac <calculate_required_frames>
f01157b7:	83 c4 10             	add    $0x10,%esp
f01157ba:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f01157bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157c0:	c1 e0 0a             	shl    $0xa,%eax
f01157c3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01157c6:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01157cd:	99                   	cltd   
f01157ce:	f7 fb                	idiv   %ebx
f01157d0:	89 c1                	mov    %eax,%ecx
f01157d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157d5:	c1 e0 0a             	shl    $0xa,%eax
f01157d8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01157db:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01157e2:	99                   	cltd   
f01157e3:	f7 fe                	idiv   %esi
f01157e5:	01 c8                	add    %ecx,%eax
f01157e7:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01157ea:	74 4c                	je     f0115838 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f01157ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157ef:	c1 e0 0a             	shl    $0xa,%eax
f01157f2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01157f5:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01157fc:	99                   	cltd   
f01157fd:	f7 fb                	idiv   %ebx
f01157ff:	89 c1                	mov    %eax,%ecx
f0115801:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115804:	c1 e0 0a             	shl    $0xa,%eax
f0115807:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011580a:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115811:	99                   	cltd   
f0115812:	f7 fe                	idiv   %esi
f0115814:	01 c8                	add    %ecx,%eax
f0115816:	83 ec 0c             	sub    $0xc,%esp
f0115819:	50                   	push   %eax
f011581a:	ff 75 c8             	pushl  -0x38(%ebp)
f011581d:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115822:	68 3d 06 00 00       	push   $0x63d
f0115827:	68 82 98 12 f0       	push   $0xf0129882
f011582c:	e8 a5 ac fe ff       	call   f01004d6 <_warn>
f0115831:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115834:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115838:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011583c:	74 04                	je     f0115842 <test_calculate_required_frames+0x23f>
f011583e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115842:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0115846:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115849:	89 d0                	mov    %edx,%eax
f011584b:	01 c0                	add    %eax,%eax
f011584d:	01 d0                	add    %edx,%eax
f011584f:	01 c0                	add    %eax,%eax
f0115851:	83 ec 04             	sub    $0x4,%esp
f0115854:	50                   	push   %eax
f0115855:	68 00 10 00 00       	push   $0x1000
f011585a:	ff 75 d8             	pushl  -0x28(%ebp)
f011585d:	e8 4a 56 ff ff       	call   f010aeac <calculate_required_frames>
f0115862:	83 c4 10             	add    $0x10,%esp
f0115865:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115868:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011586c:	74 23                	je     f0115891 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011586e:	83 ec 0c             	sub    $0xc,%esp
f0115871:	6a 03                	push   $0x3
f0115873:	ff 75 c8             	pushl  -0x38(%ebp)
f0115876:	68 fc b0 12 f0       	push   $0xf012b0fc
f011587b:	68 49 06 00 00       	push   $0x649
f0115880:	68 82 98 12 f0       	push   $0xf0129882
f0115885:	e8 4c ac fe ff       	call   f01004d6 <_warn>
f011588a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011588d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115891:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115895:	74 04                	je     f011589b <test_calculate_required_frames+0x298>
f0115897:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011589b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f011589f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01158a2:	89 c2                	mov    %eax,%edx
f01158a4:	01 d2                	add    %edx,%edx
f01158a6:	01 d0                	add    %edx,%eax
f01158a8:	83 ec 04             	sub    $0x4,%esp
f01158ab:	50                   	push   %eax
f01158ac:	68 00 18 00 00       	push   $0x1800
f01158b1:	ff 75 d8             	pushl  -0x28(%ebp)
f01158b4:	e8 f3 55 ff ff       	call   f010aeac <calculate_required_frames>
f01158b9:	83 c4 10             	add    $0x10,%esp
f01158bc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01158bf:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01158c3:	74 23                	je     f01158e8 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01158c5:	83 ec 0c             	sub    $0xc,%esp
f01158c8:	6a 03                	push   $0x3
f01158ca:	ff 75 c8             	pushl  -0x38(%ebp)
f01158cd:	68 fc b0 12 f0       	push   $0xf012b0fc
f01158d2:	68 53 06 00 00       	push   $0x653
f01158d7:	68 82 98 12 f0       	push   $0xf0129882
f01158dc:	e8 f5 ab fe ff       	call   f01004d6 <_warn>
f01158e1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158e4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01158e8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158ec:	74 04                	je     f01158f2 <test_calculate_required_frames+0x2ef>
f01158ee:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158f2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01158f6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01158f9:	89 d0                	mov    %edx,%eax
f01158fb:	c1 e0 02             	shl    $0x2,%eax
f01158fe:	01 d0                	add    %edx,%eax
f0115900:	01 c0                	add    %eax,%eax
f0115902:	83 ec 04             	sub    $0x4,%esp
f0115905:	50                   	push   %eax
f0115906:	68 00 00 40 00       	push   $0x400000
f011590b:	ff 75 d8             	pushl  -0x28(%ebp)
f011590e:	e8 99 55 ff ff       	call   f010aeac <calculate_required_frames>
f0115913:	83 c4 10             	add    $0x10,%esp
f0115916:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0115919:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0115920:	74 26                	je     f0115948 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115922:	83 ec 0c             	sub    $0xc,%esp
f0115925:	68 03 0a 00 00       	push   $0xa03
f011592a:	ff 75 c8             	pushl  -0x38(%ebp)
f011592d:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115932:	68 5d 06 00 00       	push   $0x65d
f0115937:	68 82 98 12 f0       	push   $0xf0129882
f011593c:	e8 95 ab fe ff       	call   f01004d6 <_warn>
f0115941:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115944:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115948:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011594c:	74 04                	je     f0115952 <test_calculate_required_frames+0x34f>
f011594e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115952:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115956:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115959:	01 c0                	add    %eax,%eax
f011595b:	83 ec 04             	sub    $0x4,%esp
f011595e:	50                   	push   %eax
f011595f:	68 00 00 70 00       	push   $0x700000
f0115964:	ff 75 d8             	pushl  -0x28(%ebp)
f0115967:	e8 40 55 ff ff       	call   f010aeac <calculate_required_frames>
f011596c:	83 c4 10             	add    $0x10,%esp
f011596f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0115972:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115979:	74 26                	je     f01159a1 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f011597b:	83 ec 0c             	sub    $0xc,%esp
f011597e:	68 02 02 00 00       	push   $0x202
f0115983:	ff 75 c8             	pushl  -0x38(%ebp)
f0115986:	68 fc b0 12 f0       	push   $0xf012b0fc
f011598b:	68 69 06 00 00       	push   $0x669
f0115990:	68 82 98 12 f0       	push   $0xf0129882
f0115995:	e8 3c ab fe ff       	call   f01004d6 <_warn>
f011599a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011599d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01159a1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159a5:	74 04                	je     f01159ab <test_calculate_required_frames+0x3a8>
f01159a7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01159ab:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01159af:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01159b2:	83 ec 04             	sub    $0x4,%esp
f01159b5:	50                   	push   %eax
f01159b6:	68 ff ff 3f 00       	push   $0x3fffff
f01159bb:	ff 75 d8             	pushl  -0x28(%ebp)
f01159be:	e8 e9 54 ff ff       	call   f010aeac <calculate_required_frames>
f01159c3:	83 c4 10             	add    $0x10,%esp
f01159c6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f01159c9:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f01159cd:	74 23                	je     f01159f2 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f01159cf:	83 ec 0c             	sub    $0xc,%esp
f01159d2:	6a 04                	push   $0x4
f01159d4:	ff 75 c8             	pushl  -0x38(%ebp)
f01159d7:	68 fc b0 12 f0       	push   $0xf012b0fc
f01159dc:	68 73 06 00 00       	push   $0x673
f01159e1:	68 82 98 12 f0       	push   $0xf0129882
f01159e6:	e8 eb aa fe ff       	call   f01004d6 <_warn>
f01159eb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159ee:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01159f2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159f6:	74 04                	je     f01159fc <test_calculate_required_frames+0x3f9>
f01159f8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01159fc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115a00:	83 ec 0c             	sub    $0xc,%esp
f0115a03:	68 35 ac 12 f0       	push   $0xf012ac35
f0115a08:	e8 7e b5 fe ff       	call   f0100f8b <cprintf>
f0115a0d:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115a10:	83 ec 0c             	sub    $0xc,%esp
f0115a13:	68 54 b1 12 f0       	push   $0xf012b154
f0115a18:	e8 6e b5 fe ff       	call   f0100f8b <cprintf>
f0115a1d:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115a20:	83 ec 04             	sub    $0x4,%esp
f0115a23:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115a29:	50                   	push   %eax
f0115a2a:	68 ee 9f 12 f0       	push   $0xf0129fee
f0115a2f:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115a35:	50                   	push   %eax
f0115a36:	e8 60 ab 00 00       	call   f012059b <strcconcat>
f0115a3b:	83 c4 10             	add    $0x10,%esp
f0115a3e:	83 ec 0c             	sub    $0xc,%esp
f0115a41:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115a47:	50                   	push   %eax
f0115a48:	e8 ae c4 fe ff       	call   f0101efb <execute_command>
f0115a4d:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115a50:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a53:	c1 e0 03             	shl    $0x3,%eax
f0115a56:	83 ec 04             	sub    $0x4,%esp
f0115a59:	50                   	push   %eax
f0115a5a:	6a 00                	push   $0x0
f0115a5c:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a5f:	e8 48 54 ff ff       	call   f010aeac <calculate_required_frames>
f0115a64:	83 c4 10             	add    $0x10,%esp
f0115a67:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115a6a:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115a71:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115a74:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115a77:	74 24                	je     f0115a9d <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115a79:	83 ec 0c             	sub    $0xc,%esp
f0115a7c:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115a7f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a82:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115a87:	68 87 06 00 00       	push   $0x687
f0115a8c:	68 82 98 12 f0       	push   $0xf0129882
f0115a91:	e8 40 aa fe ff       	call   f01004d6 <_warn>
f0115a96:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a99:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a9d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115aa1:	74 04                	je     f0115aa7 <test_calculate_required_frames+0x4a4>
f0115aa3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115aa7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115aab:	83 ec 04             	sub    $0x4,%esp
f0115aae:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115ab4:	50                   	push   %eax
f0115ab5:	68 fb 9f 12 f0       	push   $0xf0129ffb
f0115aba:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115ac0:	50                   	push   %eax
f0115ac1:	e8 d5 aa 00 00       	call   f012059b <strcconcat>
f0115ac6:	83 c4 10             	add    $0x10,%esp
f0115ac9:	83 ec 0c             	sub    $0xc,%esp
f0115acc:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115ad2:	50                   	push   %eax
f0115ad3:	e8 23 c4 fe ff       	call   f0101efb <execute_command>
f0115ad8:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115adb:	83 ec 04             	sub    $0x4,%esp
f0115ade:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115ae4:	50                   	push   %eax
f0115ae5:	68 88 b1 12 f0       	push   $0xf012b188
f0115aea:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115af0:	50                   	push   %eax
f0115af1:	e8 a5 aa 00 00       	call   f012059b <strcconcat>
f0115af6:	83 c4 10             	add    $0x10,%esp
f0115af9:	83 ec 0c             	sub    $0xc,%esp
f0115afc:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115b02:	50                   	push   %eax
f0115b03:	e8 f3 c3 fe ff       	call   f0101efb <execute_command>
f0115b08:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0115b0b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115b0e:	c1 e0 03             	shl    $0x3,%eax
f0115b11:	83 ec 04             	sub    $0x4,%esp
f0115b14:	50                   	push   %eax
f0115b15:	6a 00                	push   $0x0
f0115b17:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b1a:	e8 8d 53 ff ff       	call   f010aeac <calculate_required_frames>
f0115b1f:	83 c4 10             	add    $0x10,%esp
f0115b22:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0115b25:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115b2c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115b2f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115b32:	74 24                	je     f0115b58 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115b34:	83 ec 0c             	sub    $0xc,%esp
f0115b37:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115b3a:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b3d:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115b42:	68 95 06 00 00       	push   $0x695
f0115b47:	68 82 98 12 f0       	push   $0xf0129882
f0115b4c:	e8 85 a9 fe ff       	call   f01004d6 <_warn>
f0115b51:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b54:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b58:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b5c:	74 04                	je     f0115b62 <test_calculate_required_frames+0x55f>
f0115b5e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b62:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115b66:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115b69:	c1 e0 0a             	shl    $0xa,%eax
f0115b6c:	83 ec 04             	sub    $0x4,%esp
f0115b6f:	50                   	push   %eax
f0115b70:	6a 00                	push   $0x0
f0115b72:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b75:	e8 32 53 ff ff       	call   f010aeac <calculate_required_frames>
f0115b7a:	83 c4 10             	add    $0x10,%esp
f0115b7d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115b80:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115b83:	c1 e0 0a             	shl    $0xa,%eax
f0115b86:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115b89:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115b90:	99                   	cltd   
f0115b91:	f7 fb                	idiv   %ebx
f0115b93:	89 c1                	mov    %eax,%ecx
f0115b95:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115b98:	c1 e0 0a             	shl    $0xa,%eax
f0115b9b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115b9e:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115ba5:	99                   	cltd   
f0115ba6:	f7 fe                	idiv   %esi
f0115ba8:	01 c8                	add    %ecx,%eax
f0115baa:	83 e8 05             	sub    $0x5,%eax
f0115bad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115bb0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115bb3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115bb6:	74 24                	je     f0115bdc <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115bb8:	83 ec 0c             	sub    $0xc,%esp
f0115bbb:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115bbe:	ff 75 c8             	pushl  -0x38(%ebp)
f0115bc1:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115bc6:	68 a0 06 00 00       	push   $0x6a0
f0115bcb:	68 82 98 12 f0       	push   $0xf0129882
f0115bd0:	e8 01 a9 fe ff       	call   f01004d6 <_warn>
f0115bd5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115bd8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115bdc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115be0:	74 04                	je     f0115be6 <test_calculate_required_frames+0x5e3>
f0115be2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115be6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115bea:	83 ec 04             	sub    $0x4,%esp
f0115bed:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115bf3:	50                   	push   %eax
f0115bf4:	68 94 b1 12 f0       	push   $0xf012b194
f0115bf9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115bff:	50                   	push   %eax
f0115c00:	e8 96 a9 00 00       	call   f012059b <strcconcat>
f0115c05:	83 c4 10             	add    $0x10,%esp
f0115c08:	83 ec 0c             	sub    $0xc,%esp
f0115c0b:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115c11:	50                   	push   %eax
f0115c12:	e8 e4 c2 fe ff       	call   f0101efb <execute_command>
f0115c17:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115c1a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115c1d:	89 c2                	mov    %eax,%edx
f0115c1f:	01 d2                	add    %edx,%edx
f0115c21:	01 d0                	add    %edx,%eax
f0115c23:	83 ec 04             	sub    $0x4,%esp
f0115c26:	50                   	push   %eax
f0115c27:	68 00 18 00 00       	push   $0x1800
f0115c2c:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c2f:	e8 78 52 ff ff       	call   f010aeac <calculate_required_frames>
f0115c34:	83 c4 10             	add    $0x10,%esp
f0115c37:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115c3a:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115c41:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115c44:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115c47:	74 24                	je     f0115c6d <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115c49:	83 ec 0c             	sub    $0xc,%esp
f0115c4c:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115c4f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c52:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115c57:	68 af 06 00 00       	push   $0x6af
f0115c5c:	68 82 98 12 f0       	push   $0xf0129882
f0115c61:	e8 70 a8 fe ff       	call   f01004d6 <_warn>
f0115c66:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c69:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115c6d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c71:	74 04                	je     f0115c77 <test_calculate_required_frames+0x674>
f0115c73:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115c77:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115c7b:	83 ec 04             	sub    $0x4,%esp
f0115c7e:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115c84:	50                   	push   %eax
f0115c85:	68 54 a2 12 f0       	push   $0xf012a254
f0115c8a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c90:	50                   	push   %eax
f0115c91:	e8 05 a9 00 00       	call   f012059b <strcconcat>
f0115c96:	83 c4 10             	add    $0x10,%esp
f0115c99:	83 ec 0c             	sub    $0xc,%esp
f0115c9c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115ca2:	50                   	push   %eax
f0115ca3:	e8 53 c2 fe ff       	call   f0101efb <execute_command>
f0115ca8:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115cab:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115cae:	89 d0                	mov    %edx,%eax
f0115cb0:	c1 e0 02             	shl    $0x2,%eax
f0115cb3:	01 d0                	add    %edx,%eax
f0115cb5:	01 c0                	add    %eax,%eax
f0115cb7:	83 ec 04             	sub    $0x4,%esp
f0115cba:	50                   	push   %eax
f0115cbb:	68 00 00 40 00       	push   $0x400000
f0115cc0:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cc3:	e8 e4 51 ff ff       	call   f010aeac <calculate_required_frames>
f0115cc8:	83 c4 10             	add    $0x10,%esp
f0115ccb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115cce:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0115cd5:	74 26                	je     f0115cfd <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115cd7:	83 ec 0c             	sub    $0xc,%esp
f0115cda:	68 03 0a 00 00       	push   $0xa03
f0115cdf:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ce2:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115ce7:	68 bb 06 00 00       	push   $0x6bb
f0115cec:	68 82 98 12 f0       	push   $0xf0129882
f0115cf1:	e8 e0 a7 fe ff       	call   f01004d6 <_warn>
f0115cf6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cf9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115cfd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d01:	74 04                	je     f0115d07 <test_calculate_required_frames+0x704>
f0115d03:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d07:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115d0b:	83 ec 04             	sub    $0x4,%esp
f0115d0e:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115d14:	50                   	push   %eax
f0115d15:	68 5e a2 12 f0       	push   $0xf012a25e
f0115d1a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d20:	50                   	push   %eax
f0115d21:	e8 75 a8 00 00       	call   f012059b <strcconcat>
f0115d26:	83 c4 10             	add    $0x10,%esp
f0115d29:	83 ec 0c             	sub    $0xc,%esp
f0115d2c:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115d32:	50                   	push   %eax
f0115d33:	e8 c3 c1 fe ff       	call   f0101efb <execute_command>
f0115d38:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115d3b:	83 ec 04             	sub    $0x4,%esp
f0115d3e:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115d44:	50                   	push   %eax
f0115d45:	68 9c b1 12 f0       	push   $0xf012b19c
f0115d4a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d50:	50                   	push   %eax
f0115d51:	e8 45 a8 00 00       	call   f012059b <strcconcat>
f0115d56:	83 c4 10             	add    $0x10,%esp
f0115d59:	83 ec 0c             	sub    $0xc,%esp
f0115d5c:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115d62:	50                   	push   %eax
f0115d63:	e8 93 c1 fe ff       	call   f0101efb <execute_command>
f0115d68:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115d6b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115d6e:	01 c0                	add    %eax,%eax
f0115d70:	83 ec 04             	sub    $0x4,%esp
f0115d73:	50                   	push   %eax
f0115d74:	68 00 00 70 00       	push   $0x700000
f0115d79:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d7c:	e8 2b 51 ff ff       	call   f010aeac <calculate_required_frames>
f0115d81:	83 c4 10             	add    $0x10,%esp
f0115d84:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115d87:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115d8e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115d91:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d94:	74 24                	je     f0115dba <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115d96:	83 ec 0c             	sub    $0xc,%esp
f0115d99:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d9c:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d9f:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115da4:	68 cb 06 00 00       	push   $0x6cb
f0115da9:	68 82 98 12 f0       	push   $0xf0129882
f0115dae:	e8 23 a7 fe ff       	call   f01004d6 <_warn>
f0115db3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115db6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115dba:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115dbe:	74 04                	je     f0115dc4 <test_calculate_required_frames+0x7c1>
f0115dc0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115dc4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115dc8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115dcb:	83 ec 04             	sub    $0x4,%esp
f0115dce:	50                   	push   %eax
f0115dcf:	68 ff ff 3f 00       	push   $0x3fffff
f0115dd4:	ff 75 d8             	pushl  -0x28(%ebp)
f0115dd7:	e8 d0 50 ff ff       	call   f010aeac <calculate_required_frames>
f0115ddc:	83 c4 10             	add    $0x10,%esp
f0115ddf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0115de2:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115de9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115dec:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115def:	74 24                	je     f0115e15 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115df1:	83 ec 0c             	sub    $0xc,%esp
f0115df4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115df7:	ff 75 c8             	pushl  -0x38(%ebp)
f0115dfa:	68 fc b0 12 f0       	push   $0xf012b0fc
f0115dff:	68 d6 06 00 00       	push   $0x6d6
f0115e04:	68 82 98 12 f0       	push   $0xf0129882
f0115e09:	e8 c8 a6 fe ff       	call   f01004d6 <_warn>
f0115e0e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e11:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115e15:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e19:	74 04                	je     f0115e1f <test_calculate_required_frames+0x81c>
f0115e1b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115e1f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115e23:	83 ec 0c             	sub    $0xc,%esp
f0115e26:	68 0f a2 12 f0       	push   $0xf012a20f
f0115e2b:	e8 5b b1 fe ff       	call   f0100f8b <cprintf>
f0115e30:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115e33:	83 ec 08             	sub    $0x8,%esp
f0115e36:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115e39:	68 a8 b1 12 f0       	push   $0xf012b1a8
f0115e3e:	e8 48 b1 fe ff       	call   f0100f8b <cprintf>
f0115e43:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115e46:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115e4a:	75 10                	jne    f0115e5c <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115e4c:	83 ec 0c             	sub    $0xc,%esp
f0115e4f:	68 e8 b1 12 f0       	push   $0xf012b1e8
f0115e54:	e8 32 b1 fe ff       	call   f0100f8b <cprintf>
f0115e59:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115e5c:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f0115e61:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115e64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115e67:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115e6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115e72:	5b                   	pop    %ebx
f0115e73:	5e                   	pop    %esi
f0115e74:	5f                   	pop    %edi
f0115e75:	5d                   	pop    %ebp
f0115e76:	c3                   	ret    

f0115e77 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115e77:	55                   	push   %ebp
f0115e78:	89 e5                	mov    %esp,%ebp
f0115e7a:	57                   	push   %edi
f0115e7b:	56                   	push   %esi
f0115e7c:	53                   	push   %ebx
f0115e7d:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115e83:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115e86:	bb 84 9f 12 f0       	mov    $0xf0129f84,%ebx
f0115e8b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115e90:	89 c7                	mov    %eax,%edi
f0115e92:	89 de                	mov    %ebx,%esi
f0115e94:	89 d1                	mov    %edx,%ecx
f0115e96:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115e98:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115e9b:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115ea0:	b0 00                	mov    $0x0,%al
f0115ea2:	89 d7                	mov    %edx,%edi
f0115ea4:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115ea6:	6a 00                	push   $0x0
f0115ea8:	6a 0a                	push   $0xa
f0115eaa:	6a 14                	push   $0x14
f0115eac:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115eaf:	50                   	push   %eax
f0115eb0:	e8 f2 53 ff ff       	call   f010b2a7 <env_create>
f0115eb5:	83 c4 10             	add    $0x10,%esp
f0115eb8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115ebb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115ebe:	8b 40 64             	mov    0x64(%eax),%eax
f0115ec1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115ec4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115ec7:	8b 40 68             	mov    0x68(%eax),%eax
f0115eca:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115ecd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115ed0:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115ed3:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115eda:	75 70 20 
f0115edd:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115ee4:	00 00 00 
f0115ee7:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115eea:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115eef:	b8 00 00 00 00       	mov    $0x0,%eax
f0115ef4:	89 d7                	mov    %edx,%edi
f0115ef6:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115ef8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115efb:	8b 40 10             	mov    0x10(%eax),%eax
f0115efe:	83 ec 08             	sub    $0x8,%esp
f0115f01:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115f07:	52                   	push   %edx
f0115f08:	50                   	push   %eax
f0115f09:	e8 b4 a5 00 00       	call   f01204c2 <ltostr>
f0115f0e:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115f11:	83 ec 04             	sub    $0x4,%esp
f0115f14:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115f1a:	50                   	push   %eax
f0115f1b:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115f21:	50                   	push   %eax
f0115f22:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115f28:	50                   	push   %eax
f0115f29:	e8 6d a6 00 00       	call   f012059b <strcconcat>
f0115f2e:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115f31:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115f38:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115f3f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0115f46:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115f4a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115f51:	00 00 00 
	uint32 num_tables = 0;
f0115f54:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f5b:	00 00 00 
	ClearUserSpace(proc_directory);
f0115f5e:	83 ec 0c             	sub    $0xc,%esp
f0115f61:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f64:	e8 8d 0e 00 00       	call   f0116df6 <ClearUserSpace>
f0115f69:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115f6c:	83 ec 0c             	sub    $0xc,%esp
f0115f6f:	68 c8 b0 12 f0       	push   $0xf012b0c8
f0115f74:	e8 12 b0 fe ff       	call   f0100f8b <cprintf>
f0115f79:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115f7c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115f7f:	c1 e0 03             	shl    $0x3,%eax
f0115f82:	89 c2                	mov    %eax,%edx
f0115f84:	83 ec 0c             	sub    $0xc,%esp
f0115f87:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f8d:	50                   	push   %eax
f0115f8e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f94:	50                   	push   %eax
f0115f95:	52                   	push   %edx
f0115f96:	6a 00                	push   $0x0
f0115f98:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f9b:	e8 f2 4e ff ff       	call   f010ae92 <calculate_allocated_space>
f0115fa0:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115fa3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fa9:	85 c0                	test   %eax,%eax
f0115fab:	74 27                	je     f0115fd4 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115fad:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fb3:	83 ec 0c             	sub    $0xc,%esp
f0115fb6:	6a 00                	push   $0x0
f0115fb8:	50                   	push   %eax
f0115fb9:	68 34 b2 12 f0       	push   $0xf012b234
f0115fbe:	68 0b 07 00 00       	push   $0x70b
f0115fc3:	68 82 98 12 f0       	push   $0xf0129882
f0115fc8:	e8 09 a5 fe ff       	call   f01004d6 <_warn>
f0115fcd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fd0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115fd4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fda:	85 c0                	test   %eax,%eax
f0115fdc:	74 27                	je     f0116005 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115fde:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fe4:	83 ec 0c             	sub    $0xc,%esp
f0115fe7:	6a 00                	push   $0x0
f0115fe9:	50                   	push   %eax
f0115fea:	68 94 b2 12 f0       	push   $0xf012b294
f0115fef:	68 10 07 00 00       	push   $0x710
f0115ff4:	68 82 98 12 f0       	push   $0xf0129882
f0115ff9:	e8 d8 a4 fe ff       	call   f01004d6 <_warn>
f0115ffe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116001:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116005:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116009:	74 04                	je     f011600f <test_calculate_allocated_space+0x198>
f011600b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011600f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0116013:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011601a:	00 00 00 
		num_pages = 0;
f011601d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116024:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0116027:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011602a:	c1 e0 02             	shl    $0x2,%eax
f011602d:	89 c2                	mov    %eax,%edx
f011602f:	83 ec 0c             	sub    $0xc,%esp
f0116032:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116038:	50                   	push   %eax
f0116039:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011603f:	50                   	push   %eax
f0116040:	52                   	push   %edx
f0116041:	6a 00                	push   $0x0
f0116043:	ff 75 d8             	pushl  -0x28(%ebp)
f0116046:	e8 47 4e ff ff       	call   f010ae92 <calculate_allocated_space>
f011604b:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011604e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116054:	85 c0                	test   %eax,%eax
f0116056:	74 27                	je     f011607f <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116058:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011605e:	83 ec 0c             	sub    $0xc,%esp
f0116061:	6a 00                	push   $0x0
f0116063:	50                   	push   %eax
f0116064:	68 34 b2 12 f0       	push   $0xf012b234
f0116069:	68 1c 07 00 00       	push   $0x71c
f011606e:	68 82 98 12 f0       	push   $0xf0129882
f0116073:	e8 5e a4 fe ff       	call   f01004d6 <_warn>
f0116078:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011607b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011607f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116085:	85 c0                	test   %eax,%eax
f0116087:	74 27                	je     f01160b0 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116089:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011608f:	83 ec 0c             	sub    $0xc,%esp
f0116092:	6a 00                	push   $0x0
f0116094:	50                   	push   %eax
f0116095:	68 94 b2 12 f0       	push   $0xf012b294
f011609a:	68 21 07 00 00       	push   $0x721
f011609f:	68 82 98 12 f0       	push   $0xf0129882
f01160a4:	e8 2d a4 fe ff       	call   f01004d6 <_warn>
f01160a9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160ac:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01160b0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160b4:	74 04                	je     f01160ba <test_calculate_allocated_space+0x243>
f01160b6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01160ba:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01160be:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160c5:	00 00 00 
		num_pages = 0;
f01160c8:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160cf:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01160d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01160d5:	c1 e0 0a             	shl    $0xa,%eax
f01160d8:	89 c2                	mov    %eax,%edx
f01160da:	83 ec 0c             	sub    $0xc,%esp
f01160dd:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160e3:	50                   	push   %eax
f01160e4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160ea:	50                   	push   %eax
f01160eb:	52                   	push   %edx
f01160ec:	6a 00                	push   $0x0
f01160ee:	ff 75 d8             	pushl  -0x28(%ebp)
f01160f1:	e8 9c 4d ff ff       	call   f010ae92 <calculate_allocated_space>
f01160f6:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01160f9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160ff:	85 c0                	test   %eax,%eax
f0116101:	74 27                	je     f011612a <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116103:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116109:	83 ec 0c             	sub    $0xc,%esp
f011610c:	6a 00                	push   $0x0
f011610e:	50                   	push   %eax
f011610f:	68 34 b2 12 f0       	push   $0xf012b234
f0116114:	68 2d 07 00 00       	push   $0x72d
f0116119:	68 82 98 12 f0       	push   $0xf0129882
f011611e:	e8 b3 a3 fe ff       	call   f01004d6 <_warn>
f0116123:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116126:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011612a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116130:	85 c0                	test   %eax,%eax
f0116132:	74 27                	je     f011615b <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116134:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011613a:	83 ec 0c             	sub    $0xc,%esp
f011613d:	6a 00                	push   $0x0
f011613f:	50                   	push   %eax
f0116140:	68 94 b2 12 f0       	push   $0xf012b294
f0116145:	68 32 07 00 00       	push   $0x732
f011614a:	68 82 98 12 f0       	push   $0xf0129882
f011614f:	e8 82 a3 fe ff       	call   f01004d6 <_warn>
f0116154:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116157:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011615b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011615f:	74 04                	je     f0116165 <test_calculate_allocated_space+0x2ee>
f0116161:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116165:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0116169:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116170:	00 00 00 
		num_pages = 0;
f0116173:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011617a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f011617d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0116180:	89 d0                	mov    %edx,%eax
f0116182:	01 c0                	add    %eax,%eax
f0116184:	01 d0                	add    %edx,%eax
f0116186:	01 c0                	add    %eax,%eax
f0116188:	05 00 10 00 00       	add    $0x1000,%eax
f011618d:	89 c2                	mov    %eax,%edx
f011618f:	83 ec 0c             	sub    $0xc,%esp
f0116192:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116198:	50                   	push   %eax
f0116199:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011619f:	50                   	push   %eax
f01161a0:	52                   	push   %edx
f01161a1:	68 00 10 00 00       	push   $0x1000
f01161a6:	ff 75 d8             	pushl  -0x28(%ebp)
f01161a9:	e8 e4 4c ff ff       	call   f010ae92 <calculate_allocated_space>
f01161ae:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01161b1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161b7:	85 c0                	test   %eax,%eax
f01161b9:	74 27                	je     f01161e2 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01161bb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161c1:	83 ec 0c             	sub    $0xc,%esp
f01161c4:	6a 00                	push   $0x0
f01161c6:	50                   	push   %eax
f01161c7:	68 34 b2 12 f0       	push   $0xf012b234
f01161cc:	68 3f 07 00 00       	push   $0x73f
f01161d1:	68 82 98 12 f0       	push   $0xf0129882
f01161d6:	e8 fb a2 fe ff       	call   f01004d6 <_warn>
f01161db:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161de:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01161e2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161e8:	85 c0                	test   %eax,%eax
f01161ea:	74 27                	je     f0116213 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01161ec:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161f2:	83 ec 0c             	sub    $0xc,%esp
f01161f5:	6a 00                	push   $0x0
f01161f7:	50                   	push   %eax
f01161f8:	68 94 b2 12 f0       	push   $0xf012b294
f01161fd:	68 44 07 00 00       	push   $0x744
f0116202:	68 82 98 12 f0       	push   $0xf0129882
f0116207:	e8 ca a2 fe ff       	call   f01004d6 <_warn>
f011620c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011620f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116213:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116217:	74 04                	je     f011621d <test_calculate_allocated_space+0x3a6>
f0116219:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011621d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0116221:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116228:	00 00 00 
		num_pages = 0;
f011622b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116232:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0116235:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116238:	89 c2                	mov    %eax,%edx
f011623a:	01 d2                	add    %edx,%edx
f011623c:	01 d0                	add    %edx,%eax
f011623e:	05 00 18 00 00       	add    $0x1800,%eax
f0116243:	89 c2                	mov    %eax,%edx
f0116245:	83 ec 0c             	sub    $0xc,%esp
f0116248:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011624e:	50                   	push   %eax
f011624f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116255:	50                   	push   %eax
f0116256:	52                   	push   %edx
f0116257:	68 00 18 00 00       	push   $0x1800
f011625c:	ff 75 d8             	pushl  -0x28(%ebp)
f011625f:	e8 2e 4c ff ff       	call   f010ae92 <calculate_allocated_space>
f0116264:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116267:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011626d:	85 c0                	test   %eax,%eax
f011626f:	74 27                	je     f0116298 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116271:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116277:	83 ec 0c             	sub    $0xc,%esp
f011627a:	6a 00                	push   $0x0
f011627c:	50                   	push   %eax
f011627d:	68 34 b2 12 f0       	push   $0xf012b234
f0116282:	68 50 07 00 00       	push   $0x750
f0116287:	68 82 98 12 f0       	push   $0xf0129882
f011628c:	e8 45 a2 fe ff       	call   f01004d6 <_warn>
f0116291:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116294:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116298:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011629e:	85 c0                	test   %eax,%eax
f01162a0:	74 27                	je     f01162c9 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01162a2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01162a8:	83 ec 0c             	sub    $0xc,%esp
f01162ab:	6a 00                	push   $0x0
f01162ad:	50                   	push   %eax
f01162ae:	68 94 b2 12 f0       	push   $0xf012b294
f01162b3:	68 55 07 00 00       	push   $0x755
f01162b8:	68 82 98 12 f0       	push   $0xf0129882
f01162bd:	e8 14 a2 fe ff       	call   f01004d6 <_warn>
f01162c2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162c5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162c9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162cd:	74 04                	je     f01162d3 <test_calculate_allocated_space+0x45c>
f01162cf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162d3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f01162d7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162de:	00 00 00 
		num_pages = 0;
f01162e1:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162e8:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f01162eb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01162ee:	89 d0                	mov    %edx,%eax
f01162f0:	c1 e0 02             	shl    $0x2,%eax
f01162f3:	01 d0                	add    %edx,%eax
f01162f5:	01 c0                	add    %eax,%eax
f01162f7:	05 00 00 40 00       	add    $0x400000,%eax
f01162fc:	89 c2                	mov    %eax,%edx
f01162fe:	83 ec 0c             	sub    $0xc,%esp
f0116301:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116307:	50                   	push   %eax
f0116308:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011630e:	50                   	push   %eax
f011630f:	52                   	push   %edx
f0116310:	68 00 00 40 00       	push   $0x400000
f0116315:	ff 75 d8             	pushl  -0x28(%ebp)
f0116318:	e8 75 4b ff ff       	call   f010ae92 <calculate_allocated_space>
f011631d:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116320:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116326:	85 c0                	test   %eax,%eax
f0116328:	74 27                	je     f0116351 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011632a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116330:	83 ec 0c             	sub    $0xc,%esp
f0116333:	6a 00                	push   $0x0
f0116335:	50                   	push   %eax
f0116336:	68 34 b2 12 f0       	push   $0xf012b234
f011633b:	68 61 07 00 00       	push   $0x761
f0116340:	68 82 98 12 f0       	push   $0xf0129882
f0116345:	e8 8c a1 fe ff       	call   f01004d6 <_warn>
f011634a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011634d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116351:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116357:	85 c0                	test   %eax,%eax
f0116359:	74 27                	je     f0116382 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011635b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116361:	83 ec 0c             	sub    $0xc,%esp
f0116364:	6a 00                	push   $0x0
f0116366:	50                   	push   %eax
f0116367:	68 94 b2 12 f0       	push   $0xf012b294
f011636c:	68 66 07 00 00       	push   $0x766
f0116371:	68 82 98 12 f0       	push   $0xf0129882
f0116376:	e8 5b a1 fe ff       	call   f01004d6 <_warn>
f011637b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011637e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116382:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116386:	74 04                	je     f011638c <test_calculate_allocated_space+0x515>
f0116388:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011638c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0116390:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116397:	00 00 00 
		num_pages = 0;
f011639a:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01163a1:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01163a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01163a7:	05 00 00 38 00       	add    $0x380000,%eax
f01163ac:	01 c0                	add    %eax,%eax
f01163ae:	89 c2                	mov    %eax,%edx
f01163b0:	83 ec 0c             	sub    $0xc,%esp
f01163b3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01163b9:	50                   	push   %eax
f01163ba:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01163c0:	50                   	push   %eax
f01163c1:	52                   	push   %edx
f01163c2:	68 00 00 70 00       	push   $0x700000
f01163c7:	ff 75 d8             	pushl  -0x28(%ebp)
f01163ca:	e8 c3 4a ff ff       	call   f010ae92 <calculate_allocated_space>
f01163cf:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01163d2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163d8:	85 c0                	test   %eax,%eax
f01163da:	74 27                	je     f0116403 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01163dc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163e2:	83 ec 0c             	sub    $0xc,%esp
f01163e5:	6a 00                	push   $0x0
f01163e7:	50                   	push   %eax
f01163e8:	68 34 b2 12 f0       	push   $0xf012b234
f01163ed:	68 73 07 00 00       	push   $0x773
f01163f2:	68 82 98 12 f0       	push   $0xf0129882
f01163f7:	e8 da a0 fe ff       	call   f01004d6 <_warn>
f01163fc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116403:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116409:	85 c0                	test   %eax,%eax
f011640b:	74 27                	je     f0116434 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011640d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116413:	83 ec 0c             	sub    $0xc,%esp
f0116416:	6a 00                	push   $0x0
f0116418:	50                   	push   %eax
f0116419:	68 94 b2 12 f0       	push   $0xf012b294
f011641e:	68 78 07 00 00       	push   $0x778
f0116423:	68 82 98 12 f0       	push   $0xf0129882
f0116428:	e8 a9 a0 fe ff       	call   f01004d6 <_warn>
f011642d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116430:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116434:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116438:	74 04                	je     f011643e <test_calculate_allocated_space+0x5c7>
f011643a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011643e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0116442:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116449:	00 00 00 
		num_pages = 0;
f011644c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116453:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116456:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116459:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f011645e:	89 c2                	mov    %eax,%edx
f0116460:	83 ec 0c             	sub    $0xc,%esp
f0116463:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116469:	50                   	push   %eax
f011646a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116470:	50                   	push   %eax
f0116471:	52                   	push   %edx
f0116472:	68 ff ff 3f 00       	push   $0x3fffff
f0116477:	ff 75 d8             	pushl  -0x28(%ebp)
f011647a:	e8 13 4a ff ff       	call   f010ae92 <calculate_allocated_space>
f011647f:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116482:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116488:	85 c0                	test   %eax,%eax
f011648a:	74 27                	je     f01164b3 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011648c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116492:	83 ec 0c             	sub    $0xc,%esp
f0116495:	6a 00                	push   $0x0
f0116497:	50                   	push   %eax
f0116498:	68 34 b2 12 f0       	push   $0xf012b234
f011649d:	68 84 07 00 00       	push   $0x784
f01164a2:	68 82 98 12 f0       	push   $0xf0129882
f01164a7:	e8 2a a0 fe ff       	call   f01004d6 <_warn>
f01164ac:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164af:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01164b3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164b9:	85 c0                	test   %eax,%eax
f01164bb:	74 27                	je     f01164e4 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01164bd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164c3:	83 ec 0c             	sub    $0xc,%esp
f01164c6:	6a 00                	push   $0x0
f01164c8:	50                   	push   %eax
f01164c9:	68 94 b2 12 f0       	push   $0xf012b294
f01164ce:	68 89 07 00 00       	push   $0x789
f01164d3:	68 82 98 12 f0       	push   $0xf0129882
f01164d8:	e8 f9 9f fe ff       	call   f01004d6 <_warn>
f01164dd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164e0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01164e4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01164e8:	74 04                	je     f01164ee <test_calculate_allocated_space+0x677>
f01164ea:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01164ee:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01164f2:	83 ec 0c             	sub    $0xc,%esp
f01164f5:	68 35 ac 12 f0       	push   $0xf012ac35
f01164fa:	e8 8c aa fe ff       	call   f0100f8b <cprintf>
f01164ff:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0116502:	83 ec 0c             	sub    $0xc,%esp
f0116505:	68 54 b1 12 f0       	push   $0xf012b154
f011650a:	e8 7c aa fe ff       	call   f0100f8b <cprintf>
f011650f:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0116512:	83 ec 04             	sub    $0x4,%esp
f0116515:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f011651b:	50                   	push   %eax
f011651c:	68 ee 9f 12 f0       	push   $0xf0129fee
f0116521:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116527:	50                   	push   %eax
f0116528:	e8 6e a0 00 00       	call   f012059b <strcconcat>
f011652d:	83 c4 10             	add    $0x10,%esp
f0116530:	83 ec 0c             	sub    $0xc,%esp
f0116533:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116539:	50                   	push   %eax
f011653a:	e8 bc b9 fe ff       	call   f0101efb <execute_command>
f011653f:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0116542:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116549:	00 00 00 
		num_pages = 0;
f011654c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116553:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0116556:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116559:	c1 e0 03             	shl    $0x3,%eax
f011655c:	89 c2                	mov    %eax,%edx
f011655e:	83 ec 0c             	sub    $0xc,%esp
f0116561:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116567:	50                   	push   %eax
f0116568:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011656e:	50                   	push   %eax
f011656f:	52                   	push   %edx
f0116570:	6a 00                	push   $0x0
f0116572:	ff 75 d8             	pushl  -0x28(%ebp)
f0116575:	e8 18 49 ff ff       	call   f010ae92 <calculate_allocated_space>
f011657a:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011657d:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0116584:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011658b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116591:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116594:	74 28                	je     f01165be <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116596:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011659c:	83 ec 0c             	sub    $0xc,%esp
f011659f:	ff 75 c8             	pushl  -0x38(%ebp)
f01165a2:	50                   	push   %eax
f01165a3:	68 34 b2 12 f0       	push   $0xf012b234
f01165a8:	68 a0 07 00 00       	push   $0x7a0
f01165ad:	68 82 98 12 f0       	push   $0xf0129882
f01165b2:	e8 1f 9f fe ff       	call   f01004d6 <_warn>
f01165b7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165ba:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01165be:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01165c4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01165c7:	74 28                	je     f01165f1 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01165c9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01165cf:	83 ec 0c             	sub    $0xc,%esp
f01165d2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01165d5:	50                   	push   %eax
f01165d6:	68 94 b2 12 f0       	push   $0xf012b294
f01165db:	68 a5 07 00 00       	push   $0x7a5
f01165e0:	68 82 98 12 f0       	push   $0xf0129882
f01165e5:	e8 ec 9e fe ff       	call   f01004d6 <_warn>
f01165ea:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01165f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01165f5:	74 04                	je     f01165fb <test_calculate_allocated_space+0x784>
f01165f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01165fb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01165ff:	83 ec 04             	sub    $0x4,%esp
f0116602:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116608:	50                   	push   %eax
f0116609:	68 fb 9f 12 f0       	push   $0xf0129ffb
f011660e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116614:	50                   	push   %eax
f0116615:	e8 81 9f 00 00       	call   f012059b <strcconcat>
f011661a:	83 c4 10             	add    $0x10,%esp
f011661d:	83 ec 0c             	sub    $0xc,%esp
f0116620:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116626:	50                   	push   %eax
f0116627:	e8 cf b8 fe ff       	call   f0101efb <execute_command>
f011662c:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f011662f:	83 ec 04             	sub    $0x4,%esp
f0116632:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116638:	50                   	push   %eax
f0116639:	68 88 b1 12 f0       	push   $0xf012b188
f011663e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116644:	50                   	push   %eax
f0116645:	e8 51 9f 00 00       	call   f012059b <strcconcat>
f011664a:	83 c4 10             	add    $0x10,%esp
f011664d:	83 ec 0c             	sub    $0xc,%esp
f0116650:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116656:	50                   	push   %eax
f0116657:	e8 9f b8 fe ff       	call   f0101efb <execute_command>
f011665c:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f011665f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116666:	00 00 00 
		num_pages = 0;
f0116669:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116670:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0116673:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116676:	c1 e0 03             	shl    $0x3,%eax
f0116679:	89 c2                	mov    %eax,%edx
f011667b:	83 ec 0c             	sub    $0xc,%esp
f011667e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116684:	50                   	push   %eax
f0116685:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011668b:	50                   	push   %eax
f011668c:	52                   	push   %edx
f011668d:	6a 00                	push   $0x0
f011668f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116692:	e8 fb 47 ff ff       	call   f010ae92 <calculate_allocated_space>
f0116697:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f011669a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01166a1:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01166a8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166ae:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01166b1:	74 28                	je     f01166db <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01166b3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166b9:	83 ec 0c             	sub    $0xc,%esp
f01166bc:	ff 75 c8             	pushl  -0x38(%ebp)
f01166bf:	50                   	push   %eax
f01166c0:	68 34 b2 12 f0       	push   $0xf012b234
f01166c5:	68 b6 07 00 00       	push   $0x7b6
f01166ca:	68 82 98 12 f0       	push   $0xf0129882
f01166cf:	e8 02 9e fe ff       	call   f01004d6 <_warn>
f01166d4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01166d7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01166db:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01166e1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01166e4:	74 28                	je     f011670e <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01166e6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01166ec:	83 ec 0c             	sub    $0xc,%esp
f01166ef:	ff 75 c4             	pushl  -0x3c(%ebp)
f01166f2:	50                   	push   %eax
f01166f3:	68 94 b2 12 f0       	push   $0xf012b294
f01166f8:	68 bb 07 00 00       	push   $0x7bb
f01166fd:	68 82 98 12 f0       	push   $0xf0129882
f0116702:	e8 cf 9d fe ff       	call   f01004d6 <_warn>
f0116707:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011670a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011670e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116712:	74 04                	je     f0116718 <test_calculate_allocated_space+0x8a1>
f0116714:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116718:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f011671c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116723:	00 00 00 
		num_pages = 0;
f0116726:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011672d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116730:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116733:	c1 e0 0a             	shl    $0xa,%eax
f0116736:	89 c2                	mov    %eax,%edx
f0116738:	83 ec 0c             	sub    $0xc,%esp
f011673b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116741:	50                   	push   %eax
f0116742:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116748:	50                   	push   %eax
f0116749:	52                   	push   %edx
f011674a:	6a 00                	push   $0x0
f011674c:	ff 75 d8             	pushl  -0x28(%ebp)
f011674f:	e8 3e 47 ff ff       	call   f010ae92 <calculate_allocated_space>
f0116754:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0116757:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f011675e:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116765:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011676b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011676e:	74 28                	je     f0116798 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116770:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116776:	83 ec 0c             	sub    $0xc,%esp
f0116779:	ff 75 c8             	pushl  -0x38(%ebp)
f011677c:	50                   	push   %eax
f011677d:	68 34 b2 12 f0       	push   $0xf012b234
f0116782:	68 c9 07 00 00       	push   $0x7c9
f0116787:	68 82 98 12 f0       	push   $0xf0129882
f011678c:	e8 45 9d fe ff       	call   f01004d6 <_warn>
f0116791:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116794:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116798:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011679e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01167a1:	74 28                	je     f01167cb <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01167a3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01167a9:	83 ec 0c             	sub    $0xc,%esp
f01167ac:	ff 75 c4             	pushl  -0x3c(%ebp)
f01167af:	50                   	push   %eax
f01167b0:	68 94 b2 12 f0       	push   $0xf012b294
f01167b5:	68 ce 07 00 00       	push   $0x7ce
f01167ba:	68 82 98 12 f0       	push   $0xf0129882
f01167bf:	e8 12 9d fe ff       	call   f01004d6 <_warn>
f01167c4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01167c7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01167cb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01167cf:	74 04                	je     f01167d5 <test_calculate_allocated_space+0x95e>
f01167d1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01167d5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01167d9:	83 ec 04             	sub    $0x4,%esp
f01167dc:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01167e2:	50                   	push   %eax
f01167e3:	68 94 b1 12 f0       	push   $0xf012b194
f01167e8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01167ee:	50                   	push   %eax
f01167ef:	e8 a7 9d 00 00       	call   f012059b <strcconcat>
f01167f4:	83 c4 10             	add    $0x10,%esp
f01167f7:	83 ec 0c             	sub    $0xc,%esp
f01167fa:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116800:	50                   	push   %eax
f0116801:	e8 f5 b6 fe ff       	call   f0101efb <execute_command>
f0116806:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0116809:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116810:	00 00 00 
		num_pages = 0;
f0116813:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011681a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011681d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116820:	89 c2                	mov    %eax,%edx
f0116822:	01 d2                	add    %edx,%edx
f0116824:	01 d0                	add    %edx,%eax
f0116826:	05 00 18 00 00       	add    $0x1800,%eax
f011682b:	89 c2                	mov    %eax,%edx
f011682d:	83 ec 0c             	sub    $0xc,%esp
f0116830:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116836:	50                   	push   %eax
f0116837:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011683d:	50                   	push   %eax
f011683e:	52                   	push   %edx
f011683f:	68 00 18 00 00       	push   $0x1800
f0116844:	ff 75 d8             	pushl  -0x28(%ebp)
f0116847:	e8 46 46 ff ff       	call   f010ae92 <calculate_allocated_space>
f011684c:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011684f:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116856:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011685d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116863:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116866:	74 28                	je     f0116890 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116868:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011686e:	83 ec 0c             	sub    $0xc,%esp
f0116871:	ff 75 c8             	pushl  -0x38(%ebp)
f0116874:	50                   	push   %eax
f0116875:	68 34 b2 12 f0       	push   $0xf012b234
f011687a:	68 df 07 00 00       	push   $0x7df
f011687f:	68 82 98 12 f0       	push   $0xf0129882
f0116884:	e8 4d 9c fe ff       	call   f01004d6 <_warn>
f0116889:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011688c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116890:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116896:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116899:	74 28                	je     f01168c3 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011689b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168a1:	83 ec 0c             	sub    $0xc,%esp
f01168a4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01168a7:	50                   	push   %eax
f01168a8:	68 94 b2 12 f0       	push   $0xf012b294
f01168ad:	68 e4 07 00 00       	push   $0x7e4
f01168b2:	68 82 98 12 f0       	push   $0xf0129882
f01168b7:	e8 1a 9c fe ff       	call   f01004d6 <_warn>
f01168bc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01168bf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01168c3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01168c7:	74 04                	je     f01168cd <test_calculate_allocated_space+0xa56>
f01168c9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01168cd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01168d1:	83 ec 04             	sub    $0x4,%esp
f01168d4:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01168da:	50                   	push   %eax
f01168db:	68 54 a2 12 f0       	push   $0xf012a254
f01168e0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01168e6:	50                   	push   %eax
f01168e7:	e8 af 9c 00 00       	call   f012059b <strcconcat>
f01168ec:	83 c4 10             	add    $0x10,%esp
f01168ef:	83 ec 0c             	sub    $0xc,%esp
f01168f2:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01168f8:	50                   	push   %eax
f01168f9:	e8 fd b5 fe ff       	call   f0101efb <execute_command>
f01168fe:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116901:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116908:	00 00 00 
		num_pages = 0;
f011690b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116912:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116915:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116918:	89 d0                	mov    %edx,%eax
f011691a:	c1 e0 02             	shl    $0x2,%eax
f011691d:	01 d0                	add    %edx,%eax
f011691f:	01 c0                	add    %eax,%eax
f0116921:	05 00 00 40 00       	add    $0x400000,%eax
f0116926:	89 c2                	mov    %eax,%edx
f0116928:	83 ec 0c             	sub    $0xc,%esp
f011692b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116931:	50                   	push   %eax
f0116932:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116938:	50                   	push   %eax
f0116939:	52                   	push   %edx
f011693a:	68 00 00 40 00       	push   $0x400000
f011693f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116942:	e8 4b 45 ff ff       	call   f010ae92 <calculate_allocated_space>
f0116947:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011694a:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116951:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116958:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011695e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116961:	74 28                	je     f011698b <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116963:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116969:	83 ec 0c             	sub    $0xc,%esp
f011696c:	ff 75 c8             	pushl  -0x38(%ebp)
f011696f:	50                   	push   %eax
f0116970:	68 34 b2 12 f0       	push   $0xf012b234
f0116975:	68 f4 07 00 00       	push   $0x7f4
f011697a:	68 82 98 12 f0       	push   $0xf0129882
f011697f:	e8 52 9b fe ff       	call   f01004d6 <_warn>
f0116984:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116987:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011698b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116991:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116994:	74 28                	je     f01169be <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116996:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011699c:	83 ec 0c             	sub    $0xc,%esp
f011699f:	ff 75 c4             	pushl  -0x3c(%ebp)
f01169a2:	50                   	push   %eax
f01169a3:	68 94 b2 12 f0       	push   $0xf012b294
f01169a8:	68 f9 07 00 00       	push   $0x7f9
f01169ad:	68 82 98 12 f0       	push   $0xf0129882
f01169b2:	e8 1f 9b fe ff       	call   f01004d6 <_warn>
f01169b7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169ba:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01169be:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01169c2:	74 04                	je     f01169c8 <test_calculate_allocated_space+0xb51>
f01169c4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01169c8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01169cc:	83 ec 04             	sub    $0x4,%esp
f01169cf:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01169d5:	50                   	push   %eax
f01169d6:	68 5e a2 12 f0       	push   $0xf012a25e
f01169db:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01169e1:	50                   	push   %eax
f01169e2:	e8 b4 9b 00 00       	call   f012059b <strcconcat>
f01169e7:	83 c4 10             	add    $0x10,%esp
f01169ea:	83 ec 0c             	sub    $0xc,%esp
f01169ed:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01169f3:	50                   	push   %eax
f01169f4:	e8 02 b5 fe ff       	call   f0101efb <execute_command>
f01169f9:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01169fc:	83 ec 04             	sub    $0x4,%esp
f01169ff:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116a05:	50                   	push   %eax
f0116a06:	68 9c b1 12 f0       	push   $0xf012b19c
f0116a0b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116a11:	50                   	push   %eax
f0116a12:	e8 84 9b 00 00       	call   f012059b <strcconcat>
f0116a17:	83 c4 10             	add    $0x10,%esp
f0116a1a:	83 ec 0c             	sub    $0xc,%esp
f0116a1d:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116a23:	50                   	push   %eax
f0116a24:	e8 d2 b4 fe ff       	call   f0101efb <execute_command>
f0116a29:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116a2c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116a33:	00 00 00 
		num_pages = 0;
f0116a36:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116a3d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116a40:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116a43:	05 00 00 38 00       	add    $0x380000,%eax
f0116a48:	01 c0                	add    %eax,%eax
f0116a4a:	89 c2                	mov    %eax,%edx
f0116a4c:	83 ec 0c             	sub    $0xc,%esp
f0116a4f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116a55:	50                   	push   %eax
f0116a56:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116a5c:	50                   	push   %eax
f0116a5d:	52                   	push   %edx
f0116a5e:	68 00 00 70 00       	push   $0x700000
f0116a63:	ff 75 d8             	pushl  -0x28(%ebp)
f0116a66:	e8 27 44 ff ff       	call   f010ae92 <calculate_allocated_space>
f0116a6b:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116a6e:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0116a75:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116a7c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116a82:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116a85:	74 28                	je     f0116aaf <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116a87:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116a8d:	83 ec 0c             	sub    $0xc,%esp
f0116a90:	ff 75 c8             	pushl  -0x38(%ebp)
f0116a93:	50                   	push   %eax
f0116a94:	68 34 b2 12 f0       	push   $0xf012b234
f0116a99:	68 0b 08 00 00       	push   $0x80b
f0116a9e:	68 82 98 12 f0       	push   $0xf0129882
f0116aa3:	e8 2e 9a fe ff       	call   f01004d6 <_warn>
f0116aa8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116aab:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116aaf:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ab5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116ab8:	74 28                	je     f0116ae2 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116aba:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ac0:	83 ec 0c             	sub    $0xc,%esp
f0116ac3:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116ac6:	50                   	push   %eax
f0116ac7:	68 94 b2 12 f0       	push   $0xf012b294
f0116acc:	68 10 08 00 00       	push   $0x810
f0116ad1:	68 82 98 12 f0       	push   $0xf0129882
f0116ad6:	e8 fb 99 fe ff       	call   f01004d6 <_warn>
f0116adb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ade:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116ae2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116ae6:	74 04                	je     f0116aec <test_calculate_allocated_space+0xc75>
f0116ae8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116aec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116af0:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116af7:	00 00 00 
		num_pages = 0;
f0116afa:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116b01:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116b04:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116b07:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116b0c:	89 c2                	mov    %eax,%edx
f0116b0e:	83 ec 0c             	sub    $0xc,%esp
f0116b11:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116b17:	50                   	push   %eax
f0116b18:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116b1e:	50                   	push   %eax
f0116b1f:	52                   	push   %edx
f0116b20:	68 ff ff 3f 00       	push   $0x3fffff
f0116b25:	ff 75 d8             	pushl  -0x28(%ebp)
f0116b28:	e8 65 43 ff ff       	call   f010ae92 <calculate_allocated_space>
f0116b2d:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116b30:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0116b37:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116b3e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116b44:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116b47:	74 28                	je     f0116b71 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116b49:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116b4f:	83 ec 0c             	sub    $0xc,%esp
f0116b52:	ff 75 c8             	pushl  -0x38(%ebp)
f0116b55:	50                   	push   %eax
f0116b56:	68 34 b2 12 f0       	push   $0xf012b234
f0116b5b:	68 1e 08 00 00       	push   $0x81e
f0116b60:	68 82 98 12 f0       	push   $0xf0129882
f0116b65:	e8 6c 99 fe ff       	call   f01004d6 <_warn>
f0116b6a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116b6d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116b71:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116b77:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116b7a:	74 28                	je     f0116ba4 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116b7c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116b82:	83 ec 0c             	sub    $0xc,%esp
f0116b85:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116b88:	50                   	push   %eax
f0116b89:	68 94 b2 12 f0       	push   $0xf012b294
f0116b8e:	68 23 08 00 00       	push   $0x823
f0116b93:	68 82 98 12 f0       	push   $0xf0129882
f0116b98:	e8 39 99 fe ff       	call   f01004d6 <_warn>
f0116b9d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ba0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116ba4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116ba8:	74 04                	je     f0116bae <test_calculate_allocated_space+0xd37>
f0116baa:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116bae:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116bb2:	83 ec 0c             	sub    $0xc,%esp
f0116bb5:	68 0f a2 12 f0       	push   $0xf012a20f
f0116bba:	e8 cc a3 fe ff       	call   f0100f8b <cprintf>
f0116bbf:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116bc2:	83 ec 08             	sub    $0x8,%esp
f0116bc5:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116bc8:	68 f0 b2 12 f0       	push   $0xf012b2f0
f0116bcd:	e8 b9 a3 fe ff       	call   f0100f8b <cprintf>
f0116bd2:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116bd5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116bd9:	75 10                	jne    f0116beb <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116bdb:	83 ec 0c             	sub    $0xc,%esp
f0116bde:	68 30 b3 12 f0       	push   $0xf012b330
f0116be3:	e8 a3 a3 fe ff       	call   f0100f8b <cprintf>
f0116be8:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116beb:	a1 84 da f5 f0       	mov    0xf0f5da84,%eax
f0116bf0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0116bf3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116bf6:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116bfe:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116c01:	5b                   	pop    %ebx
f0116c02:	5e                   	pop    %esi
f0116c03:	5f                   	pop    %edi
f0116c04:	5d                   	pop    %ebp
f0116c05:	c3                   	ret    

f0116c06 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0116c06:	55                   	push   %ebp
f0116c07:	89 e5                	mov    %esp,%ebp
f0116c09:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116c0c:	8b 45 10             	mov    0x10(%ebp),%eax
f0116c0f:	ba 01 00 00 00       	mov    $0x1,%edx
f0116c14:	88 c1                	mov    %al,%cl
f0116c16:	d3 e2                	shl    %cl,%edx
f0116c18:	89 d0                	mov    %edx,%eax
f0116c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116c20:	c1 e8 16             	shr    $0x16,%eax
f0116c23:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116c2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0116c2d:	01 d0                	add    %edx,%eax
f0116c2f:	8b 00                	mov    (%eax),%eax
f0116c31:	83 e0 01             	and    $0x1,%eax
f0116c34:	85 c0                	test   %eax,%eax
f0116c36:	75 07                	jne    f0116c3f <CB+0x39>
f0116c38:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c3d:	eb 76                	jmp    f0116cb5 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116c3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116c42:	c1 e8 16             	shr    $0x16,%eax
f0116c45:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116c4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0116c4f:	01 d0                	add    %edx,%eax
f0116c51:	8b 00                	mov    (%eax),%eax
f0116c53:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116c58:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116c5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116c5e:	c1 e8 0c             	shr    $0xc,%eax
f0116c61:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116c64:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0116c69:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116c6c:	72 17                	jb     f0116c85 <CB+0x7f>
f0116c6e:	ff 75 f0             	pushl  -0x10(%ebp)
f0116c71:	68 7c b3 12 f0       	push   $0xf012b37c
f0116c76:	68 3e 08 00 00       	push   $0x83e
f0116c7b:	68 82 98 12 f0       	push   $0xf0129882
f0116c80:	e8 b4 96 fe ff       	call   f0100339 <_panic>
f0116c85:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116c88:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116c8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116c90:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116c93:	c1 e8 0c             	shr    $0xc,%eax
f0116c96:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116c9b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116ca2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116ca5:	01 d0                	add    %edx,%eax
f0116ca7:	8b 00                	mov    (%eax),%eax
f0116ca9:	23 45 f4             	and    -0xc(%ebp),%eax
f0116cac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116caf:	0f 94 c0             	sete   %al
f0116cb2:	0f b6 c0             	movzbl %al,%eax
}
f0116cb5:	c9                   	leave  
f0116cb6:	c3                   	ret    

f0116cb7 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116cb7:	55                   	push   %ebp
f0116cb8:	89 e5                	mov    %esp,%ebp
f0116cba:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116cbd:	68 ab b3 12 f0       	push   $0xf012b3ab
f0116cc2:	68 ba b3 12 f0       	push   $0xf012b3ba
f0116cc7:	68 43 08 00 00       	push   $0x843
f0116ccc:	68 82 98 12 f0       	push   $0xf0129882
f0116cd1:	e8 63 96 fe ff       	call   f0100339 <_panic>

f0116cd6 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116cd6:	55                   	push   %ebp
f0116cd7:	89 e5                	mov    %esp,%ebp
f0116cd9:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116cdc:	68 ab b3 12 f0       	push   $0xf012b3ab
f0116ce1:	68 ba b3 12 f0       	push   $0xf012b3ba
f0116ce6:	68 4d 08 00 00       	push   $0x84d
f0116ceb:	68 82 98 12 f0       	push   $0xf0129882
f0116cf0:	e8 44 96 fe ff       	call   f0100339 <_panic>

f0116cf5 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0116cf5:	55                   	push   %ebp
f0116cf6:	89 e5                	mov    %esp,%ebp
f0116cf8:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116cfb:	68 ab b3 12 f0       	push   $0xf012b3ab
f0116d00:	68 ba b3 12 f0       	push   $0xf012b3ba
f0116d05:	68 5c 08 00 00       	push   $0x85c
f0116d0a:	68 82 98 12 f0       	push   $0xf0129882
f0116d0f:	e8 25 96 fe ff       	call   f0100339 <_panic>

f0116d14 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f0116d14:	55                   	push   %ebp
f0116d15:	89 e5                	mov    %esp,%ebp
f0116d17:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116d1a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d1d:	c1 e8 16             	shr    $0x16,%eax
f0116d20:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d27:	8b 45 08             	mov    0x8(%ebp),%eax
f0116d2a:	01 d0                	add    %edx,%eax
f0116d2c:	8b 00                	mov    (%eax),%eax
f0116d2e:	83 e0 01             	and    $0x1,%eax
f0116d31:	85 c0                	test   %eax,%eax
f0116d33:	75 07                	jne    f0116d3c <CE+0x28>
f0116d35:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d3a:	eb 7a                	jmp    f0116db6 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116d3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d3f:	c1 e8 16             	shr    $0x16,%eax
f0116d42:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d49:	8b 45 08             	mov    0x8(%ebp),%eax
f0116d4c:	01 d0                	add    %edx,%eax
f0116d4e:	8b 00                	mov    (%eax),%eax
f0116d50:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116d55:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116d58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116d5b:	c1 e8 0c             	shr    $0xc,%eax
f0116d5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116d61:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f0116d66:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116d69:	72 17                	jb     f0116d82 <CE+0x6e>
f0116d6b:	ff 75 f4             	pushl  -0xc(%ebp)
f0116d6e:	68 7c b3 12 f0       	push   $0xf012b37c
f0116d73:	68 65 08 00 00       	push   $0x865
f0116d78:	68 82 98 12 f0       	push   $0xf0129882
f0116d7d:	e8 b7 95 fe ff       	call   f0100339 <_panic>
f0116d82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116d85:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116d8a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116d8d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d90:	c1 e8 0c             	shr    $0xc,%eax
f0116d93:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116d98:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116da2:	01 d0                	add    %edx,%eax
f0116da4:	8b 00                	mov    (%eax),%eax
f0116da6:	85 c0                	test   %eax,%eax
f0116da8:	74 07                	je     f0116db1 <CE+0x9d>
f0116daa:	b8 00 00 00 00       	mov    $0x0,%eax
f0116daf:	eb 05                	jmp    f0116db6 <CE+0xa2>
	return 1;
f0116db1:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116db6:	c9                   	leave  
f0116db7:	c3                   	ret    

f0116db8 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116db8:	55                   	push   %ebp
f0116db9:	89 e5                	mov    %esp,%ebp
f0116dbb:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116dbe:	68 ab b3 12 f0       	push   $0xf012b3ab
f0116dc3:	68 ba b3 12 f0       	push   $0xf012b3ba
f0116dc8:	68 6c 08 00 00       	push   $0x86c
f0116dcd:	68 82 98 12 f0       	push   $0xf0129882
f0116dd2:	e8 62 95 fe ff       	call   f0100339 <_panic>

f0116dd7 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116dd7:	55                   	push   %ebp
f0116dd8:	89 e5                	mov    %esp,%ebp
f0116dda:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116ddd:	68 ab b3 12 f0       	push   $0xf012b3ab
f0116de2:	68 ba b3 12 f0       	push   $0xf012b3ba
f0116de7:	68 7c 08 00 00       	push   $0x87c
f0116dec:	68 82 98 12 f0       	push   $0xf0129882
f0116df1:	e8 43 95 fe ff       	call   f0100339 <_panic>

f0116df6 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0116df6:	55                   	push   %ebp
f0116df7:	89 e5                	mov    %esp,%ebp
f0116df9:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116dfc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116e03:	eb 18                	jmp    f0116e1d <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116e05:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116e08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e0f:	8b 45 08             	mov    0x8(%ebp),%eax
f0116e12:	01 d0                	add    %edx,%eax
f0116e14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116e1a:	ff 45 fc             	incl   -0x4(%ebp)
f0116e1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116e20:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116e25:	76 de                	jbe    f0116e05 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116e27:	90                   	nop
f0116e28:	c9                   	leave  
f0116e29:	c3                   	ret    

f0116e2a <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116e2a:	55                   	push   %ebp
f0116e2b:	89 e5                	mov    %esp,%ebp
f0116e2d:	83 ec 38             	sub    $0x38,%esp
f0116e30:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116e33:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116e36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116e39:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116e3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116e41:	8b 45 10             	mov    0x10(%ebp),%eax
f0116e44:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116e49:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116e4c:	e9 ea 01 00 00       	jmp    f011703b <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116e51:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116e55:	74 44                	je     f0116e9b <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116e5a:	83 ec 04             	sub    $0x4,%esp
f0116e5d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116e60:	52                   	push   %edx
f0116e61:	50                   	push   %eax
f0116e62:	ff 75 08             	pushl  0x8(%ebp)
f0116e65:	e8 2a 1c ff ff       	call   f0108a94 <get_frame_info>
f0116e6a:	83 c4 10             	add    $0x10,%esp
f0116e6d:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116e70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116e73:	85 c0                	test   %eax,%eax
f0116e75:	75 24                	jne    f0116e9b <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116e77:	83 ec 04             	sub    $0x4,%esp
f0116e7a:	68 d0 b3 12 f0       	push   $0xf012b3d0
f0116e7f:	68 99 08 00 00       	push   $0x899
f0116e84:	68 82 98 12 f0       	push   $0xf0129882
f0116e89:	e8 48 96 fe ff       	call   f01004d6 <_warn>
f0116e8e:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116e91:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e96:	e9 b6 01 00 00       	jmp    f0117051 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116e9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116e9e:	83 ec 04             	sub    $0x4,%esp
f0116ea1:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116ea4:	52                   	push   %edx
f0116ea5:	50                   	push   %eax
f0116ea6:	ff 75 08             	pushl  0x8(%ebp)
f0116ea9:	e8 e6 1b ff ff       	call   f0108a94 <get_frame_info>
f0116eae:	83 c4 10             	add    $0x10,%esp
f0116eb1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116eb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116eb7:	85 c0                	test   %eax,%eax
f0116eb9:	75 24                	jne    f0116edf <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116ebb:	83 ec 04             	sub    $0x4,%esp
f0116ebe:	68 fc b3 12 f0       	push   $0xf012b3fc
f0116ec3:	68 a0 08 00 00       	push   $0x8a0
f0116ec8:	68 82 98 12 f0       	push   $0xf0129882
f0116ecd:	e8 04 96 fe ff       	call   f01004d6 <_warn>
f0116ed2:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116ed5:	b8 00 00 00 00       	mov    $0x0,%eax
f0116eda:	e9 72 01 00 00       	jmp    f0117051 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116edf:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116ee3:	75 70                	jne    f0116f55 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116ee5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116ee8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116eeb:	c1 ea 0c             	shr    $0xc,%edx
f0116eee:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116ef4:	c1 e2 02             	shl    $0x2,%edx
f0116ef7:	01 d0                	add    %edx,%eax
f0116ef9:	8b 00                	mov    (%eax),%eax
f0116efb:	c1 e8 0c             	shr    $0xc,%eax
f0116efe:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116f01:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116f04:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116f07:	c1 ea 0c             	shr    $0xc,%edx
f0116f0a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116f10:	c1 e2 02             	shl    $0x2,%edx
f0116f13:	01 d0                	add    %edx,%eax
f0116f15:	8b 00                	mov    (%eax),%eax
f0116f17:	c1 e8 0c             	shr    $0xc,%eax
f0116f1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116f1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116f20:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116f23:	74 30                	je     f0116f55 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116f25:	83 ec 04             	sub    $0x4,%esp
f0116f28:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116f2b:	ff 75 e8             	pushl  -0x18(%ebp)
f0116f2e:	ff 75 f0             	pushl  -0x10(%ebp)
f0116f31:	ff 75 f4             	pushl  -0xc(%ebp)
f0116f34:	68 28 b4 12 f0       	push   $0xf012b428
f0116f39:	68 aa 08 00 00       	push   $0x8aa
f0116f3e:	68 82 98 12 f0       	push   $0xf0129882
f0116f43:	e8 8e 95 fe ff       	call   f01004d6 <_warn>
f0116f48:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116f4b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f50:	e9 fc 00 00 00       	jmp    f0117051 <CCP+0x227>
			}
		}
		if (ref != -1)
f0116f55:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116f59:	74 52                	je     f0116fad <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116f5b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116f5f:	74 0e                	je     f0116f6f <CCP+0x145>
f0116f61:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116f64:	8b 40 08             	mov    0x8(%eax),%eax
f0116f67:	0f b7 c0             	movzwl %ax,%eax
f0116f6a:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116f6d:	74 3e                	je     f0116fad <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116f6f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116f73:	74 0b                	je     f0116f80 <CCP+0x156>
f0116f75:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116f78:	8b 40 08             	mov    0x8(%eax),%eax
f0116f7b:	0f b7 c0             	movzwl %ax,%eax
f0116f7e:	eb 05                	jmp    f0116f85 <CCP+0x15b>
f0116f80:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f85:	83 ec 0c             	sub    $0xc,%esp
f0116f88:	50                   	push   %eax
f0116f89:	ff 75 f0             	pushl  -0x10(%ebp)
f0116f8c:	68 84 b4 12 f0       	push   $0xf012b484
f0116f91:	68 b2 08 00 00       	push   $0x8b2
f0116f96:	68 82 98 12 f0       	push   $0xf0129882
f0116f9b:	e8 36 95 fe ff       	call   f01004d6 <_warn>
f0116fa0:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116fa3:	b8 00 00 00 00       	mov    $0x0,%eax
f0116fa8:	e9 a4 00 00 00       	jmp    f0117051 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116fad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116fb0:	ff 75 20             	pushl  0x20(%ebp)
f0116fb3:	ff 75 1c             	pushl  0x1c(%ebp)
f0116fb6:	50                   	push   %eax
f0116fb7:	ff 75 08             	pushl  0x8(%ebp)
f0116fba:	e8 17 fd ff ff       	call   f0116cd6 <CPs>
f0116fbf:	83 c4 10             	add    $0x10,%esp
f0116fc2:	85 c0                	test   %eax,%eax
f0116fc4:	7f 21                	jg     f0116fe7 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116fc6:	83 ec 04             	sub    $0x4,%esp
f0116fc9:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0116fce:	68 b8 08 00 00       	push   $0x8b8
f0116fd3:	68 82 98 12 f0       	push   $0xf0129882
f0116fd8:	e8 f9 94 fe ff       	call   f01004d6 <_warn>
f0116fdd:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116fe0:	b8 00 00 00 00       	mov    $0x0,%eax
f0116fe5:	eb 6a                	jmp    f0117051 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116fe7:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116feb:	74 3a                	je     f0117027 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ff0:	ff 75 28             	pushl  0x28(%ebp)
f0116ff3:	ff 75 24             	pushl  0x24(%ebp)
f0116ff6:	50                   	push   %eax
f0116ff7:	ff 75 08             	pushl  0x8(%ebp)
f0116ffa:	e8 d7 fc ff ff       	call   f0116cd6 <CPs>
f0116fff:	83 c4 10             	add    $0x10,%esp
f0117002:	85 c0                	test   %eax,%eax
f0117004:	7f 21                	jg     f0117027 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0117006:	83 ec 04             	sub    $0x4,%esp
f0117009:	68 3c b5 12 f0       	push   $0xf012b53c
f011700e:	68 bf 08 00 00       	push   $0x8bf
f0117013:	68 82 98 12 f0       	push   $0xf0129882
f0117018:	e8 b9 94 fe ff       	call   f01004d6 <_warn>
f011701d:	83 c4 10             	add    $0x10,%esp
				return 0;
f0117020:	b8 00 00 00 00       	mov    $0x0,%eax
f0117025:	eb 2a                	jmp    f0117051 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0117027:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f011702b:	74 07                	je     f0117034 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f011702d:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0117034:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f011703b:	8b 55 10             	mov    0x10(%ebp),%edx
f011703e:	8b 45 14             	mov    0x14(%ebp),%eax
f0117041:	01 d0                	add    %edx,%eax
f0117043:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117046:	0f 87 05 fe ff ff    	ja     f0116e51 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f011704c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117051:	c9                   	leave  
f0117052:	c3                   	ret    

f0117053 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0117053:	55                   	push   %ebp
f0117054:	89 e5                	mov    %esp,%ebp
f0117056:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0117059:	83 ec 04             	sub    $0x4,%esp
f011705c:	68 7c b5 12 f0       	push   $0xf012b57c
f0117061:	6a 0e                	push   $0xe
f0117063:	68 8c b5 12 f0       	push   $0xf012b58c
f0117068:	e8 cc 92 fe ff       	call   f0100339 <_panic>

f011706d <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f011706d:	55                   	push   %ebp
f011706e:	89 e5                	mov    %esp,%ebp
f0117070:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0117073:	83 ec 04             	sub    $0x4,%esp
f0117076:	68 7c b5 12 f0       	push   $0xf012b57c
f011707b:	68 d7 00 00 00       	push   $0xd7
f0117080:	68 8c b5 12 f0       	push   $0xf012b58c
f0117085:	e8 af 92 fe ff       	call   f0100339 <_panic>

f011708a <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f011708a:	55                   	push   %ebp
f011708b:	89 e5                	mov    %esp,%ebp
f011708d:	57                   	push   %edi
f011708e:	53                   	push   %ebx
f011708f:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117095:	83 ec 0c             	sub    $0xc,%esp
f0117098:	68 a8 b5 12 f0       	push   $0xf012b5a8
f011709d:	e8 e9 9e fe ff       	call   f0100f8b <cprintf>
f01170a2:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01170a5:	83 ec 0c             	sub    $0xc,%esp
f01170a8:	68 d8 b5 12 f0       	push   $0xf012b5d8
f01170ad:	e8 d9 9e fe ff       	call   f0100f8b <cprintf>
f01170b2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01170b5:	83 ec 0c             	sub    $0xc,%esp
f01170b8:	68 a8 b5 12 f0       	push   $0xf012b5a8
f01170bd:	e8 c9 9e fe ff       	call   f0100f8b <cprintf>
f01170c2:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f01170c5:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f01170c9:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f01170cd:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f01170d3:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f01170d9:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f01170e0:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f01170e7:	e8 5c 7b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01170ec:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f01170ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01170f6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f01170fd:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0117103:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117108:	b8 00 00 00 00       	mov    $0x0,%eax
f011710d:	89 d7                	mov    %edx,%edi
f011710f:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0117111:	83 ec 0c             	sub    $0xc,%esp
f0117114:	68 31 b6 12 f0       	push   $0xf012b631
f0117119:	e8 6d 9e fe ff       	call   f0100f8b <cprintf>
f011711e:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117121:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0117128:	e8 1b 7b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011712d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117130:	e8 5e d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117135:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0117138:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f011713f:	83 ec 0c             	sub    $0xc,%esp
f0117142:	ff 75 cc             	pushl  -0x34(%ebp)
f0117145:	e8 85 26 ff ff       	call   f01097cf <kmalloc>
f011714a:	83 c4 10             	add    $0x10,%esp
f011714d:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0117153:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0117159:	85 c0                	test   %eax,%eax
f011715b:	74 17                	je     f0117174 <test_kmalloc+0xea>
f011715d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117164:	83 ec 0c             	sub    $0xc,%esp
f0117167:	68 50 b6 12 f0       	push   $0xf012b650
f011716c:	e8 1a 9e fe ff       	call   f0100f8b <cprintf>
f0117171:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117174:	e8 1a d9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117179:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011717c:	74 17                	je     f0117195 <test_kmalloc+0x10b>
f011717e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117185:	83 ec 0c             	sub    $0xc,%esp
f0117188:	68 84 b6 12 f0       	push   $0xf012b684
f011718d:	e8 f9 9d fe ff       	call   f0100f8b <cprintf>
f0117192:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117195:	e8 ae 7a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011719a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011719d:	74 17                	je     f01171b6 <test_kmalloc+0x12c>
f011719f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171a6:	83 ec 0c             	sub    $0xc,%esp
f01171a9:	68 f0 b6 12 f0       	push   $0xf012b6f0
f01171ae:	e8 d8 9d fe ff       	call   f0100f8b <cprintf>
f01171b3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01171b6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01171ba:	74 04                	je     f01171c0 <test_kmalloc+0x136>
f01171bc:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f01171c0:	83 ec 0c             	sub    $0xc,%esp
f01171c3:	68 34 b7 12 f0       	push   $0xf012b734
f01171c8:	e8 be 9d fe ff       	call   f0100f8b <cprintf>
f01171cd:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01171d0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01171d7:	e8 6c 7a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01171dc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01171df:	e8 af d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01171e4:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01171e7:	83 ec 0c             	sub    $0xc,%esp
f01171ea:	68 00 fc 1f 00       	push   $0x1ffc00
f01171ef:	e8 db 25 ff ff       	call   f01097cf <kmalloc>
f01171f4:	83 c4 10             	add    $0x10,%esp
f01171f7:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01171fd:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0117203:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117208:	74 17                	je     f0117221 <test_kmalloc+0x197>
f011720a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117211:	83 ec 0c             	sub    $0xc,%esp
f0117214:	68 78 b7 12 f0       	push   $0xf012b778
f0117219:	e8 6d 9d fe ff       	call   f0100f8b <cprintf>
f011721e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117221:	e8 6d d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117226:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117229:	74 17                	je     f0117242 <test_kmalloc+0x1b8>
f011722b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117232:	83 ec 0c             	sub    $0xc,%esp
f0117235:	68 cc b7 12 f0       	push   $0xf012b7cc
f011723a:	e8 4c 9d fe ff       	call   f0100f8b <cprintf>
f011723f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117242:	e8 01 7a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117247:	89 c2                	mov    %eax,%edx
f0117249:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011724c:	29 d0                	sub    %edx,%eax
f011724e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117253:	7f 17                	jg     f011726c <test_kmalloc+0x1e2>
f0117255:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011725c:	83 ec 0c             	sub    $0xc,%esp
f011725f:	68 38 b8 12 f0       	push   $0xf012b838
f0117264:	e8 22 9d fe ff       	call   f0100f8b <cprintf>
f0117269:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011726c:	e8 d7 79 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117271:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117274:	e8 1a d8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117279:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011727c:	83 ec 0c             	sub    $0xc,%esp
f011727f:	68 00 fc 1f 00       	push   $0x1ffc00
f0117284:	e8 46 25 ff ff       	call   f01097cf <kmalloc>
f0117289:	83 c4 10             	add    $0x10,%esp
f011728c:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117292:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0117298:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011729d:	74 17                	je     f01172b6 <test_kmalloc+0x22c>
f011729f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172a6:	83 ec 0c             	sub    $0xc,%esp
f01172a9:	68 7c b8 12 f0       	push   $0xf012b87c
f01172ae:	e8 d8 9c fe ff       	call   f0100f8b <cprintf>
f01172b3:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01172b6:	e8 d8 d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01172bb:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01172be:	74 17                	je     f01172d7 <test_kmalloc+0x24d>
f01172c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172c7:	83 ec 0c             	sub    $0xc,%esp
f01172ca:	68 d0 b8 12 f0       	push   $0xf012b8d0
f01172cf:	e8 b7 9c fe ff       	call   f0100f8b <cprintf>
f01172d4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01172d7:	e8 6c 79 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01172dc:	89 c2                	mov    %eax,%edx
f01172de:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01172e1:	29 d0                	sub    %edx,%eax
f01172e3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01172e8:	7f 17                	jg     f0117301 <test_kmalloc+0x277>
f01172ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172f1:	83 ec 0c             	sub    $0xc,%esp
f01172f4:	68 3c b9 12 f0       	push   $0xf012b93c
f01172f9:	e8 8d 9c fe ff       	call   f0100f8b <cprintf>
f01172fe:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0117301:	e8 42 79 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117306:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117309:	e8 85 d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011730e:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0117311:	83 ec 0c             	sub    $0xc,%esp
f0117314:	68 ff 07 00 00       	push   $0x7ff
f0117319:	e8 b1 24 ff ff       	call   f01097cf <kmalloc>
f011731e:	83 c4 10             	add    $0x10,%esp
f0117321:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0117327:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011732d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117332:	76 28                	jbe    f011735c <test_kmalloc+0x2d2>
f0117334:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f011733a:	83 ec 0c             	sub    $0xc,%esp
f011733d:	6a 00                	push   $0x0
f011733f:	e8 58 23 ff ff       	call   f010969c <sbrk>
f0117344:	83 c4 10             	add    $0x10,%esp
f0117347:	39 c3                	cmp    %eax,%ebx
f0117349:	73 11                	jae    f011735c <test_kmalloc+0x2d2>
f011734b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117351:	89 c2                	mov    %eax,%edx
f0117353:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0117358:	39 c2                	cmp    %eax,%edx
f011735a:	72 17                	jb     f0117373 <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011735c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117363:	83 ec 0c             	sub    $0xc,%esp
f0117366:	68 80 b9 12 f0       	push   $0xf012b980
f011736b:	e8 1b 9c fe ff       	call   f0100f8b <cprintf>
f0117370:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117373:	e8 1b d7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117378:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011737b:	74 17                	je     f0117394 <test_kmalloc+0x30a>
f011737d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117384:	83 ec 0c             	sub    $0xc,%esp
f0117387:	68 0c ba 12 f0       	push   $0xf012ba0c
f011738c:	e8 fa 9b fe ff       	call   f0100f8b <cprintf>
f0117391:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117394:	e8 fa d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117399:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f011739c:	83 ec 0c             	sub    $0xc,%esp
f011739f:	68 ff 07 00 00       	push   $0x7ff
f01173a4:	e8 26 24 ff ff       	call   f01097cf <kmalloc>
f01173a9:	83 c4 10             	add    $0x10,%esp
f01173ac:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01173b2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01173b8:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01173bd:	76 28                	jbe    f01173e7 <test_kmalloc+0x35d>
f01173bf:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f01173c5:	83 ec 0c             	sub    $0xc,%esp
f01173c8:	6a 00                	push   $0x0
f01173ca:	e8 cd 22 ff ff       	call   f010969c <sbrk>
f01173cf:	83 c4 10             	add    $0x10,%esp
f01173d2:	39 c3                	cmp    %eax,%ebx
f01173d4:	73 11                	jae    f01173e7 <test_kmalloc+0x35d>
f01173d6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01173dc:	89 c2                	mov    %eax,%edx
f01173de:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f01173e3:	39 c2                	cmp    %eax,%edx
f01173e5:	72 17                	jb     f01173fe <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01173e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173ee:	83 ec 0c             	sub    $0xc,%esp
f01173f1:	68 78 ba 12 f0       	push   $0xf012ba78
f01173f6:	e8 90 9b fe ff       	call   f0100f8b <cprintf>
f01173fb:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173fe:	e8 90 d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117403:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117406:	74 17                	je     f011741f <test_kmalloc+0x395>
f0117408:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011740f:	83 ec 0c             	sub    $0xc,%esp
f0117412:	68 04 bb 12 f0       	push   $0xf012bb04
f0117417:	e8 6f 9b fe ff       	call   f0100f8b <cprintf>
f011741c:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f011741f:	e8 24 78 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117424:	89 c2                	mov    %eax,%edx
f0117426:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117429:	29 d0                	sub    %edx,%eax
f011742b:	83 f8 01             	cmp    $0x1,%eax
f011742e:	74 17                	je     f0117447 <test_kmalloc+0x3bd>
f0117430:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117437:	83 ec 0c             	sub    $0xc,%esp
f011743a:	68 70 bb 12 f0       	push   $0xf012bb70
f011743f:	e8 47 9b fe ff       	call   f0100f8b <cprintf>
f0117444:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117447:	e8 fc 77 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011744c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011744f:	e8 3f d6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117454:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0117457:	83 ec 0c             	sub    $0xc,%esp
f011745a:	68 00 1c 00 00       	push   $0x1c00
f011745f:	e8 6b 23 ff ff       	call   f01097cf <kmalloc>
f0117464:	83 c4 10             	add    $0x10,%esp
f0117467:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011746d:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117473:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117478:	74 17                	je     f0117491 <test_kmalloc+0x407>
f011747a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117481:	83 ec 0c             	sub    $0xc,%esp
f0117484:	68 90 bb 12 f0       	push   $0xf012bb90
f0117489:	e8 fd 9a fe ff       	call   f0100f8b <cprintf>
f011748e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117491:	e8 fd d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117496:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117499:	74 17                	je     f01174b2 <test_kmalloc+0x428>
f011749b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174a2:	83 ec 0c             	sub    $0xc,%esp
f01174a5:	68 e4 bb 12 f0       	push   $0xf012bbe4
f01174aa:	e8 dc 9a fe ff       	call   f0100f8b <cprintf>
f01174af:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01174b2:	e8 91 77 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01174b7:	89 c2                	mov    %eax,%edx
f01174b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01174bc:	29 d0                	sub    %edx,%eax
f01174be:	83 f8 01             	cmp    $0x1,%eax
f01174c1:	7f 17                	jg     f01174da <test_kmalloc+0x450>
f01174c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174ca:	83 ec 0c             	sub    $0xc,%esp
f01174cd:	68 50 bc 12 f0       	push   $0xf012bc50
f01174d2:	e8 b4 9a fe ff       	call   f0100f8b <cprintf>
f01174d7:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01174da:	e8 69 77 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01174df:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01174e2:	e8 ac d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01174e7:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f01174ea:	83 ec 0c             	sub    $0xc,%esp
f01174ed:	68 00 fc 2f 00       	push   $0x2ffc00
f01174f2:	e8 d8 22 ff ff       	call   f01097cf <kmalloc>
f01174f7:	83 c4 10             	add    $0x10,%esp
f01174fa:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117500:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0117506:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011750b:	74 17                	je     f0117524 <test_kmalloc+0x49a>
f011750d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117514:	83 ec 0c             	sub    $0xc,%esp
f0117517:	68 94 bc 12 f0       	push   $0xf012bc94
f011751c:	e8 6a 9a fe ff       	call   f0100f8b <cprintf>
f0117521:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117524:	e8 6a d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117529:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011752c:	74 17                	je     f0117545 <test_kmalloc+0x4bb>
f011752e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117535:	83 ec 0c             	sub    $0xc,%esp
f0117538:	68 e8 bc 12 f0       	push   $0xf012bce8
f011753d:	e8 49 9a fe ff       	call   f0100f8b <cprintf>
f0117542:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117545:	e8 fe 76 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011754a:	89 c2                	mov    %eax,%edx
f011754c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011754f:	29 d0                	sub    %edx,%eax
f0117551:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117556:	7f 17                	jg     f011756f <test_kmalloc+0x4e5>
f0117558:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011755f:	83 ec 0c             	sub    $0xc,%esp
f0117562:	68 54 bd 12 f0       	push   $0xf012bd54
f0117567:	e8 1f 9a fe ff       	call   f0100f8b <cprintf>
f011756c:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011756f:	e8 d4 76 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117574:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117577:	e8 17 d5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011757c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011757f:	83 ec 0c             	sub    $0xc,%esp
f0117582:	68 00 fc 5f 00       	push   $0x5ffc00
f0117587:	e8 43 22 ff ff       	call   f01097cf <kmalloc>
f011758c:	83 c4 10             	add    $0x10,%esp
f011758f:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117595:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011759b:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01175a0:	74 17                	je     f01175b9 <test_kmalloc+0x52f>
f01175a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175a9:	83 ec 0c             	sub    $0xc,%esp
f01175ac:	68 98 bd 12 f0       	push   $0xf012bd98
f01175b1:	e8 d5 99 fe ff       	call   f0100f8b <cprintf>
f01175b6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01175b9:	e8 d5 d4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01175be:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01175c1:	74 17                	je     f01175da <test_kmalloc+0x550>
f01175c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175ca:	83 ec 0c             	sub    $0xc,%esp
f01175cd:	68 ec bd 12 f0       	push   $0xf012bdec
f01175d2:	e8 b4 99 fe ff       	call   f0100f8b <cprintf>
f01175d7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01175da:	e8 69 76 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01175df:	89 c2                	mov    %eax,%edx
f01175e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01175e4:	29 d0                	sub    %edx,%eax
f01175e6:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f01175eb:	7f 17                	jg     f0117604 <test_kmalloc+0x57a>
f01175ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175f4:	83 ec 0c             	sub    $0xc,%esp
f01175f7:	68 58 be 12 f0       	push   $0xf012be58
f01175fc:	e8 8a 99 fe ff       	call   f0100f8b <cprintf>
f0117601:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117604:	e8 3f 76 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117609:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011760c:	e8 82 d4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117611:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0117614:	83 ec 0c             	sub    $0xc,%esp
f0117617:	68 00 38 00 00       	push   $0x3800
f011761c:	e8 ae 21 ff ff       	call   f01097cf <kmalloc>
f0117621:	83 c4 10             	add    $0x10,%esp
f0117624:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011762a:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117630:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0117635:	74 17                	je     f011764e <test_kmalloc+0x5c4>
f0117637:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011763e:	83 ec 0c             	sub    $0xc,%esp
f0117641:	68 9c be 12 f0       	push   $0xf012be9c
f0117646:	e8 40 99 fe ff       	call   f0100f8b <cprintf>
f011764b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011764e:	e8 40 d4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117653:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117656:	74 17                	je     f011766f <test_kmalloc+0x5e5>
f0117658:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011765f:	83 ec 0c             	sub    $0xc,%esp
f0117662:	68 f0 be 12 f0       	push   $0xf012bef0
f0117667:	e8 1f 99 fe ff       	call   f0100f8b <cprintf>
f011766c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011766f:	e8 d4 75 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117674:	89 c2                	mov    %eax,%edx
f0117676:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117679:	29 d0                	sub    %edx,%eax
f011767b:	83 f8 03             	cmp    $0x3,%eax
f011767e:	7f 17                	jg     f0117697 <test_kmalloc+0x60d>
f0117680:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117687:	83 ec 0c             	sub    $0xc,%esp
f011768a:	68 5c bf 12 f0       	push   $0xf012bf5c
f011768f:	e8 f7 98 fe ff       	call   f0100f8b <cprintf>
f0117694:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117697:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011769b:	74 04                	je     f01176a1 <test_kmalloc+0x617>
f011769d:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01176a1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f01176a8:	83 ec 0c             	sub    $0xc,%esp
f01176ab:	68 a0 bf 12 f0       	push   $0xf012bfa0
f01176b0:	e8 d6 98 fe ff       	call   f0100f8b <cprintf>
f01176b5:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f01176b8:	e8 8b 75 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01176bd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01176c0:	e8 ce d3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01176c5:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f01176c8:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f01176cf:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01176d5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f01176d8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01176db:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01176de:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f01176e0:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01176e3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01176e6:	01 c2                	add    %eax,%edx
f01176e8:	8a 45 ea             	mov    -0x16(%ebp),%al
f01176eb:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f01176ed:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f01176f3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f01176f6:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f01176fd:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117700:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117703:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0117706:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117709:	01 c0                	add    %eax,%eax
f011770b:	89 c2                	mov    %eax,%edx
f011770d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117710:	01 c2                	add    %eax,%edx
f0117712:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117716:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0117719:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011771f:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0117722:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0117729:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011772c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011772f:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0117731:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117734:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011773b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011773e:	01 c2                	add    %eax,%edx
f0117740:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117743:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0117745:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011774b:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f011774e:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0117755:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117758:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011775b:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f011775d:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0117760:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117763:	01 c2                	add    %eax,%edx
f0117765:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117768:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f011776a:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117770:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0117773:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f011777a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011777d:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117780:	88 10                	mov    %dl,(%eax)
f0117782:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0117785:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117788:	66 89 42 02          	mov    %ax,0x2(%edx)
f011778c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011778f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0117792:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0117795:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117798:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011779f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177a2:	01 c2                	add    %eax,%edx
f01177a4:	8a 45 ea             	mov    -0x16(%ebp),%al
f01177a7:	88 02                	mov    %al,(%edx)
f01177a9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01177ac:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01177b3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177b6:	01 c2                	add    %eax,%edx
f01177b8:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01177bc:	66 89 42 02          	mov    %ax,0x2(%edx)
f01177c0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01177c3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01177ca:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01177cd:	01 c2                	add    %eax,%edx
f01177cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01177d2:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f01177d5:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f01177dc:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01177e2:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f01177e5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01177e8:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01177eb:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f01177ed:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01177f0:	89 c2                	mov    %eax,%edx
f01177f2:	c1 ea 1f             	shr    $0x1f,%edx
f01177f5:	01 d0                	add    %edx,%eax
f01177f7:	d1 f8                	sar    %eax
f01177f9:	89 c2                	mov    %eax,%edx
f01177fb:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01177fe:	01 c2                	add    %eax,%edx
f0117800:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117803:	88 c1                	mov    %al,%cl
f0117805:	c0 e9 07             	shr    $0x7,%cl
f0117808:	01 c8                	add    %ecx,%eax
f011780a:	d0 f8                	sar    %al
f011780c:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f011780e:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117811:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117814:	01 c2                	add    %eax,%edx
f0117816:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117819:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011781b:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117821:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0117824:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011782b:	8b 55 98             	mov    -0x68(%ebp),%edx
f011782e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117831:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0117834:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0117837:	01 c0                	add    %eax,%eax
f0117839:	89 c2                	mov    %eax,%edx
f011783b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011783e:	01 c2                	add    %eax,%edx
f0117840:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117844:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0117847:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011784a:	8a 00                	mov    (%eax),%al
f011784c:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011784f:	75 0f                	jne    f0117860 <test_kmalloc+0x7d6>
f0117851:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117854:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117857:	01 d0                	add    %edx,%eax
f0117859:	8a 00                	mov    (%eax),%al
f011785b:	3a 45 ea             	cmp    -0x16(%ebp),%al
f011785e:	74 17                	je     f0117877 <test_kmalloc+0x7ed>
f0117860:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117867:	83 ec 0c             	sub    $0xc,%esp
f011786a:	68 d8 bf 12 f0       	push   $0xf012bfd8
f011786f:	e8 17 97 fe ff       	call   f0100f8b <cprintf>
f0117874:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0117877:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011787a:	66 8b 00             	mov    (%eax),%ax
f011787d:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117881:	75 15                	jne    f0117898 <test_kmalloc+0x80e>
f0117883:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117886:	01 c0                	add    %eax,%eax
f0117888:	89 c2                	mov    %eax,%edx
f011788a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011788d:	01 d0                	add    %edx,%eax
f011788f:	66 8b 00             	mov    (%eax),%ax
f0117892:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117896:	74 17                	je     f01178af <test_kmalloc+0x825>
f0117898:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011789f:	83 ec 0c             	sub    $0xc,%esp
f01178a2:	68 10 c0 12 f0       	push   $0xf012c010
f01178a7:	e8 df 96 fe ff       	call   f0100f8b <cprintf>
f01178ac:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f01178af:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01178b2:	8b 00                	mov    (%eax),%eax
f01178b4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01178b7:	75 16                	jne    f01178cf <test_kmalloc+0x845>
f01178b9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01178bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01178c3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01178c6:	01 d0                	add    %edx,%eax
f01178c8:	8b 00                	mov    (%eax),%eax
f01178ca:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01178cd:	74 17                	je     f01178e6 <test_kmalloc+0x85c>
f01178cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178d6:	83 ec 0c             	sub    $0xc,%esp
f01178d9:	68 4c c0 12 f0       	push   $0xf012c04c
f01178de:	e8 a8 96 fe ff       	call   f0100f8b <cprintf>
f01178e3:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f01178e6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01178e9:	8a 00                	mov    (%eax),%al
f01178eb:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01178ee:	75 0f                	jne    f01178ff <test_kmalloc+0x875>
f01178f0:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01178f3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01178f6:	01 d0                	add    %edx,%eax
f01178f8:	8a 00                	mov    (%eax),%al
f01178fa:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01178fd:	74 17                	je     f0117916 <test_kmalloc+0x88c>
f01178ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117906:	83 ec 0c             	sub    $0xc,%esp
f0117909:	68 88 c0 12 f0       	push   $0xf012c088
f011790e:	e8 78 96 fe ff       	call   f0100f8b <cprintf>
f0117913:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f0117916:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117919:	8a 00                	mov    (%eax),%al
f011791b:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011791e:	75 16                	jne    f0117936 <test_kmalloc+0x8ac>
f0117920:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117923:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011792a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011792d:	01 d0                	add    %edx,%eax
f011792f:	8a 00                	mov    (%eax),%al
f0117931:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117934:	74 17                	je     f011794d <test_kmalloc+0x8c3>
f0117936:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011793d:	83 ec 0c             	sub    $0xc,%esp
f0117940:	68 c4 c0 12 f0       	push   $0xf012c0c4
f0117945:	e8 41 96 fe ff       	call   f0100f8b <cprintf>
f011794a:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f011794d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117950:	66 8b 40 02          	mov    0x2(%eax),%ax
f0117954:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117958:	75 19                	jne    f0117973 <test_kmalloc+0x8e9>
f011795a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011795d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117964:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117967:	01 d0                	add    %edx,%eax
f0117969:	66 8b 40 02          	mov    0x2(%eax),%ax
f011796d:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117971:	74 17                	je     f011798a <test_kmalloc+0x900>
f0117973:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011797a:	83 ec 0c             	sub    $0xc,%esp
f011797d:	68 00 c1 12 f0       	push   $0xf012c100
f0117982:	e8 04 96 fe ff       	call   f0100f8b <cprintf>
f0117987:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f011798a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011798d:	8b 40 04             	mov    0x4(%eax),%eax
f0117990:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0117993:	75 17                	jne    f01179ac <test_kmalloc+0x922>
f0117995:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117998:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011799f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01179a2:	01 d0                	add    %edx,%eax
f01179a4:	8b 40 04             	mov    0x4(%eax),%eax
f01179a7:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01179aa:	74 17                	je     f01179c3 <test_kmalloc+0x939>
f01179ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179b3:	83 ec 0c             	sub    $0xc,%esp
f01179b6:	68 3c c1 12 f0       	push   $0xf012c13c
f01179bb:	e8 cb 95 fe ff       	call   f0100f8b <cprintf>
f01179c0:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f01179c3:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01179c6:	8a 00                	mov    (%eax),%al
f01179c8:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01179cb:	75 34                	jne    f0117a01 <test_kmalloc+0x977>
f01179cd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01179d0:	89 c2                	mov    %eax,%edx
f01179d2:	c1 ea 1f             	shr    $0x1f,%edx
f01179d5:	01 d0                	add    %edx,%eax
f01179d7:	d1 f8                	sar    %eax
f01179d9:	89 c2                	mov    %eax,%edx
f01179db:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01179de:	01 d0                	add    %edx,%eax
f01179e0:	8a 10                	mov    (%eax),%dl
f01179e2:	8a 45 ea             	mov    -0x16(%ebp),%al
f01179e5:	88 c1                	mov    %al,%cl
f01179e7:	c0 e9 07             	shr    $0x7,%cl
f01179ea:	01 c8                	add    %ecx,%eax
f01179ec:	d0 f8                	sar    %al
f01179ee:	38 c2                	cmp    %al,%dl
f01179f0:	75 0f                	jne    f0117a01 <test_kmalloc+0x977>
f01179f2:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01179f5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01179f8:	01 d0                	add    %edx,%eax
f01179fa:	8a 00                	mov    (%eax),%al
f01179fc:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01179ff:	74 17                	je     f0117a18 <test_kmalloc+0x98e>
f0117a01:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a08:	83 ec 0c             	sub    $0xc,%esp
f0117a0b:	68 78 c1 12 f0       	push   $0xf012c178
f0117a10:	e8 76 95 fe ff       	call   f0100f8b <cprintf>
f0117a15:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f0117a18:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117a1b:	66 8b 00             	mov    (%eax),%ax
f0117a1e:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117a22:	75 15                	jne    f0117a39 <test_kmalloc+0x9af>
f0117a24:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0117a27:	01 c0                	add    %eax,%eax
f0117a29:	89 c2                	mov    %eax,%edx
f0117a2b:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117a2e:	01 d0                	add    %edx,%eax
f0117a30:	66 8b 00             	mov    (%eax),%ax
f0117a33:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117a37:	74 17                	je     f0117a50 <test_kmalloc+0x9c6>
f0117a39:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a40:	83 ec 0c             	sub    $0xc,%esp
f0117a43:	68 b0 c1 12 f0       	push   $0xf012c1b0
f0117a48:	e8 3e 95 fe ff       	call   f0100f8b <cprintf>
f0117a4d:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117a50:	e8 f3 71 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117a55:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117a58:	74 17                	je     f0117a71 <test_kmalloc+0x9e7>
f0117a5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a61:	83 ec 0c             	sub    $0xc,%esp
f0117a64:	68 ec c1 12 f0       	push   $0xf012c1ec
f0117a69:	e8 1d 95 fe ff       	call   f0100f8b <cprintf>
f0117a6e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a71:	e8 1d d0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117a76:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117a79:	74 17                	je     f0117a92 <test_kmalloc+0xa08>
f0117a7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a82:	83 ec 0c             	sub    $0xc,%esp
f0117a85:	68 30 c2 12 f0       	push   $0xf012c230
f0117a8a:	e8 fc 94 fe ff       	call   f0100f8b <cprintf>
f0117a8f:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0117a92:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117a96:	74 04                	je     f0117a9c <test_kmalloc+0xa12>
f0117a98:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0117a9c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f0117aa3:	83 ec 0c             	sub    $0xc,%esp
f0117aa6:	68 9c c2 12 f0       	push   $0xf012c29c
f0117aab:	e8 db 94 fe ff       	call   f0100f8b <cprintf>
f0117ab0:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ab3:	e8 90 71 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117ab8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117abb:	e8 d3 cf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117ac0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f0117ac3:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0117aca:	8b 45 90             	mov    -0x70(%ebp),%eax
f0117acd:	40                   	inc    %eax
f0117ace:	83 ec 0c             	sub    $0xc,%esp
f0117ad1:	50                   	push   %eax
f0117ad2:	e8 f8 1c ff ff       	call   f01097cf <kmalloc>
f0117ad7:	83 c4 10             	add    $0x10,%esp
f0117ada:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0117ae0:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0117ae6:	85 c0                	test   %eax,%eax
f0117ae8:	74 17                	je     f0117b01 <test_kmalloc+0xa77>
f0117aea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117af1:	83 ec 0c             	sub    $0xc,%esp
f0117af4:	68 c0 c2 12 f0       	push   $0xf012c2c0
f0117af9:	e8 8d 94 fe ff       	call   f0100f8b <cprintf>
f0117afe:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b01:	e8 8d cf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117b06:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117b09:	74 17                	je     f0117b22 <test_kmalloc+0xa98>
f0117b0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b12:	83 ec 0c             	sub    $0xc,%esp
f0117b15:	68 f8 c2 12 f0       	push   $0xf012c2f8
f0117b1a:	e8 6c 94 fe ff       	call   f0100f8b <cprintf>
f0117b1f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117b22:	e8 21 71 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117b27:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117b2a:	74 17                	je     f0117b43 <test_kmalloc+0xab9>
f0117b2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b33:	83 ec 0c             	sub    $0xc,%esp
f0117b36:	68 64 c3 12 f0       	push   $0xf012c364
f0117b3b:	e8 4b 94 fe ff       	call   f0100f8b <cprintf>
f0117b40:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117b43:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117b47:	74 04                	je     f0117b4d <test_kmalloc+0xac3>
f0117b49:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117b4d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f0117b54:	83 ec 0c             	sub    $0xc,%esp
f0117b57:	68 a8 c3 12 f0       	push   $0xf012c3a8
f0117b5c:	e8 2a 94 fe ff       	call   f0100f8b <cprintf>
f0117b61:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0117b64:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117b6a:	05 00 40 00 00       	add    $0x4000,%eax
f0117b6f:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117b72:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117b79:	eb 6a                	jmp    f0117be5 <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117b7b:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f0117b80:	83 ec 04             	sub    $0x4,%esp
f0117b83:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117b89:	52                   	push   %edx
f0117b8a:	ff 75 ec             	pushl  -0x14(%ebp)
f0117b8d:	50                   	push   %eax
f0117b8e:	e8 87 0b ff ff       	call   f010871a <get_page_table>
f0117b93:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117b96:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117b9c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0117b9f:	c1 ea 0c             	shr    $0xc,%edx
f0117ba2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117ba8:	c1 e2 02             	shl    $0x2,%edx
f0117bab:	01 d0                	add    %edx,%eax
f0117bad:	8b 00                	mov    (%eax),%eax
f0117baf:	25 ff 0f 00 00       	and    $0xfff,%eax
f0117bb4:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0117bb7:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117bba:	83 e0 04             	and    $0x4,%eax
f0117bbd:	85 c0                	test   %eax,%eax
f0117bbf:	74 1d                	je     f0117bde <test_kmalloc+0xb54>
			{
				if (correct)
f0117bc1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117bc5:	74 17                	je     f0117bde <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0117bc7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bce:	83 ec 0c             	sub    $0xc,%esp
f0117bd1:	68 ec c3 12 f0       	push   $0xf012c3ec
f0117bd6:	e8 b0 93 fe ff       	call   f0100f8b <cprintf>
f0117bdb:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117bde:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0117be5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117be8:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0117beb:	72 8e                	jb     f0117b7b <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0117bed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117bf1:	74 04                	je     f0117bf7 <test_kmalloc+0xb6d>
f0117bf3:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f0117bf7:	83 ec 08             	sub    $0x8,%esp
f0117bfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0117bfd:	68 3c c4 12 f0       	push   $0xf012c43c
f0117c02:	e8 84 93 fe ff       	call   f0100f8b <cprintf>
f0117c07:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117c0a:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0117c0f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0117c12:	5b                   	pop    %ebx
f0117c13:	5f                   	pop    %edi
f0117c14:	5d                   	pop    %ebp
f0117c15:	c3                   	ret    

f0117c16 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0117c16:	55                   	push   %ebp
f0117c17:	89 e5                	mov    %esp,%ebp
f0117c19:	57                   	push   %edi
f0117c1a:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117c1d:	83 ec 0c             	sub    $0xc,%esp
f0117c20:	68 a8 b5 12 f0       	push   $0xf012b5a8
f0117c25:	e8 61 93 fe ff       	call   f0100f8b <cprintf>
f0117c2a:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117c2d:	83 ec 0c             	sub    $0xc,%esp
f0117c30:	68 d8 b5 12 f0       	push   $0xf012b5d8
f0117c35:	e8 51 93 fe ff       	call   f0100f8b <cprintf>
f0117c3a:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117c3d:	83 ec 0c             	sub    $0xc,%esp
f0117c40:	68 a8 b5 12 f0       	push   $0xf012b5a8
f0117c45:	e8 41 93 fe ff       	call   f0100f8b <cprintf>
f0117c4a:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117c4d:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117c50:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117c55:	b8 00 00 00 00       	mov    $0x0,%eax
f0117c5a:	89 d7                	mov    %edx,%edi
f0117c5c:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117c5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117c65:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117c6c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f0117c73:	83 ec 0c             	sub    $0xc,%esp
f0117c76:	68 68 c4 12 f0       	push   $0xf012c468
f0117c7b:	e8 0b 93 fe ff       	call   f0100f8b <cprintf>
f0117c80:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c83:	e8 c0 6f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117c88:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c8b:	e8 03 ce fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117c90:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0117c93:	83 ec 0c             	sub    $0xc,%esp
f0117c96:	68 00 fc 0f 00       	push   $0xffc00
f0117c9b:	e8 2f 1b ff ff       	call   f01097cf <kmalloc>
f0117ca0:	83 c4 10             	add    $0x10,%esp
f0117ca3:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0117ca6:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117ca9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117cae:	74 17                	je     f0117cc7 <test_kmalloc_firstfit1+0xb1>
f0117cb0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cb7:	83 ec 0c             	sub    $0xc,%esp
f0117cba:	68 a8 c4 12 f0       	push   $0xf012c4a8
f0117cbf:	e8 c7 92 fe ff       	call   f0100f8b <cprintf>
f0117cc4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117cc7:	e8 c7 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117ccc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ccf:	74 17                	je     f0117ce8 <test_kmalloc_firstfit1+0xd2>
f0117cd1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cd8:	83 ec 0c             	sub    $0xc,%esp
f0117cdb:	68 cc b7 12 f0       	push   $0xf012b7cc
f0117ce0:	e8 a6 92 fe ff       	call   f0100f8b <cprintf>
f0117ce5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f0117ce8:	e8 5b 6f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117ced:	89 c2                	mov    %eax,%edx
f0117cef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117cf2:	29 d0                	sub    %edx,%eax
f0117cf4:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117cf9:	7f 17                	jg     f0117d12 <test_kmalloc_firstfit1+0xfc>
f0117cfb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d02:	83 ec 0c             	sub    $0xc,%esp
f0117d05:	68 db c4 12 f0       	push   $0xf012c4db
f0117d0a:	e8 7c 92 fe ff       	call   f0100f8b <cprintf>
f0117d0f:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d12:	e8 31 6f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117d17:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d1a:	e8 74 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117d1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0117d22:	83 ec 0c             	sub    $0xc,%esp
f0117d25:	68 00 fc 0f 00       	push   $0xffc00
f0117d2a:	e8 a0 1a ff ff       	call   f01097cf <kmalloc>
f0117d2f:	83 c4 10             	add    $0x10,%esp
f0117d32:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117d35:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117d38:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117d3d:	74 17                	je     f0117d56 <test_kmalloc_firstfit1+0x140>
f0117d3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d46:	83 ec 0c             	sub    $0xc,%esp
f0117d49:	68 f4 c4 12 f0       	push   $0xf012c4f4
f0117d4e:	e8 38 92 fe ff       	call   f0100f8b <cprintf>
f0117d53:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d56:	e8 38 cd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117d5b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d5e:	74 17                	je     f0117d77 <test_kmalloc_firstfit1+0x161>
f0117d60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d67:	83 ec 0c             	sub    $0xc,%esp
f0117d6a:	68 d0 b8 12 f0       	push   $0xf012b8d0
f0117d6f:	e8 17 92 fe ff       	call   f0100f8b <cprintf>
f0117d74:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117d77:	e8 cc 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117d7c:	89 c2                	mov    %eax,%edx
f0117d7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117d81:	29 d0                	sub    %edx,%eax
f0117d83:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117d88:	7f 17                	jg     f0117da1 <test_kmalloc_firstfit1+0x18b>
f0117d8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d91:	83 ec 0c             	sub    $0xc,%esp
f0117d94:	68 27 c5 12 f0       	push   $0xf012c527
f0117d99:	e8 ed 91 fe ff       	call   f0100f8b <cprintf>
f0117d9e:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117da1:	e8 a2 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117da6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117da9:	e8 e5 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117dae:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0117db1:	83 ec 0c             	sub    $0xc,%esp
f0117db4:	68 00 fc 0f 00       	push   $0xffc00
f0117db9:	e8 11 1a ff ff       	call   f01097cf <kmalloc>
f0117dbe:	83 c4 10             	add    $0x10,%esp
f0117dc1:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117dc4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117dc7:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117dcc:	74 17                	je     f0117de5 <test_kmalloc_firstfit1+0x1cf>
f0117dce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dd5:	83 ec 0c             	sub    $0xc,%esp
f0117dd8:	68 40 c5 12 f0       	push   $0xf012c540
f0117ddd:	e8 a9 91 fe ff       	call   f0100f8b <cprintf>
f0117de2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117de5:	e8 a9 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117dea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ded:	74 17                	je     f0117e06 <test_kmalloc_firstfit1+0x1f0>
f0117def:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117df6:	83 ec 0c             	sub    $0xc,%esp
f0117df9:	68 0c ba 12 f0       	push   $0xf012ba0c
f0117dfe:	e8 88 91 fe ff       	call   f0100f8b <cprintf>
f0117e03:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117e06:	e8 3d 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117e0b:	89 c2                	mov    %eax,%edx
f0117e0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e10:	29 d0                	sub    %edx,%eax
f0117e12:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117e17:	7f 17                	jg     f0117e30 <test_kmalloc_firstfit1+0x21a>
f0117e19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e20:	83 ec 0c             	sub    $0xc,%esp
f0117e23:	68 73 c5 12 f0       	push   $0xf012c573
f0117e28:	e8 5e 91 fe ff       	call   f0100f8b <cprintf>
f0117e2d:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e30:	e8 13 6e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117e35:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e38:	e8 56 cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117e3d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0117e40:	83 ec 0c             	sub    $0xc,%esp
f0117e43:	68 00 fc 0f 00       	push   $0xffc00
f0117e48:	e8 82 19 ff ff       	call   f01097cf <kmalloc>
f0117e4d:	83 c4 10             	add    $0x10,%esp
f0117e50:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117e53:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117e56:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117e5b:	74 17                	je     f0117e74 <test_kmalloc_firstfit1+0x25e>
f0117e5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e64:	83 ec 0c             	sub    $0xc,%esp
f0117e67:	68 8c c5 12 f0       	push   $0xf012c58c
f0117e6c:	e8 1a 91 fe ff       	call   f0100f8b <cprintf>
f0117e71:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e74:	e8 1a cc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117e79:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e7c:	74 17                	je     f0117e95 <test_kmalloc_firstfit1+0x27f>
f0117e7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e85:	83 ec 0c             	sub    $0xc,%esp
f0117e88:	68 04 bb 12 f0       	push   $0xf012bb04
f0117e8d:	e8 f9 90 fe ff       	call   f0100f8b <cprintf>
f0117e92:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117e95:	e8 ae 6d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117e9a:	89 c2                	mov    %eax,%edx
f0117e9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e9f:	29 d0                	sub    %edx,%eax
f0117ea1:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117ea6:	7f 17                	jg     f0117ebf <test_kmalloc_firstfit1+0x2a9>
f0117ea8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117eaf:	83 ec 0c             	sub    $0xc,%esp
f0117eb2:	68 bf c5 12 f0       	push   $0xf012c5bf
f0117eb7:	e8 cf 90 fe ff       	call   f0100f8b <cprintf>
f0117ebc:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ebf:	e8 84 6d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117ec4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117ec7:	e8 c7 cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117ecc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117ecf:	83 ec 0c             	sub    $0xc,%esp
f0117ed2:	68 00 fc 1f 00       	push   $0x1ffc00
f0117ed7:	e8 f3 18 ff ff       	call   f01097cf <kmalloc>
f0117edc:	83 c4 10             	add    $0x10,%esp
f0117edf:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0117ee2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117ee5:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117eea:	74 17                	je     f0117f03 <test_kmalloc_firstfit1+0x2ed>
f0117eec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ef3:	83 ec 0c             	sub    $0xc,%esp
f0117ef6:	68 d8 c5 12 f0       	push   $0xf012c5d8
f0117efb:	e8 8b 90 fe ff       	call   f0100f8b <cprintf>
f0117f00:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f03:	e8 8b cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117f08:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f0b:	74 17                	je     f0117f24 <test_kmalloc_firstfit1+0x30e>
f0117f0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f14:	83 ec 0c             	sub    $0xc,%esp
f0117f17:	68 e4 bb 12 f0       	push   $0xf012bbe4
f0117f1c:	e8 6a 90 fe ff       	call   f0100f8b <cprintf>
f0117f21:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0117f24:	e8 1f 6d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117f29:	89 c2                	mov    %eax,%edx
f0117f2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f2e:	29 d0                	sub    %edx,%eax
f0117f30:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117f35:	7f 17                	jg     f0117f4e <test_kmalloc_firstfit1+0x338>
f0117f37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f3e:	83 ec 0c             	sub    $0xc,%esp
f0117f41:	68 0b c6 12 f0       	push   $0xf012c60b
f0117f46:	e8 40 90 fe ff       	call   f0100f8b <cprintf>
f0117f4b:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f4e:	e8 f5 6c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117f53:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f56:	e8 38 cb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117f5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117f5e:	83 ec 0c             	sub    $0xc,%esp
f0117f61:	68 00 fc 1f 00       	push   $0x1ffc00
f0117f66:	e8 64 18 ff ff       	call   f01097cf <kmalloc>
f0117f6b:	83 c4 10             	add    $0x10,%esp
f0117f6e:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117f71:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117f74:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117f79:	74 17                	je     f0117f92 <test_kmalloc_firstfit1+0x37c>
f0117f7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f82:	83 ec 0c             	sub    $0xc,%esp
f0117f85:	68 24 c6 12 f0       	push   $0xf012c624
f0117f8a:	e8 fc 8f fe ff       	call   f0100f8b <cprintf>
f0117f8f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f92:	e8 fc ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117f97:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f9a:	74 17                	je     f0117fb3 <test_kmalloc_firstfit1+0x39d>
f0117f9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fa3:	83 ec 0c             	sub    $0xc,%esp
f0117fa6:	68 e8 bc 12 f0       	push   $0xf012bce8
f0117fab:	e8 db 8f fe ff       	call   f0100f8b <cprintf>
f0117fb0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117fb3:	e8 90 6c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117fb8:	89 c2                	mov    %eax,%edx
f0117fba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fbd:	29 d0                	sub    %edx,%eax
f0117fbf:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117fc4:	7f 17                	jg     f0117fdd <test_kmalloc_firstfit1+0x3c7>
f0117fc6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fcd:	83 ec 0c             	sub    $0xc,%esp
f0117fd0:	68 57 c6 12 f0       	push   $0xf012c657
f0117fd5:	e8 b1 8f fe ff       	call   f0100f8b <cprintf>
f0117fda:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117fdd:	e8 66 6c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0117fe2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117fe5:	e8 a9 ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0117fea:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117fed:	83 ec 0c             	sub    $0xc,%esp
f0117ff0:	68 00 fc 2f 00       	push   $0x2ffc00
f0117ff5:	e8 d5 17 ff ff       	call   f01097cf <kmalloc>
f0117ffa:	83 c4 10             	add    $0x10,%esp
f0117ffd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0118000:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118003:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0118008:	74 17                	je     f0118021 <test_kmalloc_firstfit1+0x40b>
f011800a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118011:	83 ec 0c             	sub    $0xc,%esp
f0118014:	68 70 c6 12 f0       	push   $0xf012c670
f0118019:	e8 6d 8f fe ff       	call   f0100f8b <cprintf>
f011801e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118021:	e8 6d ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118026:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118029:	74 17                	je     f0118042 <test_kmalloc_firstfit1+0x42c>
f011802b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118032:	83 ec 0c             	sub    $0xc,%esp
f0118035:	68 ec bd 12 f0       	push   $0xf012bdec
f011803a:	e8 4c 8f fe ff       	call   f0100f8b <cprintf>
f011803f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0118042:	e8 01 6c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118047:	89 c2                	mov    %eax,%edx
f0118049:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011804c:	29 d0                	sub    %edx,%eax
f011804e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118053:	7f 17                	jg     f011806c <test_kmalloc_firstfit1+0x456>
f0118055:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011805c:	83 ec 0c             	sub    $0xc,%esp
f011805f:	68 a3 c6 12 f0       	push   $0xf012c6a3
f0118064:	e8 22 8f fe ff       	call   f0100f8b <cprintf>
f0118069:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011806c:	e8 d7 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118071:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118074:	e8 1a ca fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118079:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f011807c:	83 ec 0c             	sub    $0xc,%esp
f011807f:	68 00 fc 2f 00       	push   $0x2ffc00
f0118084:	e8 46 17 ff ff       	call   f01097cf <kmalloc>
f0118089:	83 c4 10             	add    $0x10,%esp
f011808c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f011808f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118092:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0118097:	74 17                	je     f01180b0 <test_kmalloc_firstfit1+0x49a>
f0118099:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180a0:	83 ec 0c             	sub    $0xc,%esp
f01180a3:	68 bc c6 12 f0       	push   $0xf012c6bc
f01180a8:	e8 de 8e fe ff       	call   f0100f8b <cprintf>
f01180ad:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01180b0:	e8 de c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01180b5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180b8:	74 17                	je     f01180d1 <test_kmalloc_firstfit1+0x4bb>
f01180ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180c1:	83 ec 0c             	sub    $0xc,%esp
f01180c4:	68 f0 be 12 f0       	push   $0xf012bef0
f01180c9:	e8 bd 8e fe ff       	call   f0100f8b <cprintf>
f01180ce:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f01180d1:	e8 72 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01180d6:	89 c2                	mov    %eax,%edx
f01180d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01180db:	29 d0                	sub    %edx,%eax
f01180dd:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01180e2:	7f 17                	jg     f01180fb <test_kmalloc_firstfit1+0x4e5>
f01180e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180eb:	83 ec 0c             	sub    $0xc,%esp
f01180ee:	68 ef c6 12 f0       	push   $0xf012c6ef
f01180f3:	e8 93 8e fe ff       	call   f0100f8b <cprintf>
f01180f8:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01180fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01180ff:	74 04                	je     f0118105 <test_kmalloc_firstfit1+0x4ef>
f0118101:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118105:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f011810c:	83 ec 0c             	sub    $0xc,%esp
f011810f:	68 08 c7 12 f0       	push   $0xf012c708
f0118114:	e8 72 8e fe ff       	call   f0100f8b <cprintf>
f0118119:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011811c:	e8 27 6b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118121:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118124:	e8 6a c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118129:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011812c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011812f:	83 ec 0c             	sub    $0xc,%esp
f0118132:	50                   	push   %eax
f0118133:	e8 57 19 ff ff       	call   f0109a8f <kfree>
f0118138:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011813b:	e8 53 c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118140:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118143:	74 17                	je     f011815c <test_kmalloc_firstfit1+0x546>
f0118145:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011814c:	83 ec 0c             	sub    $0xc,%esp
f011814f:	68 30 c7 12 f0       	push   $0xf012c730
f0118154:	e8 32 8e fe ff       	call   f0100f8b <cprintf>
f0118159:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f011815c:	e8 e7 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118161:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118164:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118169:	7f 17                	jg     f0118182 <test_kmalloc_firstfit1+0x56c>
f011816b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118172:	83 ec 0c             	sub    $0xc,%esp
f0118175:	68 9b c7 12 f0       	push   $0xf012c79b
f011817a:	e8 0c 8e fe ff       	call   f0100f8b <cprintf>
f011817f:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118182:	e8 c1 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118187:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011818a:	e8 04 c9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011818f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0118192:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118195:	83 ec 0c             	sub    $0xc,%esp
f0118198:	50                   	push   %eax
f0118199:	e8 f1 18 ff ff       	call   f0109a8f <kfree>
f011819e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181a1:	e8 ed c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01181a6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181a9:	74 17                	je     f01181c2 <test_kmalloc_firstfit1+0x5ac>
f01181ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181b2:	83 ec 0c             	sub    $0xc,%esp
f01181b5:	68 ac c7 12 f0       	push   $0xf012c7ac
f01181ba:	e8 cc 8d fe ff       	call   f0100f8b <cprintf>
f01181bf:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f01181c2:	e8 81 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01181c7:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01181ca:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01181cf:	7f 17                	jg     f01181e8 <test_kmalloc_firstfit1+0x5d2>
f01181d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181d8:	83 ec 0c             	sub    $0xc,%esp
f01181db:	68 18 c8 12 f0       	push   $0xf012c818
f01181e0:	e8 a6 8d fe ff       	call   f0100f8b <cprintf>
f01181e5:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01181e8:	e8 5b 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01181ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181f0:	e8 9e c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01181f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01181f8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01181fb:	83 ec 0c             	sub    $0xc,%esp
f01181fe:	50                   	push   %eax
f01181ff:	e8 8b 18 ff ff       	call   f0109a8f <kfree>
f0118204:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118207:	e8 87 c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011820c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011820f:	74 17                	je     f0118228 <test_kmalloc_firstfit1+0x612>
f0118211:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118218:	83 ec 0c             	sub    $0xc,%esp
f011821b:	68 2c c8 12 f0       	push   $0xf012c82c
f0118220:	e8 66 8d fe ff       	call   f0100f8b <cprintf>
f0118225:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0118228:	e8 1b 6a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011822d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118230:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118235:	7f 17                	jg     f011824e <test_kmalloc_firstfit1+0x638>
f0118237:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011823e:	83 ec 0c             	sub    $0xc,%esp
f0118241:	68 98 c8 12 f0       	push   $0xf012c898
f0118246:	e8 40 8d fe ff       	call   f0100f8b <cprintf>
f011824b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011824e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118252:	74 04                	je     f0118258 <test_kmalloc_firstfit1+0x642>
f0118254:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118258:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f011825f:	83 ec 0c             	sub    $0xc,%esp
f0118262:	68 ac c8 12 f0       	push   $0xf012c8ac
f0118267:	e8 1f 8d fe ff       	call   f0100f8b <cprintf>
f011826c:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011826f:	e8 d4 69 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118274:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118277:	e8 17 c8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011827c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f011827f:	83 ec 0c             	sub    $0xc,%esp
f0118282:	68 00 fc 07 00       	push   $0x7fc00
f0118287:	e8 43 15 ff ff       	call   f01097cf <kmalloc>
f011828c:	83 c4 10             	add    $0x10,%esp
f011828f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0118292:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118295:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011829a:	74 17                	je     f01182b3 <test_kmalloc_firstfit1+0x69d>
f011829c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182a3:	83 ec 0c             	sub    $0xc,%esp
f01182a6:	68 d8 c8 12 f0       	push   $0xf012c8d8
f01182ab:	e8 db 8c fe ff       	call   f0100f8b <cprintf>
f01182b0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01182b3:	e8 db c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01182b8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01182bb:	74 17                	je     f01182d4 <test_kmalloc_firstfit1+0x6be>
f01182bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182c4:	83 ec 0c             	sub    $0xc,%esp
f01182c7:	68 0c c9 12 f0       	push   $0xf012c90c
f01182cc:	e8 ba 8c fe ff       	call   f0100f8b <cprintf>
f01182d1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f01182d4:	e8 6f 69 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01182d9:	89 c2                	mov    %eax,%edx
f01182db:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01182de:	29 d0                	sub    %edx,%eax
f01182e0:	83 f8 7f             	cmp    $0x7f,%eax
f01182e3:	7f 17                	jg     f01182fc <test_kmalloc_firstfit1+0x6e6>
f01182e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182ec:	83 ec 0c             	sub    $0xc,%esp
f01182ef:	68 78 c9 12 f0       	push   $0xf012c978
f01182f4:	e8 92 8c fe ff       	call   f0100f8b <cprintf>
f01182f9:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01182fc:	e8 47 69 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118301:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118304:	e8 8a c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118309:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f011830c:	83 ec 0c             	sub    $0xc,%esp
f011830f:	68 00 fc 0f 00       	push   $0xffc00
f0118314:	e8 b6 14 ff ff       	call   f01097cf <kmalloc>
f0118319:	83 c4 10             	add    $0x10,%esp
f011831c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f011831f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118322:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118327:	74 17                	je     f0118340 <test_kmalloc_firstfit1+0x72a>
f0118329:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118330:	83 ec 0c             	sub    $0xc,%esp
f0118333:	68 90 c9 12 f0       	push   $0xf012c990
f0118338:	e8 4e 8c fe ff       	call   f0100f8b <cprintf>
f011833d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118340:	e8 4e c7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118345:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118348:	74 17                	je     f0118361 <test_kmalloc_firstfit1+0x74b>
f011834a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118351:	83 ec 0c             	sub    $0xc,%esp
f0118354:	68 c4 c9 12 f0       	push   $0xf012c9c4
f0118359:	e8 2d 8c fe ff       	call   f0100f8b <cprintf>
f011835e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0118361:	e8 e2 68 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118366:	89 c2                	mov    %eax,%edx
f0118368:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011836b:	29 d0                	sub    %edx,%eax
f011836d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118372:	7f 17                	jg     f011838b <test_kmalloc_firstfit1+0x775>
f0118374:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011837b:	83 ec 0c             	sub    $0xc,%esp
f011837e:	68 30 ca 12 f0       	push   $0xf012ca30
f0118383:	e8 03 8c fe ff       	call   f0100f8b <cprintf>
f0118388:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011838b:	e8 b8 68 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118390:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118393:	e8 fb c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118398:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f011839b:	83 ec 0c             	sub    $0xc,%esp
f011839e:	68 00 fc 03 00       	push   $0x3fc00
f01183a3:	e8 27 14 ff ff       	call   f01097cf <kmalloc>
f01183a8:	83 c4 10             	add    $0x10,%esp
f01183ab:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f01183ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01183b1:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f01183b6:	74 17                	je     f01183cf <test_kmalloc_firstfit1+0x7b9>
f01183b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183bf:	83 ec 0c             	sub    $0xc,%esp
f01183c2:	68 48 ca 12 f0       	push   $0xf012ca48
f01183c7:	e8 bf 8b fe ff       	call   f0100f8b <cprintf>
f01183cc:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183cf:	e8 bf c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01183d4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01183d7:	74 17                	je     f01183f0 <test_kmalloc_firstfit1+0x7da>
f01183d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183e0:	83 ec 0c             	sub    $0xc,%esp
f01183e3:	68 7c ca 12 f0       	push   $0xf012ca7c
f01183e8:	e8 9e 8b fe ff       	call   f0100f8b <cprintf>
f01183ed:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f01183f0:	e8 53 68 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01183f5:	89 c2                	mov    %eax,%edx
f01183f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01183fa:	29 d0                	sub    %edx,%eax
f01183fc:	83 f8 3f             	cmp    $0x3f,%eax
f01183ff:	7f 17                	jg     f0118418 <test_kmalloc_firstfit1+0x802>
f0118401:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118408:	83 ec 0c             	sub    $0xc,%esp
f011840b:	68 e8 ca 12 f0       	push   $0xf012cae8
f0118410:	e8 76 8b fe ff       	call   f0100f8b <cprintf>
f0118415:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118418:	e8 2b 68 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011841d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118420:	e8 6e c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118425:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0118428:	83 ec 0c             	sub    $0xc,%esp
f011842b:	68 00 00 20 00       	push   $0x200000
f0118430:	e8 9a 13 ff ff       	call   f01097cf <kmalloc>
f0118435:	83 c4 10             	add    $0x10,%esp
f0118438:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f011843b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011843e:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0118443:	74 17                	je     f011845c <test_kmalloc_firstfit1+0x846>
f0118445:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011844c:	83 ec 0c             	sub    $0xc,%esp
f011844f:	68 00 cb 12 f0       	push   $0xf012cb00
f0118454:	e8 32 8b fe ff       	call   f0100f8b <cprintf>
f0118459:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f011845c:	e8 e7 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118461:	89 c2                	mov    %eax,%edx
f0118463:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118466:	29 d0                	sub    %edx,%eax
f0118468:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011846d:	7f 17                	jg     f0118486 <test_kmalloc_firstfit1+0x870>
f011846f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118476:	83 ec 0c             	sub    $0xc,%esp
f0118479:	68 34 cb 12 f0       	push   $0xf012cb34
f011847e:	e8 08 8b fe ff       	call   f0100f8b <cprintf>
f0118483:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118486:	e8 08 c6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011848b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011848e:	74 17                	je     f01184a7 <test_kmalloc_firstfit1+0x891>
f0118490:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118497:	83 ec 0c             	sub    $0xc,%esp
f011849a:	68 4c cb 12 f0       	push   $0xf012cb4c
f011849f:	e8 e7 8a fe ff       	call   f0100f8b <cprintf>
f01184a4:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f01184a7:	e8 9c 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01184ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184af:	e8 df c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01184b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f01184b7:	83 ec 0c             	sub    $0xc,%esp
f01184ba:	68 00 fc 3f 00       	push   $0x3ffc00
f01184bf:	e8 0b 13 ff ff       	call   f01097cf <kmalloc>
f01184c4:	83 c4 10             	add    $0x10,%esp
f01184c7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f01184ca:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01184cd:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f01184d2:	74 17                	je     f01184eb <test_kmalloc_firstfit1+0x8d5>
f01184d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184db:	83 ec 0c             	sub    $0xc,%esp
f01184de:	68 b8 cb 12 f0       	push   $0xf012cbb8
f01184e3:	e8 a3 8a fe ff       	call   f0100f8b <cprintf>
f01184e8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184eb:	e8 a3 c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01184f0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184f3:	74 17                	je     f011850c <test_kmalloc_firstfit1+0x8f6>
f01184f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184fc:	83 ec 0c             	sub    $0xc,%esp
f01184ff:	68 ec cb 12 f0       	push   $0xf012cbec
f0118504:	e8 82 8a fe ff       	call   f0100f8b <cprintf>
f0118509:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f011850c:	e8 37 67 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118511:	89 c2                	mov    %eax,%edx
f0118513:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118516:	29 d0                	sub    %edx,%eax
f0118518:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f011851d:	7f 17                	jg     f0118536 <test_kmalloc_firstfit1+0x920>
f011851f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118526:	83 ec 0c             	sub    $0xc,%esp
f0118529:	68 58 cc 12 f0       	push   $0xf012cc58
f011852e:	e8 58 8a fe ff       	call   f0100f8b <cprintf>
f0118533:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0118536:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011853a:	74 04                	je     f0118540 <test_kmalloc_firstfit1+0x92a>
f011853c:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0118540:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0118547:	83 ec 0c             	sub    $0xc,%esp
f011854a:	68 70 cc 12 f0       	push   $0xf012cc70
f011854f:	e8 37 8a fe ff       	call   f0100f8b <cprintf>
f0118554:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118557:	e8 ec 66 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011855c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011855f:	e8 2f c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118564:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0118567:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011856a:	83 ec 0c             	sub    $0xc,%esp
f011856d:	50                   	push   %eax
f011856e:	e8 1c 15 ff ff       	call   f0109a8f <kfree>
f0118573:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118576:	e8 18 c5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011857b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011857e:	74 17                	je     f0118597 <test_kmalloc_firstfit1+0x981>
f0118580:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118587:	83 ec 0c             	sub    $0xc,%esp
f011858a:	68 30 c2 12 f0       	push   $0xf012c230
f011858f:	e8 f7 89 fe ff       	call   f0100f8b <cprintf>
f0118594:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0118597:	e8 ac 66 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011859c:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011859f:	3d ff 00 00 00       	cmp    $0xff,%eax
f01185a4:	7f 17                	jg     f01185bd <test_kmalloc_firstfit1+0x9a7>
f01185a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185ad:	83 ec 0c             	sub    $0xc,%esp
f01185b0:	68 a4 cc 12 f0       	push   $0xf012cca4
f01185b5:	e8 d1 89 fe ff       	call   f0100f8b <cprintf>
f01185ba:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f01185bd:	e8 86 66 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01185c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01185c5:	e8 c9 c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01185ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f01185cd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01185d0:	83 ec 0c             	sub    $0xc,%esp
f01185d3:	50                   	push   %eax
f01185d4:	e8 b6 14 ff ff       	call   f0109a8f <kfree>
f01185d9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185dc:	e8 b2 c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01185e1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185e4:	74 17                	je     f01185fd <test_kmalloc_firstfit1+0x9e7>
f01185e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185ed:	83 ec 0c             	sub    $0xc,%esp
f01185f0:	68 f8 c2 12 f0       	push   $0xf012c2f8
f01185f5:	e8 91 89 fe ff       	call   f0100f8b <cprintf>
f01185fa:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f01185fd:	e8 46 66 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118602:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118605:	3d ff 00 00 00       	cmp    $0xff,%eax
f011860a:	7f 17                	jg     f0118623 <test_kmalloc_firstfit1+0xa0d>
f011860c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118613:	83 ec 0c             	sub    $0xc,%esp
f0118616:	68 b5 cc 12 f0       	push   $0xf012ccb5
f011861b:	e8 6b 89 fe ff       	call   f0100f8b <cprintf>
f0118620:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118623:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118627:	74 04                	je     f011862d <test_kmalloc_firstfit1+0xa17>
f0118629:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011862d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0118634:	83 ec 0c             	sub    $0xc,%esp
f0118637:	68 c8 cc 12 f0       	push   $0xf012ccc8
f011863c:	e8 4a 89 fe ff       	call   f0100f8b <cprintf>
f0118641:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0118644:	e8 ff 65 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118649:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011864c:	e8 42 c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118651:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0118654:	83 ec 0c             	sub    $0xc,%esp
f0118657:	68 00 00 10 00       	push   $0x100000
f011865c:	e8 6e 11 ff ff       	call   f01097cf <kmalloc>
f0118661:	83 c4 10             	add    $0x10,%esp
f0118664:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118667:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011866a:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f011866f:	74 17                	je     f0118688 <test_kmalloc_firstfit1+0xa72>
f0118671:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118678:	83 ec 0c             	sub    $0xc,%esp
f011867b:	68 08 cd 12 f0       	push   $0xf012cd08
f0118680:	e8 06 89 fe ff       	call   f0100f8b <cprintf>
f0118685:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118688:	e8 06 c4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011868d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118690:	74 17                	je     f01186a9 <test_kmalloc_firstfit1+0xa93>
f0118692:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118699:	83 ec 0c             	sub    $0xc,%esp
f011869c:	68 3c cd 12 f0       	push   $0xf012cd3c
f01186a1:	e8 e5 88 fe ff       	call   f0100f8b <cprintf>
f01186a6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f01186a9:	e8 9a 65 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01186ae:	89 c2                	mov    %eax,%edx
f01186b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01186b3:	29 d0                	sub    %edx,%eax
f01186b5:	3d ff 00 00 00       	cmp    $0xff,%eax
f01186ba:	7f 17                	jg     f01186d3 <test_kmalloc_firstfit1+0xabd>
f01186bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186c3:	83 ec 0c             	sub    $0xc,%esp
f01186c6:	68 a8 cd 12 f0       	push   $0xf012cda8
f01186cb:	e8 bb 88 fe ff       	call   f0100f8b <cprintf>
f01186d0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f01186d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01186d7:	74 04                	je     f01186dd <test_kmalloc_firstfit1+0xac7>
f01186d9:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f01186dd:	83 ec 08             	sub    $0x8,%esp
f01186e0:	ff 75 f4             	pushl  -0xc(%ebp)
f01186e3:	68 c0 cd 12 f0       	push   $0xf012cdc0
f01186e8:	e8 9e 88 fe ff       	call   f0100f8b <cprintf>
f01186ed:	83 c4 10             	add    $0x10,%esp

	return 1;
f01186f0:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01186f5:	8b 7d fc             	mov    -0x4(%ebp),%edi
f01186f8:	c9                   	leave  
f01186f9:	c3                   	ret    

f01186fa <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f01186fa:	55                   	push   %ebp
f01186fb:	89 e5                	mov    %esp,%ebp
f01186fd:	57                   	push   %edi
f01186fe:	53                   	push   %ebx
f01186ff:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118702:	83 ec 0c             	sub    $0xc,%esp
f0118705:	68 a8 b5 12 f0       	push   $0xf012b5a8
f011870a:	e8 7c 88 fe ff       	call   f0100f8b <cprintf>
f011870f:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118712:	83 ec 0c             	sub    $0xc,%esp
f0118715:	68 d8 b5 12 f0       	push   $0xf012b5d8
f011871a:	e8 6c 88 fe ff       	call   f0100f8b <cprintf>
f011871f:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118722:	83 ec 0c             	sub    $0xc,%esp
f0118725:	68 a8 b5 12 f0       	push   $0xf012b5a8
f011872a:	e8 5c 88 fe ff       	call   f0100f8b <cprintf>
f011872f:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0118732:	8d 55 98             	lea    -0x68(%ebp),%edx
f0118735:	b9 14 00 00 00       	mov    $0x14,%ecx
f011873a:	b8 00 00 00 00       	mov    $0x0,%eax
f011873f:	89 d7                	mov    %edx,%edi
f0118741:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0118743:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011874a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0118751:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0118758:	83 ec 0c             	sub    $0xc,%esp
f011875b:	68 f8 cd 12 f0       	push   $0xf012cdf8
f0118760:	e8 26 88 fe ff       	call   f0100f8b <cprintf>
f0118765:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0118768:	83 ec 0c             	sub    $0xc,%esp
f011876b:	68 01 e0 ff 07       	push   $0x7ffe001
f0118770:	e8 5a 10 ff ff       	call   f01097cf <kmalloc>
f0118775:	83 c4 10             	add    $0x10,%esp
f0118778:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f011877b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011877e:	85 c0                	test   %eax,%eax
f0118780:	74 17                	je     f0118799 <test_kmalloc_firstfit2+0x9f>
f0118782:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118789:	83 ec 0c             	sub    $0xc,%esp
f011878c:	68 2c ce 12 f0       	push   $0xf012ce2c
f0118791:	e8 f5 87 fe ff       	call   f0100f8b <cprintf>
f0118796:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118799:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011879d:	74 04                	je     f01187a3 <test_kmalloc_firstfit2+0xa9>
f011879f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01187a3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f01187aa:	83 ec 0c             	sub    $0xc,%esp
f01187ad:	68 74 ce 12 f0       	push   $0xf012ce74
f01187b2:	e8 d4 87 fe ff       	call   f0100f8b <cprintf>
f01187b7:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01187ba:	e8 89 64 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01187bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187c2:	e8 cc c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01187c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f01187ca:	83 ec 0c             	sub    $0xc,%esp
f01187cd:	68 00 fc 1f 00       	push   $0x1ffc00
f01187d2:	e8 f8 0f ff ff       	call   f01097cf <kmalloc>
f01187d7:	83 c4 10             	add    $0x10,%esp
f01187da:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f01187dd:	8b 45 98             	mov    -0x68(%ebp),%eax
f01187e0:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01187e5:	74 17                	je     f01187fe <test_kmalloc_firstfit2+0x104>
f01187e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187ee:	83 ec 0c             	sub    $0xc,%esp
f01187f1:	68 f4 c4 12 f0       	push   $0xf012c4f4
f01187f6:	e8 90 87 fe ff       	call   f0100f8b <cprintf>
f01187fb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187fe:	e8 90 c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118803:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118806:	74 17                	je     f011881f <test_kmalloc_firstfit2+0x125>
f0118808:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011880f:	83 ec 0c             	sub    $0xc,%esp
f0118812:	68 d0 b8 12 f0       	push   $0xf012b8d0
f0118817:	e8 6f 87 fe ff       	call   f0100f8b <cprintf>
f011881c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f011881f:	e8 24 64 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118824:	89 c2                	mov    %eax,%edx
f0118826:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118829:	29 d0                	sub    %edx,%eax
f011882b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118830:	7f 17                	jg     f0118849 <test_kmalloc_firstfit2+0x14f>
f0118832:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118839:	83 ec 0c             	sub    $0xc,%esp
f011883c:	68 27 c5 12 f0       	push   $0xf012c527
f0118841:	e8 45 87 fe ff       	call   f0100f8b <cprintf>
f0118846:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118849:	e8 fa 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011884e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118851:	e8 3d c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118856:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0118859:	83 ec 0c             	sub    $0xc,%esp
f011885c:	68 00 fc 1f 00       	push   $0x1ffc00
f0118861:	e8 69 0f ff ff       	call   f01097cf <kmalloc>
f0118866:	83 c4 10             	add    $0x10,%esp
f0118869:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f011886c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011886f:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118874:	74 17                	je     f011888d <test_kmalloc_firstfit2+0x193>
f0118876:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011887d:	83 ec 0c             	sub    $0xc,%esp
f0118880:	68 40 c5 12 f0       	push   $0xf012c540
f0118885:	e8 01 87 fe ff       	call   f0100f8b <cprintf>
f011888a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011888d:	e8 01 c2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118892:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118895:	74 17                	je     f01188ae <test_kmalloc_firstfit2+0x1b4>
f0118897:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011889e:	83 ec 0c             	sub    $0xc,%esp
f01188a1:	68 0c ba 12 f0       	push   $0xf012ba0c
f01188a6:	e8 e0 86 fe ff       	call   f0100f8b <cprintf>
f01188ab:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01188ae:	e8 95 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01188b3:	89 c2                	mov    %eax,%edx
f01188b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01188b8:	29 d0                	sub    %edx,%eax
f01188ba:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01188bf:	7f 17                	jg     f01188d8 <test_kmalloc_firstfit2+0x1de>
f01188c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188c8:	83 ec 0c             	sub    $0xc,%esp
f01188cb:	68 73 c5 12 f0       	push   $0xf012c573
f01188d0:	e8 b6 86 fe ff       	call   f0100f8b <cprintf>
f01188d5:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01188d8:	e8 6b 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01188dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01188e0:	e8 ae c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01188e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f01188e8:	83 ec 0c             	sub    $0xc,%esp
f01188eb:	68 00 1c 00 00       	push   $0x1c00
f01188f0:	e8 da 0e ff ff       	call   f01097cf <kmalloc>
f01188f5:	83 c4 10             	add    $0x10,%esp
f01188f8:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01188fb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01188fe:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118903:	74 17                	je     f011891c <test_kmalloc_firstfit2+0x222>
f0118905:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011890c:	83 ec 0c             	sub    $0xc,%esp
f011890f:	68 8c c5 12 f0       	push   $0xf012c58c
f0118914:	e8 72 86 fe ff       	call   f0100f8b <cprintf>
f0118919:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011891c:	e8 72 c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118921:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118924:	74 17                	je     f011893d <test_kmalloc_firstfit2+0x243>
f0118926:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011892d:	83 ec 0c             	sub    $0xc,%esp
f0118930:	68 04 bb 12 f0       	push   $0xf012bb04
f0118935:	e8 51 86 fe ff       	call   f0100f8b <cprintf>
f011893a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f011893d:	e8 06 63 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118942:	89 c2                	mov    %eax,%edx
f0118944:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118947:	29 d0                	sub    %edx,%eax
f0118949:	83 f8 01             	cmp    $0x1,%eax
f011894c:	7f 17                	jg     f0118965 <test_kmalloc_firstfit2+0x26b>
f011894e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118955:	83 ec 0c             	sub    $0xc,%esp
f0118958:	68 bf c5 12 f0       	push   $0xf012c5bf
f011895d:	e8 29 86 fe ff       	call   f0100f8b <cprintf>
f0118962:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118965:	e8 de 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011896a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011896d:	e8 21 c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118972:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0118975:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118978:	83 ec 0c             	sub    $0xc,%esp
f011897b:	50                   	push   %eax
f011897c:	e8 0e 11 ff ff       	call   f0109a8f <kfree>
f0118981:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118984:	e8 0a c1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118989:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011898c:	74 17                	je     f01189a5 <test_kmalloc_firstfit2+0x2ab>
f011898e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118995:	83 ec 0c             	sub    $0xc,%esp
f0118998:	68 e4 bb 12 f0       	push   $0xf012bbe4
f011899d:	e8 e9 85 fe ff       	call   f0100f8b <cprintf>
f01189a2:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f01189a5:	e8 9e 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01189aa:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01189ad:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01189b2:	7f 17                	jg     f01189cb <test_kmalloc_firstfit2+0x2d1>
f01189b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189bb:	83 ec 0c             	sub    $0xc,%esp
f01189be:	68 ba ce 12 f0       	push   $0xf012ceba
f01189c3:	e8 c3 85 fe ff       	call   f0100f8b <cprintf>
f01189c8:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01189cb:	e8 78 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01189d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01189d3:	e8 bb c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01189d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f01189db:	83 ec 0c             	sub    $0xc,%esp
f01189de:	68 00 fc 2f 00       	push   $0x2ffc00
f01189e3:	e8 e7 0d ff ff       	call   f01097cf <kmalloc>
f01189e8:	83 c4 10             	add    $0x10,%esp
f01189eb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f01189ee:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01189f1:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01189f6:	74 17                	je     f0118a0f <test_kmalloc_firstfit2+0x315>
f01189f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189ff:	83 ec 0c             	sub    $0xc,%esp
f0118a02:	68 24 c6 12 f0       	push   $0xf012c624
f0118a07:	e8 7f 85 fe ff       	call   f0100f8b <cprintf>
f0118a0c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a0f:	e8 7f c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118a14:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a17:	74 17                	je     f0118a30 <test_kmalloc_firstfit2+0x336>
f0118a19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a20:	83 ec 0c             	sub    $0xc,%esp
f0118a23:	68 e8 bc 12 f0       	push   $0xf012bce8
f0118a28:	e8 5e 85 fe ff       	call   f0100f8b <cprintf>
f0118a2d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0118a30:	e8 13 62 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118a35:	89 c2                	mov    %eax,%edx
f0118a37:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a3a:	29 d0                	sub    %edx,%eax
f0118a3c:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118a41:	7f 17                	jg     f0118a5a <test_kmalloc_firstfit2+0x360>
f0118a43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a4a:	83 ec 0c             	sub    $0xc,%esp
f0118a4d:	68 57 c6 12 f0       	push   $0xf012c657
f0118a52:	e8 34 85 fe ff       	call   f0100f8b <cprintf>
f0118a57:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118a5a:	e8 e9 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118a5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a62:	e8 2c c0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118a67:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0118a6a:	83 ec 0c             	sub    $0xc,%esp
f0118a6d:	68 00 18 20 00       	push   $0x201800
f0118a72:	e8 58 0d ff ff       	call   f01097cf <kmalloc>
f0118a77:	83 c4 10             	add    $0x10,%esp
f0118a7a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0118a7d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118a80:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0118a85:	74 17                	je     f0118a9e <test_kmalloc_firstfit2+0x3a4>
f0118a87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a8e:	83 ec 0c             	sub    $0xc,%esp
f0118a91:	68 70 c6 12 f0       	push   $0xf012c670
f0118a96:	e8 f0 84 fe ff       	call   f0100f8b <cprintf>
f0118a9b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a9e:	e8 f0 bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118aa3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118aa6:	74 17                	je     f0118abf <test_kmalloc_firstfit2+0x3c5>
f0118aa8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aaf:	83 ec 0c             	sub    $0xc,%esp
f0118ab2:	68 ec bd 12 f0       	push   $0xf012bdec
f0118ab7:	e8 cf 84 fe ff       	call   f0100f8b <cprintf>
f0118abc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0118abf:	e8 84 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118ac4:	89 c2                	mov    %eax,%edx
f0118ac6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118ac9:	29 d0                	sub    %edx,%eax
f0118acb:	3d 01 02 00 00       	cmp    $0x201,%eax
f0118ad0:	7f 17                	jg     f0118ae9 <test_kmalloc_firstfit2+0x3ef>
f0118ad2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ad9:	83 ec 0c             	sub    $0xc,%esp
f0118adc:	68 a3 c6 12 f0       	push   $0xf012c6a3
f0118ae1:	e8 a5 84 fe ff       	call   f0100f8b <cprintf>
f0118ae6:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ae9:	e8 5a 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118aee:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118af1:	e8 9d bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118af6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0118af9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118afc:	83 ec 0c             	sub    $0xc,%esp
f0118aff:	50                   	push   %eax
f0118b00:	e8 8a 0f ff ff       	call   f0109a8f <kfree>
f0118b05:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b08:	e8 86 bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118b0d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b10:	74 17                	je     f0118b29 <test_kmalloc_firstfit2+0x42f>
f0118b12:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b19:	83 ec 0c             	sub    $0xc,%esp
f0118b1c:	68 f0 be 12 f0       	push   $0xf012bef0
f0118b21:	e8 65 84 fe ff       	call   f0100f8b <cprintf>
f0118b26:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f0118b29:	e8 1a 61 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118b2e:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118b31:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118b36:	7f 17                	jg     f0118b4f <test_kmalloc_firstfit2+0x455>
f0118b38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b3f:	83 ec 0c             	sub    $0xc,%esp
f0118b42:	68 ca ce 12 f0       	push   $0xf012ceca
f0118b47:	e8 3f 84 fe ff       	call   f0100f8b <cprintf>
f0118b4c:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118b4f:	e8 f4 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118b54:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b57:	e8 37 bf fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118b5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0118b5f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118b62:	83 ec 0c             	sub    $0xc,%esp
f0118b65:	50                   	push   %eax
f0118b66:	e8 24 0f ff ff       	call   f0109a8f <kfree>
f0118b6b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f0118b6e:	e8 d5 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118b73:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118b76:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118b7b:	7f 17                	jg     f0118b94 <test_kmalloc_firstfit2+0x49a>
f0118b7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b84:	83 ec 0c             	sub    $0xc,%esp
f0118b87:	68 9b c7 12 f0       	push   $0xf012c79b
f0118b8c:	e8 fa 83 fe ff       	call   f0100f8b <cprintf>
f0118b91:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b94:	e8 fa be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118b99:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b9c:	74 17                	je     f0118bb5 <test_kmalloc_firstfit2+0x4bb>
f0118b9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ba5:	83 ec 0c             	sub    $0xc,%esp
f0118ba8:	68 30 c7 12 f0       	push   $0xf012c730
f0118bad:	e8 d9 83 fe ff       	call   f0100f8b <cprintf>
f0118bb2:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118bb5:	e8 8e 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118bba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118bbd:	e8 d1 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118bc2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0118bc5:	83 ec 0c             	sub    $0xc,%esp
f0118bc8:	68 00 fc 4f 00       	push   $0x4ffc00
f0118bcd:	e8 fd 0b ff ff       	call   f01097cf <kmalloc>
f0118bd2:	83 c4 10             	add    $0x10,%esp
f0118bd5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0118bd8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118bdb:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0118be0:	74 17                	je     f0118bf9 <test_kmalloc_firstfit2+0x4ff>
f0118be2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118be9:	83 ec 0c             	sub    $0xc,%esp
f0118bec:	68 dc ce 12 f0       	push   $0xf012cedc
f0118bf1:	e8 95 83 fe ff       	call   f0100f8b <cprintf>
f0118bf6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118bf9:	e8 95 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118bfe:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c01:	74 17                	je     f0118c1a <test_kmalloc_firstfit2+0x520>
f0118c03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c0a:	83 ec 0c             	sub    $0xc,%esp
f0118c0d:	68 ac c7 12 f0       	push   $0xf012c7ac
f0118c12:	e8 74 83 fe ff       	call   f0100f8b <cprintf>
f0118c17:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f0118c1a:	e8 29 60 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118c1f:	89 c2                	mov    %eax,%edx
f0118c21:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118c24:	29 d0                	sub    %edx,%eax
f0118c26:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f0118c2b:	7f 17                	jg     f0118c44 <test_kmalloc_firstfit2+0x54a>
f0118c2d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c34:	83 ec 0c             	sub    $0xc,%esp
f0118c37:	68 10 cf 12 f0       	push   $0xf012cf10
f0118c3c:	e8 4a 83 fe ff       	call   f0100f8b <cprintf>
f0118c41:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118c44:	e8 ff 5f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118c49:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c4c:	e8 42 be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118c51:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0118c54:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118c57:	83 ec 0c             	sub    $0xc,%esp
f0118c5a:	50                   	push   %eax
f0118c5b:	e8 2f 0e ff ff       	call   f0109a8f <kfree>
f0118c60:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c63:	e8 2b be fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118c68:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c6b:	74 17                	je     f0118c84 <test_kmalloc_firstfit2+0x58a>
f0118c6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c74:	83 ec 0c             	sub    $0xc,%esp
f0118c77:	68 2c c8 12 f0       	push   $0xf012c82c
f0118c7c:	e8 0a 83 fe ff       	call   f0100f8b <cprintf>
f0118c81:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f0118c84:	e8 bf 5f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118c89:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118c8c:	83 f8 01             	cmp    $0x1,%eax
f0118c8f:	7f 17                	jg     f0118ca8 <test_kmalloc_firstfit2+0x5ae>
f0118c91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c98:	83 ec 0c             	sub    $0xc,%esp
f0118c9b:	68 98 c8 12 f0       	push   $0xf012c898
f0118ca0:	e8 e6 82 fe ff       	call   f0100f8b <cprintf>
f0118ca5:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ca8:	e8 9b 5f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118cad:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118cb0:	e8 de bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118cb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0118cb8:	83 ec 0c             	sub    $0xc,%esp
f0118cbb:	68 00 04 00 00       	push   $0x400
f0118cc0:	e8 0a 0b ff ff       	call   f01097cf <kmalloc>
f0118cc5:	83 c4 10             	add    $0x10,%esp
f0118cc8:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118ccb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118cce:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118cd3:	76 22                	jbe    f0118cf7 <test_kmalloc_firstfit2+0x5fd>
f0118cd5:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0118cd8:	83 ec 0c             	sub    $0xc,%esp
f0118cdb:	6a 00                	push   $0x0
f0118cdd:	e8 ba 09 ff ff       	call   f010969c <sbrk>
f0118ce2:	83 c4 10             	add    $0x10,%esp
f0118ce5:	39 c3                	cmp    %eax,%ebx
f0118ce7:	73 0e                	jae    f0118cf7 <test_kmalloc_firstfit2+0x5fd>
f0118ce9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118cec:	89 c2                	mov    %eax,%edx
f0118cee:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118cf3:	39 c2                	cmp    %eax,%edx
f0118cf5:	72 17                	jb     f0118d0e <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118cf7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cfe:	83 ec 0c             	sub    $0xc,%esp
f0118d01:	68 28 cf 12 f0       	push   $0xf012cf28
f0118d06:	e8 80 82 fe ff       	call   f0100f8b <cprintf>
f0118d0b:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d0e:	e8 80 bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118d13:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d16:	74 17                	je     f0118d2f <test_kmalloc_firstfit2+0x635>
f0118d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d1f:	83 ec 0c             	sub    $0xc,%esp
f0118d22:	68 0c c9 12 f0       	push   $0xf012c90c
f0118d27:	e8 5f 82 fe ff       	call   f0100f8b <cprintf>
f0118d2c:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118d2f:	e8 5f bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118d34:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0118d37:	83 ec 0c             	sub    $0xc,%esp
f0118d3a:	68 00 08 00 00       	push   $0x800
f0118d3f:	e8 8b 0a ff ff       	call   f01097cf <kmalloc>
f0118d44:	83 c4 10             	add    $0x10,%esp
f0118d47:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118d4a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118d4d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118d52:	76 22                	jbe    f0118d76 <test_kmalloc_firstfit2+0x67c>
f0118d54:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118d57:	83 ec 0c             	sub    $0xc,%esp
f0118d5a:	6a 00                	push   $0x0
f0118d5c:	e8 3b 09 ff ff       	call   f010969c <sbrk>
f0118d61:	83 c4 10             	add    $0x10,%esp
f0118d64:	39 c3                	cmp    %eax,%ebx
f0118d66:	73 0e                	jae    f0118d76 <test_kmalloc_firstfit2+0x67c>
f0118d68:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118d6b:	89 c2                	mov    %eax,%edx
f0118d6d:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118d72:	39 c2                	cmp    %eax,%edx
f0118d74:	72 17                	jb     f0118d8d <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118d76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d7d:	83 ec 0c             	sub    $0xc,%esp
f0118d80:	68 b4 cf 12 f0       	push   $0xf012cfb4
f0118d85:	e8 01 82 fe ff       	call   f0100f8b <cprintf>
f0118d8a:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d8d:	e8 01 bd fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118d92:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d95:	74 17                	je     f0118dae <test_kmalloc_firstfit2+0x6b4>
f0118d97:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d9e:	83 ec 0c             	sub    $0xc,%esp
f0118da1:	68 c4 c9 12 f0       	push   $0xf012c9c4
f0118da6:	e8 e0 81 fe ff       	call   f0100f8b <cprintf>
f0118dab:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118dae:	e8 e0 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118db3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0118db6:	83 ec 0c             	sub    $0xc,%esp
f0118db9:	68 00 04 00 00       	push   $0x400
f0118dbe:	e8 0c 0a ff ff       	call   f01097cf <kmalloc>
f0118dc3:	83 c4 10             	add    $0x10,%esp
f0118dc6:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118dc9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118dcc:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118dd1:	76 22                	jbe    f0118df5 <test_kmalloc_firstfit2+0x6fb>
f0118dd3:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0118dd6:	83 ec 0c             	sub    $0xc,%esp
f0118dd9:	6a 00                	push   $0x0
f0118ddb:	e8 bc 08 ff ff       	call   f010969c <sbrk>
f0118de0:	83 c4 10             	add    $0x10,%esp
f0118de3:	39 c3                	cmp    %eax,%ebx
f0118de5:	73 0e                	jae    f0118df5 <test_kmalloc_firstfit2+0x6fb>
f0118de7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118dea:	89 c2                	mov    %eax,%edx
f0118dec:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f0118df1:	39 c2                	cmp    %eax,%edx
f0118df3:	72 17                	jb     f0118e0c <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118df5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118dfc:	83 ec 0c             	sub    $0xc,%esp
f0118dff:	68 40 d0 12 f0       	push   $0xf012d040
f0118e04:	e8 82 81 fe ff       	call   f0100f8b <cprintf>
f0118e09:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e0c:	e8 82 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e11:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e14:	74 17                	je     f0118e2d <test_kmalloc_firstfit2+0x733>
f0118e16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e1d:	83 ec 0c             	sub    $0xc,%esp
f0118e20:	68 7c ca 12 f0       	push   $0xf012ca7c
f0118e25:	e8 61 81 fe ff       	call   f0100f8b <cprintf>
f0118e2a:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0118e2d:	e8 16 5e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118e32:	89 c2                	mov    %eax,%edx
f0118e34:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118e37:	29 d0                	sub    %edx,%eax
f0118e39:	83 f8 01             	cmp    $0x1,%eax
f0118e3c:	74 17                	je     f0118e55 <test_kmalloc_firstfit2+0x75b>
f0118e3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e45:	83 ec 0c             	sub    $0xc,%esp
f0118e48:	68 cc d0 12 f0       	push   $0xf012d0cc
f0118e4d:	e8 39 81 fe ff       	call   f0100f8b <cprintf>
f0118e52:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118e55:	e8 ee 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118e5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118e5d:	e8 31 bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e62:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118e65:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118e68:	83 ec 0c             	sub    $0xc,%esp
f0118e6b:	50                   	push   %eax
f0118e6c:	e8 1e 0c ff ff       	call   f0109a8f <kfree>
f0118e71:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e74:	e8 1a bc fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118e79:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e7c:	74 17                	je     f0118e95 <test_kmalloc_firstfit2+0x79b>
f0118e7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e85:	83 ec 0c             	sub    $0xc,%esp
f0118e88:	68 4c cb 12 f0       	push   $0xf012cb4c
f0118e8d:	e8 f9 80 fe ff       	call   f0100f8b <cprintf>
f0118e92:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118e95:	e8 ae 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118e9a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118e9d:	74 17                	je     f0118eb6 <test_kmalloc_firstfit2+0x7bc>
f0118e9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ea6:	83 ec 0c             	sub    $0xc,%esp
f0118ea9:	68 f0 d0 12 f0       	push   $0xf012d0f0
f0118eae:	e8 d8 80 fe ff       	call   f0100f8b <cprintf>
f0118eb3:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118eb6:	e8 8d 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118ebb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118ebe:	e8 d0 bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118ec3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118ec6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118ec9:	83 ec 0c             	sub    $0xc,%esp
f0118ecc:	50                   	push   %eax
f0118ecd:	e8 bd 0b ff ff       	call   f0109a8f <kfree>
f0118ed2:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ed5:	e8 b9 bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118eda:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118edd:	74 17                	je     f0118ef6 <test_kmalloc_firstfit2+0x7fc>
f0118edf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ee6:	83 ec 0c             	sub    $0xc,%esp
f0118ee9:	68 ec cb 12 f0       	push   $0xf012cbec
f0118eee:	e8 98 80 fe ff       	call   f0100f8b <cprintf>
f0118ef3:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118ef6:	e8 4d 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118efb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118efe:	74 17                	je     f0118f17 <test_kmalloc_firstfit2+0x81d>
f0118f00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f07:	83 ec 0c             	sub    $0xc,%esp
f0118f0a:	68 50 d1 12 f0       	push   $0xf012d150
f0118f0f:	e8 77 80 fe ff       	call   f0100f8b <cprintf>
f0118f14:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118f17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118f1b:	74 04                	je     f0118f21 <test_kmalloc_firstfit2+0x827>
f0118f1d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118f21:	83 ec 0c             	sub    $0xc,%esp
f0118f24:	68 b0 d1 12 f0       	push   $0xf012d1b0
f0118f29:	e8 5d 80 fe ff       	call   f0100f8b <cprintf>
f0118f2e:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118f31:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118f38:	e8 0b 5d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118f3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118f40:	e8 4e bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118f45:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118f48:	83 ec 0c             	sub    $0xc,%esp
f0118f4b:	68 00 08 00 00       	push   $0x800
f0118f50:	e8 7a 08 ff ff       	call   f01097cf <kmalloc>
f0118f55:	83 c4 10             	add    $0x10,%esp
f0118f58:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118f5b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118f5e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118f61:	39 c2                	cmp    %eax,%edx
f0118f63:	74 17                	je     f0118f7c <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118f65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f6c:	83 ec 0c             	sub    $0xc,%esp
f0118f6f:	68 e8 d1 12 f0       	push   $0xf012d1e8
f0118f74:	e8 12 80 fe ff       	call   f0100f8b <cprintf>
f0118f79:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f7c:	e8 12 bb fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118f81:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f84:	74 17                	je     f0118f9d <test_kmalloc_firstfit2+0x8a3>
f0118f86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f8d:	83 ec 0c             	sub    $0xc,%esp
f0118f90:	68 30 c2 12 f0       	push   $0xf012c230
f0118f95:	e8 f1 7f fe ff       	call   f0100f8b <cprintf>
f0118f9a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118f9d:	e8 a6 5c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118fa2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118fa5:	74 17                	je     f0118fbe <test_kmalloc_firstfit2+0x8c4>
f0118fa7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fae:	83 ec 0c             	sub    $0xc,%esp
f0118fb1:	68 1c d2 12 f0       	push   $0xf012d21c
f0118fb6:	e8 d0 7f fe ff       	call   f0100f8b <cprintf>
f0118fbb:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118fbe:	e8 85 5c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0118fc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118fc6:	e8 c8 ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0118fcb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118fce:	83 ec 0c             	sub    $0xc,%esp
f0118fd1:	68 00 04 00 00       	push   $0x400
f0118fd6:	e8 f4 07 ff ff       	call   f01097cf <kmalloc>
f0118fdb:	83 c4 10             	add    $0x10,%esp
f0118fde:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118fe1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118fe4:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118fe7:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118fed:	39 d0                	cmp    %edx,%eax
f0118fef:	74 17                	je     f0119008 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118ff1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ff8:	83 ec 0c             	sub    $0xc,%esp
f0118ffb:	68 34 d2 12 f0       	push   $0xf012d234
f0119000:	e8 86 7f fe ff       	call   f0100f8b <cprintf>
f0119005:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119008:	e8 86 ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011900d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119010:	74 17                	je     f0119029 <test_kmalloc_firstfit2+0x92f>
f0119012:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119019:	83 ec 0c             	sub    $0xc,%esp
f011901c:	68 f8 c2 12 f0       	push   $0xf012c2f8
f0119021:	e8 65 7f fe ff       	call   f0100f8b <cprintf>
f0119026:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0119029:	e8 1a 5c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011902e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119031:	74 17                	je     f011904a <test_kmalloc_firstfit2+0x950>
f0119033:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011903a:	83 ec 0c             	sub    $0xc,%esp
f011903d:	68 68 d2 12 f0       	push   $0xf012d268
f0119042:	e8 44 7f fe ff       	call   f0100f8b <cprintf>
f0119047:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f011904a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011904e:	74 04                	je     f0119054 <test_kmalloc_firstfit2+0x95a>
f0119050:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0119054:	83 ec 0c             	sub    $0xc,%esp
f0119057:	68 80 d2 12 f0       	push   $0xf012d280
f011905c:	e8 2a 7f fe ff       	call   f0100f8b <cprintf>
f0119061:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0119064:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011906b:	e8 d8 5b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119070:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119073:	e8 1b ba fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119078:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f011907b:	83 ec 0c             	sub    $0xc,%esp
f011907e:	68 00 04 70 00       	push   $0x700400
f0119083:	e8 47 07 ff ff       	call   f01097cf <kmalloc>
f0119088:	83 c4 10             	add    $0x10,%esp
f011908b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f011908e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119091:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119096:	74 17                	je     f01190af <test_kmalloc_firstfit2+0x9b5>
f0119098:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011909f:	83 ec 0c             	sub    $0xc,%esp
f01190a2:	68 08 cd 12 f0       	push   $0xf012cd08
f01190a7:	e8 df 7e fe ff       	call   f0100f8b <cprintf>
f01190ac:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01190af:	e8 df b9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01190b4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01190b7:	74 17                	je     f01190d0 <test_kmalloc_firstfit2+0x9d6>
f01190b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190c0:	83 ec 0c             	sub    $0xc,%esp
f01190c3:	68 3c cd 12 f0       	push   $0xf012cd3c
f01190c8:	e8 be 7e fe ff       	call   f0100f8b <cprintf>
f01190cd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f01190d0:	e8 73 5b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01190d5:	89 c2                	mov    %eax,%edx
f01190d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01190da:	29 d0                	sub    %edx,%eax
f01190dc:	3d 00 07 00 00       	cmp    $0x700,%eax
f01190e1:	7f 17                	jg     f01190fa <test_kmalloc_firstfit2+0xa00>
f01190e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190ea:	83 ec 0c             	sub    $0xc,%esp
f01190ed:	68 a8 cd 12 f0       	push   $0xf012cda8
f01190f2:	e8 94 7e fe ff       	call   f0100f8b <cprintf>
f01190f7:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01190fa:	e8 49 5b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01190ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119102:	e8 8c b9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119107:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f011910a:	83 ec 0c             	sub    $0xc,%esp
f011910d:	68 00 0c 00 00       	push   $0xc00
f0119112:	e8 b8 06 ff ff       	call   f01097cf <kmalloc>
f0119117:	83 c4 10             	add    $0x10,%esp
f011911a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f011911d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119120:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0119125:	74 17                	je     f011913e <test_kmalloc_firstfit2+0xa44>
f0119127:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011912e:	83 ec 0c             	sub    $0xc,%esp
f0119131:	68 b4 d2 12 f0       	push   $0xf012d2b4
f0119136:	e8 50 7e fe ff       	call   f0100f8b <cprintf>
f011913b:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011913e:	e8 50 b9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119143:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119146:	74 17                	je     f011915f <test_kmalloc_firstfit2+0xa65>
f0119148:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011914f:	83 ec 0c             	sub    $0xc,%esp
f0119152:	68 e8 d2 12 f0       	push   $0xf012d2e8
f0119157:	e8 2f 7e fe ff       	call   f0100f8b <cprintf>
f011915c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f011915f:	e8 e4 5a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119164:	89 c2                	mov    %eax,%edx
f0119166:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119169:	29 d0                	sub    %edx,%eax
f011916b:	85 c0                	test   %eax,%eax
f011916d:	7f 17                	jg     f0119186 <test_kmalloc_firstfit2+0xa8c>
f011916f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119176:	83 ec 0c             	sub    $0xc,%esp
f0119179:	68 54 d3 12 f0       	push   $0xf012d354
f011917e:	e8 08 7e fe ff       	call   f0100f8b <cprintf>
f0119183:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0119186:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011918a:	74 04                	je     f0119190 <test_kmalloc_firstfit2+0xa96>
f011918c:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0119190:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0119197:	83 ec 0c             	sub    $0xc,%esp
f011919a:	68 6c d3 12 f0       	push   $0xf012d36c
f011919f:	e8 e7 7d fe ff       	call   f0100f8b <cprintf>
f01191a4:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f01191a7:	83 ec 0c             	sub    $0xc,%esp
f01191aa:	68 00 e0 1f 07       	push   $0x71fe000
f01191af:	e8 1b 06 ff ff       	call   f01097cf <kmalloc>
f01191b4:	83 c4 10             	add    $0x10,%esp
f01191b7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f01191ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01191bd:	85 c0                	test   %eax,%eax
f01191bf:	74 17                	je     f01191d8 <test_kmalloc_firstfit2+0xade>
f01191c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191c8:	83 ec 0c             	sub    $0xc,%esp
f01191cb:	68 c0 d3 12 f0       	push   $0xf012d3c0
f01191d0:	e8 b6 7d fe ff       	call   f0100f8b <cprintf>
f01191d5:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f01191d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01191dc:	74 04                	je     f01191e2 <test_kmalloc_firstfit2+0xae8>
f01191de:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f01191e2:	83 ec 08             	sub    $0x8,%esp
f01191e5:	ff 75 f4             	pushl  -0xc(%ebp)
f01191e8:	68 28 d4 12 f0       	push   $0xf012d428
f01191ed:	e8 99 7d fe ff       	call   f0100f8b <cprintf>
f01191f2:	83 c4 10             	add    $0x10,%esp

	return 1;
f01191f5:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01191fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01191fd:	5b                   	pop    %ebx
f01191fe:	5f                   	pop    %edi
f01191ff:	5d                   	pop    %ebp
f0119200:	c3                   	ret    

f0119201 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0119201:	55                   	push   %ebp
f0119202:	89 e5                	mov    %esp,%ebp
f0119204:	53                   	push   %ebx
f0119205:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119208:	83 ec 0c             	sub    $0xc,%esp
f011920b:	68 a8 b5 12 f0       	push   $0xf012b5a8
f0119210:	e8 76 7d fe ff       	call   f0100f8b <cprintf>
f0119215:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119218:	83 ec 0c             	sub    $0xc,%esp
f011921b:	68 d8 b5 12 f0       	push   $0xf012b5d8
f0119220:	e8 66 7d fe ff       	call   f0100f8b <cprintf>
f0119225:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119228:	83 ec 0c             	sub    $0xc,%esp
f011922b:	68 a8 b5 12 f0       	push   $0xf012b5a8
f0119230:	e8 56 7d fe ff       	call   f0100f8b <cprintf>
f0119235:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0119238:	e8 0b 5a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011923d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0119240:	e8 4e b8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119245:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0119248:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f011924f:	83 ec 0c             	sub    $0xc,%esp
f0119252:	68 5d d4 12 f0       	push   $0xf012d45d
f0119257:	e8 2f 7d fe ff       	call   f0100f8b <cprintf>
f011925c:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f011925f:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0119264:	ba 00 00 00 00       	mov    $0x0,%edx
f0119269:	f7 75 e4             	divl   -0x1c(%ebp)
f011926c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f011926f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119276:	eb 1d                	jmp    f0119295 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0119278:	83 ec 0c             	sub    $0xc,%esp
f011927b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011927e:	e8 4c 05 ff ff       	call   f01097cf <kmalloc>
f0119283:	83 c4 10             	add    $0x10,%esp
f0119286:	89 c2                	mov    %eax,%edx
f0119288:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011928b:	89 14 85 c0 4f 73 f0 	mov    %edx,-0xf8cb040(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0119292:	ff 45 f4             	incl   -0xc(%ebp)
f0119295:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119298:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011929b:	7c db                	jl     f0119278 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f011929d:	83 ec 0c             	sub    $0xc,%esp
f01192a0:	68 61 d4 12 f0       	push   $0xf012d461
f01192a5:	e8 e1 7c fe ff       	call   f0100f8b <cprintf>
f01192aa:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f01192ad:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f01192b2:	ba 00 00 00 00       	mov    $0x0,%edx
f01192b7:	f7 75 e4             	divl   -0x1c(%ebp)
f01192ba:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f01192bd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01192c1:	74 1e                	je     f01192e1 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f01192c3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f01192c6:	8d 43 01             	lea    0x1(%ebx),%eax
f01192c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01192cc:	83 ec 0c             	sub    $0xc,%esp
f01192cf:	ff 75 e0             	pushl  -0x20(%ebp)
f01192d2:	e8 f8 04 ff ff       	call   f01097cf <kmalloc>
f01192d7:	83 c4 10             	add    $0x10,%esp
f01192da:	89 04 9d c0 4f 73 f0 	mov    %eax,-0xf8cb040(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f01192e1:	83 ec 04             	sub    $0x4,%esp
f01192e4:	ff 75 f0             	pushl  -0x10(%ebp)
f01192e7:	ff 75 e4             	pushl  -0x1c(%ebp)
f01192ea:	68 68 d4 12 f0       	push   $0xf012d468
f01192ef:	e8 97 7c fe ff       	call   f0100f8b <cprintf>
f01192f4:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f01192f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01192fe:	eb 36                	jmp    f0119336 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0119300:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119303:	8b 04 85 c0 4f 73 f0 	mov    -0xf8cb040(,%eax,4),%eax
f011930a:	89 c2                	mov    %eax,%edx
f011930c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011930f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119313:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0119318:	39 c2                	cmp    %eax,%edx
f011931a:	74 17                	je     f0119333 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f011931c:	83 ec 04             	sub    $0x4,%esp
f011931f:	68 b0 d4 12 f0       	push   $0xf012d4b0
f0119324:	68 e3 02 00 00       	push   $0x2e3
f0119329:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011932e:	e8 06 70 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0119333:	ff 45 f4             	incl   -0xc(%ebp)
f0119336:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119339:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011933c:	7c c2                	jl     f0119300 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011933e:	e8 50 b7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119343:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119346:	74 17                	je     f011935f <test_fastfirstfit+0x15e>
f0119348:	83 ec 04             	sub    $0x4,%esp
f011934b:	68 0c d5 12 f0       	push   $0xf012d50c
f0119350:	68 e6 02 00 00       	push   $0x2e6
f0119355:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011935a:	e8 da 6f fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f011935f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119362:	e8 e1 58 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119367:	29 c3                	sub    %eax,%ebx
f0119369:	89 d8                	mov    %ebx,%eax
f011936b:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0119370:	77 17                	ja     f0119389 <test_fastfirstfit+0x188>
f0119372:	83 ec 04             	sub    $0x4,%esp
f0119375:	68 74 d5 12 f0       	push   $0xf012d574
f011937a:	68 e7 02 00 00       	push   $0x2e7
f011937f:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119384:	e8 b0 6f fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0119389:	e8 05 b7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011938e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0119391:	e8 b2 58 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119396:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0119399:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f011939d:	7f 17                	jg     f01193b6 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f011939f:	83 ec 04             	sub    $0x4,%esp
f01193a2:	68 88 d5 12 f0       	push   $0xf012d588
f01193a7:	68 ee 02 00 00       	push   $0x2ee
f01193ac:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01193b1:	e8 83 6f fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f01193b6:	a1 c0 4f 73 f0       	mov    0xf0734fc0,%eax
f01193bb:	83 ec 0c             	sub    $0xc,%esp
f01193be:	50                   	push   %eax
f01193bf:	e8 cb 06 ff ff       	call   f0109a8f <kfree>
f01193c4:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f01193c7:	a1 c8 4f 73 f0       	mov    0xf0734fc8,%eax
f01193cc:	83 ec 0c             	sub    $0xc,%esp
f01193cf:	50                   	push   %eax
f01193d0:	e8 ba 06 ff ff       	call   f0109a8f <kfree>
f01193d5:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f01193d8:	a1 cc 4f 73 f0       	mov    0xf0734fcc,%eax
f01193dd:	83 ec 0c             	sub    $0xc,%esp
f01193e0:	50                   	push   %eax
f01193e1:	e8 a9 06 ff ff       	call   f0109a8f <kfree>
f01193e6:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f01193e9:	a1 d4 4f 73 f0       	mov    0xf0734fd4,%eax
f01193ee:	83 ec 0c             	sub    $0xc,%esp
f01193f1:	50                   	push   %eax
f01193f2:	e8 98 06 ff ff       	call   f0109a8f <kfree>
f01193f7:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f01193fa:	a1 e8 4f 73 f0       	mov    0xf0734fe8,%eax
f01193ff:	83 ec 0c             	sub    $0xc,%esp
f0119402:	50                   	push   %eax
f0119403:	e8 87 06 ff ff       	call   f0109a8f <kfree>
f0119408:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f011940b:	a1 f0 4f 73 f0       	mov    0xf0734ff0,%eax
f0119410:	83 ec 0c             	sub    $0xc,%esp
f0119413:	50                   	push   %eax
f0119414:	e8 76 06 ff ff       	call   f0109a8f <kfree>
f0119419:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f011941c:	a1 ec 4f 73 f0       	mov    0xf0734fec,%eax
f0119421:	83 ec 0c             	sub    $0xc,%esp
f0119424:	50                   	push   %eax
f0119425:	e8 65 06 ff ff       	call   f0109a8f <kfree>
f011942a:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f011942d:	a1 10 50 73 f0       	mov    0xf0735010,%eax
f0119432:	83 ec 0c             	sub    $0xc,%esp
f0119435:	50                   	push   %eax
f0119436:	e8 54 06 ff ff       	call   f0109a8f <kfree>
f011943b:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f011943e:	a1 24 50 73 f0       	mov    0xf0735024,%eax
f0119443:	83 ec 0c             	sub    $0xc,%esp
f0119446:	50                   	push   %eax
f0119447:	e8 43 06 ff ff       	call   f0109a8f <kfree>
f011944c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f011944f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119452:	83 e8 02             	sub    $0x2,%eax
f0119455:	8b 04 85 c0 4f 73 f0 	mov    -0xf8cb040(,%eax,4),%eax
f011945c:	83 ec 0c             	sub    $0xc,%esp
f011945f:	50                   	push   %eax
f0119460:	e8 2a 06 ff ff       	call   f0109a8f <kfree>
f0119465:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0119468:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011946b:	83 e8 03             	sub    $0x3,%eax
f011946e:	8b 04 85 c0 4f 73 f0 	mov    -0xf8cb040(,%eax,4),%eax
f0119475:	83 ec 0c             	sub    $0xc,%esp
f0119478:	50                   	push   %eax
f0119479:	e8 11 06 ff ff       	call   f0109a8f <kfree>
f011947e:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119481:	e8 0d b6 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119486:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119489:	74 17                	je     f01194a2 <test_fastfirstfit+0x2a1>
f011948b:	83 ec 04             	sub    $0x4,%esp
f011948e:	68 0c d5 12 f0       	push   $0xf012d50c
f0119493:	68 fb 02 00 00       	push   $0x2fb
f0119498:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011949d:	e8 97 6e fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f01194a2:	e8 a1 57 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01194a7:	89 c2                	mov    %eax,%edx
f01194a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01194ac:	89 d1                	mov    %edx,%ecx
f01194ae:	29 c1                	sub    %eax,%ecx
f01194b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01194b3:	89 d0                	mov    %edx,%eax
f01194b5:	c1 e0 02             	shl    $0x2,%eax
f01194b8:	01 d0                	add    %edx,%eax
f01194ba:	01 c0                	add    %eax,%eax
f01194bc:	01 d0                	add    %edx,%eax
f01194be:	c1 e8 0c             	shr    $0xc,%eax
f01194c1:	39 c1                	cmp    %eax,%ecx
f01194c3:	74 17                	je     f01194dc <test_fastfirstfit+0x2db>
f01194c5:	83 ec 04             	sub    $0x4,%esp
f01194c8:	68 c4 d5 12 f0       	push   $0xf012d5c4
f01194cd:	68 fc 02 00 00       	push   $0x2fc
f01194d2:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01194d7:	e8 5d 6e fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f01194dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194df:	01 c0                	add    %eax,%eax
f01194e1:	89 c2                	mov    %eax,%edx
f01194e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194e6:	d1 e8                	shr    %eax
f01194e8:	01 d0                	add    %edx,%eax
f01194ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01194ed:	e8 a1 b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01194f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01194f5:	e8 4e 57 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01194fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01194fd:	83 ec 0c             	sub    $0xc,%esp
f0119500:	ff 75 dc             	pushl  -0x24(%ebp)
f0119503:	e8 c7 02 ff ff       	call   f01097cf <kmalloc>
f0119508:	83 c4 10             	add    $0x10,%esp
f011950b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f011950e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119511:	89 d0                	mov    %edx,%eax
f0119513:	c1 e0 02             	shl    $0x2,%eax
f0119516:	01 d0                	add    %edx,%eax
f0119518:	01 c0                	add    %eax,%eax
f011951a:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119520:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119523:	39 c2                	cmp    %eax,%edx
f0119525:	74 17                	je     f011953e <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f0119527:	83 ec 04             	sub    $0x4,%esp
f011952a:	68 04 d6 12 f0       	push   $0xf012d604
f011952f:	68 07 03 00 00       	push   $0x307
f0119534:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119539:	e8 fb 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011953e:	e8 50 b5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119543:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119546:	74 17                	je     f011955f <test_fastfirstfit+0x35e>
f0119548:	83 ec 04             	sub    $0x4,%esp
f011954b:	68 0c d5 12 f0       	push   $0xf012d50c
f0119550:	68 08 03 00 00       	push   $0x308
f0119555:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011955a:	e8 da 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011955f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119562:	e8 e1 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119567:	29 c3                	sub    %eax,%ebx
f0119569:	89 da                	mov    %ebx,%edx
f011956b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011956e:	c1 e8 0c             	shr    $0xc,%eax
f0119571:	39 c2                	cmp    %eax,%edx
f0119573:	73 17                	jae    f011958c <test_fastfirstfit+0x38b>
f0119575:	83 ec 04             	sub    $0x4,%esp
f0119578:	68 74 d5 12 f0       	push   $0xf012d574
f011957d:	68 09 03 00 00       	push   $0x309
f0119582:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119587:	e8 ad 6d fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f011958c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011958f:	01 c0                	add    %eax,%eax
f0119591:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119594:	e8 fa b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119599:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011959c:	e8 a7 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01195a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01195a4:	83 ec 0c             	sub    $0xc,%esp
f01195a7:	ff 75 dc             	pushl  -0x24(%ebp)
f01195aa:	e8 20 02 ff ff       	call   f01097cf <kmalloc>
f01195af:	83 c4 10             	add    $0x10,%esp
f01195b2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f01195b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01195b8:	05 00 08 00 7c       	add    $0x7c000800,%eax
f01195bd:	01 c0                	add    %eax,%eax
f01195bf:	89 c2                	mov    %eax,%edx
f01195c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01195c4:	39 c2                	cmp    %eax,%edx
f01195c6:	74 17                	je     f01195df <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f01195c8:	83 ec 04             	sub    $0x4,%esp
f01195cb:	68 04 d6 12 f0       	push   $0xf012d604
f01195d0:	68 13 03 00 00       	push   $0x313
f01195d5:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01195da:	e8 5a 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01195df:	e8 af b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01195e4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01195e7:	74 17                	je     f0119600 <test_fastfirstfit+0x3ff>
f01195e9:	83 ec 04             	sub    $0x4,%esp
f01195ec:	68 0c d5 12 f0       	push   $0xf012d50c
f01195f1:	68 14 03 00 00       	push   $0x314
f01195f6:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01195fb:	e8 39 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119600:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119603:	e8 40 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119608:	29 c3                	sub    %eax,%ebx
f011960a:	89 da                	mov    %ebx,%edx
f011960c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011960f:	c1 e8 0c             	shr    $0xc,%eax
f0119612:	39 c2                	cmp    %eax,%edx
f0119614:	73 17                	jae    f011962d <test_fastfirstfit+0x42c>
f0119616:	83 ec 04             	sub    $0x4,%esp
f0119619:	68 74 d5 12 f0       	push   $0xf012d574
f011961e:	68 15 03 00 00       	push   $0x315
f0119623:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119628:	e8 0c 6d fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f011962d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119630:	89 c2                	mov    %eax,%edx
f0119632:	01 d2                	add    %edx,%edx
f0119634:	01 d0                	add    %edx,%eax
f0119636:	d1 e8                	shr    %eax
f0119638:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011963b:	e8 53 b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119640:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119643:	e8 00 56 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119648:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011964b:	83 ec 0c             	sub    $0xc,%esp
f011964e:	ff 75 dc             	pushl  -0x24(%ebp)
f0119651:	e8 79 01 ff ff       	call   f01097cf <kmalloc>
f0119656:	83 c4 10             	add    $0x10,%esp
f0119659:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f011965c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011965f:	83 e8 03             	sub    $0x3,%eax
f0119662:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119666:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011966c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011966f:	39 c2                	cmp    %eax,%edx
f0119671:	74 17                	je     f011968a <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0119673:	83 ec 04             	sub    $0x4,%esp
f0119676:	68 04 d6 12 f0       	push   $0xf012d604
f011967b:	68 1f 03 00 00       	push   $0x31f
f0119680:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119685:	e8 af 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011968a:	e8 04 b4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011968f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119692:	74 17                	je     f01196ab <test_fastfirstfit+0x4aa>
f0119694:	83 ec 04             	sub    $0x4,%esp
f0119697:	68 0c d5 12 f0       	push   $0xf012d50c
f011969c:	68 20 03 00 00       	push   $0x320
f01196a1:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01196a6:	e8 8e 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01196ab:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01196ae:	e8 95 55 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01196b3:	29 c3                	sub    %eax,%ebx
f01196b5:	89 da                	mov    %ebx,%edx
f01196b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01196ba:	c1 e8 0c             	shr    $0xc,%eax
f01196bd:	39 c2                	cmp    %eax,%edx
f01196bf:	73 17                	jae    f01196d8 <test_fastfirstfit+0x4d7>
f01196c1:	83 ec 04             	sub    $0x4,%esp
f01196c4:	68 74 d5 12 f0       	push   $0xf012d574
f01196c9:	68 21 03 00 00       	push   $0x321
f01196ce:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01196d3:	e8 61 6c fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01196d8:	e8 b6 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01196dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01196e0:	e8 63 55 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01196e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01196e8:	83 ec 0c             	sub    $0xc,%esp
f01196eb:	ff 75 e4             	pushl  -0x1c(%ebp)
f01196ee:	e8 dc 00 ff ff       	call   f01097cf <kmalloc>
f01196f3:	83 c4 10             	add    $0x10,%esp
f01196f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f01196f9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01196fc:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119701:	74 17                	je     f011971a <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0119703:	83 ec 04             	sub    $0x4,%esp
f0119706:	68 04 d6 12 f0       	push   $0xf012d604
f011970b:	68 2a 03 00 00       	push   $0x32a
f0119710:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119715:	e8 1f 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011971a:	e8 74 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011971f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119722:	74 17                	je     f011973b <test_fastfirstfit+0x53a>
f0119724:	83 ec 04             	sub    $0x4,%esp
f0119727:	68 0c d5 12 f0       	push   $0xf012d50c
f011972c:	68 2b 03 00 00       	push   $0x32b
f0119731:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119736:	e8 fe 6b fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011973b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011973e:	e8 05 55 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119743:	29 c3                	sub    %eax,%ebx
f0119745:	89 da                	mov    %ebx,%edx
f0119747:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011974a:	c1 e8 0c             	shr    $0xc,%eax
f011974d:	39 c2                	cmp    %eax,%edx
f011974f:	73 17                	jae    f0119768 <test_fastfirstfit+0x567>
f0119751:	83 ec 04             	sub    $0x4,%esp
f0119754:	68 74 d5 12 f0       	push   $0xf012d574
f0119759:	68 2c 03 00 00       	push   $0x32c
f011975e:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119763:	e8 d1 6b fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119768:	e8 26 b3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011976d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119770:	e8 d3 54 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119775:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119778:	83 ec 0c             	sub    $0xc,%esp
f011977b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011977e:	e8 4c 00 ff ff       	call   f01097cf <kmalloc>
f0119783:	83 c4 10             	add    $0x10,%esp
f0119786:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0119789:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011978c:	89 d0                	mov    %edx,%eax
f011978e:	c1 e0 02             	shl    $0x2,%eax
f0119791:	01 d0                	add    %edx,%eax
f0119793:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119799:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011979c:	39 c2                	cmp    %eax,%edx
f011979e:	74 17                	je     f01197b7 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f01197a0:	83 ec 04             	sub    $0x4,%esp
f01197a3:	68 04 d6 12 f0       	push   $0xf012d604
f01197a8:	68 35 03 00 00       	push   $0x335
f01197ad:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01197b2:	e8 82 6b fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01197b7:	e8 d7 b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01197bc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01197bf:	74 17                	je     f01197d8 <test_fastfirstfit+0x5d7>
f01197c1:	83 ec 04             	sub    $0x4,%esp
f01197c4:	68 0c d5 12 f0       	push   $0xf012d50c
f01197c9:	68 36 03 00 00       	push   $0x336
f01197ce:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01197d3:	e8 61 6b fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01197d8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01197db:	e8 68 54 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01197e0:	29 c3                	sub    %eax,%ebx
f01197e2:	89 da                	mov    %ebx,%edx
f01197e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01197e7:	c1 e8 0c             	shr    $0xc,%eax
f01197ea:	39 c2                	cmp    %eax,%edx
f01197ec:	73 17                	jae    f0119805 <test_fastfirstfit+0x604>
f01197ee:	83 ec 04             	sub    $0x4,%esp
f01197f1:	68 74 d5 12 f0       	push   $0xf012d574
f01197f6:	68 37 03 00 00       	push   $0x337
f01197fb:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119800:	e8 34 6b fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119805:	e8 89 b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011980a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011980d:	e8 36 54 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119812:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119815:	83 ec 0c             	sub    $0xc,%esp
f0119818:	ff 75 e4             	pushl  -0x1c(%ebp)
f011981b:	e8 af ff fe ff       	call   f01097cf <kmalloc>
f0119820:	83 c4 10             	add    $0x10,%esp
f0119823:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0119826:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119829:	89 d0                	mov    %edx,%eax
f011982b:	c1 e0 02             	shl    $0x2,%eax
f011982e:	01 d0                	add    %edx,%eax
f0119830:	c1 e0 02             	shl    $0x2,%eax
f0119833:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119839:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011983c:	39 c2                	cmp    %eax,%edx
f011983e:	74 17                	je     f0119857 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0119840:	83 ec 04             	sub    $0x4,%esp
f0119843:	68 04 d6 12 f0       	push   $0xf012d604
f0119848:	68 40 03 00 00       	push   $0x340
f011984d:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119852:	e8 e2 6a fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119857:	e8 37 b2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011985c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011985f:	74 17                	je     f0119878 <test_fastfirstfit+0x677>
f0119861:	83 ec 04             	sub    $0x4,%esp
f0119864:	68 0c d5 12 f0       	push   $0xf012d50c
f0119869:	68 41 03 00 00       	push   $0x341
f011986e:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119873:	e8 c1 6a fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119878:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011987b:	e8 c8 53 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119880:	29 c3                	sub    %eax,%ebx
f0119882:	89 da                	mov    %ebx,%edx
f0119884:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119887:	c1 e8 0c             	shr    $0xc,%eax
f011988a:	39 c2                	cmp    %eax,%edx
f011988c:	73 17                	jae    f01198a5 <test_fastfirstfit+0x6a4>
f011988e:	83 ec 04             	sub    $0x4,%esp
f0119891:	68 74 d5 12 f0       	push   $0xf012d574
f0119896:	68 42 03 00 00       	push   $0x342
f011989b:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01198a0:	e8 94 6a fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01198a5:	e8 e9 b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01198aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01198ad:	e8 96 53 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01198b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01198b5:	83 ec 0c             	sub    $0xc,%esp
f01198b8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01198bb:	e8 0f ff fe ff       	call   f01097cf <kmalloc>
f01198c0:	83 c4 10             	add    $0x10,%esp
f01198c3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f01198c6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01198c9:	89 d0                	mov    %edx,%eax
f01198cb:	c1 e0 02             	shl    $0x2,%eax
f01198ce:	01 d0                	add    %edx,%eax
f01198d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01198d7:	01 d0                	add    %edx,%eax
f01198d9:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01198df:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01198e2:	39 c2                	cmp    %eax,%edx
f01198e4:	74 17                	je     f01198fd <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f01198e6:	83 ec 04             	sub    $0x4,%esp
f01198e9:	68 04 d6 12 f0       	push   $0xf012d604
f01198ee:	68 4b 03 00 00       	push   $0x34b
f01198f3:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01198f8:	e8 3c 6a fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01198fd:	e8 91 b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119902:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119905:	74 17                	je     f011991e <test_fastfirstfit+0x71d>
f0119907:	83 ec 04             	sub    $0x4,%esp
f011990a:	68 0c d5 12 f0       	push   $0xf012d50c
f011990f:	68 4c 03 00 00       	push   $0x34c
f0119914:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119919:	e8 1b 6a fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011991e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119921:	e8 22 53 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119926:	29 c3                	sub    %eax,%ebx
f0119928:	89 da                	mov    %ebx,%edx
f011992a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011992d:	c1 e8 0c             	shr    $0xc,%eax
f0119930:	39 c2                	cmp    %eax,%edx
f0119932:	73 17                	jae    f011994b <test_fastfirstfit+0x74a>
f0119934:	83 ec 04             	sub    $0x4,%esp
f0119937:	68 74 d5 12 f0       	push   $0xf012d574
f011993c:	68 4d 03 00 00       	push   $0x34d
f0119941:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119946:	e8 ee 69 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f011994b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011994e:	d1 e8                	shr    %eax
f0119950:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119953:	e8 3b b1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119958:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011995b:	e8 e8 52 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119960:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119963:	83 ec 0c             	sub    $0xc,%esp
f0119966:	ff 75 dc             	pushl  -0x24(%ebp)
f0119969:	e8 61 fe fe ff       	call   f01097cf <kmalloc>
f011996e:	83 c4 10             	add    $0x10,%esp
f0119971:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0119974:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119977:	89 d0                	mov    %edx,%eax
f0119979:	c1 e0 02             	shl    $0x2,%eax
f011997c:	01 d0                	add    %edx,%eax
f011997e:	01 c0                	add    %eax,%eax
f0119980:	89 c1                	mov    %eax,%ecx
f0119982:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119985:	89 d0                	mov    %edx,%eax
f0119987:	c1 e0 02             	shl    $0x2,%eax
f011998a:	01 d0                	add    %edx,%eax
f011998c:	d1 e8                	shr    %eax
f011998e:	01 c8                	add    %ecx,%eax
f0119990:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119996:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119999:	39 c2                	cmp    %eax,%edx
f011999b:	74 17                	je     f01199b4 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f011999d:	83 ec 04             	sub    $0x4,%esp
f01199a0:	68 04 d6 12 f0       	push   $0xf012d604
f01199a5:	68 57 03 00 00       	push   $0x357
f01199aa:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01199af:	e8 85 69 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01199b4:	e8 da b0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f01199b9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01199bc:	74 17                	je     f01199d5 <test_fastfirstfit+0x7d4>
f01199be:	83 ec 04             	sub    $0x4,%esp
f01199c1:	68 0c d5 12 f0       	push   $0xf012d50c
f01199c6:	68 58 03 00 00       	push   $0x358
f01199cb:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01199d0:	e8 64 69 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01199d5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01199d8:	e8 6b 52 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f01199dd:	29 c3                	sub    %eax,%ebx
f01199df:	89 da                	mov    %ebx,%edx
f01199e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01199e4:	c1 e8 0c             	shr    $0xc,%eax
f01199e7:	39 c2                	cmp    %eax,%edx
f01199e9:	73 17                	jae    f0119a02 <test_fastfirstfit+0x801>
f01199eb:	83 ec 04             	sub    $0x4,%esp
f01199ee:	68 74 d5 12 f0       	push   $0xf012d574
f01199f3:	68 59 03 00 00       	push   $0x359
f01199f8:	68 f3 d4 12 f0       	push   $0xf012d4f3
f01199fd:	e8 37 69 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0119a02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119a05:	d1 e8                	shr    %eax
f0119a07:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119a0a:	e8 84 b0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119a0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119a12:	e8 31 52 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119a17:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119a1a:	83 ec 0c             	sub    $0xc,%esp
f0119a1d:	ff 75 dc             	pushl  -0x24(%ebp)
f0119a20:	e8 aa fd fe ff       	call   f01097cf <kmalloc>
f0119a25:	83 c4 10             	add    $0x10,%esp
f0119a28:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f0119a2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119a2e:	83 e8 03             	sub    $0x3,%eax
f0119a31:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119a35:	89 c2                	mov    %eax,%edx
f0119a37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119a3a:	89 c1                	mov    %eax,%ecx
f0119a3c:	01 c9                	add    %ecx,%ecx
f0119a3e:	01 c8                	add    %ecx,%eax
f0119a40:	d1 e8                	shr    %eax
f0119a42:	01 d0                	add    %edx,%eax
f0119a44:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119a4a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119a4d:	39 c2                	cmp    %eax,%edx
f0119a4f:	74 17                	je     f0119a68 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f0119a51:	83 ec 04             	sub    $0x4,%esp
f0119a54:	68 04 d6 12 f0       	push   $0xf012d604
f0119a59:	68 63 03 00 00       	push   $0x363
f0119a5e:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119a63:	e8 d1 68 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119a68:	e8 26 b0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119a6d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119a70:	74 17                	je     f0119a89 <test_fastfirstfit+0x888>
f0119a72:	83 ec 04             	sub    $0x4,%esp
f0119a75:	68 0c d5 12 f0       	push   $0xf012d50c
f0119a7a:	68 64 03 00 00       	push   $0x364
f0119a7f:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119a84:	e8 b0 68 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119a89:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119a8c:	e8 b7 51 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119a91:	29 c3                	sub    %eax,%ebx
f0119a93:	89 da                	mov    %ebx,%edx
f0119a95:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119a98:	c1 e8 0c             	shr    $0xc,%eax
f0119a9b:	39 c2                	cmp    %eax,%edx
f0119a9d:	73 17                	jae    f0119ab6 <test_fastfirstfit+0x8b5>
f0119a9f:	83 ec 04             	sub    $0x4,%esp
f0119aa2:	68 74 d5 12 f0       	push   $0xf012d574
f0119aa7:	68 65 03 00 00       	push   $0x365
f0119aac:	68 f3 d4 12 f0       	push   $0xf012d4f3
f0119ab1:	e8 83 68 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f0119ab6:	83 ec 0c             	sub    $0xc,%esp
f0119ab9:	68 24 d6 12 f0       	push   $0xf012d624
f0119abe:	e8 c8 74 fe ff       	call   f0100f8b <cprintf>
f0119ac3:	83 c4 10             	add    $0x10,%esp
	return 1;
f0119ac6:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119acb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0119ace:	c9                   	leave  
f0119acf:	c3                   	ret    

f0119ad0 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0119ad0:	55                   	push   %ebp
f0119ad1:	89 e5                	mov    %esp,%ebp
f0119ad3:	57                   	push   %edi
f0119ad4:	53                   	push   %ebx
f0119ad5:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119adb:	83 ec 0c             	sub    $0xc,%esp
f0119ade:	68 a8 b5 12 f0       	push   $0xf012b5a8
f0119ae3:	e8 a3 74 fe ff       	call   f0100f8b <cprintf>
f0119ae8:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119aeb:	83 ec 0c             	sub    $0xc,%esp
f0119aee:	68 d8 b5 12 f0       	push   $0xf012b5d8
f0119af3:	e8 93 74 fe ff       	call   f0100f8b <cprintf>
f0119af8:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119afb:	83 ec 0c             	sub    $0xc,%esp
f0119afe:	68 a8 b5 12 f0       	push   $0xf012b5a8
f0119b03:	e8 83 74 fe ff       	call   f0100f8b <cprintf>
f0119b08:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0119b0b:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f0119b0f:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0119b13:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f0119b19:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0119b1f:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119b26:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0119b2d:	e8 16 51 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119b32:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0119b35:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f0119b3b:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119b40:	b8 00 00 00 00       	mov    $0x0,%eax
f0119b45:	89 d7                	mov    %edx,%edi
f0119b47:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119b49:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f0119b4f:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119b54:	b8 00 00 00 00       	mov    $0x0,%eax
f0119b59:	89 d7                	mov    %edx,%edi
f0119b5b:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f0119b5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0119b64:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f0119b6b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f0119b72:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119b78:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119b7d:	b8 00 00 00 00       	mov    $0x0,%eax
f0119b82:	89 d7                	mov    %edx,%edi
f0119b84:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119b86:	83 ec 0c             	sub    $0xc,%esp
f0119b89:	68 68 d6 12 f0       	push   $0xf012d668
f0119b8e:	e8 f8 73 fe ff       	call   f0100f8b <cprintf>
f0119b93:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119b96:	e8 ad 50 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119b9b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b9e:	e8 f0 ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119ba3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119ba6:	83 ec 0c             	sub    $0xc,%esp
f0119ba9:	68 00 fc 1f 00       	push   $0x1ffc00
f0119bae:	e8 1c fc fe ff       	call   f01097cf <kmalloc>
f0119bb3:	83 c4 10             	add    $0x10,%esp
f0119bb6:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119bbc:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119bc2:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119bc7:	74 17                	je     f0119be0 <test_kfree_bestfirstfit+0x110>
f0119bc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bd0:	83 ec 0c             	sub    $0xc,%esp
f0119bd3:	68 a0 d6 12 f0       	push   $0xf012d6a0
f0119bd8:	e8 ae 73 fe ff       	call   f0100f8b <cprintf>
f0119bdd:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119be0:	e8 ae ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119be5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119be8:	74 17                	je     f0119c01 <test_kfree_bestfirstfit+0x131>
f0119bea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bf1:	83 ec 0c             	sub    $0xc,%esp
f0119bf4:	68 f4 d6 12 f0       	push   $0xf012d6f4
f0119bf9:	e8 8d 73 fe ff       	call   f0100f8b <cprintf>
f0119bfe:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119c01:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119c04:	e8 3f 50 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119c09:	29 c3                	sub    %eax,%ebx
f0119c0b:	89 d8                	mov    %ebx,%eax
f0119c0d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119c12:	77 17                	ja     f0119c2b <test_kfree_bestfirstfit+0x15b>
f0119c14:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c1b:	83 ec 0c             	sub    $0xc,%esp
f0119c1e:	68 64 d7 12 f0       	push   $0xf012d764
f0119c23:	e8 63 73 fe ff       	call   f0100f8b <cprintf>
f0119c28:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f0119c2b:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0119c32:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119c35:	e8 0e 50 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119c3a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c3d:	e8 51 ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119c42:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119c45:	83 ec 0c             	sub    $0xc,%esp
f0119c48:	68 00 fc 1f 00       	push   $0x1ffc00
f0119c4d:	e8 7d fb fe ff       	call   f01097cf <kmalloc>
f0119c52:	83 c4 10             	add    $0x10,%esp
f0119c55:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119c5b:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119c61:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119c66:	74 17                	je     f0119c7f <test_kfree_bestfirstfit+0x1af>
f0119c68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c6f:	83 ec 0c             	sub    $0xc,%esp
f0119c72:	68 ac d7 12 f0       	push   $0xf012d7ac
f0119c77:	e8 0f 73 fe ff       	call   f0100f8b <cprintf>
f0119c7c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c7f:	e8 0f ae fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119c84:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c87:	74 17                	je     f0119ca0 <test_kfree_bestfirstfit+0x1d0>
f0119c89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c90:	83 ec 0c             	sub    $0xc,%esp
f0119c93:	68 00 d8 12 f0       	push   $0xf012d800
f0119c98:	e8 ee 72 fe ff       	call   f0100f8b <cprintf>
f0119c9d:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119ca0:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119ca3:	e8 a0 4f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119ca8:	29 c3                	sub    %eax,%ebx
f0119caa:	89 d8                	mov    %ebx,%eax
f0119cac:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119cb1:	77 17                	ja     f0119cca <test_kfree_bestfirstfit+0x1fa>
f0119cb3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119cba:	83 ec 0c             	sub    $0xc,%esp
f0119cbd:	68 70 d8 12 f0       	push   $0xf012d870
f0119cc2:	e8 c4 72 fe ff       	call   f0100f8b <cprintf>
f0119cc7:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119cca:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f0119cd1:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f0119cd4:	e8 6f 4f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119cd9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119cdc:	e8 b2 ad fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119ce1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f0119ce4:	83 ec 0c             	sub    $0xc,%esp
f0119ce7:	68 00 1c 00 00       	push   $0x1c00
f0119cec:	e8 de fa fe ff       	call   f01097cf <kmalloc>
f0119cf1:	83 c4 10             	add    $0x10,%esp
f0119cf4:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119cfa:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119d00:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119d05:	74 17                	je     f0119d1e <test_kfree_bestfirstfit+0x24e>
f0119d07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d0e:	83 ec 0c             	sub    $0xc,%esp
f0119d11:	68 b8 d8 12 f0       	push   $0xf012d8b8
f0119d16:	e8 70 72 fe ff       	call   f0100f8b <cprintf>
f0119d1b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d1e:	e8 70 ad fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119d23:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d26:	74 17                	je     f0119d3f <test_kfree_bestfirstfit+0x26f>
f0119d28:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d2f:	83 ec 0c             	sub    $0xc,%esp
f0119d32:	68 0c d9 12 f0       	push   $0xf012d90c
f0119d37:	e8 4f 72 fe ff       	call   f0100f8b <cprintf>
f0119d3c:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119d3f:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119d42:	e8 01 4f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119d47:	29 c3                	sub    %eax,%ebx
f0119d49:	89 d8                	mov    %ebx,%eax
f0119d4b:	83 f8 01             	cmp    $0x1,%eax
f0119d4e:	77 17                	ja     f0119d67 <test_kfree_bestfirstfit+0x297>
f0119d50:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d57:	83 ec 0c             	sub    $0xc,%esp
f0119d5a:	68 7c d9 12 f0       	push   $0xf012d97c
f0119d5f:	e8 27 72 fe ff       	call   f0100f8b <cprintf>
f0119d64:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119d67:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f0119d6e:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f0119d71:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119d77:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119d7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119d81:	eb 0e                	jmp    f0119d91 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f0119d83:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119d86:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119d89:	01 d0                	add    %edx,%eax
f0119d8b:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f0119d8e:	ff 45 f4             	incl   -0xc(%ebp)
f0119d91:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119d97:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119d9a:	7f e7                	jg     f0119d83 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119d9c:	e8 a7 4e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119da1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119da4:	e8 ea ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119da9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119dac:	83 ec 0c             	sub    $0xc,%esp
f0119daf:	68 00 fc 2f 00       	push   $0x2ffc00
f0119db4:	e8 16 fa fe ff       	call   f01097cf <kmalloc>
f0119db9:	83 c4 10             	add    $0x10,%esp
f0119dbc:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119dc2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119dc8:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119dcd:	74 17                	je     f0119de6 <test_kfree_bestfirstfit+0x316>
f0119dcf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dd6:	83 ec 0c             	sub    $0xc,%esp
f0119dd9:	68 c4 d9 12 f0       	push   $0xf012d9c4
f0119dde:	e8 a8 71 fe ff       	call   f0100f8b <cprintf>
f0119de3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119de6:	e8 a8 ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119deb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119dee:	74 17                	je     f0119e07 <test_kfree_bestfirstfit+0x337>
f0119df0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119df7:	83 ec 0c             	sub    $0xc,%esp
f0119dfa:	68 18 da 12 f0       	push   $0xf012da18
f0119dff:	e8 87 71 fe ff       	call   f0100f8b <cprintf>
f0119e04:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119e07:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119e0a:	e8 39 4e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119e0f:	29 c3                	sub    %eax,%ebx
f0119e11:	89 d8                	mov    %ebx,%eax
f0119e13:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119e18:	77 17                	ja     f0119e31 <test_kfree_bestfirstfit+0x361>
f0119e1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e21:	83 ec 0c             	sub    $0xc,%esp
f0119e24:	68 88 da 12 f0       	push   $0xf012da88
f0119e29:	e8 5d 71 fe ff       	call   f0100f8b <cprintf>
f0119e2e:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0119e31:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0119e38:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f0119e3b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119e41:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0119e44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119e4b:	eb 0e                	jmp    f0119e5b <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0119e4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119e50:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119e53:	01 d0                	add    %edx,%eax
f0119e55:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119e58:	ff 45 f4             	incl   -0xc(%ebp)
f0119e5b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119e61:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119e64:	7f e7                	jg     f0119e4d <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119e66:	e8 dd 4d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119e6b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e6e:	e8 20 ac fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119e73:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119e76:	83 ec 0c             	sub    $0xc,%esp
f0119e79:	68 00 fc 5f 00       	push   $0x5ffc00
f0119e7e:	e8 4c f9 fe ff       	call   f01097cf <kmalloc>
f0119e83:	83 c4 10             	add    $0x10,%esp
f0119e86:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119e8c:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119e92:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119e97:	74 17                	je     f0119eb0 <test_kfree_bestfirstfit+0x3e0>
f0119e99:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ea0:	83 ec 0c             	sub    $0xc,%esp
f0119ea3:	68 d0 da 12 f0       	push   $0xf012dad0
f0119ea8:	e8 de 70 fe ff       	call   f0100f8b <cprintf>
f0119ead:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119eb0:	e8 de ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119eb5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119eb8:	74 17                	je     f0119ed1 <test_kfree_bestfirstfit+0x401>
f0119eba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ec1:	83 ec 0c             	sub    $0xc,%esp
f0119ec4:	68 24 db 12 f0       	push   $0xf012db24
f0119ec9:	e8 bd 70 fe ff       	call   f0100f8b <cprintf>
f0119ece:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119ed1:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119ed4:	e8 6f 4d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119ed9:	29 c3                	sub    %eax,%ebx
f0119edb:	89 d8                	mov    %ebx,%eax
f0119edd:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119ee2:	77 17                	ja     f0119efb <test_kfree_bestfirstfit+0x42b>
f0119ee4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eeb:	83 ec 0c             	sub    $0xc,%esp
f0119eee:	68 94 db 12 f0       	push   $0xf012db94
f0119ef3:	e8 93 70 fe ff       	call   f0100f8b <cprintf>
f0119ef8:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0119efb:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0119f02:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0119f05:	e8 3e 4d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119f0a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f0d:	e8 81 ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119f12:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0119f15:	83 ec 0c             	sub    $0xc,%esp
f0119f18:	68 00 38 00 00       	push   $0x3800
f0119f1d:	e8 ad f8 fe ff       	call   f01097cf <kmalloc>
f0119f22:	83 c4 10             	add    $0x10,%esp
f0119f25:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119f2b:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119f31:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119f36:	74 17                	je     f0119f4f <test_kfree_bestfirstfit+0x47f>
f0119f38:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f3f:	83 ec 0c             	sub    $0xc,%esp
f0119f42:	68 dc db 12 f0       	push   $0xf012dbdc
f0119f47:	e8 3f 70 fe ff       	call   f0100f8b <cprintf>
f0119f4c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f4f:	e8 3f ab fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119f54:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119f57:	74 17                	je     f0119f70 <test_kfree_bestfirstfit+0x4a0>
f0119f59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f60:	83 ec 0c             	sub    $0xc,%esp
f0119f63:	68 30 dc 12 f0       	push   $0xf012dc30
f0119f68:	e8 1e 70 fe ff       	call   f0100f8b <cprintf>
f0119f6d:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119f70:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119f73:	e8 d0 4c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119f78:	29 c3                	sub    %eax,%ebx
f0119f7a:	89 d8                	mov    %ebx,%eax
f0119f7c:	83 f8 03             	cmp    $0x3,%eax
f0119f7f:	77 17                	ja     f0119f98 <test_kfree_bestfirstfit+0x4c8>
f0119f81:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f88:	83 ec 0c             	sub    $0xc,%esp
f0119f8b:	68 a0 dc 12 f0       	push   $0xf012dca0
f0119f90:	e8 f6 6f fe ff       	call   f0100f8b <cprintf>
f0119f95:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119f98:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119f9f:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119fa5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119fa8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119faf:	eb 0e                	jmp    f0119fbf <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119fb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119fb4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119fb7:	01 d0                	add    %edx,%eax
f0119fb9:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119fbc:	ff 45 f4             	incl   -0xc(%ebp)
f0119fbf:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119fc2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119fc5:	7f ea                	jg     f0119fb1 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119fc7:	e8 7c 4c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f0119fcc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119fcf:	e8 bf aa fe ff       	call   f0104a93 <pf_calculate_free_frames>
f0119fd4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119fd7:	83 ec 0c             	sub    $0xc,%esp
f0119fda:	68 00 08 00 00       	push   $0x800
f0119fdf:	e8 eb f7 fe ff       	call   f01097cf <kmalloc>
f0119fe4:	83 c4 10             	add    $0x10,%esp
f0119fe7:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119fed:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119ff3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119ff8:	76 28                	jbe    f011a022 <test_kfree_bestfirstfit+0x552>
f0119ffa:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f011a000:	83 ec 0c             	sub    $0xc,%esp
f011a003:	6a 00                	push   $0x0
f011a005:	e8 92 f6 fe ff       	call   f010969c <sbrk>
f011a00a:	83 c4 10             	add    $0x10,%esp
f011a00d:	39 c3                	cmp    %eax,%ebx
f011a00f:	73 11                	jae    f011a022 <test_kfree_bestfirstfit+0x552>
f011a011:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a017:	89 c2                	mov    %eax,%edx
f011a019:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011a01e:	39 c2                	cmp    %eax,%edx
f011a020:	72 17                	jb     f011a039 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a022:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a029:	83 ec 0c             	sub    $0xc,%esp
f011a02c:	68 e8 dc 12 f0       	push   $0xf012dce8
f011a031:	e8 55 6f fe ff       	call   f0100f8b <cprintf>
f011a036:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a039:	e8 55 aa fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a03e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a041:	74 17                	je     f011a05a <test_kfree_bestfirstfit+0x58a>
f011a043:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a04a:	83 ec 0c             	sub    $0xc,%esp
f011a04d:	68 74 dd 12 f0       	push   $0xf012dd74
f011a052:	e8 34 6f fe ff       	call   f0100f8b <cprintf>
f011a057:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f011a05a:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f011a061:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011a064:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a06a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f011a06d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a074:	eb 0e                	jmp    f011a084 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f011a076:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a079:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a07c:	01 d0                	add    %edx,%eax
f011a07e:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011a081:	ff 45 f4             	incl   -0xc(%ebp)
f011a084:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a08a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a08d:	7f e7                	jg     f011a076 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f011a08f:	e8 ff a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a094:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a097:	83 ec 0c             	sub    $0xc,%esp
f011a09a:	68 00 08 00 00       	push   $0x800
f011a09f:	e8 2b f7 fe ff       	call   f01097cf <kmalloc>
f011a0a4:	83 c4 10             	add    $0x10,%esp
f011a0a7:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a0ad:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a0b3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a0b8:	76 28                	jbe    f011a0e2 <test_kfree_bestfirstfit+0x612>
f011a0ba:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011a0c0:	83 ec 0c             	sub    $0xc,%esp
f011a0c3:	6a 00                	push   $0x0
f011a0c5:	e8 d2 f5 fe ff       	call   f010969c <sbrk>
f011a0ca:	83 c4 10             	add    $0x10,%esp
f011a0cd:	39 c3                	cmp    %eax,%ebx
f011a0cf:	73 11                	jae    f011a0e2 <test_kfree_bestfirstfit+0x612>
f011a0d1:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a0d7:	89 c2                	mov    %eax,%edx
f011a0d9:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011a0de:	39 c2                	cmp    %eax,%edx
f011a0e0:	72 17                	jb     f011a0f9 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a0e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0e9:	83 ec 0c             	sub    $0xc,%esp
f011a0ec:	68 e4 dd 12 f0       	push   $0xf012dde4
f011a0f1:	e8 95 6e fe ff       	call   f0100f8b <cprintf>
f011a0f6:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a0f9:	e8 95 a9 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a0fe:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a101:	74 17                	je     f011a11a <test_kfree_bestfirstfit+0x64a>
f011a103:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a10a:	83 ec 0c             	sub    $0xc,%esp
f011a10d:	68 70 de 12 f0       	push   $0xf012de70
f011a112:	e8 74 6e fe ff       	call   f0100f8b <cprintf>
f011a117:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011a11a:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011a121:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011a124:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a12a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f011a12d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a134:	eb 0e                	jmp    f011a144 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f011a136:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a139:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a13c:	01 d0                	add    %edx,%eax
f011a13e:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011a141:	ff 45 f4             	incl   -0xc(%ebp)
f011a144:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a14a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a14d:	7f e7                	jg     f011a136 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f011a14f:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a152:	e8 f1 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a157:	29 c3                	sub    %eax,%ebx
f011a159:	89 d8                	mov    %ebx,%eax
f011a15b:	83 f8 01             	cmp    $0x1,%eax
f011a15e:	74 17                	je     f011a177 <test_kfree_bestfirstfit+0x6a7>
f011a160:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a167:	83 ec 0c             	sub    $0xc,%esp
f011a16a:	68 e0 de 12 f0       	push   $0xf012dee0
f011a16f:	e8 17 6e fe ff       	call   f0100f8b <cprintf>
f011a174:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f011a177:	83 ec 0c             	sub    $0xc,%esp
f011a17a:	68 04 df 12 f0       	push   $0xf012df04
f011a17f:	e8 07 6e fe ff       	call   f0100f8b <cprintf>
f011a184:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a187:	e8 bc 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a18c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a18f:	e8 ff a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a194:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011a197:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011a19d:	83 ec 0c             	sub    $0xc,%esp
f011a1a0:	50                   	push   %eax
f011a1a1:	e8 e9 f8 fe ff       	call   f0109a8f <kfree>
f011a1a6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1a9:	e8 e5 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a1ae:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a1b1:	74 17                	je     f011a1ca <test_kfree_bestfirstfit+0x6fa>
f011a1b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1ba:	83 ec 0c             	sub    $0xc,%esp
f011a1bd:	68 34 df 12 f0       	push   $0xf012df34
f011a1c2:	e8 c4 6d fe ff       	call   f0100f8b <cprintf>
f011a1c7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a1ca:	e8 79 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a1cf:	89 c2                	mov    %eax,%edx
f011a1d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a1d4:	29 c2                	sub    %eax,%edx
f011a1d6:	89 d0                	mov    %edx,%eax
f011a1d8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a1dd:	77 17                	ja     f011a1f6 <test_kfree_bestfirstfit+0x726>
f011a1df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1e6:	83 ec 0c             	sub    $0xc,%esp
f011a1e9:	68 a4 df 12 f0       	push   $0xf012dfa4
f011a1ee:	e8 98 6d fe ff       	call   f0100f8b <cprintf>
f011a1f3:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f011a1f6:	e8 4d 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a1fb:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a1fe:	e8 90 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a203:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011a206:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a20c:	83 ec 0c             	sub    $0xc,%esp
f011a20f:	50                   	push   %eax
f011a210:	e8 7a f8 fe ff       	call   f0109a8f <kfree>
f011a215:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a218:	e8 76 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a21d:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a220:	74 17                	je     f011a239 <test_kfree_bestfirstfit+0x769>
f011a222:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a229:	83 ec 0c             	sub    $0xc,%esp
f011a22c:	68 e0 df 12 f0       	push   $0xf012dfe0
f011a231:	e8 55 6d fe ff       	call   f0100f8b <cprintf>
f011a236:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a239:	e8 0a 4a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a23e:	89 c2                	mov    %eax,%edx
f011a240:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a243:	39 c2                	cmp    %eax,%edx
f011a245:	74 17                	je     f011a25e <test_kfree_bestfirstfit+0x78e>
f011a247:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a24e:	83 ec 0c             	sub    $0xc,%esp
f011a251:	68 50 e0 12 f0       	push   $0xf012e050
f011a256:	e8 30 6d fe ff       	call   f0100f8b <cprintf>
f011a25b:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a25e:	e8 e5 49 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a263:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a266:	e8 28 a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a26b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011a26e:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a274:	83 ec 0c             	sub    $0xc,%esp
f011a277:	50                   	push   %eax
f011a278:	e8 12 f8 fe ff       	call   f0109a8f <kfree>
f011a27d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a280:	e8 0e a8 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a285:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a288:	74 17                	je     f011a2a1 <test_kfree_bestfirstfit+0x7d1>
f011a28a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a291:	83 ec 0c             	sub    $0xc,%esp
f011a294:	68 b0 e0 12 f0       	push   $0xf012e0b0
f011a299:	e8 ed 6c fe ff       	call   f0100f8b <cprintf>
f011a29e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a2a1:	e8 a2 49 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a2a6:	89 c2                	mov    %eax,%edx
f011a2a8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a2ab:	29 c2                	sub    %eax,%edx
f011a2ad:	89 d0                	mov    %edx,%eax
f011a2af:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a2b4:	77 17                	ja     f011a2cd <test_kfree_bestfirstfit+0x7fd>
f011a2b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2bd:	83 ec 0c             	sub    $0xc,%esp
f011a2c0:	68 20 e1 12 f0       	push   $0xf012e120
f011a2c5:	e8 c1 6c fe ff       	call   f0100f8b <cprintf>
f011a2ca:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a2cd:	e8 76 49 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a2d2:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a2d5:	e8 b9 a7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a2da:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011a2dd:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a2e3:	83 ec 0c             	sub    $0xc,%esp
f011a2e6:	50                   	push   %eax
f011a2e7:	e8 a3 f7 fe ff       	call   f0109a8f <kfree>
f011a2ec:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a2ef:	e8 9f a7 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a2f4:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a2f7:	74 17                	je     f011a310 <test_kfree_bestfirstfit+0x840>
f011a2f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a300:	83 ec 0c             	sub    $0xc,%esp
f011a303:	68 5c e1 12 f0       	push   $0xf012e15c
f011a308:	e8 7e 6c fe ff       	call   f0100f8b <cprintf>
f011a30d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a310:	e8 33 49 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a315:	89 c2                	mov    %eax,%edx
f011a317:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a31a:	29 c2                	sub    %eax,%edx
f011a31c:	89 d0                	mov    %edx,%eax
f011a31e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a323:	77 17                	ja     f011a33c <test_kfree_bestfirstfit+0x86c>
f011a325:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a32c:	83 ec 0c             	sub    $0xc,%esp
f011a32f:	68 cc e1 12 f0       	push   $0xf012e1cc
f011a334:	e8 52 6c fe ff       	call   f0100f8b <cprintf>
f011a339:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a33c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a340:	74 04                	je     f011a346 <test_kfree_bestfirstfit+0x876>
f011a342:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a346:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f011a34d:	83 ec 0c             	sub    $0xc,%esp
f011a350:	68 08 e2 12 f0       	push   $0xf012e208
f011a355:	e8 31 6c fe ff       	call   f0100f8b <cprintf>
f011a35a:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011a35d:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a363:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011a366:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a36d:	eb 1e                	jmp    f011a38d <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f011a36f:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a375:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a378:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a37b:	01 c8                	add    %ecx,%eax
f011a37d:	8a 00                	mov    (%eax),%al
f011a37f:	0f be c0             	movsbl %al,%eax
f011a382:	01 d0                	add    %edx,%eax
f011a384:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011a38a:	ff 45 f4             	incl   -0xc(%ebp)
f011a38d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a393:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a396:	7f d7                	jg     f011a36f <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f011a398:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a39e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a3a4:	89 c1                	mov    %eax,%ecx
f011a3a6:	01 c9                	add    %ecx,%ecx
f011a3a8:	01 c8                	add    %ecx,%eax
f011a3aa:	39 c2                	cmp    %eax,%edx
f011a3ac:	74 17                	je     f011a3c5 <test_kfree_bestfirstfit+0x8f5>
f011a3ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3b5:	83 ec 0c             	sub    $0xc,%esp
f011a3b8:	68 50 e2 12 f0       	push   $0xf012e250
f011a3bd:	e8 c9 6b fe ff       	call   f0100f8b <cprintf>
f011a3c2:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011a3c5:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a3cb:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011a3ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3d5:	eb 1e                	jmp    f011a3f5 <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f011a3d7:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011a3dd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a3e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3e3:	01 c8                	add    %ecx,%eax
f011a3e5:	8a 00                	mov    (%eax),%al
f011a3e7:	0f be c0             	movsbl %al,%eax
f011a3ea:	01 d0                	add    %edx,%eax
f011a3ec:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011a3f2:	ff 45 f4             	incl   -0xc(%ebp)
f011a3f5:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a3fb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a3fe:	7f d7                	jg     f011a3d7 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f011a400:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a406:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f011a40c:	c1 e2 02             	shl    $0x2,%edx
f011a40f:	39 d0                	cmp    %edx,%eax
f011a411:	74 17                	je     f011a42a <test_kfree_bestfirstfit+0x95a>
f011a413:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a41a:	83 ec 0c             	sub    $0xc,%esp
f011a41d:	68 88 e2 12 f0       	push   $0xf012e288
f011a422:	e8 64 6b fe ff       	call   f0100f8b <cprintf>
f011a427:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011a42a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a430:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011a433:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a43a:	eb 1e                	jmp    f011a45a <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f011a43c:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011a442:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a445:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a448:	01 c8                	add    %ecx,%eax
f011a44a:	8a 00                	mov    (%eax),%al
f011a44c:	0f be c0             	movsbl %al,%eax
f011a44f:	01 d0                	add    %edx,%eax
f011a451:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011a457:	ff 45 f4             	incl   -0xc(%ebp)
f011a45a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a460:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a463:	7f d7                	jg     f011a43c <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011a465:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011a46b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011a471:	89 d0                	mov    %edx,%eax
f011a473:	c1 e0 02             	shl    $0x2,%eax
f011a476:	01 d0                	add    %edx,%eax
f011a478:	39 c1                	cmp    %eax,%ecx
f011a47a:	74 17                	je     f011a493 <test_kfree_bestfirstfit+0x9c3>
f011a47c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a483:	83 ec 0c             	sub    $0xc,%esp
f011a486:	68 c0 e2 12 f0       	push   $0xf012e2c0
f011a48b:	e8 fb 6a fe ff       	call   f0100f8b <cprintf>
f011a490:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011a493:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a499:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011a49c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a4a3:	eb 1e                	jmp    f011a4c3 <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011a4a5:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011a4ab:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a4ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a4b1:	01 c8                	add    %ecx,%eax
f011a4b3:	8a 00                	mov    (%eax),%al
f011a4b5:	0f be c0             	movsbl %al,%eax
f011a4b8:	01 d0                	add    %edx,%eax
f011a4ba:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011a4c0:	ff 45 f4             	incl   -0xc(%ebp)
f011a4c3:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a4c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a4c9:	7f da                	jg     f011a4a5 <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011a4cb:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011a4d1:	8b 55 80             	mov    -0x80(%ebp),%edx
f011a4d4:	89 d0                	mov    %edx,%eax
f011a4d6:	01 c0                	add    %eax,%eax
f011a4d8:	01 d0                	add    %edx,%eax
f011a4da:	01 c0                	add    %eax,%eax
f011a4dc:	01 d0                	add    %edx,%eax
f011a4de:	39 c1                	cmp    %eax,%ecx
f011a4e0:	74 17                	je     f011a4f9 <test_kfree_bestfirstfit+0xa29>
f011a4e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4e9:	83 ec 0c             	sub    $0xc,%esp
f011a4ec:	68 f8 e2 12 f0       	push   $0xf012e2f8
f011a4f1:	e8 95 6a fe ff       	call   f0100f8b <cprintf>
f011a4f6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a4f9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a4fd:	74 04                	je     f011a503 <test_kfree_bestfirstfit+0xa33>
f011a4ff:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a503:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011a50a:	83 ec 0c             	sub    $0xc,%esp
f011a50d:	68 30 e3 12 f0       	push   $0xf012e330
f011a512:	e8 74 6a fe ff       	call   f0100f8b <cprintf>
f011a517:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011a51a:	e8 29 47 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a51f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a522:	e8 6c a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a527:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011a52a:	83 ec 0c             	sub    $0xc,%esp
f011a52d:	68 00 04 00 00       	push   $0x400
f011a532:	e8 98 f2 fe ff       	call   f01097cf <kmalloc>
f011a537:	83 c4 10             	add    $0x10,%esp
f011a53a:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011a540:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011a546:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a54c:	39 c2                	cmp    %eax,%edx
f011a54e:	74 17                	je     f011a567 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a550:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a557:	83 ec 0c             	sub    $0xc,%esp
f011a55a:	68 50 e3 12 f0       	push   $0xf012e350
f011a55f:	e8 27 6a fe ff       	call   f0100f8b <cprintf>
f011a564:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a567:	e8 27 a5 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a56c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a56f:	74 17                	je     f011a588 <test_kfree_bestfirstfit+0xab8>
f011a571:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a578:	83 ec 0c             	sub    $0xc,%esp
f011a57b:	68 a4 e3 12 f0       	push   $0xf012e3a4
f011a580:	e8 06 6a fe ff       	call   f0100f8b <cprintf>
f011a585:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a588:	e8 bb 46 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a58d:	89 c2                	mov    %eax,%edx
f011a58f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a592:	39 c2                	cmp    %eax,%edx
f011a594:	74 17                	je     f011a5ad <test_kfree_bestfirstfit+0xadd>
f011a596:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a59d:	83 ec 0c             	sub    $0xc,%esp
f011a5a0:	68 14 e4 12 f0       	push   $0xf012e414
f011a5a5:	e8 e1 69 fe ff       	call   f0100f8b <cprintf>
f011a5aa:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011a5ad:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011a5b4:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a5ba:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011a5bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a5c4:	eb 0e                	jmp    f011a5d4 <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011a5c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a5c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a5cc:	01 d0                	add    %edx,%eax
f011a5ce:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011a5d1:	ff 45 f4             	incl   -0xc(%ebp)
f011a5d4:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a5d7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a5da:	7f ea                	jg     f011a5c6 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a5dc:	e8 67 46 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a5e1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a5e4:	e8 aa a4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a5e9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011a5ec:	83 ec 0c             	sub    $0xc,%esp
f011a5ef:	68 00 00 30 00       	push   $0x300000
f011a5f4:	e8 d6 f1 fe ff       	call   f01097cf <kmalloc>
f011a5f9:	83 c4 10             	add    $0x10,%esp
f011a5fc:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a602:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a608:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a60d:	74 17                	je     f011a626 <test_kfree_bestfirstfit+0xb56>
f011a60f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a616:	83 ec 0c             	sub    $0xc,%esp
f011a619:	68 90 e4 12 f0       	push   $0xf012e490
f011a61e:	e8 68 69 fe ff       	call   f0100f8b <cprintf>
f011a623:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a626:	e8 68 a4 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a62b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a62e:	74 17                	je     f011a647 <test_kfree_bestfirstfit+0xb77>
f011a630:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a637:	83 ec 0c             	sub    $0xc,%esp
f011a63a:	68 e4 e4 12 f0       	push   $0xf012e4e4
f011a63f:	e8 47 69 fe ff       	call   f0100f8b <cprintf>
f011a644:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a647:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a64a:	e8 f9 45 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a64f:	29 c3                	sub    %eax,%ebx
f011a651:	89 d8                	mov    %ebx,%eax
f011a653:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a658:	77 17                	ja     f011a671 <test_kfree_bestfirstfit+0xba1>
f011a65a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a661:	83 ec 0c             	sub    $0xc,%esp
f011a664:	68 54 e5 12 f0       	push   $0xf012e554
f011a669:	e8 1d 69 fe ff       	call   f0100f8b <cprintf>
f011a66e:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011a671:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011a678:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a67e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011a681:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a688:	eb 0e                	jmp    f011a698 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011a68a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a68d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a690:	01 d0                	add    %edx,%eax
f011a692:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011a695:	ff 45 f4             	incl   -0xc(%ebp)
f011a698:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a69b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a69e:	7f ea                	jg     f011a68a <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011a6a0:	e8 a3 45 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a6a5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a6a8:	e8 e6 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a6ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011a6b0:	83 ec 0c             	sub    $0xc,%esp
f011a6b3:	68 00 00 10 00       	push   $0x100000
f011a6b8:	e8 12 f1 fe ff       	call   f01097cf <kmalloc>
f011a6bd:	83 c4 10             	add    $0x10,%esp
f011a6c0:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a6c6:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a6cc:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011a6d1:	74 17                	je     f011a6ea <test_kfree_bestfirstfit+0xc1a>
f011a6d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6da:	83 ec 0c             	sub    $0xc,%esp
f011a6dd:	68 9c e5 12 f0       	push   $0xf012e59c
f011a6e2:	e8 a4 68 fe ff       	call   f0100f8b <cprintf>
f011a6e7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a6ea:	e8 a4 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a6ef:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a6f2:	74 17                	je     f011a70b <test_kfree_bestfirstfit+0xc3b>
f011a6f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6fb:	83 ec 0c             	sub    $0xc,%esp
f011a6fe:	68 f0 e5 12 f0       	push   $0xf012e5f0
f011a703:	e8 83 68 fe ff       	call   f0100f8b <cprintf>
f011a708:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a70b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a70e:	e8 35 45 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a713:	29 c3                	sub    %eax,%ebx
f011a715:	89 d8                	mov    %ebx,%eax
f011a717:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a71c:	77 17                	ja     f011a735 <test_kfree_bestfirstfit+0xc65>
f011a71e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a725:	83 ec 0c             	sub    $0xc,%esp
f011a728:	68 60 e6 12 f0       	push   $0xf012e660
f011a72d:	e8 59 68 fe ff       	call   f0100f8b <cprintf>
f011a732:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011a735:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011a73c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a742:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011a745:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a74c:	eb 0e                	jmp    f011a75c <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011a74e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a751:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a754:	01 d0                	add    %edx,%eax
f011a756:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011a759:	ff 45 f4             	incl   -0xc(%ebp)
f011a75c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a75f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a762:	7f ea                	jg     f011a74e <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011a764:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a768:	74 04                	je     f011a76e <test_kfree_bestfirstfit+0xc9e>
f011a76a:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a76e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011a775:	83 ec 0c             	sub    $0xc,%esp
f011a778:	68 a8 e6 12 f0       	push   $0xf012e6a8
f011a77d:	e8 09 68 fe ff       	call   f0100f8b <cprintf>
f011a782:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011a785:	e8 be 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a78a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a78d:	e8 01 a3 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a792:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011a795:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a79b:	83 ec 0c             	sub    $0xc,%esp
f011a79e:	50                   	push   %eax
f011a79f:	e8 eb f2 fe ff       	call   f0109a8f <kfree>
f011a7a4:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7a7:	e8 e7 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a7ac:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a7af:	74 17                	je     f011a7c8 <test_kfree_bestfirstfit+0xcf8>
f011a7b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7b8:	83 ec 0c             	sub    $0xc,%esp
f011a7bb:	68 d4 e6 12 f0       	push   $0xf012e6d4
f011a7c0:	e8 c6 67 fe ff       	call   f0100f8b <cprintf>
f011a7c5:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a7c8:	e8 7b 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a7cd:	89 c2                	mov    %eax,%edx
f011a7cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a7d2:	29 c2                	sub    %eax,%edx
f011a7d4:	89 d0                	mov    %edx,%eax
f011a7d6:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a7db:	77 17                	ja     f011a7f4 <test_kfree_bestfirstfit+0xd24>
f011a7dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7e4:	83 ec 0c             	sub    $0xc,%esp
f011a7e7:	68 44 e7 12 f0       	push   $0xf012e744
f011a7ec:	e8 9a 67 fe ff       	call   f0100f8b <cprintf>
f011a7f1:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011a7f4:	e8 4f 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a7f9:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a7fc:	e8 92 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a801:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011a804:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a80a:	83 ec 0c             	sub    $0xc,%esp
f011a80d:	50                   	push   %eax
f011a80e:	e8 7c f2 fe ff       	call   f0109a8f <kfree>
f011a813:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a816:	e8 78 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a81b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a81e:	74 17                	je     f011a837 <test_kfree_bestfirstfit+0xd67>
f011a820:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a827:	83 ec 0c             	sub    $0xc,%esp
f011a82a:	68 80 e7 12 f0       	push   $0xf012e780
f011a82f:	e8 57 67 fe ff       	call   f0100f8b <cprintf>
f011a834:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a837:	e8 0c 44 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a83c:	89 c2                	mov    %eax,%edx
f011a83e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a841:	29 c2                	sub    %eax,%edx
f011a843:	89 d0                	mov    %edx,%eax
f011a845:	83 f8 01             	cmp    $0x1,%eax
f011a848:	77 17                	ja     f011a861 <test_kfree_bestfirstfit+0xd91>
f011a84a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a851:	83 ec 0c             	sub    $0xc,%esp
f011a854:	68 f0 e7 12 f0       	push   $0xf012e7f0
f011a859:	e8 2d 67 fe ff       	call   f0100f8b <cprintf>
f011a85e:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011a861:	e8 e2 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a866:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a869:	e8 25 a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a86e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011a871:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a877:	83 ec 0c             	sub    $0xc,%esp
f011a87a:	50                   	push   %eax
f011a87b:	e8 0f f2 fe ff       	call   f0109a8f <kfree>
f011a880:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a883:	e8 0b a2 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a888:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a88b:	74 17                	je     f011a8a4 <test_kfree_bestfirstfit+0xdd4>
f011a88d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a894:	83 ec 0c             	sub    $0xc,%esp
f011a897:	68 2c e8 12 f0       	push   $0xf012e82c
f011a89c:	e8 ea 66 fe ff       	call   f0100f8b <cprintf>
f011a8a1:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a8a4:	e8 9f 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a8a9:	89 c2                	mov    %eax,%edx
f011a8ab:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a8ae:	29 c2                	sub    %eax,%edx
f011a8b0:	89 d0                	mov    %edx,%eax
f011a8b2:	83 f8 03             	cmp    $0x3,%eax
f011a8b5:	77 17                	ja     f011a8ce <test_kfree_bestfirstfit+0xdfe>
f011a8b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8be:	83 ec 0c             	sub    $0xc,%esp
f011a8c1:	68 9c e8 12 f0       	push   $0xf012e89c
f011a8c6:	e8 c0 66 fe ff       	call   f0100f8b <cprintf>
f011a8cb:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011a8ce:	e8 75 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a8d3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a8d6:	e8 b8 a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a8db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011a8de:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a8e4:	83 ec 0c             	sub    $0xc,%esp
f011a8e7:	50                   	push   %eax
f011a8e8:	e8 a2 f1 fe ff       	call   f0109a8f <kfree>
f011a8ed:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8f0:	e8 9e a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a8f5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a8f8:	74 17                	je     f011a911 <test_kfree_bestfirstfit+0xe41>
f011a8fa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a901:	83 ec 0c             	sub    $0xc,%esp
f011a904:	68 d8 e8 12 f0       	push   $0xf012e8d8
f011a909:	e8 7d 66 fe ff       	call   f0100f8b <cprintf>
f011a90e:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a911:	e8 32 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a916:	89 c2                	mov    %eax,%edx
f011a918:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a91b:	29 c2                	sub    %eax,%edx
f011a91d:	89 d0                	mov    %edx,%eax
f011a91f:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a924:	77 17                	ja     f011a93d <test_kfree_bestfirstfit+0xe6d>
f011a926:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a92d:	83 ec 0c             	sub    $0xc,%esp
f011a930:	68 48 e9 12 f0       	push   $0xf012e948
f011a935:	e8 51 66 fe ff       	call   f0100f8b <cprintf>
f011a93a:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011a93d:	e8 06 43 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a942:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a945:	e8 49 a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a94a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011a94d:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a953:	83 ec 0c             	sub    $0xc,%esp
f011a956:	50                   	push   %eax
f011a957:	e8 33 f1 fe ff       	call   f0109a8f <kfree>
f011a95c:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a95f:	e8 2f a1 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a964:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a967:	74 17                	je     f011a980 <test_kfree_bestfirstfit+0xeb0>
f011a969:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a970:	83 ec 0c             	sub    $0xc,%esp
f011a973:	68 84 e9 12 f0       	push   $0xf012e984
f011a978:	e8 0e 66 fe ff       	call   f0100f8b <cprintf>
f011a97d:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a980:	e8 c3 42 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a985:	89 c2                	mov    %eax,%edx
f011a987:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a98a:	29 c2                	sub    %eax,%edx
f011a98c:	89 d0                	mov    %edx,%eax
f011a98e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a993:	77 17                	ja     f011a9ac <test_kfree_bestfirstfit+0xedc>
f011a995:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a99c:	83 ec 0c             	sub    $0xc,%esp
f011a99f:	68 f4 e9 12 f0       	push   $0xf012e9f4
f011a9a4:	e8 e2 65 fe ff       	call   f0100f8b <cprintf>
f011a9a9:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011a9ac:	e8 97 42 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a9b1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a9b4:	e8 da a0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a9b9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011a9bc:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a9c2:	83 ec 0c             	sub    $0xc,%esp
f011a9c5:	50                   	push   %eax
f011a9c6:	e8 c4 f0 fe ff       	call   f0109a8f <kfree>
f011a9cb:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9ce:	e8 c0 a0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011a9d3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a9d6:	74 17                	je     f011a9ef <test_kfree_bestfirstfit+0xf1f>
f011a9d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9df:	83 ec 0c             	sub    $0xc,%esp
f011a9e2:	68 30 ea 12 f0       	push   $0xf012ea30
f011a9e7:	e8 9f 65 fe ff       	call   f0100f8b <cprintf>
f011a9ec:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a9ef:	e8 54 42 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011a9f4:	89 c2                	mov    %eax,%edx
f011a9f6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a9f9:	39 c2                	cmp    %eax,%edx
f011a9fb:	74 17                	je     f011aa14 <test_kfree_bestfirstfit+0xf44>
f011a9fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa04:	83 ec 0c             	sub    $0xc,%esp
f011aa07:	68 a0 ea 12 f0       	push   $0xf012eaa0
f011aa0c:	e8 7a 65 fe ff       	call   f0100f8b <cprintf>
f011aa11:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011aa14:	e8 2f 42 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011aa19:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aa1c:	e8 72 a0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011aa21:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011aa24:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011aa2a:	83 ec 0c             	sub    $0xc,%esp
f011aa2d:	50                   	push   %eax
f011aa2e:	e8 5c f0 fe ff       	call   f0109a8f <kfree>
f011aa33:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa36:	e8 58 a0 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011aa3b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aa3e:	74 17                	je     f011aa57 <test_kfree_bestfirstfit+0xf87>
f011aa40:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa47:	83 ec 0c             	sub    $0xc,%esp
f011aa4a:	68 dc ea 12 f0       	push   $0xf012eadc
f011aa4f:	e8 37 65 fe ff       	call   f0100f8b <cprintf>
f011aa54:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011aa57:	e8 ec 41 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011aa5c:	89 c2                	mov    %eax,%edx
f011aa5e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011aa61:	39 c2                	cmp    %eax,%edx
f011aa63:	74 17                	je     f011aa7c <test_kfree_bestfirstfit+0xfac>
f011aa65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa6c:	83 ec 0c             	sub    $0xc,%esp
f011aa6f:	68 4c eb 12 f0       	push   $0xf012eb4c
f011aa74:	e8 12 65 fe ff       	call   f0100f8b <cprintf>
f011aa79:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011aa7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aa80:	74 04                	je     f011aa86 <test_kfree_bestfirstfit+0xfb6>
f011aa82:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011aa86:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011aa8d:	83 ec 0c             	sub    $0xc,%esp
f011aa90:	68 ac eb 12 f0       	push   $0xf012ebac
f011aa95:	e8 f1 64 fe ff       	call   f0100f8b <cprintf>
f011aa9a:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011aa9d:	83 ec 0c             	sub    $0xc,%esp
f011aaa0:	6a 03                	push   $0x3
f011aaa2:	e8 32 46 ff ff       	call   f010f0d9 <sys_bypassPageFault>
f011aaa7:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011aaaa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aab1:	e9 af 00 00 00       	jmp    f011ab65 <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011aab6:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011aaba:	0f 84 a1 00 00 00    	je     f011ab61 <test_kfree_bestfirstfit+0x1091>
f011aac0:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011aac4:	0f 84 97 00 00 00    	je     f011ab61 <test_kfree_bestfirstfit+0x1091>
f011aaca:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011aace:	0f 84 8d 00 00 00    	je     f011ab61 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011aad4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aad7:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011aade:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011aae1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aae4:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011aae7:	e8 db 45 ff ff       	call   f010f0c7 <sys_rcr2>
f011aaec:	89 c2                	mov    %eax,%edx
f011aaee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aaf1:	39 c2                	cmp    %eax,%edx
f011aaf3:	74 1d                	je     f011ab12 <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011aaf5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aaf9:	74 17                	je     f011ab12 <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011aafb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab02:	83 ec 0c             	sub    $0xc,%esp
f011ab05:	68 ec eb 12 f0       	push   $0xf012ebec
f011ab0a:	e8 7c 64 fe ff       	call   f0100f8b <cprintf>
f011ab0f:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011ab12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ab15:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011ab1c:	89 c2                	mov    %eax,%edx
f011ab1e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab21:	01 d0                	add    %edx,%eax
f011ab23:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011ab26:	e8 9c 45 ff ff       	call   f010f0c7 <sys_rcr2>
f011ab2b:	89 c2                	mov    %eax,%edx
f011ab2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ab30:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011ab37:	89 c1                	mov    %eax,%ecx
f011ab39:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab3c:	01 c8                	add    %ecx,%eax
f011ab3e:	39 c2                	cmp    %eax,%edx
f011ab40:	74 20                	je     f011ab62 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011ab42:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ab46:	74 1a                	je     f011ab62 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011ab48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab4f:	83 ec 0c             	sub    $0xc,%esp
f011ab52:	68 38 ec 12 f0       	push   $0xf012ec38
f011ab57:	e8 2f 64 fe ff       	call   f0100f8b <cprintf>
f011ab5c:	83 c4 10             	add    $0x10,%esp
f011ab5f:	eb 01                	jmp    f011ab62 <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011ab61:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011ab62:	ff 45 f4             	incl   -0xc(%ebp)
f011ab65:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011ab69:	0f 8e 47 ff ff ff    	jle    f011aab6 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011ab6f:	83 ec 0c             	sub    $0xc,%esp
f011ab72:	6a 00                	push   $0x0
f011ab74:	e8 60 45 ff ff       	call   f010f0d9 <sys_bypassPageFault>
f011ab79:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011ab7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ab80:	74 04                	je     f011ab86 <test_kfree_bestfirstfit+0x10b6>
f011ab82:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011ab86:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011ab8d:	83 ec 0c             	sub    $0xc,%esp
f011ab90:	68 84 ec 12 f0       	push   $0xf012ec84
f011ab95:	e8 f1 63 fe ff       	call   f0100f8b <cprintf>
f011ab9a:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011ab9d:	e8 a6 40 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011aba2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aba5:	e8 e9 9e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011abaa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011abad:	83 ec 0c             	sub    $0xc,%esp
f011abb0:	68 00 04 00 00       	push   $0x400
f011abb5:	e8 15 ec fe ff       	call   f01097cf <kmalloc>
f011abba:	83 c4 10             	add    $0x10,%esp
f011abbd:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011abc3:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011abc9:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011abcf:	39 c2                	cmp    %eax,%edx
f011abd1:	74 17                	je     f011abea <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011abd3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abda:	83 ec 0c             	sub    $0xc,%esp
f011abdd:	68 a8 ec 12 f0       	push   $0xf012eca8
f011abe2:	e8 a4 63 fe ff       	call   f0100f8b <cprintf>
f011abe7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011abea:	e8 a4 9e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011abef:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011abf2:	74 17                	je     f011ac0b <test_kfree_bestfirstfit+0x113b>
f011abf4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abfb:	83 ec 0c             	sub    $0xc,%esp
f011abfe:	68 fc ec 12 f0       	push   $0xf012ecfc
f011ac03:	e8 83 63 fe ff       	call   f0100f8b <cprintf>
f011ac08:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ac0b:	e8 38 40 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ac10:	89 c2                	mov    %eax,%edx
f011ac12:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ac15:	39 c2                	cmp    %eax,%edx
f011ac17:	74 17                	je     f011ac30 <test_kfree_bestfirstfit+0x1160>
f011ac19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac20:	83 ec 0c             	sub    $0xc,%esp
f011ac23:	68 6c ed 12 f0       	push   $0xf012ed6c
f011ac28:	e8 5e 63 fe ff       	call   f0100f8b <cprintf>
f011ac2d:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011ac30:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011ac37:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ac3d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011ac40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac47:	eb 0e                	jmp    f011ac57 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011ac49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ac4c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac4f:	01 d0                	add    %edx,%eax
f011ac51:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011ac54:	ff 45 f4             	incl   -0xc(%ebp)
f011ac57:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ac5a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac5d:	7f ea                	jg     f011ac49 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011ac5f:	e8 e4 3f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ac64:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ac67:	e8 27 9e fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ac6c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011ac6f:	83 ec 0c             	sub    $0xc,%esp
f011ac72:	68 00 08 00 00       	push   $0x800
f011ac77:	e8 53 eb fe ff       	call   f01097cf <kmalloc>
f011ac7c:	83 c4 10             	add    $0x10,%esp
f011ac7f:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011ac85:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011ac8b:	05 08 04 00 00       	add    $0x408,%eax
f011ac90:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011ac93:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ac99:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ac9c:	74 35                	je     f011acd3 <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011ac9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011aca5:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011acab:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011acb1:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011acb7:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011acbd:	81 c2 00 04 00 00    	add    $0x400,%edx
f011acc3:	50                   	push   %eax
f011acc4:	51                   	push   %ecx
f011acc5:	52                   	push   %edx
f011acc6:	68 e8 ed 12 f0       	push   $0xf012ede8
f011accb:	e8 bb 62 fe ff       	call   f0100f8b <cprintf>
f011acd0:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011acd3:	e8 bb 9d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011acd8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011acdb:	74 17                	je     f011acf4 <test_kfree_bestfirstfit+0x1224>
f011acdd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ace4:	83 ec 0c             	sub    $0xc,%esp
f011ace7:	68 5c ee 12 f0       	push   $0xf012ee5c
f011acec:	e8 9a 62 fe ff       	call   f0100f8b <cprintf>
f011acf1:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011acf4:	e8 4f 3f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011acf9:	89 c2                	mov    %eax,%edx
f011acfb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011acfe:	39 c2                	cmp    %eax,%edx
f011ad00:	74 17                	je     f011ad19 <test_kfree_bestfirstfit+0x1249>
f011ad02:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad09:	83 ec 0c             	sub    $0xc,%esp
f011ad0c:	68 cc ee 12 f0       	push   $0xf012eecc
f011ad11:	e8 75 62 fe ff       	call   f0100f8b <cprintf>
f011ad16:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011ad19:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011ad20:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ad26:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011ad29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ad30:	eb 0e                	jmp    f011ad40 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011ad32:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad35:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ad38:	01 d0                	add    %edx,%eax
f011ad3a:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011ad3d:	ff 45 f4             	incl   -0xc(%ebp)
f011ad40:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ad43:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ad46:	7f ea                	jg     f011ad32 <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011ad48:	e8 fb 3e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ad4d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ad50:	e8 3e 9d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ad55:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011ad58:	83 ec 0c             	sub    $0xc,%esp
f011ad5b:	68 00 06 00 00       	push   $0x600
f011ad60:	e8 6a ea fe ff       	call   f01097cf <kmalloc>
f011ad65:	83 c4 10             	add    $0x10,%esp
f011ad68:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011ad6e:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011ad74:	05 10 0c 00 00       	add    $0xc10,%eax
f011ad79:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011ad7c:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011ad82:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ad85:	74 17                	je     f011ad9e <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ad87:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad8e:	83 ec 0c             	sub    $0xc,%esp
f011ad91:	68 48 ef 12 f0       	push   $0xf012ef48
f011ad96:	e8 f0 61 fe ff       	call   f0100f8b <cprintf>
f011ad9b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad9e:	e8 f0 9c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ada3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ada6:	74 17                	je     f011adbf <test_kfree_bestfirstfit+0x12ef>
f011ada8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adaf:	83 ec 0c             	sub    $0xc,%esp
f011adb2:	68 9c ef 12 f0       	push   $0xf012ef9c
f011adb7:	e8 cf 61 fe ff       	call   f0100f8b <cprintf>
f011adbc:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011adbf:	e8 84 3e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011adc4:	89 c2                	mov    %eax,%edx
f011adc6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011adc9:	39 c2                	cmp    %eax,%edx
f011adcb:	74 17                	je     f011ade4 <test_kfree_bestfirstfit+0x1314>
f011adcd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011add4:	83 ec 0c             	sub    $0xc,%esp
f011add7:	68 0c f0 12 f0       	push   $0xf012f00c
f011addc:	e8 aa 61 fe ff       	call   f0100f8b <cprintf>
f011ade1:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011ade4:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011adeb:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011adf1:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011adf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011adfb:	eb 0e                	jmp    f011ae0b <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011adfd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ae00:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ae03:	01 d0                	add    %edx,%eax
f011ae05:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011ae08:	ff 45 f4             	incl   -0xc(%ebp)
f011ae0b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ae0e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ae11:	7f ea                	jg     f011adfd <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011ae13:	e8 30 3e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ae18:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ae1b:	e8 73 9c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ae20:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011ae23:	83 ec 0c             	sub    $0xc,%esp
f011ae26:	68 00 00 e0 01       	push   $0x1e00000
f011ae2b:	e8 9f e9 fe ff       	call   f01097cf <kmalloc>
f011ae30:	83 c4 10             	add    $0x10,%esp
f011ae33:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae39:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ae3f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ae44:	74 17                	je     f011ae5d <test_kfree_bestfirstfit+0x138d>
f011ae46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae4d:	83 ec 0c             	sub    $0xc,%esp
f011ae50:	68 88 f0 12 f0       	push   $0xf012f088
f011ae55:	e8 31 61 fe ff       	call   f0100f8b <cprintf>
f011ae5a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae5d:	e8 31 9c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ae62:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ae65:	74 17                	je     f011ae7e <test_kfree_bestfirstfit+0x13ae>
f011ae67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae6e:	83 ec 0c             	sub    $0xc,%esp
f011ae71:	68 dc f0 12 f0       	push   $0xf012f0dc
f011ae76:	e8 10 61 fe ff       	call   f0100f8b <cprintf>
f011ae7b:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ae7e:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ae81:	e8 c2 3d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ae86:	29 c3                	sub    %eax,%ebx
f011ae88:	89 d8                	mov    %ebx,%eax
f011ae8a:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011ae8f:	77 17                	ja     f011aea8 <test_kfree_bestfirstfit+0x13d8>
f011ae91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae98:	83 ec 0c             	sub    $0xc,%esp
f011ae9b:	68 4c f1 12 f0       	push   $0xf012f14c
f011aea0:	e8 e6 60 fe ff       	call   f0100f8b <cprintf>
f011aea5:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011aea8:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011aeaf:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aeb5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011aeb8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aebf:	eb 0e                	jmp    f011aecf <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011aec1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aec4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aec7:	01 d0                	add    %edx,%eax
f011aec9:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011aecc:	ff 45 f4             	incl   -0xc(%ebp)
f011aecf:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011aed2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aed5:	7f ea                	jg     f011aec1 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011aed7:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aedd:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011aee0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aee7:	eb 1e                	jmp    f011af07 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011aee9:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011aeef:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011aef2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aef5:	01 c8                	add    %ecx,%eax
f011aef7:	8a 00                	mov    (%eax),%al
f011aef9:	0f be c0             	movsbl %al,%eax
f011aefc:	01 d0                	add    %edx,%eax
f011aefe:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011af04:	ff 45 f4             	incl   -0xc(%ebp)
f011af07:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011af0a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011af0d:	7f da                	jg     f011aee9 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011af0f:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011af15:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011af18:	89 d0                	mov    %edx,%eax
f011af1a:	c1 e0 02             	shl    $0x2,%eax
f011af1d:	01 d0                	add    %edx,%eax
f011af1f:	01 c0                	add    %eax,%eax
f011af21:	39 c1                	cmp    %eax,%ecx
f011af23:	74 17                	je     f011af3c <test_kfree_bestfirstfit+0x146c>
f011af25:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af2c:	83 ec 0c             	sub    $0xc,%esp
f011af2f:	68 94 f1 12 f0       	push   $0xf012f194
f011af34:	e8 52 60 fe ff       	call   f0100f8b <cprintf>
f011af39:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011af3c:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011af42:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011af45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011af4c:	eb 1e                	jmp    f011af6c <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011af4e:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011af54:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011af57:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011af5a:	01 c8                	add    %ecx,%eax
f011af5c:	8a 00                	mov    (%eax),%al
f011af5e:	0f be c0             	movsbl %al,%eax
f011af61:	01 d0                	add    %edx,%eax
f011af63:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011af69:	ff 45 f4             	incl   -0xc(%ebp)
f011af6c:	8b 45 90             	mov    -0x70(%ebp),%eax
f011af6f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011af72:	7f da                	jg     f011af4e <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011af74:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011af7a:	8b 55 90             	mov    -0x70(%ebp),%edx
f011af7d:	89 d0                	mov    %edx,%eax
f011af7f:	c1 e0 02             	shl    $0x2,%eax
f011af82:	01 d0                	add    %edx,%eax
f011af84:	01 c0                	add    %eax,%eax
f011af86:	01 d0                	add    %edx,%eax
f011af88:	39 c1                	cmp    %eax,%ecx
f011af8a:	74 17                	je     f011afa3 <test_kfree_bestfirstfit+0x14d3>
f011af8c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af93:	83 ec 0c             	sub    $0xc,%esp
f011af96:	68 c4 f1 12 f0       	push   $0xf012f1c4
f011af9b:	e8 eb 5f fe ff       	call   f0100f8b <cprintf>
f011afa0:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011afa3:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011afa9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011afac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011afb3:	eb 1e                	jmp    f011afd3 <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011afb5:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011afbb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011afbe:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011afc1:	01 c8                	add    %ecx,%eax
f011afc3:	8a 00                	mov    (%eax),%al
f011afc5:	0f be c0             	movsbl %al,%eax
f011afc8:	01 d0                	add    %edx,%eax
f011afca:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011afd0:	ff 45 f4             	incl   -0xc(%ebp)
f011afd3:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011afd6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011afd9:	7f da                	jg     f011afb5 <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011afdb:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011afe1:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011afe4:	89 d0                	mov    %edx,%eax
f011afe6:	01 c0                	add    %eax,%eax
f011afe8:	01 d0                	add    %edx,%eax
f011afea:	c1 e0 02             	shl    $0x2,%eax
f011afed:	39 c1                	cmp    %eax,%ecx
f011afef:	74 17                	je     f011b008 <test_kfree_bestfirstfit+0x1538>
f011aff1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aff8:	83 ec 0c             	sub    $0xc,%esp
f011affb:	68 f4 f1 12 f0       	push   $0xf012f1f4
f011b000:	e8 86 5f fe ff       	call   f0100f8b <cprintf>
f011b005:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011b008:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b00e:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011b011:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b018:	eb 1e                	jmp    f011b038 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011b01a:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011b020:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b023:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b026:	01 c8                	add    %ecx,%eax
f011b028:	8a 00                	mov    (%eax),%al
f011b02a:	0f be c0             	movsbl %al,%eax
f011b02d:	01 d0                	add    %edx,%eax
f011b02f:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011b035:	ff 45 f4             	incl   -0xc(%ebp)
f011b038:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b03b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b03e:	7f da                	jg     f011b01a <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011b040:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011b046:	8b 55 98             	mov    -0x68(%ebp),%edx
f011b049:	89 d0                	mov    %edx,%eax
f011b04b:	01 c0                	add    %eax,%eax
f011b04d:	01 d0                	add    %edx,%eax
f011b04f:	c1 e0 02             	shl    $0x2,%eax
f011b052:	01 d0                	add    %edx,%eax
f011b054:	39 c1                	cmp    %eax,%ecx
f011b056:	74 17                	je     f011b06f <test_kfree_bestfirstfit+0x159f>
f011b058:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b05f:	83 ec 0c             	sub    $0xc,%esp
f011b062:	68 24 f2 12 f0       	push   $0xf012f224
f011b067:	e8 1f 5f fe ff       	call   f0100f8b <cprintf>
f011b06c:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011b06f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b073:	74 04                	je     f011b079 <test_kfree_bestfirstfit+0x15a9>
f011b075:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b079:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011b080:	83 ec 0c             	sub    $0xc,%esp
f011b083:	68 51 f2 12 f0       	push   $0xf012f251
f011b088:	e8 fe 5e fe ff       	call   f0100f8b <cprintf>
f011b08d:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b090:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011b097:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011b09e:	eb 4e                	jmp    f011b0ee <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011b0a0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b0a3:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011b0a8:	83 ec 04             	sub    $0x4,%esp
f011b0ab:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011b0b1:	51                   	push   %ecx
f011b0b2:	52                   	push   %edx
f011b0b3:	50                   	push   %eax
f011b0b4:	e8 61 d6 fe ff       	call   f010871a <get_page_table>
f011b0b9:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b0bc:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011b0c2:	85 c0                	test   %eax,%eax
f011b0c4:	75 1d                	jne    f011b0e3 <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011b0c6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b0ca:	74 17                	je     f011b0e3 <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011b0cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0d3:	83 ec 0c             	sub    $0xc,%esp
f011b0d6:	68 70 f2 12 f0       	push   $0xf012f270
f011b0db:	e8 ab 5e fe ff       	call   f0100f8b <cprintf>
f011b0e0:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b0e3:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011b0ea:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011b0ee:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b0f2:	78 ac                	js     f011b0a0 <test_kfree_bestfirstfit+0x15d0>
f011b0f4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b0f8:	7f 09                	jg     f011b103 <test_kfree_bestfirstfit+0x1633>
f011b0fa:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011b101:	76 9d                	jbe    f011b0a0 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011b103:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b107:	74 04                	je     f011b10d <test_kfree_bestfirstfit+0x163d>
f011b109:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011b10d:	83 ec 08             	sub    $0x8,%esp
f011b110:	ff 75 f0             	pushl  -0x10(%ebp)
f011b113:	68 d8 f2 12 f0       	push   $0xf012f2d8
f011b118:	e8 6e 5e fe ff       	call   f0100f8b <cprintf>
f011b11d:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b120:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b125:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b128:	5b                   	pop    %ebx
f011b129:	5f                   	pop    %edi
f011b12a:	5d                   	pop    %ebp
f011b12b:	c3                   	ret    

f011b12c <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011b12c:	55                   	push   %ebp
f011b12d:	89 e5                	mov    %esp,%ebp
f011b12f:	57                   	push   %edi
f011b130:	53                   	push   %ebx
f011b131:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b137:	83 ec 0c             	sub    $0xc,%esp
f011b13a:	68 a8 b5 12 f0       	push   $0xf012b5a8
f011b13f:	e8 47 5e fe ff       	call   f0100f8b <cprintf>
f011b144:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b147:	83 ec 0c             	sub    $0xc,%esp
f011b14a:	68 d8 b5 12 f0       	push   $0xf012b5d8
f011b14f:	e8 37 5e fe ff       	call   f0100f8b <cprintf>
f011b154:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b157:	83 ec 0c             	sub    $0xc,%esp
f011b15a:	68 a8 b5 12 f0       	push   $0xf012b5a8
f011b15f:	e8 27 5e fe ff       	call   f0100f8b <cprintf>
f011b164:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b167:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011b16b:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011b16f:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011b175:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011b17b:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b182:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b189:	e8 ba 3a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b18e:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011b191:	83 ec 0c             	sub    $0xc,%esp
f011b194:	68 fc f2 12 f0       	push   $0xf012f2fc
f011b199:	e8 ed 5d fe ff       	call   f0100f8b <cprintf>
f011b19e:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b1a1:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011b1a7:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b1ac:	b8 00 00 00 00       	mov    $0x0,%eax
f011b1b1:	89 d7                	mov    %edx,%edi
f011b1b3:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b1b5:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011b1bb:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b1c0:	b8 00 00 00 00       	mov    $0x0,%eax
f011b1c5:	89 d7                	mov    %edx,%edi
f011b1c7:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011b1c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011b1d0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011b1d7:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011b1dd:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b1e2:	b8 00 00 00 00       	mov    $0x0,%eax
f011b1e7:	89 d7                	mov    %edx,%edi
f011b1e9:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b1eb:	e8 58 3a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b1f0:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b1f3:	e8 9b 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b1f8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b1fb:	83 ec 0c             	sub    $0xc,%esp
f011b1fe:	68 00 fc 1f 00       	push   $0x1ffc00
f011b203:	e8 c7 e5 fe ff       	call   f01097cf <kmalloc>
f011b208:	83 c4 10             	add    $0x10,%esp
f011b20b:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b211:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b217:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b21c:	74 17                	je     f011b235 <test_kheap_phys_addr+0x109>
f011b21e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b225:	83 ec 0c             	sub    $0xc,%esp
f011b228:	68 a0 d6 12 f0       	push   $0xf012d6a0
f011b22d:	e8 59 5d fe ff       	call   f0100f8b <cprintf>
f011b232:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b235:	e8 59 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b23a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b23d:	74 17                	je     f011b256 <test_kheap_phys_addr+0x12a>
f011b23f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b246:	83 ec 0c             	sub    $0xc,%esp
f011b249:	68 f4 d6 12 f0       	push   $0xf012d6f4
f011b24e:	e8 38 5d fe ff       	call   f0100f8b <cprintf>
f011b253:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b256:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b259:	e8 ea 39 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b25e:	29 c3                	sub    %eax,%ebx
f011b260:	89 d8                	mov    %ebx,%eax
f011b262:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b267:	77 17                	ja     f011b280 <test_kheap_phys_addr+0x154>
f011b269:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b270:	83 ec 0c             	sub    $0xc,%esp
f011b273:	68 64 d7 12 f0       	push   $0xf012d764
f011b278:	e8 0e 5d fe ff       	call   f0100f8b <cprintf>
f011b27d:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b280:	e8 c3 39 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b285:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b288:	e8 06 98 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b28d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b290:	83 ec 0c             	sub    $0xc,%esp
f011b293:	68 00 fc 1f 00       	push   $0x1ffc00
f011b298:	e8 32 e5 fe ff       	call   f01097cf <kmalloc>
f011b29d:	83 c4 10             	add    $0x10,%esp
f011b2a0:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b2a6:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b2ac:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b2b1:	74 17                	je     f011b2ca <test_kheap_phys_addr+0x19e>
f011b2b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2ba:	83 ec 0c             	sub    $0xc,%esp
f011b2bd:	68 ac d7 12 f0       	push   $0xf012d7ac
f011b2c2:	e8 c4 5c fe ff       	call   f0100f8b <cprintf>
f011b2c7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2ca:	e8 c4 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b2cf:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b2d2:	74 17                	je     f011b2eb <test_kheap_phys_addr+0x1bf>
f011b2d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2db:	83 ec 0c             	sub    $0xc,%esp
f011b2de:	68 00 d8 12 f0       	push   $0xf012d800
f011b2e3:	e8 a3 5c fe ff       	call   f0100f8b <cprintf>
f011b2e8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b2eb:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b2ee:	e8 55 39 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b2f3:	29 c3                	sub    %eax,%ebx
f011b2f5:	89 d8                	mov    %ebx,%eax
f011b2f7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b2fc:	77 17                	ja     f011b315 <test_kheap_phys_addr+0x1e9>
f011b2fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b305:	83 ec 0c             	sub    $0xc,%esp
f011b308:	68 70 d8 12 f0       	push   $0xf012d870
f011b30d:	e8 79 5c fe ff       	call   f0100f8b <cprintf>
f011b312:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011b315:	e8 2e 39 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b31a:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b31d:	e8 71 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b322:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011b325:	83 ec 0c             	sub    $0xc,%esp
f011b328:	68 00 04 00 00       	push   $0x400
f011b32d:	e8 9d e4 fe ff       	call   f01097cf <kmalloc>
f011b332:	83 c4 10             	add    $0x10,%esp
f011b335:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b33b:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b341:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b346:	76 28                	jbe    f011b370 <test_kheap_phys_addr+0x244>
f011b348:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011b34e:	83 ec 0c             	sub    $0xc,%esp
f011b351:	6a 00                	push   $0x0
f011b353:	e8 44 e3 fe ff       	call   f010969c <sbrk>
f011b358:	83 c4 10             	add    $0x10,%esp
f011b35b:	39 c3                	cmp    %eax,%ebx
f011b35d:	73 11                	jae    f011b370 <test_kheap_phys_addr+0x244>
f011b35f:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b365:	89 c2                	mov    %eax,%edx
f011b367:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b36c:	39 c2                	cmp    %eax,%edx
f011b36e:	72 17                	jb     f011b387 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b370:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b377:	83 ec 0c             	sub    $0xc,%esp
f011b37a:	68 2c f3 12 f0       	push   $0xf012f32c
f011b37f:	e8 07 5c fe ff       	call   f0100f8b <cprintf>
f011b384:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b387:	e8 07 97 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b38c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b38f:	74 17                	je     f011b3a8 <test_kheap_phys_addr+0x27c>
f011b391:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b398:	83 ec 0c             	sub    $0xc,%esp
f011b39b:	68 0c d9 12 f0       	push   $0xf012d90c
f011b3a0:	e8 e6 5b fe ff       	call   f0100f8b <cprintf>
f011b3a5:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b3a8:	e8 9b 38 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b3ad:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b3b0:	e8 de 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b3b5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b3b8:	83 ec 0c             	sub    $0xc,%esp
f011b3bb:	68 00 08 00 00       	push   $0x800
f011b3c0:	e8 0a e4 fe ff       	call   f01097cf <kmalloc>
f011b3c5:	83 c4 10             	add    $0x10,%esp
f011b3c8:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b3ce:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b3d4:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b3d9:	76 28                	jbe    f011b403 <test_kheap_phys_addr+0x2d7>
f011b3db:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b3e1:	83 ec 0c             	sub    $0xc,%esp
f011b3e4:	6a 00                	push   $0x0
f011b3e6:	e8 b1 e2 fe ff       	call   f010969c <sbrk>
f011b3eb:	83 c4 10             	add    $0x10,%esp
f011b3ee:	39 c3                	cmp    %eax,%ebx
f011b3f0:	73 11                	jae    f011b403 <test_kheap_phys_addr+0x2d7>
f011b3f2:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b3f8:	89 c2                	mov    %eax,%edx
f011b3fa:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b3ff:	39 c2                	cmp    %eax,%edx
f011b401:	72 17                	jb     f011b41a <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b403:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b40a:	83 ec 0c             	sub    $0xc,%esp
f011b40d:	68 b8 f3 12 f0       	push   $0xf012f3b8
f011b412:	e8 74 5b fe ff       	call   f0100f8b <cprintf>
f011b417:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b41a:	e8 74 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b41f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b422:	74 17                	je     f011b43b <test_kheap_phys_addr+0x30f>
f011b424:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b42b:	83 ec 0c             	sub    $0xc,%esp
f011b42e:	68 18 da 12 f0       	push   $0xf012da18
f011b433:	e8 53 5b fe ff       	call   f0100f8b <cprintf>
f011b438:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b43b:	e8 08 38 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b440:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b443:	e8 4b 96 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b448:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b44b:	83 ec 0c             	sub    $0xc,%esp
f011b44e:	68 00 06 00 00       	push   $0x600
f011b453:	e8 77 e3 fe ff       	call   f01097cf <kmalloc>
f011b458:	83 c4 10             	add    $0x10,%esp
f011b45b:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b461:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b467:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b46c:	76 28                	jbe    f011b496 <test_kheap_phys_addr+0x36a>
f011b46e:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011b474:	83 ec 0c             	sub    $0xc,%esp
f011b477:	6a 00                	push   $0x0
f011b479:	e8 1e e2 fe ff       	call   f010969c <sbrk>
f011b47e:	83 c4 10             	add    $0x10,%esp
f011b481:	39 c3                	cmp    %eax,%ebx
f011b483:	73 11                	jae    f011b496 <test_kheap_phys_addr+0x36a>
f011b485:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b48b:	89 c2                	mov    %eax,%edx
f011b48d:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b492:	39 c2                	cmp    %eax,%edx
f011b494:	72 17                	jb     f011b4ad <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b496:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b49d:	83 ec 0c             	sub    $0xc,%esp
f011b4a0:	68 44 f4 12 f0       	push   $0xf012f444
f011b4a5:	e8 e1 5a fe ff       	call   f0100f8b <cprintf>
f011b4aa:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b4ad:	e8 e1 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b4b2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b4b5:	74 17                	je     f011b4ce <test_kheap_phys_addr+0x3a2>
f011b4b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4be:	83 ec 0c             	sub    $0xc,%esp
f011b4c1:	68 24 db 12 f0       	push   $0xf012db24
f011b4c6:	e8 c0 5a fe ff       	call   f0100f8b <cprintf>
f011b4cb:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b4ce:	e8 75 37 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b4d3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b4d6:	e8 b8 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b4db:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b4de:	83 ec 0c             	sub    $0xc,%esp
f011b4e1:	68 00 1c 00 00       	push   $0x1c00
f011b4e6:	e8 e4 e2 fe ff       	call   f01097cf <kmalloc>
f011b4eb:	83 c4 10             	add    $0x10,%esp
f011b4ee:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b4f4:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b4fa:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b4ff:	74 17                	je     f011b518 <test_kheap_phys_addr+0x3ec>
f011b501:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b508:	83 ec 0c             	sub    $0xc,%esp
f011b50b:	68 dc db 12 f0       	push   $0xf012dbdc
f011b510:	e8 76 5a fe ff       	call   f0100f8b <cprintf>
f011b515:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b518:	e8 76 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b51d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b520:	74 17                	je     f011b539 <test_kheap_phys_addr+0x40d>
f011b522:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b529:	83 ec 0c             	sub    $0xc,%esp
f011b52c:	68 30 dc 12 f0       	push   $0xf012dc30
f011b531:	e8 55 5a fe ff       	call   f0100f8b <cprintf>
f011b536:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b539:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b53c:	e8 07 37 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b541:	29 c3                	sub    %eax,%ebx
f011b543:	89 d8                	mov    %ebx,%eax
f011b545:	83 f8 01             	cmp    $0x1,%eax
f011b548:	77 17                	ja     f011b561 <test_kheap_phys_addr+0x435>
f011b54a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b551:	83 ec 0c             	sub    $0xc,%esp
f011b554:	68 a0 dc 12 f0       	push   $0xf012dca0
f011b559:	e8 2d 5a fe ff       	call   f0100f8b <cprintf>
f011b55e:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b561:	e8 e2 36 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b566:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b569:	e8 25 95 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b56e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b571:	83 ec 0c             	sub    $0xc,%esp
f011b574:	68 00 fc 2f 00       	push   $0x2ffc00
f011b579:	e8 51 e2 fe ff       	call   f01097cf <kmalloc>
f011b57e:	83 c4 10             	add    $0x10,%esp
f011b581:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b587:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b58d:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b592:	74 17                	je     f011b5ab <test_kheap_phys_addr+0x47f>
f011b594:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b59b:	83 ec 0c             	sub    $0xc,%esp
f011b59e:	68 d0 f4 12 f0       	push   $0xf012f4d0
f011b5a3:	e8 e3 59 fe ff       	call   f0100f8b <cprintf>
f011b5a8:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5ab:	e8 e3 94 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b5b0:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b5b3:	74 17                	je     f011b5cc <test_kheap_phys_addr+0x4a0>
f011b5b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5bc:	83 ec 0c             	sub    $0xc,%esp
f011b5bf:	68 74 dd 12 f0       	push   $0xf012dd74
f011b5c4:	e8 c2 59 fe ff       	call   f0100f8b <cprintf>
f011b5c9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b5cc:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b5cf:	e8 74 36 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b5d4:	29 c3                	sub    %eax,%ebx
f011b5d6:	89 d8                	mov    %ebx,%eax
f011b5d8:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b5dd:	77 17                	ja     f011b5f6 <test_kheap_phys_addr+0x4ca>
f011b5df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5e6:	83 ec 0c             	sub    $0xc,%esp
f011b5e9:	68 24 f5 12 f0       	push   $0xf012f524
f011b5ee:	e8 98 59 fe ff       	call   f0100f8b <cprintf>
f011b5f3:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b5f6:	e8 4d 36 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b5fb:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b5fe:	e8 90 94 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b603:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b606:	83 ec 0c             	sub    $0xc,%esp
f011b609:	68 00 fc 5f 00       	push   $0x5ffc00
f011b60e:	e8 bc e1 fe ff       	call   f01097cf <kmalloc>
f011b613:	83 c4 10             	add    $0x10,%esp
f011b616:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b61c:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b622:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b627:	74 17                	je     f011b640 <test_kheap_phys_addr+0x514>
f011b629:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b630:	83 ec 0c             	sub    $0xc,%esp
f011b633:	68 6c f5 12 f0       	push   $0xf012f56c
f011b638:	e8 4e 59 fe ff       	call   f0100f8b <cprintf>
f011b63d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b640:	e8 4e 94 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b645:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b648:	74 17                	je     f011b661 <test_kheap_phys_addr+0x535>
f011b64a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b651:	83 ec 0c             	sub    $0xc,%esp
f011b654:	68 70 de 12 f0       	push   $0xf012de70
f011b659:	e8 2d 59 fe ff       	call   f0100f8b <cprintf>
f011b65e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b661:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b664:	e8 df 35 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b669:	29 c3                	sub    %eax,%ebx
f011b66b:	89 d8                	mov    %ebx,%eax
f011b66d:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b672:	77 17                	ja     f011b68b <test_kheap_phys_addr+0x55f>
f011b674:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b67b:	83 ec 0c             	sub    $0xc,%esp
f011b67e:	68 c0 f5 12 f0       	push   $0xf012f5c0
f011b683:	e8 03 59 fe ff       	call   f0100f8b <cprintf>
f011b688:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b68b:	e8 b8 35 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b690:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b693:	e8 fb 93 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b698:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b69b:	83 ec 0c             	sub    $0xc,%esp
f011b69e:	68 00 38 00 00       	push   $0x3800
f011b6a3:	e8 27 e1 fe ff       	call   f01097cf <kmalloc>
f011b6a8:	83 c4 10             	add    $0x10,%esp
f011b6ab:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b6b1:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011b6b7:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b6bc:	74 17                	je     f011b6d5 <test_kheap_phys_addr+0x5a9>
f011b6be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6c5:	83 ec 0c             	sub    $0xc,%esp
f011b6c8:	68 08 f6 12 f0       	push   $0xf012f608
f011b6cd:	e8 b9 58 fe ff       	call   f0100f8b <cprintf>
f011b6d2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b6d5:	e8 b9 93 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b6da:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b6dd:	74 17                	je     f011b6f6 <test_kheap_phys_addr+0x5ca>
f011b6df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6e6:	83 ec 0c             	sub    $0xc,%esp
f011b6e9:	68 5c f6 12 f0       	push   $0xf012f65c
f011b6ee:	e8 98 58 fe ff       	call   f0100f8b <cprintf>
f011b6f3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b6f6:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b6f9:	e8 4a 35 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b6fe:	29 c3                	sub    %eax,%ebx
f011b700:	89 d8                	mov    %ebx,%eax
f011b702:	83 f8 03             	cmp    $0x3,%eax
f011b705:	77 17                	ja     f011b71e <test_kheap_phys_addr+0x5f2>
f011b707:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b70e:	83 ec 0c             	sub    $0xc,%esp
f011b711:	68 cc f6 12 f0       	push   $0xf012f6cc
f011b716:	e8 70 58 fe ff       	call   f0100f8b <cprintf>
f011b71b:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011b71e:	83 ec 0c             	sub    $0xc,%esp
f011b721:	68 14 f7 12 f0       	push   $0xf012f714
f011b726:	e8 60 58 fe ff       	call   f0100f8b <cprintf>
f011b72b:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b72e:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b735:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011b73c:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b743:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011b748:	05 00 10 00 00       	add    $0x1000,%eax
f011b74d:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b750:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b753:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b756:	eb 2e                	jmp    f011b786 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b758:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b75b:	8d 43 01             	lea    0x1(%ebx),%eax
f011b75e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b761:	83 ec 0c             	sub    $0xc,%esp
f011b764:	ff 75 e8             	pushl  -0x18(%ebp)
f011b767:	e8 49 e4 fe ff       	call   f0109bb5 <kheap_physical_address>
f011b76c:	83 c4 10             	add    $0x10,%esp
f011b76f:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b776:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b779:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b77c:	01 d0                	add    %edx,%eax
f011b77e:	05 00 10 00 00       	add    $0x1000,%eax
f011b783:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b786:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b789:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b78c:	72 ca                	jb     f011b758 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b78e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b791:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011b794:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b79b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b79e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b7a1:	e9 ce 00 00 00       	jmp    f011b874 <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b7a6:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011b7ab:	83 ec 04             	sub    $0x4,%esp
f011b7ae:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b7b4:	52                   	push   %edx
f011b7b5:	ff 75 e8             	pushl  -0x18(%ebp)
f011b7b8:	50                   	push   %eax
f011b7b9:	e8 5c cf fe ff       	call   f010871a <get_page_table>
f011b7be:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b7c1:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b7c7:	85 c0                	test   %eax,%eax
f011b7c9:	75 1e                	jne    f011b7e9 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b7cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b7d2:	83 ec 04             	sub    $0x4,%esp
f011b7d5:	68 60 f7 12 f0       	push   $0xf012f760
f011b7da:	68 e7 05 00 00       	push   $0x5e7
f011b7df:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011b7e4:	e8 50 4b fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b7e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b7ec:	c1 e8 0c             	shr    $0xc,%eax
f011b7ef:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b7f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b7f7:	eb 62                	jmp    f011b85b <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011b7f9:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b7ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b802:	c1 e2 02             	shl    $0x2,%edx
f011b805:	01 d0                	add    %edx,%eax
f011b807:	8b 00                	mov    (%eax),%eax
f011b809:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b80e:	89 c2                	mov    %eax,%edx
f011b810:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b813:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b818:	01 c2                	add    %eax,%edx
f011b81a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b81d:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b824:	39 c2                	cmp    %eax,%edx
f011b826:	74 1d                	je     f011b845 <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b828:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b82c:	74 17                	je     f011b845 <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011b82e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b835:	83 ec 0c             	sub    $0xc,%esp
f011b838:	68 c0 f7 12 f0       	push   $0xf012f7c0
f011b83d:	e8 49 57 fe ff       	call   f0100f8b <cprintf>
f011b842:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011b845:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b848:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b84b:	01 d0                	add    %edx,%eax
f011b84d:	05 00 10 00 00       	add    $0x1000,%eax
f011b852:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b855:	ff 45 e4             	incl   -0x1c(%ebp)
f011b858:	ff 45 f4             	incl   -0xc(%ebp)
f011b85b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b85e:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011b861:	7d 11                	jge    f011b874 <test_kheap_phys_addr+0x748>
f011b863:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011b86a:	7f 08                	jg     f011b874 <test_kheap_phys_addr+0x748>
f011b86c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b86f:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b872:	72 85                	jb     f011b7f9 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b874:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b877:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b87a:	0f 82 26 ff ff ff    	jb     f011b7a6 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011b880:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b884:	74 04                	je     f011b88a <test_kheap_phys_addr+0x75e>
f011b886:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b88a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011b891:	83 ec 0c             	sub    $0xc,%esp
f011b894:	68 e4 f7 12 f0       	push   $0xf012f7e4
f011b899:	e8 ed 56 fe ff       	call   f0100f8b <cprintf>
f011b89e:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b8a1:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011b8a8:	e9 b0 00 00 00       	jmp    f011b95d <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011b8ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b8b0:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011b8b7:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011b8ba:	83 ec 0c             	sub    $0xc,%esp
f011b8bd:	ff 75 90             	pushl  -0x70(%ebp)
f011b8c0:	e8 f0 e2 fe ff       	call   f0109bb5 <kheap_physical_address>
f011b8c5:	83 c4 10             	add    $0x10,%esp
f011b8c8:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b8cb:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011b8d0:	83 ec 04             	sub    $0x4,%esp
f011b8d3:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b8d9:	52                   	push   %edx
f011b8da:	ff 75 90             	pushl  -0x70(%ebp)
f011b8dd:	50                   	push   %eax
f011b8de:	e8 37 ce fe ff       	call   f010871a <get_page_table>
f011b8e3:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b8e6:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b8ec:	85 c0                	test   %eax,%eax
f011b8ee:	75 1e                	jne    f011b90e <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b8f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b8f7:	83 ec 04             	sub    $0x4,%esp
f011b8fa:	68 34 f8 12 f0       	push   $0xf012f834
f011b8ff:	68 04 06 00 00       	push   $0x604
f011b904:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011b909:	e8 2b 4a fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b90e:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b914:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b917:	c1 ea 0c             	shr    $0xc,%edx
f011b91a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b920:	c1 e2 02             	shl    $0x2,%edx
f011b923:	01 d0                	add    %edx,%eax
f011b925:	8b 00                	mov    (%eax),%eax
f011b927:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b92c:	89 c2                	mov    %eax,%edx
f011b92e:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b931:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b936:	01 d0                	add    %edx,%eax
f011b938:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b93b:	74 1d                	je     f011b95a <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b93d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b941:	74 17                	je     f011b95a <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011b943:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b94a:	83 ec 0c             	sub    $0xc,%esp
f011b94d:	68 94 f8 12 f0       	push   $0xf012f894
f011b952:	e8 34 56 fe ff       	call   f0100f8b <cprintf>
f011b957:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b95a:	ff 45 e0             	incl   -0x20(%ebp)
f011b95d:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011b961:	0f 8e 46 ff ff ff    	jle    f011b8ad <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011b967:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b96b:	74 04                	je     f011b971 <test_kheap_phys_addr+0x845>
f011b96d:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011b971:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011b978:	83 ec 0c             	sub    $0xc,%esp
f011b97b:	68 b8 f8 12 f0       	push   $0xf012f8b8
f011b980:	e8 06 56 fe ff       	call   f0100f8b <cprintf>
f011b985:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b988:	e8 bb 32 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b98d:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b990:	e8 fe 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b995:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b998:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b99e:	83 ec 0c             	sub    $0xc,%esp
f011b9a1:	50                   	push   %eax
f011b9a2:	e8 e8 e0 fe ff       	call   f0109a8f <kfree>
f011b9a7:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b9aa:	e8 e4 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011b9af:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b9b2:	74 17                	je     f011b9cb <test_kheap_phys_addr+0x89f>
f011b9b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9bb:	83 ec 0c             	sub    $0xc,%esp
f011b9be:	68 a4 e3 12 f0       	push   $0xf012e3a4
f011b9c3:	e8 c3 55 fe ff       	call   f0100f8b <cprintf>
f011b9c8:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b9cb:	e8 78 32 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b9d0:	89 c2                	mov    %eax,%edx
f011b9d2:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b9d5:	29 c2                	sub    %eax,%edx
f011b9d7:	89 d0                	mov    %edx,%eax
f011b9d9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b9de:	77 17                	ja     f011b9f7 <test_kheap_phys_addr+0x8cb>
f011b9e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9e7:	83 ec 0c             	sub    $0xc,%esp
f011b9ea:	68 e0 f8 12 f0       	push   $0xf012f8e0
f011b9ef:	e8 97 55 fe ff       	call   f0100f8b <cprintf>
f011b9f4:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b9f7:	e8 4c 32 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011b9fc:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b9ff:	e8 8f 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ba04:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011ba07:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011ba0d:	83 ec 0c             	sub    $0xc,%esp
f011ba10:	50                   	push   %eax
f011ba11:	e8 79 e0 fe ff       	call   f0109a8f <kfree>
f011ba16:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba19:	e8 75 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ba1e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ba21:	74 17                	je     f011ba3a <test_kheap_phys_addr+0x90e>
f011ba23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba2a:	83 ec 0c             	sub    $0xc,%esp
f011ba2d:	68 e4 e4 12 f0       	push   $0xf012e4e4
f011ba32:	e8 54 55 fe ff       	call   f0100f8b <cprintf>
f011ba37:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011ba3a:	e8 09 32 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ba3f:	89 c2                	mov    %eax,%edx
f011ba41:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ba44:	29 c2                	sub    %eax,%edx
f011ba46:	89 d0                	mov    %edx,%eax
f011ba48:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ba4d:	77 17                	ja     f011ba66 <test_kheap_phys_addr+0x93a>
f011ba4f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba56:	83 ec 0c             	sub    $0xc,%esp
f011ba59:	68 1c f9 12 f0       	push   $0xf012f91c
f011ba5e:	e8 28 55 fe ff       	call   f0100f8b <cprintf>
f011ba63:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011ba66:	e8 dd 31 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ba6b:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ba6e:	e8 20 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ba73:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011ba76:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011ba7c:	83 ec 0c             	sub    $0xc,%esp
f011ba7f:	50                   	push   %eax
f011ba80:	e8 0a e0 fe ff       	call   f0109a8f <kfree>
f011ba85:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba88:	e8 06 90 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ba8d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ba90:	74 17                	je     f011baa9 <test_kheap_phys_addr+0x97d>
f011ba92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba99:	83 ec 0c             	sub    $0xc,%esp
f011ba9c:	68 f0 e5 12 f0       	push   $0xf012e5f0
f011baa1:	e8 e5 54 fe ff       	call   f0100f8b <cprintf>
f011baa6:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011baa9:	e8 9a 31 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011baae:	89 c2                	mov    %eax,%edx
f011bab0:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bab3:	29 c2                	sub    %eax,%edx
f011bab5:	89 d0                	mov    %edx,%eax
f011bab7:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011babc:	77 17                	ja     f011bad5 <test_kheap_phys_addr+0x9a9>
f011babe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bac5:	83 ec 0c             	sub    $0xc,%esp
f011bac8:	68 58 f9 12 f0       	push   $0xf012f958
f011bacd:	e8 b9 54 fe ff       	call   f0100f8b <cprintf>
f011bad2:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011bad5:	83 ec 0c             	sub    $0xc,%esp
f011bad8:	68 94 f9 12 f0       	push   $0xf012f994
f011badd:	e8 a9 54 fe ff       	call   f0100f8b <cprintf>
f011bae2:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011bae5:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011baec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011baf3:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011bafa:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011bafd:	8b 15 38 0e 18 f0    	mov    0xf0180e38,%edx
f011bb03:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011bb09:	01 d0                	add    %edx,%eax
f011bb0b:	05 00 10 00 00       	add    $0x1000,%eax
f011bb10:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011bb16:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bb1c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011bb1f:	eb 25                	jmp    f011bb46 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011bb21:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011bb24:	8d 43 01             	lea    0x1(%ebx),%eax
f011bb27:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011bb2a:	83 ec 0c             	sub    $0xc,%esp
f011bb2d:	ff 75 d8             	pushl  -0x28(%ebp)
f011bb30:	e8 80 e0 fe ff       	call   f0109bb5 <kheap_physical_address>
f011bb35:	83 c4 10             	add    $0x10,%esp
f011bb38:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011bb3f:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011bb46:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bb49:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011bb4c:	72 d3                	jb     f011bb21 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011bb4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bb51:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011bb57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011bb5e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bb64:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011bb67:	e9 f4 00 00 00       	jmp    f011bc60 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bb6c:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011bb71:	83 ec 04             	sub    $0x4,%esp
f011bb74:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011bb7a:	52                   	push   %edx
f011bb7b:	ff 75 d8             	pushl  -0x28(%ebp)
f011bb7e:	50                   	push   %eax
f011bb7f:	e8 96 cb fe ff       	call   f010871a <get_page_table>
f011bb84:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bb87:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bb8d:	85 c0                	test   %eax,%eax
f011bb8f:	75 24                	jne    f011bbb5 <test_kheap_phys_addr+0xa89>
				if (correct)
f011bb91:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bb95:	74 1e                	je     f011bbb5 <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bb97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb9e:	83 ec 04             	sub    $0x4,%esp
f011bba1:	68 e4 f9 12 f0       	push   $0xf012f9e4
f011bba6:	68 42 06 00 00       	push   $0x642
f011bbab:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011bbb0:	e8 84 47 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bbb5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bbb8:	c1 e8 0c             	shr    $0xc,%eax
f011bbbb:	25 ff 03 00 00       	and    $0x3ff,%eax
f011bbc0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011bbc3:	eb 7b                	jmp    f011bc40 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011bbc5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011bbcc:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bbd2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011bbd5:	c1 e2 02             	shl    $0x2,%edx
f011bbd8:	01 d0                	add    %edx,%eax
f011bbda:	8b 00                	mov    (%eax),%eax
f011bbdc:	83 e0 01             	and    $0x1,%eax
f011bbdf:	85 c0                	test   %eax,%eax
f011bbe1:	74 24                	je     f011bc07 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011bbe3:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011bbe9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011bbec:	c1 e2 02             	shl    $0x2,%edx
f011bbef:	01 d0                	add    %edx,%eax
f011bbf1:	8b 00                	mov    (%eax),%eax
f011bbf3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bbf8:	89 c2                	mov    %eax,%edx
f011bbfa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bbfd:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bc02:	01 d0                	add    %edx,%eax
f011bc04:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011bc07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bc0a:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011bc11:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011bc14:	74 1d                	je     f011bc33 <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bc16:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bc1a:	74 17                	je     f011bc33 <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011bc1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc23:	83 ec 0c             	sub    $0xc,%esp
f011bc26:	68 44 fa 12 f0       	push   $0xf012fa44
f011bc2b:	e8 5b 53 fe ff       	call   f0100f8b <cprintf>
f011bc30:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011bc33:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bc3a:	ff 45 d4             	incl   -0x2c(%ebp)
f011bc3d:	ff 45 f4             	incl   -0xc(%ebp)
f011bc40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bc43:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011bc49:	7d 15                	jge    f011bc60 <test_kheap_phys_addr+0xb34>
f011bc4b:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011bc52:	7f 0c                	jg     f011bc60 <test_kheap_phys_addr+0xb34>
f011bc54:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bc57:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011bc5a:	0f 82 65 ff ff ff    	jb     f011bbc5 <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bc60:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bc63:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011bc66:	0f 82 00 ff ff ff    	jb     f011bb6c <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011bc6c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bc70:	74 04                	je     f011bc76 <test_kheap_phys_addr+0xb4a>
f011bc72:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011bc76:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011bc7d:	83 ec 0c             	sub    $0xc,%esp
f011bc80:	68 68 fa 12 f0       	push   $0xf012fa68
f011bc85:	e8 01 53 fe ff       	call   f0100f8b <cprintf>
f011bc8a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011bc8d:	83 ec 0c             	sub    $0xc,%esp
f011bc90:	6a 00                	push   $0x0
f011bc92:	e8 05 da fe ff       	call   f010969c <sbrk>
f011bc97:	83 c4 10             	add    $0x10,%esp
f011bc9a:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011bc9f:	77 17                	ja     f011bcb8 <test_kheap_phys_addr+0xb8c>
f011bca1:	83 ec 04             	sub    $0x4,%esp
f011bca4:	68 c0 fa 12 f0       	push   $0xf012fac0
f011bca9:	68 5d 06 00 00       	push   $0x65d
f011bcae:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011bcb3:	e8 81 46 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011bcb8:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011bcbf:	e9 af 00 00 00       	jmp    f011bd73 <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011bcc4:	83 ec 0c             	sub    $0xc,%esp
f011bcc7:	ff 75 d0             	pushl  -0x30(%ebp)
f011bcca:	e8 e6 de fe ff       	call   f0109bb5 <kheap_physical_address>
f011bccf:	83 c4 10             	add    $0x10,%esp
f011bcd2:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bcd8:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011bcdd:	83 ec 04             	sub    $0x4,%esp
f011bce0:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011bce6:	52                   	push   %edx
f011bce7:	ff 75 d0             	pushl  -0x30(%ebp)
f011bcea:	50                   	push   %eax
f011bceb:	e8 2a ca fe ff       	call   f010871a <get_page_table>
f011bcf0:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bcf3:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011bcf9:	85 c0                	test   %eax,%eax
f011bcfb:	75 24                	jne    f011bd21 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011bcfd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bd01:	74 1e                	je     f011bd21 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bd03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd0a:	83 ec 04             	sub    $0x4,%esp
f011bd0d:	68 dc fa 12 f0       	push   $0xf012fadc
f011bd12:	68 65 06 00 00       	push   $0x665
f011bd17:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011bd1c:	e8 18 46 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011bd21:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011bd27:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bd2a:	c1 ea 0c             	shr    $0xc,%edx
f011bd2d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011bd33:	c1 e2 02             	shl    $0x2,%edx
f011bd36:	01 d0                	add    %edx,%eax
f011bd38:	8b 00                	mov    (%eax),%eax
f011bd3a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bd3f:	89 c2                	mov    %eax,%edx
f011bd41:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bd44:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bd49:	01 d0                	add    %edx,%eax
f011bd4b:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011bd51:	74 1d                	je     f011bd70 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011bd53:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bd57:	74 17                	je     f011bd70 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011bd59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd60:	83 ec 0c             	sub    $0xc,%esp
f011bd63:	68 3c fb 12 f0       	push   $0xf012fb3c
f011bd68:	e8 1e 52 fe ff       	call   f0100f8b <cprintf>
f011bd6d:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011bd70:	ff 45 d0             	incl   -0x30(%ebp)
f011bd73:	83 ec 0c             	sub    $0xc,%esp
f011bd76:	6a 00                	push   $0x0
f011bd78:	e8 1f d9 fe ff       	call   f010969c <sbrk>
f011bd7d:	83 c4 10             	add    $0x10,%esp
f011bd80:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011bd83:	0f 87 3b ff ff ff    	ja     f011bcc4 <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011bd89:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bd8d:	74 04                	je     f011bd93 <test_kheap_phys_addr+0xc67>
f011bd8f:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011bd93:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011bd9a:	83 ec 0c             	sub    $0xc,%esp
f011bd9d:	68 60 fb 12 f0       	push   $0xf012fb60
f011bda2:	e8 e4 51 fe ff       	call   f0100f8b <cprintf>
f011bda7:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011bdaa:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011bdb1:	10 00 f9 
		i = 0;
f011bdb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011bdbb:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bdc1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011bdc4:	eb 0a                	jmp    f011bdd0 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011bdc6:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011bdc9:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011bdd0:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011bdd7:	76 ed                	jbe    f011bdc6 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011bdd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bddc:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011bde2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011bde9:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bdef:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011bdf2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011bdf9:	e9 cb 00 00 00       	jmp    f011bec9 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011bdfe:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011be01:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011be06:	83 ec 04             	sub    $0x4,%esp
f011be09:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011be0f:	51                   	push   %ecx
f011be10:	52                   	push   %edx
f011be11:	50                   	push   %eax
f011be12:	e8 03 c9 fe ff       	call   f010871a <get_page_table>
f011be17:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011be1a:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011be20:	85 c0                	test   %eax,%eax
f011be22:	75 24                	jne    f011be48 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011be24:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011be28:	74 1e                	je     f011be48 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011be2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be31:	83 ec 04             	sub    $0x4,%esp
f011be34:	68 9c fb 12 f0       	push   $0xf012fb9c
f011be39:	68 87 06 00 00       	push   $0x687
f011be3e:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011be43:	e8 f1 44 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011be48:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011be4f:	eb 59                	jmp    f011beaa <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011be51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011be54:	c1 e0 0c             	shl    $0xc,%eax
f011be57:	89 c2                	mov    %eax,%edx
f011be59:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011be5f:	01 d0                	add    %edx,%eax
f011be61:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011be67:	83 ec 0c             	sub    $0xc,%esp
f011be6a:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011be70:	e8 40 dd fe ff       	call   f0109bb5 <kheap_physical_address>
f011be75:	83 c4 10             	add    $0x10,%esp
f011be78:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011be7e:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011be85:	74 1d                	je     f011bea4 <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011be87:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011be8b:	74 17                	je     f011bea4 <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011be8d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be94:	83 ec 0c             	sub    $0xc,%esp
f011be97:	68 fc fb 12 f0       	push   $0xf012fbfc
f011be9c:	e8 ea 50 fe ff       	call   f0100f8b <cprintf>
f011bea1:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bea4:	ff 45 c8             	incl   -0x38(%ebp)
f011bea7:	ff 45 f4             	incl   -0xc(%ebp)
f011beaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bead:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011beb3:	7d 09                	jge    f011bebe <test_kheap_phys_addr+0xd92>
f011beb5:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011bebc:	7e 93                	jle    f011be51 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011bebe:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011bec5:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011bec9:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011becd:	0f 88 2b ff ff ff    	js     f011bdfe <test_kheap_phys_addr+0xcd2>
f011bed3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bed7:	7f 0d                	jg     f011bee6 <test_kheap_phys_addr+0xdba>
f011bed9:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011bee0:	0f 86 18 ff ff ff    	jbe    f011bdfe <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011bee6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011beea:	74 04                	je     f011bef0 <test_kheap_phys_addr+0xdc4>
f011beec:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011bef0:	83 ec 08             	sub    $0x8,%esp
f011bef3:	ff 75 f0             	pushl  -0x10(%ebp)
f011bef6:	68 20 fc 12 f0       	push   $0xf012fc20
f011befb:	e8 8b 50 fe ff       	call   f0100f8b <cprintf>
f011bf00:	83 c4 10             	add    $0x10,%esp

	return 1;
f011bf03:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011bf08:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011bf0b:	5b                   	pop    %ebx
f011bf0c:	5f                   	pop    %edi
f011bf0d:	5d                   	pop    %ebp
f011bf0e:	c3                   	ret    

f011bf0f <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011bf0f:	55                   	push   %ebp
f011bf10:	89 e5                	mov    %esp,%ebp
f011bf12:	57                   	push   %edi
f011bf13:	56                   	push   %esi
f011bf14:	53                   	push   %ebx
f011bf15:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011bf1b:	89 e0                	mov    %esp,%eax
f011bf1d:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011bf1f:	83 ec 0c             	sub    $0xc,%esp
f011bf22:	68 a8 b5 12 f0       	push   $0xf012b5a8
f011bf27:	e8 5f 50 fe ff       	call   f0100f8b <cprintf>
f011bf2c:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011bf2f:	83 ec 0c             	sub    $0xc,%esp
f011bf32:	68 d8 b5 12 f0       	push   $0xf012b5d8
f011bf37:	e8 4f 50 fe ff       	call   f0100f8b <cprintf>
f011bf3c:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011bf3f:	83 ec 0c             	sub    $0xc,%esp
f011bf42:	68 a8 b5 12 f0       	push   $0xf012b5a8
f011bf47:	e8 3f 50 fe ff       	call   f0100f8b <cprintf>
f011bf4c:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011bf4f:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011bf53:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011bf57:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011bf5d:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011bf63:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011bf6a:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011bf71:	e8 d2 2c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011bf76:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011bf79:	83 ec 0c             	sub    $0xc,%esp
f011bf7c:	68 fc f2 12 f0       	push   $0xf012f2fc
f011bf81:	e8 05 50 fe ff       	call   f0100f8b <cprintf>
f011bf86:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011bf89:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011bf8f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bf94:	b8 00 00 00 00       	mov    $0x0,%eax
f011bf99:	89 d7                	mov    %edx,%edi
f011bf9b:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011bf9d:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011bfa3:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bfa8:	b8 00 00 00 00       	mov    $0x0,%eax
f011bfad:	89 d7                	mov    %edx,%edi
f011bfaf:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011bfb1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011bfb8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011bfbf:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bfc5:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bfca:	b8 00 00 00 00       	mov    $0x0,%eax
f011bfcf:	89 d7                	mov    %edx,%edi
f011bfd1:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bfd3:	e8 70 2c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011bfd8:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bfdb:	e8 b3 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011bfe0:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011bfe3:	83 ec 0c             	sub    $0xc,%esp
f011bfe6:	68 00 fc 1f 00       	push   $0x1ffc00
f011bfeb:	e8 df d7 fe ff       	call   f01097cf <kmalloc>
f011bff0:	83 c4 10             	add    $0x10,%esp
f011bff3:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bff9:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bfff:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011c004:	74 17                	je     f011c01d <test_kheap_virt_addr+0x10e>
f011c006:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c00d:	83 ec 0c             	sub    $0xc,%esp
f011c010:	68 a0 d6 12 f0       	push   $0xf012d6a0
f011c015:	e8 71 4f fe ff       	call   f0100f8b <cprintf>
f011c01a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c01d:	e8 71 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c022:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c025:	74 17                	je     f011c03e <test_kheap_virt_addr+0x12f>
f011c027:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c02e:	83 ec 0c             	sub    $0xc,%esp
f011c031:	68 f4 d6 12 f0       	push   $0xf012d6f4
f011c036:	e8 50 4f fe ff       	call   f0100f8b <cprintf>
f011c03b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c03e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c041:	e8 02 2c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c046:	29 c3                	sub    %eax,%ebx
f011c048:	89 d8                	mov    %ebx,%eax
f011c04a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c04f:	77 17                	ja     f011c068 <test_kheap_virt_addr+0x159>
f011c051:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c058:	83 ec 0c             	sub    $0xc,%esp
f011c05b:	68 64 d7 12 f0       	push   $0xf012d764
f011c060:	e8 26 4f fe ff       	call   f0100f8b <cprintf>
f011c065:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c068:	e8 db 2b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c06d:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c070:	e8 1e 8a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c075:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011c078:	83 ec 0c             	sub    $0xc,%esp
f011c07b:	68 00 fc 1f 00       	push   $0x1ffc00
f011c080:	e8 4a d7 fe ff       	call   f01097cf <kmalloc>
f011c085:	83 c4 10             	add    $0x10,%esp
f011c088:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c08e:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c094:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011c099:	74 17                	je     f011c0b2 <test_kheap_virt_addr+0x1a3>
f011c09b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0a2:	83 ec 0c             	sub    $0xc,%esp
f011c0a5:	68 ac d7 12 f0       	push   $0xf012d7ac
f011c0aa:	e8 dc 4e fe ff       	call   f0100f8b <cprintf>
f011c0af:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c0b2:	e8 dc 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c0b7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c0ba:	74 17                	je     f011c0d3 <test_kheap_virt_addr+0x1c4>
f011c0bc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0c3:	83 ec 0c             	sub    $0xc,%esp
f011c0c6:	68 00 d8 12 f0       	push   $0xf012d800
f011c0cb:	e8 bb 4e fe ff       	call   f0100f8b <cprintf>
f011c0d0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c0d3:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c0d6:	e8 6d 2b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c0db:	29 c3                	sub    %eax,%ebx
f011c0dd:	89 d8                	mov    %ebx,%eax
f011c0df:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c0e4:	77 17                	ja     f011c0fd <test_kheap_virt_addr+0x1ee>
f011c0e6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0ed:	83 ec 0c             	sub    $0xc,%esp
f011c0f0:	68 70 d8 12 f0       	push   $0xf012d870
f011c0f5:	e8 91 4e fe ff       	call   f0100f8b <cprintf>
f011c0fa:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011c0fd:	e8 46 2b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c102:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c105:	e8 89 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c10a:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011c10d:	83 ec 0c             	sub    $0xc,%esp
f011c110:	68 00 04 00 00       	push   $0x400
f011c115:	e8 b5 d6 fe ff       	call   f01097cf <kmalloc>
f011c11a:	83 c4 10             	add    $0x10,%esp
f011c11d:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011c123:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c129:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c12e:	76 28                	jbe    f011c158 <test_kheap_virt_addr+0x249>
f011c130:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011c136:	83 ec 0c             	sub    $0xc,%esp
f011c139:	6a 00                	push   $0x0
f011c13b:	e8 5c d5 fe ff       	call   f010969c <sbrk>
f011c140:	83 c4 10             	add    $0x10,%esp
f011c143:	39 c3                	cmp    %eax,%ebx
f011c145:	73 11                	jae    f011c158 <test_kheap_virt_addr+0x249>
f011c147:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c14d:	89 c2                	mov    %eax,%edx
f011c14f:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c154:	39 c2                	cmp    %eax,%edx
f011c156:	72 17                	jb     f011c16f <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c158:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c15f:	83 ec 0c             	sub    $0xc,%esp
f011c162:	68 2c f3 12 f0       	push   $0xf012f32c
f011c167:	e8 1f 4e fe ff       	call   f0100f8b <cprintf>
f011c16c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c16f:	e8 1f 89 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c174:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c177:	74 17                	je     f011c190 <test_kheap_virt_addr+0x281>
f011c179:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c180:	83 ec 0c             	sub    $0xc,%esp
f011c183:	68 0c d9 12 f0       	push   $0xf012d90c
f011c188:	e8 fe 4d fe ff       	call   f0100f8b <cprintf>
f011c18d:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c190:	e8 b3 2a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c195:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c198:	e8 f6 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c19d:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c1a0:	83 ec 0c             	sub    $0xc,%esp
f011c1a3:	68 00 08 00 00       	push   $0x800
f011c1a8:	e8 22 d6 fe ff       	call   f01097cf <kmalloc>
f011c1ad:	83 c4 10             	add    $0x10,%esp
f011c1b0:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c1b6:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c1bc:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c1c1:	76 28                	jbe    f011c1eb <test_kheap_virt_addr+0x2dc>
f011c1c3:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011c1c9:	83 ec 0c             	sub    $0xc,%esp
f011c1cc:	6a 00                	push   $0x0
f011c1ce:	e8 c9 d4 fe ff       	call   f010969c <sbrk>
f011c1d3:	83 c4 10             	add    $0x10,%esp
f011c1d6:	39 c3                	cmp    %eax,%ebx
f011c1d8:	73 11                	jae    f011c1eb <test_kheap_virt_addr+0x2dc>
f011c1da:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c1e0:	89 c2                	mov    %eax,%edx
f011c1e2:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c1e7:	39 c2                	cmp    %eax,%edx
f011c1e9:	72 17                	jb     f011c202 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c1eb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1f2:	83 ec 0c             	sub    $0xc,%esp
f011c1f5:	68 b8 f3 12 f0       	push   $0xf012f3b8
f011c1fa:	e8 8c 4d fe ff       	call   f0100f8b <cprintf>
f011c1ff:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c202:	e8 8c 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c207:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c20a:	74 17                	je     f011c223 <test_kheap_virt_addr+0x314>
f011c20c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c213:	83 ec 0c             	sub    $0xc,%esp
f011c216:	68 18 da 12 f0       	push   $0xf012da18
f011c21b:	e8 6b 4d fe ff       	call   f0100f8b <cprintf>
f011c220:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011c223:	e8 20 2a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c228:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c22b:	e8 63 88 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c230:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011c233:	83 ec 0c             	sub    $0xc,%esp
f011c236:	68 00 06 00 00       	push   $0x600
f011c23b:	e8 8f d5 fe ff       	call   f01097cf <kmalloc>
f011c240:	83 c4 10             	add    $0x10,%esp
f011c243:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011c249:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c24f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c254:	76 28                	jbe    f011c27e <test_kheap_virt_addr+0x36f>
f011c256:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011c25c:	83 ec 0c             	sub    $0xc,%esp
f011c25f:	6a 00                	push   $0x0
f011c261:	e8 36 d4 fe ff       	call   f010969c <sbrk>
f011c266:	83 c4 10             	add    $0x10,%esp
f011c269:	39 c3                	cmp    %eax,%ebx
f011c26b:	73 11                	jae    f011c27e <test_kheap_virt_addr+0x36f>
f011c26d:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c273:	89 c2                	mov    %eax,%edx
f011c275:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c27a:	39 c2                	cmp    %eax,%edx
f011c27c:	72 17                	jb     f011c295 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c27e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c285:	83 ec 0c             	sub    $0xc,%esp
f011c288:	68 44 f4 12 f0       	push   $0xf012f444
f011c28d:	e8 f9 4c fe ff       	call   f0100f8b <cprintf>
f011c292:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c295:	e8 f9 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c29a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c29d:	74 17                	je     f011c2b6 <test_kheap_virt_addr+0x3a7>
f011c29f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2a6:	83 ec 0c             	sub    $0xc,%esp
f011c2a9:	68 24 db 12 f0       	push   $0xf012db24
f011c2ae:	e8 d8 4c fe ff       	call   f0100f8b <cprintf>
f011c2b3:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011c2b6:	e8 8d 29 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c2bb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c2be:	e8 d0 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c2c3:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011c2c6:	83 ec 0c             	sub    $0xc,%esp
f011c2c9:	68 00 1c 00 00       	push   $0x1c00
f011c2ce:	e8 fc d4 fe ff       	call   f01097cf <kmalloc>
f011c2d3:	83 c4 10             	add    $0x10,%esp
f011c2d6:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c2dc:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011c2e2:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011c2e7:	74 17                	je     f011c300 <test_kheap_virt_addr+0x3f1>
f011c2e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2f0:	83 ec 0c             	sub    $0xc,%esp
f011c2f3:	68 dc db 12 f0       	push   $0xf012dbdc
f011c2f8:	e8 8e 4c fe ff       	call   f0100f8b <cprintf>
f011c2fd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c300:	e8 8e 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c305:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c308:	74 17                	je     f011c321 <test_kheap_virt_addr+0x412>
f011c30a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c311:	83 ec 0c             	sub    $0xc,%esp
f011c314:	68 30 dc 12 f0       	push   $0xf012dc30
f011c319:	e8 6d 4c fe ff       	call   f0100f8b <cprintf>
f011c31e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c321:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c324:	e8 1f 29 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c329:	29 c3                	sub    %eax,%ebx
f011c32b:	89 d8                	mov    %ebx,%eax
f011c32d:	83 f8 01             	cmp    $0x1,%eax
f011c330:	77 17                	ja     f011c349 <test_kheap_virt_addr+0x43a>
f011c332:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c339:	83 ec 0c             	sub    $0xc,%esp
f011c33c:	68 a0 dc 12 f0       	push   $0xf012dca0
f011c341:	e8 45 4c fe ff       	call   f0100f8b <cprintf>
f011c346:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011c349:	e8 fa 28 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c34e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c351:	e8 3d 87 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c356:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011c359:	83 ec 0c             	sub    $0xc,%esp
f011c35c:	68 00 fc 2f 00       	push   $0x2ffc00
f011c361:	e8 69 d4 fe ff       	call   f01097cf <kmalloc>
f011c366:	83 c4 10             	add    $0x10,%esp
f011c369:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c36f:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011c375:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011c37a:	74 17                	je     f011c393 <test_kheap_virt_addr+0x484>
f011c37c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c383:	83 ec 0c             	sub    $0xc,%esp
f011c386:	68 d0 f4 12 f0       	push   $0xf012f4d0
f011c38b:	e8 fb 4b fe ff       	call   f0100f8b <cprintf>
f011c390:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c393:	e8 fb 86 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c398:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c39b:	74 17                	je     f011c3b4 <test_kheap_virt_addr+0x4a5>
f011c39d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3a4:	83 ec 0c             	sub    $0xc,%esp
f011c3a7:	68 74 dd 12 f0       	push   $0xf012dd74
f011c3ac:	e8 da 4b fe ff       	call   f0100f8b <cprintf>
f011c3b1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c3b4:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c3b7:	e8 8c 28 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c3bc:	29 c3                	sub    %eax,%ebx
f011c3be:	89 d8                	mov    %ebx,%eax
f011c3c0:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011c3c5:	77 17                	ja     f011c3de <test_kheap_virt_addr+0x4cf>
f011c3c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3ce:	83 ec 0c             	sub    $0xc,%esp
f011c3d1:	68 24 f5 12 f0       	push   $0xf012f524
f011c3d6:	e8 b0 4b fe ff       	call   f0100f8b <cprintf>
f011c3db:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c3de:	e8 65 28 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c3e3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c3e6:	e8 a8 86 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c3eb:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011c3ee:	83 ec 0c             	sub    $0xc,%esp
f011c3f1:	68 00 fc 5f 00       	push   $0x5ffc00
f011c3f6:	e8 d4 d3 fe ff       	call   f01097cf <kmalloc>
f011c3fb:	83 c4 10             	add    $0x10,%esp
f011c3fe:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c404:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c40a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c40f:	74 17                	je     f011c428 <test_kheap_virt_addr+0x519>
f011c411:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c418:	83 ec 0c             	sub    $0xc,%esp
f011c41b:	68 6c f5 12 f0       	push   $0xf012f56c
f011c420:	e8 66 4b fe ff       	call   f0100f8b <cprintf>
f011c425:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c428:	e8 66 86 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c42d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c430:	74 17                	je     f011c449 <test_kheap_virt_addr+0x53a>
f011c432:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c439:	83 ec 0c             	sub    $0xc,%esp
f011c43c:	68 70 de 12 f0       	push   $0xf012de70
f011c441:	e8 45 4b fe ff       	call   f0100f8b <cprintf>
f011c446:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c449:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c44c:	e8 f7 27 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c451:	29 c3                	sub    %eax,%ebx
f011c453:	89 d8                	mov    %ebx,%eax
f011c455:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c45a:	77 17                	ja     f011c473 <test_kheap_virt_addr+0x564>
f011c45c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c463:	83 ec 0c             	sub    $0xc,%esp
f011c466:	68 c0 f5 12 f0       	push   $0xf012f5c0
f011c46b:	e8 1b 4b fe ff       	call   f0100f8b <cprintf>
f011c470:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011c473:	e8 d0 27 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c478:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c47b:	e8 13 86 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c480:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011c483:	83 ec 0c             	sub    $0xc,%esp
f011c486:	68 00 38 00 00       	push   $0x3800
f011c48b:	e8 3f d3 fe ff       	call   f01097cf <kmalloc>
f011c490:	83 c4 10             	add    $0x10,%esp
f011c493:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c499:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c49f:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c4a4:	74 17                	je     f011c4bd <test_kheap_virt_addr+0x5ae>
f011c4a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4ad:	83 ec 0c             	sub    $0xc,%esp
f011c4b0:	68 08 f6 12 f0       	push   $0xf012f608
f011c4b5:	e8 d1 4a fe ff       	call   f0100f8b <cprintf>
f011c4ba:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c4bd:	e8 d1 85 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c4c2:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c4c5:	74 17                	je     f011c4de <test_kheap_virt_addr+0x5cf>
f011c4c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4ce:	83 ec 0c             	sub    $0xc,%esp
f011c4d1:	68 5c f6 12 f0       	push   $0xf012f65c
f011c4d6:	e8 b0 4a fe ff       	call   f0100f8b <cprintf>
f011c4db:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c4de:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c4e1:	e8 62 27 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c4e6:	29 c3                	sub    %eax,%ebx
f011c4e8:	89 d8                	mov    %ebx,%eax
f011c4ea:	83 f8 03             	cmp    $0x3,%eax
f011c4ed:	77 17                	ja     f011c506 <test_kheap_virt_addr+0x5f7>
f011c4ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4f6:	83 ec 0c             	sub    $0xc,%esp
f011c4f9:	68 cc f6 12 f0       	push   $0xf012f6cc
f011c4fe:	e8 88 4a fe ff       	call   f0100f8b <cprintf>
f011c503:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011c506:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011c50d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c510:	c1 e8 0c             	shr    $0xc,%eax
f011c513:	89 c2                	mov    %eax,%edx
f011c515:	4a                   	dec    %edx
f011c516:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011c519:	c1 e0 02             	shl    $0x2,%eax
f011c51c:	8d 50 03             	lea    0x3(%eax),%edx
f011c51f:	b8 10 00 00 00       	mov    $0x10,%eax
f011c524:	48                   	dec    %eax
f011c525:	01 d0                	add    %edx,%eax
f011c527:	bf 10 00 00 00       	mov    $0x10,%edi
f011c52c:	ba 00 00 00 00       	mov    $0x0,%edx
f011c531:	f7 f7                	div    %edi
f011c533:	6b c0 10             	imul   $0x10,%eax,%eax
f011c536:	29 c4                	sub    %eax,%esp
f011c538:	89 e0                	mov    %esp,%eax
f011c53a:	83 c0 03             	add    $0x3,%eax
f011c53d:	c1 e8 02             	shr    $0x2,%eax
f011c540:	c1 e0 02             	shl    $0x2,%eax
f011c543:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011c546:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c549:	c1 e8 0c             	shr    $0xc,%eax
f011c54c:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011c54f:	83 ec 0c             	sub    $0xc,%esp
f011c552:	68 54 fc 12 f0       	push   $0xf012fc54
f011c557:	e8 2f 4a fe ff       	call   f0100f8b <cprintf>
f011c55c:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c55f:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c566:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c56b:	05 00 10 00 00       	add    $0x1000,%eax
f011c570:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011c573:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c57a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c57d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c580:	e9 2d 01 00 00       	jmp    f011c6b2 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c585:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011c58a:	83 ec 04             	sub    $0x4,%esp
f011c58d:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c593:	52                   	push   %edx
f011c594:	ff 75 dc             	pushl  -0x24(%ebp)
f011c597:	50                   	push   %eax
f011c598:	e8 7d c1 fe ff       	call   f010871a <get_page_table>
f011c59d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c5a0:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c5a6:	85 c0                	test   %eax,%eax
f011c5a8:	75 1e                	jne    f011c5c8 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c5aa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5b1:	83 ec 04             	sub    $0x4,%esp
f011c5b4:	68 60 f7 12 f0       	push   $0xf012f760
f011c5b9:	68 26 07 00 00       	push   $0x726
f011c5be:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011c5c3:	e8 71 3d fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c5c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c5cb:	c1 e8 0c             	shr    $0xc,%eax
f011c5ce:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c5d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c5d6:	e9 ba 00 00 00       	jmp    f011c695 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011c5db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c5de:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011c5e1:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c5e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c5ea:	c1 e2 02             	shl    $0x2,%edx
f011c5ed:	01 d0                	add    %edx,%eax
f011c5ef:	8b 00                	mov    (%eax),%eax
f011c5f1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c5f6:	89 c2                	mov    %eax,%edx
f011c5f8:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c5fb:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c5fe:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c601:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c604:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c607:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c60a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c60d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c610:	83 ec 0c             	sub    $0xc,%esp
f011c613:	50                   	push   %eax
f011c614:	e8 f9 d5 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c619:	83 c4 10             	add    $0x10,%esp
f011c61c:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011c61f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c622:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c625:	01 d0                	add    %edx,%eax
f011c627:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c62a:	74 5c                	je     f011c688 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011c62c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c630:	74 56                	je     f011c688 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011c632:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c635:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c638:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c63b:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011c641:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011c644:	c1 e1 02             	shl    $0x2,%ecx
f011c647:	01 ca                	add    %ecx,%edx
f011c649:	8b 12                	mov    (%edx),%edx
f011c64b:	89 d1                	mov    %edx,%ecx
f011c64d:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011c653:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011c656:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c659:	01 da                	add    %ebx,%edx
f011c65b:	83 ec 0c             	sub    $0xc,%esp
f011c65e:	50                   	push   %eax
f011c65f:	51                   	push   %ecx
f011c660:	52                   	push   %edx
f011c661:	ff 75 8c             	pushl  -0x74(%ebp)
f011c664:	68 a0 fc 12 f0       	push   $0xf012fca0
f011c669:	e8 1d 49 fe ff       	call   f0100f8b <cprintf>
f011c66e:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011c671:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c678:	83 ec 0c             	sub    $0xc,%esp
f011c67b:	68 e4 fc 12 f0       	push   $0xf012fce4
f011c680:	e8 06 49 fe ff       	call   f0100f8b <cprintf>
f011c685:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011c688:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c68f:	ff 45 d4             	incl   -0x2c(%ebp)
f011c692:	ff 45 d8             	incl   -0x28(%ebp)
f011c695:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c698:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011c69b:	7d 15                	jge    f011c6b2 <test_kheap_virt_addr+0x7a3>
f011c69d:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c6a4:	7f 0c                	jg     f011c6b2 <test_kheap_virt_addr+0x7a3>
f011c6a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c6a9:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c6ac:	0f 82 29 ff ff ff    	jb     f011c5db <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c6b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c6b5:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c6b8:	0f 82 c7 fe ff ff    	jb     f011c585 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c6be:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c6c2:	74 04                	je     f011c6c8 <test_kheap_virt_addr+0x7b9>
f011c6c4:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c6c8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011c6cf:	83 ec 0c             	sub    $0xc,%esp
f011c6d2:	68 08 fd 12 f0       	push   $0xf012fd08
f011c6d7:	e8 af 48 fe ff       	call   f0100f8b <cprintf>
f011c6dc:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c6df:	e8 64 25 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c6e4:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c6e7:	e8 a7 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c6ec:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c6ef:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c6f5:	83 ec 0c             	sub    $0xc,%esp
f011c6f8:	50                   	push   %eax
f011c6f9:	e8 91 d3 fe ff       	call   f0109a8f <kfree>
f011c6fe:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c701:	e8 8d 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c706:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c709:	74 17                	je     f011c722 <test_kheap_virt_addr+0x813>
f011c70b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c712:	83 ec 0c             	sub    $0xc,%esp
f011c715:	68 30 fd 12 f0       	push   $0xf012fd30
f011c71a:	e8 6c 48 fe ff       	call   f0100f8b <cprintf>
f011c71f:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c722:	e8 21 25 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c727:	89 c2                	mov    %eax,%edx
f011c729:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c72c:	29 c2                	sub    %eax,%edx
f011c72e:	89 d0                	mov    %edx,%eax
f011c730:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c735:	77 17                	ja     f011c74e <test_kheap_virt_addr+0x83f>
f011c737:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c73e:	83 ec 0c             	sub    $0xc,%esp
f011c741:	68 a0 fd 12 f0       	push   $0xf012fda0
f011c746:	e8 40 48 fe ff       	call   f0100f8b <cprintf>
f011c74b:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c74e:	e8 f5 24 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c753:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c756:	e8 38 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c75b:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c75e:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c764:	83 ec 0c             	sub    $0xc,%esp
f011c767:	50                   	push   %eax
f011c768:	e8 22 d3 fe ff       	call   f0109a8f <kfree>
f011c76d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c770:	e8 1e 83 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c775:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c778:	74 17                	je     f011c791 <test_kheap_virt_addr+0x882>
f011c77a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c781:	83 ec 0c             	sub    $0xc,%esp
f011c784:	68 dc fd 12 f0       	push   $0xf012fddc
f011c789:	e8 fd 47 fe ff       	call   f0100f8b <cprintf>
f011c78e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c791:	e8 b2 24 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c796:	89 c2                	mov    %eax,%edx
f011c798:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c79b:	29 c2                	sub    %eax,%edx
f011c79d:	89 d0                	mov    %edx,%eax
f011c79f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c7a4:	77 17                	ja     f011c7bd <test_kheap_virt_addr+0x8ae>
f011c7a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7ad:	83 ec 0c             	sub    $0xc,%esp
f011c7b0:	68 4c fe 12 f0       	push   $0xf012fe4c
f011c7b5:	e8 d1 47 fe ff       	call   f0100f8b <cprintf>
f011c7ba:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c7bd:	e8 86 24 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c7c2:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c7c5:	e8 c9 82 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c7ca:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c7cd:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c7d3:	83 ec 0c             	sub    $0xc,%esp
f011c7d6:	50                   	push   %eax
f011c7d7:	e8 b3 d2 fe ff       	call   f0109a8f <kfree>
f011c7dc:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c7df:	e8 af 82 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011c7e4:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c7e7:	74 17                	je     f011c800 <test_kheap_virt_addr+0x8f1>
f011c7e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7f0:	83 ec 0c             	sub    $0xc,%esp
f011c7f3:	68 88 fe 12 f0       	push   $0xf012fe88
f011c7f8:	e8 8e 47 fe ff       	call   f0100f8b <cprintf>
f011c7fd:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c800:	e8 43 24 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011c805:	89 c2                	mov    %eax,%edx
f011c807:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c80a:	29 c2                	sub    %eax,%edx
f011c80c:	89 d0                	mov    %edx,%eax
f011c80e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c813:	77 17                	ja     f011c82c <test_kheap_virt_addr+0x91d>
f011c815:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c81c:	83 ec 0c             	sub    $0xc,%esp
f011c81f:	68 f8 fe 12 f0       	push   $0xf012fef8
f011c824:	e8 62 47 fe ff       	call   f0100f8b <cprintf>
f011c829:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011c82c:	83 ec 0c             	sub    $0xc,%esp
f011c82f:	68 34 ff 12 f0       	push   $0xf012ff34
f011c834:	e8 52 47 fe ff       	call   f0100f8b <cprintf>
f011c839:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c83c:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c843:	a1 38 0e 18 f0       	mov    0xf0180e38,%eax
f011c848:	05 00 10 00 00       	add    $0x1000,%eax
f011c84d:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011c853:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011c85a:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011c861:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c864:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c86a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c86d:	eb 44                	jmp    f011c8b3 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c86f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c872:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c875:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c878:	83 ec 0c             	sub    $0xc,%esp
f011c87b:	50                   	push   %eax
f011c87c:	e8 91 d3 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c881:	83 c4 10             	add    $0x10,%esp
f011c884:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011c88a:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011c891:	74 1d                	je     f011c8b0 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011c893:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c897:	74 17                	je     f011c8b0 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011c899:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8a0:	83 ec 0c             	sub    $0xc,%esp
f011c8a3:	68 84 ff 12 f0       	push   $0xf012ff84
f011c8a8:	e8 de 46 fe ff       	call   f0100f8b <cprintf>
f011c8ad:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c8b0:	ff 45 d0             	incl   -0x30(%ebp)
f011c8b3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c8b9:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011c8bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c8c2:	39 c2                	cmp    %eax,%edx
f011c8c4:	77 a9                	ja     f011c86f <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c8c6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c8cc:	05 00 04 00 00       	add    $0x400,%eax
f011c8d1:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c8d4:	eb 64                	jmp    f011c93a <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c8d6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c8d9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c8dc:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c8df:	83 ec 0c             	sub    $0xc,%esp
f011c8e2:	50                   	push   %eax
f011c8e3:	e8 2a d3 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c8e8:	83 c4 10             	add    $0x10,%esp
f011c8eb:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c8f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c8f4:	c1 e0 0c             	shl    $0xc,%eax
f011c8f7:	89 c2                	mov    %eax,%edx
f011c8f9:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c8ff:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c902:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c905:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c908:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c90b:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c910:	01 c8                	add    %ecx,%eax
f011c912:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c918:	74 1d                	je     f011c937 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011c91a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c91e:	74 17                	je     f011c937 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011c920:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c927:	83 ec 0c             	sub    $0xc,%esp
f011c92a:	68 a8 ff 12 f0       	push   $0xf012ffa8
f011c92f:	e8 57 46 fe ff       	call   f0100f8b <cprintf>
f011c934:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c937:	ff 45 d0             	incl   -0x30(%ebp)
f011c93a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c940:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011c946:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c949:	39 c2                	cmp    %eax,%edx
f011c94b:	77 89                	ja     f011c8d6 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c94d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c953:	05 02 07 00 00       	add    $0x702,%eax
f011c958:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c95b:	eb 44                	jmp    f011c9a1 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c95d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c960:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c963:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c966:	83 ec 0c             	sub    $0xc,%esp
f011c969:	50                   	push   %eax
f011c96a:	e8 a3 d2 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c96f:	83 c4 10             	add    $0x10,%esp
f011c972:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011c978:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011c97f:	74 1d                	je     f011c99e <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011c981:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c985:	74 17                	je     f011c99e <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011c987:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c98e:	83 ec 0c             	sub    $0xc,%esp
f011c991:	68 cc ff 12 f0       	push   $0xf012ffcc
f011c996:	e8 f0 45 fe ff       	call   f0100f8b <cprintf>
f011c99b:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c99e:	ff 45 d0             	incl   -0x30(%ebp)
f011c9a1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c9a7:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011c9ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c9b0:	39 c2                	cmp    %eax,%edx
f011c9b2:	77 a9                	ja     f011c95d <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c9b4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c9ba:	05 02 0d 00 00       	add    $0xd02,%eax
f011c9bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c9c2:	eb 64                	jmp    f011ca28 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c9c4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c9c7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c9ca:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c9cd:	83 ec 0c             	sub    $0xc,%esp
f011c9d0:	50                   	push   %eax
f011c9d1:	e8 3c d2 fe ff       	call   f0109c12 <kheap_virtual_address>
f011c9d6:	83 c4 10             	add    $0x10,%esp
f011c9d9:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c9df:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c9e2:	c1 e0 0c             	shl    $0xc,%eax
f011c9e5:	89 c2                	mov    %eax,%edx
f011c9e7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c9ed:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c9f0:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c9f3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c9f6:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c9f9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c9fe:	01 c8                	add    %ecx,%eax
f011ca00:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011ca06:	74 1d                	je     f011ca25 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011ca08:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ca0c:	74 17                	je     f011ca25 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011ca0e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca15:	83 ec 0c             	sub    $0xc,%esp
f011ca18:	68 f0 ff 12 f0       	push   $0xf012fff0
f011ca1d:	e8 69 45 fe ff       	call   f0100f8b <cprintf>
f011ca22:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011ca25:	ff 45 d0             	incl   -0x30(%ebp)
f011ca28:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ca2e:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011ca34:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ca37:	39 c2                	cmp    %eax,%edx
f011ca39:	77 89                	ja     f011c9c4 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011ca3b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ca3f:	74 04                	je     f011ca45 <test_kheap_virt_addr+0xb36>
f011ca41:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011ca45:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011ca4c:	83 ec 0c             	sub    $0xc,%esp
f011ca4f:	68 14 00 13 f0       	push   $0xf0130014
f011ca54:	e8 32 45 fe ff       	call   f0100f8b <cprintf>
f011ca59:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011ca5c:	83 ec 0c             	sub    $0xc,%esp
f011ca5f:	6a 00                	push   $0x0
f011ca61:	e8 36 cc fe ff       	call   f010969c <sbrk>
f011ca66:	83 c4 10             	add    $0x10,%esp
f011ca69:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011ca6e:	77 17                	ja     f011ca87 <test_kheap_virt_addr+0xb78>
f011ca70:	83 ec 04             	sub    $0x4,%esp
f011ca73:	68 5b 00 13 f0       	push   $0xf013005b
f011ca78:	68 91 07 00 00       	push   $0x791
f011ca7d:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011ca82:	e8 b2 38 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011ca87:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011ca8e:	e9 d1 00 00 00       	jmp    f011cb64 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ca93:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011ca98:	83 ec 04             	sub    $0x4,%esp
f011ca9b:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011caa1:	52                   	push   %edx
f011caa2:	ff 75 cc             	pushl  -0x34(%ebp)
f011caa5:	50                   	push   %eax
f011caa6:	e8 6f bc fe ff       	call   f010871a <get_page_table>
f011caab:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011caae:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011cab4:	85 c0                	test   %eax,%eax
f011cab6:	75 1e                	jne    f011cad6 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011cab8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cabf:	83 ec 04             	sub    $0x4,%esp
f011cac2:	68 e4 f9 12 f0       	push   $0xf012f9e4
f011cac7:	68 97 07 00 00       	push   $0x797
f011cacc:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011cad1:	e8 63 38 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011cad6:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011cadc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011cadf:	c1 ea 0c             	shr    $0xc,%edx
f011cae2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011cae8:	c1 e2 02             	shl    $0x2,%edx
f011caeb:	01 d0                	add    %edx,%eax
f011caed:	8b 00                	mov    (%eax),%eax
f011caef:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011caf4:	89 c2                	mov    %eax,%edx
f011caf6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011caf9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011cafe:	01 d0                	add    %edx,%eax
f011cb00:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011cb06:	83 ec 0c             	sub    $0xc,%esp
f011cb09:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011cb0f:	e8 fe d0 fe ff       	call   f0109c12 <kheap_virtual_address>
f011cb14:	83 c4 10             	add    $0x10,%esp
f011cb17:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011cb1d:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011cb23:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011cb26:	74 39                	je     f011cb61 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011cb28:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cb2c:	74 33                	je     f011cb61 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011cb2e:	ff 75 cc             	pushl  -0x34(%ebp)
f011cb31:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011cb37:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011cb3d:	68 74 00 13 f0       	push   $0xf0130074
f011cb42:	e8 44 44 fe ff       	call   f0100f8b <cprintf>
f011cb47:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011cb4a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb51:	83 ec 0c             	sub    $0xc,%esp
f011cb54:	68 a0 00 13 f0       	push   $0xf01300a0
f011cb59:	e8 2d 44 fe ff       	call   f0100f8b <cprintf>
f011cb5e:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011cb61:	ff 45 cc             	incl   -0x34(%ebp)
f011cb64:	83 ec 0c             	sub    $0xc,%esp
f011cb67:	6a 00                	push   $0x0
f011cb69:	e8 2e cb fe ff       	call   f010969c <sbrk>
f011cb6e:	83 c4 10             	add    $0x10,%esp
f011cb71:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011cb74:	0f 87 19 ff ff ff    	ja     f011ca93 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011cb7a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cb7e:	74 04                	je     f011cb84 <test_kheap_virt_addr+0xc75>
f011cb80:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011cb84:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011cb8b:	83 ec 0c             	sub    $0xc,%esp
f011cb8e:	68 c4 00 13 f0       	push   $0xf01300c4
f011cb93:	e8 f3 43 fe ff       	call   f0100f8b <cprintf>
f011cb98:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011cb9b:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011cba2:	eb 5a                	jmp    f011cbfe <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011cba4:	83 ec 0c             	sub    $0xc,%esp
f011cba7:	ff 75 c8             	pushl  -0x38(%ebp)
f011cbaa:	e8 63 d0 fe ff       	call   f0109c12 <kheap_virtual_address>
f011cbaf:	83 c4 10             	add    $0x10,%esp
f011cbb2:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011cbb8:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011cbbf:	74 36                	je     f011cbf7 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011cbc1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cbc5:	74 30                	je     f011cbf7 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011cbc7:	83 ec 04             	sub    $0x4,%esp
f011cbca:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011cbd0:	ff 75 c8             	pushl  -0x38(%ebp)
f011cbd3:	68 03 01 13 f0       	push   $0xf0130103
f011cbd8:	e8 ae 43 fe ff       	call   f0100f8b <cprintf>
f011cbdd:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011cbe0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbe7:	83 ec 0c             	sub    $0xc,%esp
f011cbea:	68 20 01 13 f0       	push   $0xf0130120
f011cbef:	e8 97 43 fe ff       	call   f0100f8b <cprintf>
f011cbf4:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011cbf7:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011cbfe:	b8 70 04 6f 02       	mov    $0x26f0470,%eax
f011cc03:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011cc06:	72 9c                	jb     f011cba4 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011cc08:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cc0c:	74 04                	je     f011cc12 <test_kheap_virt_addr+0xd03>
f011cc0e:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011cc12:	83 ec 08             	sub    $0x8,%esp
f011cc15:	ff 75 e4             	pushl  -0x1c(%ebp)
f011cc18:	68 44 01 13 f0       	push   $0xf0130144
f011cc1d:	e8 69 43 fe ff       	call   f0100f8b <cprintf>
f011cc22:	83 c4 10             	add    $0x10,%esp

	return 1;
f011cc25:	b8 01 00 00 00       	mov    $0x1,%eax
f011cc2a:	89 f4                	mov    %esi,%esp

}
f011cc2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cc2f:	5b                   	pop    %ebx
f011cc30:	5e                   	pop    %esi
f011cc31:	5f                   	pop    %edi
f011cc32:	5d                   	pop    %ebp
f011cc33:	c3                   	ret    

f011cc34 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011cc34:	55                   	push   %ebp
f011cc35:	89 e5                	mov    %esp,%ebp
f011cc37:	57                   	push   %edi
f011cc38:	56                   	push   %esi
f011cc39:	53                   	push   %ebx
f011cc3a:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011cc40:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011cc46:	b9 14 00 00 00       	mov    $0x14,%ecx
f011cc4b:	b8 00 00 00 00       	mov    $0x0,%eax
f011cc50:	89 d7                	mov    %edx,%edi
f011cc52:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011cc54:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011cc5b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011cc62:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011cc69:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011cc6e:	0f b6 c0             	movzbl %al,%eax
f011cc71:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011cc74:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011cc7b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011cc7e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011cc81:	39 c2                	cmp    %eax,%edx
f011cc83:	73 02                	jae    f011cc87 <test_ksbrk+0x53>
f011cc85:	89 c2                	mov    %eax,%edx
f011cc87:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011cc8c:	0f b6 c0             	movzbl %al,%eax
f011cc8f:	c1 e0 04             	shl    $0x4,%eax
f011cc92:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011cc95:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011cc9c:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011cc9f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011cca2:	39 c8                	cmp    %ecx,%eax
f011cca4:	73 02                	jae    f011cca8 <test_ksbrk+0x74>
f011cca6:	89 c8                	mov    %ecx,%eax
f011cca8:	01 d0                	add    %edx,%eax
f011ccaa:	83 c0 10             	add    $0x10,%eax
f011ccad:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011ccb2:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011ccb5:	83 ec 0c             	sub    $0xc,%esp
f011ccb8:	68 78 01 13 f0       	push   $0xf0130178
f011ccbd:	e8 c9 42 fe ff       	call   f0100f8b <cprintf>
f011ccc2:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011ccc5:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cccc:	e8 77 1f ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ccd1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ccd4:	e8 ba 7d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ccd9:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011ccdc:	83 ec 10             	sub    $0x10,%esp
f011ccdf:	89 e0                	mov    %esp,%eax
f011cce1:	89 c2                	mov    %eax,%edx
f011cce3:	bb 50 d3 b5 f0       	mov    $0xf0b5d350,%ebx
f011cce8:	b8 04 00 00 00       	mov    $0x4,%eax
f011cced:	89 d7                	mov    %edx,%edi
f011ccef:	89 de                	mov    %ebx,%esi
f011ccf1:	89 c1                	mov    %eax,%ecx
f011ccf3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011ccf5:	e8 53 3e 00 00       	call   f0120b4d <print_blocks_list>
f011ccfa:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011ccfd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd00:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cd03:	29 c2                	sub    %eax,%edx
f011cd05:	89 d0                	mov    %edx,%eax
f011cd07:	83 ec 0c             	sub    $0xc,%esp
f011cd0a:	50                   	push   %eax
f011cd0b:	e8 bf ca fe ff       	call   f01097cf <kmalloc>
f011cd10:	83 c4 10             	add    $0x10,%esp
f011cd13:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011cd19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cd1c:	89 c2                	mov    %eax,%edx
f011cd1e:	c1 ea 1f             	shr    $0x1f,%edx
f011cd21:	01 d0                	add    %edx,%eax
f011cd23:	d1 f8                	sar    %eax
f011cd25:	89 c2                	mov    %eax,%edx
f011cd27:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011cd2a:	01 d0                	add    %edx,%eax
f011cd2c:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011cd2f:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cd35:	6a 01                	push   $0x1
f011cd37:	ff 75 b8             	pushl  -0x48(%ebp)
f011cd3a:	ff 75 ac             	pushl  -0x54(%ebp)
f011cd3d:	50                   	push   %eax
f011cd3e:	e8 db 43 ff ff       	call   f011111e <check_block>
f011cd43:	83 c4 10             	add    $0x10,%esp
f011cd46:	85 c0                	test   %eax,%eax
f011cd48:	75 17                	jne    f011cd61 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011cd4a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd51:	83 ec 0c             	sub    $0xc,%esp
f011cd54:	68 c9 01 13 f0       	push   $0xf01301c9
f011cd59:	e8 2d 42 fe ff       	call   f0100f8b <cprintf>
f011cd5e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cd61:	e8 e2 1e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cd66:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cd69:	74 17                	je     f011cd82 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011cd6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd72:	83 ec 0c             	sub    $0xc,%esp
f011cd75:	68 e0 01 13 f0       	push   $0xf01301e0
f011cd7a:	e8 0c 42 fe ff       	call   f0100f8b <cprintf>
f011cd7f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cd82:	e8 0c 7d fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cd87:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cd8a:	74 17                	je     f011cda3 <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cd8c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd93:	83 ec 0c             	sub    $0xc,%esp
f011cd96:	68 00 02 13 f0       	push   $0xf0130200
f011cd9b:	e8 eb 41 fe ff       	call   f0100f8b <cprintf>
f011cda0:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011cda3:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011cda8:	0f b6 c0             	movzbl %al,%eax
f011cdab:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011cdae:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011cdb5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011cdb8:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011cdbb:	39 c2                	cmp    %eax,%edx
f011cdbd:	73 02                	jae    f011cdc1 <test_ksbrk+0x18d>
f011cdbf:	89 c2                	mov    %eax,%edx
f011cdc1:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011cdc6:	0f b6 c0             	movzbl %al,%eax
f011cdc9:	c1 e0 04             	shl    $0x4,%eax
f011cdcc:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011cdcf:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011cdd6:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011cdd9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cddc:	39 c8                	cmp    %ecx,%eax
f011cdde:	73 02                	jae    f011cde2 <test_ksbrk+0x1ae>
f011cde0:	89 c8                	mov    %ecx,%eax
f011cde2:	01 d0                	add    %edx,%eax
f011cde4:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011cde9:	29 c2                	sub    %eax,%edx
f011cdeb:	89 d0                	mov    %edx,%eax
f011cded:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cdf0:	e8 53 1e ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cdf5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cdf8:	e8 96 7c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cdfd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011ce00:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce03:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ce06:	29 c2                	sub    %eax,%edx
f011ce08:	89 d0                	mov    %edx,%eax
f011ce0a:	83 ec 0c             	sub    $0xc,%esp
f011ce0d:	50                   	push   %eax
f011ce0e:	e8 bc c9 fe ff       	call   f01097cf <kmalloc>
f011ce13:	83 c4 10             	add    $0x10,%esp
f011ce16:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011ce1c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce1f:	89 c2                	mov    %eax,%edx
f011ce21:	c1 ea 1f             	shr    $0x1f,%edx
f011ce24:	01 d0                	add    %edx,%eax
f011ce26:	d1 f8                	sar    %eax
f011ce28:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011ce2e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011ce31:	01 d0                	add    %edx,%eax
f011ce33:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011ce36:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011ce3c:	6a 01                	push   $0x1
f011ce3e:	ff 75 b8             	pushl  -0x48(%ebp)
f011ce41:	ff 75 ac             	pushl  -0x54(%ebp)
f011ce44:	50                   	push   %eax
f011ce45:	e8 d4 42 ff ff       	call   f011111e <check_block>
f011ce4a:	83 c4 10             	add    $0x10,%esp
f011ce4d:	85 c0                	test   %eax,%eax
f011ce4f:	75 17                	jne    f011ce68 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011ce51:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce58:	83 ec 0c             	sub    $0xc,%esp
f011ce5b:	68 6e 02 13 f0       	push   $0xf013026e
f011ce60:	e8 26 41 fe ff       	call   f0100f8b <cprintf>
f011ce65:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ce68:	e8 db 1d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ce6d:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ce70:	74 17                	je     f011ce89 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011ce72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce79:	83 ec 0c             	sub    $0xc,%esp
f011ce7c:	68 88 02 13 f0       	push   $0xf0130288
f011ce81:	e8 05 41 fe ff       	call   f0100f8b <cprintf>
f011ce86:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ce89:	e8 05 7c fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011ce8e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ce91:	74 17                	je     f011ceaa <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce93:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce9a:	83 ec 0c             	sub    $0xc,%esp
f011ce9d:	68 a8 02 13 f0       	push   $0xf01302a8
f011cea2:	e8 e4 40 fe ff       	call   f0100f8b <cprintf>
f011cea7:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011ceaa:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011ceb1:	e8 92 1d ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011ceb6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ceb9:	e8 d5 7b fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cebe:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011cec1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cec4:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cec7:	29 c2                	sub    %eax,%edx
f011cec9:	89 d0                	mov    %edx,%eax
f011cecb:	83 ec 0c             	sub    $0xc,%esp
f011cece:	50                   	push   %eax
f011cecf:	e8 fb c8 fe ff       	call   f01097cf <kmalloc>
f011ced4:	83 c4 10             	add    $0x10,%esp
f011ced7:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cedd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cee0:	89 c2                	mov    %eax,%edx
f011cee2:	c1 ea 1f             	shr    $0x1f,%edx
f011cee5:	01 d0                	add    %edx,%eax
f011cee7:	d1 f8                	sar    %eax
f011cee9:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011ceee:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011cef1:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011cef7:	6a 01                	push   $0x1
f011cef9:	ff 75 b8             	pushl  -0x48(%ebp)
f011cefc:	ff 75 ac             	pushl  -0x54(%ebp)
f011ceff:	50                   	push   %eax
f011cf00:	e8 19 42 ff ff       	call   f011111e <check_block>
f011cf05:	83 c4 10             	add    $0x10,%esp
f011cf08:	85 c0                	test   %eax,%eax
f011cf0a:	75 17                	jne    f011cf23 <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011cf0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf13:	83 ec 0c             	sub    $0xc,%esp
f011cf16:	68 16 03 13 f0       	push   $0xf0130316
f011cf1b:	e8 6b 40 fe ff       	call   f0100f8b <cprintf>
f011cf20:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cf23:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cf26:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011cf29:	b8 00 10 00 00       	mov    $0x1000,%eax
f011cf2e:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011cf31:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cf34:	6a 00                	push   $0x0
f011cf36:	ff 75 98             	pushl  -0x68(%ebp)
f011cf39:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf3c:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf3f:	e8 da 41 ff ff       	call   f011111e <check_block>
f011cf44:	83 c4 10             	add    $0x10,%esp
f011cf47:	85 c0                	test   %eax,%eax
f011cf49:	75 17                	jne    f011cf62 <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011cf4b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf52:	83 ec 0c             	sub    $0xc,%esp
f011cf55:	68 2d 03 13 f0       	push   $0xf013032d
f011cf5a:	e8 2c 40 fe ff       	call   f0100f8b <cprintf>
f011cf5f:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011cf62:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cf69:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cf6c:	8b 00                	mov    (%eax),%eax
f011cf6e:	83 f8 01             	cmp    $0x1,%eax
f011cf71:	74 17                	je     f011cf8a <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011cf73:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf7a:	83 ec 0c             	sub    $0xc,%esp
f011cf7d:	68 44 03 13 f0       	push   $0xf0130344
f011cf82:	e8 04 40 fe ff       	call   f0100f8b <cprintf>
f011cf87:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cf8a:	83 ec 0c             	sub    $0xc,%esp
f011cf8d:	6a 00                	push   $0x0
f011cf8f:	e8 08 c7 fe ff       	call   f010969c <sbrk>
f011cf94:	83 c4 10             	add    $0x10,%esp
f011cf97:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011cf9a:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cfa1:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cfa4:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cfa7:	74 1d                	je     f011cfc6 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cfa9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfb0:	83 ec 04             	sub    $0x4,%esp
f011cfb3:	ff 75 90             	pushl  -0x70(%ebp)
f011cfb6:	ff 75 8c             	pushl  -0x74(%ebp)
f011cfb9:	68 70 03 13 f0       	push   $0xf0130370
f011cfbe:	e8 c8 3f fe ff       	call   f0100f8b <cprintf>
f011cfc3:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cfc6:	e8 7d 1c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011cfcb:	89 c2                	mov    %eax,%edx
f011cfcd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cfd0:	29 d0                	sub    %edx,%eax
f011cfd2:	83 f8 01             	cmp    $0x1,%eax
f011cfd5:	74 17                	je     f011cfee <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011cfd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfde:	83 ec 0c             	sub    $0xc,%esp
f011cfe1:	68 a4 03 13 f0       	push   $0xf01303a4
f011cfe6:	e8 a0 3f fe ff       	call   f0100f8b <cprintf>
f011cfeb:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cfee:	e8 a0 7a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011cff3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cff6:	74 17                	je     f011d00f <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cff8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfff:	83 ec 0c             	sub    $0xc,%esp
f011d002:	68 c4 03 13 f0       	push   $0xf01303c4
f011d007:	e8 7f 3f fe ff       	call   f0100f8b <cprintf>
f011d00c:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011d00f:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d016:	e8 2d 1c ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d01b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d01e:	e8 70 7a fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d023:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011d026:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d029:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d02c:	29 c2                	sub    %eax,%edx
f011d02e:	89 d0                	mov    %edx,%eax
f011d030:	83 ec 0c             	sub    $0xc,%esp
f011d033:	50                   	push   %eax
f011d034:	e8 96 c7 fe ff       	call   f01097cf <kmalloc>
f011d039:	83 c4 10             	add    $0x10,%esp
f011d03c:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011d042:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011d049:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011d04f:	6a 01                	push   $0x1
f011d051:	ff 75 b8             	pushl  -0x48(%ebp)
f011d054:	ff 75 ac             	pushl  -0x54(%ebp)
f011d057:	50                   	push   %eax
f011d058:	e8 c1 40 ff ff       	call   f011111e <check_block>
f011d05d:	83 c4 10             	add    $0x10,%esp
f011d060:	85 c0                	test   %eax,%eax
f011d062:	75 17                	jne    f011d07b <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011d064:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d06b:	83 ec 0c             	sub    $0xc,%esp
f011d06e:	68 33 04 13 f0       	push   $0xf0130433
f011d073:	e8 13 3f fe ff       	call   f0100f8b <cprintf>
f011d078:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d07b:	e8 c8 1b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d080:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d083:	74 17                	je     f011d09c <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011d085:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d08c:	83 ec 0c             	sub    $0xc,%esp
f011d08f:	68 4c 04 13 f0       	push   $0xf013044c
f011d094:	e8 f2 3e fe ff       	call   f0100f8b <cprintf>
f011d099:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d09c:	e8 f2 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d0a1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d0a4:	74 17                	je     f011d0bd <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d0a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0ad:	83 ec 0c             	sub    $0xc,%esp
f011d0b0:	68 6c 04 13 f0       	push   $0xf013046c
f011d0b5:	e8 d1 3e fe ff       	call   f0100f8b <cprintf>
f011d0ba:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011d0bd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d0c1:	74 04                	je     f011d0c7 <test_ksbrk+0x493>
		eval += 25;
f011d0c3:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011d0c7:	83 ec 0c             	sub    $0xc,%esp
f011d0ca:	68 dc 04 13 f0       	push   $0xf01304dc
f011d0cf:	e8 b7 3e fe ff       	call   f0100f8b <cprintf>
f011d0d4:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011d0d7:	83 ec 0c             	sub    $0xc,%esp
f011d0da:	6a 00                	push   $0x0
f011d0dc:	e8 bb c5 fe ff       	call   f010969c <sbrk>
f011d0e1:	83 c4 10             	add    $0x10,%esp
f011d0e4:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011d0e7:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d0ee:	e8 55 1b ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d0f3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d0f6:	e8 98 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d0fb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011d0fe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d101:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d104:	29 c2                	sub    %eax,%edx
f011d106:	89 d0                	mov    %edx,%eax
f011d108:	83 ec 0c             	sub    $0xc,%esp
f011d10b:	50                   	push   %eax
f011d10c:	e8 be c6 fe ff       	call   f01097cf <kmalloc>
f011d111:	83 c4 10             	add    $0x10,%esp
f011d114:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011d11a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d11d:	89 c2                	mov    %eax,%edx
f011d11f:	c1 ea 1f             	shr    $0x1f,%edx
f011d122:	01 d0                	add    %edx,%eax
f011d124:	d1 f8                	sar    %eax
f011d126:	89 c2                	mov    %eax,%edx
f011d128:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d12b:	01 d0                	add    %edx,%eax
f011d12d:	83 e8 04             	sub    $0x4,%eax
f011d130:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011d133:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011d139:	6a 01                	push   $0x1
f011d13b:	ff 75 b8             	pushl  -0x48(%ebp)
f011d13e:	ff 75 ac             	pushl  -0x54(%ebp)
f011d141:	50                   	push   %eax
f011d142:	e8 d7 3f ff ff       	call   f011111e <check_block>
f011d147:	83 c4 10             	add    $0x10,%esp
f011d14a:	85 c0                	test   %eax,%eax
f011d14c:	75 17                	jne    f011d165 <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011d14e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d155:	83 ec 0c             	sub    $0xc,%esp
f011d158:	68 3f 05 13 f0       	push   $0xf013053f
f011d15d:	e8 29 3e fe ff       	call   f0100f8b <cprintf>
f011d162:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d165:	e8 de 1a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d16a:	89 c2                	mov    %eax,%edx
f011d16c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d16f:	29 d0                	sub    %edx,%eax
f011d171:	83 f8 01             	cmp    $0x1,%eax
f011d174:	74 17                	je     f011d18d <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011d176:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d17d:	83 ec 0c             	sub    $0xc,%esp
f011d180:	68 58 05 13 f0       	push   $0xf0130558
f011d185:	e8 01 3e fe ff       	call   f0100f8b <cprintf>
f011d18a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d18d:	e8 01 79 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d192:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d195:	74 17                	je     f011d1ae <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d197:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d19e:	83 ec 0c             	sub    $0xc,%esp
f011d1a1:	68 78 05 13 f0       	push   $0xf0130578
f011d1a6:	e8 e0 3d fe ff       	call   f0100f8b <cprintf>
f011d1ab:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011d1ae:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d1b5:	e8 8e 1a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d1ba:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d1bd:	e8 d1 78 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d1c2:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011d1c5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d1c8:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d1cb:	29 c2                	sub    %eax,%edx
f011d1cd:	89 d0                	mov    %edx,%eax
f011d1cf:	83 ec 0c             	sub    $0xc,%esp
f011d1d2:	50                   	push   %eax
f011d1d3:	e8 f7 c5 fe ff       	call   f01097cf <kmalloc>
f011d1d8:	83 c4 10             	add    $0x10,%esp
f011d1db:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011d1e1:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011d1e8:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011d1ee:	6a 01                	push   $0x1
f011d1f0:	ff 75 b8             	pushl  -0x48(%ebp)
f011d1f3:	ff 75 ac             	pushl  -0x54(%ebp)
f011d1f6:	50                   	push   %eax
f011d1f7:	e8 22 3f ff ff       	call   f011111e <check_block>
f011d1fc:	83 c4 10             	add    $0x10,%esp
f011d1ff:	85 c0                	test   %eax,%eax
f011d201:	75 17                	jne    f011d21a <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011d203:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d20a:	83 ec 0c             	sub    $0xc,%esp
f011d20d:	68 e6 05 13 f0       	push   $0xf01305e6
f011d212:	e8 74 3d fe ff       	call   f0100f8b <cprintf>
f011d217:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d21a:	e8 29 1a ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d21f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d222:	74 17                	je     f011d23b <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011d224:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d22b:	83 ec 0c             	sub    $0xc,%esp
f011d22e:	68 00 06 13 f0       	push   $0xf0130600
f011d233:	e8 53 3d fe ff       	call   f0100f8b <cprintf>
f011d238:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d23b:	e8 53 78 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d240:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d243:	74 17                	je     f011d25c <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d245:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d24c:	83 ec 0c             	sub    $0xc,%esp
f011d24f:	68 20 06 13 f0       	push   $0xf0130620
f011d254:	e8 32 3d fe ff       	call   f0100f8b <cprintf>
f011d259:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011d25c:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011d263:	e8 e0 19 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d268:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d26b:	e8 23 78 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d270:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011d273:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d276:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d279:	29 c2                	sub    %eax,%edx
f011d27b:	89 d0                	mov    %edx,%eax
f011d27d:	83 ec 0c             	sub    $0xc,%esp
f011d280:	50                   	push   %eax
f011d281:	e8 49 c5 fe ff       	call   f01097cf <kmalloc>
f011d286:	83 c4 10             	add    $0x10,%esp
f011d289:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011d28f:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011d296:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011d29c:	6a 01                	push   $0x1
f011d29e:	ff 75 b8             	pushl  -0x48(%ebp)
f011d2a1:	ff 75 ac             	pushl  -0x54(%ebp)
f011d2a4:	50                   	push   %eax
f011d2a5:	e8 74 3e ff ff       	call   f011111e <check_block>
f011d2aa:	83 c4 10             	add    $0x10,%esp
f011d2ad:	85 c0                	test   %eax,%eax
f011d2af:	75 17                	jne    f011d2c8 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011d2b1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d2b8:	83 ec 0c             	sub    $0xc,%esp
f011d2bb:	68 8e 06 13 f0       	push   $0xf013068e
f011d2c0:	e8 c6 3c fe ff       	call   f0100f8b <cprintf>
f011d2c5:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011d2c8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d2cb:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011d2ce:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011d2d5:	6a 00                	push   $0x0
f011d2d7:	ff 75 98             	pushl  -0x68(%ebp)
f011d2da:	ff 75 ac             	pushl  -0x54(%ebp)
f011d2dd:	ff 75 ac             	pushl  -0x54(%ebp)
f011d2e0:	e8 39 3e ff ff       	call   f011111e <check_block>
f011d2e5:	83 c4 10             	add    $0x10,%esp
f011d2e8:	85 c0                	test   %eax,%eax
f011d2ea:	75 17                	jne    f011d303 <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011d2ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d2f3:	83 ec 0c             	sub    $0xc,%esp
f011d2f6:	68 a5 06 13 f0       	push   $0xf01306a5
f011d2fb:	e8 8b 3c fe ff       	call   f0100f8b <cprintf>
f011d300:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011d303:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d306:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011d30b:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011d30e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d311:	8b 00                	mov    (%eax),%eax
f011d313:	83 f8 01             	cmp    $0x1,%eax
f011d316:	74 17                	je     f011d32f <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011d318:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d31f:	83 ec 0c             	sub    $0xc,%esp
f011d322:	68 bc 06 13 f0       	push   $0xf01306bc
f011d327:	e8 5f 3c fe ff       	call   f0100f8b <cprintf>
f011d32c:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011d32f:	83 ec 0c             	sub    $0xc,%esp
f011d332:	6a 00                	push   $0x0
f011d334:	e8 63 c3 fe ff       	call   f010969c <sbrk>
f011d339:	83 c4 10             	add    $0x10,%esp
f011d33c:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011d33f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d342:	05 00 20 00 00       	add    $0x2000,%eax
f011d347:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011d34a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d34d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011d350:	74 1d                	je     f011d36f <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011d352:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d359:	83 ec 04             	sub    $0x4,%esp
f011d35c:	ff 75 90             	pushl  -0x70(%ebp)
f011d35f:	ff 75 8c             	pushl  -0x74(%ebp)
f011d362:	68 e8 06 13 f0       	push   $0xf01306e8
f011d367:	e8 1f 3c fe ff       	call   f0100f8b <cprintf>
f011d36c:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d36f:	e8 d4 18 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d374:	89 c2                	mov    %eax,%edx
f011d376:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d379:	29 d0                	sub    %edx,%eax
f011d37b:	83 f8 01             	cmp    $0x1,%eax
f011d37e:	74 17                	je     f011d397 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011d380:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d387:	83 ec 0c             	sub    $0xc,%esp
f011d38a:	68 1c 07 13 f0       	push   $0xf013071c
f011d38f:	e8 f7 3b fe ff       	call   f0100f8b <cprintf>
f011d394:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d397:	e8 f7 76 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d39c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d39f:	74 17                	je     f011d3b8 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d3a1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d3a8:	83 ec 0c             	sub    $0xc,%esp
f011d3ab:	68 3c 07 13 f0       	push   $0xf013073c
f011d3b0:	e8 d6 3b fe ff       	call   f0100f8b <cprintf>
f011d3b5:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011d3b8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d3bc:	74 04                	je     f011d3c2 <test_ksbrk+0x78e>
		eval += 25;
f011d3be:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011d3c2:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011d3c9:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011d3cf:	bb 78 0a 13 f0       	mov    $0xf0130a78,%ebx
f011d3d4:	ba 05 00 00 00       	mov    $0x5,%edx
f011d3d9:	89 c7                	mov    %eax,%edi
f011d3db:	89 de                	mov    %ebx,%esi
f011d3dd:	89 d1                	mov    %edx,%ecx
f011d3df:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011d3e1:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011d3e7:	bb 8c 0a 13 f0       	mov    $0xf0130a8c,%ebx
f011d3ec:	ba 05 00 00 00       	mov    $0x5,%edx
f011d3f1:	89 c7                	mov    %eax,%edi
f011d3f3:	89 de                	mov    %ebx,%esi
f011d3f5:	89 d1                	mov    %edx,%ecx
f011d3f7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011d3f9:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011d3ff:	bb a0 0a 13 f0       	mov    $0xf0130aa0,%ebx
f011d404:	ba 05 00 00 00       	mov    $0x5,%edx
f011d409:	89 c7                	mov    %eax,%edi
f011d40b:	89 de                	mov    %ebx,%esi
f011d40d:	89 d1                	mov    %edx,%ecx
f011d40f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011d411:	83 ec 04             	sub    $0x4,%esp
f011d414:	68 00 00 00 f8       	push   $0xf8000000
f011d419:	68 00 10 00 00       	push   $0x1000
f011d41e:	68 00 00 00 f6       	push   $0xf6000000
f011d423:	e8 48 c1 fe ff       	call   f0109570 <initialize_kheap_dynamic_allocator>
f011d428:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d42b:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011d432:	eb 1b                	jmp    f011d44f <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011d434:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011d439:	83 ec 08             	sub    $0x8,%esp
f011d43c:	ff 75 dc             	pushl  -0x24(%ebp)
f011d43f:	50                   	push   %eax
f011d440:	e8 c5 b6 fe ff       	call   f0108b0a <unmap_frame>
f011d445:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d448:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011d44f:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011d456:	76 dc                	jbe    f011d434 <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011d458:	83 ec 0c             	sub    $0xc,%esp
f011d45b:	68 ac 07 13 f0       	push   $0xf01307ac
f011d460:	e8 26 3b fe ff       	call   f0100f8b <cprintf>
f011d465:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d468:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d46f:	e9 21 01 00 00       	jmp    f011d595 <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d474:	e8 cf 17 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d479:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d47c:	e8 12 76 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d481:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d484:	83 ec 0c             	sub    $0xc,%esp
f011d487:	6a 00                	push   $0x0
f011d489:	e8 0e c2 fe ff       	call   f010969c <sbrk>
f011d48e:	83 c4 10             	add    $0x10,%esp
f011d491:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d494:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d497:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d49e:	83 ec 0c             	sub    $0xc,%esp
f011d4a1:	50                   	push   %eax
f011d4a2:	e8 f5 c1 fe ff       	call   f010969c <sbrk>
f011d4a7:	83 c4 10             	add    $0x10,%esp
f011d4aa:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011d4ad:	83 ec 0c             	sub    $0xc,%esp
f011d4b0:	6a 00                	push   $0x0
f011d4b2:	e8 e5 c1 fe ff       	call   f010969c <sbrk>
f011d4b7:	83 c4 10             	add    $0x10,%esp
f011d4ba:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d4bd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d4c4:	e8 ca 75 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d4c9:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d4cc:	74 1a                	je     f011d4e8 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011d4ce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d4d5:	83 ec 08             	sub    $0x8,%esp
f011d4d8:	ff 75 d8             	pushl  -0x28(%ebp)
f011d4db:	68 f0 07 13 f0       	push   $0xf01307f0
f011d4e0:	e8 a6 3a fe ff       	call   f0100f8b <cprintf>
f011d4e5:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011d4e8:	e8 5b 17 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d4ed:	89 c2                	mov    %eax,%edx
f011d4ef:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d4f2:	29 d0                	sub    %edx,%eax
f011d4f4:	89 c2                	mov    %eax,%edx
f011d4f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d4f9:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d500:	39 c2                	cmp    %eax,%edx
f011d502:	74 1a                	je     f011d51e <test_ksbrk+0x8ea>
			{
				correct = 0;
f011d504:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011d50b:	83 ec 08             	sub    $0x8,%esp
f011d50e:	ff 75 d8             	pushl  -0x28(%ebp)
f011d511:	68 60 08 13 f0       	push   $0xf0130860
f011d516:	e8 70 3a fe ff       	call   f0100f8b <cprintf>
f011d51b:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d51e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d521:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d528:	8b 45 80             	mov    -0x80(%ebp),%eax
f011d52b:	39 c2                	cmp    %eax,%edx
f011d52d:	74 25                	je     f011d554 <test_ksbrk+0x920>
			{
				correct = 0;
f011d52f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d536:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d539:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d540:	ff 75 80             	pushl  -0x80(%ebp)
f011d543:	50                   	push   %eax
f011d544:	ff 75 d8             	pushl  -0x28(%ebp)
f011d547:	68 80 08 13 f0       	push   $0xf0130880
f011d54c:	e8 3a 3a fe ff       	call   f0100f8b <cprintf>
f011d551:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d554:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d557:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d55e:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d561:	74 25                	je     f011d588 <test_ksbrk+0x954>
			{
				correct = 0;
f011d563:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d56a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d56d:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d574:	ff 75 90             	pushl  -0x70(%ebp)
f011d577:	50                   	push   %eax
f011d578:	ff 75 d8             	pushl  -0x28(%ebp)
f011d57b:	68 b8 08 13 f0       	push   $0xf01308b8
f011d580:	e8 06 3a fe ff       	call   f0100f8b <cprintf>
f011d585:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d588:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d58c:	74 04                	je     f011d592 <test_ksbrk+0x95e>
				eval += 10;
f011d58e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d592:	ff 45 d8             	incl   -0x28(%ebp)
f011d595:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d598:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d59b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d59e:	39 c2                	cmp    %eax,%edx
f011d5a0:	0f 87 ce fe ff ff    	ja     f011d474 <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011d5a6:	83 ec 0c             	sub    $0xc,%esp
f011d5a9:	68 ec 08 13 f0       	push   $0xf01308ec
f011d5ae:	e8 d8 39 fe ff       	call   f0100f8b <cprintf>
f011d5b3:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d5b6:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d5b9:	48                   	dec    %eax
f011d5ba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011d5bd:	e9 18 01 00 00       	jmp    f011d6da <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d5c2:	e8 81 16 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d5c7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d5ca:	e8 c4 74 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d5cf:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d5d2:	83 ec 0c             	sub    $0xc,%esp
f011d5d5:	6a 00                	push   $0x0
f011d5d7:	e8 c0 c0 fe ff       	call   f010969c <sbrk>
f011d5dc:	83 c4 10             	add    $0x10,%esp
f011d5df:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d5e2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d5e5:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d5ec:	83 ec 0c             	sub    $0xc,%esp
f011d5ef:	50                   	push   %eax
f011d5f0:	e8 a7 c0 fe ff       	call   f010969c <sbrk>
f011d5f5:	83 c4 10             	add    $0x10,%esp
f011d5f8:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011d5fe:	83 ec 0c             	sub    $0xc,%esp
f011d601:	6a 00                	push   $0x0
f011d603:	e8 94 c0 fe ff       	call   f010969c <sbrk>
f011d608:	83 c4 10             	add    $0x10,%esp
f011d60b:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d60e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d615:	e8 79 74 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d61a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d61d:	74 1a                	je     f011d639 <test_ksbrk+0xa05>
			{
				correct = 0;
f011d61f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d626:	83 ec 08             	sub    $0x8,%esp
f011d629:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d62c:	68 3c 09 13 f0       	push   $0xf013093c
f011d631:	e8 55 39 fe ff       	call   f0100f8b <cprintf>
f011d636:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d639:	e8 0a 16 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d63e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d641:	74 1a                	je     f011d65d <test_ksbrk+0xa29>
			{
				correct = 0;
f011d643:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011d64a:	83 ec 08             	sub    $0x8,%esp
f011d64d:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d650:	68 ac 09 13 f0       	push   $0xf01309ac
f011d655:	e8 31 39 fe ff       	call   f0100f8b <cprintf>
f011d65a:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d65d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d660:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d667:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d66d:	39 c2                	cmp    %eax,%edx
f011d66f:	74 28                	je     f011d699 <test_ksbrk+0xa65>
			{
				correct = 0;
f011d671:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d678:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d67b:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d682:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011d688:	50                   	push   %eax
f011d689:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d68c:	68 cc 09 13 f0       	push   $0xf01309cc
f011d691:	e8 f5 38 fe ff       	call   f0100f8b <cprintf>
f011d696:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d699:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d69c:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d6a3:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d6a6:	74 25                	je     f011d6cd <test_ksbrk+0xa99>
			{
				correct = 0;
f011d6a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d6af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d6b2:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d6b9:	ff 75 90             	pushl  -0x70(%ebp)
f011d6bc:	50                   	push   %eax
f011d6bd:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d6c0:	68 04 0a 13 f0       	push   $0xf0130a04
f011d6c5:	e8 c1 38 fe ff       	call   f0100f8b <cprintf>
f011d6ca:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d6cd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d6d1:	74 04                	je     f011d6d7 <test_ksbrk+0xaa3>
				eval += 10;
f011d6d3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d6d7:	ff 45 d4             	incl   -0x2c(%ebp)
f011d6da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d6dd:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011d6e0:	0f 82 dc fe ff ff    	jb     f011d5c2 <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011d6e6:	83 ec 08             	sub    $0x8,%esp
f011d6e9:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d6ec:	68 38 0a 13 f0       	push   $0xf0130a38
f011d6f1:	e8 95 38 fe ff       	call   f0100f8b <cprintf>
f011d6f6:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011d6f9:	83 ec 0c             	sub    $0xc,%esp
f011d6fc:	68 62 0a 13 f0       	push   $0xf0130a62
f011d701:	e8 85 38 fe ff       	call   f0100f8b <cprintf>
f011d706:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d709:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d70e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d711:	5b                   	pop    %ebx
f011d712:	5e                   	pop    %esi
f011d713:	5f                   	pop    %edi
f011d714:	5d                   	pop    %ebp
f011d715:	c3                   	ret    

f011d716 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011d716:	55                   	push   %ebp
f011d717:	89 e5                	mov    %esp,%ebp
f011d719:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d71c:	83 ec 04             	sub    $0x4,%esp
f011d71f:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d724:	68 c2 08 00 00       	push   $0x8c2
f011d729:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d72e:	e8 06 2c fe ff       	call   f0100339 <_panic>

f011d733 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011d733:	55                   	push   %ebp
f011d734:	89 e5                	mov    %esp,%ebp
f011d736:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d739:	83 ec 04             	sub    $0x4,%esp
f011d73c:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d741:	68 c7 08 00 00       	push   $0x8c7
f011d746:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d74b:	e8 e9 2b fe ff       	call   f0100339 <_panic>

f011d750 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011d750:	55                   	push   %ebp
f011d751:	89 e5                	mov    %esp,%ebp
f011d753:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d756:	83 ec 04             	sub    $0x4,%esp
f011d759:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d75e:	68 cc 08 00 00       	push   $0x8cc
f011d763:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d768:	e8 cc 2b fe ff       	call   f0100339 <_panic>

f011d76d <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011d76d:	55                   	push   %ebp
f011d76e:	89 e5                	mov    %esp,%ebp
f011d770:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d773:	83 ec 04             	sub    $0x4,%esp
f011d776:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d77b:	68 d1 08 00 00       	push   $0x8d1
f011d780:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d785:	e8 af 2b fe ff       	call   f0100339 <_panic>

f011d78a <test_kfree>:
}

int test_kfree()
{
f011d78a:	55                   	push   %ebp
f011d78b:	89 e5                	mov    %esp,%ebp
f011d78d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d790:	83 ec 04             	sub    $0x4,%esp
f011d793:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d798:	68 d6 08 00 00       	push   $0x8d6
f011d79d:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d7a2:	e8 92 2b fe ff       	call   f0100339 <_panic>

f011d7a7 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011d7a7:	55                   	push   %ebp
f011d7a8:	89 e5                	mov    %esp,%ebp
f011d7aa:	57                   	push   %edi
f011d7ab:	56                   	push   %esi
f011d7ac:	53                   	push   %ebx
f011d7ad:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011d7b3:	a0 3c 0e 18 f0       	mov    0xf0180e3c,%al
f011d7b8:	84 c0                	test   %al,%al
f011d7ba:	74 56                	je     f011d812 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011d7bc:	c6 05 3c 0e 18 f0 00 	movb   $0x0,0xf0180e3c
		initFreeFrames = sys_calculate_free_frames() ;
f011d7c3:	e8 80 14 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d7c8:	a3 88 01 6f f2       	mov    %eax,0xf26f0188
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011d7cd:	e8 c1 72 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d7d2:	a3 84 01 6f f2       	mov    %eax,0xf26f0184
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011d7d7:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d7dd:	bb 19 0c 13 f0       	mov    $0xf0130c19,%ebx
f011d7e2:	ba 11 00 00 00       	mov    $0x11,%edx
f011d7e7:	89 c7                	mov    %eax,%edi
f011d7e9:	89 de                	mov    %ebx,%esi
f011d7eb:	89 d1                	mov    %edx,%ecx
f011d7ed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011d7ef:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011d7f5:	b9 53 00 00 00       	mov    $0x53,%ecx
f011d7fa:	b0 00                	mov    $0x0,%al
f011d7fc:	89 d7                	mov    %edx,%edi
f011d7fe:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011d800:	83 ec 0c             	sub    $0xc,%esp
f011d803:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d809:	50                   	push   %eax
f011d80a:	e8 ec 46 fe ff       	call   f0101efb <execute_command>
f011d80f:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011d812:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011d819:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d820:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f011d825:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d828:	eb 2b                	jmp    f011d855 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011d82a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d82d:	83 c0 20             	add    $0x20,%eax
f011d830:	83 ec 08             	sub    $0x8,%esp
f011d833:	68 c4 0a 13 f0       	push   $0xf0130ac4
f011d838:	50                   	push   %eax
f011d839:	e8 ea 28 00 00       	call   f0120128 <strcmp>
f011d83e:	83 c4 10             	add    $0x10,%esp
f011d841:	85 c0                	test   %eax,%eax
f011d843:	75 08                	jne    f011d84d <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011d845:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d848:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011d84b:	eb 2f                	jmp    f011d87c <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d84d:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f011d852:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d855:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d859:	74 08                	je     f011d863 <test_three_creation_functions+0xbc>
f011d85b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d85e:	8b 40 08             	mov    0x8(%eax),%eax
f011d861:	eb 05                	jmp    f011d868 <test_three_creation_functions+0xc1>
f011d863:	b8 00 00 00 00       	mov    $0x0,%eax
f011d868:	a3 a8 d2 75 f0       	mov    %eax,0xf075d2a8
f011d86d:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f011d872:	85 c0                	test   %eax,%eax
f011d874:	75 b4                	jne    f011d82a <test_three_creation_functions+0x83>
f011d876:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d87a:	75 ae                	jne    f011d82a <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011d87c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d87f:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011d885:	85 c0                	test   %eax,%eax
f011d887:	74 17                	je     f011d8a0 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011d889:	83 ec 04             	sub    $0x4,%esp
f011d88c:	68 cc 0a 13 f0       	push   $0xf0130acc
f011d891:	68 f7 08 00 00       	push   $0x8f7
f011d896:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d89b:	e8 99 2a fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011d8a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d8a3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011d8a9:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011d8ac:	e8 97 13 ff ff       	call   f010ec48 <sys_calculate_free_frames>
f011d8b1:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011d8b4:	e8 da 71 fe ff       	call   f0104a93 <pf_calculate_free_frames>
f011d8b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d8bc:	a1 84 01 6f f2       	mov    0xf26f0184,%eax
f011d8c1:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011d8c4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d8c7:	74 17                	je     f011d8e0 <test_three_creation_functions+0x139>
f011d8c9:	83 ec 04             	sub    $0x4,%esp
f011d8cc:	68 0c d5 12 f0       	push   $0xf012d50c
f011d8d1:	68 01 09 00 00       	push   $0x901
f011d8d6:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d8db:	e8 59 2a fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011d8e0:	a1 88 01 6f f2       	mov    0xf26f0188,%eax
f011d8e5:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011d8e8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d8eb:	83 c2 15             	add    $0x15,%edx
f011d8ee:	39 d0                	cmp    %edx,%eax
f011d8f0:	74 17                	je     f011d909 <test_three_creation_functions+0x162>
f011d8f2:	83 ec 04             	sub    $0x4,%esp
f011d8f5:	68 1c 0b 13 f0       	push   $0xf0130b1c
f011d8fa:	68 03 09 00 00       	push   $0x903
f011d8ff:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d904:	e8 30 2a fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011d909:	83 ec 0c             	sub    $0xc,%esp
f011d90c:	68 00 10 00 00       	push   $0x1000
f011d911:	e8 b9 be fe ff       	call   f01097cf <kmalloc>
f011d916:	83 c4 10             	add    $0x10,%esp
f011d919:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011d91c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d91f:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011d924:	74 17                	je     f011d93d <test_three_creation_functions+0x196>
f011d926:	83 ec 04             	sub    $0x4,%esp
f011d929:	68 5c 0b 13 f0       	push   $0xf0130b5c
f011d92e:	68 07 09 00 00       	push   $0x907
f011d933:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d938:	e8 fc 29 fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011d93d:	83 ec 0c             	sub    $0xc,%esp
f011d940:	68 cc 0b 13 f0       	push   $0xf0130bcc
f011d945:	e8 41 36 fe ff       	call   f0100f8b <cprintf>
f011d94a:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d94d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011d952:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d955:	5b                   	pop    %ebx
f011d956:	5e                   	pop    %esi
f011d957:	5f                   	pop    %edi
f011d958:	5d                   	pop    %ebp
f011d959:	c3                   	ret    

f011d95a <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011d95a:	55                   	push   %ebp
f011d95b:	89 e5                	mov    %esp,%ebp
f011d95d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d960:	83 ec 04             	sub    $0x4,%esp
f011d963:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d968:	68 15 09 00 00       	push   $0x915
f011d96d:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d972:	e8 c2 29 fe ff       	call   f0100339 <_panic>

f011d977 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011d977:	55                   	push   %ebp
f011d978:	89 e5                	mov    %esp,%ebp
f011d97a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d97d:	83 ec 04             	sub    $0x4,%esp
f011d980:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d985:	68 1d 09 00 00       	push   $0x91d
f011d98a:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d98f:	e8 a5 29 fe ff       	call   f0100339 <_panic>

f011d994 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011d994:	55                   	push   %ebp
f011d995:	89 e5                	mov    %esp,%ebp
f011d997:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d99a:	83 ec 04             	sub    $0x4,%esp
f011d99d:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d9a2:	68 24 09 00 00       	push   $0x924
f011d9a7:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d9ac:	e8 88 29 fe ff       	call   f0100339 <_panic>

f011d9b1 <test_kfreelast>:

}


int test_kfreelast()
{
f011d9b1:	55                   	push   %ebp
f011d9b2:	89 e5                	mov    %esp,%ebp
f011d9b4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d9b7:	83 ec 04             	sub    $0x4,%esp
f011d9ba:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d9bf:	68 2b 09 00 00       	push   $0x92b
f011d9c4:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d9c9:	e8 6b 29 fe ff       	call   f0100339 <_panic>

f011d9ce <test_krealloc>:

}

int test_krealloc() {
f011d9ce:	55                   	push   %ebp
f011d9cf:	89 e5                	mov    %esp,%ebp
f011d9d1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d9d4:	83 ec 04             	sub    $0x4,%esp
f011d9d7:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d9dc:	68 30 09 00 00       	push   $0x930
f011d9e1:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011d9e6:	e8 4e 29 fe ff       	call   f0100339 <_panic>

f011d9eb <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011d9eb:	55                   	push   %ebp
f011d9ec:	89 e5                	mov    %esp,%ebp
f011d9ee:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d9f1:	83 ec 04             	sub    $0x4,%esp
f011d9f4:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011d9f9:	68 35 09 00 00       	push   $0x935
f011d9fe:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011da03:	e8 31 29 fe ff       	call   f0100339 <_panic>

f011da08 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011da08:	55                   	push   %ebp
f011da09:	89 e5                	mov    %esp,%ebp
f011da0b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011da0e:	83 ec 04             	sub    $0x4,%esp
f011da11:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011da16:	68 3b 09 00 00       	push   $0x93b
f011da1b:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011da20:	e8 14 29 fe ff       	call   f0100339 <_panic>

f011da25 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011da25:	55                   	push   %ebp
f011da26:	89 e5                	mov    %esp,%ebp
f011da28:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011da2b:	83 ec 04             	sub    $0x4,%esp
f011da2e:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011da33:	68 40 09 00 00       	push   $0x940
f011da38:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011da3d:	e8 f7 28 fe ff       	call   f0100339 <_panic>

f011da42 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011da42:	55                   	push   %ebp
f011da43:	89 e5                	mov    %esp,%ebp
f011da45:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011da48:	83 ec 04             	sub    $0x4,%esp
f011da4b:	68 b4 0a 13 f0       	push   $0xf0130ab4
f011da50:	68 46 09 00 00       	push   $0x946
f011da55:	68 f3 d4 12 f0       	push   $0xf012d4f3
f011da5a:	e8 da 28 fe ff       	call   f0100339 <_panic>

f011da5f <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011da5f:	55                   	push   %ebp
f011da60:	89 e5                	mov    %esp,%ebp
f011da62:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011da65:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011da6c:	e9 84 00 00 00       	jmp    f011daf5 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011da71:	83 ec 08             	sub    $0x8,%esp
f011da74:	ff 75 f4             	pushl  -0xc(%ebp)
f011da77:	68 80 0c 13 f0       	push   $0xf0130c80
f011da7c:	e8 0a 35 fe ff       	call   f0100f8b <cprintf>
f011da81:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011da84:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011da8b:	eb 4c                	jmp    f011dad9 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011da8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011da90:	89 d0                	mov    %edx,%eax
f011da92:	c1 e0 02             	shl    $0x2,%eax
f011da95:	01 d0                	add    %edx,%eax
f011da97:	c1 e0 03             	shl    $0x3,%eax
f011da9a:	89 c2                	mov    %eax,%edx
f011da9c:	8b 45 08             	mov    0x8(%ebp),%eax
f011da9f:	01 c2                	add    %eax,%edx
f011daa1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011daa4:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011daa7:	85 c0                	test   %eax,%eax
f011daa9:	74 36                	je     f011dae1 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011daab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011daae:	89 d0                	mov    %edx,%eax
f011dab0:	c1 e0 02             	shl    $0x2,%eax
f011dab3:	01 d0                	add    %edx,%eax
f011dab5:	c1 e0 03             	shl    $0x3,%eax
f011dab8:	89 c2                	mov    %eax,%edx
f011daba:	8b 45 08             	mov    0x8(%ebp),%eax
f011dabd:	01 c2                	add    %eax,%edx
f011dabf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dac2:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011dac5:	83 ec 08             	sub    $0x8,%esp
f011dac8:	50                   	push   %eax
f011dac9:	68 88 0c 13 f0       	push   $0xf0130c88
f011dace:	e8 b8 34 fe ff       	call   f0100f8b <cprintf>
f011dad3:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011dad6:	ff 45 f0             	incl   -0x10(%ebp)
f011dad9:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011dadd:	7e ae                	jle    f011da8d <print_order+0x2e>
f011dadf:	eb 01                	jmp    f011dae2 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011dae1:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011dae2:	83 ec 0c             	sub    $0xc,%esp
f011dae5:	68 8d 0c 13 f0       	push   $0xf0130c8d
f011daea:	e8 9c 34 fe ff       	call   f0100f8b <cprintf>
f011daef:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011daf2:	ff 45 f4             	incl   -0xc(%ebp)
f011daf5:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011daf9:	0f 8e 72 ff ff ff    	jle    f011da71 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011daff:	90                   	nop
f011db00:	c9                   	leave  
f011db01:	c3                   	ret    

f011db02 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011db02:	55                   	push   %ebp
f011db03:	89 e5                	mov    %esp,%ebp
f011db05:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011db08:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011db0f:	83 ec 0c             	sub    $0xc,%esp
f011db12:	68 20 d2 75 f0       	push   $0xf075d220
f011db17:	e8 52 25 ff ff       	call   f011006e <acquire_spinlock>
f011db1c:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011db1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011db26:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011db2d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011db30:	8b 45 10             	mov    0x10(%ebp),%eax
f011db33:	01 d0                	add    %edx,%eax
f011db35:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011db38:	a1 ac d2 75 f0       	mov    0xf075d2ac,%eax
f011db3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011db40:	a1 a4 d2 75 f0       	mov    0xf075d2a4,%eax
f011db45:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011db48:	ff 75 e8             	pushl  -0x18(%ebp)
f011db4b:	ff 75 0c             	pushl  0xc(%ebp)
f011db4e:	ff 75 08             	pushl  0x8(%ebp)
f011db51:	68 90 0c 13 f0       	push   $0xf0130c90
f011db56:	e8 30 34 fe ff       	call   f0100f8b <cprintf>
f011db5b:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011db5e:	eb 34                	jmp    f011db94 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011db60:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db63:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011db66:	7d 05                	jge    f011db6d <find_in_range+0x6b>
			{
				i++;
f011db68:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011db6b:	eb 1e                	jmp    f011db8b <find_in_range+0x89>
			}
			if (i >= end)
f011db6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db70:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011db73:	7d 29                	jge    f011db9e <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011db75:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011db78:	8b 40 10             	mov    0x10(%eax),%eax
f011db7b:	3b 45 08             	cmp    0x8(%ebp),%eax
f011db7e:	75 08                	jne    f011db88 <find_in_range+0x86>
			{
				ret = i;
f011db80:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db83:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011db86:	eb 17                	jmp    f011db9f <find_in_range+0x9d>
			}
			i++;
f011db88:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011db8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011db8e:	8b 40 0c             	mov    0xc(%eax),%eax
f011db91:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011db94:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db97:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011db9a:	7c c4                	jl     f011db60 <find_in_range+0x5e>
f011db9c:	eb 01                	jmp    f011db9f <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011db9e:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011db9f:	83 ec 0c             	sub    $0xc,%esp
f011dba2:	68 20 d2 75 f0       	push   $0xf075d220
f011dba7:	e8 49 25 ff ff       	call   f01100f5 <release_spinlock>
f011dbac:	83 c4 10             	add    $0x10,%esp
	return ret;
f011dbaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011dbb2:	c9                   	leave  
f011dbb3:	c3                   	ret    

f011dbb4 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011dbb4:	55                   	push   %ebp
f011dbb5:	89 e5                	mov    %esp,%ebp
f011dbb7:	57                   	push   %edi
f011dbb8:	56                   	push   %esi
f011dbb9:	53                   	push   %ebx
f011dbba:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011dbbd:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011dbc2:	84 c0                	test   %al,%al
f011dbc4:	0f 84 9b 01 00 00    	je     f011dd65 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011dbca:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		int nice_values[] = {-10, -5, 0, 5, 10};
f011dbd1:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dbd4:	bb 08 0e 13 f0       	mov    $0xf0130e08,%ebx
f011dbd9:	ba 05 00 00 00       	mov    $0x5,%edx
f011dbde:	89 c7                	mov    %eax,%edi
f011dbe0:	89 de                	mov    %ebx,%esi
f011dbe2:	89 d1                	mov    %edx,%ecx
f011dbe4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011dbe6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011dbed:	e9 44 01 00 00       	jmp    f011dd36 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011dbf2:	6a 00                	push   $0x0
f011dbf4:	6a 00                	push   $0x0
f011dbf6:	68 f4 01 00 00       	push   $0x1f4
f011dbfb:	68 c1 0c 13 f0       	push   $0xf0130cc1
f011dc00:	e8 a2 d6 fe ff       	call   f010b2a7 <env_create>
f011dc05:	83 c4 10             	add    $0x10,%esp
f011dc08:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011dc0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dc0e:	b9 05 00 00 00       	mov    $0x5,%ecx
f011dc13:	99                   	cltd   
f011dc14:	f7 f9                	idiv   %ecx
f011dc16:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011dc19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dc1c:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dc20:	83 ec 08             	sub    $0x8,%esp
f011dc23:	50                   	push   %eax
f011dc24:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dc27:	e8 c5 8c fe ff       	call   f01068f1 <env_set_nice>
f011dc2c:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011dc2f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011dc33:	75 14                	jne    f011dc49 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011dc35:	83 ec 04             	sub    $0x4,%esp
f011dc38:	68 c9 0c 13 f0       	push   $0xf0130cc9
f011dc3d:	6a 53                	push   $0x53
f011dc3f:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011dc44:	e8 f0 26 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011dc49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dc4c:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dc52:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dc57:	74 14                	je     f011dc6d <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011dc59:	83 ec 04             	sub    $0x4,%esp
f011dc5c:	68 00 0d 13 f0       	push   $0xf0130d00
f011dc61:	6a 55                	push   $0x55
f011dc63:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011dc68:	e8 cc 26 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011dc6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dc70:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dc74:	83 c0 0a             	add    $0xa,%eax
f011dc77:	83 f8 14             	cmp    $0x14,%eax
f011dc7a:	0f 87 a5 00 00 00    	ja     f011dd25 <test_bsd_nice_0+0x171>
f011dc80:	8b 04 85 1c 0e 13 f0 	mov    -0xfecf1e4(,%eax,4),%eax
f011dc87:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011dc89:	a1 bc cf 75 f0       	mov    0xf075cfbc,%eax
f011dc8e:	8d 50 01             	lea    0x1(%eax),%edx
f011dc91:	89 15 bc cf 75 f0    	mov    %edx,0xf075cfbc
f011dc97:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dc9a:	8b 52 10             	mov    0x10(%edx),%edx
f011dc9d:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011dca4:	eb 7f                	jmp    f011dd25 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011dca6:	a1 c0 cf 75 f0       	mov    0xf075cfc0,%eax
f011dcab:	8d 50 01             	lea    0x1(%eax),%edx
f011dcae:	89 15 c0 cf 75 f0    	mov    %edx,0xf075cfc0
f011dcb4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dcb7:	8b 52 10             	mov    0x10(%edx),%edx
f011dcba:	83 c0 0a             	add    $0xa,%eax
f011dcbd:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011dcc4:	eb 5f                	jmp    f011dd25 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011dcc6:	a1 c4 cf 75 f0       	mov    0xf075cfc4,%eax
f011dccb:	8d 50 01             	lea    0x1(%eax),%edx
f011dcce:	89 15 c4 cf 75 f0    	mov    %edx,0xf075cfc4
f011dcd4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dcd7:	8b 52 10             	mov    0x10(%edx),%edx
f011dcda:	83 c0 14             	add    $0x14,%eax
f011dcdd:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011dce4:	eb 3f                	jmp    f011dd25 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011dce6:	a1 c8 cf 75 f0       	mov    0xf075cfc8,%eax
f011dceb:	8d 50 01             	lea    0x1(%eax),%edx
f011dcee:	89 15 c8 cf 75 f0    	mov    %edx,0xf075cfc8
f011dcf4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dcf7:	8b 52 10             	mov    0x10(%edx),%edx
f011dcfa:	83 c0 1e             	add    $0x1e,%eax
f011dcfd:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011dd04:	eb 1f                	jmp    f011dd25 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011dd06:	a1 cc cf 75 f0       	mov    0xf075cfcc,%eax
f011dd0b:	8d 50 01             	lea    0x1(%eax),%edx
f011dd0e:	89 15 cc cf 75 f0    	mov    %edx,0xf075cfcc
f011dd14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011dd17:	8b 52 10             	mov    0x10(%edx),%edx
f011dd1a:	83 c0 28             	add    $0x28,%eax
f011dd1d:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011dd24:	90                   	nop
			}
			sched_new_env(env);
f011dd25:	83 ec 0c             	sub    $0xc,%esp
f011dd28:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dd2b:	e8 57 7c fe ff       	call   f0105987 <sched_new_env>
f011dd30:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011dd33:	ff 45 e4             	incl   -0x1c(%ebp)
f011dd36:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011dd3a:	0f 8e b2 fe ff ff    	jle    f011dbf2 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011dd40:	83 ec 0c             	sub    $0xc,%esp
f011dd43:	68 30 0d 13 f0       	push   $0xf0130d30
f011dd48:	e8 3e 32 fe ff       	call   f0100f8b <cprintf>
f011dd4d:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011dd50:	83 ec 0c             	sub    $0xc,%esp
f011dd53:	68 7f 0d 13 f0       	push   $0xf0130d7f
f011dd58:	e8 9e 41 fe ff       	call   f0101efb <execute_command>
f011dd5d:	83 c4 10             	add    $0x10,%esp
f011dd60:	e9 c0 00 00 00       	jmp    f011de25 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011dd65:	83 ec 0c             	sub    $0xc,%esp
f011dd68:	68 86 0d 13 f0       	push   $0xf0130d86
f011dd6d:	e8 19 32 fe ff       	call   f0100f8b <cprintf>
f011dd72:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dd75:	e8 45 83 fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011dd7a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011dd81:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011dd88:	e9 87 00 00 00       	jmp    f011de14 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011dd8d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011dd94:	eb 52                	jmp    f011dde8 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011dd96:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dd99:	8b 14 85 bc cf 75 f0 	mov    -0xf8a3044(,%eax,4),%edx
f011dda0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011dda3:	89 c8                	mov    %ecx,%eax
f011dda5:	c1 e0 02             	shl    $0x2,%eax
f011dda8:	01 c8                	add    %ecx,%eax
f011ddaa:	01 c0                	add    %eax,%eax
f011ddac:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011ddaf:	01 c8                	add    %ecx,%eax
f011ddb1:	8b 04 85 a0 01 6f f2 	mov    -0xd90fe60(,%eax,4),%eax
f011ddb8:	83 ec 04             	sub    $0x4,%esp
f011ddbb:	52                   	push   %edx
f011ddbc:	ff 75 e0             	pushl  -0x20(%ebp)
f011ddbf:	50                   	push   %eax
f011ddc0:	e8 3d fd ff ff       	call   f011db02 <find_in_range>
f011ddc5:	83 c4 10             	add    $0x10,%esp
f011ddc8:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011ddcb:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011ddcf:	75 14                	jne    f011dde5 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011ddd1:	83 ec 04             	sub    $0x4,%esp
f011ddd4:	68 98 0d 13 f0       	push   $0xf0130d98
f011ddd9:	6a 7b                	push   $0x7b
f011dddb:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011dde0:	e8 54 25 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011dde5:	ff 45 d8             	incl   -0x28(%ebp)
f011dde8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ddeb:	89 d0                	mov    %edx,%eax
f011dded:	c1 e0 02             	shl    $0x2,%eax
f011ddf0:	01 d0                	add    %edx,%eax
f011ddf2:	01 c0                	add    %eax,%eax
f011ddf4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ddf7:	01 d0                	add    %edx,%eax
f011ddf9:	8b 04 85 a0 01 6f f2 	mov    -0xd90fe60(,%eax,4),%eax
f011de00:	85 c0                	test   %eax,%eax
f011de02:	75 92                	jne    f011dd96 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011de04:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de07:	8b 04 85 bc cf 75 f0 	mov    -0xf8a3044(,%eax,4),%eax
f011de0e:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011de11:	ff 45 dc             	incl   -0x24(%ebp)
f011de14:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011de18:	0f 8e 6f ff ff ff    	jle    f011dd8d <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011de1e:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011de25:	83 ec 0c             	sub    $0xc,%esp
f011de28:	68 cc 0d 13 f0       	push   $0xf0130dcc
f011de2d:	e8 59 31 fe ff       	call   f0100f8b <cprintf>
f011de32:	83 c4 10             	add    $0x10,%esp
}
f011de35:	90                   	nop
f011de36:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011de39:	5b                   	pop    %ebx
f011de3a:	5e                   	pop    %esi
f011de3b:	5f                   	pop    %edi
f011de3c:	5d                   	pop    %ebp
f011de3d:	c3                   	ret    

f011de3e <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011de3e:	55                   	push   %ebp
f011de3f:	89 e5                	mov    %esp,%ebp
f011de41:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011de44:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011de49:	84 c0                	test   %al,%al
f011de4b:	0f 84 50 01 00 00    	je     f011dfa1 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011de51:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011de58:	6a 00                	push   $0x0
f011de5a:	6a 00                	push   $0x0
f011de5c:	68 f4 01 00 00       	push   $0x1f4
f011de61:	68 c1 0c 13 f0       	push   $0xf0130cc1
f011de66:	e8 3c d4 fe ff       	call   f010b2a7 <env_create>
f011de6b:	83 c4 10             	add    $0x10,%esp
f011de6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011de71:	6a 00                	push   $0x0
f011de73:	6a 00                	push   $0x0
f011de75:	68 f4 01 00 00       	push   $0x1f4
f011de7a:	68 70 0e 13 f0       	push   $0xf0130e70
f011de7f:	e8 23 d4 fe ff       	call   f010b2a7 <env_create>
f011de84:	83 c4 10             	add    $0x10,%esp
f011de87:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011de8a:	6a 00                	push   $0x0
f011de8c:	6a 00                	push   $0x0
f011de8e:	68 f4 01 00 00       	push   $0x1f4
f011de93:	68 7d 0e 13 f0       	push   $0xf0130e7d
f011de98:	e8 0a d4 fe ff       	call   f010b2a7 <env_create>
f011de9d:	83 c4 10             	add    $0x10,%esp
f011dea0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011dea3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011dea7:	74 0c                	je     f011deb5 <test_bsd_nice_1+0x77>
f011dea9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011dead:	74 06                	je     f011deb5 <test_bsd_nice_1+0x77>
f011deaf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011deb3:	75 17                	jne    f011decc <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011deb5:	83 ec 04             	sub    $0x4,%esp
f011deb8:	68 c9 0c 13 f0       	push   $0xf0130cc9
f011debd:	68 8e 00 00 00       	push   $0x8e
f011dec2:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011dec7:	e8 6d 24 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011decc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011decf:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011ded5:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011deda:	75 20                	jne    f011defc <test_bsd_nice_1+0xbe>
f011dedc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dedf:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dee5:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011deea:	75 10                	jne    f011defc <test_bsd_nice_1+0xbe>
f011deec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011deef:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011def5:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011defa:	74 35                	je     f011df31 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011defc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011deff:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011df05:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011df08:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011df0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011df11:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011df17:	83 ec 08             	sub    $0x8,%esp
f011df1a:	51                   	push   %ecx
f011df1b:	52                   	push   %edx
f011df1c:	50                   	push   %eax
f011df1d:	68 8c 0e 13 f0       	push   $0xf0130e8c
f011df22:	68 90 00 00 00       	push   $0x90
f011df27:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011df2c:	e8 08 24 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011df31:	83 ec 0c             	sub    $0xc,%esp
f011df34:	ff 75 ec             	pushl  -0x14(%ebp)
f011df37:	e8 4b 7a fe ff       	call   f0105987 <sched_new_env>
f011df3c:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011df3f:	83 ec 0c             	sub    $0xc,%esp
f011df42:	ff 75 e8             	pushl  -0x18(%ebp)
f011df45:	e8 3d 7a fe ff       	call   f0105987 <sched_new_env>
f011df4a:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011df4d:	83 ec 0c             	sub    $0xc,%esp
f011df50:	ff 75 e4             	pushl  -0x1c(%ebp)
f011df53:	e8 2f 7a fe ff       	call   f0105987 <sched_new_env>
f011df58:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011df5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011df5e:	8b 40 10             	mov    0x10(%eax),%eax
f011df61:	a3 a0 01 6f f2       	mov    %eax,0xf26f01a0
		prog_orders[1][0] = fibEnv->env_id;
f011df66:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011df69:	8b 40 10             	mov    0x10(%eax),%eax
f011df6c:	a3 c8 01 6f f2       	mov    %eax,0xf26f01c8
		prog_orders[2][0] = fibposnEnv->env_id;
f011df71:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011df74:	8b 40 10             	mov    0x10(%eax),%eax
f011df77:	a3 f0 01 6f f2       	mov    %eax,0xf26f01f0
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011df7c:	83 ec 0c             	sub    $0xc,%esp
f011df7f:	68 30 0d 13 f0       	push   $0xf0130d30
f011df84:	e8 02 30 fe ff       	call   f0100f8b <cprintf>
f011df89:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011df8c:	83 ec 0c             	sub    $0xc,%esp
f011df8f:	68 7f 0d 13 f0       	push   $0xf0130d7f
f011df94:	e8 62 3f fe ff       	call   f0101efb <execute_command>
f011df99:	83 c4 10             	add    $0x10,%esp
f011df9c:	e9 9e 00 00 00       	jmp    f011e03f <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011dfa1:	83 ec 0c             	sub    $0xc,%esp
f011dfa4:	68 86 0d 13 f0       	push   $0xf0130d86
f011dfa9:	e8 dd 2f fe ff       	call   f0100f8b <cprintf>
f011dfae:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dfb1:	e8 09 81 fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011dfb6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011dfbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011dfc4:	83 ec 0c             	sub    $0xc,%esp
f011dfc7:	68 20 d2 75 f0       	push   $0xf075d220
f011dfcc:	e8 9d 20 ff ff       	call   f011006e <acquire_spinlock>
f011dfd1:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011dfd4:	a1 ac d2 75 f0       	mov    0xf075d2ac,%eax
f011dfd9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011dfdc:	a1 a4 d2 75 f0       	mov    0xf075d2a4,%eax
f011dfe1:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dfe4:	eb 41                	jmp    f011e027 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011dfe6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dfe9:	89 d0                	mov    %edx,%eax
f011dfeb:	c1 e0 02             	shl    $0x2,%eax
f011dfee:	01 d0                	add    %edx,%eax
f011dff0:	c1 e0 03             	shl    $0x3,%eax
f011dff3:	05 a0 01 6f f2       	add    $0xf26f01a0,%eax
f011dff8:	8b 10                	mov    (%eax),%edx
f011dffa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dffd:	8b 40 10             	mov    0x10(%eax),%eax
f011e000:	39 c2                	cmp    %eax,%edx
f011e002:	74 17                	je     f011e01b <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011e004:	83 ec 04             	sub    $0x4,%esp
f011e007:	68 98 0d 13 f0       	push   $0xf0130d98
f011e00c:	68 ab 00 00 00       	push   $0xab
f011e011:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011e016:	e8 1e 23 fe ff       	call   f0100339 <_panic>
				i++;
f011e01b:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e01e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e021:	8b 40 0c             	mov    0xc(%eax),%eax
f011e024:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e027:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e02a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e02d:	7c b7                	jl     f011dfe6 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e02f:	83 ec 0c             	sub    $0xc,%esp
f011e032:	68 20 d2 75 f0       	push   $0xf075d220
f011e037:	e8 b9 20 ff ff       	call   f01100f5 <release_spinlock>
f011e03c:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011e03f:	83 ec 0c             	sub    $0xc,%esp
f011e042:	68 f8 0e 13 f0       	push   $0xf0130ef8
f011e047:	e8 3f 2f fe ff       	call   f0100f8b <cprintf>
f011e04c:	83 c4 10             	add    $0x10,%esp
}
f011e04f:	90                   	nop
f011e050:	c9                   	leave  
f011e051:	c3                   	ret    

f011e052 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011e052:	55                   	push   %ebp
f011e053:	89 e5                	mov    %esp,%ebp
f011e055:	57                   	push   %edi
f011e056:	56                   	push   %esi
f011e057:	53                   	push   %ebx
f011e058:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011e05b:	a0 3d 0e 18 f0       	mov    0xf0180e3d,%al
f011e060:	84 c0                	test   %al,%al
f011e062:	0f 84 ae 01 00 00    	je     f011e216 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011e068:	83 ec 0c             	sub    $0xc,%esp
f011e06b:	6a 01                	push   $0x1
f011e06d:	e8 fe 10 00 00       	call   f011f170 <chksch>
f011e072:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011e075:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
		int nice_values[] = {15, 5, 0, -5, -15};
f011e07c:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e07f:	bb 7c 0f 13 f0       	mov    $0xf0130f7c,%ebx
f011e084:	ba 05 00 00 00       	mov    $0x5,%edx
f011e089:	89 c7                	mov    %eax,%edi
f011e08b:	89 de                	mov    %ebx,%esi
f011e08d:	89 d1                	mov    %edx,%ecx
f011e08f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e091:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011e098:	e9 4a 01 00 00       	jmp    f011e1e7 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011e09d:	6a 00                	push   $0x0
f011e09f:	6a 00                	push   $0x0
f011e0a1:	68 10 27 00 00       	push   $0x2710
f011e0a6:	68 34 0f 13 f0       	push   $0xf0130f34
f011e0ab:	e8 f7 d1 fe ff       	call   f010b2a7 <env_create>
f011e0b0:	83 c4 10             	add    $0x10,%esp
f011e0b3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011e0b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e0b9:	b9 05 00 00 00       	mov    $0x5,%ecx
f011e0be:	99                   	cltd   
f011e0bf:	f7 f9                	idiv   %ecx
f011e0c1:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011e0c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e0c7:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e0cb:	83 ec 08             	sub    $0x8,%esp
f011e0ce:	50                   	push   %eax
f011e0cf:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e0d2:	e8 1a 88 fe ff       	call   f01068f1 <env_set_nice>
f011e0d7:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011e0da:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011e0de:	75 17                	jne    f011e0f7 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011e0e0:	83 ec 04             	sub    $0x4,%esp
f011e0e3:	68 c9 0c 13 f0       	push   $0xf0130cc9
f011e0e8:	68 c1 00 00 00       	push   $0xc1
f011e0ed:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011e0f2:	e8 42 22 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011e0f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e0fa:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011e100:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011e105:	74 17                	je     f011e11e <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011e107:	83 ec 04             	sub    $0x4,%esp
f011e10a:	68 00 0d 13 f0       	push   $0xf0130d00
f011e10f:	68 c3 00 00 00       	push   $0xc3
f011e114:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011e119:	e8 1b 22 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011e11e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e121:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e125:	83 c0 0f             	add    $0xf,%eax
f011e128:	83 f8 1e             	cmp    $0x1e,%eax
f011e12b:	0f 87 a5 00 00 00    	ja     f011e1d6 <test_bsd_nice_2+0x184>
f011e131:	8b 04 85 90 0f 13 f0 	mov    -0xfecf070(,%eax,4),%eax
f011e138:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011e13a:	a1 bc cf 75 f0       	mov    0xf075cfbc,%eax
f011e13f:	8d 50 01             	lea    0x1(%eax),%edx
f011e142:	89 15 bc cf 75 f0    	mov    %edx,0xf075cfbc
f011e148:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e14b:	8b 52 10             	mov    0x10(%edx),%edx
f011e14e:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011e155:	eb 7f                	jmp    f011e1d6 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011e157:	a1 c0 cf 75 f0       	mov    0xf075cfc0,%eax
f011e15c:	8d 50 01             	lea    0x1(%eax),%edx
f011e15f:	89 15 c0 cf 75 f0    	mov    %edx,0xf075cfc0
f011e165:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e168:	8b 52 10             	mov    0x10(%edx),%edx
f011e16b:	83 c0 0a             	add    $0xa,%eax
f011e16e:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011e175:	eb 5f                	jmp    f011e1d6 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011e177:	a1 c4 cf 75 f0       	mov    0xf075cfc4,%eax
f011e17c:	8d 50 01             	lea    0x1(%eax),%edx
f011e17f:	89 15 c4 cf 75 f0    	mov    %edx,0xf075cfc4
f011e185:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e188:	8b 52 10             	mov    0x10(%edx),%edx
f011e18b:	83 c0 14             	add    $0x14,%eax
f011e18e:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011e195:	eb 3f                	jmp    f011e1d6 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011e197:	a1 c8 cf 75 f0       	mov    0xf075cfc8,%eax
f011e19c:	8d 50 01             	lea    0x1(%eax),%edx
f011e19f:	89 15 c8 cf 75 f0    	mov    %edx,0xf075cfc8
f011e1a5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e1a8:	8b 52 10             	mov    0x10(%edx),%edx
f011e1ab:	83 c0 1e             	add    $0x1e,%eax
f011e1ae:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011e1b5:	eb 1f                	jmp    f011e1d6 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011e1b7:	a1 cc cf 75 f0       	mov    0xf075cfcc,%eax
f011e1bc:	8d 50 01             	lea    0x1(%eax),%edx
f011e1bf:	89 15 cc cf 75 f0    	mov    %edx,0xf075cfcc
f011e1c5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e1c8:	8b 52 10             	mov    0x10(%edx),%edx
f011e1cb:	83 c0 28             	add    $0x28,%eax
f011e1ce:	89 14 85 a0 01 6f f2 	mov    %edx,-0xd90fe60(,%eax,4)
				break;
f011e1d5:	90                   	nop
			}
			sched_new_env(env);
f011e1d6:	83 ec 0c             	sub    $0xc,%esp
f011e1d9:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e1dc:	e8 a6 77 fe ff       	call   f0105987 <sched_new_env>
f011e1e1:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e1e4:	ff 45 e4             	incl   -0x1c(%ebp)
f011e1e7:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011e1eb:	0f 8e ac fe ff ff    	jle    f011e09d <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e1f1:	83 ec 0c             	sub    $0xc,%esp
f011e1f4:	68 30 0d 13 f0       	push   $0xf0130d30
f011e1f9:	e8 8d 2d fe ff       	call   f0100f8b <cprintf>
f011e1fe:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e201:	83 ec 0c             	sub    $0xc,%esp
f011e204:	68 7f 0d 13 f0       	push   $0xf0130d7f
f011e209:	e8 ed 3c fe ff       	call   f0101efb <execute_command>
f011e20e:	83 c4 10             	add    $0x10,%esp
f011e211:	e9 d0 00 00 00       	jmp    f011e2e6 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011e216:	83 ec 0c             	sub    $0xc,%esp
f011e219:	6a 00                	push   $0x0
f011e21b:	e8 50 0f 00 00       	call   f011f170 <chksch>
f011e220:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011e223:	83 ec 0c             	sub    $0xc,%esp
f011e226:	68 86 0d 13 f0       	push   $0xf0130d86
f011e22b:	e8 5b 2d fe ff       	call   f0100f8b <cprintf>
f011e230:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e233:	e8 87 7e fe ff       	call   f01060bf <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011e238:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e23f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011e246:	e9 8a 00 00 00       	jmp    f011e2d5 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e24b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011e252:	eb 55                	jmp    f011e2a9 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011e254:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e257:	8b 14 85 bc cf 75 f0 	mov    -0xf8a3044(,%eax,4),%edx
f011e25e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011e261:	89 c8                	mov    %ecx,%eax
f011e263:	c1 e0 02             	shl    $0x2,%eax
f011e266:	01 c8                	add    %ecx,%eax
f011e268:	01 c0                	add    %eax,%eax
f011e26a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011e26d:	01 c8                	add    %ecx,%eax
f011e26f:	8b 04 85 a0 01 6f f2 	mov    -0xd90fe60(,%eax,4),%eax
f011e276:	83 ec 04             	sub    $0x4,%esp
f011e279:	52                   	push   %edx
f011e27a:	ff 75 e0             	pushl  -0x20(%ebp)
f011e27d:	50                   	push   %eax
f011e27e:	e8 7f f8 ff ff       	call   f011db02 <find_in_range>
f011e283:	83 c4 10             	add    $0x10,%esp
f011e286:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011e289:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011e28d:	75 17                	jne    f011e2a6 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011e28f:	83 ec 04             	sub    $0x4,%esp
f011e292:	68 98 0d 13 f0       	push   $0xf0130d98
f011e297:	68 ea 00 00 00       	push   $0xea
f011e29c:	68 e2 0c 13 f0       	push   $0xf0130ce2
f011e2a1:	e8 93 20 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e2a6:	ff 45 d8             	incl   -0x28(%ebp)
f011e2a9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011e2ac:	89 d0                	mov    %edx,%eax
f011e2ae:	c1 e0 02             	shl    $0x2,%eax
f011e2b1:	01 d0                	add    %edx,%eax
f011e2b3:	01 c0                	add    %eax,%eax
f011e2b5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e2b8:	01 d0                	add    %edx,%eax
f011e2ba:	8b 04 85 a0 01 6f f2 	mov    -0xd90fe60(,%eax,4),%eax
f011e2c1:	85 c0                	test   %eax,%eax
f011e2c3:	75 8f                	jne    f011e254 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011e2c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e2c8:	8b 04 85 bc cf 75 f0 	mov    -0xf8a3044(,%eax,4),%eax
f011e2cf:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e2d2:	ff 45 dc             	incl   -0x24(%ebp)
f011e2d5:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011e2d9:	0f 8e 6c ff ff ff    	jle    f011e24b <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011e2df:	c6 05 3d 0e 18 f0 00 	movb   $0x0,0xf0180e3d
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011e2e6:	83 ec 0c             	sub    $0xc,%esp
f011e2e9:	68 40 0f 13 f0       	push   $0xf0130f40
f011e2ee:	e8 98 2c fe ff       	call   f0100f8b <cprintf>
f011e2f3:	83 c4 10             	add    $0x10,%esp
}
f011e2f6:	90                   	nop
f011e2f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011e2fa:	5b                   	pop    %ebx
f011e2fb:	5e                   	pop    %esi
f011e2fc:	5f                   	pop    %edi
f011e2fd:	5d                   	pop    %ebp
f011e2fe:	c3                   	ret    

f011e2ff <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011e2ff:	55                   	push   %ebp
f011e300:	89 e5                	mov    %esp,%ebp
f011e302:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011e305:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e308:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011e30b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e30e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011e311:	89 10                	mov    %edx,(%eax)
}
f011e313:	8b 45 08             	mov    0x8(%ebp),%eax
f011e316:	c9                   	leave  
f011e317:	c2 04 00             	ret    $0x4

f011e31a <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011e31a:	55                   	push   %ebp
f011e31b:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011e31d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e320:	85 c0                	test   %eax,%eax
f011e322:	78 16                	js     f011e33a <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011e324:	8b 45 08             	mov    0x8(%ebp),%eax
f011e327:	05 00 20 00 00       	add    $0x2000,%eax
f011e32c:	85 c0                	test   %eax,%eax
f011e32e:	79 05                	jns    f011e335 <fix_round+0x1b>
f011e330:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011e335:	c1 f8 0e             	sar    $0xe,%eax
f011e338:	eb 14                	jmp    f011e34e <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011e33a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e33d:	2d 00 20 00 00       	sub    $0x2000,%eax
f011e342:	85 c0                	test   %eax,%eax
f011e344:	79 05                	jns    f011e34b <fix_round+0x31>
f011e346:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011e34b:	c1 f8 0e             	sar    $0xe,%eax
}
f011e34e:	5d                   	pop    %ebp
f011e34f:	c3                   	ret    

f011e350 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011e350:	55                   	push   %ebp
f011e351:	89 e5                	mov    %esp,%ebp
f011e353:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011e356:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e35a:	79 16                	jns    f011e372 <fix_scale+0x22>
f011e35c:	68 0c 10 13 f0       	push   $0xf013100c
f011e361:	68 13 10 13 f0       	push   $0xf0131013
f011e366:	6a 5a                	push   $0x5a
f011e368:	68 28 10 13 f0       	push   $0xf0131028
f011e36d:	e8 c7 1f fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011e372:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e375:	0f af 45 10          	imul   0x10(%ebp),%eax
f011e379:	89 c2                	mov    %eax,%edx
f011e37b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e37e:	83 ec 08             	sub    $0x8,%esp
f011e381:	52                   	push   %edx
f011e382:	50                   	push   %eax
f011e383:	e8 77 ff ff ff       	call   f011e2ff <__mk_fix>
f011e388:	83 c4 0c             	add    $0xc,%esp
}
f011e38b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e38e:	c9                   	leave  
f011e38f:	c2 04 00             	ret    $0x4

f011e392 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011e392:	55                   	push   %ebp
f011e393:	89 e5                	mov    %esp,%ebp
f011e395:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011e398:	83 ec 08             	sub    $0x8,%esp
f011e39b:	68 3c 10 13 f0       	push   $0xf013103c
f011e3a0:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e3a5:	e8 93 1c ff ff       	call   f011003d <init_spinlock>
f011e3aa:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011e3ad:	83 ec 0c             	sub    $0xc,%esp
f011e3b0:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e3b5:	e8 b4 1c ff ff       	call   f011006e <acquire_spinlock>
f011e3ba:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011e3bd:	c7 05 08 d1 75 f0 00 	movl   $0x0,0xf075d108
f011e3c4:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011e3c7:	83 ec 0c             	sub    $0xc,%esp
f011e3ca:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e3cf:	e8 21 1d ff ff       	call   f01100f5 <release_spinlock>
f011e3d4:	83 c4 10             	add    $0x10,%esp
}
f011e3d7:	90                   	nop
f011e3d8:	c9                   	leave  
f011e3d9:	c3                   	ret    

f011e3da <inctst>:
void inctst()
{
f011e3da:	55                   	push   %ebp
f011e3db:	89 e5                	mov    %esp,%ebp
f011e3dd:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011e3e0:	83 ec 0c             	sub    $0xc,%esp
f011e3e3:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e3e8:	e8 81 1c ff ff       	call   f011006e <acquire_spinlock>
f011e3ed:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011e3f0:	a1 08 d1 75 f0       	mov    0xf075d108,%eax
f011e3f5:	40                   	inc    %eax
f011e3f6:	a3 08 d1 75 f0       	mov    %eax,0xf075d108
	}
	release_spinlock(&tstcntlock);
f011e3fb:	83 ec 0c             	sub    $0xc,%esp
f011e3fe:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e403:	e8 ed 1c ff ff       	call   f01100f5 <release_spinlock>
f011e408:	83 c4 10             	add    $0x10,%esp
}
f011e40b:	90                   	nop
f011e40c:	c9                   	leave  
f011e40d:	c3                   	ret    

f011e40e <gettst>:
uint32 gettst()
{
f011e40e:	55                   	push   %ebp
f011e40f:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011e411:	a1 08 d1 75 f0       	mov    0xf075d108,%eax
}
f011e416:	5d                   	pop    %ebp
f011e417:	c3                   	ret    

f011e418 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011e418:	55                   	push   %ebp
f011e419:	89 e5                	mov    %esp,%ebp
f011e41b:	83 ec 28             	sub    $0x28,%esp
f011e41e:	8b 45 14             	mov    0x14(%ebp),%eax
f011e421:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011e424:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011e42b:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011e42f:	83 f8 65             	cmp    $0x65,%eax
f011e432:	74 5d                	je     f011e491 <tst+0x79>
f011e434:	83 f8 65             	cmp    $0x65,%eax
f011e437:	7f 0a                	jg     f011e443 <tst+0x2b>
f011e439:	83 f8 62             	cmp    $0x62,%eax
f011e43c:	74 73                	je     f011e4b1 <tst+0x99>
f011e43e:	e9 91 00 00 00       	jmp    f011e4d4 <tst+0xbc>
f011e443:	83 f8 67             	cmp    $0x67,%eax
f011e446:	74 29                	je     f011e471 <tst+0x59>
f011e448:	83 f8 6c             	cmp    $0x6c,%eax
f011e44b:	0f 85 83 00 00 00    	jne    f011e4d4 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011e451:	8b 45 08             	mov    0x8(%ebp),%eax
f011e454:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e457:	73 09                	jae    f011e462 <tst+0x4a>
			chk = 1;
f011e459:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e460:	eb 68                	jmp    f011e4ca <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011e462:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e466:	74 62                	je     f011e4ca <tst+0xb2>
			chk = 1;
f011e468:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e46f:	eb 59                	jmp    f011e4ca <tst+0xb2>
	case 'g':
		if (n > v1)
f011e471:	8b 45 08             	mov    0x8(%ebp),%eax
f011e474:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e477:	76 09                	jbe    f011e482 <tst+0x6a>
			chk = 1;
f011e479:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e480:	eb 4b                	jmp    f011e4cd <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011e482:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e486:	74 45                	je     f011e4cd <tst+0xb5>
			chk = 1;
f011e488:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e48f:	eb 3c                	jmp    f011e4cd <tst+0xb5>
	case 'e':
		if (n == v1)
f011e491:	8b 45 08             	mov    0x8(%ebp),%eax
f011e494:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e497:	75 09                	jne    f011e4a2 <tst+0x8a>
			chk = 1;
f011e499:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e4a0:	eb 2e                	jmp    f011e4d0 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011e4a2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e4a6:	74 28                	je     f011e4d0 <tst+0xb8>
			chk = 1;
f011e4a8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e4af:	eb 1f                	jmp    f011e4d0 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011e4b1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4b4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e4b7:	72 1a                	jb     f011e4d3 <tst+0xbb>
f011e4b9:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4bc:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e4bf:	77 12                	ja     f011e4d3 <tst+0xbb>
			chk = 1;
f011e4c1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e4c8:	eb 09                	jmp    f011e4d3 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e4ca:	90                   	nop
f011e4cb:	eb 07                	jmp    f011e4d4 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e4cd:	90                   	nop
f011e4ce:	eb 04                	jmp    f011e4d4 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e4d0:	90                   	nop
f011e4d1:	eb 01                	jmp    f011e4d4 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011e4d3:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011e4d4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e4d8:	75 14                	jne    f011e4ee <tst+0xd6>
f011e4da:	83 ec 04             	sub    $0x4,%esp
f011e4dd:	68 48 10 13 f0       	push   $0xf0131048
f011e4e2:	6a 48                	push   $0x48
f011e4e4:	68 5b 10 13 f0       	push   $0xf013105b
f011e4e9:	e8 4b 1e fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011e4ee:	83 ec 0c             	sub    $0xc,%esp
f011e4f1:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e4f6:	e8 73 1b ff ff       	call   f011006e <acquire_spinlock>
f011e4fb:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011e4fe:	a1 08 d1 75 f0       	mov    0xf075d108,%eax
f011e503:	40                   	inc    %eax
f011e504:	a3 08 d1 75 f0       	mov    %eax,0xf075d108
	}
	release_spinlock(&tstcntlock);
f011e509:	83 ec 0c             	sub    $0xc,%esp
f011e50c:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e511:	e8 df 1b ff ff       	call   f01100f5 <release_spinlock>
f011e516:	83 c4 10             	add    $0x10,%esp

	return;
f011e519:	90                   	nop
}
f011e51a:	c9                   	leave  
f011e51b:	c3                   	ret    

f011e51c <chktst>:

void chktst(uint32 n)
{
f011e51c:	55                   	push   %ebp
f011e51d:	89 e5                	mov    %esp,%ebp
f011e51f:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011e522:	83 ec 0c             	sub    $0xc,%esp
f011e525:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e52a:	e8 3f 1b ff ff       	call   f011006e <acquire_spinlock>
f011e52f:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011e532:	a1 08 d1 75 f0       	mov    0xf075d108,%eax
f011e537:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011e53a:	83 ec 0c             	sub    $0xc,%esp
f011e53d:	68 a0 da f5 f0       	push   $0xf0f5daa0
f011e542:	e8 ae 1b ff ff       	call   f01100f5 <release_spinlock>
f011e547:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011e54a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e54d:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e550:	75 12                	jne    f011e564 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011e552:	83 ec 0c             	sub    $0xc,%esp
f011e555:	68 74 10 13 f0       	push   $0xf0131074
f011e55a:	e8 2c 2a fe ff       	call   f0100f8b <cprintf>
f011e55f:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011e562:	eb 14                	jmp    f011e578 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011e564:	83 ec 04             	sub    $0x4,%esp
f011e567:	68 a0 10 13 f0       	push   $0xf01310a0
f011e56c:	6a 5e                	push   $0x5e
f011e56e:	68 5b 10 13 f0       	push   $0xf013105b
f011e573:	e8 c1 1d fe ff       	call   f0100339 <_panic>
}
f011e578:	c9                   	leave  
f011e579:	c3                   	ret    

f011e57a <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011e57a:	55                   	push   %ebp
f011e57b:	89 e5                	mov    %esp,%ebp
f011e57d:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e580:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e584:	77 07                	ja     f011e58d <nearest_pow2_ceil+0x13>
f011e586:	b8 01 00 00 00       	mov    $0x1,%eax
f011e58b:	eb 20                	jmp    f011e5ad <nearest_pow2_ceil+0x33>
	int power = 2;
f011e58d:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e594:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e597:	eb 08                	jmp    f011e5a1 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011e599:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e59c:	01 c0                	add    %eax,%eax
f011e59e:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011e5a1:	d1 6d 08             	shrl   0x8(%ebp)
f011e5a4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e5a8:	75 ef                	jne    f011e599 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011e5aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e5ad:	c9                   	leave  
f011e5ae:	c3                   	ret    

f011e5af <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011e5af:	55                   	push   %ebp
f011e5b0:	89 e5                	mov    %esp,%ebp
f011e5b2:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e5b5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e5b9:	77 07                	ja     f011e5c2 <log2_ceil+0x13>
f011e5bb:	b8 01 00 00 00       	mov    $0x1,%eax
f011e5c0:	eb 1b                	jmp    f011e5dd <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011e5c2:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e5c9:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e5cc:	eb 03                	jmp    f011e5d1 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011e5ce:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011e5d1:	d1 6d 08             	shrl   0x8(%ebp)
f011e5d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e5d8:	75 f4                	jne    f011e5ce <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011e5da:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e5dd:	c9                   	leave  
f011e5de:	c3                   	ret    

f011e5df <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011e5df:	55                   	push   %ebp
f011e5e0:	89 e5                	mov    %esp,%ebp
f011e5e2:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011e5e5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011e5ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e5f3:	eb 12                	jmp    f011e607 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011e5f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e5f8:	89 d0                	mov    %edx,%eax
f011e5fa:	c1 e0 02             	shl    $0x2,%eax
f011e5fd:	01 d0                	add    %edx,%eax
f011e5ff:	01 c0                	add    %eax,%eax
f011e601:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011e604:	ff 45 f0             	incl   -0x10(%ebp)
f011e607:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e60a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e60d:	7c e6                	jl     f011e5f5 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011e60f:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011e612:	83 ec 04             	sub    $0x4,%esp
f011e615:	ff 75 f4             	pushl  -0xc(%ebp)
f011e618:	ff 75 08             	pushl  0x8(%ebp)
f011e61b:	50                   	push   %eax
f011e61c:	e8 2f fd ff ff       	call   f011e350 <fix_scale>
f011e621:	83 c4 0c             	add    $0xc,%esp
f011e624:	83 ec 0c             	sub    $0xc,%esp
f011e627:	ff 75 dc             	pushl  -0x24(%ebp)
f011e62a:	e8 eb fc ff ff       	call   f011e31a <fix_round>
f011e62f:	83 c4 10             	add    $0x10,%esp
f011e632:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011e635:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e638:	99                   	cltd   
f011e639:	f7 7d f4             	idivl  -0xc(%ebp)
f011e63c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011e63f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e642:	99                   	cltd   
f011e643:	f7 7d f4             	idivl  -0xc(%ebp)
f011e646:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011e649:	83 ec 08             	sub    $0x8,%esp
f011e64c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e64f:	50                   	push   %eax
f011e650:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e653:	e8 6a 1e 00 00       	call   f01204c2 <ltostr>
f011e658:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011e65b:	83 ec 08             	sub    $0x8,%esp
f011e65e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e661:	50                   	push   %eax
f011e662:	ff 75 e0             	pushl  -0x20(%ebp)
f011e665:	e8 58 1e 00 00       	call   f01204c2 <ltostr>
f011e66a:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011e66d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011e670:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e675:	f7 e9                	imul   %ecx
f011e677:	c1 fa 02             	sar    $0x2,%edx
f011e67a:	89 c8                	mov    %ecx,%eax
f011e67c:	c1 f8 1f             	sar    $0x1f,%eax
f011e67f:	29 c2                	sub    %eax,%edx
f011e681:	89 d0                	mov    %edx,%eax
f011e683:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011e686:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011e68d:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011e694:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011e69a:	eb 31                	jmp    f011e6cd <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011e69c:	83 ec 04             	sub    $0x4,%esp
f011e69f:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e6a2:	50                   	push   %eax
f011e6a3:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e6a6:	50                   	push   %eax
f011e6a7:	68 bc 10 13 f0       	push   $0xf01310bc
f011e6ac:	e8 ea 1e 00 00       	call   f012059b <strcconcat>
f011e6b1:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011e6b4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011e6b7:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e6bc:	f7 e9                	imul   %ecx
f011e6be:	c1 fa 02             	sar    $0x2,%edx
f011e6c1:	89 c8                	mov    %ecx,%eax
f011e6c3:	c1 f8 1f             	sar    $0x1f,%eax
f011e6c6:	29 c2                	sub    %eax,%edx
f011e6c8:	89 d0                	mov    %edx,%eax
f011e6ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011e6cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e6d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e6d3:	7c c7                	jl     f011e69c <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011e6d5:	83 ec 04             	sub    $0x4,%esp
f011e6d8:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e6db:	50                   	push   %eax
f011e6dc:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e6df:	50                   	push   %eax
f011e6e0:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e6e3:	50                   	push   %eax
f011e6e4:	e8 b2 1e 00 00       	call   f012059b <strcconcat>
f011e6e9:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011e6ec:	83 ec 04             	sub    $0x4,%esp
f011e6ef:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e6f2:	50                   	push   %eax
f011e6f3:	68 be 10 13 f0       	push   $0xf01310be
f011e6f8:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e6fb:	50                   	push   %eax
f011e6fc:	e8 9a 1e 00 00       	call   f012059b <strcconcat>
f011e701:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011e704:	83 ec 04             	sub    $0x4,%esp
f011e707:	ff 75 10             	pushl  0x10(%ebp)
f011e70a:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e70d:	50                   	push   %eax
f011e70e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e711:	50                   	push   %eax
f011e712:	e8 84 1e 00 00       	call   f012059b <strcconcat>
f011e717:	83 c4 10             	add    $0x10,%esp

}
f011e71a:	90                   	nop
f011e71b:	c9                   	leave  
f011e71c:	c3                   	ret    

f011e71d <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011e71d:	55                   	push   %ebp
f011e71e:	89 e5                	mov    %esp,%ebp
f011e720:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011e726:	83 ec 0c             	sub    $0xc,%esp
f011e729:	68 c0 10 13 f0       	push   $0xf01310c0
f011e72e:	e8 e9 18 00 00       	call   f012001c <strlen>
f011e733:	83 c4 10             	add    $0x10,%esp
f011e736:	83 ec 04             	sub    $0x4,%esp
f011e739:	50                   	push   %eax
f011e73a:	68 c0 10 13 f0       	push   $0xf01310c0
f011e73f:	ff 75 08             	pushl  0x8(%ebp)
f011e742:	e8 19 1a 00 00       	call   f0120160 <strncmp>
f011e747:	83 c4 10             	add    $0x10,%esp
f011e74a:	85 c0                	test   %eax,%eax
f011e74c:	0f 85 8a 00 00 00    	jne    f011e7dc <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e752:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011e755:	50                   	push   %eax
f011e756:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e75c:	50                   	push   %eax
f011e75d:	68 ce 10 13 f0       	push   $0xf01310ce
f011e762:	ff 75 08             	pushl  0x8(%ebp)
f011e765:	e8 c7 1e 00 00       	call   f0120631 <strsplit>
f011e76a:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011e76d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e773:	83 ec 04             	sub    $0x4,%esp
f011e776:	6a 0a                	push   $0xa
f011e778:	6a 00                	push   $0x0
f011e77a:	50                   	push   %eax
f011e77b:	e8 fc 1b 00 00       	call   f012037c <strtol>
f011e780:	83 c4 10             	add    $0x10,%esp
f011e783:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011e786:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011e78d:	83 ec 04             	sub    $0x4,%esp
f011e790:	6a 00                	push   $0x0
f011e792:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e795:	50                   	push   %eax
f011e796:	ff 75 e0             	pushl  -0x20(%ebp)
f011e799:	e8 d7 d5 fe ff       	call   f010bd75 <envid2env>
f011e79e:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011e7a1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e7a4:	8b 40 10             	mov    0x10(%eax),%eax
f011e7a7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e7aa:	74 19                	je     f011e7c5 <sys_utilities+0xa8>
f011e7ac:	68 d0 10 13 f0       	push   $0xf01310d0
f011e7b1:	68 13 10 13 f0       	push   $0xf0131013
f011e7b6:	68 a4 00 00 00       	push   $0xa4
f011e7bb:	68 5b 10 13 f0       	push   $0xf013105b
f011e7c0:	e8 74 1b fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011e7c5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e7c8:	83 ec 08             	sub    $0x8,%esp
f011e7cb:	ff 75 0c             	pushl  0xc(%ebp)
f011e7ce:	50                   	push   %eax
f011e7cf:	e8 1d 81 fe ff       	call   f01068f1 <env_set_nice>
f011e7d4:	83 c4 10             	add    $0x10,%esp
f011e7d7:	e9 12 04 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011e7dc:	83 ec 0c             	sub    $0xc,%esp
f011e7df:	68 e5 10 13 f0       	push   $0xf01310e5
f011e7e4:	e8 33 18 00 00       	call   f012001c <strlen>
f011e7e9:	83 c4 10             	add    $0x10,%esp
f011e7ec:	83 ec 04             	sub    $0x4,%esp
f011e7ef:	50                   	push   %eax
f011e7f0:	68 e5 10 13 f0       	push   $0xf01310e5
f011e7f5:	ff 75 08             	pushl  0x8(%ebp)
f011e7f8:	e8 63 19 00 00       	call   f0120160 <strncmp>
f011e7fd:	83 c4 10             	add    $0x10,%esp
f011e800:	85 c0                	test   %eax,%eax
f011e802:	0f 85 a6 01 00 00    	jne    f011e9ae <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011e808:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e80b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e80e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e811:	50                   	push   %eax
f011e812:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e818:	50                   	push   %eax
f011e819:	68 ce 10 13 f0       	push   $0xf01310ce
f011e81e:	ff 75 08             	pushl  0x8(%ebp)
f011e821:	e8 0b 1e 00 00       	call   f0120631 <strsplit>
f011e826:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011e829:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e82f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011e832:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011e839:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011e840:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011e847:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e84a:	8b 00                	mov    (%eax),%eax
f011e84c:	85 c0                	test   %eax,%eax
f011e84e:	79 1c                	jns    f011e86c <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011e850:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011e857:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e85a:	8b 00                	mov    (%eax),%eax
f011e85c:	f7 d8                	neg    %eax
f011e85e:	89 c2                	mov    %eax,%edx
f011e860:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e863:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011e865:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011e86c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011e873:	83 ec 0c             	sub    $0xc,%esp
f011e876:	68 20 d2 75 f0       	push   $0xf075d220
f011e87b:	e8 ee 17 ff ff       	call   f011006e <acquire_spinlock>
f011e880:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e883:	a1 ac d2 75 f0       	mov    0xf075d2ac,%eax
f011e888:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e88b:	a1 a4 d2 75 f0       	mov    0xf075d2a4,%eax
f011e890:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e893:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e896:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e899:	eb 6c                	jmp    f011e907 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011e89b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e89e:	83 c0 20             	add    $0x20,%eax
f011e8a1:	83 ec 08             	sub    $0x8,%esp
f011e8a4:	ff 75 d8             	pushl  -0x28(%ebp)
f011e8a7:	50                   	push   %eax
f011e8a8:	e8 7b 18 00 00       	call   f0120128 <strcmp>
f011e8ad:	83 c4 10             	add    $0x10,%esp
f011e8b0:	85 c0                	test   %eax,%eax
f011e8b2:	75 46                	jne    f011e8fa <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011e8b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e8b7:	8b 00                	mov    (%eax),%eax
f011e8b9:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e8bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e8bf:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011e8c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e8c5:	74 14                	je     f011e8db <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011e8c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e8ca:	8b 40 10             	mov    0x10(%eax),%eax
f011e8cd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e8d0:	7d 1d                	jge    f011e8ef <sys_utilities+0x1d2>
					{
						success = 0;
f011e8d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e8d9:	eb 32                	jmp    f011e90d <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011e8db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e8de:	8b 40 10             	mov    0x10(%eax),%eax
f011e8e1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e8e4:	7e 09                	jle    f011e8ef <sys_utilities+0x1d2>
					{
						success = 0;
f011e8e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e8ed:	eb 1e                	jmp    f011e90d <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011e8ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e8f2:	8b 40 10             	mov    0x10(%eax),%eax
f011e8f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e8f8:	eb 01                	jmp    f011e8fb <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011e8fa:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e8fb:	ff 4d e4             	decl   -0x1c(%ebp)
f011e8fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e901:	8b 40 0c             	mov    0xc(%eax),%eax
f011e904:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e907:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e90b:	7f 8e                	jg     f011e89b <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e90d:	83 ec 0c             	sub    $0xc,%esp
f011e910:	68 20 d2 75 f0       	push   $0xf075d220
f011e915:	e8 db 17 ff ff       	call   f01100f5 <release_spinlock>
f011e91a:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011e91d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e920:	8b 00                	mov    (%eax),%eax
f011e922:	85 c0                	test   %eax,%eax
f011e924:	75 06                	jne    f011e92c <sys_utilities+0x20f>
f011e926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e92a:	75 41                	jne    f011e96d <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011e92c:	83 ec 0c             	sub    $0xc,%esp
f011e92f:	68 f8 10 13 f0       	push   $0xf01310f8
f011e934:	e8 52 26 fe ff       	call   f0100f8b <cprintf>
f011e939:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011e93c:	83 ec 08             	sub    $0x8,%esp
f011e93f:	ff 75 d8             	pushl  -0x28(%ebp)
f011e942:	68 28 11 13 f0       	push   $0xf0131128
f011e947:	e8 3f 26 fe ff       	call   f0100f8b <cprintf>
f011e94c:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011e94f:	83 ec 0c             	sub    $0xc,%esp
f011e952:	68 f8 10 13 f0       	push   $0xf01310f8
f011e957:	e8 2f 26 fe ff       	call   f0100f8b <cprintf>
f011e95c:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011e95f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e962:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011e968:	e9 81 02 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011e96d:	83 ec 0c             	sub    $0xc,%esp
f011e970:	68 48 11 13 f0       	push   $0xf0131148
f011e975:	e8 11 26 fe ff       	call   f0100f8b <cprintf>
f011e97a:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011e97d:	83 ec 08             	sub    $0x8,%esp
f011e980:	ff 75 d8             	pushl  -0x28(%ebp)
f011e983:	68 80 11 13 f0       	push   $0xf0131180
f011e988:	e8 fe 25 fe ff       	call   f0100f8b <cprintf>
f011e98d:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011e990:	83 ec 0c             	sub    $0xc,%esp
f011e993:	68 48 11 13 f0       	push   $0xf0131148
f011e998:	e8 ee 25 fe ff       	call   f0100f8b <cprintf>
f011e99d:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011e9a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e9a3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011e9a9:	e9 40 02 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011e9ae:	83 ec 08             	sub    $0x8,%esp
f011e9b1:	68 a3 11 13 f0       	push   $0xf01311a3
f011e9b6:	ff 75 08             	pushl  0x8(%ebp)
f011e9b9:	e8 6a 17 00 00       	call   f0120128 <strcmp>
f011e9be:	83 c4 10             	add    $0x10,%esp
f011e9c1:	85 c0                	test   %eax,%eax
f011e9c3:	75 77                	jne    f011ea3c <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011e9c5:	a1 40 0e 18 f0       	mov    0xf0180e40,%eax
f011e9ca:	85 c0                	test   %eax,%eax
f011e9cc:	74 34                	je     f011ea02 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011e9ce:	c7 05 40 0e 18 f0 00 	movl   $0x0,0xf0180e40
f011e9d5:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011e9d8:	83 ec 08             	sub    $0x8,%esp
f011e9db:	68 ad 11 13 f0       	push   $0xf01311ad
f011e9e0:	68 80 02 6f f2       	push   $0xf26f0280
f011e9e5:	e8 44 1a ff ff       	call   f011042e <init_channel>
f011e9ea:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011e9ed:	83 ec 08             	sub    $0x8,%esp
f011e9f0:	68 ba 11 13 f0       	push   $0xf01311ba
f011e9f5:	68 00 04 6f f2       	push   $0xf26f0400
f011e9fa:	e8 3e 16 ff ff       	call   f011003d <init_spinlock>
f011e9ff:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011ea02:	83 ec 0c             	sub    $0xc,%esp
f011ea05:	68 00 04 6f f2       	push   $0xf26f0400
f011ea0a:	e8 5f 16 ff ff       	call   f011006e <acquire_spinlock>
f011ea0f:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011ea12:	83 ec 08             	sub    $0x8,%esp
f011ea15:	68 00 04 6f f2       	push   $0xf26f0400
f011ea1a:	68 80 02 6f f2       	push   $0xf26f0280
f011ea1f:	e8 37 1a ff ff       	call   f011045b <sleep>
f011ea24:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011ea27:	83 ec 0c             	sub    $0xc,%esp
f011ea2a:	68 00 04 6f f2       	push   $0xf26f0400
f011ea2f:	e8 c1 16 ff ff       	call   f01100f5 <release_spinlock>
f011ea34:	83 c4 10             	add    $0x10,%esp
f011ea37:	e9 b2 01 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011ea3c:	83 ec 08             	sub    $0x8,%esp
f011ea3f:	68 cc 11 13 f0       	push   $0xf01311cc
f011ea44:	ff 75 08             	pushl  0x8(%ebp)
f011ea47:	e8 dc 16 00 00       	call   f0120128 <strcmp>
f011ea4c:	83 c4 10             	add    $0x10,%esp
f011ea4f:	85 c0                	test   %eax,%eax
f011ea51:	75 15                	jne    f011ea68 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011ea53:	83 ec 0c             	sub    $0xc,%esp
f011ea56:	68 80 02 6f f2       	push   $0xf26f0280
f011ea5b:	e8 68 1a ff ff       	call   f01104c8 <wakeup_one>
f011ea60:	83 c4 10             	add    $0x10,%esp
f011ea63:	e9 86 01 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011ea68:	83 ec 08             	sub    $0x8,%esp
f011ea6b:	68 da 11 13 f0       	push   $0xf01311da
f011ea70:	ff 75 08             	pushl  0x8(%ebp)
f011ea73:	e8 b0 16 00 00       	call   f0120128 <strcmp>
f011ea78:	83 c4 10             	add    $0x10,%esp
f011ea7b:	85 c0                	test   %eax,%eax
f011ea7d:	75 15                	jne    f011ea94 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011ea7f:	83 ec 0c             	sub    $0xc,%esp
f011ea82:	68 80 02 6f f2       	push   $0xf26f0280
f011ea87:	e8 c0 1a ff ff       	call   f011054c <wakeup_all>
f011ea8c:	83 c4 10             	add    $0x10,%esp
f011ea8f:	e9 5a 01 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011ea94:	83 ec 08             	sub    $0x8,%esp
f011ea97:	68 e8 11 13 f0       	push   $0xf01311e8
f011ea9c:	ff 75 08             	pushl  0x8(%ebp)
f011ea9f:	e8 84 16 00 00       	call   f0120128 <strcmp>
f011eaa4:	83 c4 10             	add    $0x10,%esp
f011eaa7:	85 c0                	test   %eax,%eax
f011eaa9:	75 17                	jne    f011eac2 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011eaab:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eaae:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011eab1:	a1 8c 02 6f f2       	mov    0xf26f028c,%eax
f011eab6:	89 c2                	mov    %eax,%edx
f011eab8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eabb:	89 10                	mov    %edx,(%eax)
f011eabd:	e9 2c 01 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011eac2:	83 ec 08             	sub    $0x8,%esp
f011eac5:	68 fd 11 13 f0       	push   $0xf01311fd
f011eaca:	ff 75 08             	pushl  0x8(%ebp)
f011eacd:	e8 56 16 00 00       	call   f0120128 <strcmp>
f011ead2:	83 c4 10             	add    $0x10,%esp
f011ead5:	85 c0                	test   %eax,%eax
f011ead7:	75 1a                	jne    f011eaf3 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011ead9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eadc:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011eadf:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011eae4:	8b 40 0c             	mov    0xc(%eax),%eax
f011eae7:	89 c2                	mov    %eax,%edx
f011eae9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011eaec:	89 10                	mov    %edx,(%eax)
f011eaee:	e9 fb 00 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011eaf3:	83 ec 08             	sub    $0x8,%esp
f011eaf6:	68 13 12 13 f0       	push   $0xf0131213
f011eafb:	ff 75 08             	pushl  0x8(%ebp)
f011eafe:	e8 25 16 00 00       	call   f0120128 <strcmp>
f011eb03:	83 c4 10             	add    $0x10,%esp
f011eb06:	85 c0                	test   %eax,%eax
f011eb08:	75 3d                	jne    f011eb47 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011eb0a:	a1 44 0e 18 f0       	mov    0xf0180e44,%eax
f011eb0f:	85 c0                	test   %eax,%eax
f011eb11:	74 1f                	je     f011eb32 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011eb13:	c7 05 44 0e 18 f0 00 	movl   $0x0,0xf0180e44
f011eb1a:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011eb1d:	83 ec 08             	sub    $0x8,%esp
f011eb20:	68 28 12 13 f0       	push   $0xf0131228
f011eb25:	68 e0 02 6f f2       	push   $0xf26f02e0
f011eb2a:	e8 99 17 ff ff       	call   f01102c8 <init_sleeplock>
f011eb2f:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011eb32:	83 ec 0c             	sub    $0xc,%esp
f011eb35:	68 e0 02 6f f2       	push   $0xf26f02e0
f011eb3a:	e8 4d 18 ff ff       	call   f011038c <acquire_sleeplock>
f011eb3f:	83 c4 10             	add    $0x10,%esp
f011eb42:	e9 a7 00 00 00       	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011eb47:	83 ec 08             	sub    $0x8,%esp
f011eb4a:	68 38 12 13 f0       	push   $0xf0131238
f011eb4f:	ff 75 08             	pushl  0x8(%ebp)
f011eb52:	e8 d1 15 00 00       	call   f0120128 <strcmp>
f011eb57:	83 c4 10             	add    $0x10,%esp
f011eb5a:	85 c0                	test   %eax,%eax
f011eb5c:	75 12                	jne    f011eb70 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011eb5e:	83 ec 0c             	sub    $0xc,%esp
f011eb61:	68 e0 02 6f f2       	push   $0xf26f02e0
f011eb66:	e8 7b 18 ff ff       	call   f01103e6 <release_sleeplock>
f011eb6b:	83 c4 10             	add    $0x10,%esp
f011eb6e:	eb 7e                	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011eb70:	83 ec 08             	sub    $0x8,%esp
f011eb73:	68 4d 12 13 f0       	push   $0xf013124d
f011eb78:	ff 75 08             	pushl  0x8(%ebp)
f011eb7b:	e8 a8 15 00 00       	call   f0120128 <strcmp>
f011eb80:	83 c4 10             	add    $0x10,%esp
f011eb83:	85 c0                	test   %eax,%eax
f011eb85:	75 14                	jne    f011eb9b <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011eb87:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eb8a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011eb8d:	a1 60 03 6f f2       	mov    0xf26f0360,%eax
f011eb92:	89 c2                	mov    %eax,%edx
f011eb94:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011eb97:	89 10                	mov    %edx,(%eax)
f011eb99:	eb 53                	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011eb9b:	83 ec 08             	sub    $0x8,%esp
f011eb9e:	68 62 12 13 f0       	push   $0xf0131262
f011eba3:	ff 75 08             	pushl  0x8(%ebp)
f011eba6:	e8 7d 15 00 00       	call   f0120128 <strcmp>
f011ebab:	83 c4 10             	add    $0x10,%esp
f011ebae:	85 c0                	test   %eax,%eax
f011ebb0:	75 13                	jne    f011ebc5 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011ebb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ebb5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011ebb8:	8b 15 e0 02 6f f2    	mov    0xf26f02e0,%edx
f011ebbe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ebc1:	89 10                	mov    %edx,(%eax)
f011ebc3:	eb 29                	jmp    f011ebee <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011ebc5:	83 ec 08             	sub    $0x8,%esp
f011ebc8:	68 73 12 13 f0       	push   $0xf0131273
f011ebcd:	ff 75 08             	pushl  0x8(%ebp)
f011ebd0:	e8 53 15 00 00       	call   f0120128 <strcmp>
f011ebd5:	83 c4 10             	add    $0x10,%esp
f011ebd8:	85 c0                	test   %eax,%eax
f011ebda:	75 12                	jne    f011ebee <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011ebdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ebdf:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011ebe2:	a1 e4 03 6f f2       	mov    0xf26f03e4,%eax
f011ebe7:	89 c2                	mov    %eax,%edx
f011ebe9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ebec:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011ebee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ebf2:	79 5b                	jns    f011ec4f <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011ebf4:	83 ec 08             	sub    $0x8,%esp
f011ebf7:	68 84 12 13 f0       	push   $0xf0131284
f011ebfc:	ff 75 08             	pushl  0x8(%ebp)
f011ebff:	e8 24 15 00 00       	call   f0120128 <strcmp>
f011ec04:	83 c4 10             	add    $0x10,%esp
f011ec07:	85 c0                	test   %eax,%eax
f011ec09:	75 44                	jne    f011ec4f <sys_utilities+0x532>
		{
			switch (value)
f011ec0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec0e:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011ec11:	74 07                	je     f011ec1a <sys_utilities+0x4fd>
f011ec13:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011ec16:	74 19                	je     f011ec31 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011ec18:	eb 35                	jmp    f011ec4f <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011ec1a:	83 ec 0c             	sub    $0xc,%esp
f011ec1d:	68 94 12 13 f0       	push   $0xf0131294
f011ec22:	e8 64 23 fe ff       	call   f0100f8b <cprintf>
f011ec27:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011ec2a:	e8 bc 0d ff ff       	call   f010f9eb <setPageReplacmentAlgorithmFIFO>
				break;
f011ec2f:	eb 1e                	jmp    f011ec4f <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011ec31:	83 ec 0c             	sub    $0xc,%esp
f011ec34:	68 04 13 13 f0       	push   $0xf0131304
f011ec39:	e8 4d 23 fe ff       	call   f0100f8b <cprintf>
f011ec3e:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011ec41:	83 ec 0c             	sub    $0xc,%esp
f011ec44:	6a 02                	push   $0x2
f011ec46:	e8 5d 0d ff ff       	call   f010f9a8 <setPageReplacmentAlgorithmLRU>
f011ec4b:	83 c4 10             	add    $0x10,%esp
				break;
f011ec4e:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011ec4f:	90                   	nop
f011ec50:	c9                   	leave  
f011ec51:	c3                   	ret    

f011ec52 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011ec52:	55                   	push   %ebp
f011ec53:	89 e5                	mov    %esp,%ebp
f011ec55:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011ec58:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec5b:	8b 00                	mov    (%eax),%eax
f011ec5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011ec60:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec63:	8b 00                	mov    (%eax),%eax
f011ec65:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011ec68:	eb 52                	jmp    f011ecbc <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011ec6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec6d:	8b 00                	mov    (%eax),%eax
f011ec6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011ec72:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec75:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ec78:	75 12                	jne    f011ec8c <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011ec7a:	83 ec 0c             	sub    $0xc,%esp
f011ec7d:	68 78 13 13 f0       	push   $0xf0131378
f011ec82:	e8 04 23 fe ff       	call   f0100f8b <cprintf>
f011ec87:	83 c4 10             	add    $0x10,%esp
			break;
f011ec8a:	eb 3f                	jmp    f011eccb <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011ec8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ec90:	74 38                	je     f011ecca <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011ec92:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec95:	8b 00                	mov    (%eax),%eax
f011ec97:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011ec9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ec9d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011eca0:	75 12                	jne    f011ecb4 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011eca2:	83 ec 0c             	sub    $0xc,%esp
f011eca5:	68 94 13 13 f0       	push   $0xf0131394
f011ecaa:	e8 dc 22 fe ff       	call   f0100f8b <cprintf>
f011ecaf:	83 c4 10             	add    $0x10,%esp
			break;
f011ecb2:	eb 17                	jmp    f011eccb <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011ecb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ecb7:	8b 00                	mov    (%eax),%eax
f011ecb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011ecbc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ecc0:	74 09                	je     f011eccb <detect_loop_in_FrameInfo_list+0x79>
f011ecc2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ecc6:	75 a2                	jne    f011ec6a <detect_loop_in_FrameInfo_list+0x18>
f011ecc8:	eb 01                	jmp    f011eccb <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011ecca:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011eccb:	83 ec 0c             	sub    $0xc,%esp
f011ecce:	68 ab 13 13 f0       	push   $0xf01313ab
f011ecd3:	e8 b3 22 fe ff       	call   f0100f8b <cprintf>
f011ecd8:	83 c4 10             	add    $0x10,%esp
}
f011ecdb:	90                   	nop
f011ecdc:	c9                   	leave  
f011ecdd:	c3                   	ret    

f011ecde <scarce_memory>:

void scarce_memory()
{
f011ecde:	55                   	push   %ebp
f011ecdf:	89 e5                	mov    %esp,%ebp
f011ece1:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011ece4:	a1 f0 d3 b5 f0       	mov    0xf0b5d3f0,%eax
f011ece9:	ba 64 00 00 00       	mov    $0x64,%edx
f011ecee:	29 c2                	sub    %eax,%edx
f011ecf0:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f011ecf5:	0f af c2             	imul   %edx,%eax
f011ecf8:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ecfd:	f7 e2                	mul    %edx
f011ecff:	89 d0                	mov    %edx,%eax
f011ed01:	c1 e8 05             	shr    $0x5,%eax
f011ed04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011ed07:	a1 f0 d3 b5 f0       	mov    0xf0b5d3f0,%eax
f011ed0c:	ba 64 00 00 00       	mov    $0x64,%edx
f011ed11:	29 c2                	sub    %eax,%edx
f011ed13:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f011ed18:	89 d1                	mov    %edx,%ecx
f011ed1a:	0f af c8             	imul   %eax,%ecx
f011ed1d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ed22:	f7 e1                	mul    %ecx
f011ed24:	c1 ea 05             	shr    $0x5,%edx
f011ed27:	89 d0                	mov    %edx,%eax
f011ed29:	c1 e0 02             	shl    $0x2,%eax
f011ed2c:	01 d0                	add    %edx,%eax
f011ed2e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ed35:	01 d0                	add    %edx,%eax
f011ed37:	c1 e0 02             	shl    $0x2,%eax
f011ed3a:	29 c1                	sub    %eax,%ecx
f011ed3c:	89 ca                	mov    %ecx,%edx
f011ed3e:	85 d2                	test   %edx,%edx
f011ed40:	74 03                	je     f011ed45 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011ed42:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011ed45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011ed4c:	83 ec 0c             	sub    $0xc,%esp
f011ed4f:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f011ed54:	e8 15 13 ff ff       	call   f011006e <acquire_spinlock>
f011ed59:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011ed5c:	a1 cc d2 b5 f0       	mov    0xf0b5d2cc,%eax
f011ed61:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011ed64:	8b 15 b8 d4 b5 f0    	mov    0xf0b5d4b8,%edx
f011ed6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ed6d:	29 c2                	sub    %eax,%edx
f011ed6f:	89 d0                	mov    %edx,%eax
f011ed71:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011ed74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ed77:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011ed7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011ed7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ed84:	eb 12                	jmp    f011ed98 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011ed86:	83 ec 0c             	sub    $0xc,%esp
f011ed89:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011ed8c:	50                   	push   %eax
f011ed8d:	e8 4b 97 fe ff       	call   f01084dd <allocate_frame>
f011ed92:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ed95:	ff 45 f0             	incl   -0x10(%ebp)
f011ed98:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed9b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011ed9e:	76 e6                	jbe    f011ed86 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011eda0:	83 ec 0c             	sub    $0xc,%esp
f011eda3:	68 e0 d2 b5 f0       	push   $0xf0b5d2e0
f011eda8:	e8 48 13 ff ff       	call   f01100f5 <release_spinlock>
f011edad:	83 c4 10             	add    $0x10,%esp

}
f011edb0:	90                   	nop
f011edb1:	c9                   	leave  
f011edb2:	c3                   	ret    

f011edb3 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011edb3:	55                   	push   %ebp
f011edb4:	89 e5                	mov    %esp,%ebp
f011edb6:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011edb9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011edc0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011edc7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011edce:	e8 52 cf fe ff       	call   f010bd25 <get_cpu_proc>
f011edd3:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011edd6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011edda:	75 19                	jne    f011edf5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011eddc:	68 c5 13 13 f0       	push   $0xf01313c5
f011ede1:	68 13 10 13 f0       	push   $0xf0131013
f011ede6:	68 79 01 00 00       	push   $0x179
f011edeb:	68 5b 10 13 f0       	push   $0xf013105b
f011edf0:	e8 44 15 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011edf5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011edf9:	0f 85 d6 01 00 00    	jne    f011efd5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011edff:	83 ec 0c             	sub    $0xc,%esp
f011ee02:	68 20 d2 75 f0       	push   $0xf075d220
f011ee07:	e8 62 12 ff ff       	call   f011006e <acquire_spinlock>
f011ee0c:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011ee0f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011ee16:	e9 d2 00 00 00       	jmp    f011eeed <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011ee1b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ee22:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011ee27:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ee2a:	c1 e2 04             	shl    $0x4,%edx
f011ee2d:	01 d0                	add    %edx,%eax
f011ee2f:	8b 00                	mov    (%eax),%eax
f011ee31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ee34:	eb 7c                	jmp    f011eeb2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011ee36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ee39:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ee3f:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ee42:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee45:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ee4b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ee4e:	0f af c2             	imul   %edx,%eax
f011ee51:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ee56:	f7 e2                	mul    %edx
f011ee58:	89 d0                	mov    %edx,%eax
f011ee5a:	c1 e8 05             	shr    $0x5,%eax
f011ee5d:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ee60:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ee63:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ee69:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ee6c:	89 d1                	mov    %edx,%ecx
f011ee6e:	0f af c8             	imul   %eax,%ecx
f011ee71:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ee76:	f7 e1                	mul    %ecx
f011ee78:	c1 ea 05             	shr    $0x5,%edx
f011ee7b:	89 d0                	mov    %edx,%eax
f011ee7d:	c1 e0 02             	shl    $0x2,%eax
f011ee80:	01 d0                	add    %edx,%eax
f011ee82:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ee89:	01 d0                	add    %edx,%eax
f011ee8b:	c1 e0 02             	shl    $0x2,%eax
f011ee8e:	29 c1                	sub    %eax,%ecx
f011ee90:	89 ca                	mov    %ecx,%edx
f011ee92:	85 d2                	test   %edx,%edx
f011ee94:	74 03                	je     f011ee99 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011ee96:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011ee99:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ee9c:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011ee9f:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011eea4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eea7:	c1 e2 04             	shl    $0x4,%edx
f011eeaa:	01 d0                	add    %edx,%eax
f011eeac:	8b 40 08             	mov    0x8(%eax),%eax
f011eeaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011eeb2:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011eeb7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eeba:	c1 e2 04             	shl    $0x4,%edx
f011eebd:	01 d0                	add    %edx,%eax
f011eebf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eec3:	74 08                	je     f011eecd <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011eec5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011eec8:	8b 52 08             	mov    0x8(%edx),%edx
f011eecb:	eb 05                	jmp    f011eed2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011eecd:	ba 00 00 00 00       	mov    $0x0,%edx
f011eed2:	89 50 08             	mov    %edx,0x8(%eax)
f011eed5:	8b 40 08             	mov    0x8(%eax),%eax
f011eed8:	85 c0                	test   %eax,%eax
f011eeda:	0f 85 56 ff ff ff    	jne    f011ee36 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011eee0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eee4:	0f 85 4c ff ff ff    	jne    f011ee36 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011eeea:	ff 45 e8             	incl   -0x18(%ebp)
f011eeed:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011eef2:	0f b6 c0             	movzbl %al,%eax
f011eef5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011eef8:	0f 8f 1d ff ff ff    	jg     f011ee1b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011eefe:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011ef05:	a1 a0 d2 75 f0       	mov    0xf075d2a0,%eax
f011ef0a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ef0d:	eb 1a                	jmp    f011ef29 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011ef0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ef12:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ef18:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011ef1b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ef1e:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011ef21:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f011ef26:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ef29:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ef2d:	74 08                	je     f011ef37 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011ef2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ef32:	8b 40 08             	mov    0x8(%eax),%eax
f011ef35:	eb 05                	jmp    f011ef3c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011ef37:	b8 00 00 00 00       	mov    $0x0,%eax
f011ef3c:	a3 a8 d2 75 f0       	mov    %eax,0xf075d2a8
f011ef41:	a1 a8 d2 75 f0       	mov    0xf075d2a8,%eax
f011ef46:	85 c0                	test   %eax,%eax
f011ef48:	75 c5                	jne    f011ef0f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011ef4a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ef4e:	75 bf                	jne    f011ef0f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011ef50:	83 ec 0c             	sub    $0xc,%esp
f011ef53:	68 20 d2 75 f0       	push   $0xf075d220
f011ef58:	e8 98 11 ff ff       	call   f01100f5 <release_spinlock>
f011ef5d:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011ef60:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011ef64:	0f 84 d4 00 00 00    	je     f011f03e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ef6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef6d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ef73:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ef76:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef79:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ef7f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ef82:	0f af c2             	imul   %edx,%eax
f011ef85:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ef8a:	f7 e2                	mul    %edx
f011ef8c:	89 d0                	mov    %edx,%eax
f011ef8e:	c1 e8 05             	shr    $0x5,%eax
f011ef91:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ef94:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ef97:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ef9d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011efa0:	89 d1                	mov    %edx,%ecx
f011efa2:	0f af c8             	imul   %eax,%ecx
f011efa5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011efaa:	f7 e1                	mul    %ecx
f011efac:	c1 ea 05             	shr    $0x5,%edx
f011efaf:	89 d0                	mov    %edx,%eax
f011efb1:	c1 e0 02             	shl    $0x2,%eax
f011efb4:	01 d0                	add    %edx,%eax
f011efb6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011efbd:	01 d0                	add    %edx,%eax
f011efbf:	c1 e0 02             	shl    $0x2,%eax
f011efc2:	29 c1                	sub    %eax,%ecx
f011efc4:	89 ca                	mov    %ecx,%edx
f011efc6:	85 d2                	test   %edx,%edx
f011efc8:	74 03                	je     f011efcd <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011efca:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011efcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011efd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011efd3:	eb 69                	jmp    f011f03e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011efd5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011efd8:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011efde:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011efe1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011efe4:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011efea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011efed:	0f af c2             	imul   %edx,%eax
f011eff0:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eff5:	f7 e2                	mul    %edx
f011eff7:	89 d0                	mov    %edx,%eax
f011eff9:	c1 e8 05             	shr    $0x5,%eax
f011effc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011efff:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f002:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011f008:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f00b:	89 d1                	mov    %edx,%ecx
f011f00d:	0f af c8             	imul   %eax,%ecx
f011f010:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f015:	f7 e1                	mul    %ecx
f011f017:	c1 ea 05             	shr    $0x5,%edx
f011f01a:	89 d0                	mov    %edx,%eax
f011f01c:	c1 e0 02             	shl    $0x2,%eax
f011f01f:	01 d0                	add    %edx,%eax
f011f021:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f028:	01 d0                	add    %edx,%eax
f011f02a:	c1 e0 02             	shl    $0x2,%eax
f011f02d:	29 c1                	sub    %eax,%ecx
f011f02f:	89 ca                	mov    %ecx,%edx
f011f031:	85 d2                	test   %edx,%edx
f011f033:	74 03                	je     f011f038 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011f035:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011f038:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011f03b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011f03e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f041:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f044:	01 c2                	add    %eax,%edx
f011f046:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f049:	01 d0                	add    %edx,%eax
}
f011f04b:	c9                   	leave  
f011f04c:	c3                   	ret    

f011f04d <schenv>:


void schenv()
{
f011f04d:	55                   	push   %ebp
f011f04e:	89 e5                	mov    %esp,%ebp
f011f050:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011f053:	c6 05 80 da f5 f0 00 	movb   $0x0,0xf0f5da80
	__ne = NULL;
f011f05a:	c7 05 0c d7 b5 f0 00 	movl   $0x0,0xf0b5d70c
f011f061:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011f064:	83 ec 0c             	sub    $0xc,%esp
f011f067:	68 20 d2 75 f0       	push   $0xf075d220
f011f06c:	e8 fd 0f ff ff       	call   f011006e <acquire_spinlock>
f011f071:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011f074:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f07b:	eb 3f                	jmp    f011f0bc <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011f07d:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011f082:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f085:	c1 e2 04             	shl    $0x4,%edx
f011f088:	01 d0                	add    %edx,%eax
f011f08a:	83 ec 0c             	sub    $0xc,%esp
f011f08d:	50                   	push   %eax
f011f08e:	e8 ed 60 fe ff       	call   f0105180 <queue_size>
f011f093:	83 c4 10             	add    $0x10,%esp
f011f096:	85 c0                	test   %eax,%eax
f011f098:	74 1f                	je     f011f0b9 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011f09a:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011f09f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f0a2:	c1 e2 04             	shl    $0x4,%edx
f011f0a5:	01 d0                	add    %edx,%eax
f011f0a7:	8b 40 04             	mov    0x4(%eax),%eax
f011f0aa:	a3 0c d7 b5 f0       	mov    %eax,0xf0b5d70c
				__nl = i;
f011f0af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f0b2:	a2 80 da f5 f0       	mov    %al,0xf0f5da80
				break;
f011f0b7:	eb 10                	jmp    f011f0c9 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011f0b9:	ff 45 f4             	incl   -0xc(%ebp)
f011f0bc:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011f0c1:	0f b6 c0             	movzbl %al,%eax
f011f0c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f0c7:	7f b4                	jg     f011f07d <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011f0c9:	83 ec 0c             	sub    $0xc,%esp
f011f0cc:	68 20 d2 75 f0       	push   $0xf075d220
f011f0d1:	e8 1f 10 ff ff       	call   f01100f5 <release_spinlock>
f011f0d6:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011f0d9:	e8 47 cc fe ff       	call   f010bd25 <get_cpu_proc>
f011f0de:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011f0e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f0e5:	0f 84 82 00 00 00    	je     f011f16d <schenv+0x120>
	{
		if (__ne != NULL)
f011f0eb:	a1 0c d7 b5 f0       	mov    0xf0b5d70c,%eax
f011f0f0:	85 c0                	test   %eax,%eax
f011f0f2:	74 49                	je     f011f13d <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011f0f4:	a0 01 d2 75 f0       	mov    0xf075d201,%al
f011f0f9:	0f b6 c0             	movzbl %al,%eax
f011f0fc:	8d 50 01             	lea    0x1(%eax),%edx
f011f0ff:	a0 80 da f5 f0       	mov    0xf0f5da80,%al
f011f104:	0f b6 c0             	movzbl %al,%eax
f011f107:	39 c2                	cmp    %eax,%edx
f011f109:	7d 62                	jge    f011f16d <schenv+0x120>
			{
				__ne = cur_env;
f011f10b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f10e:	a3 0c d7 b5 f0       	mov    %eax,0xf0b5d70c
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f113:	a0 01 d2 75 f0       	mov    0xf075d201,%al
f011f118:	0f b6 c0             	movzbl %al,%eax
f011f11b:	8a 15 e4 d9 f5 f0    	mov    0xf0f5d9e4,%dl
f011f121:	0f b6 d2             	movzbl %dl,%edx
f011f124:	4a                   	dec    %edx
f011f125:	39 d0                	cmp    %edx,%eax
f011f127:	7d 08                	jge    f011f131 <schenv+0xe4>
f011f129:	a0 01 d2 75 f0       	mov    0xf075d201,%al
f011f12e:	40                   	inc    %eax
f011f12f:	eb 05                	jmp    f011f136 <schenv+0xe9>
f011f131:	a0 01 d2 75 f0       	mov    0xf075d201,%al
f011f136:	a2 80 da f5 f0       	mov    %al,0xf0f5da80
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011f13b:	eb 30                	jmp    f011f16d <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011f13d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f140:	a3 0c d7 b5 f0       	mov    %eax,0xf0b5d70c
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f145:	a0 01 d2 75 f0       	mov    0xf075d201,%al
f011f14a:	0f b6 c0             	movzbl %al,%eax
f011f14d:	8a 15 e4 d9 f5 f0    	mov    0xf0f5d9e4,%dl
f011f153:	0f b6 d2             	movzbl %dl,%edx
f011f156:	4a                   	dec    %edx
f011f157:	39 d0                	cmp    %edx,%eax
f011f159:	7d 08                	jge    f011f163 <schenv+0x116>
f011f15b:	a0 01 d2 75 f0       	mov    0xf075d201,%al
f011f160:	40                   	inc    %eax
f011f161:	eb 05                	jmp    f011f168 <schenv+0x11b>
f011f163:	a0 01 d2 75 f0       	mov    0xf075d201,%al
f011f168:	a2 80 da f5 f0       	mov    %al,0xf0f5da80
		}
	}
}
f011f16d:	90                   	nop
f011f16e:	c9                   	leave  
f011f16f:	c3                   	ret    

f011f170 <chksch>:

void chksch(uint8 onoff)
{
f011f170:	55                   	push   %ebp
f011f171:	89 e5                	mov    %esp,%ebp
f011f173:	83 ec 18             	sub    $0x18,%esp
f011f176:	8b 45 08             	mov    0x8(%ebp),%eax
f011f179:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f17c:	e8 3a 78 fe ff       	call   f01069bb <isSchedMethodBSD>
f011f181:	85 c0                	test   %eax,%eax
f011f183:	74 48                	je     f011f1cd <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011f185:	e8 a1 77 fe ff       	call   f010692b <get_load_average>
f011f18a:	a3 08 da f5 f0       	mov    %eax,0xf0f5da08
f011f18f:	a1 08 da f5 f0       	mov    0xf0f5da08,%eax
f011f194:	a3 bc d4 b5 f0       	mov    %eax,0xf0b5d4bc
		acquire_spinlock(&ProcessQueues.qlock);
f011f199:	83 ec 0c             	sub    $0xc,%esp
f011f19c:	68 20 d2 75 f0       	push   $0xf075d220
f011f1a1:	e8 c8 0e ff ff       	call   f011006e <acquire_spinlock>
f011f1a6:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011f1a9:	a1 ac d2 75 f0       	mov    0xf075d2ac,%eax
f011f1ae:	a3 60 d3 b5 f0       	mov    %eax,0xf0b5d360
		}
		release_spinlock(&ProcessQueues.qlock);
f011f1b3:	83 ec 0c             	sub    $0xc,%esp
f011f1b6:	68 20 d2 75 f0       	push   $0xf075d220
f011f1bb:	e8 35 0f ff ff       	call   f01100f5 <release_spinlock>
f011f1c0:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011f1c3:	c7 05 1c d7 b5 f0 01 	movl   $0x1,0xf0b5d71c
f011f1ca:	00 00 00 
	}
	__chkstatus = onoff;
f011f1cd:	8a 45 f4             	mov    -0xc(%ebp),%al
f011f1d0:	a2 08 d7 b5 f0       	mov    %al,0xf0b5d708
}
f011f1d5:	90                   	nop
f011f1d6:	c9                   	leave  
f011f1d7:	c3                   	ret    

f011f1d8 <chk1>:
void chk1()
{
f011f1d8:	55                   	push   %ebp
f011f1d9:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011f1db:	90                   	nop
f011f1dc:	5d                   	pop    %ebp
f011f1dd:	c3                   	ret    

f011f1de <chk2>:
void chk2(struct Env* __se)
{
f011f1de:	55                   	push   %ebp
f011f1df:	89 e5                	mov    %esp,%ebp
f011f1e1:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011f1e4:	a0 08 d7 b5 f0       	mov    0xf0b5d708,%al
f011f1e9:	84 c0                	test   %al,%al
f011f1eb:	0f 84 59 03 00 00    	je     f011f54a <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f1f1:	e8 c5 77 fe ff       	call   f01069bb <isSchedMethodBSD>
f011f1f6:	85 c0                	test   %eax,%eax
f011f1f8:	0f 84 4d 03 00 00    	je     f011f54b <chk2+0x36d>
	{
		__nla = get_load_average();
f011f1fe:	e8 28 77 fe ff       	call   f010692b <get_load_average>
f011f203:	a3 f4 d3 b5 f0       	mov    %eax,0xf0b5d3f4
		acquire_spinlock(&ProcessQueues.qlock);
f011f208:	83 ec 0c             	sub    $0xc,%esp
f011f20b:	68 20 d2 75 f0       	push   $0xf075d220
f011f210:	e8 59 0e ff ff       	call   f011006e <acquire_spinlock>
f011f215:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011f218:	a1 ac d2 75 f0       	mov    0xf075d2ac,%eax
f011f21d:	a3 10 d7 b5 f0       	mov    %eax,0xf0b5d710
		}
		release_spinlock(&ProcessQueues.qlock);
f011f222:	83 ec 0c             	sub    $0xc,%esp
f011f225:	68 20 d2 75 f0       	push   $0xf075d220
f011f22a:	e8 c6 0e ff ff       	call   f01100f5 <release_spinlock>
f011f22f:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011f232:	a1 1c d7 b5 f0       	mov    0xf0b5d71c,%eax
f011f237:	85 c0                	test   %eax,%eax
f011f239:	74 72                	je     f011f2ad <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011f23b:	83 ec 0c             	sub    $0xc,%esp
f011f23e:	68 20 d2 75 f0       	push   $0xf075d220
f011f243:	e8 26 0e ff ff       	call   f011006e <acquire_spinlock>
f011f248:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011f24b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f24f:	0f 95 c0             	setne  %al
f011f252:	0f b6 c0             	movzbl %al,%eax
f011f255:	a3 d4 d8 b5 f0       	mov    %eax,0xf0b5d8d4
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f25a:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011f25f:	0f b6 c0             	movzbl %al,%eax
f011f262:	48                   	dec    %eax
f011f263:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f266:	eb 20                	jmp    f011f288 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f268:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011f26d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f270:	c1 e2 04             	shl    $0x4,%edx
f011f273:	01 d0                	add    %edx,%eax
f011f275:	8b 40 0c             	mov    0xc(%eax),%eax
f011f278:	8b 15 d4 d8 b5 f0    	mov    0xf0b5d8d4,%edx
f011f27e:	01 d0                	add    %edx,%eax
f011f280:	a3 d4 d8 b5 f0       	mov    %eax,0xf0b5d8d4
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f285:	ff 4d f4             	decl   -0xc(%ebp)
f011f288:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f28c:	79 da                	jns    f011f268 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011f28e:	c7 05 1c d7 b5 f0 00 	movl   $0x0,0xf0b5d71c
f011f295:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011f298:	83 ec 0c             	sub    $0xc,%esp
f011f29b:	68 20 d2 75 f0       	push   $0xf075d220
f011f2a0:	e8 50 0e ff ff       	call   f01100f5 <release_spinlock>
f011f2a5:	83 c4 10             	add    $0x10,%esp
f011f2a8:	e9 91 02 00 00       	jmp    f011f53e <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011f2ad:	8b 15 60 d3 b5 f0    	mov    0xf0b5d360,%edx
f011f2b3:	a1 10 d7 b5 f0       	mov    0xf0b5d710,%eax
f011f2b8:	39 c2                	cmp    %eax,%edx
f011f2ba:	74 63                	je     f011f31f <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011f2bc:	83 ec 0c             	sub    $0xc,%esp
f011f2bf:	68 20 d2 75 f0       	push   $0xf075d220
f011f2c4:	e8 a5 0d ff ff       	call   f011006e <acquire_spinlock>
f011f2c9:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011f2cc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f2d0:	0f 95 c0             	setne  %al
f011f2d3:	0f b6 c0             	movzbl %al,%eax
f011f2d6:	a3 d4 d8 b5 f0       	mov    %eax,0xf0b5d8d4
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f2db:	a0 e4 d9 f5 f0       	mov    0xf0f5d9e4,%al
f011f2e0:	0f b6 c0             	movzbl %al,%eax
f011f2e3:	48                   	dec    %eax
f011f2e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f2e7:	eb 20                	jmp    f011f309 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f2e9:	a1 b0 d2 75 f0       	mov    0xf075d2b0,%eax
f011f2ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f2f1:	c1 e2 04             	shl    $0x4,%edx
f011f2f4:	01 d0                	add    %edx,%eax
f011f2f6:	8b 40 0c             	mov    0xc(%eax),%eax
f011f2f9:	8b 15 d4 d8 b5 f0    	mov    0xf0b5d8d4,%edx
f011f2ff:	01 d0                	add    %edx,%eax
f011f301:	a3 d4 d8 b5 f0       	mov    %eax,0xf0b5d8d4
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f306:	ff 4d f0             	decl   -0x10(%ebp)
f011f309:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f30d:	79 da                	jns    f011f2e9 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011f30f:	83 ec 0c             	sub    $0xc,%esp
f011f312:	68 20 d2 75 f0       	push   $0xf075d220
f011f317:	e8 d9 0d ff ff       	call   f01100f5 <release_spinlock>
f011f31c:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011f31f:	e8 a0 75 fe ff       	call   f01068c4 <timer_ticks>
f011f324:	6a 00                	push   $0x0
f011f326:	68 e8 03 00 00       	push   $0x3e8
f011f32b:	52                   	push   %edx
f011f32c:	50                   	push   %eax
f011f32d:	e8 be 31 00 00       	call   f01224f0 <__moddi3>
f011f332:	83 c4 10             	add    $0x10,%esp
f011f335:	09 d0                	or     %edx,%eax
f011f337:	85 c0                	test   %eax,%eax
f011f339:	75 32                	jne    f011f36d <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011f33b:	8b 15 bc d4 b5 f0    	mov    0xf0b5d4bc,%edx
f011f341:	a1 f4 d3 b5 f0       	mov    0xf0b5d3f4,%eax
f011f346:	39 c2                	cmp    %eax,%edx
f011f348:	75 19                	jne    f011f363 <chk2+0x185>
f011f34a:	68 d5 13 13 f0       	push   $0xf01313d5
f011f34f:	68 13 10 13 f0       	push   $0xf0131013
f011f354:	68 35 02 00 00       	push   $0x235
f011f359:	68 5b 10 13 f0       	push   $0xf013105b
f011f35e:	e8 66 10 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011f363:	a1 f4 d3 b5 f0       	mov    0xf0b5d3f4,%eax
f011f368:	a3 bc d4 b5 f0       	mov    %eax,0xf0b5d4bc
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011f36d:	e8 52 75 fe ff       	call   f01068c4 <timer_ticks>
f011f372:	6a 00                	push   $0x0
f011f374:	6a 64                	push   $0x64
f011f376:	52                   	push   %edx
f011f377:	50                   	push   %eax
f011f378:	e8 73 31 00 00       	call   f01224f0 <__moddi3>
f011f37d:	83 c4 10             	add    $0x10,%esp
f011f380:	09 d0                	or     %edx,%eax
f011f382:	85 c0                	test   %eax,%eax
f011f384:	0f 85 b4 01 00 00    	jne    f011f53e <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011f38a:	8b 0d 08 da f5 f0    	mov    0xf0f5da08,%ecx
f011f390:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f395:	f7 e9                	imul   %ecx
f011f397:	c1 fa 05             	sar    $0x5,%edx
f011f39a:	89 c8                	mov    %ecx,%eax
f011f39c:	c1 f8 1f             	sar    $0x1f,%eax
f011f39f:	29 c2                	sub    %eax,%edx
f011f3a1:	89 d0                	mov    %edx,%eax
f011f3a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011f3a6:	8b 0d 08 da f5 f0    	mov    0xf0f5da08,%ecx
f011f3ac:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f3b1:	f7 e9                	imul   %ecx
f011f3b3:	c1 fa 05             	sar    $0x5,%edx
f011f3b6:	89 c8                	mov    %ecx,%eax
f011f3b8:	c1 f8 1f             	sar    $0x1f,%eax
f011f3bb:	29 c2                	sub    %eax,%edx
f011f3bd:	89 d0                	mov    %edx,%eax
f011f3bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f3c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f3c5:	89 d0                	mov    %edx,%eax
f011f3c7:	c1 e0 02             	shl    $0x2,%eax
f011f3ca:	01 d0                	add    %edx,%eax
f011f3cc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f3d3:	01 d0                	add    %edx,%eax
f011f3d5:	c1 e0 02             	shl    $0x2,%eax
f011f3d8:	29 c1                	sub    %eax,%ecx
f011f3da:	89 c8                	mov    %ecx,%eax
f011f3dc:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011f3df:	8b 0d f4 d3 b5 f0    	mov    0xf0b5d3f4,%ecx
f011f3e5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f3ea:	f7 e9                	imul   %ecx
f011f3ec:	c1 fa 05             	sar    $0x5,%edx
f011f3ef:	89 c8                	mov    %ecx,%eax
f011f3f1:	c1 f8 1f             	sar    $0x1f,%eax
f011f3f4:	29 c2                	sub    %eax,%edx
f011f3f6:	89 d0                	mov    %edx,%eax
f011f3f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011f3fb:	8b 0d f4 d3 b5 f0    	mov    0xf0b5d3f4,%ecx
f011f401:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f406:	f7 e9                	imul   %ecx
f011f408:	c1 fa 05             	sar    $0x5,%edx
f011f40b:	89 c8                	mov    %ecx,%eax
f011f40d:	c1 f8 1f             	sar    $0x1f,%eax
f011f410:	29 c2                	sub    %eax,%edx
f011f412:	89 d0                	mov    %edx,%eax
f011f414:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f417:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f41a:	89 d0                	mov    %edx,%eax
f011f41c:	c1 e0 02             	shl    $0x2,%eax
f011f41f:	01 d0                	add    %edx,%eax
f011f421:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f428:	01 d0                	add    %edx,%eax
f011f42a:	c1 e0 02             	shl    $0x2,%eax
f011f42d:	29 c1                	sub    %eax,%ecx
f011f42f:	89 c8                	mov    %ecx,%eax
f011f431:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f434:	8b 15 10 d7 b5 f0    	mov    0xf0b5d710,%edx
f011f43a:	a1 60 d3 b5 f0       	mov    0xf0b5d360,%eax
f011f43f:	39 c2                	cmp    %eax,%edx
f011f441:	0f 85 ed 00 00 00    	jne    f011f534 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f447:	a1 d4 d8 b5 f0       	mov    0xf0b5d8d4,%eax
f011f44c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f44f:	7e 5b                	jle    f011f4ac <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f451:	a1 d4 d8 b5 f0       	mov    0xf0b5d8d4,%eax
f011f456:	83 ec 08             	sub    $0x8,%esp
f011f459:	ff 75 e0             	pushl  -0x20(%ebp)
f011f45c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f45f:	ff 75 e8             	pushl  -0x18(%ebp)
f011f462:	ff 75 ec             	pushl  -0x14(%ebp)
f011f465:	50                   	push   %eax
f011f466:	68 e8 13 13 f0       	push   $0xf01313e8
f011f46b:	e8 1b 1b fe ff       	call   f0100f8b <cprintf>
f011f470:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f473:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f476:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f479:	0f 8f b5 00 00 00    	jg     f011f534 <chk2+0x356>
f011f47f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f482:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f485:	75 0c                	jne    f011f493 <chk2+0x2b5>
f011f487:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f48a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f48d:	0f 8d a1 00 00 00    	jge    f011f534 <chk2+0x356>
f011f493:	68 30 14 13 f0       	push   $0xf0131430
f011f498:	68 13 10 13 f0       	push   $0xf0131013
f011f49d:	68 4a 02 00 00       	push   $0x24a
f011f4a2:	68 5b 10 13 f0       	push   $0xf013105b
f011f4a7:	e8 1d 0f fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011f4ac:	a1 d4 d8 b5 f0       	mov    0xf0b5d8d4,%eax
f011f4b1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f4b4:	7d 53                	jge    f011f509 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f4b6:	a1 d4 d8 b5 f0       	mov    0xf0b5d8d4,%eax
f011f4bb:	83 ec 08             	sub    $0x8,%esp
f011f4be:	ff 75 e0             	pushl  -0x20(%ebp)
f011f4c1:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f4c4:	ff 75 e8             	pushl  -0x18(%ebp)
f011f4c7:	ff 75 ec             	pushl  -0x14(%ebp)
f011f4ca:	50                   	push   %eax
f011f4cb:	68 70 14 13 f0       	push   $0xf0131470
f011f4d0:	e8 b6 1a fe ff       	call   f0100f8b <cprintf>
f011f4d5:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f4d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f4db:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f4de:	7c 54                	jl     f011f534 <chk2+0x356>
f011f4e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f4e3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f4e6:	75 08                	jne    f011f4f0 <chk2+0x312>
f011f4e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f4eb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f4ee:	7e 44                	jle    f011f534 <chk2+0x356>
f011f4f0:	68 b8 14 13 f0       	push   $0xf01314b8
f011f4f5:	68 13 10 13 f0       	push   $0xf0131013
f011f4fa:	68 50 02 00 00       	push   $0x250
f011f4ff:	68 5b 10 13 f0       	push   $0xf013105b
f011f504:	e8 c0 0e fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011f509:	a1 d4 d8 b5 f0       	mov    0xf0b5d8d4,%eax
f011f50e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f511:	75 21                	jne    f011f534 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011f513:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f516:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f519:	74 19                	je     f011f534 <chk2+0x356>
f011f51b:	68 f8 14 13 f0       	push   $0xf01314f8
f011f520:	68 13 10 13 f0       	push   $0xf0131013
f011f525:	68 54 02 00 00       	push   $0x254
f011f52a:	68 5b 10 13 f0       	push   $0xf013105b
f011f52f:	e8 95 0e fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011f534:	a1 f4 d3 b5 f0       	mov    0xf0b5d3f4,%eax
f011f539:	a3 08 da f5 f0       	mov    %eax,0xf0f5da08
			}
		}
		__pnexit = __nnexit;
f011f53e:	a1 10 d7 b5 f0       	mov    0xf0b5d710,%eax
f011f543:	a3 60 d3 b5 f0       	mov    %eax,0xf0b5d360
f011f548:	eb 01                	jmp    f011f54b <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011f54a:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011f54b:	c9                   	leave  
f011f54c:	c3                   	ret    

f011f54d <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011f54d:	55                   	push   %ebp
f011f54e:	89 e5                	mov    %esp,%ebp
f011f550:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f553:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f55a:	eb 40                	jmp    f011f59c <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011f55c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f55f:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f565:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011f56a:	83 ec 08             	sub    $0x8,%esp
f011f56d:	52                   	push   %edx
f011f56e:	50                   	push   %eax
f011f56f:	e8 af 01 00 00       	call   f011f723 <check_va2pa>
f011f574:	83 c4 10             	add    $0x10,%esp
f011f577:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f57a:	74 19                	je     f011f595 <check_boot_pgdir+0x48>
f011f57c:	68 0c 15 13 f0       	push   $0xf013150c
f011f581:	68 13 10 13 f0       	push   $0xf0131013
f011f586:	68 9b 02 00 00       	push   $0x29b
f011f58b:	68 5b 10 13 f0       	push   $0xf013105b
f011f590:	e8 a4 0d fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f595:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f59c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f59f:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f5a5:	a1 50 d9 f5 f0       	mov    0xf0f5d950,%eax
f011f5aa:	39 c2                	cmp    %eax,%edx
f011f5ac:	72 ae                	jb     f011f55c <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f5ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f5b5:	e9 81 00 00 00       	jmp    f011f63b <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011f5ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5bd:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011f5c2:	85 c0                	test   %eax,%eax
f011f5c4:	74 6d                	je     f011f633 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011f5c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5c9:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011f5cf:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011f5d4:	83 ec 08             	sub    $0x8,%esp
f011f5d7:	52                   	push   %edx
f011f5d8:	50                   	push   %eax
f011f5d9:	e8 45 01 00 00       	call   f011f723 <check_va2pa>
f011f5de:	83 c4 10             	add    $0x10,%esp
f011f5e1:	c7 45 f0 00 80 17 f0 	movl   $0xf0178000,-0x10(%ebp)
f011f5e8:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011f5ef:	77 17                	ja     f011f608 <check_boot_pgdir+0xbb>
f011f5f1:	ff 75 f0             	pushl  -0x10(%ebp)
f011f5f4:	68 44 15 13 f0       	push   $0xf0131544
f011f5f9:	68 a9 02 00 00       	push   $0x2a9
f011f5fe:	68 5b 10 13 f0       	push   $0xf013105b
f011f603:	e8 31 0d fe ff       	call   f0100339 <_panic>
f011f608:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f60b:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011f611:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f614:	01 ca                	add    %ecx,%edx
f011f616:	39 d0                	cmp    %edx,%eax
f011f618:	74 1a                	je     f011f634 <check_boot_pgdir+0xe7>
f011f61a:	68 78 15 13 f0       	push   $0xf0131578
f011f61f:	68 13 10 13 f0       	push   $0xf0131013
f011f624:	68 a9 02 00 00       	push   $0x2a9
f011f629:	68 5b 10 13 f0       	push   $0xf013105b
f011f62e:	e8 06 0d fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011f633:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f634:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f63b:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011f642:	0f 86 72 ff ff ff    	jbe    f011f5ba <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f648:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f64f:	e9 af 00 00 00       	jmp    f011f703 <check_boot_pgdir+0x1b6>
		switch (i) {
f011f654:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f657:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f65c:	74 11                	je     f011f66f <check_boot_pgdir+0x122>
f011f65e:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f663:	72 36                	jb     f011f69b <check_boot_pgdir+0x14e>
f011f665:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011f66a:	83 f8 02             	cmp    $0x2,%eax
f011f66d:	77 2c                	ja     f011f69b <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011f66f:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011f674:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f677:	c1 e2 02             	shl    $0x2,%edx
f011f67a:	01 d0                	add    %edx,%eax
f011f67c:	8b 00                	mov    (%eax),%eax
f011f67e:	85 c0                	test   %eax,%eax
f011f680:	75 7a                	jne    f011f6fc <check_boot_pgdir+0x1af>
f011f682:	68 fe 15 13 f0       	push   $0xf01315fe
f011f687:	68 13 10 13 f0       	push   $0xf0131013
f011f68c:	68 b4 02 00 00       	push   $0x2b4
f011f691:	68 5b 10 13 f0       	push   $0xf013105b
f011f696:	e8 9e 0c fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011f69b:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011f6a2:	76 2c                	jbe    f011f6d0 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011f6a4:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011f6a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f6ac:	c1 e2 02             	shl    $0x2,%edx
f011f6af:	01 d0                	add    %edx,%eax
f011f6b1:	8b 00                	mov    (%eax),%eax
f011f6b3:	85 c0                	test   %eax,%eax
f011f6b5:	75 48                	jne    f011f6ff <check_boot_pgdir+0x1b2>
f011f6b7:	68 fe 15 13 f0       	push   $0xf01315fe
f011f6bc:	68 13 10 13 f0       	push   $0xf0131013
f011f6c1:	68 b8 02 00 00       	push   $0x2b8
f011f6c6:	68 5b 10 13 f0       	push   $0xf013105b
f011f6cb:	e8 69 0c fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011f6d0:	a1 54 d9 f5 f0       	mov    0xf0f5d954,%eax
f011f6d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f6d8:	c1 e2 02             	shl    $0x2,%edx
f011f6db:	01 d0                	add    %edx,%eax
f011f6dd:	8b 00                	mov    (%eax),%eax
f011f6df:	85 c0                	test   %eax,%eax
f011f6e1:	74 1c                	je     f011f6ff <check_boot_pgdir+0x1b2>
f011f6e3:	68 14 16 13 f0       	push   $0xf0131614
f011f6e8:	68 13 10 13 f0       	push   $0xf0131013
f011f6ed:	68 ba 02 00 00       	push   $0x2ba
f011f6f2:	68 5b 10 13 f0       	push   $0xf013105b
f011f6f7:	e8 3d 0c fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011f6fc:	90                   	nop
f011f6fd:	eb 01                	jmp    f011f700 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011f6ff:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f700:	ff 45 f4             	incl   -0xc(%ebp)
f011f703:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011f70a:	0f 86 44 ff ff ff    	jbe    f011f654 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011f710:	83 ec 0c             	sub    $0xc,%esp
f011f713:	68 30 16 13 f0       	push   $0xf0131630
f011f718:	e8 6e 18 fe ff       	call   f0100f8b <cprintf>
f011f71d:	83 c4 10             	add    $0x10,%esp
}
f011f720:	90                   	nop
f011f721:	c9                   	leave  
f011f722:	c3                   	ret    

f011f723 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011f723:	55                   	push   %ebp
f011f724:	89 e5                	mov    %esp,%ebp
f011f726:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011f729:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f72c:	c1 e8 16             	shr    $0x16,%eax
f011f72f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f736:	8b 45 08             	mov    0x8(%ebp),%eax
f011f739:	01 d0                	add    %edx,%eax
f011f73b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011f73e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f741:	8b 00                	mov    (%eax),%eax
f011f743:	83 e0 01             	and    $0x1,%eax
f011f746:	85 c0                	test   %eax,%eax
f011f748:	75 0a                	jne    f011f754 <check_va2pa+0x31>
		return ~0;
f011f74a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f74f:	e9 87 00 00 00       	jmp    f011f7db <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011f754:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f757:	8b 00                	mov    (%eax),%eax
f011f759:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f75e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f761:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f764:	c1 e8 0c             	shr    $0xc,%eax
f011f767:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f76a:	a1 b8 d4 b5 f0       	mov    0xf0b5d4b8,%eax
f011f76f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011f772:	72 17                	jb     f011f78b <check_va2pa+0x68>
f011f774:	ff 75 f0             	pushl  -0x10(%ebp)
f011f777:	68 54 16 13 f0       	push   $0xf0131654
f011f77c:	68 d0 02 00 00       	push   $0x2d0
f011f781:	68 5b 10 13 f0       	push   $0xf013105b
f011f786:	e8 ae 0b fe ff       	call   f0100339 <_panic>
f011f78b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f78e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011f793:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011f796:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f799:	c1 e8 0c             	shr    $0xc,%eax
f011f79c:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f7a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f7a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f7ab:	01 d0                	add    %edx,%eax
f011f7ad:	8b 00                	mov    (%eax),%eax
f011f7af:	83 e0 01             	and    $0x1,%eax
f011f7b2:	85 c0                	test   %eax,%eax
f011f7b4:	75 07                	jne    f011f7bd <check_va2pa+0x9a>
		return ~0;
f011f7b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f7bb:	eb 1e                	jmp    f011f7db <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011f7bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f7c0:	c1 e8 0c             	shr    $0xc,%eax
f011f7c3:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f7c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f7cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f7d2:	01 d0                	add    %edx,%eax
f011f7d4:	8b 00                	mov    (%eax),%eax
f011f7d6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011f7db:	c9                   	leave  
f011f7dc:	c3                   	ret    

f011f7dd <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011f7dd:	55                   	push   %ebp
f011f7de:	89 e5                	mov    %esp,%ebp
f011f7e0:	53                   	push   %ebx
f011f7e1:	83 ec 14             	sub    $0x14,%esp
f011f7e4:	8b 45 10             	mov    0x10(%ebp),%eax
f011f7e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f7ea:	8b 45 14             	mov    0x14(%ebp),%eax
f011f7ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011f7f0:	8b 45 18             	mov    0x18(%ebp),%eax
f011f7f3:	ba 00 00 00 00       	mov    $0x0,%edx
f011f7f8:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f7fb:	77 55                	ja     f011f852 <printnum+0x75>
f011f7fd:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f800:	72 05                	jb     f011f807 <printnum+0x2a>
f011f802:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f805:	77 4b                	ja     f011f852 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011f807:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011f80a:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011f80d:	8b 45 18             	mov    0x18(%ebp),%eax
f011f810:	ba 00 00 00 00       	mov    $0x0,%edx
f011f815:	52                   	push   %edx
f011f816:	50                   	push   %eax
f011f817:	ff 75 f4             	pushl  -0xc(%ebp)
f011f81a:	ff 75 f0             	pushl  -0x10(%ebp)
f011f81d:	e8 66 2e 00 00       	call   f0122688 <__udivdi3>
f011f822:	83 c4 10             	add    $0x10,%esp
f011f825:	83 ec 04             	sub    $0x4,%esp
f011f828:	ff 75 20             	pushl  0x20(%ebp)
f011f82b:	53                   	push   %ebx
f011f82c:	ff 75 18             	pushl  0x18(%ebp)
f011f82f:	52                   	push   %edx
f011f830:	50                   	push   %eax
f011f831:	ff 75 0c             	pushl  0xc(%ebp)
f011f834:	ff 75 08             	pushl  0x8(%ebp)
f011f837:	e8 a1 ff ff ff       	call   f011f7dd <printnum>
f011f83c:	83 c4 20             	add    $0x20,%esp
f011f83f:	eb 1a                	jmp    f011f85b <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011f841:	83 ec 08             	sub    $0x8,%esp
f011f844:	ff 75 0c             	pushl  0xc(%ebp)
f011f847:	ff 75 20             	pushl  0x20(%ebp)
f011f84a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f84d:	ff d0                	call   *%eax
f011f84f:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011f852:	ff 4d 1c             	decl   0x1c(%ebp)
f011f855:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011f859:	7f e6                	jg     f011f841 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011f85b:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011f85e:	bb 00 00 00 00       	mov    $0x0,%ebx
f011f863:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f866:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f869:	53                   	push   %ebx
f011f86a:	51                   	push   %ecx
f011f86b:	52                   	push   %edx
f011f86c:	50                   	push   %eax
f011f86d:	e8 26 2f 00 00       	call   f0122798 <__umoddi3>
f011f872:	83 c4 10             	add    $0x10,%esp
f011f875:	05 b4 18 13 f0       	add    $0xf01318b4,%eax
f011f87a:	8a 00                	mov    (%eax),%al
f011f87c:	0f be c0             	movsbl %al,%eax
f011f87f:	83 ec 08             	sub    $0x8,%esp
f011f882:	ff 75 0c             	pushl  0xc(%ebp)
f011f885:	50                   	push   %eax
f011f886:	8b 45 08             	mov    0x8(%ebp),%eax
f011f889:	ff d0                	call   *%eax
f011f88b:	83 c4 10             	add    $0x10,%esp
}
f011f88e:	90                   	nop
f011f88f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f892:	c9                   	leave  
f011f893:	c3                   	ret    

f011f894 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011f894:	55                   	push   %ebp
f011f895:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f897:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f89b:	7e 1c                	jle    f011f8b9 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011f89d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8a0:	8b 00                	mov    (%eax),%eax
f011f8a2:	8d 50 08             	lea    0x8(%eax),%edx
f011f8a5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8a8:	89 10                	mov    %edx,(%eax)
f011f8aa:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8ad:	8b 00                	mov    (%eax),%eax
f011f8af:	83 e8 08             	sub    $0x8,%eax
f011f8b2:	8b 50 04             	mov    0x4(%eax),%edx
f011f8b5:	8b 00                	mov    (%eax),%eax
f011f8b7:	eb 40                	jmp    f011f8f9 <getuint+0x65>
	else if (lflag)
f011f8b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f8bd:	74 1e                	je     f011f8dd <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011f8bf:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8c2:	8b 00                	mov    (%eax),%eax
f011f8c4:	8d 50 04             	lea    0x4(%eax),%edx
f011f8c7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8ca:	89 10                	mov    %edx,(%eax)
f011f8cc:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8cf:	8b 00                	mov    (%eax),%eax
f011f8d1:	83 e8 04             	sub    $0x4,%eax
f011f8d4:	8b 00                	mov    (%eax),%eax
f011f8d6:	ba 00 00 00 00       	mov    $0x0,%edx
f011f8db:	eb 1c                	jmp    f011f8f9 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011f8dd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8e0:	8b 00                	mov    (%eax),%eax
f011f8e2:	8d 50 04             	lea    0x4(%eax),%edx
f011f8e5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8e8:	89 10                	mov    %edx,(%eax)
f011f8ea:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8ed:	8b 00                	mov    (%eax),%eax
f011f8ef:	83 e8 04             	sub    $0x4,%eax
f011f8f2:	8b 00                	mov    (%eax),%eax
f011f8f4:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011f8f9:	5d                   	pop    %ebp
f011f8fa:	c3                   	ret    

f011f8fb <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011f8fb:	55                   	push   %ebp
f011f8fc:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f8fe:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f902:	7e 1c                	jle    f011f920 <getint+0x25>
		return va_arg(*ap, long long);
f011f904:	8b 45 08             	mov    0x8(%ebp),%eax
f011f907:	8b 00                	mov    (%eax),%eax
f011f909:	8d 50 08             	lea    0x8(%eax),%edx
f011f90c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f90f:	89 10                	mov    %edx,(%eax)
f011f911:	8b 45 08             	mov    0x8(%ebp),%eax
f011f914:	8b 00                	mov    (%eax),%eax
f011f916:	83 e8 08             	sub    $0x8,%eax
f011f919:	8b 50 04             	mov    0x4(%eax),%edx
f011f91c:	8b 00                	mov    (%eax),%eax
f011f91e:	eb 38                	jmp    f011f958 <getint+0x5d>
	else if (lflag)
f011f920:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f924:	74 1a                	je     f011f940 <getint+0x45>
		return va_arg(*ap, long);
f011f926:	8b 45 08             	mov    0x8(%ebp),%eax
f011f929:	8b 00                	mov    (%eax),%eax
f011f92b:	8d 50 04             	lea    0x4(%eax),%edx
f011f92e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f931:	89 10                	mov    %edx,(%eax)
f011f933:	8b 45 08             	mov    0x8(%ebp),%eax
f011f936:	8b 00                	mov    (%eax),%eax
f011f938:	83 e8 04             	sub    $0x4,%eax
f011f93b:	8b 00                	mov    (%eax),%eax
f011f93d:	99                   	cltd   
f011f93e:	eb 18                	jmp    f011f958 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011f940:	8b 45 08             	mov    0x8(%ebp),%eax
f011f943:	8b 00                	mov    (%eax),%eax
f011f945:	8d 50 04             	lea    0x4(%eax),%edx
f011f948:	8b 45 08             	mov    0x8(%ebp),%eax
f011f94b:	89 10                	mov    %edx,(%eax)
f011f94d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f950:	8b 00                	mov    (%eax),%eax
f011f952:	83 e8 04             	sub    $0x4,%eax
f011f955:	8b 00                	mov    (%eax),%eax
f011f957:	99                   	cltd   
}
f011f958:	5d                   	pop    %ebp
f011f959:	c3                   	ret    

f011f95a <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011f95a:	55                   	push   %ebp
f011f95b:	89 e5                	mov    %esp,%ebp
f011f95d:	56                   	push   %esi
f011f95e:	53                   	push   %ebx
f011f95f:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f962:	eb 17                	jmp    f011f97b <vprintfmt+0x21>
			if (ch == '\0')
f011f964:	85 db                	test   %ebx,%ebx
f011f966:	0f 84 c1 03 00 00    	je     f011fd2d <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011f96c:	83 ec 08             	sub    $0x8,%esp
f011f96f:	ff 75 0c             	pushl  0xc(%ebp)
f011f972:	53                   	push   %ebx
f011f973:	8b 45 08             	mov    0x8(%ebp),%eax
f011f976:	ff d0                	call   *%eax
f011f978:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f97b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f97e:	8d 50 01             	lea    0x1(%eax),%edx
f011f981:	89 55 10             	mov    %edx,0x10(%ebp)
f011f984:	8a 00                	mov    (%eax),%al
f011f986:	0f b6 d8             	movzbl %al,%ebx
f011f989:	83 fb 25             	cmp    $0x25,%ebx
f011f98c:	75 d6                	jne    f011f964 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011f98e:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011f992:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011f999:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011f9a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011f9a7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011f9ae:	8b 45 10             	mov    0x10(%ebp),%eax
f011f9b1:	8d 50 01             	lea    0x1(%eax),%edx
f011f9b4:	89 55 10             	mov    %edx,0x10(%ebp)
f011f9b7:	8a 00                	mov    (%eax),%al
f011f9b9:	0f b6 d8             	movzbl %al,%ebx
f011f9bc:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011f9bf:	83 f8 5b             	cmp    $0x5b,%eax
f011f9c2:	0f 87 3d 03 00 00    	ja     f011fd05 <vprintfmt+0x3ab>
f011f9c8:	8b 04 85 d8 18 13 f0 	mov    -0xfece728(,%eax,4),%eax
f011f9cf:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011f9d1:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011f9d5:	eb d7                	jmp    f011f9ae <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011f9d7:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011f9db:	eb d1                	jmp    f011f9ae <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f9dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011f9e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f9e7:	89 d0                	mov    %edx,%eax
f011f9e9:	c1 e0 02             	shl    $0x2,%eax
f011f9ec:	01 d0                	add    %edx,%eax
f011f9ee:	01 c0                	add    %eax,%eax
f011f9f0:	01 d8                	add    %ebx,%eax
f011f9f2:	83 e8 30             	sub    $0x30,%eax
f011f9f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011f9f8:	8b 45 10             	mov    0x10(%ebp),%eax
f011f9fb:	8a 00                	mov    (%eax),%al
f011f9fd:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011fa00:	83 fb 2f             	cmp    $0x2f,%ebx
f011fa03:	7e 3e                	jle    f011fa43 <vprintfmt+0xe9>
f011fa05:	83 fb 39             	cmp    $0x39,%ebx
f011fa08:	7f 39                	jg     f011fa43 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011fa0a:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011fa0d:	eb d5                	jmp    f011f9e4 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011fa0f:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa12:	83 c0 04             	add    $0x4,%eax
f011fa15:	89 45 14             	mov    %eax,0x14(%ebp)
f011fa18:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa1b:	83 e8 04             	sub    $0x4,%eax
f011fa1e:	8b 00                	mov    (%eax),%eax
f011fa20:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011fa23:	eb 1f                	jmp    f011fa44 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011fa25:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fa29:	79 83                	jns    f011f9ae <vprintfmt+0x54>
				width = 0;
f011fa2b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011fa32:	e9 77 ff ff ff       	jmp    f011f9ae <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011fa37:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011fa3e:	e9 6b ff ff ff       	jmp    f011f9ae <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011fa43:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011fa44:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fa48:	0f 89 60 ff ff ff    	jns    f011f9ae <vprintfmt+0x54>
				width = precision, precision = -1;
f011fa4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fa51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011fa54:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011fa5b:	e9 4e ff ff ff       	jmp    f011f9ae <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011fa60:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011fa63:	e9 46 ff ff ff       	jmp    f011f9ae <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011fa68:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa6b:	83 c0 04             	add    $0x4,%eax
f011fa6e:	89 45 14             	mov    %eax,0x14(%ebp)
f011fa71:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa74:	83 e8 04             	sub    $0x4,%eax
f011fa77:	8b 00                	mov    (%eax),%eax
f011fa79:	83 ec 08             	sub    $0x8,%esp
f011fa7c:	ff 75 0c             	pushl  0xc(%ebp)
f011fa7f:	50                   	push   %eax
f011fa80:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa83:	ff d0                	call   *%eax
f011fa85:	83 c4 10             	add    $0x10,%esp
			break;
f011fa88:	e9 9b 02 00 00       	jmp    f011fd28 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011fa8d:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa90:	83 c0 04             	add    $0x4,%eax
f011fa93:	89 45 14             	mov    %eax,0x14(%ebp)
f011fa96:	8b 45 14             	mov    0x14(%ebp),%eax
f011fa99:	83 e8 04             	sub    $0x4,%eax
f011fa9c:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011fa9e:	85 db                	test   %ebx,%ebx
f011faa0:	79 02                	jns    f011faa4 <vprintfmt+0x14a>
				err = -err;
f011faa2:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011faa4:	83 fb 64             	cmp    $0x64,%ebx
f011faa7:	7f 0b                	jg     f011fab4 <vprintfmt+0x15a>
f011faa9:	8b 34 9d 20 17 13 f0 	mov    -0xfece8e0(,%ebx,4),%esi
f011fab0:	85 f6                	test   %esi,%esi
f011fab2:	75 19                	jne    f011facd <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011fab4:	53                   	push   %ebx
f011fab5:	68 c5 18 13 f0       	push   $0xf01318c5
f011faba:	ff 75 0c             	pushl  0xc(%ebp)
f011fabd:	ff 75 08             	pushl  0x8(%ebp)
f011fac0:	e8 70 02 00 00       	call   f011fd35 <printfmt>
f011fac5:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011fac8:	e9 5b 02 00 00       	jmp    f011fd28 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011facd:	56                   	push   %esi
f011face:	68 ce 18 13 f0       	push   $0xf01318ce
f011fad3:	ff 75 0c             	pushl  0xc(%ebp)
f011fad6:	ff 75 08             	pushl  0x8(%ebp)
f011fad9:	e8 57 02 00 00       	call   f011fd35 <printfmt>
f011fade:	83 c4 10             	add    $0x10,%esp
			break;
f011fae1:	e9 42 02 00 00       	jmp    f011fd28 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011fae6:	8b 45 14             	mov    0x14(%ebp),%eax
f011fae9:	83 c0 04             	add    $0x4,%eax
f011faec:	89 45 14             	mov    %eax,0x14(%ebp)
f011faef:	8b 45 14             	mov    0x14(%ebp),%eax
f011faf2:	83 e8 04             	sub    $0x4,%eax
f011faf5:	8b 30                	mov    (%eax),%esi
f011faf7:	85 f6                	test   %esi,%esi
f011faf9:	75 05                	jne    f011fb00 <vprintfmt+0x1a6>
				p = "(null)";
f011fafb:	be d1 18 13 f0       	mov    $0xf01318d1,%esi
			if (width > 0 && padc != '-')
f011fb00:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fb04:	7e 6d                	jle    f011fb73 <vprintfmt+0x219>
f011fb06:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011fb0a:	74 67                	je     f011fb73 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011fb0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fb0f:	83 ec 08             	sub    $0x8,%esp
f011fb12:	50                   	push   %eax
f011fb13:	56                   	push   %esi
f011fb14:	e8 26 05 00 00       	call   f012003f <strnlen>
f011fb19:	83 c4 10             	add    $0x10,%esp
f011fb1c:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011fb1f:	eb 16                	jmp    f011fb37 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011fb21:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011fb25:	83 ec 08             	sub    $0x8,%esp
f011fb28:	ff 75 0c             	pushl  0xc(%ebp)
f011fb2b:	50                   	push   %eax
f011fb2c:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb2f:	ff d0                	call   *%eax
f011fb31:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011fb34:	ff 4d e4             	decl   -0x1c(%ebp)
f011fb37:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fb3b:	7f e4                	jg     f011fb21 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011fb3d:	eb 34                	jmp    f011fb73 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011fb3f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011fb43:	74 1c                	je     f011fb61 <vprintfmt+0x207>
f011fb45:	83 fb 1f             	cmp    $0x1f,%ebx
f011fb48:	7e 05                	jle    f011fb4f <vprintfmt+0x1f5>
f011fb4a:	83 fb 7e             	cmp    $0x7e,%ebx
f011fb4d:	7e 12                	jle    f011fb61 <vprintfmt+0x207>
					putch('?', putdat);
f011fb4f:	83 ec 08             	sub    $0x8,%esp
f011fb52:	ff 75 0c             	pushl  0xc(%ebp)
f011fb55:	6a 3f                	push   $0x3f
f011fb57:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb5a:	ff d0                	call   *%eax
f011fb5c:	83 c4 10             	add    $0x10,%esp
f011fb5f:	eb 0f                	jmp    f011fb70 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011fb61:	83 ec 08             	sub    $0x8,%esp
f011fb64:	ff 75 0c             	pushl  0xc(%ebp)
f011fb67:	53                   	push   %ebx
f011fb68:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb6b:	ff d0                	call   *%eax
f011fb6d:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011fb70:	ff 4d e4             	decl   -0x1c(%ebp)
f011fb73:	89 f0                	mov    %esi,%eax
f011fb75:	8d 70 01             	lea    0x1(%eax),%esi
f011fb78:	8a 00                	mov    (%eax),%al
f011fb7a:	0f be d8             	movsbl %al,%ebx
f011fb7d:	85 db                	test   %ebx,%ebx
f011fb7f:	74 24                	je     f011fba5 <vprintfmt+0x24b>
f011fb81:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fb85:	78 b8                	js     f011fb3f <vprintfmt+0x1e5>
f011fb87:	ff 4d e0             	decl   -0x20(%ebp)
f011fb8a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011fb8e:	79 af                	jns    f011fb3f <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011fb90:	eb 13                	jmp    f011fba5 <vprintfmt+0x24b>
				putch(' ', putdat);
f011fb92:	83 ec 08             	sub    $0x8,%esp
f011fb95:	ff 75 0c             	pushl  0xc(%ebp)
f011fb98:	6a 20                	push   $0x20
f011fb9a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb9d:	ff d0                	call   *%eax
f011fb9f:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011fba2:	ff 4d e4             	decl   -0x1c(%ebp)
f011fba5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fba9:	7f e7                	jg     f011fb92 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011fbab:	e9 78 01 00 00       	jmp    f011fd28 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011fbb0:	83 ec 08             	sub    $0x8,%esp
f011fbb3:	ff 75 e8             	pushl  -0x18(%ebp)
f011fbb6:	8d 45 14             	lea    0x14(%ebp),%eax
f011fbb9:	50                   	push   %eax
f011fbba:	e8 3c fd ff ff       	call   f011f8fb <getint>
f011fbbf:	83 c4 10             	add    $0x10,%esp
f011fbc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fbc5:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011fbc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fbcb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbce:	85 d2                	test   %edx,%edx
f011fbd0:	79 23                	jns    f011fbf5 <vprintfmt+0x29b>
				putch('-', putdat);
f011fbd2:	83 ec 08             	sub    $0x8,%esp
f011fbd5:	ff 75 0c             	pushl  0xc(%ebp)
f011fbd8:	6a 2d                	push   $0x2d
f011fbda:	8b 45 08             	mov    0x8(%ebp),%eax
f011fbdd:	ff d0                	call   *%eax
f011fbdf:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011fbe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fbe5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbe8:	f7 d8                	neg    %eax
f011fbea:	83 d2 00             	adc    $0x0,%edx
f011fbed:	f7 da                	neg    %edx
f011fbef:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fbf2:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011fbf5:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011fbfc:	e9 bc 00 00 00       	jmp    f011fcbd <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011fc01:	83 ec 08             	sub    $0x8,%esp
f011fc04:	ff 75 e8             	pushl  -0x18(%ebp)
f011fc07:	8d 45 14             	lea    0x14(%ebp),%eax
f011fc0a:	50                   	push   %eax
f011fc0b:	e8 84 fc ff ff       	call   f011f894 <getuint>
f011fc10:	83 c4 10             	add    $0x10,%esp
f011fc13:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fc16:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011fc19:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011fc20:	e9 98 00 00 00       	jmp    f011fcbd <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011fc25:	83 ec 08             	sub    $0x8,%esp
f011fc28:	ff 75 0c             	pushl  0xc(%ebp)
f011fc2b:	6a 58                	push   $0x58
f011fc2d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc30:	ff d0                	call   *%eax
f011fc32:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011fc35:	83 ec 08             	sub    $0x8,%esp
f011fc38:	ff 75 0c             	pushl  0xc(%ebp)
f011fc3b:	6a 58                	push   $0x58
f011fc3d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc40:	ff d0                	call   *%eax
f011fc42:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011fc45:	83 ec 08             	sub    $0x8,%esp
f011fc48:	ff 75 0c             	pushl  0xc(%ebp)
f011fc4b:	6a 58                	push   $0x58
f011fc4d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc50:	ff d0                	call   *%eax
f011fc52:	83 c4 10             	add    $0x10,%esp
			break;
f011fc55:	e9 ce 00 00 00       	jmp    f011fd28 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011fc5a:	83 ec 08             	sub    $0x8,%esp
f011fc5d:	ff 75 0c             	pushl  0xc(%ebp)
f011fc60:	6a 30                	push   $0x30
f011fc62:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc65:	ff d0                	call   *%eax
f011fc67:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011fc6a:	83 ec 08             	sub    $0x8,%esp
f011fc6d:	ff 75 0c             	pushl  0xc(%ebp)
f011fc70:	6a 78                	push   $0x78
f011fc72:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc75:	ff d0                	call   *%eax
f011fc77:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011fc7a:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc7d:	83 c0 04             	add    $0x4,%eax
f011fc80:	89 45 14             	mov    %eax,0x14(%ebp)
f011fc83:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc86:	83 e8 04             	sub    $0x4,%eax
f011fc89:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011fc8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fc8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011fc95:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011fc9c:	eb 1f                	jmp    f011fcbd <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011fc9e:	83 ec 08             	sub    $0x8,%esp
f011fca1:	ff 75 e8             	pushl  -0x18(%ebp)
f011fca4:	8d 45 14             	lea    0x14(%ebp),%eax
f011fca7:	50                   	push   %eax
f011fca8:	e8 e7 fb ff ff       	call   f011f894 <getuint>
f011fcad:	83 c4 10             	add    $0x10,%esp
f011fcb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fcb3:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011fcb6:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011fcbd:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011fcc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fcc4:	83 ec 04             	sub    $0x4,%esp
f011fcc7:	52                   	push   %edx
f011fcc8:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fccb:	50                   	push   %eax
f011fccc:	ff 75 f4             	pushl  -0xc(%ebp)
f011fccf:	ff 75 f0             	pushl  -0x10(%ebp)
f011fcd2:	ff 75 0c             	pushl  0xc(%ebp)
f011fcd5:	ff 75 08             	pushl  0x8(%ebp)
f011fcd8:	e8 00 fb ff ff       	call   f011f7dd <printnum>
f011fcdd:	83 c4 20             	add    $0x20,%esp
			break;
f011fce0:	eb 46                	jmp    f011fd28 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011fce2:	83 ec 08             	sub    $0x8,%esp
f011fce5:	ff 75 0c             	pushl  0xc(%ebp)
f011fce8:	53                   	push   %ebx
f011fce9:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcec:	ff d0                	call   *%eax
f011fcee:	83 c4 10             	add    $0x10,%esp
			break;
f011fcf1:	eb 35                	jmp    f011fd28 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011fcf3:	c6 05 00 d2 75 f0 00 	movb   $0x0,0xf075d200
			break;
f011fcfa:	eb 2c                	jmp    f011fd28 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011fcfc:	c6 05 00 d2 75 f0 01 	movb   $0x1,0xf075d200
			break;
f011fd03:	eb 23                	jmp    f011fd28 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011fd05:	83 ec 08             	sub    $0x8,%esp
f011fd08:	ff 75 0c             	pushl  0xc(%ebp)
f011fd0b:	6a 25                	push   $0x25
f011fd0d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd10:	ff d0                	call   *%eax
f011fd12:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011fd15:	ff 4d 10             	decl   0x10(%ebp)
f011fd18:	eb 03                	jmp    f011fd1d <vprintfmt+0x3c3>
f011fd1a:	ff 4d 10             	decl   0x10(%ebp)
f011fd1d:	8b 45 10             	mov    0x10(%ebp),%eax
f011fd20:	48                   	dec    %eax
f011fd21:	8a 00                	mov    (%eax),%al
f011fd23:	3c 25                	cmp    $0x25,%al
f011fd25:	75 f3                	jne    f011fd1a <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011fd27:	90                   	nop
		}
	}
f011fd28:	e9 35 fc ff ff       	jmp    f011f962 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011fd2d:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011fd2e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011fd31:	5b                   	pop    %ebx
f011fd32:	5e                   	pop    %esi
f011fd33:	5d                   	pop    %ebp
f011fd34:	c3                   	ret    

f011fd35 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011fd35:	55                   	push   %ebp
f011fd36:	89 e5                	mov    %esp,%ebp
f011fd38:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011fd3b:	8d 45 10             	lea    0x10(%ebp),%eax
f011fd3e:	83 c0 04             	add    $0x4,%eax
f011fd41:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011fd44:	8b 45 10             	mov    0x10(%ebp),%eax
f011fd47:	ff 75 f4             	pushl  -0xc(%ebp)
f011fd4a:	50                   	push   %eax
f011fd4b:	ff 75 0c             	pushl  0xc(%ebp)
f011fd4e:	ff 75 08             	pushl  0x8(%ebp)
f011fd51:	e8 04 fc ff ff       	call   f011f95a <vprintfmt>
f011fd56:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011fd59:	90                   	nop
f011fd5a:	c9                   	leave  
f011fd5b:	c3                   	ret    

f011fd5c <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011fd5c:	55                   	push   %ebp
f011fd5d:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011fd5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd62:	8b 40 08             	mov    0x8(%eax),%eax
f011fd65:	8d 50 01             	lea    0x1(%eax),%edx
f011fd68:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd6b:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011fd6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd71:	8b 10                	mov    (%eax),%edx
f011fd73:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd76:	8b 40 04             	mov    0x4(%eax),%eax
f011fd79:	39 c2                	cmp    %eax,%edx
f011fd7b:	73 12                	jae    f011fd8f <sprintputch+0x33>
		*b->buf++ = ch;
f011fd7d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd80:	8b 00                	mov    (%eax),%eax
f011fd82:	8d 48 01             	lea    0x1(%eax),%ecx
f011fd85:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fd88:	89 0a                	mov    %ecx,(%edx)
f011fd8a:	8b 55 08             	mov    0x8(%ebp),%edx
f011fd8d:	88 10                	mov    %dl,(%eax)
}
f011fd8f:	90                   	nop
f011fd90:	5d                   	pop    %ebp
f011fd91:	c3                   	ret    

f011fd92 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011fd92:	55                   	push   %ebp
f011fd93:	89 e5                	mov    %esp,%ebp
f011fd95:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011fd98:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fd9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fda1:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fda4:	8b 45 08             	mov    0x8(%ebp),%eax
f011fda7:	01 d0                	add    %edx,%eax
f011fda9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fdac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011fdb3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fdb7:	74 06                	je     f011fdbf <vsnprintf+0x2d>
f011fdb9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fdbd:	7f 07                	jg     f011fdc6 <vsnprintf+0x34>
		return -E_INVAL;
f011fdbf:	b8 03 00 00 00       	mov    $0x3,%eax
f011fdc4:	eb 20                	jmp    f011fde6 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011fdc6:	ff 75 14             	pushl  0x14(%ebp)
f011fdc9:	ff 75 10             	pushl  0x10(%ebp)
f011fdcc:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011fdcf:	50                   	push   %eax
f011fdd0:	68 5c fd 11 f0       	push   $0xf011fd5c
f011fdd5:	e8 80 fb ff ff       	call   f011f95a <vprintfmt>
f011fdda:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011fddd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fde0:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011fde3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011fde6:	c9                   	leave  
f011fde7:	c3                   	ret    

f011fde8 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011fde8:	55                   	push   %ebp
f011fde9:	89 e5                	mov    %esp,%ebp
f011fdeb:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011fdee:	8d 45 10             	lea    0x10(%ebp),%eax
f011fdf1:	83 c0 04             	add    $0x4,%eax
f011fdf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011fdf7:	8b 45 10             	mov    0x10(%ebp),%eax
f011fdfa:	ff 75 f4             	pushl  -0xc(%ebp)
f011fdfd:	50                   	push   %eax
f011fdfe:	ff 75 0c             	pushl  0xc(%ebp)
f011fe01:	ff 75 08             	pushl  0x8(%ebp)
f011fe04:	e8 89 ff ff ff       	call   f011fd92 <vsnprintf>
f011fe09:	83 c4 10             	add    $0x10,%esp
f011fe0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011fe0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011fe12:	c9                   	leave  
f011fe13:	c3                   	ret    

f011fe14 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011fe14:	55                   	push   %ebp
f011fe15:	89 e5                	mov    %esp,%ebp
f011fe17:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011fe1a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fe1e:	74 13                	je     f011fe33 <readline+0x1f>
		cprintf("%s", prompt);
f011fe20:	83 ec 08             	sub    $0x8,%esp
f011fe23:	ff 75 08             	pushl  0x8(%ebp)
f011fe26:	68 48 1a 13 f0       	push   $0xf0131a48
f011fe2b:	e8 5b 11 fe ff       	call   f0100f8b <cprintf>
f011fe30:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011fe33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011fe3a:	83 ec 0c             	sub    $0xc,%esp
f011fe3d:	6a 00                	push   $0x0
f011fe3f:	e8 54 10 fe ff       	call   f0100e98 <iscons>
f011fe44:	83 c4 10             	add    $0x10,%esp
f011fe47:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011fe4a:	e8 30 10 fe ff       	call   f0100e7f <getchar>
f011fe4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011fe52:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fe56:	79 22                	jns    f011fe7a <readline+0x66>
			if (c != -E_EOF)
f011fe58:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fe5c:	0f 84 ad 00 00 00    	je     f011ff0f <readline+0xfb>
				cprintf("read error: %e\n", c);
f011fe62:	83 ec 08             	sub    $0x8,%esp
f011fe65:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe68:	68 4b 1a 13 f0       	push   $0xf0131a4b
f011fe6d:	e8 19 11 fe ff       	call   f0100f8b <cprintf>
f011fe72:	83 c4 10             	add    $0x10,%esp
			break;
f011fe75:	e9 95 00 00 00       	jmp    f011ff0f <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011fe7a:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fe7e:	7e 34                	jle    f011feb4 <readline+0xa0>
f011fe80:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fe87:	7f 2b                	jg     f011feb4 <readline+0xa0>
			if (echoing)
f011fe89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fe8d:	74 0e                	je     f011fe9d <readline+0x89>
				cputchar(c);
f011fe8f:	83 ec 0c             	sub    $0xc,%esp
f011fe92:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe95:	e8 ce 0f fe ff       	call   f0100e68 <cputchar>
f011fe9a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011fe9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fea0:	8d 50 01             	lea    0x1(%eax),%edx
f011fea3:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fea6:	89 c2                	mov    %eax,%edx
f011fea8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011feab:	01 d0                	add    %edx,%eax
f011fead:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011feb0:	88 10                	mov    %dl,(%eax)
f011feb2:	eb 56                	jmp    f011ff0a <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011feb4:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011feb8:	75 1f                	jne    f011fed9 <readline+0xc5>
f011feba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011febe:	7e 19                	jle    f011fed9 <readline+0xc5>
			if (echoing)
f011fec0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fec4:	74 0e                	je     f011fed4 <readline+0xc0>
				cputchar(c);
f011fec6:	83 ec 0c             	sub    $0xc,%esp
f011fec9:	ff 75 ec             	pushl  -0x14(%ebp)
f011fecc:	e8 97 0f fe ff       	call   f0100e68 <cputchar>
f011fed1:	83 c4 10             	add    $0x10,%esp

			i--;
f011fed4:	ff 4d f4             	decl   -0xc(%ebp)
f011fed7:	eb 31                	jmp    f011ff0a <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011fed9:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fedd:	74 0a                	je     f011fee9 <readline+0xd5>
f011fedf:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fee3:	0f 85 61 ff ff ff    	jne    f011fe4a <readline+0x36>
			if (echoing)
f011fee9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011feed:	74 0e                	je     f011fefd <readline+0xe9>
				cputchar(c);
f011feef:	83 ec 0c             	sub    $0xc,%esp
f011fef2:	ff 75 ec             	pushl  -0x14(%ebp)
f011fef5:	e8 6e 0f fe ff       	call   f0100e68 <cputchar>
f011fefa:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011fefd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ff00:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff03:	01 d0                	add    %edx,%eax
f011ff05:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011ff08:	eb 06                	jmp    f011ff10 <readline+0xfc>
		}
	}
f011ff0a:	e9 3b ff ff ff       	jmp    f011fe4a <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011ff0f:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011ff10:	90                   	nop
f011ff11:	c9                   	leave  
f011ff12:	c3                   	ret    

f011ff13 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011ff13:	55                   	push   %ebp
f011ff14:	89 e5                	mov    %esp,%ebp
f011ff16:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011ff19:	e8 99 eb fe ff       	call   f010eab7 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011ff1e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ff22:	74 13                	je     f011ff37 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011ff24:	83 ec 08             	sub    $0x8,%esp
f011ff27:	ff 75 08             	pushl  0x8(%ebp)
f011ff2a:	68 48 1a 13 f0       	push   $0xf0131a48
f011ff2f:	e8 57 10 fe ff       	call   f0100f8b <cprintf>
f011ff34:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011ff37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011ff3e:	83 ec 0c             	sub    $0xc,%esp
f011ff41:	6a 00                	push   $0x0
f011ff43:	e8 50 0f fe ff       	call   f0100e98 <iscons>
f011ff48:	83 c4 10             	add    $0x10,%esp
f011ff4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011ff4e:	e8 2c 0f fe ff       	call   f0100e7f <getchar>
f011ff53:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011ff56:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ff5a:	79 22                	jns    f011ff7e <atomic_readline+0x6b>
				if (c != -E_EOF)
f011ff5c:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011ff60:	0f 84 ad 00 00 00    	je     f0120013 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011ff66:	83 ec 08             	sub    $0x8,%esp
f011ff69:	ff 75 ec             	pushl  -0x14(%ebp)
f011ff6c:	68 4b 1a 13 f0       	push   $0xf0131a4b
f011ff71:	e8 15 10 fe ff       	call   f0100f8b <cprintf>
f011ff76:	83 c4 10             	add    $0x10,%esp
				break;
f011ff79:	e9 95 00 00 00       	jmp    f0120013 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011ff7e:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011ff82:	7e 34                	jle    f011ffb8 <atomic_readline+0xa5>
f011ff84:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011ff8b:	7f 2b                	jg     f011ffb8 <atomic_readline+0xa5>
				if (echoing)
f011ff8d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ff91:	74 0e                	je     f011ffa1 <atomic_readline+0x8e>
					cputchar(c);
f011ff93:	83 ec 0c             	sub    $0xc,%esp
f011ff96:	ff 75 ec             	pushl  -0x14(%ebp)
f011ff99:	e8 ca 0e fe ff       	call   f0100e68 <cputchar>
f011ff9e:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011ffa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ffa4:	8d 50 01             	lea    0x1(%eax),%edx
f011ffa7:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011ffaa:	89 c2                	mov    %eax,%edx
f011ffac:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ffaf:	01 d0                	add    %edx,%eax
f011ffb1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ffb4:	88 10                	mov    %dl,(%eax)
f011ffb6:	eb 56                	jmp    f012000e <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011ffb8:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011ffbc:	75 1f                	jne    f011ffdd <atomic_readline+0xca>
f011ffbe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ffc2:	7e 19                	jle    f011ffdd <atomic_readline+0xca>
				if (echoing)
f011ffc4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ffc8:	74 0e                	je     f011ffd8 <atomic_readline+0xc5>
					cputchar(c);
f011ffca:	83 ec 0c             	sub    $0xc,%esp
f011ffcd:	ff 75 ec             	pushl  -0x14(%ebp)
f011ffd0:	e8 93 0e fe ff       	call   f0100e68 <cputchar>
f011ffd5:	83 c4 10             	add    $0x10,%esp
				i--;
f011ffd8:	ff 4d f4             	decl   -0xc(%ebp)
f011ffdb:	eb 31                	jmp    f012000e <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011ffdd:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011ffe1:	74 0a                	je     f011ffed <atomic_readline+0xda>
f011ffe3:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011ffe7:	0f 85 61 ff ff ff    	jne    f011ff4e <atomic_readline+0x3b>
				if (echoing)
f011ffed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fff1:	74 0e                	je     f0120001 <atomic_readline+0xee>
					cputchar(c);
f011fff3:	83 ec 0c             	sub    $0xc,%esp
f011fff6:	ff 75 ec             	pushl  -0x14(%ebp)
f011fff9:	e8 6a 0e fe ff       	call   f0100e68 <cputchar>
f011fffe:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f0120001:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120004:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120007:	01 d0                	add    %edx,%eax
f0120009:	c6 00 00             	movb   $0x0,(%eax)
				break;
f012000c:	eb 06                	jmp    f0120014 <atomic_readline+0x101>
			}
		}
f012000e:	e9 3b ff ff ff       	jmp    f011ff4e <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f0120013:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f0120014:	e8 ac ea fe ff       	call   f010eac5 <sys_unlock_cons>
}
f0120019:	90                   	nop
f012001a:	c9                   	leave  
f012001b:	c3                   	ret    

f012001c <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f012001c:	55                   	push   %ebp
f012001d:	89 e5                	mov    %esp,%ebp
f012001f:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f0120022:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120029:	eb 06                	jmp    f0120031 <strlen+0x15>
		n++;
f012002b:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f012002e:	ff 45 08             	incl   0x8(%ebp)
f0120031:	8b 45 08             	mov    0x8(%ebp),%eax
f0120034:	8a 00                	mov    (%eax),%al
f0120036:	84 c0                	test   %al,%al
f0120038:	75 f1                	jne    f012002b <strlen+0xf>
		n++;
	return n;
f012003a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f012003d:	c9                   	leave  
f012003e:	c3                   	ret    

f012003f <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f012003f:	55                   	push   %ebp
f0120040:	89 e5                	mov    %esp,%ebp
f0120042:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0120045:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f012004c:	eb 09                	jmp    f0120057 <strnlen+0x18>
		n++;
f012004e:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0120051:	ff 45 08             	incl   0x8(%ebp)
f0120054:	ff 4d 0c             	decl   0xc(%ebp)
f0120057:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012005b:	74 09                	je     f0120066 <strnlen+0x27>
f012005d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120060:	8a 00                	mov    (%eax),%al
f0120062:	84 c0                	test   %al,%al
f0120064:	75 e8                	jne    f012004e <strnlen+0xf>
		n++;
	return n;
f0120066:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120069:	c9                   	leave  
f012006a:	c3                   	ret    

f012006b <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f012006b:	55                   	push   %ebp
f012006c:	89 e5                	mov    %esp,%ebp
f012006e:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f0120071:	8b 45 08             	mov    0x8(%ebp),%eax
f0120074:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f0120077:	90                   	nop
f0120078:	8b 45 08             	mov    0x8(%ebp),%eax
f012007b:	8d 50 01             	lea    0x1(%eax),%edx
f012007e:	89 55 08             	mov    %edx,0x8(%ebp)
f0120081:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120084:	8d 4a 01             	lea    0x1(%edx),%ecx
f0120087:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f012008a:	8a 12                	mov    (%edx),%dl
f012008c:	88 10                	mov    %dl,(%eax)
f012008e:	8a 00                	mov    (%eax),%al
f0120090:	84 c0                	test   %al,%al
f0120092:	75 e4                	jne    f0120078 <strcpy+0xd>
		/* do nothing */;
	return ret;
f0120094:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120097:	c9                   	leave  
f0120098:	c3                   	ret    

f0120099 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f0120099:	55                   	push   %ebp
f012009a:	89 e5                	mov    %esp,%ebp
f012009c:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f012009f:	8b 45 08             	mov    0x8(%ebp),%eax
f01200a2:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f01200a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01200ac:	eb 1f                	jmp    f01200cd <strncpy+0x34>
		*dst++ = *src;
f01200ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01200b1:	8d 50 01             	lea    0x1(%eax),%edx
f01200b4:	89 55 08             	mov    %edx,0x8(%ebp)
f01200b7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01200ba:	8a 12                	mov    (%edx),%dl
f01200bc:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f01200be:	8b 45 0c             	mov    0xc(%ebp),%eax
f01200c1:	8a 00                	mov    (%eax),%al
f01200c3:	84 c0                	test   %al,%al
f01200c5:	74 03                	je     f01200ca <strncpy+0x31>
			src++;
f01200c7:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f01200ca:	ff 45 fc             	incl   -0x4(%ebp)
f01200cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01200d0:	3b 45 10             	cmp    0x10(%ebp),%eax
f01200d3:	72 d9                	jb     f01200ae <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f01200d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01200d8:	c9                   	leave  
f01200d9:	c3                   	ret    

f01200da <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f01200da:	55                   	push   %ebp
f01200db:	89 e5                	mov    %esp,%ebp
f01200dd:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f01200e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01200e3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f01200e6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01200ea:	74 30                	je     f012011c <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f01200ec:	eb 16                	jmp    f0120104 <strlcpy+0x2a>
			*dst++ = *src++;
f01200ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01200f1:	8d 50 01             	lea    0x1(%eax),%edx
f01200f4:	89 55 08             	mov    %edx,0x8(%ebp)
f01200f7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01200fa:	8d 4a 01             	lea    0x1(%edx),%ecx
f01200fd:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0120100:	8a 12                	mov    (%edx),%dl
f0120102:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f0120104:	ff 4d 10             	decl   0x10(%ebp)
f0120107:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012010b:	74 09                	je     f0120116 <strlcpy+0x3c>
f012010d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120110:	8a 00                	mov    (%eax),%al
f0120112:	84 c0                	test   %al,%al
f0120114:	75 d8                	jne    f01200ee <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f0120116:	8b 45 08             	mov    0x8(%ebp),%eax
f0120119:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f012011c:	8b 55 08             	mov    0x8(%ebp),%edx
f012011f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120122:	29 c2                	sub    %eax,%edx
f0120124:	89 d0                	mov    %edx,%eax
}
f0120126:	c9                   	leave  
f0120127:	c3                   	ret    

f0120128 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f0120128:	55                   	push   %ebp
f0120129:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f012012b:	eb 06                	jmp    f0120133 <strcmp+0xb>
		p++, q++;
f012012d:	ff 45 08             	incl   0x8(%ebp)
f0120130:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f0120133:	8b 45 08             	mov    0x8(%ebp),%eax
f0120136:	8a 00                	mov    (%eax),%al
f0120138:	84 c0                	test   %al,%al
f012013a:	74 0e                	je     f012014a <strcmp+0x22>
f012013c:	8b 45 08             	mov    0x8(%ebp),%eax
f012013f:	8a 10                	mov    (%eax),%dl
f0120141:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120144:	8a 00                	mov    (%eax),%al
f0120146:	38 c2                	cmp    %al,%dl
f0120148:	74 e3                	je     f012012d <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f012014a:	8b 45 08             	mov    0x8(%ebp),%eax
f012014d:	8a 00                	mov    (%eax),%al
f012014f:	0f b6 d0             	movzbl %al,%edx
f0120152:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120155:	8a 00                	mov    (%eax),%al
f0120157:	0f b6 c0             	movzbl %al,%eax
f012015a:	29 c2                	sub    %eax,%edx
f012015c:	89 d0                	mov    %edx,%eax
}
f012015e:	5d                   	pop    %ebp
f012015f:	c3                   	ret    

f0120160 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f0120160:	55                   	push   %ebp
f0120161:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f0120163:	eb 09                	jmp    f012016e <strncmp+0xe>
		n--, p++, q++;
f0120165:	ff 4d 10             	decl   0x10(%ebp)
f0120168:	ff 45 08             	incl   0x8(%ebp)
f012016b:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f012016e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120172:	74 17                	je     f012018b <strncmp+0x2b>
f0120174:	8b 45 08             	mov    0x8(%ebp),%eax
f0120177:	8a 00                	mov    (%eax),%al
f0120179:	84 c0                	test   %al,%al
f012017b:	74 0e                	je     f012018b <strncmp+0x2b>
f012017d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120180:	8a 10                	mov    (%eax),%dl
f0120182:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120185:	8a 00                	mov    (%eax),%al
f0120187:	38 c2                	cmp    %al,%dl
f0120189:	74 da                	je     f0120165 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f012018b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012018f:	75 07                	jne    f0120198 <strncmp+0x38>
		return 0;
f0120191:	b8 00 00 00 00       	mov    $0x0,%eax
f0120196:	eb 14                	jmp    f01201ac <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f0120198:	8b 45 08             	mov    0x8(%ebp),%eax
f012019b:	8a 00                	mov    (%eax),%al
f012019d:	0f b6 d0             	movzbl %al,%edx
f01201a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201a3:	8a 00                	mov    (%eax),%al
f01201a5:	0f b6 c0             	movzbl %al,%eax
f01201a8:	29 c2                	sub    %eax,%edx
f01201aa:	89 d0                	mov    %edx,%eax
}
f01201ac:	5d                   	pop    %ebp
f01201ad:	c3                   	ret    

f01201ae <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f01201ae:	55                   	push   %ebp
f01201af:	89 e5                	mov    %esp,%ebp
f01201b1:	83 ec 04             	sub    $0x4,%esp
f01201b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201b7:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01201ba:	eb 12                	jmp    f01201ce <strchr+0x20>
		if (*s == c)
f01201bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01201bf:	8a 00                	mov    (%eax),%al
f01201c1:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01201c4:	75 05                	jne    f01201cb <strchr+0x1d>
			return (char *) s;
f01201c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01201c9:	eb 11                	jmp    f01201dc <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f01201cb:	ff 45 08             	incl   0x8(%ebp)
f01201ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01201d1:	8a 00                	mov    (%eax),%al
f01201d3:	84 c0                	test   %al,%al
f01201d5:	75 e5                	jne    f01201bc <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f01201d7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01201dc:	c9                   	leave  
f01201dd:	c3                   	ret    

f01201de <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f01201de:	55                   	push   %ebp
f01201df:	89 e5                	mov    %esp,%ebp
f01201e1:	83 ec 04             	sub    $0x4,%esp
f01201e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201e7:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01201ea:	eb 0d                	jmp    f01201f9 <strfind+0x1b>
		if (*s == c)
f01201ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01201ef:	8a 00                	mov    (%eax),%al
f01201f1:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01201f4:	74 0e                	je     f0120204 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f01201f6:	ff 45 08             	incl   0x8(%ebp)
f01201f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01201fc:	8a 00                	mov    (%eax),%al
f01201fe:	84 c0                	test   %al,%al
f0120200:	75 ea                	jne    f01201ec <strfind+0xe>
f0120202:	eb 01                	jmp    f0120205 <strfind+0x27>
		if (*s == c)
			break;
f0120204:	90                   	nop
	return (char *) s;
f0120205:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120208:	c9                   	leave  
f0120209:	c3                   	ret    

f012020a <memset>:


void *
memset(void *v, int c, uint32 n)
{
f012020a:	55                   	push   %ebp
f012020b:	89 e5                	mov    %esp,%ebp
f012020d:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f0120210:	8b 45 08             	mov    0x8(%ebp),%eax
f0120213:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f0120216:	8b 45 10             	mov    0x10(%ebp),%eax
f0120219:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f012021c:	eb 0e                	jmp    f012022c <memset+0x22>
		*p++ = c;
f012021e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120221:	8d 50 01             	lea    0x1(%eax),%edx
f0120224:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0120227:	8b 55 0c             	mov    0xc(%ebp),%edx
f012022a:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f012022c:	ff 4d f8             	decl   -0x8(%ebp)
f012022f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f0120233:	79 e9                	jns    f012021e <memset+0x14>
		*p++ = c;

	return v;
f0120235:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120238:	c9                   	leave  
f0120239:	c3                   	ret    

f012023a <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f012023a:	55                   	push   %ebp
f012023b:	89 e5                	mov    %esp,%ebp
f012023d:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f0120240:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120243:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0120246:	8b 45 08             	mov    0x8(%ebp),%eax
f0120249:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f012024c:	eb 16                	jmp    f0120264 <memcpy+0x2a>
		*d++ = *s++;
f012024e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120251:	8d 50 01             	lea    0x1(%eax),%edx
f0120254:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120257:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012025a:	8d 4a 01             	lea    0x1(%edx),%ecx
f012025d:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0120260:	8a 12                	mov    (%edx),%dl
f0120262:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f0120264:	8b 45 10             	mov    0x10(%ebp),%eax
f0120267:	8d 50 ff             	lea    -0x1(%eax),%edx
f012026a:	89 55 10             	mov    %edx,0x10(%ebp)
f012026d:	85 c0                	test   %eax,%eax
f012026f:	75 dd                	jne    f012024e <memcpy+0x14>
		*d++ = *s++;

	return dst;
f0120271:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120274:	c9                   	leave  
f0120275:	c3                   	ret    

f0120276 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f0120276:	55                   	push   %ebp
f0120277:	89 e5                	mov    %esp,%ebp
f0120279:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f012027c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012027f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0120282:	8b 45 08             	mov    0x8(%ebp),%eax
f0120285:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f0120288:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012028b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012028e:	73 50                	jae    f01202e0 <memmove+0x6a>
f0120290:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120293:	8b 45 10             	mov    0x10(%ebp),%eax
f0120296:	01 d0                	add    %edx,%eax
f0120298:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012029b:	76 43                	jbe    f01202e0 <memmove+0x6a>
		s += n;
f012029d:	8b 45 10             	mov    0x10(%ebp),%eax
f01202a0:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f01202a3:	8b 45 10             	mov    0x10(%ebp),%eax
f01202a6:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f01202a9:	eb 10                	jmp    f01202bb <memmove+0x45>
			*--d = *--s;
f01202ab:	ff 4d f8             	decl   -0x8(%ebp)
f01202ae:	ff 4d fc             	decl   -0x4(%ebp)
f01202b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01202b4:	8a 10                	mov    (%eax),%dl
f01202b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01202b9:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f01202bb:	8b 45 10             	mov    0x10(%ebp),%eax
f01202be:	8d 50 ff             	lea    -0x1(%eax),%edx
f01202c1:	89 55 10             	mov    %edx,0x10(%ebp)
f01202c4:	85 c0                	test   %eax,%eax
f01202c6:	75 e3                	jne    f01202ab <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f01202c8:	eb 23                	jmp    f01202ed <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f01202ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01202cd:	8d 50 01             	lea    0x1(%eax),%edx
f01202d0:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01202d3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01202d6:	8d 4a 01             	lea    0x1(%edx),%ecx
f01202d9:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f01202dc:	8a 12                	mov    (%edx),%dl
f01202de:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f01202e0:	8b 45 10             	mov    0x10(%ebp),%eax
f01202e3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01202e6:	89 55 10             	mov    %edx,0x10(%ebp)
f01202e9:	85 c0                	test   %eax,%eax
f01202eb:	75 dd                	jne    f01202ca <memmove+0x54>
			*d++ = *s++;

	return dst;
f01202ed:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01202f0:	c9                   	leave  
f01202f1:	c3                   	ret    

f01202f2 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f01202f2:	55                   	push   %ebp
f01202f3:	89 e5                	mov    %esp,%ebp
f01202f5:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f01202f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01202fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f01202fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120301:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f0120304:	eb 2a                	jmp    f0120330 <memcmp+0x3e>
		if (*s1 != *s2)
f0120306:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120309:	8a 10                	mov    (%eax),%dl
f012030b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012030e:	8a 00                	mov    (%eax),%al
f0120310:	38 c2                	cmp    %al,%dl
f0120312:	74 16                	je     f012032a <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f0120314:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120317:	8a 00                	mov    (%eax),%al
f0120319:	0f b6 d0             	movzbl %al,%edx
f012031c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012031f:	8a 00                	mov    (%eax),%al
f0120321:	0f b6 c0             	movzbl %al,%eax
f0120324:	29 c2                	sub    %eax,%edx
f0120326:	89 d0                	mov    %edx,%eax
f0120328:	eb 18                	jmp    f0120342 <memcmp+0x50>
		s1++, s2++;
f012032a:	ff 45 fc             	incl   -0x4(%ebp)
f012032d:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f0120330:	8b 45 10             	mov    0x10(%ebp),%eax
f0120333:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120336:	89 55 10             	mov    %edx,0x10(%ebp)
f0120339:	85 c0                	test   %eax,%eax
f012033b:	75 c9                	jne    f0120306 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f012033d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120342:	c9                   	leave  
f0120343:	c3                   	ret    

f0120344 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f0120344:	55                   	push   %ebp
f0120345:	89 e5                	mov    %esp,%ebp
f0120347:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f012034a:	8b 55 08             	mov    0x8(%ebp),%edx
f012034d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120350:	01 d0                	add    %edx,%eax
f0120352:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f0120355:	eb 15                	jmp    f012036c <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f0120357:	8b 45 08             	mov    0x8(%ebp),%eax
f012035a:	8a 00                	mov    (%eax),%al
f012035c:	0f b6 d0             	movzbl %al,%edx
f012035f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120362:	0f b6 c0             	movzbl %al,%eax
f0120365:	39 c2                	cmp    %eax,%edx
f0120367:	74 0d                	je     f0120376 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f0120369:	ff 45 08             	incl   0x8(%ebp)
f012036c:	8b 45 08             	mov    0x8(%ebp),%eax
f012036f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0120372:	72 e3                	jb     f0120357 <memfind+0x13>
f0120374:	eb 01                	jmp    f0120377 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f0120376:	90                   	nop
	return (void *) s;
f0120377:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012037a:	c9                   	leave  
f012037b:	c3                   	ret    

f012037c <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f012037c:	55                   	push   %ebp
f012037d:	89 e5                	mov    %esp,%ebp
f012037f:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f0120382:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f0120389:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0120390:	eb 03                	jmp    f0120395 <strtol+0x19>
		s++;
f0120392:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f0120395:	8b 45 08             	mov    0x8(%ebp),%eax
f0120398:	8a 00                	mov    (%eax),%al
f012039a:	3c 20                	cmp    $0x20,%al
f012039c:	74 f4                	je     f0120392 <strtol+0x16>
f012039e:	8b 45 08             	mov    0x8(%ebp),%eax
f01203a1:	8a 00                	mov    (%eax),%al
f01203a3:	3c 09                	cmp    $0x9,%al
f01203a5:	74 eb                	je     f0120392 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f01203a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01203aa:	8a 00                	mov    (%eax),%al
f01203ac:	3c 2b                	cmp    $0x2b,%al
f01203ae:	75 05                	jne    f01203b5 <strtol+0x39>
		s++;
f01203b0:	ff 45 08             	incl   0x8(%ebp)
f01203b3:	eb 13                	jmp    f01203c8 <strtol+0x4c>
	else if (*s == '-')
f01203b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01203b8:	8a 00                	mov    (%eax),%al
f01203ba:	3c 2d                	cmp    $0x2d,%al
f01203bc:	75 0a                	jne    f01203c8 <strtol+0x4c>
		s++, neg = 1;
f01203be:	ff 45 08             	incl   0x8(%ebp)
f01203c1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f01203c8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01203cc:	74 06                	je     f01203d4 <strtol+0x58>
f01203ce:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f01203d2:	75 20                	jne    f01203f4 <strtol+0x78>
f01203d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01203d7:	8a 00                	mov    (%eax),%al
f01203d9:	3c 30                	cmp    $0x30,%al
f01203db:	75 17                	jne    f01203f4 <strtol+0x78>
f01203dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01203e0:	40                   	inc    %eax
f01203e1:	8a 00                	mov    (%eax),%al
f01203e3:	3c 78                	cmp    $0x78,%al
f01203e5:	75 0d                	jne    f01203f4 <strtol+0x78>
		s += 2, base = 16;
f01203e7:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f01203eb:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f01203f2:	eb 28                	jmp    f012041c <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f01203f4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01203f8:	75 15                	jne    f012040f <strtol+0x93>
f01203fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01203fd:	8a 00                	mov    (%eax),%al
f01203ff:	3c 30                	cmp    $0x30,%al
f0120401:	75 0c                	jne    f012040f <strtol+0x93>
		s++, base = 8;
f0120403:	ff 45 08             	incl   0x8(%ebp)
f0120406:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f012040d:	eb 0d                	jmp    f012041c <strtol+0xa0>
	else if (base == 0)
f012040f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120413:	75 07                	jne    f012041c <strtol+0xa0>
		base = 10;
f0120415:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f012041c:	8b 45 08             	mov    0x8(%ebp),%eax
f012041f:	8a 00                	mov    (%eax),%al
f0120421:	3c 2f                	cmp    $0x2f,%al
f0120423:	7e 19                	jle    f012043e <strtol+0xc2>
f0120425:	8b 45 08             	mov    0x8(%ebp),%eax
f0120428:	8a 00                	mov    (%eax),%al
f012042a:	3c 39                	cmp    $0x39,%al
f012042c:	7f 10                	jg     f012043e <strtol+0xc2>
			dig = *s - '0';
f012042e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120431:	8a 00                	mov    (%eax),%al
f0120433:	0f be c0             	movsbl %al,%eax
f0120436:	83 e8 30             	sub    $0x30,%eax
f0120439:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012043c:	eb 42                	jmp    f0120480 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f012043e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120441:	8a 00                	mov    (%eax),%al
f0120443:	3c 60                	cmp    $0x60,%al
f0120445:	7e 19                	jle    f0120460 <strtol+0xe4>
f0120447:	8b 45 08             	mov    0x8(%ebp),%eax
f012044a:	8a 00                	mov    (%eax),%al
f012044c:	3c 7a                	cmp    $0x7a,%al
f012044e:	7f 10                	jg     f0120460 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0120450:	8b 45 08             	mov    0x8(%ebp),%eax
f0120453:	8a 00                	mov    (%eax),%al
f0120455:	0f be c0             	movsbl %al,%eax
f0120458:	83 e8 57             	sub    $0x57,%eax
f012045b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012045e:	eb 20                	jmp    f0120480 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f0120460:	8b 45 08             	mov    0x8(%ebp),%eax
f0120463:	8a 00                	mov    (%eax),%al
f0120465:	3c 40                	cmp    $0x40,%al
f0120467:	7e 39                	jle    f01204a2 <strtol+0x126>
f0120469:	8b 45 08             	mov    0x8(%ebp),%eax
f012046c:	8a 00                	mov    (%eax),%al
f012046e:	3c 5a                	cmp    $0x5a,%al
f0120470:	7f 30                	jg     f01204a2 <strtol+0x126>
			dig = *s - 'A' + 10;
f0120472:	8b 45 08             	mov    0x8(%ebp),%eax
f0120475:	8a 00                	mov    (%eax),%al
f0120477:	0f be c0             	movsbl %al,%eax
f012047a:	83 e8 37             	sub    $0x37,%eax
f012047d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f0120480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120483:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120486:	7d 19                	jge    f01204a1 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f0120488:	ff 45 08             	incl   0x8(%ebp)
f012048b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012048e:	0f af 45 10          	imul   0x10(%ebp),%eax
f0120492:	89 c2                	mov    %eax,%edx
f0120494:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120497:	01 d0                	add    %edx,%eax
f0120499:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f012049c:	e9 7b ff ff ff       	jmp    f012041c <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f01204a1:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f01204a2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01204a6:	74 08                	je     f01204b0 <strtol+0x134>
		*endptr = (char *) s;
f01204a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204ab:	8b 55 08             	mov    0x8(%ebp),%edx
f01204ae:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f01204b0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01204b4:	74 07                	je     f01204bd <strtol+0x141>
f01204b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01204b9:	f7 d8                	neg    %eax
f01204bb:	eb 03                	jmp    f01204c0 <strtol+0x144>
f01204bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01204c0:	c9                   	leave  
f01204c1:	c3                   	ret    

f01204c2 <ltostr>:

void
ltostr(long value, char *str)
{
f01204c2:	55                   	push   %ebp
f01204c3:	89 e5                	mov    %esp,%ebp
f01204c5:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f01204c8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f01204cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f01204d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01204da:	79 13                	jns    f01204ef <ltostr+0x2d>
	{
		neg = 1;
f01204dc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f01204e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204e6:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f01204e9:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f01204ec:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f01204ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01204f2:	b9 0a 00 00 00       	mov    $0xa,%ecx
f01204f7:	99                   	cltd   
f01204f8:	f7 f9                	idiv   %ecx
f01204fa:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f01204fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120500:	8d 50 01             	lea    0x1(%eax),%edx
f0120503:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120506:	89 c2                	mov    %eax,%edx
f0120508:	8b 45 0c             	mov    0xc(%ebp),%eax
f012050b:	01 d0                	add    %edx,%eax
f012050d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120510:	83 c2 30             	add    $0x30,%edx
f0120513:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f0120515:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0120518:	b8 67 66 66 66       	mov    $0x66666667,%eax
f012051d:	f7 e9                	imul   %ecx
f012051f:	c1 fa 02             	sar    $0x2,%edx
f0120522:	89 c8                	mov    %ecx,%eax
f0120524:	c1 f8 1f             	sar    $0x1f,%eax
f0120527:	29 c2                	sub    %eax,%edx
f0120529:	89 d0                	mov    %edx,%eax
f012052b:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f012052e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120532:	75 bb                	jne    f01204ef <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f0120534:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f012053b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012053e:	48                   	dec    %eax
f012053f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0120542:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0120546:	74 3d                	je     f0120585 <ltostr+0xc3>
		start = 1 ;
f0120548:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f012054f:	eb 34                	jmp    f0120585 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0120551:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120554:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120557:	01 d0                	add    %edx,%eax
f0120559:	8a 00                	mov    (%eax),%al
f012055b:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f012055e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120561:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120564:	01 c2                	add    %eax,%edx
f0120566:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0120569:	8b 45 0c             	mov    0xc(%ebp),%eax
f012056c:	01 c8                	add    %ecx,%eax
f012056e:	8a 00                	mov    (%eax),%al
f0120570:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0120572:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120575:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120578:	01 c2                	add    %eax,%edx
f012057a:	8a 45 eb             	mov    -0x15(%ebp),%al
f012057d:	88 02                	mov    %al,(%edx)
		start++ ;
f012057f:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0120582:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0120585:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120588:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f012058b:	7c c4                	jl     f0120551 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f012058d:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0120590:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120593:	01 d0                	add    %edx,%eax
f0120595:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0120598:	90                   	nop
f0120599:	c9                   	leave  
f012059a:	c3                   	ret    

f012059b <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f012059b:	55                   	push   %ebp
f012059c:	89 e5                	mov    %esp,%ebp
f012059e:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f01205a1:	ff 75 08             	pushl  0x8(%ebp)
f01205a4:	e8 73 fa ff ff       	call   f012001c <strlen>
f01205a9:	83 c4 04             	add    $0x4,%esp
f01205ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f01205af:	ff 75 0c             	pushl  0xc(%ebp)
f01205b2:	e8 65 fa ff ff       	call   f012001c <strlen>
f01205b7:	83 c4 04             	add    $0x4,%esp
f01205ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f01205bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f01205c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01205cb:	eb 17                	jmp    f01205e4 <strcconcat+0x49>
		final[s] = str1[s] ;
f01205cd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01205d0:	8b 45 10             	mov    0x10(%ebp),%eax
f01205d3:	01 c2                	add    %eax,%edx
f01205d5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f01205d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01205db:	01 c8                	add    %ecx,%eax
f01205dd:	8a 00                	mov    (%eax),%al
f01205df:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f01205e1:	ff 45 fc             	incl   -0x4(%ebp)
f01205e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01205e7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01205ea:	7c e1                	jl     f01205cd <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f01205ec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f01205f3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f01205fa:	eb 1f                	jmp    f012061b <strcconcat+0x80>
		final[s++] = str2[i] ;
f01205fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01205ff:	8d 50 01             	lea    0x1(%eax),%edx
f0120602:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0120605:	89 c2                	mov    %eax,%edx
f0120607:	8b 45 10             	mov    0x10(%ebp),%eax
f012060a:	01 c2                	add    %eax,%edx
f012060c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f012060f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120612:	01 c8                	add    %ecx,%eax
f0120614:	8a 00                	mov    (%eax),%al
f0120616:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f0120618:	ff 45 f8             	incl   -0x8(%ebp)
f012061b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012061e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120621:	7c d9                	jl     f01205fc <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0120623:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120626:	8b 45 10             	mov    0x10(%ebp),%eax
f0120629:	01 d0                	add    %edx,%eax
f012062b:	c6 00 00             	movb   $0x0,(%eax)
}
f012062e:	90                   	nop
f012062f:	c9                   	leave  
f0120630:	c3                   	ret    

f0120631 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0120631:	55                   	push   %ebp
f0120632:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f0120634:	8b 45 14             	mov    0x14(%ebp),%eax
f0120637:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f012063d:	8b 45 14             	mov    0x14(%ebp),%eax
f0120640:	8b 00                	mov    (%eax),%eax
f0120642:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120649:	8b 45 10             	mov    0x10(%ebp),%eax
f012064c:	01 d0                	add    %edx,%eax
f012064e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120654:	eb 0c                	jmp    f0120662 <strsplit+0x31>
			*string++ = 0;
f0120656:	8b 45 08             	mov    0x8(%ebp),%eax
f0120659:	8d 50 01             	lea    0x1(%eax),%edx
f012065c:	89 55 08             	mov    %edx,0x8(%ebp)
f012065f:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120662:	8b 45 08             	mov    0x8(%ebp),%eax
f0120665:	8a 00                	mov    (%eax),%al
f0120667:	84 c0                	test   %al,%al
f0120669:	74 18                	je     f0120683 <strsplit+0x52>
f012066b:	8b 45 08             	mov    0x8(%ebp),%eax
f012066e:	8a 00                	mov    (%eax),%al
f0120670:	0f be c0             	movsbl %al,%eax
f0120673:	50                   	push   %eax
f0120674:	ff 75 0c             	pushl  0xc(%ebp)
f0120677:	e8 32 fb ff ff       	call   f01201ae <strchr>
f012067c:	83 c4 08             	add    $0x8,%esp
f012067f:	85 c0                	test   %eax,%eax
f0120681:	75 d3                	jne    f0120656 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0120683:	8b 45 08             	mov    0x8(%ebp),%eax
f0120686:	8a 00                	mov    (%eax),%al
f0120688:	84 c0                	test   %al,%al
f012068a:	74 5a                	je     f01206e6 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f012068c:	8b 45 14             	mov    0x14(%ebp),%eax
f012068f:	8b 00                	mov    (%eax),%eax
f0120691:	83 f8 0f             	cmp    $0xf,%eax
f0120694:	75 07                	jne    f012069d <strsplit+0x6c>
		{
			return 0;
f0120696:	b8 00 00 00 00       	mov    $0x0,%eax
f012069b:	eb 66                	jmp    f0120703 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f012069d:	8b 45 14             	mov    0x14(%ebp),%eax
f01206a0:	8b 00                	mov    (%eax),%eax
f01206a2:	8d 48 01             	lea    0x1(%eax),%ecx
f01206a5:	8b 55 14             	mov    0x14(%ebp),%edx
f01206a8:	89 0a                	mov    %ecx,(%edx)
f01206aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01206b1:	8b 45 10             	mov    0x10(%ebp),%eax
f01206b4:	01 c2                	add    %eax,%edx
f01206b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01206b9:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f01206bb:	eb 03                	jmp    f01206c0 <strsplit+0x8f>
			string++;
f01206bd:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f01206c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01206c3:	8a 00                	mov    (%eax),%al
f01206c5:	84 c0                	test   %al,%al
f01206c7:	74 8b                	je     f0120654 <strsplit+0x23>
f01206c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01206cc:	8a 00                	mov    (%eax),%al
f01206ce:	0f be c0             	movsbl %al,%eax
f01206d1:	50                   	push   %eax
f01206d2:	ff 75 0c             	pushl  0xc(%ebp)
f01206d5:	e8 d4 fa ff ff       	call   f01201ae <strchr>
f01206da:	83 c4 08             	add    $0x8,%esp
f01206dd:	85 c0                	test   %eax,%eax
f01206df:	74 dc                	je     f01206bd <strsplit+0x8c>
			string++;
	}
f01206e1:	e9 6e ff ff ff       	jmp    f0120654 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f01206e6:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f01206e7:	8b 45 14             	mov    0x14(%ebp),%eax
f01206ea:	8b 00                	mov    (%eax),%eax
f01206ec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01206f3:	8b 45 10             	mov    0x10(%ebp),%eax
f01206f6:	01 d0                	add    %edx,%eax
f01206f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f01206fe:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0120703:	c9                   	leave  
f0120704:	c3                   	ret    

f0120705 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0120705:	55                   	push   %ebp
f0120706:	89 e5                	mov    %esp,%ebp
f0120708:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f012070b:	83 ec 04             	sub    $0x4,%esp
f012070e:	68 5c 1a 13 f0       	push   $0xf0131a5c
f0120713:	68 3f 01 00 00       	push   $0x13f
f0120718:	68 7e 1a 13 f0       	push   $0xf0131a7e
f012071d:	e8 17 fc fd ff       	call   f0100339 <_panic>

f0120722 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0120722:	55                   	push   %ebp
f0120723:	89 e5                	mov    %esp,%ebp
f0120725:	83 ec 18             	sub    $0x18,%esp
f0120728:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f012072f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120732:	89 c2                	mov    %eax,%edx
f0120734:	ec                   	in     (%dx),%al
f0120735:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120738:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f012073b:	0f b6 c0             	movzbl %al,%eax
f012073e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120741:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120744:	25 c0 00 00 00       	and    $0xc0,%eax
f0120749:	83 f8 40             	cmp    $0x40,%eax
f012074c:	75 10                	jne    f012075e <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f012074e:	83 ec 0c             	sub    $0xc,%esp
f0120751:	68 20 d1 75 f0       	push   $0xf075d120
f0120756:	e8 6d fd fe ff       	call   f01104c8 <wakeup_one>
f012075b:	83 c4 10             	add    $0x10,%esp
	}

}
f012075e:	90                   	nop
f012075f:	c9                   	leave  
f0120760:	c3                   	ret    

f0120761 <ide_init>:

void ide_init()
{
f0120761:	55                   	push   %ebp
f0120762:	89 e5                	mov    %esp,%ebp
f0120764:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0120767:	83 ec 08             	sub    $0x8,%esp
f012076a:	68 22 07 12 f0       	push   $0xf0120722
f012076f:	6a 0e                	push   $0xe
f0120771:	e8 48 de fe ff       	call   f010e5be <irq_install_handler>
f0120776:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0120779:	83 ec 08             	sub    $0x8,%esp
f012077c:	68 8c 1a 13 f0       	push   $0xf0131a8c
f0120781:	68 20 d1 75 f0       	push   $0xf075d120
f0120786:	e8 a3 fc fe ff       	call   f011042e <init_channel>
f012078b:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f012078e:	83 ec 08             	sub    $0x8,%esp
f0120791:	68 99 1a 13 f0       	push   $0xf0131a99
f0120796:	68 40 d7 b5 f0       	push   $0xf0b5d740
f012079b:	e8 9d f8 fe ff       	call   f011003d <init_spinlock>
f01207a0:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f01207a3:	90                   	nop
f01207a4:	c9                   	leave  
f01207a5:	c3                   	ret    

f01207a6 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f01207a6:	55                   	push   %ebp
f01207a7:	89 e5                	mov    %esp,%ebp
f01207a9:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01207ac:	90                   	nop
f01207ad:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01207b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01207b7:	89 c2                	mov    %eax,%edx
f01207b9:	ec                   	in     (%dx),%al
f01207ba:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f01207bd:	8a 45 ef             	mov    -0x11(%ebp),%al
f01207c0:	0f b6 c0             	movzbl %al,%eax
f01207c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01207c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01207c9:	25 c0 00 00 00       	and    $0xc0,%eax
f01207ce:	83 f8 40             	cmp    $0x40,%eax
f01207d1:	75 da                	jne    f01207ad <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f01207d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01207d7:	74 24                	je     f01207fd <ide_wait_ready+0x57>
f01207d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01207dc:	83 e0 21             	and    $0x21,%eax
f01207df:	85 c0                	test   %eax,%eax
f01207e1:	74 1a                	je     f01207fd <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f01207e3:	83 ec 0c             	sub    $0xc,%esp
f01207e6:	ff 75 f4             	pushl  -0xc(%ebp)
f01207e9:	ff 75 f4             	pushl  -0xc(%ebp)
f01207ec:	68 ac 1a 13 f0       	push   $0xf0131aac
f01207f1:	6a 5d                	push   $0x5d
f01207f3:	68 cf 1a 13 f0       	push   $0xf0131acf
f01207f8:	e8 3c fb fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f01207fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120802:	c9                   	leave  
f0120803:	c3                   	ret    

f0120804 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0120804:	55                   	push   %ebp
f0120805:	89 e5                	mov    %esp,%ebp
f0120807:	57                   	push   %edi
f0120808:	53                   	push   %ebx
f0120809:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f012080c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120813:	76 16                	jbe    f012082b <ide_read+0x27>
f0120815:	68 da 1a 13 f0       	push   $0xf0131ada
f012081a:	68 e7 1a 13 f0       	push   $0xf0131ae7
f012081f:	6a 68                	push   $0x68
f0120821:	68 cf 1a 13 f0       	push   $0xf0131acf
f0120826:	e8 0e fb fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f012082b:	83 ec 0c             	sub    $0xc,%esp
f012082e:	6a 00                	push   $0x0
f0120830:	e8 71 ff ff ff       	call   f01207a6 <ide_wait_ready>
f0120835:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f0120838:	8b 45 10             	mov    0x10(%ebp),%eax
f012083b:	0f b6 c0             	movzbl %al,%eax
f012083e:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120845:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120848:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012084b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012084e:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f012084f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120852:	0f b6 c0             	movzbl %al,%eax
f0120855:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f012085c:	88 45 d3             	mov    %al,-0x2d(%ebp)
f012085f:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120862:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120865:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120866:	8b 45 08             	mov    0x8(%ebp),%eax
f0120869:	c1 e8 08             	shr    $0x8,%eax
f012086c:	0f b6 c0             	movzbl %al,%eax
f012086f:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120876:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120879:	8a 45 d4             	mov    -0x2c(%ebp),%al
f012087c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012087f:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120880:	8b 45 08             	mov    0x8(%ebp),%eax
f0120883:	c1 e8 10             	shr    $0x10,%eax
f0120886:	0f b6 c0             	movzbl %al,%eax
f0120889:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120890:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120893:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120896:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120899:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f012089a:	a1 d0 cf 75 f0       	mov    0xf075cfd0,%eax
f012089f:	83 e0 01             	and    $0x1,%eax
f01208a2:	c1 e0 04             	shl    $0x4,%eax
f01208a5:	88 c2                	mov    %al,%dl
f01208a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01208aa:	c1 e8 18             	shr    $0x18,%eax
f01208ad:	83 e0 0f             	and    $0xf,%eax
f01208b0:	09 d0                	or     %edx,%eax
f01208b2:	83 c8 e0             	or     $0xffffffe0,%eax
f01208b5:	0f b6 c0             	movzbl %al,%eax
f01208b8:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f01208bf:	88 45 d6             	mov    %al,-0x2a(%ebp)
f01208c2:	8a 45 d6             	mov    -0x2a(%ebp),%al
f01208c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01208c8:	ee                   	out    %al,(%dx)
f01208c9:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f01208d0:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f01208d4:	8a 45 d7             	mov    -0x29(%ebp),%al
f01208d7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01208da:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01208db:	eb 55                	jmp    f0120932 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f01208dd:	83 ec 0c             	sub    $0xc,%esp
f01208e0:	6a 01                	push   $0x1
f01208e2:	e8 bf fe ff ff       	call   f01207a6 <ide_wait_ready>
f01208e7:	83 c4 10             	add    $0x10,%esp
f01208ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01208ed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01208f1:	79 05                	jns    f01208f8 <ide_read+0xf4>
			return r;
f01208f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01208f6:	eb 45                	jmp    f012093d <ide_read+0x139>
f01208f8:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01208ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120902:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120905:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f012090c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012090f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120912:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120915:	89 cb                	mov    %ecx,%ebx
f0120917:	89 df                	mov    %ebx,%edi
f0120919:	89 c1                	mov    %eax,%ecx
f012091b:	fc                   	cld    
f012091c:	f2 6d                	repnz insl (%dx),%es:(%edi)
f012091e:	89 c8                	mov    %ecx,%eax
f0120920:	89 fb                	mov    %edi,%ebx
f0120922:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120925:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120928:	ff 4d 10             	decl   0x10(%ebp)
f012092b:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120932:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120936:	75 a5                	jne    f01208dd <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f0120938:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012093d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120940:	5b                   	pop    %ebx
f0120941:	5f                   	pop    %edi
f0120942:	5d                   	pop    %ebp
f0120943:	c3                   	ret    

f0120944 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f0120944:	55                   	push   %ebp
f0120945:	89 e5                	mov    %esp,%ebp
f0120947:	56                   	push   %esi
f0120948:	53                   	push   %ebx
f0120949:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f012094c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120953:	76 19                	jbe    f012096e <ide_write+0x2a>
f0120955:	68 da 1a 13 f0       	push   $0xf0131ada
f012095a:	68 e7 1a 13 f0       	push   $0xf0131ae7
f012095f:	68 82 00 00 00       	push   $0x82
f0120964:	68 cf 1a 13 f0       	push   $0xf0131acf
f0120969:	e8 cb f9 fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f012096e:	83 ec 0c             	sub    $0xc,%esp
f0120971:	6a 00                	push   $0x0
f0120973:	e8 2e fe ff ff       	call   f01207a6 <ide_wait_ready>
f0120978:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f012097b:	8b 45 10             	mov    0x10(%ebp),%eax
f012097e:	0f b6 c0             	movzbl %al,%eax
f0120981:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120988:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f012098b:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012098e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120991:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120992:	8b 45 08             	mov    0x8(%ebp),%eax
f0120995:	0f b6 c0             	movzbl %al,%eax
f0120998:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f012099f:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01209a2:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01209a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01209a8:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f01209a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01209ac:	c1 e8 08             	shr    $0x8,%eax
f01209af:	0f b6 c0             	movzbl %al,%eax
f01209b2:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f01209b9:	88 45 d4             	mov    %al,-0x2c(%ebp)
f01209bc:	8a 45 d4             	mov    -0x2c(%ebp),%al
f01209bf:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01209c2:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f01209c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01209c6:	c1 e8 10             	shr    $0x10,%eax
f01209c9:	0f b6 c0             	movzbl %al,%eax
f01209cc:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f01209d3:	88 45 d5             	mov    %al,-0x2b(%ebp)
f01209d6:	8a 45 d5             	mov    -0x2b(%ebp),%al
f01209d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01209dc:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f01209dd:	a1 d0 cf 75 f0       	mov    0xf075cfd0,%eax
f01209e2:	83 e0 01             	and    $0x1,%eax
f01209e5:	c1 e0 04             	shl    $0x4,%eax
f01209e8:	88 c2                	mov    %al,%dl
f01209ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01209ed:	c1 e8 18             	shr    $0x18,%eax
f01209f0:	83 e0 0f             	and    $0xf,%eax
f01209f3:	09 d0                	or     %edx,%eax
f01209f5:	83 c8 e0             	or     $0xffffffe0,%eax
f01209f8:	0f b6 c0             	movzbl %al,%eax
f01209fb:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120a02:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120a05:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120a08:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120a0b:	ee                   	out    %al,(%dx)
f0120a0c:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120a13:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0120a17:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120a1a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120a1d:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120a1e:	eb 55                	jmp    f0120a75 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0120a20:	83 ec 0c             	sub    $0xc,%esp
f0120a23:	6a 01                	push   $0x1
f0120a25:	e8 7c fd ff ff       	call   f01207a6 <ide_wait_ready>
f0120a2a:	83 c4 10             	add    $0x10,%esp
f0120a2d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120a30:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120a34:	79 05                	jns    f0120a3b <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0120a36:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120a39:	eb 45                	jmp    f0120a80 <ide_write+0x13c>
f0120a3b:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120a42:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a45:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120a48:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0120a4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120a52:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120a55:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120a58:	89 cb                	mov    %ecx,%ebx
f0120a5a:	89 de                	mov    %ebx,%esi
f0120a5c:	89 c1                	mov    %eax,%ecx
f0120a5e:	fc                   	cld    
f0120a5f:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0120a61:	89 c8                	mov    %ecx,%eax
f0120a63:	89 f3                	mov    %esi,%ebx
f0120a65:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120a68:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120a6b:	ff 4d 10             	decl   0x10(%ebp)
f0120a6e:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120a75:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120a79:	75 a5                	jne    f0120a20 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0120a7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120a80:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120a83:	5b                   	pop    %ebx
f0120a84:	5e                   	pop    %esi
f0120a85:	5d                   	pop    %ebp
f0120a86:	c3                   	ret    

f0120a87 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120a87:	55                   	push   %ebp
f0120a88:	89 e5                	mov    %esp,%ebp
f0120a8a:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120a8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a90:	83 e8 04             	sub    $0x4,%eax
f0120a93:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120a96:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120a99:	8b 00                	mov    (%eax),%eax
f0120a9b:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0120a9e:	c9                   	leave  
f0120a9f:	c3                   	ret    

f0120aa0 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0120aa0:	55                   	push   %ebp
f0120aa1:	89 e5                	mov    %esp,%ebp
f0120aa3:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120aa6:	8b 45 08             	mov    0x8(%ebp),%eax
f0120aa9:	83 e8 04             	sub    $0x4,%eax
f0120aac:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0120aaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120ab2:	8b 00                	mov    (%eax),%eax
f0120ab4:	83 e0 01             	and    $0x1,%eax
f0120ab7:	85 c0                	test   %eax,%eax
f0120ab9:	0f 94 c0             	sete   %al
}
f0120abc:	c9                   	leave  
f0120abd:	c3                   	ret    

f0120abe <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0120abe:	55                   	push   %ebp
f0120abf:	89 e5                	mov    %esp,%ebp
f0120ac1:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f0120ac4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0120acb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120ace:	83 f8 02             	cmp    $0x2,%eax
f0120ad1:	74 2b                	je     f0120afe <alloc_block+0x40>
f0120ad3:	83 f8 02             	cmp    $0x2,%eax
f0120ad6:	7f 07                	jg     f0120adf <alloc_block+0x21>
f0120ad8:	83 f8 01             	cmp    $0x1,%eax
f0120adb:	74 0e                	je     f0120aeb <alloc_block+0x2d>
f0120add:	eb 58                	jmp    f0120b37 <alloc_block+0x79>
f0120adf:	83 f8 03             	cmp    $0x3,%eax
f0120ae2:	74 2d                	je     f0120b11 <alloc_block+0x53>
f0120ae4:	83 f8 04             	cmp    $0x4,%eax
f0120ae7:	74 3b                	je     f0120b24 <alloc_block+0x66>
f0120ae9:	eb 4c                	jmp    f0120b37 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0120aeb:	83 ec 0c             	sub    $0xc,%esp
f0120aee:	ff 75 08             	pushl  0x8(%ebp)
f0120af1:	e8 11 03 00 00       	call   f0120e07 <alloc_block_FF>
f0120af6:	83 c4 10             	add    $0x10,%esp
f0120af9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120afc:	eb 4a                	jmp    f0120b48 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f0120afe:	83 ec 0c             	sub    $0xc,%esp
f0120b01:	ff 75 08             	pushl  0x8(%ebp)
f0120b04:	e8 c7 19 00 00       	call   f01224d0 <alloc_block_NF>
f0120b09:	83 c4 10             	add    $0x10,%esp
f0120b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120b0f:	eb 37                	jmp    f0120b48 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0120b11:	83 ec 0c             	sub    $0xc,%esp
f0120b14:	ff 75 08             	pushl  0x8(%ebp)
f0120b17:	e8 a7 07 00 00       	call   f01212c3 <alloc_block_BF>
f0120b1c:	83 c4 10             	add    $0x10,%esp
f0120b1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120b22:	eb 24                	jmp    f0120b48 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f0120b24:	83 ec 0c             	sub    $0xc,%esp
f0120b27:	ff 75 08             	pushl  0x8(%ebp)
f0120b2a:	e8 84 19 00 00       	call   f01224b3 <alloc_block_WF>
f0120b2f:	83 c4 10             	add    $0x10,%esp
f0120b32:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0120b35:	eb 11                	jmp    f0120b48 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f0120b37:	83 ec 0c             	sub    $0xc,%esp
f0120b3a:	68 fc 1a 13 f0       	push   $0xf0131afc
f0120b3f:	e8 47 04 fe ff       	call   f0100f8b <cprintf>
f0120b44:	83 c4 10             	add    $0x10,%esp
		break;
f0120b47:	90                   	nop
	}
	return va;
f0120b48:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0120b4b:	c9                   	leave  
f0120b4c:	c3                   	ret    

f0120b4d <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0120b4d:	55                   	push   %ebp
f0120b4e:	89 e5                	mov    %esp,%ebp
f0120b50:	53                   	push   %ebx
f0120b51:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0120b54:	83 ec 0c             	sub    $0xc,%esp
f0120b57:	68 1c 1b 13 f0       	push   $0xf0131b1c
f0120b5c:	e8 2a 04 fe ff       	call   f0100f8b <cprintf>
f0120b61:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0120b64:	83 ec 0c             	sub    $0xc,%esp
f0120b67:	68 47 1b 13 f0       	push   $0xf0131b47
f0120b6c:	e8 1a 04 fe ff       	call   f0100f8b <cprintf>
f0120b71:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0120b74:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b77:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120b7a:	eb 37                	jmp    f0120bb3 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120b7c:	83 ec 0c             	sub    $0xc,%esp
f0120b7f:	ff 75 f4             	pushl  -0xc(%ebp)
f0120b82:	e8 19 ff ff ff       	call   f0120aa0 <is_free_block>
f0120b87:	83 c4 10             	add    $0x10,%esp
f0120b8a:	0f be d8             	movsbl %al,%ebx
f0120b8d:	83 ec 0c             	sub    $0xc,%esp
f0120b90:	ff 75 f4             	pushl  -0xc(%ebp)
f0120b93:	e8 ef fe ff ff       	call   f0120a87 <get_block_size>
f0120b98:	83 c4 10             	add    $0x10,%esp
f0120b9b:	83 ec 04             	sub    $0x4,%esp
f0120b9e:	53                   	push   %ebx
f0120b9f:	50                   	push   %eax
f0120ba0:	68 5f 1b 13 f0       	push   $0xf0131b5f
f0120ba5:	e8 e1 03 fe ff       	call   f0100f8b <cprintf>
f0120baa:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120bad:	8b 45 10             	mov    0x10(%ebp),%eax
f0120bb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120bb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120bb7:	74 07                	je     f0120bc0 <print_blocks_list+0x73>
f0120bb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bbc:	8b 00                	mov    (%eax),%eax
f0120bbe:	eb 05                	jmp    f0120bc5 <print_blocks_list+0x78>
f0120bc0:	b8 00 00 00 00       	mov    $0x0,%eax
f0120bc5:	89 45 10             	mov    %eax,0x10(%ebp)
f0120bc8:	8b 45 10             	mov    0x10(%ebp),%eax
f0120bcb:	85 c0                	test   %eax,%eax
f0120bcd:	75 ad                	jne    f0120b7c <print_blocks_list+0x2f>
f0120bcf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120bd3:	75 a7                	jne    f0120b7c <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f0120bd5:	83 ec 0c             	sub    $0xc,%esp
f0120bd8:	68 1c 1b 13 f0       	push   $0xf0131b1c
f0120bdd:	e8 a9 03 fe ff       	call   f0100f8b <cprintf>
f0120be2:	83 c4 10             	add    $0x10,%esp

}
f0120be5:	90                   	nop
f0120be6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0120be9:	c9                   	leave  
f0120bea:	c3                   	ret    

f0120beb <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0120beb:	55                   	push   %ebp
f0120bec:	89 e5                	mov    %esp,%ebp
f0120bee:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0120bf1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120bf4:	83 e0 01             	and    $0x1,%eax
f0120bf7:	85 c0                	test   %eax,%eax
f0120bf9:	74 03                	je     f0120bfe <initialize_dynamic_allocator+0x13>
f0120bfb:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f0120bfe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120c02:	0f 84 c7 01 00 00    	je     f0120dcf <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f0120c08:	c7 05 d4 cf 75 f0 01 	movl   $0x1,0xf075cfd4
f0120c0f:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f0120c12:	8b 55 08             	mov    0x8(%ebp),%edx
f0120c15:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120c18:	01 d0                	add    %edx,%eax
f0120c1a:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f0120c1f:	0f 87 ad 01 00 00    	ja     f0120dd2 <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f0120c25:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c28:	85 c0                	test   %eax,%eax
f0120c2a:	0f 89 a5 01 00 00    	jns    f0120dd5 <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f0120c30:	8b 55 08             	mov    0x8(%ebp),%edx
f0120c33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120c36:	01 d0                	add    %edx,%eax
f0120c38:	83 e8 04             	sub    $0x4,%eax
f0120c3b:	a3 f4 d9 f5 f0       	mov    %eax,0xf0f5d9f4
     struct BlockElement * element = NULL;
f0120c40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0120c47:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0120c4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120c4f:	e9 87 00 00 00       	jmp    f0120cdb <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f0120c54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120c58:	75 14                	jne    f0120c6e <initialize_dynamic_allocator+0x83>
f0120c5a:	83 ec 04             	sub    $0x4,%esp
f0120c5d:	68 77 1b 13 f0       	push   $0xf0131b77
f0120c62:	6a 79                	push   $0x79
f0120c64:	68 95 1b 13 f0       	push   $0xf0131b95
f0120c69:	e8 cb f6 fd ff       	call   f0100339 <_panic>
f0120c6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c71:	8b 00                	mov    (%eax),%eax
f0120c73:	85 c0                	test   %eax,%eax
f0120c75:	74 10                	je     f0120c87 <initialize_dynamic_allocator+0x9c>
f0120c77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c7a:	8b 00                	mov    (%eax),%eax
f0120c7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120c7f:	8b 52 04             	mov    0x4(%edx),%edx
f0120c82:	89 50 04             	mov    %edx,0x4(%eax)
f0120c85:	eb 0b                	jmp    f0120c92 <initialize_dynamic_allocator+0xa7>
f0120c87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c8a:	8b 40 04             	mov    0x4(%eax),%eax
f0120c8d:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0120c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c95:	8b 40 04             	mov    0x4(%eax),%eax
f0120c98:	85 c0                	test   %eax,%eax
f0120c9a:	74 0f                	je     f0120cab <initialize_dynamic_allocator+0xc0>
f0120c9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c9f:	8b 40 04             	mov    0x4(%eax),%eax
f0120ca2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120ca5:	8b 12                	mov    (%edx),%edx
f0120ca7:	89 10                	mov    %edx,(%eax)
f0120ca9:	eb 0a                	jmp    f0120cb5 <initialize_dynamic_allocator+0xca>
f0120cab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cae:	8b 00                	mov    (%eax),%eax
f0120cb0:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0120cb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cb8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120cbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cc1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120cc8:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0120ccd:	48                   	dec    %eax
f0120cce:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f0120cd3:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f0120cd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120cdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120cdf:	74 07                	je     f0120ce8 <initialize_dynamic_allocator+0xfd>
f0120ce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ce4:	8b 00                	mov    (%eax),%eax
f0120ce6:	eb 05                	jmp    f0120ced <initialize_dynamic_allocator+0x102>
f0120ce8:	b8 00 00 00 00       	mov    $0x0,%eax
f0120ced:	a3 58 d3 b5 f0       	mov    %eax,0xf0b5d358
f0120cf2:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f0120cf7:	85 c0                	test   %eax,%eax
f0120cf9:	0f 85 55 ff ff ff    	jne    f0120c54 <initialize_dynamic_allocator+0x69>
f0120cff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d03:	0f 85 4b ff ff ff    	jne    f0120c54 <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f0120d09:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f0120d0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d12:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f0120d18:	a1 f4 d9 f5 f0       	mov    0xf0f5d9f4,%eax
f0120d1d:	a3 b0 d7 b5 f0       	mov    %eax,0xf0b5d7b0
    end_block->info = 1;
f0120d22:	a1 b0 d7 b5 f0       	mov    0xf0b5d7b0,%eax
f0120d27:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f0120d2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d30:	83 c0 08             	add    $0x8,%eax
f0120d33:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120d36:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d39:	83 c0 04             	add    $0x4,%eax
f0120d3c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120d3f:	83 ea 08             	sub    $0x8,%edx
f0120d42:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f0120d44:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120d47:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d4a:	01 d0                	add    %edx,%eax
f0120d4c:	83 e8 08             	sub    $0x8,%eax
f0120d4f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120d52:	83 ea 08             	sub    $0x8,%edx
f0120d55:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120d57:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120d5a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0120d60:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120d63:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120d6a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120d6e:	75 17                	jne    f0120d87 <initialize_dynamic_allocator+0x19c>
f0120d70:	83 ec 04             	sub    $0x4,%esp
f0120d73:	68 b0 1b 13 f0       	push   $0xf0131bb0
f0120d78:	68 90 00 00 00       	push   $0x90
f0120d7d:	68 95 1b 13 f0       	push   $0xf0131b95
f0120d82:	e8 b2 f5 fd ff       	call   f0100339 <_panic>
f0120d87:	8b 15 50 d3 b5 f0    	mov    0xf0b5d350,%edx
f0120d8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120d90:	89 10                	mov    %edx,(%eax)
f0120d92:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120d95:	8b 00                	mov    (%eax),%eax
f0120d97:	85 c0                	test   %eax,%eax
f0120d99:	74 0d                	je     f0120da8 <initialize_dynamic_allocator+0x1bd>
f0120d9b:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0120da0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120da3:	89 50 04             	mov    %edx,0x4(%eax)
f0120da6:	eb 08                	jmp    f0120db0 <initialize_dynamic_allocator+0x1c5>
f0120da8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120dab:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0120db0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120db3:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0120db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120dbb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120dc2:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0120dc7:	40                   	inc    %eax
f0120dc8:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f0120dcd:	eb 07                	jmp    f0120dd6 <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f0120dcf:	90                   	nop
f0120dd0:	eb 04                	jmp    f0120dd6 <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f0120dd2:	90                   	nop
f0120dd3:	eb 01                	jmp    f0120dd6 <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f0120dd5:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f0120dd6:	c9                   	leave  
f0120dd7:	c3                   	ret    

f0120dd8 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120dd8:	55                   	push   %ebp
f0120dd9:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120ddb:	8b 45 10             	mov    0x10(%ebp),%eax
f0120dde:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f0120de1:	8b 45 08             	mov    0x8(%ebp),%eax
f0120de4:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120de7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120dea:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f0120dec:	8b 45 08             	mov    0x8(%ebp),%eax
f0120def:	83 e8 04             	sub    $0x4,%eax
f0120df2:	8b 00                	mov    (%eax),%eax
f0120df4:	83 e0 fe             	and    $0xfffffffe,%eax
f0120df7:	8d 50 f8             	lea    -0x8(%eax),%edx
f0120dfa:	8b 45 08             	mov    0x8(%ebp),%eax
f0120dfd:	01 c2                	add    %eax,%edx
f0120dff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e02:	89 02                	mov    %eax,(%edx)
}
f0120e04:	90                   	nop
f0120e05:	5d                   	pop    %ebp
f0120e06:	c3                   	ret    

f0120e07 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f0120e07:	55                   	push   %ebp
f0120e08:	89 e5                	mov    %esp,%ebp
f0120e0a:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120e0d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e10:	83 e0 01             	and    $0x1,%eax
f0120e13:	85 c0                	test   %eax,%eax
f0120e15:	74 03                	je     f0120e1a <alloc_block_FF+0x13>
f0120e17:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120e1a:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120e1e:	77 07                	ja     f0120e27 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120e20:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120e27:	a1 d4 cf 75 f0       	mov    0xf075cfd4,%eax
f0120e2c:	85 c0                	test   %eax,%eax
f0120e2e:	75 73                	jne    f0120ea3 <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120e30:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e33:	83 c0 10             	add    $0x10,%eax
f0120e36:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120e39:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0120e40:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120e43:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120e46:	01 d0                	add    %edx,%eax
f0120e48:	48                   	dec    %eax
f0120e49:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120e4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120e4f:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e54:	f7 75 ec             	divl   -0x14(%ebp)
f0120e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120e5a:	29 d0                	sub    %edx,%eax
f0120e5c:	c1 e8 0c             	shr    $0xc,%eax
f0120e5f:	83 ec 0c             	sub    $0xc,%esp
f0120e62:	50                   	push   %eax
f0120e63:	e8 34 88 fe ff       	call   f010969c <sbrk>
f0120e68:	83 c4 10             	add    $0x10,%esp
f0120e6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120e6e:	83 ec 0c             	sub    $0xc,%esp
f0120e71:	6a 00                	push   $0x0
f0120e73:	e8 24 88 fe ff       	call   f010969c <sbrk>
f0120e78:	83 c4 10             	add    $0x10,%esp
f0120e7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120e7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120e81:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120e84:	83 ec 08             	sub    $0x8,%esp
f0120e87:	50                   	push   %eax
f0120e88:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120e8b:	e8 5b fd ff ff       	call   f0120beb <initialize_dynamic_allocator>
f0120e90:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120e93:	83 ec 0c             	sub    $0xc,%esp
f0120e96:	68 d3 1b 13 f0       	push   $0xf0131bd3
f0120e9b:	e8 eb 00 fe ff       	call   f0100f8b <cprintf>
f0120ea0:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120ea3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120ea7:	75 0a                	jne    f0120eb3 <alloc_block_FF+0xac>
	        return NULL;
f0120ea9:	b8 00 00 00 00       	mov    $0x0,%eax
f0120eae:	e9 0e 04 00 00       	jmp    f01212c1 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120eb3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120eba:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0120ebf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120ec2:	e9 f3 02 00 00       	jmp    f01211ba <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120ec7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120eca:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120ecd:	83 ec 0c             	sub    $0xc,%esp
f0120ed0:	ff 75 bc             	pushl  -0x44(%ebp)
f0120ed3:	e8 af fb ff ff       	call   f0120a87 <get_block_size>
f0120ed8:	83 c4 10             	add    $0x10,%esp
f0120edb:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120ede:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ee1:	83 c0 08             	add    $0x8,%eax
f0120ee4:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120ee7:	0f 87 c5 02 00 00    	ja     f01211b2 <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120eed:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ef0:	83 c0 18             	add    $0x18,%eax
f0120ef3:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120ef6:	0f 87 19 02 00 00    	ja     f0121115 <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f0120efc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120eff:	2b 45 08             	sub    0x8(%ebp),%eax
f0120f02:	83 e8 08             	sub    $0x8,%eax
f0120f05:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f0120f08:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f0b:	8d 50 08             	lea    0x8(%eax),%edx
f0120f0e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120f11:	01 d0                	add    %edx,%eax
f0120f13:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120f16:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f19:	83 c0 08             	add    $0x8,%eax
f0120f1c:	83 ec 04             	sub    $0x4,%esp
f0120f1f:	6a 01                	push   $0x1
f0120f21:	50                   	push   %eax
f0120f22:	ff 75 bc             	pushl  -0x44(%ebp)
f0120f25:	e8 ae fe ff ff       	call   f0120dd8 <set_block_data>
f0120f2a:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120f2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f30:	8b 40 04             	mov    0x4(%eax),%eax
f0120f33:	85 c0                	test   %eax,%eax
f0120f35:	75 68                	jne    f0120f9f <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120f37:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120f3b:	75 17                	jne    f0120f54 <alloc_block_FF+0x14d>
f0120f3d:	83 ec 04             	sub    $0x4,%esp
f0120f40:	68 b0 1b 13 f0       	push   $0xf0131bb0
f0120f45:	68 d7 00 00 00       	push   $0xd7
f0120f4a:	68 95 1b 13 f0       	push   $0xf0131b95
f0120f4f:	e8 e5 f3 fd ff       	call   f0100339 <_panic>
f0120f54:	8b 15 50 d3 b5 f0    	mov    0xf0b5d350,%edx
f0120f5a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f5d:	89 10                	mov    %edx,(%eax)
f0120f5f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f62:	8b 00                	mov    (%eax),%eax
f0120f64:	85 c0                	test   %eax,%eax
f0120f66:	74 0d                	je     f0120f75 <alloc_block_FF+0x16e>
f0120f68:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0120f6d:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120f70:	89 50 04             	mov    %edx,0x4(%eax)
f0120f73:	eb 08                	jmp    f0120f7d <alloc_block_FF+0x176>
f0120f75:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f78:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0120f7d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f80:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0120f85:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120f88:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120f8f:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0120f94:	40                   	inc    %eax
f0120f95:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f0120f9a:	e9 dc 00 00 00       	jmp    f012107b <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120f9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fa2:	8b 00                	mov    (%eax),%eax
f0120fa4:	85 c0                	test   %eax,%eax
f0120fa6:	75 65                	jne    f012100d <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120fa8:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120fac:	75 17                	jne    f0120fc5 <alloc_block_FF+0x1be>
f0120fae:	83 ec 04             	sub    $0x4,%esp
f0120fb1:	68 e4 1b 13 f0       	push   $0xf0131be4
f0120fb6:	68 db 00 00 00       	push   $0xdb
f0120fbb:	68 95 1b 13 f0       	push   $0xf0131b95
f0120fc0:	e8 74 f3 fd ff       	call   f0100339 <_panic>
f0120fc5:	8b 15 54 d3 b5 f0    	mov    0xf0b5d354,%edx
f0120fcb:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120fce:	89 50 04             	mov    %edx,0x4(%eax)
f0120fd1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120fd4:	8b 40 04             	mov    0x4(%eax),%eax
f0120fd7:	85 c0                	test   %eax,%eax
f0120fd9:	74 0c                	je     f0120fe7 <alloc_block_FF+0x1e0>
f0120fdb:	a1 54 d3 b5 f0       	mov    0xf0b5d354,%eax
f0120fe0:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120fe3:	89 10                	mov    %edx,(%eax)
f0120fe5:	eb 08                	jmp    f0120fef <alloc_block_FF+0x1e8>
f0120fe7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120fea:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0120fef:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ff2:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0120ff7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ffa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121000:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121005:	40                   	inc    %eax
f0121006:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f012100b:	eb 6e                	jmp    f012107b <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f012100d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121011:	74 06                	je     f0121019 <alloc_block_FF+0x212>
f0121013:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0121017:	75 17                	jne    f0121030 <alloc_block_FF+0x229>
f0121019:	83 ec 04             	sub    $0x4,%esp
f012101c:	68 08 1c 13 f0       	push   $0xf0131c08
f0121021:	68 df 00 00 00       	push   $0xdf
f0121026:	68 95 1b 13 f0       	push   $0xf0131b95
f012102b:	e8 09 f3 fd ff       	call   f0100339 <_panic>
f0121030:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121033:	8b 10                	mov    (%eax),%edx
f0121035:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0121038:	89 10                	mov    %edx,(%eax)
f012103a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012103d:	8b 00                	mov    (%eax),%eax
f012103f:	85 c0                	test   %eax,%eax
f0121041:	74 0b                	je     f012104e <alloc_block_FF+0x247>
f0121043:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121046:	8b 00                	mov    (%eax),%eax
f0121048:	8b 55 b0             	mov    -0x50(%ebp),%edx
f012104b:	89 50 04             	mov    %edx,0x4(%eax)
f012104e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121051:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0121054:	89 10                	mov    %edx,(%eax)
f0121056:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0121059:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012105c:	89 50 04             	mov    %edx,0x4(%eax)
f012105f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0121062:	8b 00                	mov    (%eax),%eax
f0121064:	85 c0                	test   %eax,%eax
f0121066:	75 08                	jne    f0121070 <alloc_block_FF+0x269>
f0121068:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012106b:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121070:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121075:	40                   	inc    %eax
f0121076:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
				}
				LIST_REMOVE(&freeBlocksList, blk);
f012107b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012107f:	75 17                	jne    f0121098 <alloc_block_FF+0x291>
f0121081:	83 ec 04             	sub    $0x4,%esp
f0121084:	68 77 1b 13 f0       	push   $0xf0131b77
f0121089:	68 e1 00 00 00       	push   $0xe1
f012108e:	68 95 1b 13 f0       	push   $0xf0131b95
f0121093:	e8 a1 f2 fd ff       	call   f0100339 <_panic>
f0121098:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012109b:	8b 00                	mov    (%eax),%eax
f012109d:	85 c0                	test   %eax,%eax
f012109f:	74 10                	je     f01210b1 <alloc_block_FF+0x2aa>
f01210a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210a4:	8b 00                	mov    (%eax),%eax
f01210a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01210a9:	8b 52 04             	mov    0x4(%edx),%edx
f01210ac:	89 50 04             	mov    %edx,0x4(%eax)
f01210af:	eb 0b                	jmp    f01210bc <alloc_block_FF+0x2b5>
f01210b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210b4:	8b 40 04             	mov    0x4(%eax),%eax
f01210b7:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f01210bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210bf:	8b 40 04             	mov    0x4(%eax),%eax
f01210c2:	85 c0                	test   %eax,%eax
f01210c4:	74 0f                	je     f01210d5 <alloc_block_FF+0x2ce>
f01210c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210c9:	8b 40 04             	mov    0x4(%eax),%eax
f01210cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01210cf:	8b 12                	mov    (%edx),%edx
f01210d1:	89 10                	mov    %edx,(%eax)
f01210d3:	eb 0a                	jmp    f01210df <alloc_block_FF+0x2d8>
f01210d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210d8:	8b 00                	mov    (%eax),%eax
f01210da:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f01210df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01210e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210eb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01210f2:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01210f7:	48                   	dec    %eax
f01210f8:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
				set_block_data(new_block_va, remaining_size, 0);
f01210fd:	83 ec 04             	sub    $0x4,%esp
f0121100:	6a 00                	push   $0x0
f0121102:	ff 75 b4             	pushl  -0x4c(%ebp)
f0121105:	ff 75 b0             	pushl  -0x50(%ebp)
f0121108:	e8 cb fc ff ff       	call   f0120dd8 <set_block_data>
f012110d:	83 c4 10             	add    $0x10,%esp
f0121110:	e9 95 00 00 00       	jmp    f01211aa <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f0121115:	83 ec 04             	sub    $0x4,%esp
f0121118:	6a 01                	push   $0x1
f012111a:	ff 75 b8             	pushl  -0x48(%ebp)
f012111d:	ff 75 bc             	pushl  -0x44(%ebp)
f0121120:	e8 b3 fc ff ff       	call   f0120dd8 <set_block_data>
f0121125:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f0121128:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012112c:	75 17                	jne    f0121145 <alloc_block_FF+0x33e>
f012112e:	83 ec 04             	sub    $0x4,%esp
f0121131:	68 77 1b 13 f0       	push   $0xf0131b77
f0121136:	68 e8 00 00 00       	push   $0xe8
f012113b:	68 95 1b 13 f0       	push   $0xf0131b95
f0121140:	e8 f4 f1 fd ff       	call   f0100339 <_panic>
f0121145:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121148:	8b 00                	mov    (%eax),%eax
f012114a:	85 c0                	test   %eax,%eax
f012114c:	74 10                	je     f012115e <alloc_block_FF+0x357>
f012114e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121151:	8b 00                	mov    (%eax),%eax
f0121153:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121156:	8b 52 04             	mov    0x4(%edx),%edx
f0121159:	89 50 04             	mov    %edx,0x4(%eax)
f012115c:	eb 0b                	jmp    f0121169 <alloc_block_FF+0x362>
f012115e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121161:	8b 40 04             	mov    0x4(%eax),%eax
f0121164:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121169:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012116c:	8b 40 04             	mov    0x4(%eax),%eax
f012116f:	85 c0                	test   %eax,%eax
f0121171:	74 0f                	je     f0121182 <alloc_block_FF+0x37b>
f0121173:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121176:	8b 40 04             	mov    0x4(%eax),%eax
f0121179:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012117c:	8b 12                	mov    (%edx),%edx
f012117e:	89 10                	mov    %edx,(%eax)
f0121180:	eb 0a                	jmp    f012118c <alloc_block_FF+0x385>
f0121182:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121185:	8b 00                	mov    (%eax),%eax
f0121187:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f012118c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012118f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121198:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012119f:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01211a4:	48                   	dec    %eax
f01211a5:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
	            }
	            return va;
f01211aa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01211ad:	e9 0f 01 00 00       	jmp    f01212c1 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f01211b2:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f01211b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01211ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01211be:	74 07                	je     f01211c7 <alloc_block_FF+0x3c0>
f01211c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01211c3:	8b 00                	mov    (%eax),%eax
f01211c5:	eb 05                	jmp    f01211cc <alloc_block_FF+0x3c5>
f01211c7:	b8 00 00 00 00       	mov    $0x0,%eax
f01211cc:	a3 58 d3 b5 f0       	mov    %eax,0xf0b5d358
f01211d1:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f01211d6:	85 c0                	test   %eax,%eax
f01211d8:	0f 85 e9 fc ff ff    	jne    f0120ec7 <alloc_block_FF+0xc0>
f01211de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01211e2:	0f 85 df fc ff ff    	jne    f0120ec7 <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f01211e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01211eb:	83 c0 08             	add    $0x8,%eax
f01211ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01211f1:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01211f8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01211fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01211fe:	01 d0                	add    %edx,%eax
f0121200:	48                   	dec    %eax
f0121201:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0121204:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121207:	ba 00 00 00 00       	mov    $0x0,%edx
f012120c:	f7 75 d8             	divl   -0x28(%ebp)
f012120f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121212:	29 d0                	sub    %edx,%eax
f0121214:	c1 e8 0c             	shr    $0xc,%eax
f0121217:	83 ec 0c             	sub    $0xc,%esp
f012121a:	50                   	push   %eax
f012121b:	e8 7c 84 fe ff       	call   f010969c <sbrk>
f0121220:	83 c4 10             	add    $0x10,%esp
f0121223:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f0121226:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f012122a:	75 0a                	jne    f0121236 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f012122c:	b8 00 00 00 00       	mov    $0x0,%eax
f0121231:	e9 8b 00 00 00       	jmp    f01212c1 <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0121236:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f012123d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121240:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121243:	01 d0                	add    %edx,%eax
f0121245:	48                   	dec    %eax
f0121246:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0121249:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012124c:	ba 00 00 00 00       	mov    $0x0,%edx
f0121251:	f7 75 cc             	divl   -0x34(%ebp)
f0121254:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121257:	29 d0                	sub    %edx,%eax
f0121259:	8d 50 fc             	lea    -0x4(%eax),%edx
f012125c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f012125f:	01 d0                	add    %edx,%eax
f0121261:	a3 b0 d7 b5 f0       	mov    %eax,0xf0b5d7b0
			end_block->info = 1;
f0121266:	a1 b0 d7 b5 f0       	mov    0xf0b5d7b0,%eax
f012126b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0121271:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0121278:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012127b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012127e:	01 d0                	add    %edx,%eax
f0121280:	48                   	dec    %eax
f0121281:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0121284:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121287:	ba 00 00 00 00       	mov    $0x0,%edx
f012128c:	f7 75 c4             	divl   -0x3c(%ebp)
f012128f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121292:	29 d0                	sub    %edx,%eax
f0121294:	83 ec 04             	sub    $0x4,%esp
f0121297:	6a 01                	push   $0x1
f0121299:	50                   	push   %eax
f012129a:	ff 75 d0             	pushl  -0x30(%ebp)
f012129d:	e8 36 fb ff ff       	call   f0120dd8 <set_block_data>
f01212a2:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f01212a5:	83 ec 0c             	sub    $0xc,%esp
f01212a8:	ff 75 d0             	pushl  -0x30(%ebp)
f01212ab:	e8 f8 09 00 00       	call   f0121ca8 <free_block>
f01212b0:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f01212b3:	83 ec 0c             	sub    $0xc,%esp
f01212b6:	ff 75 08             	pushl  0x8(%ebp)
f01212b9:	e8 49 fb ff ff       	call   f0120e07 <alloc_block_FF>
f01212be:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f01212c1:	c9                   	leave  
f01212c2:	c3                   	ret    

f01212c3 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f01212c3:	55                   	push   %ebp
f01212c4:	89 e5                	mov    %esp,%ebp
f01212c6:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01212c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01212cc:	83 e0 01             	and    $0x1,%eax
f01212cf:	85 c0                	test   %eax,%eax
f01212d1:	74 03                	je     f01212d6 <alloc_block_BF+0x13>
f01212d3:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f01212d6:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f01212da:	77 07                	ja     f01212e3 <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f01212dc:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f01212e3:	a1 d4 cf 75 f0       	mov    0xf075cfd4,%eax
f01212e8:	85 c0                	test   %eax,%eax
f01212ea:	75 73                	jne    f012135f <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f01212ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01212ef:	83 c0 10             	add    $0x10,%eax
f01212f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f01212f5:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01212fc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01212ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121302:	01 d0                	add    %edx,%eax
f0121304:	48                   	dec    %eax
f0121305:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0121308:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012130b:	ba 00 00 00 00       	mov    $0x0,%edx
f0121310:	f7 75 e0             	divl   -0x20(%ebp)
f0121313:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121316:	29 d0                	sub    %edx,%eax
f0121318:	c1 e8 0c             	shr    $0xc,%eax
f012131b:	83 ec 0c             	sub    $0xc,%esp
f012131e:	50                   	push   %eax
f012131f:	e8 78 83 fe ff       	call   f010969c <sbrk>
f0121324:	83 c4 10             	add    $0x10,%esp
f0121327:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f012132a:	83 ec 0c             	sub    $0xc,%esp
f012132d:	6a 00                	push   $0x0
f012132f:	e8 68 83 fe ff       	call   f010969c <sbrk>
f0121334:	83 c4 10             	add    $0x10,%esp
f0121337:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f012133a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012133d:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0121340:	83 ec 08             	sub    $0x8,%esp
f0121343:	50                   	push   %eax
f0121344:	ff 75 d8             	pushl  -0x28(%ebp)
f0121347:	e8 9f f8 ff ff       	call   f0120beb <initialize_dynamic_allocator>
f012134c:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f012134f:	83 ec 0c             	sub    $0xc,%esp
f0121352:	68 d3 1b 13 f0       	push   $0xf0131bd3
f0121357:	e8 2f fc fd ff       	call   f0100f8b <cprintf>
f012135c:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f012135f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f0121366:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f012136d:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f0121374:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f012137b:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0121380:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121383:	e9 1d 01 00 00       	jmp    f01214a5 <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0121388:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012138b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f012138e:	83 ec 0c             	sub    $0xc,%esp
f0121391:	ff 75 a8             	pushl  -0x58(%ebp)
f0121394:	e8 ee f6 ff ff       	call   f0120a87 <get_block_size>
f0121399:	83 c4 10             	add    $0x10,%esp
f012139c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f012139f:	8b 45 08             	mov    0x8(%ebp),%eax
f01213a2:	83 c0 08             	add    $0x8,%eax
f01213a5:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01213a8:	0f 87 ef 00 00 00    	ja     f012149d <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f01213ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01213b1:	83 c0 18             	add    $0x18,%eax
f01213b4:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01213b7:	77 1d                	ja     f01213d6 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f01213b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01213bc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01213bf:	0f 86 d8 00 00 00    	jbe    f012149d <alloc_block_BF+0x1da>
				{
					best_va = va;
f01213c5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01213c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f01213cb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01213ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01213d1:	e9 c7 00 00 00       	jmp    f012149d <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f01213d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01213d9:	83 c0 08             	add    $0x8,%eax
f01213dc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01213df:	0f 85 9d 00 00 00    	jne    f0121482 <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f01213e5:	83 ec 04             	sub    $0x4,%esp
f01213e8:	6a 01                	push   $0x1
f01213ea:	ff 75 a4             	pushl  -0x5c(%ebp)
f01213ed:	ff 75 a8             	pushl  -0x58(%ebp)
f01213f0:	e8 e3 f9 ff ff       	call   f0120dd8 <set_block_data>
f01213f5:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f01213f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01213fc:	75 17                	jne    f0121415 <alloc_block_BF+0x152>
f01213fe:	83 ec 04             	sub    $0x4,%esp
f0121401:	68 77 1b 13 f0       	push   $0xf0131b77
f0121406:	68 2c 01 00 00       	push   $0x12c
f012140b:	68 95 1b 13 f0       	push   $0xf0131b95
f0121410:	e8 24 ef fd ff       	call   f0100339 <_panic>
f0121415:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121418:	8b 00                	mov    (%eax),%eax
f012141a:	85 c0                	test   %eax,%eax
f012141c:	74 10                	je     f012142e <alloc_block_BF+0x16b>
f012141e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121421:	8b 00                	mov    (%eax),%eax
f0121423:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121426:	8b 52 04             	mov    0x4(%edx),%edx
f0121429:	89 50 04             	mov    %edx,0x4(%eax)
f012142c:	eb 0b                	jmp    f0121439 <alloc_block_BF+0x176>
f012142e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121431:	8b 40 04             	mov    0x4(%eax),%eax
f0121434:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121439:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012143c:	8b 40 04             	mov    0x4(%eax),%eax
f012143f:	85 c0                	test   %eax,%eax
f0121441:	74 0f                	je     f0121452 <alloc_block_BF+0x18f>
f0121443:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121446:	8b 40 04             	mov    0x4(%eax),%eax
f0121449:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012144c:	8b 12                	mov    (%edx),%edx
f012144e:	89 10                	mov    %edx,(%eax)
f0121450:	eb 0a                	jmp    f012145c <alloc_block_BF+0x199>
f0121452:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121455:	8b 00                	mov    (%eax),%eax
f0121457:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f012145c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012145f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121465:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121468:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012146f:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121474:	48                   	dec    %eax
f0121475:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
					return va;
f012147a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012147d:	e9 01 04 00 00       	jmp    f0121883 <alloc_block_BF+0x5c0>
				}
				else
				{
					if (best_blk_size > blk_size)
f0121482:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121485:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121488:	76 13                	jbe    f012149d <alloc_block_BF+0x1da>
					{
						internal = 1;
f012148a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f0121491:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121494:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0121497:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f012149a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f012149d:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f01214a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01214a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01214a9:	74 07                	je     f01214b2 <alloc_block_BF+0x1ef>
f01214ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01214ae:	8b 00                	mov    (%eax),%eax
f01214b0:	eb 05                	jmp    f01214b7 <alloc_block_BF+0x1f4>
f01214b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01214b7:	a3 58 d3 b5 f0       	mov    %eax,0xf0b5d358
f01214bc:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f01214c1:	85 c0                	test   %eax,%eax
f01214c3:	0f 85 bf fe ff ff    	jne    f0121388 <alloc_block_BF+0xc5>
f01214c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01214cd:	0f 85 b5 fe ff ff    	jne    f0121388 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f01214d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01214d7:	0f 84 26 02 00 00    	je     f0121703 <alloc_block_BF+0x440>
f01214dd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01214e1:	0f 85 1c 02 00 00    	jne    f0121703 <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f01214e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01214ea:	2b 45 08             	sub    0x8(%ebp),%eax
f01214ed:	83 e8 08             	sub    $0x8,%eax
f01214f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f01214f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01214f6:	8d 50 08             	lea    0x8(%eax),%edx
f01214f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01214fc:	01 d0                	add    %edx,%eax
f01214fe:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0121501:	8b 45 08             	mov    0x8(%ebp),%eax
f0121504:	83 c0 08             	add    $0x8,%eax
f0121507:	83 ec 04             	sub    $0x4,%esp
f012150a:	6a 01                	push   $0x1
f012150c:	50                   	push   %eax
f012150d:	ff 75 f0             	pushl  -0x10(%ebp)
f0121510:	e8 c3 f8 ff ff       	call   f0120dd8 <set_block_data>
f0121515:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f0121518:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012151b:	8b 40 04             	mov    0x4(%eax),%eax
f012151e:	85 c0                	test   %eax,%eax
f0121520:	75 68                	jne    f012158a <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0121522:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121526:	75 17                	jne    f012153f <alloc_block_BF+0x27c>
f0121528:	83 ec 04             	sub    $0x4,%esp
f012152b:	68 b0 1b 13 f0       	push   $0xf0131bb0
f0121530:	68 45 01 00 00       	push   $0x145
f0121535:	68 95 1b 13 f0       	push   $0xf0131b95
f012153a:	e8 fa ed fd ff       	call   f0100339 <_panic>
f012153f:	8b 15 50 d3 b5 f0    	mov    0xf0b5d350,%edx
f0121545:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121548:	89 10                	mov    %edx,(%eax)
f012154a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012154d:	8b 00                	mov    (%eax),%eax
f012154f:	85 c0                	test   %eax,%eax
f0121551:	74 0d                	je     f0121560 <alloc_block_BF+0x29d>
f0121553:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0121558:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012155b:	89 50 04             	mov    %edx,0x4(%eax)
f012155e:	eb 08                	jmp    f0121568 <alloc_block_BF+0x2a5>
f0121560:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121563:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121568:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012156b:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121570:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121573:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012157a:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f012157f:	40                   	inc    %eax
f0121580:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f0121585:	e9 dc 00 00 00       	jmp    f0121666 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f012158a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012158d:	8b 00                	mov    (%eax),%eax
f012158f:	85 c0                	test   %eax,%eax
f0121591:	75 65                	jne    f01215f8 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0121593:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121597:	75 17                	jne    f01215b0 <alloc_block_BF+0x2ed>
f0121599:	83 ec 04             	sub    $0x4,%esp
f012159c:	68 e4 1b 13 f0       	push   $0xf0131be4
f01215a1:	68 4a 01 00 00       	push   $0x14a
f01215a6:	68 95 1b 13 f0       	push   $0xf0131b95
f01215ab:	e8 89 ed fd ff       	call   f0100339 <_panic>
f01215b0:	8b 15 54 d3 b5 f0    	mov    0xf0b5d354,%edx
f01215b6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01215b9:	89 50 04             	mov    %edx,0x4(%eax)
f01215bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01215bf:	8b 40 04             	mov    0x4(%eax),%eax
f01215c2:	85 c0                	test   %eax,%eax
f01215c4:	74 0c                	je     f01215d2 <alloc_block_BF+0x30f>
f01215c6:	a1 54 d3 b5 f0       	mov    0xf0b5d354,%eax
f01215cb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01215ce:	89 10                	mov    %edx,(%eax)
f01215d0:	eb 08                	jmp    f01215da <alloc_block_BF+0x317>
f01215d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01215d5:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f01215da:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01215dd:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f01215e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01215e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01215eb:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01215f0:	40                   	inc    %eax
f01215f1:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f01215f6:	eb 6e                	jmp    f0121666 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f01215f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01215fc:	74 06                	je     f0121604 <alloc_block_BF+0x341>
f01215fe:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121602:	75 17                	jne    f012161b <alloc_block_BF+0x358>
f0121604:	83 ec 04             	sub    $0x4,%esp
f0121607:	68 08 1c 13 f0       	push   $0xf0131c08
f012160c:	68 4f 01 00 00       	push   $0x14f
f0121611:	68 95 1b 13 f0       	push   $0xf0131b95
f0121616:	e8 1e ed fd ff       	call   f0100339 <_panic>
f012161b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012161e:	8b 10                	mov    (%eax),%edx
f0121620:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121623:	89 10                	mov    %edx,(%eax)
f0121625:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121628:	8b 00                	mov    (%eax),%eax
f012162a:	85 c0                	test   %eax,%eax
f012162c:	74 0b                	je     f0121639 <alloc_block_BF+0x376>
f012162e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121631:	8b 00                	mov    (%eax),%eax
f0121633:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121636:	89 50 04             	mov    %edx,0x4(%eax)
f0121639:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012163c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f012163f:	89 10                	mov    %edx,(%eax)
f0121641:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121644:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121647:	89 50 04             	mov    %edx,0x4(%eax)
f012164a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012164d:	8b 00                	mov    (%eax),%eax
f012164f:	85 c0                	test   %eax,%eax
f0121651:	75 08                	jne    f012165b <alloc_block_BF+0x398>
f0121653:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121656:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f012165b:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121660:	40                   	inc    %eax
f0121661:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0121666:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012166a:	75 17                	jne    f0121683 <alloc_block_BF+0x3c0>
f012166c:	83 ec 04             	sub    $0x4,%esp
f012166f:	68 77 1b 13 f0       	push   $0xf0131b77
f0121674:	68 51 01 00 00       	push   $0x151
f0121679:	68 95 1b 13 f0       	push   $0xf0131b95
f012167e:	e8 b6 ec fd ff       	call   f0100339 <_panic>
f0121683:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121686:	8b 00                	mov    (%eax),%eax
f0121688:	85 c0                	test   %eax,%eax
f012168a:	74 10                	je     f012169c <alloc_block_BF+0x3d9>
f012168c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012168f:	8b 00                	mov    (%eax),%eax
f0121691:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121694:	8b 52 04             	mov    0x4(%edx),%edx
f0121697:	89 50 04             	mov    %edx,0x4(%eax)
f012169a:	eb 0b                	jmp    f01216a7 <alloc_block_BF+0x3e4>
f012169c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012169f:	8b 40 04             	mov    0x4(%eax),%eax
f01216a2:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f01216a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216aa:	8b 40 04             	mov    0x4(%eax),%eax
f01216ad:	85 c0                	test   %eax,%eax
f01216af:	74 0f                	je     f01216c0 <alloc_block_BF+0x3fd>
f01216b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216b4:	8b 40 04             	mov    0x4(%eax),%eax
f01216b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01216ba:	8b 12                	mov    (%edx),%edx
f01216bc:	89 10                	mov    %edx,(%eax)
f01216be:	eb 0a                	jmp    f01216ca <alloc_block_BF+0x407>
f01216c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216c3:	8b 00                	mov    (%eax),%eax
f01216c5:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f01216ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01216d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216d6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01216dd:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01216e2:	48                   	dec    %eax
f01216e3:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
			set_block_data(new_block_va, remaining_size, 0);
f01216e8:	83 ec 04             	sub    $0x4,%esp
f01216eb:	6a 00                	push   $0x0
f01216ed:	ff 75 d0             	pushl  -0x30(%ebp)
f01216f0:	ff 75 cc             	pushl  -0x34(%ebp)
f01216f3:	e8 e0 f6 ff ff       	call   f0120dd8 <set_block_data>
f01216f8:	83 c4 10             	add    $0x10,%esp
			return best_va;
f01216fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216fe:	e9 80 01 00 00       	jmp    f0121883 <alloc_block_BF+0x5c0>
	}
	else if(internal == 1)
f0121703:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0121707:	0f 85 9d 00 00 00    	jne    f01217aa <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f012170d:	83 ec 04             	sub    $0x4,%esp
f0121710:	6a 01                	push   $0x1
f0121712:	ff 75 ec             	pushl  -0x14(%ebp)
f0121715:	ff 75 f0             	pushl  -0x10(%ebp)
f0121718:	e8 bb f6 ff ff       	call   f0120dd8 <set_block_data>
f012171d:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0121720:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121724:	75 17                	jne    f012173d <alloc_block_BF+0x47a>
f0121726:	83 ec 04             	sub    $0x4,%esp
f0121729:	68 77 1b 13 f0       	push   $0xf0131b77
f012172e:	68 58 01 00 00       	push   $0x158
f0121733:	68 95 1b 13 f0       	push   $0xf0131b95
f0121738:	e8 fc eb fd ff       	call   f0100339 <_panic>
f012173d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121740:	8b 00                	mov    (%eax),%eax
f0121742:	85 c0                	test   %eax,%eax
f0121744:	74 10                	je     f0121756 <alloc_block_BF+0x493>
f0121746:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121749:	8b 00                	mov    (%eax),%eax
f012174b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012174e:	8b 52 04             	mov    0x4(%edx),%edx
f0121751:	89 50 04             	mov    %edx,0x4(%eax)
f0121754:	eb 0b                	jmp    f0121761 <alloc_block_BF+0x49e>
f0121756:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121759:	8b 40 04             	mov    0x4(%eax),%eax
f012175c:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121761:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121764:	8b 40 04             	mov    0x4(%eax),%eax
f0121767:	85 c0                	test   %eax,%eax
f0121769:	74 0f                	je     f012177a <alloc_block_BF+0x4b7>
f012176b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012176e:	8b 40 04             	mov    0x4(%eax),%eax
f0121771:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121774:	8b 12                	mov    (%edx),%edx
f0121776:	89 10                	mov    %edx,(%eax)
f0121778:	eb 0a                	jmp    f0121784 <alloc_block_BF+0x4c1>
f012177a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012177d:	8b 00                	mov    (%eax),%eax
f012177f:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121784:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121787:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012178d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121790:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121797:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f012179c:	48                   	dec    %eax
f012179d:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
		return best_va;
f01217a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01217a5:	e9 d9 00 00 00       	jmp    f0121883 <alloc_block_BF+0x5c0>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f01217aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01217ad:	83 c0 08             	add    $0x8,%eax
f01217b0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f01217b3:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f01217ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01217bd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01217c0:	01 d0                	add    %edx,%eax
f01217c2:	48                   	dec    %eax
f01217c3:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01217c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01217c9:	ba 00 00 00 00       	mov    $0x0,%edx
f01217ce:	f7 75 c4             	divl   -0x3c(%ebp)
f01217d1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01217d4:	29 d0                	sub    %edx,%eax
f01217d6:	c1 e8 0c             	shr    $0xc,%eax
f01217d9:	83 ec 0c             	sub    $0xc,%esp
f01217dc:	50                   	push   %eax
f01217dd:	e8 ba 7e fe ff       	call   f010969c <sbrk>
f01217e2:	83 c4 10             	add    $0x10,%esp
f01217e5:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f01217e8:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f01217ec:	75 0a                	jne    f01217f8 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f01217ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01217f3:	e9 8b 00 00 00       	jmp    f0121883 <alloc_block_BF+0x5c0>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f01217f8:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f01217ff:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121802:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0121805:	01 d0                	add    %edx,%eax
f0121807:	48                   	dec    %eax
f0121808:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f012180b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f012180e:	ba 00 00 00 00       	mov    $0x0,%edx
f0121813:	f7 75 b8             	divl   -0x48(%ebp)
f0121816:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0121819:	29 d0                	sub    %edx,%eax
f012181b:	8d 50 fc             	lea    -0x4(%eax),%edx
f012181e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0121821:	01 d0                	add    %edx,%eax
f0121823:	a3 b0 d7 b5 f0       	mov    %eax,0xf0b5d7b0
				end_block->info = 1;
f0121828:	a1 b0 d7 b5 f0       	mov    0xf0b5d7b0,%eax
f012182d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				
			
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0121833:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f012183a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012183d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0121840:	01 d0                	add    %edx,%eax
f0121842:	48                   	dec    %eax
f0121843:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0121846:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0121849:	ba 00 00 00 00       	mov    $0x0,%edx
f012184e:	f7 75 b0             	divl   -0x50(%ebp)
f0121851:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0121854:	29 d0                	sub    %edx,%eax
f0121856:	83 ec 04             	sub    $0x4,%esp
f0121859:	6a 01                	push   $0x1
f012185b:	50                   	push   %eax
f012185c:	ff 75 bc             	pushl  -0x44(%ebp)
f012185f:	e8 74 f5 ff ff       	call   f0120dd8 <set_block_data>
f0121864:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f0121867:	83 ec 0c             	sub    $0xc,%esp
f012186a:	ff 75 bc             	pushl  -0x44(%ebp)
f012186d:	e8 36 04 00 00       	call   f0121ca8 <free_block>
f0121872:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0121875:	83 ec 0c             	sub    $0xc,%esp
f0121878:	ff 75 08             	pushl  0x8(%ebp)
f012187b:	e8 43 fa ff ff       	call   f01212c3 <alloc_block_BF>
f0121880:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0121883:	c9                   	leave  
f0121884:	c3                   	ret    

f0121885 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0121885:	55                   	push   %ebp
f0121886:	89 e5                	mov    %esp,%ebp
f0121888:	53                   	push   %ebx
f0121889:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f012188c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121893:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f012189a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012189e:	74 1e                	je     f01218be <merging+0x39>
f01218a0:	ff 75 08             	pushl  0x8(%ebp)
f01218a3:	e8 df f1 ff ff       	call   f0120a87 <get_block_size>
f01218a8:	83 c4 04             	add    $0x4,%esp
f01218ab:	89 c2                	mov    %eax,%edx
f01218ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01218b0:	01 d0                	add    %edx,%eax
f01218b2:	3b 45 10             	cmp    0x10(%ebp),%eax
f01218b5:	75 07                	jne    f01218be <merging+0x39>
		prev_is_free = 1;
f01218b7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f01218be:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01218c2:	74 1e                	je     f01218e2 <merging+0x5d>
f01218c4:	ff 75 10             	pushl  0x10(%ebp)
f01218c7:	e8 bb f1 ff ff       	call   f0120a87 <get_block_size>
f01218cc:	83 c4 04             	add    $0x4,%esp
f01218cf:	89 c2                	mov    %eax,%edx
f01218d1:	8b 45 10             	mov    0x10(%ebp),%eax
f01218d4:	01 d0                	add    %edx,%eax
f01218d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01218d9:	75 07                	jne    f01218e2 <merging+0x5d>
		next_is_free = 1;
f01218db:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f01218e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01218e6:	0f 84 cc 00 00 00    	je     f01219b8 <merging+0x133>
f01218ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01218f0:	0f 84 c2 00 00 00    	je     f01219b8 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f01218f6:	ff 75 08             	pushl  0x8(%ebp)
f01218f9:	e8 89 f1 ff ff       	call   f0120a87 <get_block_size>
f01218fe:	83 c4 04             	add    $0x4,%esp
f0121901:	89 c3                	mov    %eax,%ebx
f0121903:	ff 75 10             	pushl  0x10(%ebp)
f0121906:	e8 7c f1 ff ff       	call   f0120a87 <get_block_size>
f012190b:	83 c4 04             	add    $0x4,%esp
f012190e:	01 c3                	add    %eax,%ebx
f0121910:	ff 75 0c             	pushl  0xc(%ebp)
f0121913:	e8 6f f1 ff ff       	call   f0120a87 <get_block_size>
f0121918:	83 c4 04             	add    $0x4,%esp
f012191b:	01 d8                	add    %ebx,%eax
f012191d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0121920:	6a 00                	push   $0x0
f0121922:	ff 75 ec             	pushl  -0x14(%ebp)
f0121925:	ff 75 08             	pushl  0x8(%ebp)
f0121928:	e8 ab f4 ff ff       	call   f0120dd8 <set_block_data>
f012192d:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f0121930:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121934:	75 17                	jne    f012194d <merging+0xc8>
f0121936:	83 ec 04             	sub    $0x4,%esp
f0121939:	68 77 1b 13 f0       	push   $0xf0131b77
f012193e:	68 7d 01 00 00       	push   $0x17d
f0121943:	68 95 1b 13 f0       	push   $0xf0131b95
f0121948:	e8 ec e9 fd ff       	call   f0100339 <_panic>
f012194d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121950:	8b 00                	mov    (%eax),%eax
f0121952:	85 c0                	test   %eax,%eax
f0121954:	74 10                	je     f0121966 <merging+0xe1>
f0121956:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121959:	8b 00                	mov    (%eax),%eax
f012195b:	8b 55 0c             	mov    0xc(%ebp),%edx
f012195e:	8b 52 04             	mov    0x4(%edx),%edx
f0121961:	89 50 04             	mov    %edx,0x4(%eax)
f0121964:	eb 0b                	jmp    f0121971 <merging+0xec>
f0121966:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121969:	8b 40 04             	mov    0x4(%eax),%eax
f012196c:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121974:	8b 40 04             	mov    0x4(%eax),%eax
f0121977:	85 c0                	test   %eax,%eax
f0121979:	74 0f                	je     f012198a <merging+0x105>
f012197b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012197e:	8b 40 04             	mov    0x4(%eax),%eax
f0121981:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121984:	8b 12                	mov    (%edx),%edx
f0121986:	89 10                	mov    %edx,(%eax)
f0121988:	eb 0a                	jmp    f0121994 <merging+0x10f>
f012198a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012198d:	8b 00                	mov    (%eax),%eax
f012198f:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121994:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121997:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012199d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01219a0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01219a7:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01219ac:	48                   	dec    %eax
f01219ad:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f01219b2:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01219b3:	e9 ea 02 00 00       	jmp    f0121ca2 <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f01219b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01219bc:	74 3b                	je     f01219f9 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f01219be:	83 ec 0c             	sub    $0xc,%esp
f01219c1:	ff 75 08             	pushl  0x8(%ebp)
f01219c4:	e8 be f0 ff ff       	call   f0120a87 <get_block_size>
f01219c9:	83 c4 10             	add    $0x10,%esp
f01219cc:	89 c3                	mov    %eax,%ebx
f01219ce:	83 ec 0c             	sub    $0xc,%esp
f01219d1:	ff 75 10             	pushl  0x10(%ebp)
f01219d4:	e8 ae f0 ff ff       	call   f0120a87 <get_block_size>
f01219d9:	83 c4 10             	add    $0x10,%esp
f01219dc:	01 d8                	add    %ebx,%eax
f01219de:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01219e1:	83 ec 04             	sub    $0x4,%esp
f01219e4:	6a 00                	push   $0x0
f01219e6:	ff 75 e8             	pushl  -0x18(%ebp)
f01219e9:	ff 75 08             	pushl  0x8(%ebp)
f01219ec:	e8 e7 f3 ff ff       	call   f0120dd8 <set_block_data>
f01219f1:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01219f4:	e9 a9 02 00 00       	jmp    f0121ca2 <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f01219f9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01219fd:	0f 84 2d 01 00 00    	je     f0121b30 <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0121a03:	83 ec 0c             	sub    $0xc,%esp
f0121a06:	ff 75 10             	pushl  0x10(%ebp)
f0121a09:	e8 79 f0 ff ff       	call   f0120a87 <get_block_size>
f0121a0e:	83 c4 10             	add    $0x10,%esp
f0121a11:	89 c3                	mov    %eax,%ebx
f0121a13:	83 ec 0c             	sub    $0xc,%esp
f0121a16:	ff 75 0c             	pushl  0xc(%ebp)
f0121a19:	e8 69 f0 ff ff       	call   f0120a87 <get_block_size>
f0121a1e:	83 c4 10             	add    $0x10,%esp
f0121a21:	01 d8                	add    %ebx,%eax
f0121a23:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f0121a26:	83 ec 04             	sub    $0x4,%esp
f0121a29:	6a 00                	push   $0x0
f0121a2b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121a2e:	ff 75 10             	pushl  0x10(%ebp)
f0121a31:	e8 a2 f3 ff ff       	call   f0120dd8 <set_block_data>
f0121a36:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f0121a39:	8b 45 10             	mov    0x10(%ebp),%eax
f0121a3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f0121a3f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121a43:	74 06                	je     f0121a4b <merging+0x1c6>
f0121a45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121a49:	75 17                	jne    f0121a62 <merging+0x1dd>
f0121a4b:	83 ec 04             	sub    $0x4,%esp
f0121a4e:	68 3c 1c 13 f0       	push   $0xf0131c3c
f0121a53:	68 8d 01 00 00       	push   $0x18d
f0121a58:	68 95 1b 13 f0       	push   $0xf0131b95
f0121a5d:	e8 d7 e8 fd ff       	call   f0100339 <_panic>
f0121a62:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a65:	8b 50 04             	mov    0x4(%eax),%edx
f0121a68:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121a6b:	89 50 04             	mov    %edx,0x4(%eax)
f0121a6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121a71:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121a74:	89 10                	mov    %edx,(%eax)
f0121a76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a79:	8b 40 04             	mov    0x4(%eax),%eax
f0121a7c:	85 c0                	test   %eax,%eax
f0121a7e:	74 0d                	je     f0121a8d <merging+0x208>
f0121a80:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a83:	8b 40 04             	mov    0x4(%eax),%eax
f0121a86:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121a89:	89 10                	mov    %edx,(%eax)
f0121a8b:	eb 08                	jmp    f0121a95 <merging+0x210>
f0121a8d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121a90:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121a95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a98:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121a9b:	89 50 04             	mov    %edx,0x4(%eax)
f0121a9e:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121aa3:	40                   	inc    %eax
f0121aa4:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
		LIST_REMOVE(&freeBlocksList, next_block);
f0121aa9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121aad:	75 17                	jne    f0121ac6 <merging+0x241>
f0121aaf:	83 ec 04             	sub    $0x4,%esp
f0121ab2:	68 77 1b 13 f0       	push   $0xf0131b77
f0121ab7:	68 8e 01 00 00       	push   $0x18e
f0121abc:	68 95 1b 13 f0       	push   $0xf0131b95
f0121ac1:	e8 73 e8 fd ff       	call   f0100339 <_panic>
f0121ac6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ac9:	8b 00                	mov    (%eax),%eax
f0121acb:	85 c0                	test   %eax,%eax
f0121acd:	74 10                	je     f0121adf <merging+0x25a>
f0121acf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ad2:	8b 00                	mov    (%eax),%eax
f0121ad4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121ad7:	8b 52 04             	mov    0x4(%edx),%edx
f0121ada:	89 50 04             	mov    %edx,0x4(%eax)
f0121add:	eb 0b                	jmp    f0121aea <merging+0x265>
f0121adf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ae2:	8b 40 04             	mov    0x4(%eax),%eax
f0121ae5:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121aea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121aed:	8b 40 04             	mov    0x4(%eax),%eax
f0121af0:	85 c0                	test   %eax,%eax
f0121af2:	74 0f                	je     f0121b03 <merging+0x27e>
f0121af4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121af7:	8b 40 04             	mov    0x4(%eax),%eax
f0121afa:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121afd:	8b 12                	mov    (%edx),%edx
f0121aff:	89 10                	mov    %edx,(%eax)
f0121b01:	eb 0a                	jmp    f0121b0d <merging+0x288>
f0121b03:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121b06:	8b 00                	mov    (%eax),%eax
f0121b08:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121b0d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121b10:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121b16:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121b19:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121b20:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121b25:	48                   	dec    %eax
f0121b26:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121b2b:	e9 72 01 00 00       	jmp    f0121ca2 <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f0121b30:	8b 45 10             	mov    0x10(%ebp),%eax
f0121b33:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121b36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121b3a:	74 79                	je     f0121bb5 <merging+0x330>
f0121b3c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121b40:	74 73                	je     f0121bb5 <merging+0x330>
f0121b42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121b46:	74 06                	je     f0121b4e <merging+0x2c9>
f0121b48:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121b4c:	75 17                	jne    f0121b65 <merging+0x2e0>
f0121b4e:	83 ec 04             	sub    $0x4,%esp
f0121b51:	68 08 1c 13 f0       	push   $0xf0131c08
f0121b56:	68 94 01 00 00       	push   $0x194
f0121b5b:	68 95 1b 13 f0       	push   $0xf0131b95
f0121b60:	e8 d4 e7 fd ff       	call   f0100339 <_panic>
f0121b65:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b68:	8b 10                	mov    (%eax),%edx
f0121b6a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b6d:	89 10                	mov    %edx,(%eax)
f0121b6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b72:	8b 00                	mov    (%eax),%eax
f0121b74:	85 c0                	test   %eax,%eax
f0121b76:	74 0b                	je     f0121b83 <merging+0x2fe>
f0121b78:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b7b:	8b 00                	mov    (%eax),%eax
f0121b7d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121b80:	89 50 04             	mov    %edx,0x4(%eax)
f0121b83:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b86:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121b89:	89 10                	mov    %edx,(%eax)
f0121b8b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b8e:	8b 55 08             	mov    0x8(%ebp),%edx
f0121b91:	89 50 04             	mov    %edx,0x4(%eax)
f0121b94:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121b97:	8b 00                	mov    (%eax),%eax
f0121b99:	85 c0                	test   %eax,%eax
f0121b9b:	75 08                	jne    f0121ba5 <merging+0x320>
f0121b9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121ba0:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121ba5:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121baa:	40                   	inc    %eax
f0121bab:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f0121bb0:	e9 ce 00 00 00       	jmp    f0121c83 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0121bb5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121bb9:	74 65                	je     f0121c20 <merging+0x39b>
f0121bbb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121bbf:	75 17                	jne    f0121bd8 <merging+0x353>
f0121bc1:	83 ec 04             	sub    $0x4,%esp
f0121bc4:	68 e4 1b 13 f0       	push   $0xf0131be4
f0121bc9:	68 95 01 00 00       	push   $0x195
f0121bce:	68 95 1b 13 f0       	push   $0xf0131b95
f0121bd3:	e8 61 e7 fd ff       	call   f0100339 <_panic>
f0121bd8:	8b 15 54 d3 b5 f0    	mov    0xf0b5d354,%edx
f0121bde:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121be1:	89 50 04             	mov    %edx,0x4(%eax)
f0121be4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121be7:	8b 40 04             	mov    0x4(%eax),%eax
f0121bea:	85 c0                	test   %eax,%eax
f0121bec:	74 0c                	je     f0121bfa <merging+0x375>
f0121bee:	a1 54 d3 b5 f0       	mov    0xf0b5d354,%eax
f0121bf3:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121bf6:	89 10                	mov    %edx,(%eax)
f0121bf8:	eb 08                	jmp    f0121c02 <merging+0x37d>
f0121bfa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121bfd:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121c02:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c05:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121c0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c0d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121c13:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121c18:	40                   	inc    %eax
f0121c19:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f0121c1e:	eb 63                	jmp    f0121c83 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f0121c20:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121c24:	75 17                	jne    f0121c3d <merging+0x3b8>
f0121c26:	83 ec 04             	sub    $0x4,%esp
f0121c29:	68 b0 1b 13 f0       	push   $0xf0131bb0
f0121c2e:	68 98 01 00 00       	push   $0x198
f0121c33:	68 95 1b 13 f0       	push   $0xf0131b95
f0121c38:	e8 fc e6 fd ff       	call   f0100339 <_panic>
f0121c3d:	8b 15 50 d3 b5 f0    	mov    0xf0b5d350,%edx
f0121c43:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c46:	89 10                	mov    %edx,(%eax)
f0121c48:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c4b:	8b 00                	mov    (%eax),%eax
f0121c4d:	85 c0                	test   %eax,%eax
f0121c4f:	74 0d                	je     f0121c5e <merging+0x3d9>
f0121c51:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0121c56:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121c59:	89 50 04             	mov    %edx,0x4(%eax)
f0121c5c:	eb 08                	jmp    f0121c66 <merging+0x3e1>
f0121c5e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c61:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121c66:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c69:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121c6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121c71:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121c78:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121c7d:	40                   	inc    %eax
f0121c7e:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
		}
		set_block_data(va, get_block_size(va), 0);
f0121c83:	83 ec 0c             	sub    $0xc,%esp
f0121c86:	ff 75 10             	pushl  0x10(%ebp)
f0121c89:	e8 f9 ed ff ff       	call   f0120a87 <get_block_size>
f0121c8e:	83 c4 10             	add    $0x10,%esp
f0121c91:	83 ec 04             	sub    $0x4,%esp
f0121c94:	6a 00                	push   $0x0
f0121c96:	50                   	push   %eax
f0121c97:	ff 75 10             	pushl  0x10(%ebp)
f0121c9a:	e8 39 f1 ff ff       	call   f0120dd8 <set_block_data>
f0121c9f:	83 c4 10             	add    $0x10,%esp
	}
}
f0121ca2:	90                   	nop
f0121ca3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121ca6:	c9                   	leave  
f0121ca7:	c3                   	ret    

f0121ca8 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121ca8:	55                   	push   %ebp
f0121ca9:	89 e5                	mov    %esp,%ebp
f0121cab:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f0121cae:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0121cb3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0121cb6:	a1 54 d3 b5 f0       	mov    0xf0b5d354,%eax
f0121cbb:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121cbe:	73 1b                	jae    f0121cdb <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f0121cc0:	a1 54 d3 b5 f0       	mov    0xf0b5d354,%eax
f0121cc5:	83 ec 04             	sub    $0x4,%esp
f0121cc8:	ff 75 08             	pushl  0x8(%ebp)
f0121ccb:	6a 00                	push   $0x0
f0121ccd:	50                   	push   %eax
f0121cce:	e8 b2 fb ff ff       	call   f0121885 <merging>
f0121cd3:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121cd6:	e9 8b 00 00 00       	jmp    f0121d66 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f0121cdb:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0121ce0:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121ce3:	76 18                	jbe    f0121cfd <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f0121ce5:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0121cea:	83 ec 04             	sub    $0x4,%esp
f0121ced:	ff 75 08             	pushl  0x8(%ebp)
f0121cf0:	50                   	push   %eax
f0121cf1:	6a 00                	push   $0x0
f0121cf3:	e8 8d fb ff ff       	call   f0121885 <merging>
f0121cf8:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121cfb:	eb 69                	jmp    f0121d66 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121cfd:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0121d02:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121d05:	eb 39                	jmp    f0121d40 <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f0121d07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d0a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121d0d:	73 29                	jae    f0121d38 <free_block+0x90>
f0121d0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d12:	8b 00                	mov    (%eax),%eax
f0121d14:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121d17:	76 1f                	jbe    f0121d38 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f0121d19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d1c:	8b 00                	mov    (%eax),%eax
f0121d1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f0121d21:	83 ec 04             	sub    $0x4,%esp
f0121d24:	ff 75 08             	pushl  0x8(%ebp)
f0121d27:	ff 75 f0             	pushl  -0x10(%ebp)
f0121d2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0121d2d:	e8 53 fb ff ff       	call   f0121885 <merging>
f0121d32:	83 c4 10             	add    $0x10,%esp
			break;
f0121d35:	90                   	nop
		}
	}
}
f0121d36:	eb 2e                	jmp    f0121d66 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121d38:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f0121d3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121d40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121d44:	74 07                	je     f0121d4d <free_block+0xa5>
f0121d46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121d49:	8b 00                	mov    (%eax),%eax
f0121d4b:	eb 05                	jmp    f0121d52 <free_block+0xaa>
f0121d4d:	b8 00 00 00 00       	mov    $0x0,%eax
f0121d52:	a3 58 d3 b5 f0       	mov    %eax,0xf0b5d358
f0121d57:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f0121d5c:	85 c0                	test   %eax,%eax
f0121d5e:	75 a7                	jne    f0121d07 <free_block+0x5f>
f0121d60:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121d64:	75 a1                	jne    f0121d07 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121d66:	90                   	nop
f0121d67:	c9                   	leave  
f0121d68:	c3                   	ret    

f0121d69 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121d69:	55                   	push   %ebp
f0121d6a:	89 e5                	mov    %esp,%ebp
f0121d6c:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f0121d6f:	ff 75 08             	pushl  0x8(%ebp)
f0121d72:	e8 10 ed ff ff       	call   f0120a87 <get_block_size>
f0121d77:	83 c4 04             	add    $0x4,%esp
f0121d7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f0121d7d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121d84:	eb 17                	jmp    f0121d9d <copy_data+0x34>
f0121d86:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121d89:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121d8c:	01 c2                	add    %eax,%edx
f0121d8e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0121d91:	8b 45 08             	mov    0x8(%ebp),%eax
f0121d94:	01 c8                	add    %ecx,%eax
f0121d96:	8a 00                	mov    (%eax),%al
f0121d98:	88 02                	mov    %al,(%edx)
f0121d9a:	ff 45 fc             	incl   -0x4(%ebp)
f0121d9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0121da0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0121da3:	72 e1                	jb     f0121d86 <copy_data+0x1d>
}
f0121da5:	90                   	nop
f0121da6:	c9                   	leave  
f0121da7:	c3                   	ret    

f0121da8 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121da8:	55                   	push   %ebp
f0121da9:	89 e5                	mov    %esp,%ebp
f0121dab:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f0121dae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121db2:	75 23                	jne    f0121dd7 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0121db4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121db8:	74 13                	je     f0121dcd <realloc_block_FF+0x25>
f0121dba:	83 ec 0c             	sub    $0xc,%esp
f0121dbd:	ff 75 0c             	pushl  0xc(%ebp)
f0121dc0:	e8 42 f0 ff ff       	call   f0120e07 <alloc_block_FF>
f0121dc5:	83 c4 10             	add    $0x10,%esp
f0121dc8:	e9 e4 06 00 00       	jmp    f01224b1 <realloc_block_FF+0x709>
		return NULL;
f0121dcd:	b8 00 00 00 00       	mov    $0x0,%eax
f0121dd2:	e9 da 06 00 00       	jmp    f01224b1 <realloc_block_FF+0x709>
	}

	if(new_size == 0)
f0121dd7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121ddb:	75 18                	jne    f0121df5 <realloc_block_FF+0x4d>
	{
		free_block(va);
f0121ddd:	83 ec 0c             	sub    $0xc,%esp
f0121de0:	ff 75 08             	pushl  0x8(%ebp)
f0121de3:	e8 c0 fe ff ff       	call   f0121ca8 <free_block>
f0121de8:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0121deb:	b8 00 00 00 00       	mov    $0x0,%eax
f0121df0:	e9 bc 06 00 00       	jmp    f01224b1 <realloc_block_FF+0x709>
	}


	if(new_size < 8) new_size = 8;
f0121df5:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0121df9:	77 07                	ja     f0121e02 <realloc_block_FF+0x5a>
f0121dfb:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f0121e02:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e05:	83 e0 01             	and    $0x1,%eax
f0121e08:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f0121e0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e0e:	83 c0 08             	add    $0x8,%eax
f0121e11:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0121e14:	83 ec 0c             	sub    $0xc,%esp
f0121e17:	ff 75 08             	pushl  0x8(%ebp)
f0121e1a:	e8 68 ec ff ff       	call   f0120a87 <get_block_size>
f0121e1f:	83 c4 10             	add    $0x10,%esp
f0121e22:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121e25:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121e28:	83 e8 08             	sub    $0x8,%eax
f0121e2b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f0121e2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e31:	83 e8 04             	sub    $0x4,%eax
f0121e34:	8b 00                	mov    (%eax),%eax
f0121e36:	83 e0 fe             	and    $0xfffffffe,%eax
f0121e39:	89 c2                	mov    %eax,%edx
f0121e3b:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e3e:	01 d0                	add    %edx,%eax
f0121e40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121e43:	83 ec 0c             	sub    $0xc,%esp
f0121e46:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121e49:	e8 39 ec ff ff       	call   f0120a87 <get_block_size>
f0121e4e:	83 c4 10             	add    $0x10,%esp
f0121e51:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121e54:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121e57:	83 e8 08             	sub    $0x8,%eax
f0121e5a:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121e5d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e60:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121e63:	75 08                	jne    f0121e6d <realloc_block_FF+0xc5>
	{
		 return va;
f0121e65:	8b 45 08             	mov    0x8(%ebp),%eax
f0121e68:	e9 44 06 00 00       	jmp    f01224b1 <realloc_block_FF+0x709>

	}


	if(new_size < cur_size)
f0121e6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e70:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121e73:	0f 83 d5 03 00 00    	jae    f012224e <realloc_block_FF+0x4a6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121e79:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121e7c:	2b 45 0c             	sub    0xc(%ebp),%eax
f0121e7f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121e82:	83 ec 0c             	sub    $0xc,%esp
f0121e85:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121e88:	e8 13 ec ff ff       	call   f0120aa0 <is_free_block>
f0121e8d:	83 c4 10             	add    $0x10,%esp
f0121e90:	84 c0                	test   %al,%al
f0121e92:	0f 84 3b 01 00 00    	je     f0121fd3 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121e98:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121e9b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121e9e:	01 d0                	add    %edx,%eax
f0121ea0:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121ea3:	83 ec 04             	sub    $0x4,%esp
f0121ea6:	6a 01                	push   $0x1
f0121ea8:	ff 75 f0             	pushl  -0x10(%ebp)
f0121eab:	ff 75 08             	pushl  0x8(%ebp)
f0121eae:	e8 25 ef ff ff       	call   f0120dd8 <set_block_data>
f0121eb3:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121eb6:	8b 45 08             	mov    0x8(%ebp),%eax
f0121eb9:	83 e8 04             	sub    $0x4,%eax
f0121ebc:	8b 00                	mov    (%eax),%eax
f0121ebe:	83 e0 fe             	and    $0xfffffffe,%eax
f0121ec1:	89 c2                	mov    %eax,%edx
f0121ec3:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ec6:	01 d0                	add    %edx,%eax
f0121ec8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121ecb:	83 ec 04             	sub    $0x4,%esp
f0121ece:	6a 00                	push   $0x0
f0121ed0:	ff 75 cc             	pushl  -0x34(%ebp)
f0121ed3:	ff 75 c8             	pushl  -0x38(%ebp)
f0121ed6:	e8 fd ee ff ff       	call   f0120dd8 <set_block_data>
f0121edb:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121ede:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121ee2:	74 06                	je     f0121eea <realloc_block_FF+0x142>
f0121ee4:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0121ee8:	75 17                	jne    f0121f01 <realloc_block_FF+0x159>
f0121eea:	83 ec 04             	sub    $0x4,%esp
f0121eed:	68 08 1c 13 f0       	push   $0xf0131c08
f0121ef2:	68 f6 01 00 00       	push   $0x1f6
f0121ef7:	68 95 1b 13 f0       	push   $0xf0131b95
f0121efc:	e8 38 e4 fd ff       	call   f0100339 <_panic>
f0121f01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f04:	8b 10                	mov    (%eax),%edx
f0121f06:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121f09:	89 10                	mov    %edx,(%eax)
f0121f0b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121f0e:	8b 00                	mov    (%eax),%eax
f0121f10:	85 c0                	test   %eax,%eax
f0121f12:	74 0b                	je     f0121f1f <realloc_block_FF+0x177>
f0121f14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f17:	8b 00                	mov    (%eax),%eax
f0121f19:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121f1c:	89 50 04             	mov    %edx,0x4(%eax)
f0121f1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f22:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121f25:	89 10                	mov    %edx,(%eax)
f0121f27:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121f2a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121f2d:	89 50 04             	mov    %edx,0x4(%eax)
f0121f30:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121f33:	8b 00                	mov    (%eax),%eax
f0121f35:	85 c0                	test   %eax,%eax
f0121f37:	75 08                	jne    f0121f41 <realloc_block_FF+0x199>
f0121f39:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121f3c:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121f41:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121f46:	40                   	inc    %eax
f0121f47:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121f4c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121f50:	75 17                	jne    f0121f69 <realloc_block_FF+0x1c1>
f0121f52:	83 ec 04             	sub    $0x4,%esp
f0121f55:	68 77 1b 13 f0       	push   $0xf0131b77
f0121f5a:	68 f7 01 00 00       	push   $0x1f7
f0121f5f:	68 95 1b 13 f0       	push   $0xf0131b95
f0121f64:	e8 d0 e3 fd ff       	call   f0100339 <_panic>
f0121f69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f6c:	8b 00                	mov    (%eax),%eax
f0121f6e:	85 c0                	test   %eax,%eax
f0121f70:	74 10                	je     f0121f82 <realloc_block_FF+0x1da>
f0121f72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f75:	8b 00                	mov    (%eax),%eax
f0121f77:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121f7a:	8b 52 04             	mov    0x4(%edx),%edx
f0121f7d:	89 50 04             	mov    %edx,0x4(%eax)
f0121f80:	eb 0b                	jmp    f0121f8d <realloc_block_FF+0x1e5>
f0121f82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f85:	8b 40 04             	mov    0x4(%eax),%eax
f0121f88:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0121f8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f90:	8b 40 04             	mov    0x4(%eax),%eax
f0121f93:	85 c0                	test   %eax,%eax
f0121f95:	74 0f                	je     f0121fa6 <realloc_block_FF+0x1fe>
f0121f97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121f9a:	8b 40 04             	mov    0x4(%eax),%eax
f0121f9d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121fa0:	8b 12                	mov    (%edx),%edx
f0121fa2:	89 10                	mov    %edx,(%eax)
f0121fa4:	eb 0a                	jmp    f0121fb0 <realloc_block_FF+0x208>
f0121fa6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fa9:	8b 00                	mov    (%eax),%eax
f0121fab:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0121fb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fb3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121fb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fbc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121fc3:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0121fc8:	48                   	dec    %eax
f0121fc9:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f0121fce:	e9 73 02 00 00       	jmp    f0122246 <realloc_block_FF+0x49e>
		}
		else
		{
			if(remaining_size>=16)
f0121fd3:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0121fd7:	0f 86 69 02 00 00    	jbe    f0122246 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0121fdd:	83 ec 04             	sub    $0x4,%esp
f0121fe0:	6a 01                	push   $0x1
f0121fe2:	ff 75 f0             	pushl  -0x10(%ebp)
f0121fe5:	ff 75 08             	pushl  0x8(%ebp)
f0121fe8:	e8 eb ed ff ff       	call   f0120dd8 <set_block_data>
f0121fed:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121ff0:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ff3:	83 e8 04             	sub    $0x4,%eax
f0121ff6:	8b 00                	mov    (%eax),%eax
f0121ff8:	83 e0 fe             	and    $0xfffffffe,%eax
f0121ffb:	89 c2                	mov    %eax,%edx
f0121ffd:	8b 45 08             	mov    0x8(%ebp),%eax
f0122000:	01 d0                	add    %edx,%eax
f0122002:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0122005:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f012200a:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f012200d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0122011:	75 68                	jne    f012207b <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0122013:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0122017:	75 17                	jne    f0122030 <realloc_block_FF+0x288>
f0122019:	83 ec 04             	sub    $0x4,%esp
f012201c:	68 b0 1b 13 f0       	push   $0xf0131bb0
f0122021:	68 06 02 00 00       	push   $0x206
f0122026:	68 95 1b 13 f0       	push   $0xf0131b95
f012202b:	e8 09 e3 fd ff       	call   f0100339 <_panic>
f0122030:	8b 15 50 d3 b5 f0    	mov    0xf0b5d350,%edx
f0122036:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122039:	89 10                	mov    %edx,(%eax)
f012203b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012203e:	8b 00                	mov    (%eax),%eax
f0122040:	85 c0                	test   %eax,%eax
f0122042:	74 0d                	je     f0122051 <realloc_block_FF+0x2a9>
f0122044:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0122049:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012204c:	89 50 04             	mov    %edx,0x4(%eax)
f012204f:	eb 08                	jmp    f0122059 <realloc_block_FF+0x2b1>
f0122051:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122054:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0122059:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012205c:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0122061:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122064:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012206b:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0122070:	40                   	inc    %eax
f0122071:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f0122076:	e9 b0 01 00 00       	jmp    f012222b <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f012207b:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f0122080:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0122083:	76 68                	jbe    f01220ed <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0122085:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0122089:	75 17                	jne    f01220a2 <realloc_block_FF+0x2fa>
f012208b:	83 ec 04             	sub    $0x4,%esp
f012208e:	68 b0 1b 13 f0       	push   $0xf0131bb0
f0122093:	68 0b 02 00 00       	push   $0x20b
f0122098:	68 95 1b 13 f0       	push   $0xf0131b95
f012209d:	e8 97 e2 fd ff       	call   f0100339 <_panic>
f01220a2:	8b 15 50 d3 b5 f0    	mov    0xf0b5d350,%edx
f01220a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01220ab:	89 10                	mov    %edx,(%eax)
f01220ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01220b0:	8b 00                	mov    (%eax),%eax
f01220b2:	85 c0                	test   %eax,%eax
f01220b4:	74 0d                	je     f01220c3 <realloc_block_FF+0x31b>
f01220b6:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f01220bb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01220be:	89 50 04             	mov    %edx,0x4(%eax)
f01220c1:	eb 08                	jmp    f01220cb <realloc_block_FF+0x323>
f01220c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01220c6:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f01220cb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01220ce:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f01220d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01220d6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01220dd:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01220e2:	40                   	inc    %eax
f01220e3:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f01220e8:	e9 3e 01 00 00       	jmp    f012222b <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f01220ed:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f01220f2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01220f5:	73 68                	jae    f012215f <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f01220f7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01220fb:	75 17                	jne    f0122114 <realloc_block_FF+0x36c>
f01220fd:	83 ec 04             	sub    $0x4,%esp
f0122100:	68 e4 1b 13 f0       	push   $0xf0131be4
f0122105:	68 10 02 00 00       	push   $0x210
f012210a:	68 95 1b 13 f0       	push   $0xf0131b95
f012210f:	e8 25 e2 fd ff       	call   f0100339 <_panic>
f0122114:	8b 15 54 d3 b5 f0    	mov    0xf0b5d354,%edx
f012211a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012211d:	89 50 04             	mov    %edx,0x4(%eax)
f0122120:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122123:	8b 40 04             	mov    0x4(%eax),%eax
f0122126:	85 c0                	test   %eax,%eax
f0122128:	74 0c                	je     f0122136 <realloc_block_FF+0x38e>
f012212a:	a1 54 d3 b5 f0       	mov    0xf0b5d354,%eax
f012212f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0122132:	89 10                	mov    %edx,(%eax)
f0122134:	eb 08                	jmp    f012213e <realloc_block_FF+0x396>
f0122136:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122139:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f012213e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122141:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0122146:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0122149:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012214f:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0122154:	40                   	inc    %eax
f0122155:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
f012215a:	e9 cc 00 00 00       	jmp    f012222b <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f012215f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0122166:	a1 50 d3 b5 f0       	mov    0xf0b5d350,%eax
f012216b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012216e:	e9 8a 00 00 00       	jmp    f01221fd <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0122173:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122176:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0122179:	73 7a                	jae    f01221f5 <realloc_block_FF+0x44d>
f012217b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012217e:	8b 00                	mov    (%eax),%eax
f0122180:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0122183:	73 70                	jae    f01221f5 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0122185:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122189:	74 06                	je     f0122191 <realloc_block_FF+0x3e9>
f012218b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f012218f:	75 17                	jne    f01221a8 <realloc_block_FF+0x400>
f0122191:	83 ec 04             	sub    $0x4,%esp
f0122194:	68 08 1c 13 f0       	push   $0xf0131c08
f0122199:	68 1a 02 00 00       	push   $0x21a
f012219e:	68 95 1b 13 f0       	push   $0xf0131b95
f01221a3:	e8 91 e1 fd ff       	call   f0100339 <_panic>
f01221a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01221ab:	8b 10                	mov    (%eax),%edx
f01221ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01221b0:	89 10                	mov    %edx,(%eax)
f01221b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01221b5:	8b 00                	mov    (%eax),%eax
f01221b7:	85 c0                	test   %eax,%eax
f01221b9:	74 0b                	je     f01221c6 <realloc_block_FF+0x41e>
f01221bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01221be:	8b 00                	mov    (%eax),%eax
f01221c0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01221c3:	89 50 04             	mov    %edx,0x4(%eax)
f01221c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01221c9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01221cc:	89 10                	mov    %edx,(%eax)
f01221ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01221d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01221d4:	89 50 04             	mov    %edx,0x4(%eax)
f01221d7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01221da:	8b 00                	mov    (%eax),%eax
f01221dc:	85 c0                	test   %eax,%eax
f01221de:	75 08                	jne    f01221e8 <realloc_block_FF+0x440>
f01221e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01221e3:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f01221e8:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f01221ed:	40                   	inc    %eax
f01221ee:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
							break;
f01221f3:	eb 36                	jmp    f012222b <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f01221f5:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f01221fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01221fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122201:	74 07                	je     f012220a <realloc_block_FF+0x462>
f0122203:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122206:	8b 00                	mov    (%eax),%eax
f0122208:	eb 05                	jmp    f012220f <realloc_block_FF+0x467>
f012220a:	b8 00 00 00 00       	mov    $0x0,%eax
f012220f:	a3 58 d3 b5 f0       	mov    %eax,0xf0b5d358
f0122214:	a1 58 d3 b5 f0       	mov    0xf0b5d358,%eax
f0122219:	85 c0                	test   %eax,%eax
f012221b:	0f 85 52 ff ff ff    	jne    f0122173 <realloc_block_FF+0x3cb>
f0122221:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122225:	0f 85 48 ff ff ff    	jne    f0122173 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f012222b:	83 ec 04             	sub    $0x4,%esp
f012222e:	6a 00                	push   $0x0
f0122230:	ff 75 d8             	pushl  -0x28(%ebp)
f0122233:	ff 75 d4             	pushl  -0x2c(%ebp)
f0122236:	e8 9d eb ff ff       	call   f0120dd8 <set_block_data>
f012223b:	83 c4 10             	add    $0x10,%esp
				return va;
f012223e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122241:	e9 6b 02 00 00       	jmp    f01224b1 <realloc_block_FF+0x709>
			}
			
		}
		return va;
f0122246:	8b 45 08             	mov    0x8(%ebp),%eax
f0122249:	e9 63 02 00 00       	jmp    f01224b1 <realloc_block_FF+0x709>
	}

	if(new_size > cur_size)
f012224e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122251:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0122254:	0f 86 4d 02 00 00    	jbe    f01224a7 <realloc_block_FF+0x6ff>
	{
		if(is_free_block(next_va))
f012225a:	83 ec 0c             	sub    $0xc,%esp
f012225d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0122260:	e8 3b e8 ff ff       	call   f0120aa0 <is_free_block>
f0122265:	83 c4 10             	add    $0x10,%esp
f0122268:	84 c0                	test   %al,%al
f012226a:	0f 84 37 02 00 00    	je     f01224a7 <realloc_block_FF+0x6ff>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0122270:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122273:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0122276:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0122279:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012227c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f012227f:	76 38                	jbe    f01222b9 <realloc_block_FF+0x511>
			{
				void *new_va = alloc_block_FF(new_size); //new allocation
f0122281:	83 ec 0c             	sub    $0xc,%esp
f0122284:	ff 75 0c             	pushl  0xc(%ebp)
f0122287:	e8 7b eb ff ff       	call   f0120e07 <alloc_block_FF>
f012228c:	83 c4 10             	add    $0x10,%esp
f012228f:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0122292:	83 ec 08             	sub    $0x8,%esp
f0122295:	ff 75 c0             	pushl  -0x40(%ebp)
f0122298:	ff 75 08             	pushl  0x8(%ebp)
f012229b:	e8 c9 fa ff ff       	call   f0121d69 <copy_data>
f01222a0:	83 c4 10             	add    $0x10,%esp
				free_block(va); //set it free
f01222a3:	83 ec 0c             	sub    $0xc,%esp
f01222a6:	ff 75 08             	pushl  0x8(%ebp)
f01222a9:	e8 fa f9 ff ff       	call   f0121ca8 <free_block>
f01222ae:	83 c4 10             	add    $0x10,%esp
				return new_va;
f01222b1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01222b4:	e9 f8 01 00 00       	jmp    f01224b1 <realloc_block_FF+0x709>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f01222b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01222bc:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f01222bf:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f01222c2:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f01222c6:	0f 87 a0 00 00 00    	ja     f012236c <realloc_block_FF+0x5c4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f01222cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01222d0:	75 17                	jne    f01222e9 <realloc_block_FF+0x541>
f01222d2:	83 ec 04             	sub    $0x4,%esp
f01222d5:	68 77 1b 13 f0       	push   $0xf0131b77
f01222da:	68 38 02 00 00       	push   $0x238
f01222df:	68 95 1b 13 f0       	push   $0xf0131b95
f01222e4:	e8 50 e0 fd ff       	call   f0100339 <_panic>
f01222e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222ec:	8b 00                	mov    (%eax),%eax
f01222ee:	85 c0                	test   %eax,%eax
f01222f0:	74 10                	je     f0122302 <realloc_block_FF+0x55a>
f01222f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01222f5:	8b 00                	mov    (%eax),%eax
f01222f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01222fa:	8b 52 04             	mov    0x4(%edx),%edx
f01222fd:	89 50 04             	mov    %edx,0x4(%eax)
f0122300:	eb 0b                	jmp    f012230d <realloc_block_FF+0x565>
f0122302:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122305:	8b 40 04             	mov    0x4(%eax),%eax
f0122308:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f012230d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122310:	8b 40 04             	mov    0x4(%eax),%eax
f0122313:	85 c0                	test   %eax,%eax
f0122315:	74 0f                	je     f0122326 <realloc_block_FF+0x57e>
f0122317:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012231a:	8b 40 04             	mov    0x4(%eax),%eax
f012231d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122320:	8b 12                	mov    (%edx),%edx
f0122322:	89 10                	mov    %edx,(%eax)
f0122324:	eb 0a                	jmp    f0122330 <realloc_block_FF+0x588>
f0122326:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122329:	8b 00                	mov    (%eax),%eax
f012232b:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0122330:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122333:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122339:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012233c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122343:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0122348:	48                   	dec    %eax
f0122349:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f012234e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122351:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0122354:	01 d0                	add    %edx,%eax
f0122356:	83 ec 04             	sub    $0x4,%esp
f0122359:	6a 01                	push   $0x1
f012235b:	50                   	push   %eax
f012235c:	ff 75 08             	pushl  0x8(%ebp)
f012235f:	e8 74 ea ff ff       	call   f0120dd8 <set_block_data>
f0122364:	83 c4 10             	add    $0x10,%esp
f0122367:	e9 36 01 00 00       	jmp    f01224a2 <realloc_block_FF+0x6fa>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f012236c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012236f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0122372:	01 d0                	add    %edx,%eax
f0122374:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0122377:	83 ec 04             	sub    $0x4,%esp
f012237a:	6a 01                	push   $0x1
f012237c:	ff 75 f0             	pushl  -0x10(%ebp)
f012237f:	ff 75 08             	pushl  0x8(%ebp)
f0122382:	e8 51 ea ff ff       	call   f0120dd8 <set_block_data>
f0122387:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f012238a:	8b 45 08             	mov    0x8(%ebp),%eax
f012238d:	83 e8 04             	sub    $0x4,%eax
f0122390:	8b 00                	mov    (%eax),%eax
f0122392:	83 e0 fe             	and    $0xfffffffe,%eax
f0122395:	89 c2                	mov    %eax,%edx
f0122397:	8b 45 08             	mov    0x8(%ebp),%eax
f012239a:	01 d0                	add    %edx,%eax
f012239c:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f012239f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01223a3:	74 06                	je     f01223ab <realloc_block_FF+0x603>
f01223a5:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f01223a9:	75 17                	jne    f01223c2 <realloc_block_FF+0x61a>
f01223ab:	83 ec 04             	sub    $0x4,%esp
f01223ae:	68 08 1c 13 f0       	push   $0xf0131c08
f01223b3:	68 44 02 00 00       	push   $0x244
f01223b8:	68 95 1b 13 f0       	push   $0xf0131b95
f01223bd:	e8 77 df fd ff       	call   f0100339 <_panic>
f01223c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01223c5:	8b 10                	mov    (%eax),%edx
f01223c7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01223ca:	89 10                	mov    %edx,(%eax)
f01223cc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01223cf:	8b 00                	mov    (%eax),%eax
f01223d1:	85 c0                	test   %eax,%eax
f01223d3:	74 0b                	je     f01223e0 <realloc_block_FF+0x638>
f01223d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01223d8:	8b 00                	mov    (%eax),%eax
f01223da:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01223dd:	89 50 04             	mov    %edx,0x4(%eax)
f01223e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01223e3:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01223e6:	89 10                	mov    %edx,(%eax)
f01223e8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01223eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01223ee:	89 50 04             	mov    %edx,0x4(%eax)
f01223f1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01223f4:	8b 00                	mov    (%eax),%eax
f01223f6:	85 c0                	test   %eax,%eax
f01223f8:	75 08                	jne    f0122402 <realloc_block_FF+0x65a>
f01223fa:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01223fd:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f0122402:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0122407:	40                   	inc    %eax
f0122408:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f012240d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122411:	75 17                	jne    f012242a <realloc_block_FF+0x682>
f0122413:	83 ec 04             	sub    $0x4,%esp
f0122416:	68 77 1b 13 f0       	push   $0xf0131b77
f012241b:	68 45 02 00 00       	push   $0x245
f0122420:	68 95 1b 13 f0       	push   $0xf0131b95
f0122425:	e8 0f df fd ff       	call   f0100339 <_panic>
f012242a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012242d:	8b 00                	mov    (%eax),%eax
f012242f:	85 c0                	test   %eax,%eax
f0122431:	74 10                	je     f0122443 <realloc_block_FF+0x69b>
f0122433:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122436:	8b 00                	mov    (%eax),%eax
f0122438:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012243b:	8b 52 04             	mov    0x4(%edx),%edx
f012243e:	89 50 04             	mov    %edx,0x4(%eax)
f0122441:	eb 0b                	jmp    f012244e <realloc_block_FF+0x6a6>
f0122443:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122446:	8b 40 04             	mov    0x4(%eax),%eax
f0122449:	a3 54 d3 b5 f0       	mov    %eax,0xf0b5d354
f012244e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122451:	8b 40 04             	mov    0x4(%eax),%eax
f0122454:	85 c0                	test   %eax,%eax
f0122456:	74 0f                	je     f0122467 <realloc_block_FF+0x6bf>
f0122458:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012245b:	8b 40 04             	mov    0x4(%eax),%eax
f012245e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122461:	8b 12                	mov    (%edx),%edx
f0122463:	89 10                	mov    %edx,(%eax)
f0122465:	eb 0a                	jmp    f0122471 <realloc_block_FF+0x6c9>
f0122467:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012246a:	8b 00                	mov    (%eax),%eax
f012246c:	a3 50 d3 b5 f0       	mov    %eax,0xf0b5d350
f0122471:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122474:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012247a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012247d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122484:	a1 5c d3 b5 f0       	mov    0xf0b5d35c,%eax
f0122489:	48                   	dec    %eax
f012248a:	a3 5c d3 b5 f0       	mov    %eax,0xf0b5d35c
				set_block_data(next_new_va, remaining_size, 0);
f012248f:	83 ec 04             	sub    $0x4,%esp
f0122492:	6a 00                	push   $0x0
f0122494:	ff 75 bc             	pushl  -0x44(%ebp)
f0122497:	ff 75 b8             	pushl  -0x48(%ebp)
f012249a:	e8 39 e9 ff ff       	call   f0120dd8 <set_block_data>
f012249f:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f01224a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01224a5:	eb 0a                	jmp    f01224b1 <realloc_block_FF+0x709>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f01224a7:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f01224ae:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01224b1:	c9                   	leave  
f01224b2:	c3                   	ret    

f01224b3 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f01224b3:	55                   	push   %ebp
f01224b4:	89 e5                	mov    %esp,%ebp
f01224b6:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f01224b9:	83 ec 04             	sub    $0x4,%esp
f01224bc:	68 74 1c 13 f0       	push   $0xf0131c74
f01224c1:	68 58 02 00 00       	push   $0x258
f01224c6:	68 95 1b 13 f0       	push   $0xf0131b95
f01224cb:	e8 69 de fd ff       	call   f0100339 <_panic>

f01224d0 <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f01224d0:	55                   	push   %ebp
f01224d1:	89 e5                	mov    %esp,%ebp
f01224d3:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f01224d6:	83 ec 04             	sub    $0x4,%esp
f01224d9:	68 9c 1c 13 f0       	push   $0xf0131c9c
f01224de:	68 61 02 00 00       	push   $0x261
f01224e3:	68 95 1b 13 f0       	push   $0xf0131b95
f01224e8:	e8 4c de fd ff       	call   f0100339 <_panic>
f01224ed:	66 90                	xchg   %ax,%ax
f01224ef:	90                   	nop

f01224f0 <__moddi3>:
f01224f0:	55                   	push   %ebp
f01224f1:	57                   	push   %edi
f01224f2:	56                   	push   %esi
f01224f3:	53                   	push   %ebx
f01224f4:	83 ec 2c             	sub    $0x2c,%esp
f01224f7:	8b 74 24 40          	mov    0x40(%esp),%esi
f01224fb:	8b 7c 24 44          	mov    0x44(%esp),%edi
f01224ff:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0122503:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0122507:	89 d8                	mov    %ebx,%eax
f0122509:	85 ff                	test   %edi,%edi
f012250b:	0f 88 d3 00 00 00    	js     f01225e4 <__moddi3+0xf4>
f0122511:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0122518:	00 
f0122519:	85 c0                	test   %eax,%eax
f012251b:	0f 88 ab 00 00 00    	js     f01225cc <__moddi3+0xdc>
f0122521:	89 0c 24             	mov    %ecx,(%esp)
f0122524:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0122528:	89 74 24 10          	mov    %esi,0x10(%esp)
f012252c:	89 fb                	mov    %edi,%ebx
f012252e:	8b 14 24             	mov    (%esp),%edx
f0122531:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0122535:	89 d0                	mov    %edx,%eax
f0122537:	89 54 24 18          	mov    %edx,0x18(%esp)
f012253b:	89 ca                	mov    %ecx,%edx
f012253d:	8b 0c 24             	mov    (%esp),%ecx
f0122540:	89 34 24             	mov    %esi,(%esp)
f0122543:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0122547:	85 d2                	test   %edx,%edx
f0122549:	75 15                	jne    f0122560 <__moddi3+0x70>
f012254b:	89 c7                	mov    %eax,%edi
f012254d:	39 d8                	cmp    %ebx,%eax
f012254f:	76 5b                	jbe    f01225ac <__moddi3+0xbc>
f0122551:	89 f0                	mov    %esi,%eax
f0122553:	89 da                	mov    %ebx,%edx
f0122555:	f7 f7                	div    %edi
f0122557:	89 d3                	mov    %edx,%ebx
f0122559:	89 d8                	mov    %ebx,%eax
f012255b:	31 d2                	xor    %edx,%edx
f012255d:	eb 09                	jmp    f0122568 <__moddi3+0x78>
f012255f:	90                   	nop
f0122560:	39 fa                	cmp    %edi,%edx
f0122562:	76 1c                	jbe    f0122580 <__moddi3+0x90>
f0122564:	89 f0                	mov    %esi,%eax
f0122566:	89 fa                	mov    %edi,%edx
f0122568:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f012256c:	85 c9                	test   %ecx,%ecx
f012256e:	74 07                	je     f0122577 <__moddi3+0x87>
f0122570:	f7 d8                	neg    %eax
f0122572:	83 d2 00             	adc    $0x0,%edx
f0122575:	f7 da                	neg    %edx
f0122577:	83 c4 2c             	add    $0x2c,%esp
f012257a:	5b                   	pop    %ebx
f012257b:	5e                   	pop    %esi
f012257c:	5f                   	pop    %edi
f012257d:	5d                   	pop    %ebp
f012257e:	c3                   	ret    
f012257f:	90                   	nop
f0122580:	0f bd c2             	bsr    %edx,%eax
f0122583:	83 f0 1f             	xor    $0x1f,%eax
f0122586:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f012258a:	75 6c                	jne    f01225f8 <__moddi3+0x108>
f012258c:	39 fa                	cmp    %edi,%edx
f012258e:	72 05                	jb     f0122595 <__moddi3+0xa5>
f0122590:	3b 0c 24             	cmp    (%esp),%ecx
f0122593:	77 0e                	ja     f01225a3 <__moddi3+0xb3>
f0122595:	8b 34 24             	mov    (%esp),%esi
f0122598:	29 ce                	sub    %ecx,%esi
f012259a:	19 d3                	sbb    %edx,%ebx
f012259c:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f01225a0:	89 34 24             	mov    %esi,(%esp)
f01225a3:	8b 04 24             	mov    (%esp),%eax
f01225a6:	8b 54 24 14          	mov    0x14(%esp),%edx
f01225aa:	eb bc                	jmp    f0122568 <__moddi3+0x78>
f01225ac:	85 c9                	test   %ecx,%ecx
f01225ae:	75 0b                	jne    f01225bb <__moddi3+0xcb>
f01225b0:	b8 01 00 00 00       	mov    $0x1,%eax
f01225b5:	31 d2                	xor    %edx,%edx
f01225b7:	f7 f1                	div    %ecx
f01225b9:	89 c1                	mov    %eax,%ecx
f01225bb:	89 d8                	mov    %ebx,%eax
f01225bd:	31 d2                	xor    %edx,%edx
f01225bf:	f7 f1                	div    %ecx
f01225c1:	8b 04 24             	mov    (%esp),%eax
f01225c4:	f7 f1                	div    %ecx
f01225c6:	89 d3                	mov    %edx,%ebx
f01225c8:	eb 8f                	jmp    f0122559 <__moddi3+0x69>
f01225ca:	66 90                	xchg   %ax,%ax
f01225cc:	89 c8                	mov    %ecx,%eax
f01225ce:	89 da                	mov    %ebx,%edx
f01225d0:	f7 d8                	neg    %eax
f01225d2:	83 d2 00             	adc    $0x0,%edx
f01225d5:	f7 da                	neg    %edx
f01225d7:	89 04 24             	mov    %eax,(%esp)
f01225da:	89 54 24 04          	mov    %edx,0x4(%esp)
f01225de:	e9 45 ff ff ff       	jmp    f0122528 <__moddi3+0x38>
f01225e3:	90                   	nop
f01225e4:	f7 de                	neg    %esi
f01225e6:	83 d7 00             	adc    $0x0,%edi
f01225e9:	f7 df                	neg    %edi
f01225eb:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f01225f2:	ff 
f01225f3:	e9 21 ff ff ff       	jmp    f0122519 <__moddi3+0x29>
f01225f8:	b8 20 00 00 00       	mov    $0x20,%eax
f01225fd:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0122601:	29 f8                	sub    %edi,%eax
f0122603:	89 c6                	mov    %eax,%esi
f0122605:	89 44 24 14          	mov    %eax,0x14(%esp)
f0122609:	89 f9                	mov    %edi,%ecx
f012260b:	d3 e2                	shl    %cl,%edx
f012260d:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0122611:	89 e8                	mov    %ebp,%eax
f0122613:	89 f1                	mov    %esi,%ecx
f0122615:	d3 e8                	shr    %cl,%eax
f0122617:	09 d0                	or     %edx,%eax
f0122619:	89 04 24             	mov    %eax,(%esp)
f012261c:	89 ea                	mov    %ebp,%edx
f012261e:	89 f9                	mov    %edi,%ecx
f0122620:	d3 e2                	shl    %cl,%edx
f0122622:	89 d7                	mov    %edx,%edi
f0122624:	89 da                	mov    %ebx,%edx
f0122626:	d3 e2                	shl    %cl,%edx
f0122628:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f012262c:	d3 e5                	shl    %cl,%ebp
f012262e:	8b 44 24 10          	mov    0x10(%esp),%eax
f0122632:	89 f1                	mov    %esi,%ecx
f0122634:	d3 e8                	shr    %cl,%eax
f0122636:	09 d0                	or     %edx,%eax
f0122638:	d3 eb                	shr    %cl,%ebx
f012263a:	89 da                	mov    %ebx,%edx
f012263c:	f7 34 24             	divl   (%esp)
f012263f:	89 d3                	mov    %edx,%ebx
f0122641:	f7 e7                	mul    %edi
f0122643:	89 c6                	mov    %eax,%esi
f0122645:	89 d1                	mov    %edx,%ecx
f0122647:	39 d3                	cmp    %edx,%ebx
f0122649:	72 29                	jb     f0122674 <__moddi3+0x184>
f012264b:	74 33                	je     f0122680 <__moddi3+0x190>
f012264d:	89 e8                	mov    %ebp,%eax
f012264f:	29 f0                	sub    %esi,%eax
f0122651:	19 cb                	sbb    %ecx,%ebx
f0122653:	89 de                	mov    %ebx,%esi
f0122655:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0122659:	d3 e6                	shl    %cl,%esi
f012265b:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f012265f:	89 f9                	mov    %edi,%ecx
f0122661:	d3 e8                	shr    %cl,%eax
f0122663:	09 c6                	or     %eax,%esi
f0122665:	89 f0                	mov    %esi,%eax
f0122667:	89 f9                	mov    %edi,%ecx
f0122669:	d3 eb                	shr    %cl,%ebx
f012266b:	89 da                	mov    %ebx,%edx
f012266d:	e9 f6 fe ff ff       	jmp    f0122568 <__moddi3+0x78>
f0122672:	66 90                	xchg   %ax,%ax
f0122674:	29 f8                	sub    %edi,%eax
f0122676:	1b 14 24             	sbb    (%esp),%edx
f0122679:	89 d1                	mov    %edx,%ecx
f012267b:	89 c6                	mov    %eax,%esi
f012267d:	eb ce                	jmp    f012264d <__moddi3+0x15d>
f012267f:	90                   	nop
f0122680:	39 c5                	cmp    %eax,%ebp
f0122682:	72 f0                	jb     f0122674 <__moddi3+0x184>
f0122684:	89 d9                	mov    %ebx,%ecx
f0122686:	eb c5                	jmp    f012264d <__moddi3+0x15d>

f0122688 <__udivdi3>:
f0122688:	55                   	push   %ebp
f0122689:	57                   	push   %edi
f012268a:	56                   	push   %esi
f012268b:	53                   	push   %ebx
f012268c:	83 ec 1c             	sub    $0x1c,%esp
f012268f:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0122693:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0122697:	8b 7c 24 38          	mov    0x38(%esp),%edi
f012269b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f012269f:	89 ca                	mov    %ecx,%edx
f01226a1:	89 f8                	mov    %edi,%eax
f01226a3:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f01226a7:	85 f6                	test   %esi,%esi
f01226a9:	75 2d                	jne    f01226d8 <__udivdi3+0x50>
f01226ab:	39 cf                	cmp    %ecx,%edi
f01226ad:	77 65                	ja     f0122714 <__udivdi3+0x8c>
f01226af:	89 fd                	mov    %edi,%ebp
f01226b1:	85 ff                	test   %edi,%edi
f01226b3:	75 0b                	jne    f01226c0 <__udivdi3+0x38>
f01226b5:	b8 01 00 00 00       	mov    $0x1,%eax
f01226ba:	31 d2                	xor    %edx,%edx
f01226bc:	f7 f7                	div    %edi
f01226be:	89 c5                	mov    %eax,%ebp
f01226c0:	31 d2                	xor    %edx,%edx
f01226c2:	89 c8                	mov    %ecx,%eax
f01226c4:	f7 f5                	div    %ebp
f01226c6:	89 c1                	mov    %eax,%ecx
f01226c8:	89 d8                	mov    %ebx,%eax
f01226ca:	f7 f5                	div    %ebp
f01226cc:	89 cf                	mov    %ecx,%edi
f01226ce:	89 fa                	mov    %edi,%edx
f01226d0:	83 c4 1c             	add    $0x1c,%esp
f01226d3:	5b                   	pop    %ebx
f01226d4:	5e                   	pop    %esi
f01226d5:	5f                   	pop    %edi
f01226d6:	5d                   	pop    %ebp
f01226d7:	c3                   	ret    
f01226d8:	39 ce                	cmp    %ecx,%esi
f01226da:	77 28                	ja     f0122704 <__udivdi3+0x7c>
f01226dc:	0f bd fe             	bsr    %esi,%edi
f01226df:	83 f7 1f             	xor    $0x1f,%edi
f01226e2:	75 40                	jne    f0122724 <__udivdi3+0x9c>
f01226e4:	39 ce                	cmp    %ecx,%esi
f01226e6:	72 0a                	jb     f01226f2 <__udivdi3+0x6a>
f01226e8:	3b 44 24 08          	cmp    0x8(%esp),%eax
f01226ec:	0f 87 9e 00 00 00    	ja     f0122790 <__udivdi3+0x108>
f01226f2:	b8 01 00 00 00       	mov    $0x1,%eax
f01226f7:	89 fa                	mov    %edi,%edx
f01226f9:	83 c4 1c             	add    $0x1c,%esp
f01226fc:	5b                   	pop    %ebx
f01226fd:	5e                   	pop    %esi
f01226fe:	5f                   	pop    %edi
f01226ff:	5d                   	pop    %ebp
f0122700:	c3                   	ret    
f0122701:	8d 76 00             	lea    0x0(%esi),%esi
f0122704:	31 ff                	xor    %edi,%edi
f0122706:	31 c0                	xor    %eax,%eax
f0122708:	89 fa                	mov    %edi,%edx
f012270a:	83 c4 1c             	add    $0x1c,%esp
f012270d:	5b                   	pop    %ebx
f012270e:	5e                   	pop    %esi
f012270f:	5f                   	pop    %edi
f0122710:	5d                   	pop    %ebp
f0122711:	c3                   	ret    
f0122712:	66 90                	xchg   %ax,%ax
f0122714:	89 d8                	mov    %ebx,%eax
f0122716:	f7 f7                	div    %edi
f0122718:	31 ff                	xor    %edi,%edi
f012271a:	89 fa                	mov    %edi,%edx
f012271c:	83 c4 1c             	add    $0x1c,%esp
f012271f:	5b                   	pop    %ebx
f0122720:	5e                   	pop    %esi
f0122721:	5f                   	pop    %edi
f0122722:	5d                   	pop    %ebp
f0122723:	c3                   	ret    
f0122724:	bd 20 00 00 00       	mov    $0x20,%ebp
f0122729:	89 eb                	mov    %ebp,%ebx
f012272b:	29 fb                	sub    %edi,%ebx
f012272d:	89 f9                	mov    %edi,%ecx
f012272f:	d3 e6                	shl    %cl,%esi
f0122731:	89 c5                	mov    %eax,%ebp
f0122733:	88 d9                	mov    %bl,%cl
f0122735:	d3 ed                	shr    %cl,%ebp
f0122737:	89 e9                	mov    %ebp,%ecx
f0122739:	09 f1                	or     %esi,%ecx
f012273b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f012273f:	89 f9                	mov    %edi,%ecx
f0122741:	d3 e0                	shl    %cl,%eax
f0122743:	89 c5                	mov    %eax,%ebp
f0122745:	89 d6                	mov    %edx,%esi
f0122747:	88 d9                	mov    %bl,%cl
f0122749:	d3 ee                	shr    %cl,%esi
f012274b:	89 f9                	mov    %edi,%ecx
f012274d:	d3 e2                	shl    %cl,%edx
f012274f:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122753:	88 d9                	mov    %bl,%cl
f0122755:	d3 e8                	shr    %cl,%eax
f0122757:	09 c2                	or     %eax,%edx
f0122759:	89 d0                	mov    %edx,%eax
f012275b:	89 f2                	mov    %esi,%edx
f012275d:	f7 74 24 0c          	divl   0xc(%esp)
f0122761:	89 d6                	mov    %edx,%esi
f0122763:	89 c3                	mov    %eax,%ebx
f0122765:	f7 e5                	mul    %ebp
f0122767:	39 d6                	cmp    %edx,%esi
f0122769:	72 19                	jb     f0122784 <__udivdi3+0xfc>
f012276b:	74 0b                	je     f0122778 <__udivdi3+0xf0>
f012276d:	89 d8                	mov    %ebx,%eax
f012276f:	31 ff                	xor    %edi,%edi
f0122771:	e9 58 ff ff ff       	jmp    f01226ce <__udivdi3+0x46>
f0122776:	66 90                	xchg   %ax,%ax
f0122778:	8b 54 24 08          	mov    0x8(%esp),%edx
f012277c:	89 f9                	mov    %edi,%ecx
f012277e:	d3 e2                	shl    %cl,%edx
f0122780:	39 c2                	cmp    %eax,%edx
f0122782:	73 e9                	jae    f012276d <__udivdi3+0xe5>
f0122784:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0122787:	31 ff                	xor    %edi,%edi
f0122789:	e9 40 ff ff ff       	jmp    f01226ce <__udivdi3+0x46>
f012278e:	66 90                	xchg   %ax,%ax
f0122790:	31 c0                	xor    %eax,%eax
f0122792:	e9 37 ff ff ff       	jmp    f01226ce <__udivdi3+0x46>
f0122797:	90                   	nop

f0122798 <__umoddi3>:
f0122798:	55                   	push   %ebp
f0122799:	57                   	push   %edi
f012279a:	56                   	push   %esi
f012279b:	53                   	push   %ebx
f012279c:	83 ec 1c             	sub    $0x1c,%esp
f012279f:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f01227a3:	8b 74 24 34          	mov    0x34(%esp),%esi
f01227a7:	8b 7c 24 38          	mov    0x38(%esp),%edi
f01227ab:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f01227af:	89 44 24 0c          	mov    %eax,0xc(%esp)
f01227b3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f01227b7:	89 f3                	mov    %esi,%ebx
f01227b9:	89 fa                	mov    %edi,%edx
f01227bb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f01227bf:	89 34 24             	mov    %esi,(%esp)
f01227c2:	85 c0                	test   %eax,%eax
f01227c4:	75 1a                	jne    f01227e0 <__umoddi3+0x48>
f01227c6:	39 f7                	cmp    %esi,%edi
f01227c8:	0f 86 a2 00 00 00    	jbe    f0122870 <__umoddi3+0xd8>
f01227ce:	89 c8                	mov    %ecx,%eax
f01227d0:	89 f2                	mov    %esi,%edx
f01227d2:	f7 f7                	div    %edi
f01227d4:	89 d0                	mov    %edx,%eax
f01227d6:	31 d2                	xor    %edx,%edx
f01227d8:	83 c4 1c             	add    $0x1c,%esp
f01227db:	5b                   	pop    %ebx
f01227dc:	5e                   	pop    %esi
f01227dd:	5f                   	pop    %edi
f01227de:	5d                   	pop    %ebp
f01227df:	c3                   	ret    
f01227e0:	39 f0                	cmp    %esi,%eax
f01227e2:	0f 87 ac 00 00 00    	ja     f0122894 <__umoddi3+0xfc>
f01227e8:	0f bd e8             	bsr    %eax,%ebp
f01227eb:	83 f5 1f             	xor    $0x1f,%ebp
f01227ee:	0f 84 ac 00 00 00    	je     f01228a0 <__umoddi3+0x108>
f01227f4:	bf 20 00 00 00       	mov    $0x20,%edi
f01227f9:	29 ef                	sub    %ebp,%edi
f01227fb:	89 fe                	mov    %edi,%esi
f01227fd:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0122801:	89 e9                	mov    %ebp,%ecx
f0122803:	d3 e0                	shl    %cl,%eax
f0122805:	89 d7                	mov    %edx,%edi
f0122807:	89 f1                	mov    %esi,%ecx
f0122809:	d3 ef                	shr    %cl,%edi
f012280b:	09 c7                	or     %eax,%edi
f012280d:	89 e9                	mov    %ebp,%ecx
f012280f:	d3 e2                	shl    %cl,%edx
f0122811:	89 14 24             	mov    %edx,(%esp)
f0122814:	89 d8                	mov    %ebx,%eax
f0122816:	d3 e0                	shl    %cl,%eax
f0122818:	89 c2                	mov    %eax,%edx
f012281a:	8b 44 24 08          	mov    0x8(%esp),%eax
f012281e:	d3 e0                	shl    %cl,%eax
f0122820:	89 44 24 04          	mov    %eax,0x4(%esp)
f0122824:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122828:	89 f1                	mov    %esi,%ecx
f012282a:	d3 e8                	shr    %cl,%eax
f012282c:	09 d0                	or     %edx,%eax
f012282e:	d3 eb                	shr    %cl,%ebx
f0122830:	89 da                	mov    %ebx,%edx
f0122832:	f7 f7                	div    %edi
f0122834:	89 d3                	mov    %edx,%ebx
f0122836:	f7 24 24             	mull   (%esp)
f0122839:	89 c6                	mov    %eax,%esi
f012283b:	89 d1                	mov    %edx,%ecx
f012283d:	39 d3                	cmp    %edx,%ebx
f012283f:	0f 82 87 00 00 00    	jb     f01228cc <__umoddi3+0x134>
f0122845:	0f 84 91 00 00 00    	je     f01228dc <__umoddi3+0x144>
f012284b:	8b 54 24 04          	mov    0x4(%esp),%edx
f012284f:	29 f2                	sub    %esi,%edx
f0122851:	19 cb                	sbb    %ecx,%ebx
f0122853:	89 d8                	mov    %ebx,%eax
f0122855:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0122859:	d3 e0                	shl    %cl,%eax
f012285b:	89 e9                	mov    %ebp,%ecx
f012285d:	d3 ea                	shr    %cl,%edx
f012285f:	09 d0                	or     %edx,%eax
f0122861:	89 e9                	mov    %ebp,%ecx
f0122863:	d3 eb                	shr    %cl,%ebx
f0122865:	89 da                	mov    %ebx,%edx
f0122867:	83 c4 1c             	add    $0x1c,%esp
f012286a:	5b                   	pop    %ebx
f012286b:	5e                   	pop    %esi
f012286c:	5f                   	pop    %edi
f012286d:	5d                   	pop    %ebp
f012286e:	c3                   	ret    
f012286f:	90                   	nop
f0122870:	89 fd                	mov    %edi,%ebp
f0122872:	85 ff                	test   %edi,%edi
f0122874:	75 0b                	jne    f0122881 <__umoddi3+0xe9>
f0122876:	b8 01 00 00 00       	mov    $0x1,%eax
f012287b:	31 d2                	xor    %edx,%edx
f012287d:	f7 f7                	div    %edi
f012287f:	89 c5                	mov    %eax,%ebp
f0122881:	89 f0                	mov    %esi,%eax
f0122883:	31 d2                	xor    %edx,%edx
f0122885:	f7 f5                	div    %ebp
f0122887:	89 c8                	mov    %ecx,%eax
f0122889:	f7 f5                	div    %ebp
f012288b:	89 d0                	mov    %edx,%eax
f012288d:	e9 44 ff ff ff       	jmp    f01227d6 <__umoddi3+0x3e>
f0122892:	66 90                	xchg   %ax,%ax
f0122894:	89 c8                	mov    %ecx,%eax
f0122896:	89 f2                	mov    %esi,%edx
f0122898:	83 c4 1c             	add    $0x1c,%esp
f012289b:	5b                   	pop    %ebx
f012289c:	5e                   	pop    %esi
f012289d:	5f                   	pop    %edi
f012289e:	5d                   	pop    %ebp
f012289f:	c3                   	ret    
f01228a0:	3b 04 24             	cmp    (%esp),%eax
f01228a3:	72 06                	jb     f01228ab <__umoddi3+0x113>
f01228a5:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f01228a9:	77 0f                	ja     f01228ba <__umoddi3+0x122>
f01228ab:	89 f2                	mov    %esi,%edx
f01228ad:	29 f9                	sub    %edi,%ecx
f01228af:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f01228b3:	89 14 24             	mov    %edx,(%esp)
f01228b6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f01228ba:	8b 44 24 04          	mov    0x4(%esp),%eax
f01228be:	8b 14 24             	mov    (%esp),%edx
f01228c1:	83 c4 1c             	add    $0x1c,%esp
f01228c4:	5b                   	pop    %ebx
f01228c5:	5e                   	pop    %esi
f01228c6:	5f                   	pop    %edi
f01228c7:	5d                   	pop    %ebp
f01228c8:	c3                   	ret    
f01228c9:	8d 76 00             	lea    0x0(%esi),%esi
f01228cc:	2b 04 24             	sub    (%esp),%eax
f01228cf:	19 fa                	sbb    %edi,%edx
f01228d1:	89 d1                	mov    %edx,%ecx
f01228d3:	89 c6                	mov    %eax,%esi
f01228d5:	e9 71 ff ff ff       	jmp    f012284b <__umoddi3+0xb3>
f01228da:	66 90                	xchg   %ax,%ax
f01228dc:	39 44 24 04          	cmp    %eax,0x4(%esp)
f01228e0:	72 ea                	jb     f01228cc <__umoddi3+0x134>
f01228e2:	89 d9                	mov    %ebx,%ecx
f01228e4:	e9 62 ff ff ff       	jmp    f012284b <__umoddi3+0xb3>
