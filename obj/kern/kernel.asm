
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 78 1b 6c f0 01 	movl   $0x1,0xf06c1b78
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 c4 1a 6c f0 01 	movl   $0x1,0xf06c1ac4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba d0 d7 b0 f0       	mov    $0xf0b0d7d0,%edx
f010006a:	b8 84 88 69 f0       	mov    $0xf0698884,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 84 88 69 f0       	push   $0xf0698884
f010007e:	e8 41 fe 01 00       	call   f011fec4 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 e0 25 12 f0       	push   $0xf01225e0
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 27 26 12 f0       	push   $0xf0122627
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 3b 26 12 f0       	push   $0xf012263b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 4f 26 12 f0       	push   $0xf012264f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 3c 70 00 00       	call   f0107116 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 5b 26 12 f0       	push   $0xf012265b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 63 26 12 f0       	push   $0xf0122663
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 81 79 00 00       	call   f0107a83 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 22 75 00 00       	call   f0107629 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 c2 7c 00 00       	call   f0107dce <initialize_paging>
		sharing_init();
f010010c:	e8 33 89 00 00       	call   f0108a44 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 2d 92 00 00       	call   f0109355 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 5d f5 00 00       	call   f010f68d <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 46 f6 00 00       	call   f010f78a <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 21 f6 00 00       	call   f010f772 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 41 f6 00 00       	call   f010f7a2 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 b2 02 02 00       	call   f012041b <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 71 26 12 f0       	push   $0xf0122671
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 c7 ac 00 00       	call   f010ae45 <env_init>
		ts_init();
f010017e:	e8 ab ce 00 00       	call   f010d02e <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 5b 26 12 f0       	push   $0xf012265b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 84 26 12 f0       	push   $0xf0122684
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 5a 6c 00 00       	call   f0106e02 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 ad 26 12 f0       	push   $0xf01226ad
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 32 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 c3 26 12 f0       	push   $0xf01226c3
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 15 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 e0 26 12 f0       	push   $0xf01226e0
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 f8 6d 00 00       	call   f0106ff4 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 ff 26 12 f0       	push   $0xf01226ff
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 1c 27 12 f0       	push   $0xf012271c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 d4 49 00 00       	call   f0104bf8 <kclock_init>
		sched_init() ;
f0100224:	e8 04 65 00 00       	call   f010672d <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 40 27 12 f0       	push   $0xf0122740
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 60 27 12 f0       	push   $0xf0122760
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 84 27 12 f0       	push   $0xf0122784
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 dc 2d 6c f0 00 	movl   $0x0,0xf06c2ddc
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 cc 27 12 f0       	push   $0xf01227cc
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 f8 27 12 f0       	push   $0xf01227f8
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 1d 28 12 f0       	push   $0xf012281d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 24 28 12 f0       	push   $0xf0122824
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 6c 28 12 f0       	push   $0xf012286c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 b4 28 12 f0       	push   $0xf01228b4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 6c 28 12 f0       	push   $0xf012286c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 24 28 12 f0       	push   $0xf0122824
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 f9 28 12 f0       	push   $0xf01228f9
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 55 b7 00 00       	call   f010ba99 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 a0 88 69 f0       	mov    %eax,0xf06988a0

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 00 29 12 f0       	push   $0xf0122900
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 25 29 12 f0       	push   $0xf0122925
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 b1 b6 00 00       	call   f010ba57 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 27 29 12 f0       	push   $0xf0122927
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 a0 88 69 f0       	mov    %eax,0xf06988a0

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 31 29 12 f0       	push   $0xf0122931
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 25 29 12 f0       	push   $0xf0122925
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 b2 6d 00 00       	call   f01071cf <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 ea 6c 00 00       	call   f010710c <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 eb 6d 00 00       	call   f0107221 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 94 60 00 00       	call   f01064d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 53 b6 00 00       	call   f010ba99 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 f8 b5 00 00       	call   f010ba57 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 a0 88 69 f0       	mov    %eax,0xf06988a0

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 31 29 12 f0       	push   $0xf0122931
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 25 29 12 f0       	push   $0xf0122925
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 e1 b5 00 00       	call   f010ba99 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 86 b5 00 00       	call   f010ba57 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 4a 29 12 f0       	push   $0xf012294a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 25 29 12 f0       	push   $0xf0122925
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 c4 88 69 f0       	mov    0xf06988c4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 68 29 12 f0       	push   $0xf0122968
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 c4 88 69 f0       	mov    %eax,0xf06988c4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 bd dc 00 00       	call   f010e332 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 c8 88 69 f0 b4 	movl   $0x3b4,0xf06988c8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 c8 88 69 f0 d4 	movl   $0x3d4,0xf06988c8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 cc 88 69 f0       	mov    %eax,0xf06988cc
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 cc 88 69 f0    	mov    0xf06988cc,%edx
f010087a:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		text_length = 0;
f01008a6:	c7 05 c0 88 69 f0 00 	movl   $0x0,0xf06988c0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d d0 88 69 f0 	mov    0xf06988d0,%cx
f01008b7:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d cc 88 69 f0    	mov    0xf06988cc,%ecx
f0100972:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 d0 88 69 f0 	mov    %dx,0xf06988d0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 c0 88 69 f0    	mov    0xf06988c0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 c0 88 69 f0       	mov    %eax,0xf06988c0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 cc 88 69 f0       	mov    0xf06988cc,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 cc 88 69 f0       	mov    0xf06988cc,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 09 f5 01 00       	call   f011fef4 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 cc 88 69 f0    	mov    0xf06988cc,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 d0 88 69 f0    	mov    %ax,0xf06988d0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 c8 88 69 f0    	mov    0xf06988c8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 c8 88 69 f0       	mov    0xf06988c8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 c8 88 69 f0    	mov    0xf06988c8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 f0 17 f0    	mov    -0xfe80fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 f1 17 f0    	mov    -0xfe80ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 e8 8a 69 f0       	mov    %eax,0xf0698ae8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 f5 17 f0 	mov    -0xfe80ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 c0 88 69 f0    	mov    0xf06988c0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 c0 88 69 f0       	mov    %eax,0xf06988c0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 d0 88 69 f0    	mov    0xf06988d0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 cc 88 69 f0    	mov    0xf06988cc,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 cc 88 69 f0       	mov    0xf06988cc,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 c0 88 69 f0       	mov    0xf06988c0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 e8 8a 69 f0       	mov    0xf0698ae8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 7b 29 12 f0       	push   $0xf012297b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 1d d6 00 00       	call   f010e332 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 e4 8a 69 f0    	mov    %edx,0xf0698ae4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 e0 88 69 f0    	mov    %dl,-0xf967720(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 e4 8a 69 f0 00 	movl   $0x0,0xf0698ae4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 e0 8a 69 f0    	mov    0xf0698ae0,%edx
f0100d7f:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 e0 8a 69 f0    	mov    %edx,0xf0698ae0
f0100d96:	8a 80 e0 88 69 f0    	mov    -0xf967720(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 e0 8a 69 f0 00 	movl   $0x0,0xf0698ae0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 e0 8a 69 f0    	mov    0xf0698ae0,%edx
f0100dd0:	a1 e4 8a 69 f0       	mov    0xf0698ae4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 e0 8a 69 f0    	mov    %edx,0xf0698ae0
f0100de7:	8a 80 e0 88 69 f0    	mov    -0xf967720(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 e0 8a 69 f0       	mov    0xf0698ae0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 e0 8a 69 f0 00 	movl   $0x0,0xf0698ae0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 c4 88 69 f0       	mov    0xf06988c4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 87 29 12 f0       	push   $0xf0122987
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ff 3d 00 00       	call   f0104cba <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 d8 ab 00 00       	call   f010ba99 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 a4 29 12 f0       	push   $0xf01229a4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 cb 29 12 f0       	push   $0xf01229cb
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 b8 3d 00 00       	call   f0104cba <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 91 ab 00 00       	call   f010ba99 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 e0 29 12 f0       	push   $0xf01229e0
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 cb 29 12 f0       	push   $0xf01229cb
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 91 e6 01 00       	call   f011f614 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 39 62 00 00       	call   f01071cf <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 6b 62 00 00       	call   f0107221 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 de ec 01 00       	call   f011fcd6 <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 c0 0e 6e f0       	push   $0xf06e0ec0
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 e1 ee 01 00       	call   f011fef4 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 1c ec 01 00       	call   f011fcd6 <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 c0 0e 6e f0       	push   $0xf06e0ec0
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 1f ee 01 00       	call   f011fef4 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 5c ed 01 00       	call   f011fec4 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 0c 2a 12 f0       	push   $0xf0122a0c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 0f 2a 12 f0       	push   $0xf0122a0f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 a0 2e 6c f0       	push   $0xf06c2ea0
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 01 ea 01 00       	call   f011fcd6 <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 16 ea 01 00       	call   f011fd25 <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 b9 e9 01 00       	call   f011fcd6 <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 1f 2a 12 f0       	push   $0xf0122a1f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 94 ef 01 00       	call   f01202eb <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 24 2a 12 f0       	push   $0xf0122a24
f010137e:	50                   	push   %eax
f010137f:	e8 5e ea 01 00       	call   f011fde2 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 28 2a 12 f0       	push   $0xf0122a28
f0101399:	50                   	push   %eax
f010139a:	e8 43 ea 01 00       	call   f011fde2 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 2d 2a 12 f0       	push   $0xf0122a2d
f01013b4:	50                   	push   %eax
f01013b5:	e8 28 ea 01 00       	call   f011fde2 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 2d 2a 12 f0       	push   $0xf0122a2d
f01013d5:	50                   	push   %eax
f01013d6:	e8 07 ea 01 00       	call   f011fde2 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 af e8 01 00       	call   f011fcd6 <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 b1 e8 01 00       	call   f011fd25 <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 90 e8 01 00       	call   f011fd25 <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 0d e8 01 00       	call   f011fcd6 <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 28 e9 01 00       	call   f011fe1a <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 5d e7 01 00       	call   f011fcd6 <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 28 e9 01 00       	call   f011fec4 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 a0 2e 6c f0    	add    $0xf06c2ea0,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 93 e7 01 00       	call   f011fd53 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 d3 e6 01 00       	call   f011fcd6 <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 eb e7 01 00       	call   f011fe1a <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 36 e6 01 00       	call   f011fcd6 <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 d6 e5 01 00       	call   f011fcd6 <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 a1 e7 01 00       	call   f011fec4 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 a0 2e 6c f0    	add    $0xf06c2ea0,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 0c e6 01 00       	call   f011fd53 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 4e e5 01 00       	call   f011fcd6 <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 69 e6 01 00       	call   f011fe1a <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 b4 e4 01 00       	call   f011fcd6 <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 5a e4 01 00       	call   f011fcd6 <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 25 e6 01 00       	call   f011fec4 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 a0 2e 6c f0    	add    $0xf06c2ea0,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 90 e4 01 00       	call   f011fd53 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 a0 2e 6c f0       	push   $0xf06c2ea0
f0101929:	e8 a8 e3 01 00       	call   f011fcd6 <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 4f e3 01 00       	call   f011fcd6 <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 3c e3 01 00       	call   f011fcd6 <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 a0 2e 6c f0    	lea    -0xf93d160(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 a0 2e 6c f0       	add    $0xf06c2ea0,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 e1 e2 01 00       	call   f011fcd6 <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 a0 be 6d f0    	lea    -0xf924160(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 d6 e2 01 00       	call   f011fef4 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 a0 0a 6e f0       	push   $0xf06e0aa0
f0101c3a:	e8 b5 e2 01 00       	call   f011fef4 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 85 e1 01 00       	call   f011fde2 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 f5 17 f0       	mov    %eax,0xf017f530
f0101c6f:	a1 30 f5 17 f0       	mov    0xf017f530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 a0 be 6d f0       	add    $0xf06dbea0,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 67 e2 01 00       	call   f011fef4 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 dc 2d 6c f0       	mov    0xf06c2ddc,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 37 2a 12 f0       	mov    $0xf0122a37,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 37 2e 12 f0       	mov    $0xf0122e37,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 37 32 12 f0       	mov    $0xf0123237,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 dc 2d 6c f0 00 	movl   $0x0,0xf06c2ddc
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 58 2d 6c f0 00 	movl   $0x0,0xf06c2d58
f0101d59:	00 00 00 
f0101d5c:	c7 05 5c 2d 6c f0 00 	movl   $0x0,0xf06c2d5c
f0101d63:	00 00 00 
f0101d66:	c7 05 64 2d 6c f0 00 	movl   $0x0,0xf06c2d64
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 3e e1 01 00       	call   f011fec4 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 31 2a 12 f0       	push   $0xf0122a31
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 47 9f 00 00       	call   f010bd26 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 28 53 00 00       	call   f010710c <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 80 2e 6c f0       	mov    %eax,0xf06c2e80
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 80 2e 6c f0       	mov    0xf06c2e80,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 80 2e 6c f0    	mov    %edx,0xf06c2e80
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
f0101e98:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 80 2e 6c f0       	mov    %eax,0xf06c2e80
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 80 2e 6c f0       	mov    0xf06c2e80,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 80 2e 6c f0    	mov    %edx,0xf06c2e80
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 a0 0e 6e f0       	mov    %eax,0xf06e0ea0
f0101ed4:	a1 a0 0e 6e f0       	mov    0xf06e0ea0,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 1f 2a 12 f0       	push   $0xf0122a1f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 d5 e3 01 00       	call   f01202eb <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 37 36 12 f0       	push   $0xf0123637
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 50 36 12 f0       	push   $0xf0123650
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 a1 36 12 f0       	push   $0xf01236a1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 bc 36 12 f0       	push   $0xf01236bc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 ec 36 12 f0       	push   $0xf01236ec
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 a1 36 12 f0       	push   $0xf01236a1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 16 37 12 f0       	push   $0xf0123716
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f010203b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 20 37 12 f0       	push   $0xf0123720
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 83 37 12 f0       	push   $0xf0123783
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 8c 37 12 f0       	push   $0xf012378c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f010218b:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 f5 17 f0       	add    $0xf017f548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 94 37 12 f0       	push   $0xf0123794
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 a1 36 12 f0       	push   $0xf01236a1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 5c 2d 6c f0       	mov    %eax,0xf06c2d5c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 58 2d 6c f0       	mov    %eax,0xf06c2d58
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 64 2d 6c f0       	mov    %eax,0xf06c2d64

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f0102292:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 04 db 01 00       	call   f011fde2 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c f5 17 f0       	add    $0xf017f54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010238d:	a3 5c 2d 6c f0       	mov    %eax,0xf06c2d5c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023a3:	a3 58 2d 6c f0       	mov    %eax,0xf06c2d58
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 64 2d 6c f0       	mov    %eax,0xf06c2d64
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 f5 17 f0       	add    $0xf017f550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 58 2d 6c f0    	mov    0xf06c2d58,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f010248c:	a3 5c 2d 6c f0       	mov    %eax,0xf06c2d5c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01024a2:	a3 58 2d 6c f0       	mov    %eax,0xf06c2d58
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 f5 17 f0       	add    $0xf017f554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 64 2d 6c f0       	mov    %eax,0xf06c2d64
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 78 1b 6c f0 00 	movl   $0x0,0xf06c1b78
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 78 1b 6c f0 01 	movl   $0x1,0xf06c1b78
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 78 1b 6c f0 02 	movl   $0x2,0xf06c1b78
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 78 1b 6c f0 03 	movl   $0x3,0xf06c1b78
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 78 1b 6c f0 04 	movl   $0x4,0xf06c1b78
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 c4 1a 6c f0 01 	movl   $0x1,0xf06c1ac4
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 c4 1a 6c f0 02 	movl   $0x2,0xf06c1ac4
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 c4 1a 6c f0 03 	movl   $0x3,0xf06c1ac4
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 c4 1a 6c f0 04 	movl   $0x4,0xf06c1ac4
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 b4 37 12 f0       	push   $0xf01237b4
f0102662:	6a 56                	push   $0x56
f0102664:	68 dc 37 12 f0       	push   $0xf01237dc
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 f5 17 f0       	add    $0xf017f544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 5f 40 12 f0       	push   $0xf012405f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 68 40 12 f0       	push   $0xf0124068
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 fc 17 f0    	mov    0xf017fce0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 fc 17 f0    	mov    0xf017fce0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 7d 40 12 f0       	push   $0xf012407d
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 99 40 12 f0       	push   $0xf0124099
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 b4 40 12 f0       	push   $0xf01240b4
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 d5 25 12 00       	mov    $0x1225d5,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 d5 25 12 f0       	push   $0xf01225d5
f010278e:	68 f0 40 12 f0       	push   $0xf01240f0
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 84 88 69 00       	mov    $0x698884,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 84 88 69 f0       	push   $0xf0698884
f01027a9:	68 2c 41 12 f0       	push   $0xf012412c
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 d0 d7 b0 00       	mov    $0xb0d7d0,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 d0 d7 b0 f0       	push   $0xf0b0d7d0
f01027c4:	68 74 41 12 f0       	push   $0xf0124174
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 d0 d7 b0 f0       	mov    $0xf0b0d7d0,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 b0 41 12 f0       	push   $0xf01241b0
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 0c d8 01 00       	call   f0120036 <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 cb d7 01 00       	call   f0120036 <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 60 92 00 00       	call   f010bae9 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 95 d7 01 00       	call   f0120036 <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 dc 41 12 f0       	push   $0xf01241dc
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 0f d7 01 00       	call   f0120036 <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 8c d3 01 00       	call   f011fcd6 <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 91 d6 01 00       	call   f0120036 <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 06 42 12 f0       	push   $0xf0124206
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 45 d6 01 00       	call   f0120036 <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 da 90 00 00       	call   f010bae9 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 0f d6 01 00       	call   f0120036 <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 06 42 12 f0       	push   $0xf0124206
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 20 42 12 f0       	push   $0xf0124220
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 7e d5 01 00       	call   f0120036 <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 4a 42 12 f0       	push   $0xf012424a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 4d 42 12 f0       	push   $0xf012424d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 21 d5 01 00       	call   f0120036 <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 b6 8f 00 00       	call   f010bae9 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 eb d4 01 00       	call   f0120036 <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 d0 d4 01 00       	call   f0120036 <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 4f 42 12 f0       	push   $0xf012424f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 34 d4 01 00       	call   f0120036 <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 c9 8e 00 00       	call   f010bae9 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 ed d3 01 00       	call   f0120036 <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 bd 6c 00 00       	call   f0109942 <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 6e 6b 00 00       	call   f01097ff <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 4b 56 00 00       	call   f0108306 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 60 42 12 f0       	push   $0xf0124260
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 f8 d2 01 00       	call   f0120036 <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 8d 8d 00 00       	call   f010bae9 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 b1 d2 01 00       	call   f0120036 <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 1b 54 00 00       	call   f01081b2 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 8a 42 12 f0       	push   $0xf012428a
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 a7 58 00 00       	call   f010867f <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 a4 42 12 f0       	push   $0xf01242a4
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 18 58 00 00       	call   f010867f <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 dc 5a 00 00       	call   f0108961 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 e8 42 12 f0       	push   $0xf01242e8
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 90 1c 6c f0       	mov    0xf06c1c90,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 40 43 12 f0       	push   $0xf0124340
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 b6 c7 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 7c 43 12 f0       	push   $0xf012437c
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 e1 d0 01 00       	call   f0120036 <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 c6 d0 01 00       	call   f0120036 <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 ab d0 01 00       	call   f0120036 <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 35 c7 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 7a d0 01 00       	call   f0120036 <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 5d d0 01 00       	call   f0120036 <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 42 d0 01 00       	call   f0120036 <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 cf c6 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 28 44 12 f0       	push   $0xf0124428
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 fa cf 01 00       	call   f0120036 <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 b8 44 12 f0       	push   $0xf01244b8
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 6d c6 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 50 45 12 f0       	push   $0xf0124550
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 a8 45 12 f0       	push   $0xf01245a8
f010309d:	68 ed 45 12 f0       	push   $0xf01245ed
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 02 46 12 f0       	push   $0xf0124602
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 a8 45 12 f0       	push   $0xf01245a8
f01030bc:	68 ed 45 12 f0       	push   $0xf01245ed
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 02 46 12 f0       	push   $0xf0124602
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 34 7f 00 00       	call   f010b01b <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 16 46 12 f0       	push   $0xf0124616
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 28 46 12 f0       	push   $0xf0124628
f0103117:	68 ed 45 12 f0       	push   $0xf01245ed
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 02 46 12 f0       	push   $0xf0124602
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 4d 35 00 00       	call   f0106686 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 58 46 12 f0       	push   $0xf0124658
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 92 25 00 00       	call   f010571c <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 90 1c 6c f0 00 	movl   $0x0,0xf06c1c90
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 cc 25 00 00       	call   f0105772 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 6b ce 01 00       	call   f0120036 <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 db 28 00 00       	call   f0105ab8 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 03 25 00 00       	call   f010571c <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 58 46 12 f0       	push   $0xf0124658
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 90 1c 6c f0 00 	movl   $0x0,0xf06c1c90
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 26 2e 00 00       	call   f0106075 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 f3 2b 00 00       	call   f0105e54 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 97 2e 00 00       	call   f010610a <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 70 46 12 f0       	push   $0xf0124670
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 81 cd 01 00       	call   f0120036 <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 7e c3 00 00       	call   f010f64a <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 d0 46 12 f0       	push   $0xf01246d0
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 58 c3 00 00       	call   f010f64a <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 14 47 12 f0       	push   $0xf0124714
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 54 47 12 f0       	push   $0xf0124754
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 f6 cc 01 00       	call   f0120036 <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 6c c3 00 00       	call   f010f6bd <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 a8 47 12 f0       	push   $0xf01247a8
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 07 c3 00 00       	call   f010f67d <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 dc 47 12 f0       	push   $0xf01247dc
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 f5 c2 00 00       	call   f010f68d <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 08 48 12 f0       	push   $0xf0124808
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 e3 c2 00 00       	call   f010f69d <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 30 48 12 f0       	push   $0xf0124830
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 4a cc 01 00       	call   f0120036 <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 a8 35 00 00       	call   f01069a7 <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 64 48 12 f0       	push   $0xf0124864
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 f6 cb 01 00       	call   f0120036 <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 c3 cb 01 00       	call   f0120036 <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 bf 35 00 00       	call   f0106a55 <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 9c 48 12 f0       	push   $0xf012489c
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 a4 19 6c f0    	mov    0xf06c19a4,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 c9 48 12 f0       	push   $0xf01248c9
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 4d 42 12 f0       	push   $0xf012424d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 1e cb 01 00       	call   f0120036 <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 03 cb 01 00       	call   f0120036 <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 32 35 00 00       	call   f0106a7d <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 d0 48 12 f0       	push   $0xf01248d0
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 4d 42 12 f0       	push   $0xf012424d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 6d 31 00 00       	call   f01066f7 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 0c 49 12 f0       	push   $0xf012490c
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 a4 19 6c f0    	mov    0xf06c19a4,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 c9 48 12 f0       	push   $0xf01248c9
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 4d 42 12 f0       	push   $0xf012424d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 ee 30 00 00       	call   f01066dd <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 40 49 12 f0       	push   $0xf0124940
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 fd 30 00 00       	call   f0106712 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 d0 48 12 f0       	push   $0xf01248d0
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 7c 49 12 f0       	push   $0xf012497c
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 c5 c9 01 00       	call   f0120036 <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 a4 b7 01 00       	call   f011ee2a <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 a4 49 12 f0       	push   $0xf01249a4
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 cc 49 12 f0       	push   $0xf01249cc
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 22 c0 00 00       	call   f010f6eb <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 f0 49 12 f0       	push   $0xf01249f0
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 e9 bf 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 18 4a 12 f0       	push   $0xf0124a18
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 c6 bf 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 58 4a 12 f0       	push   $0xf0124a58
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 d9 bf 00 00       	call   f010f706 <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 94 4a 12 f0       	push   $0xf0124a94
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 d9 bf 00 00       	call   f010f721 <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 e8 4a 12 f0       	push   $0xf0124ae8
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 14 4b 12 f0       	push   $0xf0124b14
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 44 4b 12 f0       	push   $0xf0124b44
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 74 4b 12 f0       	push   $0xf0124b74
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 a4 4b 12 f0       	push   $0xf0124ba4
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 d4 4b 12 f0       	push   $0xf0124bd4
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 00 4c 12 f0       	push   $0xf0124c00
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 2c 4c 12 f0       	push   $0xf0124c2c
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 58 4c 12 f0       	push   $0xf0124c58
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 84 4c 12 f0       	push   $0xf0124c84
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 b0 4c 12 f0       	push   $0xf0124cb0
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 b0 4c 12 f0       	push   $0xf0124cb0
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 e4 4c 12 f0       	push   $0xf0124ce4
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 14 4d 12 f0       	push   $0xf0124d14
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 44 4d 12 f0       	push   $0xf0124d44
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 78 4d 12 f0       	push   $0xf0124d78
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 b4 4d 12 f0       	push   $0xf0124db4
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 e4 4d 12 f0       	push   $0xf0124de4
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 10 4e 12 f0       	push   $0xf0124e10
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 3c 4e 12 f0       	push   $0xf0124e3c
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 6c 4e 12 f0       	push   $0xf0124e6c
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 b9 bd 00 00       	call   f010f798 <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 9c 4e 12 f0       	push   $0xf0124e9c
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 73 bd 00 00       	call   f010f772 <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 d8 4e 12 f0       	push   $0xf0124ed8
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 74 bd 00 00       	call   f010f798 <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 9c 4e 12 f0       	push   $0xf0124e9c
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 2e bd 00 00       	call   f010f772 <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 fc 4e 12 f0       	push   $0xf0124efc
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 1c bd 00 00       	call   f010f78a <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 f7 bc 00 00       	call   f010f772 <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 1c 4f 12 f0       	push   $0xf0124f1c
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 e5 bc 00 00       	call   f010f78a <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 c0 bc 00 00       	call   f010f772 <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 f6 bc 00 00       	call   f010f7b0 <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 38 4f 12 f0       	push   $0xf0124f38
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 68 4f 12 f0       	push   $0xf0124f68
f0103ada:	e8 ef bf 01 00       	call   f011face <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 44 c5 01 00       	call   f0120036 <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 a4 bc 00 00       	call   f010f7a2 <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 aa bc 00 00       	call   f010f7b0 <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 94 4f 12 f0       	push   $0xf0124f94
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 b9 4f 12 f0       	push   $0xf0124fb9
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 5f bc 00 00       	call   f010f798 <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 d4 4f 12 f0       	push   $0xf0124fd4
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 2c bc 00 00       	call   f010f780 <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 24 50 12 f0       	push   $0xf0125024
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 b9 c4 01 00       	call   f0120036 <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 19 bc 00 00       	call   f010f7a2 <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 1f bc 00 00       	call   f010f7b0 <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 94 4f 12 f0       	push   $0xf0124f94
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 e4 bb 00 00       	call   f010f798 <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 d4 4f 12 f0       	push   $0xf0124fd4
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 b1 bb 00 00       	call   f010f780 <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 24 50 12 f0       	push   $0xf0125024
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 c8 bb 00 00       	call   f010f7b0 <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 6a 50 12 f0       	push   $0xf012506a
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 fb c6 00 00       	call   f011030f <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 81 c8 01 00       	call   f01204be <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 92 c9 01 00       	call   f01205fe <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 88 50 12 f0       	push   $0xf0125088
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 9f 50 12 f0       	push   $0xf012509f
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 c0 2c 6c f0 00 	movl   $0x0,0xf06c2cc0
f0103c9f:	00 00 00 
f0103ca2:	c7 05 c4 2c 6c f0 00 	movl   $0x0,0xf06c2cc4
f0103ca9:	00 00 00 
f0103cac:	c7 05 cc 2c 6c f0 00 	movl   $0x0,0xf06c2ccc
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 b8 44 00 00       	call   f0108197 <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 bc 50 12 f0       	push   $0xf01250bc
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 9f 50 12 f0       	push   $0xf012509f
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103d36:	8b 1d a0 13 6c f0    	mov    0xf06c13a0,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 c4 2c 6c f0       	mov    %eax,0xf06c2cc4
f0103d68:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 c0 2c 6c f0       	mov    %eax,0xf06c2cc0
f0103d81:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 cc 2c 6c f0       	mov    %eax,0xf06c2ccc
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 a0 13 6c f0    	mov    0xf06c13a0,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103e0a:	e8 19 bf 00 00       	call   f010fd28 <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 c0 2c 6c f0       	mov    0xf06c2cc0,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 df 50 12 f0       	push   $0xf01250df
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 9f 50 12 f0       	push   $0xf012509f
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 c4 2c 6c f0       	mov    %eax,0xf06c2cc4
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 c0 2c 6c f0       	mov    %eax,0xf06c2cc0
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 cc 2c 6c f0       	mov    %eax,0xf06c2ccc
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 e1 42 00 00       	call   f0108197 <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103ed6:	e8 d4 be 00 00       	call   f010fdaf <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103efc:	e8 27 be 00 00       	call   f010fd28 <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 bc 50 12 f0       	push   $0xf01250bc
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 9f 50 12 f0       	push   $0xf012509f
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 c0 2c 6c f0    	mov    0xf06c2cc0,%edx
f0103f5b:	8b 1d a0 13 6c f0    	mov    0xf06c13a0,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 c4 2c 6c f0       	mov    %eax,0xf06c2cc4
f0103f8d:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 c0 2c 6c f0       	mov    %eax,0xf06c2cc0
f0103fa6:	8b 0d a0 13 6c f0    	mov    0xf06c13a0,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 cc 2c 6c f0       	mov    %eax,0xf06c2ccc
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f0103fd4:	e8 d6 bd 00 00       	call   f010fdaf <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 26 59 00 00       	call   f0109942 <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 00 51 12 f0       	push   $0xf0125100
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 9f 50 12 f0       	push   $0xf012509f
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 16 55 00 00       	call   f010959f <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 21 58 00 00       	call   f01098e5 <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 e3 bd 01 00       	call   f011fec4 <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 7c 1b 6c f0       	mov    0xf06c1b7c,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b5 00 00 00       	call   f0104231 <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 ab 00 00 00       	jmp    f010422f <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 30 51 12 f0       	push   $0xf0125130
f0104192:	68 56 51 12 f0       	push   $0xf0125156
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 9f 50 12 f0       	push   $0xf012509f
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 e8 80             	sub    $0xffffff80,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 c8 05 00 00       	call   f0104780 <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01041c4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c7:	52                   	push   %edx
f01041c8:	6a 01                	push   $0x1
f01041ca:	ff 75 0c             	pushl  0xc(%ebp)
f01041cd:	50                   	push   %eax
f01041ce:	e8 11 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d3:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041dc:	c1 ea 0c             	shr    $0xc,%edx
f01041df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e5:	c1 e2 02             	shl    $0x2,%edx
f01041e8:	01 d0                	add    %edx,%eax
f01041ea:	8b 00                	mov    (%eax),%eax
f01041ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041f2:	85 c0                	test   %eax,%eax
f01041f4:	75 34                	jne    f010422a <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f6:	83 ec 0c             	sub    $0xc,%esp
f01041f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041fc:	50                   	push   %eax
f01041fd:	e8 f3 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104208:	75 07                	jne    f0104211 <pf_add_empty_env_page+0x111>
f010420a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420f:	eb 1e                	jmp    f010422f <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104214:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104217:	c1 ea 0c             	shr    $0xc,%edx
f010421a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104220:	c1 e2 02             	shl    $0x2,%edx
f0104223:	01 c2                	add    %eax,%edx
f0104225:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104228:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010422a:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422f:	c9                   	leave  
f0104230:	c3                   	ret    

f0104231 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104231:	55                   	push   %ebp
f0104232:	89 e5                	mov    %esp,%ebp
f0104234:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104237:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423e:	76 19                	jbe    f0104259 <pf_add_env_page+0x28>
f0104240:	68 30 51 12 f0       	push   $0xf0125130
f0104245:	68 56 51 12 f0       	push   $0xf0125156
f010424a:	68 f1 00 00 00       	push   $0xf1
f010424f:	68 9f 50 12 f0       	push   $0xf012509f
f0104254:	e8 e0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104259:	8b 45 08             	mov    0x8(%ebp),%eax
f010425c:	83 e8 80             	sub    $0xffffff80,%eax
f010425f:	83 ec 08             	sub    $0x8,%esp
f0104262:	50                   	push   %eax
f0104263:	ff 75 08             	pushl  0x8(%ebp)
f0104266:	e8 15 05 00 00       	call   f0104780 <get_disk_page_directory>
f010426b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104271:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104277:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010427a:	52                   	push   %edx
f010427b:	6a 01                	push   $0x1
f010427d:	ff 75 0c             	pushl  0xc(%ebp)
f0104280:	50                   	push   %eax
f0104281:	e8 5e fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104286:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010428c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010428f:	c1 ea 0c             	shr    $0xc,%edx
f0104292:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104298:	c1 e2 02             	shl    $0x2,%edx
f010429b:	01 d0                	add    %edx,%eax
f010429d:	8b 00                	mov    (%eax),%eax
f010429f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01042a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042a5:	85 c0                	test   %eax,%eax
f01042a7:	75 34                	jne    f01042dd <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a9:	83 ec 0c             	sub    $0xc,%esp
f01042ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042af:	50                   	push   %eax
f01042b0:	e8 40 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042b5:	83 c4 10             	add    $0x10,%esp
f01042b8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042bb:	75 07                	jne    f01042c4 <pf_add_env_page+0x93>
f01042bd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042c2:	eb 31                	jmp    f01042f5 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042ca:	c1 ea 0c             	shr    $0xc,%edx
f01042cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042d3:	c1 e2 02             	shl    $0x2,%edx
f01042d6:	01 c2                	add    %eax,%edx
f01042d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042db:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042e0:	83 ec 08             	sub    $0x8,%esp
f01042e3:	ff 75 10             	pushl  0x10(%ebp)
f01042e6:	50                   	push   %eax
f01042e7:	e8 5c f9 ff ff       	call   f0103c48 <write_disk_page>
f01042ec:	83 c4 10             	add    $0x10,%esp
f01042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042f5:	c9                   	leave  
f01042f6:	c3                   	ret    

f01042f7 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f7:	55                   	push   %ebp
f01042f8:	89 e5                	mov    %esp,%ebp
f01042fa:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104304:	76 19                	jbe    f010431f <pf_update_env_page+0x28>
f0104306:	68 30 51 12 f0       	push   $0xf0125130
f010430b:	68 56 51 12 f0       	push   $0xf0125156
f0104310:	68 13 01 00 00       	push   $0x113
f0104315:	68 9f 50 12 f0       	push   $0xf012509f
f010431a:	e8 1a c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010431f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104322:	83 e8 80             	sub    $0xffffff80,%eax
f0104325:	83 ec 08             	sub    $0x8,%esp
f0104328:	50                   	push   %eax
f0104329:	ff 75 08             	pushl  0x8(%ebp)
f010432c:	e8 4f 04 00 00       	call   f0104780 <get_disk_page_directory>
f0104331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104334:	8b 45 08             	mov    0x8(%ebp),%eax
f0104337:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010433d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 98 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010434f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 29                	je     f010437f <pf_update_env_page+0x88>
f0104356:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104359:	85 c0                	test   %eax,%eax
f010435b:	0f 84 c5 00 00 00    	je     f0104426 <pf_update_env_page+0x12f>
f0104361:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 d0                	add    %edx,%eax
f0104375:	8b 00                	mov    (%eax),%eax
f0104377:	85 c0                	test   %eax,%eax
f0104379:	0f 85 a7 00 00 00    	jne    f0104426 <pf_update_env_page+0x12f>
	{

		uint32 VA = (uint32)virtual_address ;
f010437f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104382:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104388:	85 c0                	test   %eax,%eax
f010438a:	79 09                	jns    f0104395 <pf_update_env_page+0x9e>
f010438c:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104393:	76 30                	jbe    f01043c5 <pf_update_env_page+0xce>
f0104395:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010439c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010439f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01043a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01043a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01043af:	f7 75 f0             	divl   -0x10(%ebp)
f01043b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043b5:	29 d0                	sub    %edx,%eax
f01043b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043ba:	77 53                	ja     f010440f <pf_update_env_page+0x118>
f01043bc:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043c3:	77 4a                	ja     f010440f <pf_update_env_page+0x118>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043c5:	83 ec 04             	sub    $0x4,%esp
f01043c8:	6a 00                	push   $0x0
f01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01043cd:	ff 75 08             	pushl  0x8(%ebp)
f01043d0:	e8 2b fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043d5:	83 c4 10             	add    $0x10,%esp
f01043d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043db:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043df:	75 17                	jne    f01043f8 <pf_update_env_page+0x101>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043e1:	83 ec 04             	sub    $0x4,%esp
f01043e4:	68 6c 51 12 f0       	push   $0xf012516c
f01043e9:	68 43 01 00 00       	push   $0x143
f01043ee:	68 9f 50 12 f0       	push   $0xf012509f
f01043f3:	e8 41 bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fb:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104401:	8d 50 01             	lea    0x1(%eax),%edx
f0104404:	8b 45 08             	mov    0x8(%ebp),%eax
f0104407:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f010440d:	eb 17                	jmp    f0104426 <pf_update_env_page+0x12f>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010440f:	83 ec 04             	sub    $0x4,%esp
f0104412:	68 b8 51 12 f0       	push   $0xf01251b8
f0104417:	68 4c 01 00 00       	push   $0x14c
f010441c:	68 9f 50 12 f0       	push   $0xf012509f
f0104421:	e8 13 bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104426:	8b 45 08             	mov    0x8(%ebp),%eax
f0104429:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010442f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104432:	52                   	push   %edx
f0104433:	6a 00                	push   $0x0
f0104435:	ff 75 0c             	pushl  0xc(%ebp)
f0104438:	50                   	push   %eax
f0104439:	e8 a6 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f010443e:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104441:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104444:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104447:	c1 ea 0c             	shr    $0xc,%edx
f010444a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104450:	c1 e2 02             	shl    $0x2,%edx
f0104453:	01 d0                	add    %edx,%eax
f0104455:	8b 00                	mov    (%eax),%eax
f0104457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
f010445d:	8b 40 64             	mov    0x64(%eax),%eax
f0104460:	6a 00                	push   $0x0
f0104462:	68 00 00 80 ef       	push   $0xef800000
f0104467:	ff 75 10             	pushl  0x10(%ebp)
f010446a:	50                   	push   %eax
f010446b:	e8 0f 42 00 00       	call   f010867f <map_frame>
f0104470:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104473:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010447a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010447d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104482:	83 ec 08             	sub    $0x8,%esp
f0104485:	50                   	push   %eax
f0104486:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104489:	e8 ba f7 ff ff       	call   f0103c48 <write_disk_page>
f010448e:	83 c4 10             	add    $0x10,%esp
f0104491:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104494:	8b 45 10             	mov    0x10(%ebp),%eax
f0104497:	8b 40 08             	mov    0x8(%eax),%eax
f010449a:	40                   	inc    %eax
f010449b:	8b 55 10             	mov    0x10(%ebp),%edx
f010449e:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f01044a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a5:	8b 40 64             	mov    0x64(%eax),%eax
f01044a8:	83 ec 08             	sub    $0x8,%esp
f01044ab:	68 00 00 80 ef       	push   $0xef800000
f01044b0:	50                   	push   %eax
f01044b1:	e8 29 43 00 00       	call   f01087df <unmap_frame>
f01044b6:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01044bc:	8b 40 08             	mov    0x8(%eax),%eax
f01044bf:	48                   	dec    %eax
f01044c0:	8b 55 10             	mov    0x10(%ebp),%edx
f01044c3:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01044d0:	8d 50 01             	lea    0x1(%eax),%edx
f01044d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044d6:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01044dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044f5:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01044fb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104501:	85 c0                	test   %eax,%eax
f0104503:	75 0a                	jne    f010450f <pf_read_env_page+0x2e>
f0104505:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010450a:	e9 93 00 00 00       	jmp    f01045a2 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f010450f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104512:	8b 45 08             	mov    0x8(%ebp),%eax
f0104515:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010451b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010451e:	51                   	push   %ecx
f010451f:	6a 00                	push   $0x0
f0104521:	52                   	push   %edx
f0104522:	50                   	push   %eax
f0104523:	e8 bc fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104528:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010452b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452e:	85 c0                	test   %eax,%eax
f0104530:	75 07                	jne    f0104539 <pf_read_env_page+0x58>
f0104532:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104537:	eb 69                	jmp    f01045a2 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010453c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010453f:	c1 ea 0c             	shr    $0xc,%edx
f0104542:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104548:	c1 e2 02             	shl    $0x2,%edx
f010454b:	01 d0                	add    %edx,%eax
f010454d:	8b 00                	mov    (%eax),%eax
f010454f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104552:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104556:	75 07                	jne    f010455f <pf_read_env_page+0x7e>
f0104558:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010455d:	eb 43                	jmp    f01045a2 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010455f:	83 ec 08             	sub    $0x8,%esp
f0104562:	ff 75 0c             	pushl  0xc(%ebp)
f0104565:	ff 75 f0             	pushl  -0x10(%ebp)
f0104568:	e8 ac f6 ff ff       	call   f0103c19 <read_disk_page>
f010456d:	83 c4 10             	add    $0x10,%esp
f0104570:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104573:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104576:	8b 45 08             	mov    0x8(%ebp),%eax
f0104579:	8b 40 64             	mov    0x64(%eax),%eax
f010457c:	6a 40                	push   $0x40
f010457e:	6a 00                	push   $0x0
f0104580:	52                   	push   %edx
f0104581:	50                   	push   %eax
f0104582:	e8 52 57 00 00       	call   f0109cd9 <pt_set_page_permissions>
f0104587:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010458a:	8b 45 08             	mov    0x8(%ebp),%eax
f010458d:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104593:	8d 50 01             	lea    0x1(%eax),%edx
f0104596:	8b 45 08             	mov    0x8(%ebp),%eax
f0104599:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010459f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01045a2:	c9                   	leave  
f01045a3:	c3                   	ret    

f01045a4 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01045a4:	55                   	push   %ebp
f01045a5:	89 e5                	mov    %esp,%ebp
f01045a7:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01045aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ad:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045b3:	85 c0                	test   %eax,%eax
f01045b5:	74 65                	je     f010461c <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045c0:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045c3:	52                   	push   %edx
f01045c4:	6a 00                	push   $0x0
f01045c6:	ff 75 0c             	pushl  0xc(%ebp)
f01045c9:	50                   	push   %eax
f01045ca:	e8 15 fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045cf:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d5:	85 c0                	test   %eax,%eax
f01045d7:	74 46                	je     f010461f <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045df:	c1 ea 0c             	shr    $0xc,%edx
f01045e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e8:	c1 e2 02             	shl    $0x2,%edx
f01045eb:	01 d0                	add    %edx,%eax
f01045ed:	8b 00                	mov    (%eax),%eax
f01045ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045f8:	c1 ea 0c             	shr    $0xc,%edx
f01045fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104601:	c1 e2 02             	shl    $0x2,%edx
f0104604:	01 d0                	add    %edx,%eax
f0104606:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010460c:	83 ec 0c             	sub    $0xc,%esp
f010460f:	ff 75 f4             	pushl  -0xc(%ebp)
f0104612:	e8 cc f8 ff ff       	call   f0103ee3 <free_disk_frame>
f0104617:	83 c4 10             	add    $0x10,%esp
f010461a:	eb 04                	jmp    f0104620 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010461c:	90                   	nop
f010461d:	eb 01                	jmp    f0104620 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010461f:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104620:	c9                   	leave  
f0104621:	c3                   	ret    

f0104622 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104622:	55                   	push   %ebp
f0104623:	89 e5                	mov    %esp,%ebp
f0104625:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010462f:	e9 c1 00 00 00       	jmp    f01046f5 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	83 e0 01             	and    $0x1,%eax
f010464a:	85 c0                	test   %eax,%eax
f010464c:	0f 84 9f 00 00 00    	je     f01046f1 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104652:	8b 45 08             	mov    0x8(%ebp),%eax
f0104655:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010465b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010465e:	c1 e2 02             	shl    $0x2,%edx
f0104661:	01 d0                	add    %edx,%eax
f0104663:	8b 00                	mov    (%eax),%eax
f0104665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010466a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010466d:	83 ec 0c             	sub    $0xc,%esp
f0104670:	ff 75 ec             	pushl  -0x14(%ebp)
f0104673:	e8 ca 52 00 00       	call   f0109942 <kheap_virtual_address>
f0104678:	83 c4 10             	add    $0x10,%esp
f010467b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010467e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104685:	eb 3a                	jmp    f01046c1 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010468a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104691:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104694:	01 d0                	add    %edx,%eax
f0104696:	8b 00                	mov    (%eax),%eax
f0104698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010469b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01046a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046a8:	01 d0                	add    %edx,%eax
f01046aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01046b0:	83 ec 0c             	sub    $0xc,%esp
f01046b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01046b6:	e8 28 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01046bb:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046be:	ff 45 f0             	incl   -0x10(%ebp)
f01046c1:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046c8:	76 bd                	jbe    f0104687 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01046cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046d6:	c1 e2 02             	shl    $0x2,%edx
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046e1:	83 ec 0c             	sub    $0xc,%esp
f01046e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01046e7:	e8 13 51 00 00       	call   f01097ff <kfree>
f01046ec:	83 c4 10             	add    $0x10,%esp
f01046ef:	eb 01                	jmp    f01046f2 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046f1:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046f2:	ff 45 f4             	incl   -0xc(%ebp)
f01046f5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046fc:	0f 86 32 ff ff ff    	jbe    f0104634 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010470b:	83 ec 0c             	sub    $0xc,%esp
f010470e:	50                   	push   %eax
f010470f:	e8 eb 50 00 00       	call   f01097ff <kfree>
f0104714:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104717:	8b 45 08             	mov    0x8(%ebp),%eax
f010471a:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104721:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104724:	8b 45 08             	mov    0x8(%ebp),%eax
f0104727:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010472e:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010473a:	85 c0                	test   %eax,%eax
f010473c:	74 3f                	je     f010477d <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010473e:	83 ec 0c             	sub    $0xc,%esp
f0104741:	ff 75 08             	pushl  0x8(%ebp)
f0104744:	e8 14 03 00 00       	call   f0104a5d <__pf_remove_env_all_tables>
f0104749:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010474c:	8b 45 08             	mov    0x8(%ebp),%eax
f010474f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	50                   	push   %eax
f0104759:	e8 a1 50 00 00       	call   f01097ff <kfree>
f010475e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010476b:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010476e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104771:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104778:	00 00 00 
f010477b:	eb 01                	jmp    f010477e <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010477d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010477e:	c9                   	leave  
f010477f:	c3                   	ret    

f0104780 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104780:	55                   	push   %ebp
f0104781:	89 e5                	mov    %esp,%ebp
f0104783:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104786:	8b 45 08             	mov    0x8(%ebp),%eax
f0104789:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010478f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104792:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104794:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104797:	8b 00                	mov    (%eax),%eax
f0104799:	85 c0                	test   %eax,%eax
f010479b:	75 5b                	jne    f01047f8 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010479d:	83 ec 0c             	sub    $0xc,%esp
f01047a0:	68 00 10 00 00       	push   $0x1000
f01047a5:	e8 f5 4d 00 00       	call   f010959f <kmalloc>
f01047aa:	83 c4 10             	add    $0x10,%esp
f01047ad:	89 c2                	mov    %eax,%edx
f01047af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b2:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01047b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b7:	8b 00                	mov    (%eax),%eax
f01047b9:	85 c0                	test   %eax,%eax
f01047bb:	75 07                	jne    f01047c4 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01047bd:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01047c2:	eb 39                	jmp    f01047fd <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01047c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047c7:	8b 00                	mov    (%eax),%eax
f01047c9:	83 ec 0c             	sub    $0xc,%esp
f01047cc:	50                   	push   %eax
f01047cd:	e8 13 51 00 00       	call   f01098e5 <kheap_physical_address>
f01047d2:	83 c4 10             	add    $0x10,%esp
f01047d5:	89 c2                	mov    %eax,%edx
f01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047da:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	83 ec 04             	sub    $0x4,%esp
f01047e8:	68 00 10 00 00       	push   $0x1000
f01047ed:	6a 00                	push   $0x0
f01047ef:	50                   	push   %eax
f01047f0:	e8 cf b6 01 00       	call   f011fec4 <memset>
f01047f5:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fd:	c9                   	leave  
f01047fe:	c3                   	ret    

f01047ff <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047ff:	55                   	push   %ebp
f0104800:	89 e5                	mov    %esp,%ebp
f0104802:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104805:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104813:	eb 7e                	jmp    f0104893 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104815:	8b 45 08             	mov    0x8(%ebp),%eax
f0104818:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010481e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104821:	c1 e2 02             	shl    $0x2,%edx
f0104824:	01 d0                	add    %edx,%eax
f0104826:	8b 00                	mov    (%eax),%eax
f0104828:	83 e0 01             	and    $0x1,%eax
f010482b:	85 c0                	test   %eax,%eax
f010482d:	74 60                	je     f010488f <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010482f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104832:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010483b:	c1 e2 02             	shl    $0x2,%edx
f010483e:	01 d0                	add    %edx,%eax
f0104840:	8b 00                	mov    (%eax),%eax
f0104842:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104847:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010484a:	83 ec 0c             	sub    $0xc,%esp
f010484d:	ff 75 e8             	pushl  -0x18(%ebp)
f0104850:	e8 ed 50 00 00       	call   f0109942 <kheap_virtual_address>
f0104855:	83 c4 10             	add    $0x10,%esp
f0104858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010485b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104862:	eb 20                	jmp    f0104884 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010486e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104871:	01 d0                	add    %edx,%eax
f0104873:	8b 00                	mov    (%eax),%eax
f0104875:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104878:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010487c:	74 03                	je     f0104881 <pf_calculate_allocated_pages+0x82>
				counter ++;
f010487e:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104881:	ff 45 ec             	incl   -0x14(%ebp)
f0104884:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010488b:	76 d7                	jbe    f0104864 <pf_calculate_allocated_pages+0x65>
f010488d:	eb 01                	jmp    f0104890 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010488f:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104890:	ff 45 f4             	incl   -0xc(%ebp)
f0104893:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010489a:	0f 86 75 ff ff ff    	jbe    f0104815 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f01048a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01048a3:	c9                   	leave  
f01048a4:	c3                   	ret    

f01048a5 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f01048a5:	55                   	push   %ebp
f01048a6:	89 e5                	mov    %esp,%ebp
f01048a8:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f01048ab:	83 ec 0c             	sub    $0xc,%esp
f01048ae:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f01048b3:	e8 70 b4 00 00       	call   f010fd28 <acquire_spinlock>
f01048b8:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f01048bb:	a1 cc 2c 6c f0       	mov    0xf06c2ccc,%eax
f01048c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	68 d0 2c 6c f0       	push   $0xf06c2cd0
f01048cb:	e8 df b4 00 00       	call   f010fdaf <release_spinlock>
f01048d0:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f01048d6:	c9                   	leave  
f01048d7:	c3                   	ret    

f01048d8 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f01048d8:	55                   	push   %ebp
f01048d9:	89 e5                	mov    %esp,%ebp
f01048db:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f01048de:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e1:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01048e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ea:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ef:	8b 00                	mov    (%eax),%eax
f01048f1:	85 c0                	test   %eax,%eax
f01048f3:	75 5b                	jne    f0104950 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048f5:	83 ec 0c             	sub    $0xc,%esp
f01048f8:	68 00 10 00 00       	push   $0x1000
f01048fd:	e8 9d 4c 00 00       	call   f010959f <kmalloc>
f0104902:	83 c4 10             	add    $0x10,%esp
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010490c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490f:	8b 00                	mov    (%eax),%eax
f0104911:	85 c0                	test   %eax,%eax
f0104913:	75 07                	jne    f010491c <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104915:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010491a:	eb 39                	jmp    f0104955 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010491c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010491f:	8b 00                	mov    (%eax),%eax
f0104921:	83 ec 0c             	sub    $0xc,%esp
f0104924:	50                   	push   %eax
f0104925:	e8 bb 4f 00 00       	call   f01098e5 <kheap_physical_address>
f010492a:	83 c4 10             	add    $0x10,%esp
f010492d:	89 c2                	mov    %eax,%edx
f010492f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104932:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010493b:	8b 00                	mov    (%eax),%eax
f010493d:	83 ec 04             	sub    $0x4,%esp
f0104940:	68 00 10 00 00       	push   $0x1000
f0104945:	6a 00                	push   $0x0
f0104947:	50                   	push   %eax
f0104948:	e8 77 b5 01 00       	call   f011fec4 <memset>
f010494d:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104950:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104955:	c9                   	leave  
f0104956:	c3                   	ret    

f0104957 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104957:	55                   	push   %ebp
f0104958:	89 e5                	mov    %esp,%ebp
f010495a:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010495d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104964:	76 19                	jbe    f010497f <__pf_write_env_table+0x28>
f0104966:	68 30 51 12 f0       	push   $0xf0125130
f010496b:	68 56 51 12 f0       	push   $0xf0125156
f0104970:	68 91 02 00 00       	push   $0x291
f0104975:	68 9f 50 12 f0       	push   $0xf012509f
f010497a:	e8 ba b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010497f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104982:	05 88 00 00 00       	add    $0x88,%eax
f0104987:	83 ec 08             	sub    $0x8,%esp
f010498a:	50                   	push   %eax
f010498b:	ff 75 08             	pushl  0x8(%ebp)
f010498e:	e8 45 ff ff ff       	call   f01048d8 <get_disk_table_directory>
f0104993:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104996:	8b 45 08             	mov    0x8(%ebp),%eax
f0104999:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010499f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049a2:	c1 ea 16             	shr    $0x16,%edx
f01049a5:	c1 e2 02             	shl    $0x2,%edx
f01049a8:	01 d0                	add    %edx,%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01049af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049b2:	85 c0                	test   %eax,%eax
f01049b4:	75 34                	jne    f01049ea <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01049b6:	83 ec 0c             	sub    $0xc,%esp
f01049b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049bc:	50                   	push   %eax
f01049bd:	e8 33 f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_write_env_table+0x7a>
f01049ca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049cf:	eb 31                	jmp    f0104a02 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01049da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049dd:	c1 ea 16             	shr    $0x16,%edx
f01049e0:	c1 e2 02             	shl    $0x2,%edx
f01049e3:	01 c2                	add    %eax,%edx
f01049e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049e8:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ed:	83 ec 08             	sub    $0x8,%esp
f01049f0:	ff 75 10             	pushl  0x10(%ebp)
f01049f3:	50                   	push   %eax
f01049f4:	e8 4f f2 ff ff       	call   f0103c48 <write_disk_page>
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a02:	c9                   	leave  
f0104a03:	c3                   	ret    

f0104a04 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a04:	55                   	push   %ebp
f0104a05:	89 e5                	mov    %esp,%ebp
f0104a07:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a0d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a13:	85 c0                	test   %eax,%eax
f0104a15:	75 07                	jne    f0104a1e <__pf_read_env_table+0x1a>
f0104a17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a1c:	eb 3d                	jmp    f0104a5b <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a21:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a2a:	c1 ea 16             	shr    $0x16,%edx
f0104a2d:	c1 e2 02             	shl    $0x2,%edx
f0104a30:	01 d0                	add    %edx,%eax
f0104a32:	8b 00                	mov    (%eax),%eax
f0104a34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a3b:	75 07                	jne    f0104a44 <__pf_read_env_table+0x40>
f0104a3d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a42:	eb 17                	jmp    f0104a5b <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a44:	83 ec 08             	sub    $0x8,%esp
f0104a47:	ff 75 10             	pushl  0x10(%ebp)
f0104a4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a4d:	e8 c7 f1 ff ff       	call   f0103c19 <read_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a6c:	85 c0                	test   %eax,%eax
f0104a6e:	74 52                	je     f0104ac2 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a77:	eb 3e                	jmp    f0104ab7 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a85:	c1 e2 02             	shl    $0x2,%edx
f0104a88:	01 d0                	add    %edx,%eax
f0104a8a:	8b 00                	mov    (%eax),%eax
f0104a8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a92:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a9b:	c1 e2 02             	shl    $0x2,%edx
f0104a9e:	01 d0                	add    %edx,%eax
f0104aa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104aa6:	83 ec 0c             	sub    $0xc,%esp
f0104aa9:	ff 75 f0             	pushl  -0x10(%ebp)
f0104aac:	e8 32 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104ab1:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ab4:	ff 45 f4             	incl   -0xc(%ebp)
f0104ab7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104abe:	76 b9                	jbe    f0104a79 <__pf_remove_env_all_tables+0x1c>
f0104ac0:	eb 01                	jmp    f0104ac3 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ac2:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104ac3:	c9                   	leave  
f0104ac4:	c3                   	ret    

f0104ac5 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104ac5:	55                   	push   %ebp
f0104ac6:	89 e5                	mov    %esp,%ebp
f0104ac8:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104acb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104acf:	75 10                	jne    f0104ae1 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ad1:	83 ec 0c             	sub    $0xc,%esp
f0104ad4:	68 34 52 12 f0       	push   $0xf0125234
f0104ad9:	e8 ad c4 ff ff       	call   f0100f8b <cprintf>
f0104ade:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104aea:	85 c0                	test   %eax,%eax
f0104aec:	74 43                	je     f0104b31 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104af7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104afa:	c1 ea 16             	shr    $0x16,%edx
f0104afd:	c1 e2 02             	shl    $0x2,%edx
f0104b00:	01 d0                	add    %edx,%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b10:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b13:	c1 ea 16             	shr    $0x16,%edx
f0104b16:	c1 e2 02             	shl    $0x2,%edx
f0104b19:	01 d0                	add    %edx,%eax
f0104b1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b21:	83 ec 0c             	sub    $0xc,%esp
f0104b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b27:	e8 b7 f3 ff ff       	call   f0103ee3 <free_disk_frame>
f0104b2c:	83 c4 10             	add    $0x10,%esp
f0104b2f:	eb 01                	jmp    f0104b32 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b31:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b32:	c9                   	leave  
f0104b33:	c3                   	ret    

f0104b34 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b34:	55                   	push   %ebp
f0104b35:	89 e5                	mov    %esp,%ebp
f0104b37:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b3a:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b41:	eb 1f                	jmp    f0104b62 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b46:	83 ec 04             	sub    $0x4,%esp
f0104b49:	6a 08                	push   $0x8
f0104b4b:	ff 75 08             	pushl  0x8(%ebp)
f0104b4e:	50                   	push   %eax
f0104b4f:	e8 aa ba 01 00       	call   f01205fe <ide_write>
f0104b54:	83 c4 10             	add    $0x10,%esp
f0104b57:	85 c0                	test   %eax,%eax
f0104b59:	75 12                	jne    f0104b6d <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b5b:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b62:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b69:	7e d8                	jle    f0104b43 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6b:	eb 01                	jmp    f0104b6e <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b6d:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6e:	90                   	nop
f0104b6f:	c9                   	leave  
f0104b70:	c3                   	ret    

f0104b71 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b71:	55                   	push   %ebp
  pushl %eax
f0104b72:	50                   	push   %eax
  pushl %ebx
f0104b73:	53                   	push   %ebx
  pushl %ecx
f0104b74:	51                   	push   %ecx
  pushl %edx
f0104b75:	52                   	push   %edx
  pushl %esi
f0104b76:	56                   	push   %esi
  pushl %edi
f0104b77:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b78:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b7c:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b80:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b82:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b84:	5f                   	pop    %edi
  popl %esi
f0104b85:	5e                   	pop    %esi
  popl %edx
f0104b86:	5a                   	pop    %edx
  popl %ecx
f0104b87:	59                   	pop    %ecx
  popl %ebx
f0104b88:	5b                   	pop    %ebx
  popl %eax
f0104b89:	58                   	pop    %eax
  popl %ebp
f0104b8a:	5d                   	pop    %ebp
  ret
f0104b8b:	c3                   	ret    

f0104b8c <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b8c:	55                   	push   %ebp
f0104b8d:	89 e5                	mov    %esp,%ebp
f0104b8f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	0f b6 c0             	movzbl %al,%eax
f0104b98:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b9f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba2:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104ba8:	ee                   	out    %al,(%dx)
f0104ba9:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bb3:	89 c2                	mov    %eax,%edx
f0104bb5:	ec                   	in     (%dx),%al
f0104bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bb9:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bbc:	0f b6 c0             	movzbl %al,%eax
}
f0104bbf:	c9                   	leave  
f0104bc0:	c3                   	ret    

f0104bc1 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104bc1:	55                   	push   %ebp
f0104bc2:	89 e5                	mov    %esp,%ebp
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bca:	0f b6 c0             	movzbl %al,%eax
f0104bcd:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104bd4:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd7:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104bda:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bdd:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be1:	0f b6 c0             	movzbl %al,%eax
f0104be4:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104beb:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bee:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bf4:	ee                   	out    %al,(%dx)
}
f0104bf5:	90                   	nop
f0104bf6:	c9                   	leave  
f0104bf7:	c3                   	ret    

f0104bf8 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bf8:	55                   	push   %ebp
f0104bf9:	89 e5                	mov    %esp,%ebp
f0104bfb:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bfe:	c7 05 88 1c 6c f0 00 	movl   $0x0,0xf06c1c88
f0104c05:	00 00 00 
f0104c08:	c7 05 8c 1c 6c f0 00 	movl   $0x0,0xf06c1c8c
f0104c0f:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c12:	83 ec 08             	sub    $0x8,%esp
f0104c15:	68 bf 6b 10 f0       	push   $0xf0106bbf
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	e8 11 97 00 00       	call   f010e332 <irq_install_handler>
f0104c21:	83 c4 10             	add    $0x10,%esp
}
f0104c24:	90                   	nop
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	53                   	push   %ebx
f0104c2b:	83 ec 24             	sub    $0x24,%esp
f0104c2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c31:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c34:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c3b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c3f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c45:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c46:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c4a:	77 48                	ja     f0104c94 <kclock_start+0x6d>
f0104c4c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c53:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c57:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c5d:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c62:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c67:	99                   	cltd   
f0104c68:	f7 fb                	idiv   %ebx
f0104c6a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c70:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c74:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c79:	99                   	cltd   
f0104c7a:	f7 fb                	idiv   %ebx
f0104c7c:	89 c3                	mov    %eax,%ebx
f0104c7e:	89 c8                	mov    %ecx,%eax
f0104c80:	99                   	cltd   
f0104c81:	f7 fb                	idiv   %ebx
f0104c83:	0f b7 c0             	movzwl %ax,%eax
f0104c86:	83 ec 0c             	sub    $0xc,%esp
f0104c89:	50                   	push   %eax
f0104c8a:	e8 b3 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104c8f:	83 c4 10             	add    $0x10,%esp
f0104c92:	eb 13                	jmp    f0104ca7 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c94:	6a 35                	push   $0x35
f0104c96:	68 58 52 12 f0       	push   $0xf0125258
f0104c9b:	6a 41                	push   $0x41
f0104c9d:	68 b4 52 12 f0       	push   $0xf01252b4
f0104ca2:	e8 92 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ca7:	83 ec 0c             	sub    $0xc,%esp
f0104caa:	6a 00                	push   $0x0
f0104cac:	e8 43 23 00 00       	call   f0106ff4 <irq_clear_mask>
f0104cb1:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cb4:	90                   	nop
f0104cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cb8:	c9                   	leave  
f0104cb9:	c3                   	ret    

f0104cba <kclock_stop>:

void
kclock_stop(void)
{
f0104cba:	55                   	push   %ebp
f0104cbb:	89 e5                	mov    %esp,%ebp
f0104cbd:	83 ec 18             	sub    $0x18,%esp
f0104cc0:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cc7:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ccb:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cd1:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104cd2:	83 ec 0c             	sub    $0xc,%esp
f0104cd5:	6a 00                	push   $0x0
f0104cd7:	e8 a3 22 00 00       	call   f0106f7f <irq_set_mask>
f0104cdc:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cdf:	90                   	nop
f0104ce0:	c9                   	leave  
f0104ce1:	c3                   	ret    

f0104ce2 <kclock_resume>:

void
kclock_resume(void)
{
f0104ce2:	55                   	push   %ebp
f0104ce3:	89 e5                	mov    %esp,%ebp
f0104ce5:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ce8:	e8 f5 01 00 00       	call   f0104ee2 <kclock_read_cnt0_latch>
f0104ced:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cf1:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cf6:	77 06                	ja     f0104cfe <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cf8:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104cfe:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d02:	83 e0 01             	and    $0x1,%eax
f0104d05:	66 85 c0             	test   %ax,%ax
f0104d08:	74 09                	je     f0104d13 <kclock_resume+0x31>
		cnt0++;
f0104d0a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d0e:	40                   	inc    %eax
f0104d0f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d13:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d1a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d1e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d24:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d25:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d29:	83 ec 0c             	sub    $0xc,%esp
f0104d2c:	50                   	push   %eax
f0104d2d:	e8 10 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d32:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	6a 00                	push   $0x0
f0104d3a:	e8 b5 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d3f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d42:	90                   	nop
f0104d43:	c9                   	leave  
f0104d44:	c3                   	ret    

f0104d45 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d45:	55                   	push   %ebp
f0104d46:	89 e5                	mov    %esp,%ebp
f0104d48:	83 ec 28             	sub    $0x28,%esp
f0104d4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d4e:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d51:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d58:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d5c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d62:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d67:	83 ec 0c             	sub    $0xc,%esp
f0104d6a:	50                   	push   %eax
f0104d6b:	e8 d2 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d70:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d73:	83 ec 0c             	sub    $0xc,%esp
f0104d76:	6a 00                	push   $0x0
f0104d78:	e8 77 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d7d:	83 c4 10             	add    $0x10,%esp
}
f0104d80:	90                   	nop
f0104d81:	c9                   	leave  
f0104d82:	c3                   	ret    

f0104d83 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d83:	55                   	push   %ebp
f0104d84:	89 e5                	mov    %esp,%ebp
f0104d86:	56                   	push   %esi
f0104d87:	53                   	push   %ebx
f0104d88:	83 ec 20             	sub    $0x20,%esp
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d91:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d95:	0f 87 8a 00 00 00    	ja     f0104e25 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d9b:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d9f:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104da4:	99                   	cltd   
f0104da5:	f7 fe                	idiv   %esi
f0104da7:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dad:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104db1:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104db6:	99                   	cltd   
f0104db7:	f7 fb                	idiv   %ebx
f0104db9:	89 c6                	mov    %eax,%esi
f0104dbb:	89 c8                	mov    %ecx,%eax
f0104dbd:	99                   	cltd   
f0104dbe:	f7 fe                	idiv   %esi
f0104dc0:	89 c3                	mov    %eax,%ebx
f0104dc2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104dc6:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104dcb:	99                   	cltd   
f0104dcc:	f7 f9                	idiv   %ecx
f0104dce:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dd4:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104dd8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ddd:	99                   	cltd   
f0104dde:	f7 fe                	idiv   %esi
f0104de0:	89 c6                	mov    %eax,%esi
f0104de2:	89 c8                	mov    %ecx,%eax
f0104de4:	99                   	cltd   
f0104de5:	f7 fe                	idiv   %esi
f0104de7:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dec:	85 c0                	test   %eax,%eax
f0104dee:	79 05                	jns    f0104df5 <kclock_set_quantum+0x72>
f0104df0:	48                   	dec    %eax
f0104df1:	83 c8 fe             	or     $0xfffffffe,%eax
f0104df4:	40                   	inc    %eax
f0104df5:	01 d8                	add    %ebx,%eax
f0104df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dfa:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e01:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e05:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e0b:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e0f:	0f b7 c0             	movzwl %ax,%eax
f0104e12:	83 ec 0c             	sub    $0xc,%esp
f0104e15:	50                   	push   %eax
f0104e16:	e8 27 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104e1b:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e1e:	e8 97 fe ff ff       	call   f0104cba <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e23:	eb 16                	jmp    f0104e3b <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e25:	6a 35                	push   $0x35
f0104e27:	68 58 52 12 f0       	push   $0xf0125258
f0104e2c:	68 ea 00 00 00       	push   $0xea
f0104e31:	68 b4 52 12 f0       	push   $0xf01252b4
f0104e36:	e8 fe b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e3e:	5b                   	pop    %ebx
f0104e3f:	5e                   	pop    %esi
f0104e40:	5d                   	pop    %ebp
f0104e41:	c3                   	ret    

f0104e42 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e42:	55                   	push   %ebp
f0104e43:	89 e5                	mov    %esp,%ebp
f0104e45:	83 ec 28             	sub    $0x28,%esp
f0104e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e4b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e4f:	e8 7b 23 00 00       	call   f01071cf <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e57:	0f b6 c0             	movzbl %al,%eax
f0104e5a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e61:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e64:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e6a:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e6e:	66 c1 e8 08          	shr    $0x8,%ax
f0104e72:	0f b6 c0             	movzbl %al,%eax
f0104e75:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e7c:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e85:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e86:	e8 96 23 00 00       	call   f0107221 <popcli>

}
f0104e8b:	90                   	nop
f0104e8c:	c9                   	leave  
f0104e8d:	c3                   	ret    

f0104e8e <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e8e:	55                   	push   %ebp
f0104e8f:	89 e5                	mov    %esp,%ebp
f0104e91:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e94:	e8 36 23 00 00       	call   f01071cf <pushcli>
f0104e99:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ea3:	89 c2                	mov    %eax,%edx
f0104ea5:	ec                   	in     (%dx),%al
f0104ea6:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104ea9:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eac:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104eaf:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104eb9:	89 c2                	mov    %eax,%edx
f0104ebb:	ec                   	in     (%dx),%al
f0104ebc:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104ebf:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ec2:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104ec5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104ec9:	c1 e0 08             	shl    $0x8,%eax
f0104ecc:	89 c2                	mov    %eax,%edx
f0104ece:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ed2:	09 d0                	or     %edx,%eax
f0104ed4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ed8:	e8 44 23 00 00       	call   f0107221 <popcli>
	return cnt0 ;
f0104edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104ee0:	c9                   	leave  
f0104ee1:	c3                   	ret    

f0104ee2 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104ee2:	55                   	push   %ebp
f0104ee3:	89 e5                	mov    %esp,%ebp
f0104ee5:	83 ec 30             	sub    $0x30,%esp
f0104ee8:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ef2:	89 c2                	mov    %eax,%edx
f0104ef4:	ec                   	in     (%dx),%al
f0104ef5:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ef8:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104efb:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104efe:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f05:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f09:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f0f:	ee                   	out    %al,(%dx)
f0104f10:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f1a:	89 c2                	mov    %eax,%edx
f0104f1c:	ec                   	in     (%dx),%al
f0104f1d:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f20:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f23:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f26:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f30:	89 c2                	mov    %eax,%edx
f0104f32:	ec                   	in     (%dx),%al
f0104f33:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f36:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f39:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f3c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f40:	c1 e0 08             	shl    $0x8,%eax
f0104f43:	89 c2                	mov    %eax,%edx
f0104f45:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f49:	09 d0                	or     %edx,%eax
f0104f4b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f53:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f5a:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f5d:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f60:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f63:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f64:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f67:	c9                   	leave  
f0104f68:	c3                   	ret    

f0104f69 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f69:	55                   	push   %ebp
f0104f6a:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f70:	74 1d                	je     f0104f8f <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f88:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f8f:	90                   	nop
f0104f90:	5d                   	pop    %ebp
f0104f91:	c3                   	ret    

f0104f92 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f92:	55                   	push   %ebp
f0104f93:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f99:	74 08                	je     f0104fa3 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fa1:	eb 05                	jmp    f0104fa8 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fa3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    

f0104faa <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
f0104fad:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb4:	75 16                	jne    f0104fcc <enqueue+0x22>
f0104fb6:	68 c8 52 12 f0       	push   $0xf01252c8
f0104fbb:	68 d6 52 12 f0       	push   $0xf01252d6
f0104fc0:	6a 34                	push   $0x34
f0104fc2:	68 eb 52 12 f0       	push   $0xf01252eb
f0104fc7:	e8 6d b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd0:	74 66                	je     f0105038 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd6:	75 14                	jne    f0104fec <enqueue+0x42>
f0104fd8:	83 ec 04             	sub    $0x4,%esp
f0104fdb:	68 04 53 12 f0       	push   $0xf0125304
f0104fe0:	6a 37                	push   $0x37
f0104fe2:	68 eb 52 12 f0       	push   $0xf01252eb
f0104fe7:	e8 4d b3 ff ff       	call   f0100339 <_panic>
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fef:	8b 10                	mov    (%eax),%edx
f0104ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff4:	89 50 08             	mov    %edx,0x8(%eax)
f0104ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ffa:	8b 40 08             	mov    0x8(%eax),%eax
f0104ffd:	85 c0                	test   %eax,%eax
f0104fff:	74 0d                	je     f010500e <enqueue+0x64>
f0105001:	8b 45 08             	mov    0x8(%ebp),%eax
f0105004:	8b 00                	mov    (%eax),%eax
f0105006:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105009:	89 50 0c             	mov    %edx,0xc(%eax)
f010500c:	eb 09                	jmp    f0105017 <enqueue+0x6d>
f010500e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105011:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105014:	89 50 04             	mov    %edx,0x4(%eax)
f0105017:	8b 45 08             	mov    0x8(%ebp),%eax
f010501a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010501d:	89 10                	mov    %edx,(%eax)
f010501f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105029:	8b 45 08             	mov    0x8(%ebp),%eax
f010502c:	8b 40 0c             	mov    0xc(%eax),%eax
f010502f:	8d 50 01             	lea    0x1(%eax),%edx
f0105032:	8b 45 08             	mov    0x8(%ebp),%eax
f0105035:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105038:	90                   	nop
f0105039:	c9                   	leave  
f010503a:	c3                   	ret    

f010503b <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010503b:	55                   	push   %ebp
f010503c:	89 e5                	mov    %esp,%ebp
f010503e:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105041:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105045:	75 0a                	jne    f0105051 <dequeue+0x16>
f0105047:	b8 00 00 00 00       	mov    $0x0,%eax
f010504c:	e9 a0 00 00 00       	jmp    f01050f1 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105051:	8b 45 08             	mov    0x8(%ebp),%eax
f0105054:	8b 40 04             	mov    0x4(%eax),%eax
f0105057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010505a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010505e:	0f 84 8a 00 00 00    	je     f01050ee <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105068:	75 14                	jne    f010507e <dequeue+0x43>
f010506a:	83 ec 04             	sub    $0x4,%esp
f010506d:	68 27 53 12 f0       	push   $0xf0125327
f0105072:	6a 44                	push   $0x44
f0105074:	68 eb 52 12 f0       	push   $0xf01252eb
f0105079:	e8 bb b2 ff ff       	call   f0100339 <_panic>
f010507e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105081:	8b 40 08             	mov    0x8(%eax),%eax
f0105084:	85 c0                	test   %eax,%eax
f0105086:	74 11                	je     f0105099 <dequeue+0x5e>
f0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508b:	8b 40 08             	mov    0x8(%eax),%eax
f010508e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105091:	8b 52 0c             	mov    0xc(%edx),%edx
f0105094:	89 50 0c             	mov    %edx,0xc(%eax)
f0105097:	eb 0c                	jmp    f01050a5 <dequeue+0x6a>
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	8b 50 0c             	mov    0xc(%eax),%edx
f010509f:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a2:	89 50 04             	mov    %edx,0x4(%eax)
f01050a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ab:	85 c0                	test   %eax,%eax
f01050ad:	74 11                	je     f01050c0 <dequeue+0x85>
f01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050b2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050b8:	8b 52 08             	mov    0x8(%edx),%edx
f01050bb:	89 50 08             	mov    %edx,0x8(%eax)
f01050be:	eb 0b                	jmp    f01050cb <dequeue+0x90>
f01050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c3:	8b 50 08             	mov    0x8(%eax),%edx
f01050c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c9:	89 10                	mov    %edx,(%eax)
f01050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050df:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050e5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050eb:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050f1:	c9                   	leave  
f01050f2:	c3                   	ret    

f01050f3 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050f3:	55                   	push   %ebp
f01050f4:	89 e5                	mov    %esp,%ebp
f01050f6:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050fd:	75 16                	jne    f0105115 <remove_from_queue+0x22>
f01050ff:	68 c8 52 12 f0       	push   $0xf01252c8
f0105104:	68 d6 52 12 f0       	push   $0xf01252d6
f0105109:	6a 4e                	push   $0x4e
f010510b:	68 eb 52 12 f0       	push   $0xf01252eb
f0105110:	e8 24 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105119:	0f 84 8a 00 00 00    	je     f01051a9 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010511f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105123:	75 14                	jne    f0105139 <remove_from_queue+0x46>
f0105125:	83 ec 04             	sub    $0x4,%esp
f0105128:	68 27 53 12 f0       	push   $0xf0125327
f010512d:	6a 52                	push   $0x52
f010512f:	68 eb 52 12 f0       	push   $0xf01252eb
f0105134:	e8 00 b2 ff ff       	call   f0100339 <_panic>
f0105139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513c:	8b 40 08             	mov    0x8(%eax),%eax
f010513f:	85 c0                	test   %eax,%eax
f0105141:	74 11                	je     f0105154 <remove_from_queue+0x61>
f0105143:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105146:	8b 40 08             	mov    0x8(%eax),%eax
f0105149:	8b 55 0c             	mov    0xc(%ebp),%edx
f010514c:	8b 52 0c             	mov    0xc(%edx),%edx
f010514f:	89 50 0c             	mov    %edx,0xc(%eax)
f0105152:	eb 0c                	jmp    f0105160 <remove_from_queue+0x6d>
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	8b 50 0c             	mov    0xc(%eax),%edx
f010515a:	8b 45 08             	mov    0x8(%ebp),%eax
f010515d:	89 50 04             	mov    %edx,0x4(%eax)
f0105160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105163:	8b 40 0c             	mov    0xc(%eax),%eax
f0105166:	85 c0                	test   %eax,%eax
f0105168:	74 11                	je     f010517b <remove_from_queue+0x88>
f010516a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105170:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105173:	8b 52 08             	mov    0x8(%edx),%edx
f0105176:	89 50 08             	mov    %edx,0x8(%eax)
f0105179:	eb 0b                	jmp    f0105186 <remove_from_queue+0x93>
f010517b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517e:	8b 50 08             	mov    0x8(%eax),%edx
f0105181:	8b 45 08             	mov    0x8(%ebp),%eax
f0105184:	89 10                	mov    %edx,(%eax)
f0105186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105193:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010519a:	8b 45 08             	mov    0x8(%ebp),%eax
f010519d:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a6:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051a9:	90                   	nop
f01051aa:	c9                   	leave  
f01051ab:	c3                   	ret    

f01051ac <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ac:	55                   	push   %ebp
f01051ad:	89 e5                	mov    %esp,%ebp
f01051af:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051b6:	75 07                	jne    f01051bf <find_env_in_queue+0x13>
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 58                	jmp    f0105217 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01051bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	8b 00                	mov    (%eax),%eax
f01051cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051ce:	eb 19                	jmp    f01051e9 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01051d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051d3:	8b 40 10             	mov    0x10(%eax),%eax
f01051d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051d9:	75 05                	jne    f01051e0 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051de:	eb 37                	jmp    f0105217 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e3:	8b 40 08             	mov    0x8(%eax),%eax
f01051e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ed:	74 08                	je     f01051f7 <find_env_in_queue+0x4b>
f01051ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051f2:	8b 40 08             	mov    0x8(%eax),%eax
f01051f5:	eb 05                	jmp    f01051fc <find_env_in_queue+0x50>
f01051f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ff:	89 42 08             	mov    %eax,0x8(%edx)
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 40 08             	mov    0x8(%eax),%eax
f0105208:	85 c0                	test   %eax,%eax
f010520a:	75 c4                	jne    f01051d0 <find_env_in_queue+0x24>
f010520c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105210:	75 be                	jne    f01051d0 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105212:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105217:	c9                   	leave  
f0105218:	c3                   	ret    

f0105219 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105219:	55                   	push   %ebp
f010521a:	89 e5                	mov    %esp,%ebp
f010521c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010521f:	83 ec 0c             	sub    $0xc,%esp
f0105222:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105227:	e8 fc aa 00 00       	call   f010fd28 <acquire_spinlock>
f010522c:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010522f:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105234:	85 c0                	test   %eax,%eax
f0105236:	74 11                	je     f0105249 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105238:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010523d:	83 ec 0c             	sub    $0xc,%esp
f0105240:	50                   	push   %eax
f0105241:	e8 b9 45 00 00       	call   f01097ff <kfree>
f0105246:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105249:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f010524e:	85 c0                	test   %eax,%eax
f0105250:	74 11                	je     f0105263 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105252:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f0105257:	83 ec 0c             	sub    $0xc,%esp
f010525a:	50                   	push   %eax
f010525b:	e8 9f 45 00 00       	call   f01097ff <kfree>
f0105260:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 e0 15 6c f0       	push   $0xf06c15e0
f010526b:	e8 3f ab 00 00       	call   f010fdaf <release_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105273:	90                   	nop
f0105274:	c9                   	leave  
f0105275:	c3                   	ret    

f0105276 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105276:	55                   	push   %ebp
f0105277:	89 e5                	mov    %esp,%ebp
f0105279:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010527c:	83 ec 0c             	sub    $0xc,%esp
f010527f:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105284:	e8 b8 ac 00 00       	call   f010ff41 <holding_spinlock>
f0105289:	83 c4 10             	add    $0x10,%esp
f010528c:	85 c0                	test   %eax,%eax
f010528e:	75 17                	jne    f01052a7 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105290:	83 ec 04             	sub    $0x4,%esp
f0105293:	68 48 53 12 f0       	push   $0xf0125348
f0105298:	68 85 00 00 00       	push   $0x85
f010529d:	68 eb 52 12 f0       	push   $0xf01252eb
f01052a2:	e8 92 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ab:	75 19                	jne    f01052c6 <sched_insert_ready0+0x50>
f01052ad:	68 89 53 12 f0       	push   $0xf0125389
f01052b2:	68 d6 52 12 f0       	push   $0xf01252d6
f01052b7:	68 88 00 00 00       	push   $0x88
f01052bc:	68 eb 52 12 f0       	push   $0xf01252eb
f01052c1:	e8 73 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01052c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c9:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01052d0:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01052d5:	83 ec 08             	sub    $0x8,%esp
f01052d8:	ff 75 08             	pushl  0x8(%ebp)
f01052db:	50                   	push   %eax
f01052dc:	e8 c9 fc ff ff       	call   f0104faa <enqueue>
f01052e1:	83 c4 10             	add    $0x10,%esp
	}
}
f01052e4:	90                   	nop
f01052e5:	c9                   	leave  
f01052e6:	c3                   	ret    

f01052e7 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f01052e7:	55                   	push   %ebp
f01052e8:	89 e5                	mov    %esp,%ebp
f01052ea:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052ed:	83 ec 0c             	sub    $0xc,%esp
f01052f0:	68 e0 15 6c f0       	push   $0xf06c15e0
f01052f5:	e8 47 ac 00 00       	call   f010ff41 <holding_spinlock>
f01052fa:	83 c4 10             	add    $0x10,%esp
f01052fd:	85 c0                	test   %eax,%eax
f01052ff:	75 17                	jne    f0105318 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105301:	83 ec 04             	sub    $0x4,%esp
f0105304:	68 48 53 12 f0       	push   $0xf0125348
f0105309:	68 97 00 00 00       	push   $0x97
f010530e:	68 eb 52 12 f0       	push   $0xf01252eb
f0105313:	e8 21 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531c:	74 0b                	je     f0105329 <sched_remove_ready+0x42>
f010531e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105321:	8b 40 18             	mov    0x18(%eax),%eax
f0105324:	83 f8 01             	cmp    $0x1,%eax
f0105327:	74 19                	je     f0105342 <sched_remove_ready+0x5b>
f0105329:	68 98 53 12 f0       	push   $0xf0125398
f010532e:	68 d6 52 12 f0       	push   $0xf01252d6
f0105333:	68 9a 00 00 00       	push   $0x9a
f0105338:	68 eb 52 12 f0       	push   $0xf01252eb
f010533d:	e8 f7 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105349:	e9 e4 00 00 00       	jmp    f0105432 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 10             	mov    0x10(%eax),%eax
f0105354:	89 c2                	mov    %eax,%edx
f0105356:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010535b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010535e:	c1 e1 04             	shl    $0x4,%ecx
f0105361:	01 c8                	add    %ecx,%eax
f0105363:	83 ec 08             	sub    $0x8,%esp
f0105366:	52                   	push   %edx
f0105367:	50                   	push   %eax
f0105368:	e8 3f fe ff ff       	call   f01051ac <find_env_in_queue>
f010536d:	83 c4 10             	add    $0x10,%esp
f0105370:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105377:	0f 84 b2 00 00 00    	je     f010542f <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010537d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105381:	75 17                	jne    f010539a <sched_remove_ready+0xb3>
f0105383:	83 ec 04             	sub    $0x4,%esp
f0105386:	68 27 53 12 f0       	push   $0xf0125327
f010538b:	68 a1 00 00 00       	push   $0xa1
f0105390:	68 eb 52 12 f0       	push   $0xf01252eb
f0105395:	e8 9f af ff ff       	call   f0100339 <_panic>
f010539a:	8b 45 08             	mov    0x8(%ebp),%eax
f010539d:	8b 40 08             	mov    0x8(%eax),%eax
f01053a0:	85 c0                	test   %eax,%eax
f01053a2:	74 11                	je     f01053b5 <sched_remove_ready+0xce>
f01053a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a7:	8b 40 08             	mov    0x8(%eax),%eax
f01053aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01053b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01053b3:	eb 16                	jmp    f01053cb <sched_remove_ready+0xe4>
f01053b5:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01053ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053bd:	c1 e2 04             	shl    $0x4,%edx
f01053c0:	01 c2                	add    %eax,%edx
f01053c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01053c8:	89 42 04             	mov    %eax,0x4(%edx)
f01053cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01053d1:	85 c0                	test   %eax,%eax
f01053d3:	74 11                	je     f01053e6 <sched_remove_ready+0xff>
f01053d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01053db:	8b 55 08             	mov    0x8(%ebp),%edx
f01053de:	8b 52 08             	mov    0x8(%edx),%edx
f01053e1:	89 50 08             	mov    %edx,0x8(%eax)
f01053e4:	eb 15                	jmp    f01053fb <sched_remove_ready+0x114>
f01053e6:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01053eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ee:	c1 e2 04             	shl    $0x4,%edx
f01053f1:	01 c2                	add    %eax,%edx
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 02                	mov    %eax,(%edx)
f01053fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105405:	8b 45 08             	mov    0x8(%ebp),%eax
f0105408:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010540f:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105417:	c1 e2 04             	shl    $0x4,%edx
f010541a:	01 d0                	add    %edx,%eax
f010541c:	8b 50 0c             	mov    0xc(%eax),%edx
f010541f:	4a                   	dec    %edx
f0105420:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105423:	8b 45 08             	mov    0x8(%ebp),%eax
f0105426:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010542d:	eb 14                	jmp    f0105443 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010542f:	ff 45 f4             	incl   -0xc(%ebp)
f0105432:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105437:	0f b6 c0             	movzbl %al,%eax
f010543a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010543d:	0f 8f 0b ff ff ff    	jg     f010534e <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105443:	c9                   	leave  
f0105444:	c3                   	ret    

f0105445 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105445:	55                   	push   %ebp
f0105446:	89 e5                	mov    %esp,%ebp
f0105448:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105453:	e8 e9 aa 00 00       	call   f010ff41 <holding_spinlock>
f0105458:	83 c4 10             	add    $0x10,%esp
f010545b:	85 c0                	test   %eax,%eax
f010545d:	75 17                	jne    f0105476 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010545f:	83 ec 04             	sub    $0x4,%esp
f0105462:	68 48 53 12 f0       	push   $0xf0125348
f0105467:	68 b0 00 00 00       	push   $0xb0
f010546c:	68 eb 52 12 f0       	push   $0xf01252eb
f0105471:	e8 c3 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010547a:	75 19                	jne    f0105495 <sched_insert_new+0x50>
f010547c:	68 89 53 12 f0       	push   $0xf0125389
f0105481:	68 d6 52 12 f0       	push   $0xf01252d6
f0105486:	68 b3 00 00 00       	push   $0xb3
f010548b:	68 eb 52 12 f0       	push   $0xf01252eb
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010549f:	83 ec 08             	sub    $0x8,%esp
f01054a2:	ff 75 08             	pushl  0x8(%ebp)
f01054a5:	68 50 16 6c f0       	push   $0xf06c1650
f01054aa:	e8 fb fa ff ff       	call   f0104faa <enqueue>
f01054af:	83 c4 10             	add    $0x10,%esp
	}
}
f01054b2:	90                   	nop
f01054b3:	c9                   	leave  
f01054b4:	c3                   	ret    

f01054b5 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054b5:	55                   	push   %ebp
f01054b6:	89 e5                	mov    %esp,%ebp
f01054b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054bb:	83 ec 0c             	sub    $0xc,%esp
f01054be:	68 e0 15 6c f0       	push   $0xf06c15e0
f01054c3:	e8 79 aa 00 00       	call   f010ff41 <holding_spinlock>
f01054c8:	83 c4 10             	add    $0x10,%esp
f01054cb:	85 c0                	test   %eax,%eax
f01054cd:	75 17                	jne    f01054e6 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054cf:	83 ec 04             	sub    $0x4,%esp
f01054d2:	68 48 53 12 f0       	push   $0xf0125348
f01054d7:	68 c1 00 00 00       	push   $0xc1
f01054dc:	68 eb 52 12 f0       	push   $0xf01252eb
f01054e1:	e8 53 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f01054e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054ea:	74 0b                	je     f01054f7 <sched_remove_new+0x42>
f01054ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ef:	8b 40 18             	mov    0x18(%eax),%eax
f01054f2:	83 f8 04             	cmp    $0x4,%eax
f01054f5:	74 19                	je     f0105510 <sched_remove_new+0x5b>
f01054f7:	68 c4 53 12 f0       	push   $0xf01253c4
f01054fc:	68 d6 52 12 f0       	push   $0xf01252d6
f0105501:	68 c4 00 00 00       	push   $0xc4
f0105506:	68 eb 52 12 f0       	push   $0xf01252eb
f010550b:	e8 29 ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105510:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105514:	75 17                	jne    f010552d <sched_remove_new+0x78>
f0105516:	83 ec 04             	sub    $0x4,%esp
f0105519:	68 27 53 12 f0       	push   $0xf0125327
f010551e:	68 c6 00 00 00       	push   $0xc6
f0105523:	68 eb 52 12 f0       	push   $0xf01252eb
f0105528:	e8 0c ae ff ff       	call   f0100339 <_panic>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 08             	mov    0x8(%eax),%eax
f0105533:	85 c0                	test   %eax,%eax
f0105535:	74 11                	je     f0105548 <sched_remove_new+0x93>
f0105537:	8b 45 08             	mov    0x8(%ebp),%eax
f010553a:	8b 40 08             	mov    0x8(%eax),%eax
f010553d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105540:	8b 52 0c             	mov    0xc(%edx),%edx
f0105543:	89 50 0c             	mov    %edx,0xc(%eax)
f0105546:	eb 0b                	jmp    f0105553 <sched_remove_new+0x9e>
f0105548:	8b 45 08             	mov    0x8(%ebp),%eax
f010554b:	8b 40 0c             	mov    0xc(%eax),%eax
f010554e:	a3 54 16 6c f0       	mov    %eax,0xf06c1654
f0105553:	8b 45 08             	mov    0x8(%ebp),%eax
f0105556:	8b 40 0c             	mov    0xc(%eax),%eax
f0105559:	85 c0                	test   %eax,%eax
f010555b:	74 11                	je     f010556e <sched_remove_new+0xb9>
f010555d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105560:	8b 40 0c             	mov    0xc(%eax),%eax
f0105563:	8b 55 08             	mov    0x8(%ebp),%edx
f0105566:	8b 52 08             	mov    0x8(%edx),%edx
f0105569:	89 50 08             	mov    %edx,0x8(%eax)
f010556c:	eb 0b                	jmp    f0105579 <sched_remove_new+0xc4>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	a3 50 16 6c f0       	mov    %eax,0xf06c1650
f0105579:	8b 45 08             	mov    0x8(%ebp),%eax
f010557c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105583:	8b 45 08             	mov    0x8(%ebp),%eax
f0105586:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010558d:	a1 5c 16 6c f0       	mov    0xf06c165c,%eax
f0105592:	48                   	dec    %eax
f0105593:	a3 5c 16 6c f0       	mov    %eax,0xf06c165c
		env->env_status = ENV_UNKNOWN;
f0105598:	8b 45 08             	mov    0x8(%ebp),%eax
f010559b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055a2:	90                   	nop
f01055a3:	c9                   	leave  
f01055a4:	c3                   	ret    

f01055a5 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055a5:	55                   	push   %ebp
f01055a6:	89 e5                	mov    %esp,%ebp
f01055a8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ab:	83 ec 0c             	sub    $0xc,%esp
f01055ae:	68 e0 15 6c f0       	push   $0xf06c15e0
f01055b3:	e8 89 a9 00 00       	call   f010ff41 <holding_spinlock>
f01055b8:	83 c4 10             	add    $0x10,%esp
f01055bb:	85 c0                	test   %eax,%eax
f01055bd:	75 17                	jne    f01055d6 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055bf:	83 ec 04             	sub    $0x4,%esp
f01055c2:	68 48 53 12 f0       	push   $0xf0125348
f01055c7:	68 d2 00 00 00       	push   $0xd2
f01055cc:	68 eb 52 12 f0       	push   $0xf01252eb
f01055d1:	e8 63 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01055d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055da:	75 19                	jne    f01055f5 <sched_insert_exit+0x50>
f01055dc:	68 89 53 12 f0       	push   $0xf0125389
f01055e1:	68 d6 52 12 f0       	push   $0xf01252d6
f01055e6:	68 d5 00 00 00       	push   $0xd5
f01055eb:	68 eb 52 12 f0       	push   $0xf01252eb
f01055f0:	e8 44 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f01055f5:	e8 9e a1 00 00       	call   f010f798 <isBufferingEnabled>
f01055fa:	84 c0                	test   %al,%al
f01055fc:	74 0e                	je     f010560c <sched_insert_exit+0x67>
f01055fe:	83 ec 0c             	sub    $0xc,%esp
f0105601:	ff 75 08             	pushl  0x8(%ebp)
f0105604:	e8 12 77 00 00       	call   f010cd1b <cleanup_buffers>
f0105609:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105616:	83 ec 08             	sub    $0x8,%esp
f0105619:	ff 75 08             	pushl  0x8(%ebp)
f010561c:	68 60 16 6c f0       	push   $0xf06c1660
f0105621:	e8 84 f9 ff ff       	call   f0104faa <enqueue>
f0105626:	83 c4 10             	add    $0x10,%esp
	}
}
f0105629:	90                   	nop
f010562a:	c9                   	leave  
f010562b:	c3                   	ret    

f010562c <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010562c:	55                   	push   %ebp
f010562d:	89 e5                	mov    %esp,%ebp
f010562f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105632:	83 ec 0c             	sub    $0xc,%esp
f0105635:	68 e0 15 6c f0       	push   $0xf06c15e0
f010563a:	e8 02 a9 00 00       	call   f010ff41 <holding_spinlock>
f010563f:	83 c4 10             	add    $0x10,%esp
f0105642:	85 c0                	test   %eax,%eax
f0105644:	75 17                	jne    f010565d <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105646:	83 ec 04             	sub    $0x4,%esp
f0105649:	68 48 53 12 f0       	push   $0xf0125348
f010564e:	68 e3 00 00 00       	push   $0xe3
f0105653:	68 eb 52 12 f0       	push   $0xf01252eb
f0105658:	e8 dc ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010565d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105661:	74 0b                	je     f010566e <sched_remove_exit+0x42>
f0105663:	8b 45 08             	mov    0x8(%ebp),%eax
f0105666:	8b 40 18             	mov    0x18(%eax),%eax
f0105669:	83 f8 05             	cmp    $0x5,%eax
f010566c:	74 19                	je     f0105687 <sched_remove_exit+0x5b>
f010566e:	68 f0 53 12 f0       	push   $0xf01253f0
f0105673:	68 d6 52 12 f0       	push   $0xf01252d6
f0105678:	68 e6 00 00 00       	push   $0xe6
f010567d:	68 eb 52 12 f0       	push   $0xf01252eb
f0105682:	e8 b2 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105687:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010568b:	75 17                	jne    f01056a4 <sched_remove_exit+0x78>
f010568d:	83 ec 04             	sub    $0x4,%esp
f0105690:	68 27 53 12 f0       	push   $0xf0125327
f0105695:	68 e8 00 00 00       	push   $0xe8
f010569a:	68 eb 52 12 f0       	push   $0xf01252eb
f010569f:	e8 95 ac ff ff       	call   f0100339 <_panic>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 08             	mov    0x8(%eax),%eax
f01056aa:	85 c0                	test   %eax,%eax
f01056ac:	74 11                	je     f01056bf <sched_remove_exit+0x93>
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 40 08             	mov    0x8(%eax),%eax
f01056b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01056b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01056ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01056bd:	eb 0b                	jmp    f01056ca <sched_remove_exit+0x9e>
f01056bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01056c5:	a3 64 16 6c f0       	mov    %eax,0xf06c1664
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 11                	je     f01056e5 <sched_remove_exit+0xb9>
f01056d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01056da:	8b 55 08             	mov    0x8(%ebp),%edx
f01056dd:	8b 52 08             	mov    0x8(%edx),%edx
f01056e0:	89 50 08             	mov    %edx,0x8(%eax)
f01056e3:	eb 0b                	jmp    f01056f0 <sched_remove_exit+0xc4>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	a3 60 16 6c f0       	mov    %eax,0xf06c1660
f01056f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105704:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f0105709:	48                   	dec    %eax
f010570a:	a3 6c 16 6c f0       	mov    %eax,0xf06c166c
		env->env_status = ENV_UNKNOWN;
f010570f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105712:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105719:	90                   	nop
f010571a:	c9                   	leave  
f010571b:	c3                   	ret    

f010571c <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010571c:	55                   	push   %ebp
f010571d:	89 e5                	mov    %esp,%ebp
f010571f:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105722:	83 ec 0c             	sub    $0xc,%esp
f0105725:	68 e0 15 6c f0       	push   $0xf06c15e0
f010572a:	e8 f9 a5 00 00       	call   f010fd28 <acquire_spinlock>
f010572f:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105736:	75 19                	jne    f0105751 <sched_new_env+0x35>
f0105738:	68 1b 54 12 f0       	push   $0xf012541b
f010573d:	68 d6 52 12 f0       	push   $0xf01252d6
f0105742:	68 f6 00 00 00       	push   $0xf6
f0105747:	68 eb 52 12 f0       	push   $0xf01252eb
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	ff 75 08             	pushl  0x8(%ebp)
f0105757:	e8 e9 fc ff ff       	call   f0105445 <sched_insert_new>
f010575c:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105767:	e8 43 a6 00 00       	call   f010fdaf <release_spinlock>
f010576c:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010576f:	90                   	nop
f0105770:	c9                   	leave  
f0105771:	c3                   	ret    

f0105772 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105772:	55                   	push   %ebp
f0105773:	89 e5                	mov    %esp,%ebp
f0105775:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105778:	83 ec 0c             	sub    $0xc,%esp
f010577b:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105780:	e8 a3 a5 00 00       	call   f010fd28 <acquire_spinlock>
f0105785:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578f:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105797:	eb 53                	jmp    f01057ec <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105799:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579c:	8b 40 10             	mov    0x10(%eax),%eax
f010579f:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a2:	75 40                	jne    f01057e4 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057a4:	83 ec 0c             	sub    $0xc,%esp
f01057a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01057aa:	e8 06 fd ff ff       	call   f01054b5 <sched_remove_new>
f01057af:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057b2:	83 ec 0c             	sub    $0xc,%esp
f01057b5:	ff 75 f4             	pushl  -0xc(%ebp)
f01057b8:	e8 b9 fa ff ff       	call   f0105276 <sched_insert_ready0>
f01057bd:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f01057c0:	e8 47 19 00 00       	call   f010710c <mycpu>
f01057c5:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01057cb:	85 c0                	test   %eax,%eax
f01057cd:	75 46                	jne    f0105815 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057cf:	83 ec 0c             	sub    $0xc,%esp
f01057d2:	68 e0 15 6c f0       	push   $0xf06c15e0
f01057d7:	e8 d3 a5 00 00       	call   f010fdaf <release_spinlock>
f01057dc:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f01057df:	e8 ad 0f 00 00       	call   f0106791 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057e4:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f01057e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057f0:	74 08                	je     f01057fa <sched_run_env+0x88>
f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057f5:	8b 40 08             	mov    0x8(%eax),%eax
f01057f8:	eb 05                	jmp    f01057ff <sched_run_env+0x8d>
f01057fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01057ff:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f0105804:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105809:	85 c0                	test   %eax,%eax
f010580b:	75 8c                	jne    f0105799 <sched_run_env+0x27>
f010580d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105811:	75 86                	jne    f0105799 <sched_run_env+0x27>
f0105813:	eb 01                	jmp    f0105816 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105815:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 e0 15 6c f0       	push   $0xf06c15e0
f010581e:	e8 8c a5 00 00       	call   f010fdaf <release_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105826:	90                   	nop
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105837:	e8 05 a7 00 00       	call   f010ff41 <holding_spinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
f010583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105842:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105846:	75 10                	jne    f0105858 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105848:	83 ec 0c             	sub    $0xc,%esp
f010584b:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105850:	e8 d3 a4 00 00       	call   f010fd28 <acquire_spinlock>
f0105855:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105858:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010585f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105866:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010586a:	75 59                	jne    f01058c5 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010586c:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105871:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105874:	eb 28                	jmp    f010589e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105879:	8b 40 10             	mov    0x10(%eax),%eax
f010587c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587f:	75 15                	jne    f0105896 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105881:	83 ec 0c             	sub    $0xc,%esp
f0105884:	ff 75 f4             	pushl  -0xc(%ebp)
f0105887:	e8 29 fc ff ff       	call   f01054b5 <sched_remove_new>
f010588c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010588f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105896:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f010589b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	74 08                	je     f01058ac <sched_exit_env+0x83>
f01058a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a7:	8b 40 08             	mov    0x8(%eax),%eax
f01058aa:	eb 05                	jmp    f01058b1 <sched_exit_env+0x88>
f01058ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01058b1:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f01058b6:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f01058bb:	85 c0                	test   %eax,%eax
f01058bd:	75 b7                	jne    f0105876 <sched_exit_env+0x4d>
f01058bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c3:	75 b1                	jne    f0105876 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f01058c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058c9:	0f 85 67 01 00 00    	jne    f0105a36 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01058cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058d6:	e9 47 01 00 00       	jmp    f0105a22 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01058db:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01058e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058e3:	c1 e2 04             	shl    $0x4,%edx
f01058e6:	01 d0                	add    %edx,%eax
f01058e8:	8b 00                	mov    (%eax),%eax
f01058ea:	85 c0                	test   %eax,%eax
f01058ec:	0f 84 27 01 00 00    	je     f0105a19 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f01058f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01058f9:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01058fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105901:	c1 e2 04             	shl    $0x4,%edx
f0105904:	01 d0                	add    %edx,%eax
f0105906:	8b 00                	mov    (%eax),%eax
f0105908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010590b:	e9 d1 00 00 00       	jmp    f01059e1 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105913:	8b 40 10             	mov    0x10(%eax),%eax
f0105916:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105919:	0f 85 af 00 00 00    	jne    f01059ce <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010591f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105923:	75 17                	jne    f010593c <sched_exit_env+0x113>
f0105925:	83 ec 04             	sub    $0x4,%esp
f0105928:	68 27 53 12 f0       	push   $0xf0125327
f010592d:	68 44 01 00 00       	push   $0x144
f0105932:	68 eb 52 12 f0       	push   $0xf01252eb
f0105937:	e8 fd a9 ff ff       	call   f0100339 <_panic>
f010593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593f:	8b 40 08             	mov    0x8(%eax),%eax
f0105942:	85 c0                	test   %eax,%eax
f0105944:	74 11                	je     f0105957 <sched_exit_env+0x12e>
f0105946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105949:	8b 40 08             	mov    0x8(%eax),%eax
f010594c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010594f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105952:	89 50 0c             	mov    %edx,0xc(%eax)
f0105955:	eb 16                	jmp    f010596d <sched_exit_env+0x144>
f0105957:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010595c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010595f:	c1 e2 04             	shl    $0x4,%edx
f0105962:	01 c2                	add    %eax,%edx
f0105964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	89 42 04             	mov    %eax,0x4(%edx)
f010596d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105970:	8b 40 0c             	mov    0xc(%eax),%eax
f0105973:	85 c0                	test   %eax,%eax
f0105975:	74 11                	je     f0105988 <sched_exit_env+0x15f>
f0105977:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597a:	8b 40 0c             	mov    0xc(%eax),%eax
f010597d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105980:	8b 52 08             	mov    0x8(%edx),%edx
f0105983:	89 50 08             	mov    %edx,0x8(%eax)
f0105986:	eb 15                	jmp    f010599d <sched_exit_env+0x174>
f0105988:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010598d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105990:	c1 e2 04             	shl    $0x4,%edx
f0105993:	01 c2                	add    %eax,%edx
f0105995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105998:	8b 40 08             	mov    0x8(%eax),%eax
f010599b:	89 02                	mov    %eax,(%edx)
f010599d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059aa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059b1:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01059b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059b9:	c1 e2 04             	shl    $0x4,%edx
f01059bc:	01 d0                	add    %edx,%eax
f01059be:	8b 50 0c             	mov    0xc(%eax),%edx
f01059c1:	4a                   	dec    %edx
f01059c2:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f01059c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f01059cc:	eb 4b                	jmp    f0105a19 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01059ce:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01059d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d6:	c1 e2 04             	shl    $0x4,%edx
f01059d9:	01 d0                	add    %edx,%eax
f01059db:	8b 40 08             	mov    0x8(%eax),%eax
f01059de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059e1:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01059e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059e9:	c1 e2 04             	shl    $0x4,%edx
f01059ec:	01 d0                	add    %edx,%eax
f01059ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059f2:	74 08                	je     f01059fc <sched_exit_env+0x1d3>
f01059f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f7:	8b 52 08             	mov    0x8(%edx),%edx
f01059fa:	eb 05                	jmp    f0105a01 <sched_exit_env+0x1d8>
f01059fc:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a01:	89 50 08             	mov    %edx,0x8(%eax)
f0105a04:	8b 40 08             	mov    0x8(%eax),%eax
f0105a07:	85 c0                	test   %eax,%eax
f0105a09:	0f 85 01 ff ff ff    	jne    f0105910 <sched_exit_env+0xe7>
f0105a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a13:	0f 85 f7 fe ff ff    	jne    f0105910 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	75 16                	jne    f0105a35 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a1f:	ff 45 ec             	incl   -0x14(%ebp)
f0105a22:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105a27:	0f b6 c0             	movzbl %al,%eax
f0105a2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a2d:	0f 8f a8 fe ff ff    	jg     f01058db <sched_exit_env+0xb2>
f0105a33:	eb 01                	jmp    f0105a36 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a35:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a36:	e8 5e 60 00 00       	call   f010ba99 <get_cpu_proc>
f0105a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a42:	75 19                	jne    f0105a5d <sched_exit_env+0x234>
f0105a44:	68 23 54 12 f0       	push   $0xf0125423
f0105a49:	68 d6 52 12 f0       	push   $0xf01252d6
f0105a4e:	68 4e 01 00 00       	push   $0x14e
f0105a53:	68 eb 52 12 f0       	push   $0xf01252eb
f0105a58:	e8 dc a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a61:	75 18                	jne    f0105a7b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a66:	8b 40 10             	mov    0x10(%eax),%eax
f0105a69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a6c:	75 0d                	jne    f0105a7b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a74:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7f:	74 1e                	je     f0105a9f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a87:	e8 19 fb ff ff       	call   f01055a5 <sched_insert_exit>
f0105a8c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a92:	8b 40 10             	mov    0x10(%eax),%eax
f0105a95:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a98:	75 05                	jne    f0105a9f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a9a:	e8 7b 61 00 00       	call   f010bc1a <sched>
		}
	}
	if (!lock_already_held)
f0105a9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa3:	75 10                	jne    f0105ab5 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105aa5:	83 ec 0c             	sub    $0xc,%esp
f0105aa8:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105aad:	e8 fd a2 00 00       	call   f010fdaf <release_spinlock>
f0105ab2:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105ab5:	90                   	nop
f0105ab6:	c9                   	leave  
f0105ab7:	c3                   	ret    

f0105ab8 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105ab8:	55                   	push   %ebp
f0105ab9:	89 e5                	mov    %esp,%ebp
f0105abb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105abe:	83 ec 0c             	sub    $0xc,%esp
f0105ac1:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105ac6:	e8 5d a2 00 00       	call   f010fd28 <acquire_spinlock>
f0105acb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105ace:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105adc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ae0:	75 79                	jne    f0105b5b <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ae2:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105aea:	eb 48                	jmp    f0105b34 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aef:	8b 40 10             	mov    0x10(%eax),%eax
f0105af2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105af5:	75 35                	jne    f0105b2c <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afa:	8d 50 20             	lea    0x20(%eax),%edx
f0105afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b00:	8b 40 10             	mov    0x10(%eax),%eax
f0105b03:	83 ec 04             	sub    $0x4,%esp
f0105b06:	52                   	push   %edx
f0105b07:	50                   	push   %eax
f0105b08:	68 34 54 12 f0       	push   $0xf0125434
f0105b0d:	e8 79 b4 ff ff       	call   f0100f8b <cprintf>
f0105b12:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b15:	83 ec 0c             	sub    $0xc,%esp
f0105b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b1b:	e8 95 f9 ff ff       	call   f01054b5 <sched_remove_new>
f0105b20:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b2a:	eb 2f                	jmp    f0105b5b <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b2c:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b38:	74 08                	je     f0105b42 <sched_kill_env+0x8a>
f0105b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3d:	8b 40 08             	mov    0x8(%eax),%eax
f0105b40:	eb 05                	jmp    f0105b47 <sched_kill_env+0x8f>
f0105b42:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b47:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f0105b4c:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	75 97                	jne    f0105aec <sched_kill_env+0x34>
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 91                	jne    f0105aec <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b5f:	0f 85 85 01 00 00    	jne    f0105cea <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b6c:	e9 65 01 00 00       	jmp    f0105cd6 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b71:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105b76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b79:	c1 e2 04             	shl    $0x4,%edx
f0105b7c:	01 d0                	add    %edx,%eax
f0105b7e:	8b 00                	mov    (%eax),%eax
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	0f 84 45 01 00 00    	je     f0105ccd <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b8f:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b97:	c1 e2 04             	shl    $0x4,%edx
f0105b9a:	01 d0                	add    %edx,%eax
f0105b9c:	8b 00                	mov    (%eax),%eax
f0105b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ba1:	e9 ef 00 00 00       	jmp    f0105c95 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0105bac:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105baf:	0f 85 cd 00 00 00    	jne    f0105c82 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105bc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0105bc4:	52                   	push   %edx
f0105bc5:	50                   	push   %eax
f0105bc6:	68 5c 54 12 f0       	push   $0xf012545c
f0105bcb:	e8 bb b3 ff ff       	call   f0100f8b <cprintf>
f0105bd0:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bd7:	75 17                	jne    f0105bf0 <sched_kill_env+0x138>
f0105bd9:	83 ec 04             	sub    $0x4,%esp
f0105bdc:	68 27 53 12 f0       	push   $0xf0125327
f0105be1:	68 91 01 00 00       	push   $0x191
f0105be6:	68 eb 52 12 f0       	push   $0xf01252eb
f0105beb:	e8 49 a7 ff ff       	call   f0100339 <_panic>
f0105bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf3:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	74 11                	je     f0105c0b <sched_kill_env+0x153>
f0105bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfd:	8b 40 08             	mov    0x8(%eax),%eax
f0105c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c03:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c06:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c09:	eb 16                	jmp    f0105c21 <sched_kill_env+0x169>
f0105c0b:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c13:	c1 e2 04             	shl    $0x4,%edx
f0105c16:	01 c2                	add    %eax,%edx
f0105c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1b:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c1e:	89 42 04             	mov    %eax,0x4(%edx)
f0105c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c24:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c27:	85 c0                	test   %eax,%eax
f0105c29:	74 11                	je     f0105c3c <sched_kill_env+0x184>
f0105c2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c34:	8b 52 08             	mov    0x8(%edx),%edx
f0105c37:	89 50 08             	mov    %edx,0x8(%eax)
f0105c3a:	eb 15                	jmp    f0105c51 <sched_kill_env+0x199>
f0105c3c:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c44:	c1 e2 04             	shl    $0x4,%edx
f0105c47:	01 c2                	add    %eax,%edx
f0105c49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c4c:	8b 40 08             	mov    0x8(%eax),%eax
f0105c4f:	89 02                	mov    %eax,(%edx)
f0105c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c65:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	01 d0                	add    %edx,%eax
f0105c72:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c75:	4a                   	dec    %edx
f0105c76:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c80:	eb 4b                	jmp    f0105ccd <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c82:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c8a:	c1 e2 04             	shl    $0x4,%edx
f0105c8d:	01 d0                	add    %edx,%eax
f0105c8f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c95:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c9d:	c1 e2 04             	shl    $0x4,%edx
f0105ca0:	01 d0                	add    %edx,%eax
f0105ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca6:	74 08                	je     f0105cb0 <sched_kill_env+0x1f8>
f0105ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cab:	8b 52 08             	mov    0x8(%edx),%edx
f0105cae:	eb 05                	jmp    f0105cb5 <sched_kill_env+0x1fd>
f0105cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cb5:	89 50 08             	mov    %edx,0x8(%eax)
f0105cb8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	0f 85 e3 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
f0105cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cc7:	0f 85 d9 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105ccd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cd1:	75 16                	jne    f0105ce9 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cd3:	ff 45 ec             	incl   -0x14(%ebp)
f0105cd6:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105cdb:	0f b6 c0             	movzbl %al,%eax
f0105cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105ce1:	0f 8f 8a fe ff ff    	jg     f0105b71 <sched_kill_env+0xb9>
f0105ce7:	eb 01                	jmp    f0105cea <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105ce9:	90                   	nop
		}
	}
	if (!found)
f0105cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cee:	0f 85 80 00 00 00    	jne    f0105d74 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105cf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cfb:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f0105d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d03:	eb 48                	jmp    f0105d4d <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d08:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d0e:	75 35                	jne    f0105d45 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d13:	8d 50 20             	lea    0x20(%eax),%edx
f0105d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d19:	8b 40 10             	mov    0x10(%eax),%eax
f0105d1c:	83 ec 04             	sub    $0x4,%esp
f0105d1f:	52                   	push   %edx
f0105d20:	50                   	push   %eax
f0105d21:	68 88 54 12 f0       	push   $0xf0125488
f0105d26:	e8 60 b2 ff ff       	call   f0100f8b <cprintf>
f0105d2b:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d2e:	83 ec 0c             	sub    $0xc,%esp
f0105d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d34:	e8 f3 f8 ff ff       	call   f010562c <sched_remove_exit>
f0105d39:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d43:	eb 2f                	jmp    f0105d74 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d45:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0105d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d51:	74 08                	je     f0105d5b <sched_kill_env+0x2a3>
f0105d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d56:	8b 40 08             	mov    0x8(%eax),%eax
f0105d59:	eb 05                	jmp    f0105d60 <sched_kill_env+0x2a8>
f0105d5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d60:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f0105d65:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0105d6a:	85 c0                	test   %eax,%eax
f0105d6c:	75 97                	jne    f0105d05 <sched_kill_env+0x24d>
f0105d6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d72:	75 91                	jne    f0105d05 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d74:	83 ec 0c             	sub    $0xc,%esp
f0105d77:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105d7c:	e8 2e a0 00 00       	call   f010fdaf <release_spinlock>
f0105d81:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d88:	74 23                	je     f0105dad <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d90:	e8 bc 5c 00 00       	call   f010ba51 <env_free>
f0105d95:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d98:	83 ec 0c             	sub    $0xc,%esp
f0105d9b:	68 ae 54 12 f0       	push   $0xf01254ae
f0105da0:	e8 e6 b1 ff ff       	call   f0100f8b <cprintf>
f0105da5:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105da8:	e9 a4 00 00 00       	jmp    f0105e51 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dad:	e8 e7 5c 00 00       	call   f010ba99 <get_cpu_proc>
f0105db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105db5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105db9:	75 19                	jne    f0105dd4 <sched_kill_env+0x31c>
f0105dbb:	68 23 54 12 f0       	push   $0xf0125423
f0105dc0:	68 d6 52 12 f0       	push   $0xf01252d6
f0105dc5:	68 b3 01 00 00       	push   $0x1b3
f0105dca:	68 eb 52 12 f0       	push   $0xf01252eb
f0105dcf:	e8 65 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105dd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105dd7:	8b 40 10             	mov    0x10(%eax),%eax
f0105dda:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ddd:	75 72                	jne    f0105e51 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105ddf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105de8:	8b 40 18             	mov    0x18(%eax),%eax
f0105deb:	83 f8 02             	cmp    $0x2,%eax
f0105dee:	74 19                	je     f0105e09 <sched_kill_env+0x351>
f0105df0:	68 b4 54 12 f0       	push   $0xf01254b4
f0105df5:	68 d6 52 12 f0       	push   $0xf01252d6
f0105dfa:	68 b8 01 00 00       	push   $0x1b8
f0105dff:	68 eb 52 12 f0       	push   $0xf01252eb
f0105e04:	e8 30 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e0c:	8d 50 20             	lea    0x20(%eax),%edx
f0105e0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e12:	8b 40 10             	mov    0x10(%eax),%eax
f0105e15:	83 ec 04             	sub    $0x4,%esp
f0105e18:	52                   	push   %edx
f0105e19:	50                   	push   %eax
f0105e1a:	68 d8 54 12 f0       	push   $0xf01254d8
f0105e1f:	e8 67 b1 ff ff       	call   f0100f8b <cprintf>
f0105e24:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e2d:	e8 1f 5c 00 00       	call   f010ba51 <env_free>
f0105e32:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e35:	83 ec 0c             	sub    $0xc,%esp
f0105e38:	68 ae 54 12 f0       	push   $0xf01254ae
f0105e3d:	e8 49 b1 ff ff       	call   f0100f8b <cprintf>
f0105e42:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e4c:	e8 c9 5d 00 00       	call   f010bc1a <sched>
		}
	}

}
f0105e51:	90                   	nop
f0105e52:	c9                   	leave  
f0105e53:	c3                   	ret    

f0105e54 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e54:	55                   	push   %ebp
f0105e55:	89 e5                	mov    %esp,%ebp
f0105e57:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e5a:	83 ec 0c             	sub    $0xc,%esp
f0105e5d:	68 e0 15 6c f0       	push   $0xf06c15e0
f0105e62:	e8 c1 9e 00 00       	call   f010fd28 <acquire_spinlock>
f0105e67:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e6a:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105e6f:	85 c0                	test   %eax,%eax
f0105e71:	74 69                	je     f0105edc <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	68 04 55 12 f0       	push   $0xf0125504
f0105e7b:	e8 0b b1 ff ff       	call   f0100f8b <cprintf>
f0105e80:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e83:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0105e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e8b:	eb 26                	jmp    f0105eb3 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e90:	8d 50 20             	lea    0x20(%eax),%edx
f0105e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e96:	8b 40 10             	mov    0x10(%eax),%eax
f0105e99:	83 ec 04             	sub    $0x4,%esp
f0105e9c:	52                   	push   %edx
f0105e9d:	50                   	push   %eax
f0105e9e:	68 26 55 12 f0       	push   $0xf0125526
f0105ea3:	e8 e3 b0 ff ff       	call   f0100f8b <cprintf>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eab:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105eb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb7:	74 08                	je     f0105ec1 <sched_print_all+0x6d>
f0105eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebc:	8b 40 08             	mov    0x8(%eax),%eax
f0105ebf:	eb 05                	jmp    f0105ec6 <sched_print_all+0x72>
f0105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ec6:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f0105ecb:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0105ed0:	85 c0                	test   %eax,%eax
f0105ed2:	75 b9                	jne    f0105e8d <sched_print_all+0x39>
f0105ed4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ed8:	75 b3                	jne    f0105e8d <sched_print_all+0x39>
f0105eda:	eb 10                	jmp    f0105eec <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105edc:	83 ec 0c             	sub    $0xc,%esp
f0105edf:	68 30 55 12 f0       	push   $0xf0125530
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eec:	83 ec 0c             	sub    $0xc,%esp
f0105eef:	68 4c 55 12 f0       	push   $0xf012554c
f0105ef4:	e8 92 b0 ff ff       	call   f0100f8b <cprintf>
f0105ef9:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f03:	e9 c7 00 00 00       	jmp    f0105fcf <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f08:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f10:	c1 e2 04             	shl    $0x4,%edx
f0105f13:	01 d0                	add    %edx,%eax
f0105f15:	8b 00                	mov    (%eax),%eax
f0105f17:	85 c0                	test   %eax,%eax
f0105f19:	0f 84 8a 00 00 00    	je     f0105fa9 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f1f:	83 ec 08             	sub    $0x8,%esp
f0105f22:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f25:	68 80 55 12 f0       	push   $0xf0125580
f0105f2a:	e8 5c b0 ff ff       	call   f0100f8b <cprintf>
f0105f2f:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f32:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f37:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f3a:	c1 e2 04             	shl    $0x4,%edx
f0105f3d:	01 d0                	add    %edx,%eax
f0105f3f:	8b 00                	mov    (%eax),%eax
f0105f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f44:	eb 31                	jmp    f0105f77 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f49:	8d 50 20             	lea    0x20(%eax),%edx
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 10             	mov    0x10(%eax),%eax
f0105f52:	83 ec 04             	sub    $0x4,%esp
f0105f55:	52                   	push   %edx
f0105f56:	50                   	push   %eax
f0105f57:	68 26 55 12 f0       	push   $0xf0125526
f0105f5c:	e8 2a b0 ff ff       	call   f0100f8b <cprintf>
f0105f61:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f64:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6c:	c1 e2 04             	shl    $0x4,%edx
f0105f6f:	01 d0                	add    %edx,%eax
f0105f71:	8b 40 08             	mov    0x8(%eax),%eax
f0105f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f77:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0105f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7f:	c1 e2 04             	shl    $0x4,%edx
f0105f82:	01 d0                	add    %edx,%eax
f0105f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f88:	74 08                	je     f0105f92 <sched_print_all+0x13e>
f0105f8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8d:	8b 52 08             	mov    0x8(%edx),%edx
f0105f90:	eb 05                	jmp    f0105f97 <sched_print_all+0x143>
f0105f92:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f97:	89 50 08             	mov    %edx,0x8(%eax)
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	85 c0                	test   %eax,%eax
f0105f9f:	75 a5                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fa5:	75 9f                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa7:	eb 13                	jmp    f0105fbc <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fa9:	83 ec 08             	sub    $0x8,%esp
f0105fac:	ff 75 f0             	pushl  -0x10(%ebp)
f0105faf:	68 a8 55 12 f0       	push   $0xf01255a8
f0105fb4:	e8 d2 af ff ff       	call   f0100f8b <cprintf>
f0105fb9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105fbc:	83 ec 0c             	sub    $0xc,%esp
f0105fbf:	68 4c 55 12 f0       	push   $0xf012554c
f0105fc4:	e8 c2 af ff ff       	call   f0100f8b <cprintf>
f0105fc9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fcc:	ff 45 f0             	incl   -0x10(%ebp)
f0105fcf:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0105fd4:	0f b6 c0             	movzbl %al,%eax
f0105fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fda:	0f 8f 28 ff ff ff    	jg     f0105f08 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fe0:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 69                	je     f0106052 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fe9:	83 ec 0c             	sub    $0xc,%esp
f0105fec:	68 cc 55 12 f0       	push   $0xf01255cc
f0105ff1:	e8 95 af ff ff       	call   f0100f8b <cprintf>
f0105ff6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ff9:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f0105ffe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106001:	eb 26                	jmp    f0106029 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106006:	8d 50 20             	lea    0x20(%eax),%edx
f0106009:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600c:	8b 40 10             	mov    0x10(%eax),%eax
f010600f:	83 ec 04             	sub    $0x4,%esp
f0106012:	52                   	push   %edx
f0106013:	50                   	push   %eax
f0106014:	68 26 55 12 f0       	push   $0xf0125526
f0106019:	e8 6d af ff ff       	call   f0100f8b <cprintf>
f010601e:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106021:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0106026:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106029:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602d:	74 08                	je     f0106037 <sched_print_all+0x1e3>
f010602f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106032:	8b 40 08             	mov    0x8(%eax),%eax
f0106035:	eb 05                	jmp    f010603c <sched_print_all+0x1e8>
f0106037:	b8 00 00 00 00       	mov    $0x0,%eax
f010603c:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f0106041:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f0106046:	85 c0                	test   %eax,%eax
f0106048:	75 b9                	jne    f0106003 <sched_print_all+0x1af>
f010604a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010604e:	75 b3                	jne    f0106003 <sched_print_all+0x1af>
f0106050:	eb 10                	jmp    f0106062 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106052:	83 ec 0c             	sub    $0xc,%esp
f0106055:	68 ee 55 12 f0       	push   $0xf01255ee
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106062:	83 ec 0c             	sub    $0xc,%esp
f0106065:	68 e0 15 6c f0       	push   $0xf06c15e0
f010606a:	e8 40 9d 00 00       	call   f010fdaf <release_spinlock>
f010606f:	83 c4 10             	add    $0x10,%esp
}
f0106072:	90                   	nop
f0106073:	c9                   	leave  
f0106074:	c3                   	ret    

f0106075 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106075:	55                   	push   %ebp
f0106076:	89 e5                	mov    %esp,%ebp
f0106078:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010607b:	83 ec 0c             	sub    $0xc,%esp
f010607e:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106083:	e8 a0 9c 00 00       	call   f010fd28 <acquire_spinlock>
f0106088:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010608b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106092:	a1 5c 16 6c f0       	mov    0xf06c165c,%eax
f0106097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010609a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060a1:	eb 24                	jmp    f01060c7 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 50 16 6c f0       	push   $0xf06c1650
f01060ab:	e8 8b ef ff ff       	call   f010503b <dequeue>
f01060b0:	83 c4 10             	add    $0x10,%esp
f01060b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060b6:	83 ec 0c             	sub    $0xc,%esp
f01060b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01060bc:	e8 b5 f1 ff ff       	call   f0105276 <sched_insert_ready0>
f01060c1:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060c4:	ff 45 f4             	incl   -0xc(%ebp)
f01060c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060cd:	7c d4                	jl     f01060a3 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060cf:	83 ec 0c             	sub    $0xc,%esp
f01060d2:	68 e0 15 6c f0       	push   $0xf06c15e0
f01060d7:	e8 d3 9c 00 00       	call   f010fdaf <release_spinlock>
f01060dc:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060df:	e8 28 10 00 00       	call   f010710c <mycpu>
f01060e4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060ea:	85 c0                	test   %eax,%eax
f01060ec:	75 05                	jne    f01060f3 <sched_run_all+0x7e>
		fos_scheduler();
f01060ee:	e8 9e 06 00 00       	call   f0106791 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060f3:	83 ec 04             	sub    $0x4,%esp
f01060f6:	68 0c 56 12 f0       	push   $0xf012560c
f01060fb:	68 15 02 00 00       	push   $0x215
f0106100:	68 eb 52 12 f0       	push   $0xf01252eb
f0106105:	e8 2f a2 ff ff       	call   f0100339 <_panic>

f010610a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010610a:	55                   	push   %ebp
f010610b:	89 e5                	mov    %esp,%ebp
f010610d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106118:	e8 0b 9c 00 00       	call   f010fd28 <acquire_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106120:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0106125:	85 c0                	test   %eax,%eax
f0106127:	0f 84 95 00 00 00    	je     f01061c2 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010612d:	83 ec 0c             	sub    $0xc,%esp
f0106130:	68 48 56 12 f0       	push   $0xf0125648
f0106135:	e8 51 ae ff ff       	call   f0100f8b <cprintf>
f010613a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613d:	a1 50 16 6c f0       	mov    0xf06c1650,%eax
f0106142:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106145:	eb 52                	jmp    f0106199 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614a:	8d 50 20             	lea    0x20(%eax),%edx
f010614d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106150:	8b 40 10             	mov    0x10(%eax),%eax
f0106153:	83 ec 04             	sub    $0x4,%esp
f0106156:	52                   	push   %edx
f0106157:	50                   	push   %eax
f0106158:	68 74 56 12 f0       	push   $0xf0125674
f010615d:	e8 29 ae ff ff       	call   f0100f8b <cprintf>
f0106162:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106165:	83 ec 0c             	sub    $0xc,%esp
f0106168:	ff 75 f4             	pushl  -0xc(%ebp)
f010616b:	e8 45 f3 ff ff       	call   f01054b5 <sched_remove_new>
f0106170:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106173:	83 ec 0c             	sub    $0xc,%esp
f0106176:	ff 75 f4             	pushl  -0xc(%ebp)
f0106179:	e8 d3 58 00 00       	call   f010ba51 <env_free>
f010617e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106181:	83 ec 0c             	sub    $0xc,%esp
f0106184:	68 ae 54 12 f0       	push   $0xf01254ae
f0106189:	e8 fd ad ff ff       	call   f0100f8b <cprintf>
f010618e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106191:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f0106196:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619d:	74 08                	je     f01061a7 <sched_kill_all+0x9d>
f010619f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a2:	8b 40 08             	mov    0x8(%eax),%eax
f01061a5:	eb 05                	jmp    f01061ac <sched_kill_all+0xa2>
f01061a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ac:	a3 58 16 6c f0       	mov    %eax,0xf06c1658
f01061b1:	a1 58 16 6c f0       	mov    0xf06c1658,%eax
f01061b6:	85 c0                	test   %eax,%eax
f01061b8:	75 8d                	jne    f0106147 <sched_kill_all+0x3d>
f01061ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061be:	75 87                	jne    f0106147 <sched_kill_all+0x3d>
f01061c0:	eb 10                	jmp    f01061d2 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 87 56 12 f0       	push   $0xf0125687
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061d2:	83 ec 0c             	sub    $0xc,%esp
f01061d5:	68 4c 55 12 f0       	push   $0xf012554c
f01061da:	e8 ac ad ff ff       	call   f0100f8b <cprintf>
f01061df:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061e9:	e9 96 01 00 00       	jmp    f0106384 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061ee:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01061f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061f6:	c1 e2 04             	shl    $0x4,%edx
f01061f9:	01 d0                	add    %edx,%eax
f01061fb:	8b 00                	mov    (%eax),%eax
f01061fd:	85 c0                	test   %eax,%eax
f01061ff:	0f 84 59 01 00 00    	je     f010635e <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106205:	83 ec 08             	sub    $0x8,%esp
f0106208:	ff 75 f0             	pushl  -0x10(%ebp)
f010620b:	68 a4 56 12 f0       	push   $0xf01256a4
f0106210:	e8 76 ad ff ff       	call   f0100f8b <cprintf>
f0106215:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106218:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010621d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106220:	c1 e2 04             	shl    $0x4,%edx
f0106223:	01 d0                	add    %edx,%eax
f0106225:	8b 00                	mov    (%eax),%eax
f0106227:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010622a:	e9 f5 00 00 00       	jmp    f0106324 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106232:	8d 50 20             	lea    0x20(%eax),%edx
f0106235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106238:	8b 40 10             	mov    0x10(%eax),%eax
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	52                   	push   %edx
f010623f:	50                   	push   %eax
f0106240:	68 74 56 12 f0       	push   $0xf0125674
f0106245:	e8 41 ad ff ff       	call   f0100f8b <cprintf>
f010624a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010624d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106251:	75 17                	jne    f010626a <sched_kill_all+0x160>
f0106253:	83 ec 04             	sub    $0x4,%esp
f0106256:	68 27 53 12 f0       	push   $0xf0125327
f010625b:	68 37 02 00 00       	push   $0x237
f0106260:	68 eb 52 12 f0       	push   $0xf01252eb
f0106265:	e8 cf a0 ff ff       	call   f0100339 <_panic>
f010626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626d:	8b 40 08             	mov    0x8(%eax),%eax
f0106270:	85 c0                	test   %eax,%eax
f0106272:	74 11                	je     f0106285 <sched_kill_all+0x17b>
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 08             	mov    0x8(%eax),%eax
f010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010627d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106280:	89 50 0c             	mov    %edx,0xc(%eax)
f0106283:	eb 16                	jmp    f010629b <sched_kill_all+0x191>
f0106285:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f010628a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010628d:	c1 e2 04             	shl    $0x4,%edx
f0106290:	01 c2                	add    %eax,%edx
f0106292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106295:	8b 40 0c             	mov    0xc(%eax),%eax
f0106298:	89 42 04             	mov    %eax,0x4(%edx)
f010629b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629e:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a1:	85 c0                	test   %eax,%eax
f01062a3:	74 11                	je     f01062b6 <sched_kill_all+0x1ac>
f01062a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ae:	8b 52 08             	mov    0x8(%edx),%edx
f01062b1:	89 50 08             	mov    %edx,0x8(%eax)
f01062b4:	eb 15                	jmp    f01062cb <sched_kill_all+0x1c1>
f01062b6:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01062bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062be:	c1 e2 04             	shl    $0x4,%edx
f01062c1:	01 c2                	add    %eax,%edx
f01062c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c6:	8b 40 08             	mov    0x8(%eax),%eax
f01062c9:	89 02                	mov    %eax,(%edx)
f01062cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062df:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01062e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062e7:	c1 e2 04             	shl    $0x4,%edx
f01062ea:	01 d0                	add    %edx,%eax
f01062ec:	8b 50 0c             	mov    0xc(%eax),%edx
f01062ef:	4a                   	dec    %edx
f01062f0:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f01062f3:	83 ec 0c             	sub    $0xc,%esp
f01062f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f9:	e8 53 57 00 00       	call   f010ba51 <env_free>
f01062fe:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106301:	83 ec 0c             	sub    $0xc,%esp
f0106304:	68 ae 54 12 f0       	push   $0xf01254ae
f0106309:	e8 7d ac ff ff       	call   f0100f8b <cprintf>
f010630e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106311:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106316:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106319:	c1 e2 04             	shl    $0x4,%edx
f010631c:	01 d0                	add    %edx,%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106324:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632c:	c1 e2 04             	shl    $0x4,%edx
f010632f:	01 d0                	add    %edx,%eax
f0106331:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106335:	74 08                	je     f010633f <sched_kill_all+0x235>
f0106337:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010633a:	8b 52 08             	mov    0x8(%edx),%edx
f010633d:	eb 05                	jmp    f0106344 <sched_kill_all+0x23a>
f010633f:	ba 00 00 00 00       	mov    $0x0,%edx
f0106344:	89 50 08             	mov    %edx,0x8(%eax)
f0106347:	8b 40 08             	mov    0x8(%eax),%eax
f010634a:	85 c0                	test   %eax,%eax
f010634c:	0f 85 dd fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f0106352:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106356:	0f 85 d3 fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f010635c:	eb 13                	jmp    f0106371 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635e:	83 ec 08             	sub    $0x8,%esp
f0106361:	ff 75 f0             	pushl  -0x10(%ebp)
f0106364:	68 a8 55 12 f0       	push   $0xf01255a8
f0106369:	e8 1d ac ff ff       	call   f0100f8b <cprintf>
f010636e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106371:	83 ec 0c             	sub    $0xc,%esp
f0106374:	68 4c 55 12 f0       	push   $0xf012554c
f0106379:	e8 0d ac ff ff       	call   f0100f8b <cprintf>
f010637e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106381:	ff 45 f0             	incl   -0x10(%ebp)
f0106384:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f0106389:	0f b6 c0             	movzbl %al,%eax
f010638c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638f:	0f 8f 59 fe ff ff    	jg     f01061ee <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106395:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f010639a:	85 c0                	test   %eax,%eax
f010639c:	0f 84 95 00 00 00    	je     f0106437 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a2:	83 ec 0c             	sub    $0xc,%esp
f01063a5:	68 d8 56 12 f0       	push   $0xf01256d8
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b2:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f01063b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ba:	eb 52                	jmp    f010640e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bf:	8d 50 20             	lea    0x20(%eax),%edx
f01063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c5:	8b 40 10             	mov    0x10(%eax),%eax
f01063c8:	83 ec 04             	sub    $0x4,%esp
f01063cb:	52                   	push   %edx
f01063cc:	50                   	push   %eax
f01063cd:	68 74 56 12 f0       	push   $0xf0125674
f01063d2:	e8 b4 ab ff ff       	call   f0100f8b <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063da:	83 ec 0c             	sub    $0xc,%esp
f01063dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e0:	e8 47 f2 ff ff       	call   f010562c <sched_remove_exit>
f01063e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e8:	83 ec 0c             	sub    $0xc,%esp
f01063eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ee:	e8 5e 56 00 00       	call   f010ba51 <env_free>
f01063f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f6:	83 ec 0c             	sub    $0xc,%esp
f01063f9:	68 ae 54 12 f0       	push   $0xf01254ae
f01063fe:	e8 88 ab ff ff       	call   f0100f8b <cprintf>
f0106403:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106406:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f010640b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106412:	74 08                	je     f010641c <sched_kill_all+0x312>
f0106414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106417:	8b 40 08             	mov    0x8(%eax),%eax
f010641a:	eb 05                	jmp    f0106421 <sched_kill_all+0x317>
f010641c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106421:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f0106426:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f010642b:	85 c0                	test   %eax,%eax
f010642d:	75 8d                	jne    f01063bc <sched_kill_all+0x2b2>
f010642f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106433:	75 87                	jne    f01063bc <sched_kill_all+0x2b2>
f0106435:	eb 10                	jmp    f0106447 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 ee 55 12 f0       	push   $0xf01255ee
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106447:	e8 4d 56 00 00       	call   f010ba99 <get_cpu_proc>
f010644c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106453:	74 6b                	je     f01064c0 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106458:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645e:	8b 40 18             	mov    0x18(%eax),%eax
f0106461:	83 f8 02             	cmp    $0x2,%eax
f0106464:	74 19                	je     f010647f <sched_kill_all+0x375>
f0106466:	68 b4 54 12 f0       	push   $0xf01254b4
f010646b:	68 d6 52 12 f0       	push   $0xf01252d6
f0106470:	68 57 02 00 00       	push   $0x257
f0106475:	68 eb 52 12 f0       	push   $0xf01252eb
f010647a:	e8 ba 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106482:	8d 50 20             	lea    0x20(%eax),%edx
f0106485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106488:	8b 40 10             	mov    0x10(%eax),%eax
f010648b:	83 ec 04             	sub    $0x4,%esp
f010648e:	52                   	push   %edx
f010648f:	50                   	push   %eax
f0106490:	68 d8 54 12 f0       	push   $0xf01254d8
f0106495:	e8 f1 aa ff ff       	call   f0100f8b <cprintf>
f010649a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649d:	83 ec 0c             	sub    $0xc,%esp
f01064a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a3:	e8 a9 55 00 00       	call   f010ba51 <env_free>
f01064a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ab:	83 ec 0c             	sub    $0xc,%esp
f01064ae:	68 ae 54 12 f0       	push   $0xf01254ae
f01064b3:	e8 d3 aa ff ff       	call   f0100f8b <cprintf>
f01064b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064bb:	e8 5a 57 00 00       	call   f010bc1a <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064c0:	83 ec 0c             	sub    $0xc,%esp
f01064c3:	68 e0 15 6c f0       	push   $0xf06c15e0
f01064c8:	e8 e2 98 00 00       	call   f010fdaf <release_spinlock>
f01064cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064d0:	e8 ed b8 ff ff       	call   f0101dc2 <get_into_prompt>

f01064d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d5:	55                   	push   %ebp
f01064d6:	89 e5                	mov    %esp,%ebp
f01064d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064db:	83 ec 0c             	sub    $0xc,%esp
f01064de:	68 e0 15 6c f0       	push   $0xf06c15e0
f01064e3:	e8 40 98 00 00       	call   f010fd28 <acquire_spinlock>
f01064e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f9:	e9 37 01 00 00       	jmp    f0106635 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fe:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106503:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106506:	c1 e2 04             	shl    $0x4,%edx
f0106509:	01 d0                	add    %edx,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 1d 01 00 00    	je     f0106632 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106524:	c1 e2 04             	shl    $0x4,%edx
f0106527:	01 d0                	add    %edx,%eax
f0106529:	8b 00                	mov    (%eax),%eax
f010652b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652e:	e9 c7 00 00 00       	jmp    f01065fa <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106537:	75 17                	jne    f0106550 <sched_exit_all_ready_envs+0x7b>
f0106539:	83 ec 04             	sub    $0x4,%esp
f010653c:	68 27 53 12 f0       	push   $0xf0125327
f0106541:	68 79 02 00 00       	push   $0x279
f0106546:	68 eb 52 12 f0       	push   $0xf01252eb
f010654b:	e8 e9 9d ff ff       	call   f0100339 <_panic>
f0106550:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106553:	8b 40 08             	mov    0x8(%eax),%eax
f0106556:	85 c0                	test   %eax,%eax
f0106558:	74 11                	je     f010656b <sched_exit_all_ready_envs+0x96>
f010655a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655d:	8b 40 08             	mov    0x8(%eax),%eax
f0106560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106563:	8b 52 0c             	mov    0xc(%edx),%edx
f0106566:	89 50 0c             	mov    %edx,0xc(%eax)
f0106569:	eb 16                	jmp    f0106581 <sched_exit_all_ready_envs+0xac>
f010656b:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106573:	c1 e2 04             	shl    $0x4,%edx
f0106576:	01 c2                	add    %eax,%edx
f0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010657b:	8b 40 0c             	mov    0xc(%eax),%eax
f010657e:	89 42 04             	mov    %eax,0x4(%edx)
f0106581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106584:	8b 40 0c             	mov    0xc(%eax),%eax
f0106587:	85 c0                	test   %eax,%eax
f0106589:	74 11                	je     f010659c <sched_exit_all_ready_envs+0xc7>
f010658b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106591:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106594:	8b 52 08             	mov    0x8(%edx),%edx
f0106597:	89 50 08             	mov    %edx,0x8(%eax)
f010659a:	eb 15                	jmp    f01065b1 <sched_exit_all_ready_envs+0xdc>
f010659c:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a4:	c1 e2 04             	shl    $0x4,%edx
f01065a7:	01 c2                	add    %eax,%edx
f01065a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ac:	8b 40 08             	mov    0x8(%eax),%eax
f01065af:	89 02                	mov    %eax,(%edx)
f01065b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c5:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065cd:	c1 e2 04             	shl    $0x4,%edx
f01065d0:	01 d0                	add    %edx,%eax
f01065d2:	8b 50 0c             	mov    0xc(%eax),%edx
f01065d5:	4a                   	dec    %edx
f01065d6:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f01065d9:	83 ec 0c             	sub    $0xc,%esp
f01065dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01065df:	e8 c1 ef ff ff       	call   f01055a5 <sched_insert_exit>
f01065e4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065e7:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065ef:	c1 e2 04             	shl    $0x4,%edx
f01065f2:	01 d0                	add    %edx,%eax
f01065f4:	8b 40 08             	mov    0x8(%eax),%eax
f01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065fa:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f01065ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106602:	c1 e2 04             	shl    $0x4,%edx
f0106605:	01 d0                	add    %edx,%eax
f0106607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010660b:	74 08                	je     f0106615 <sched_exit_all_ready_envs+0x140>
f010660d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106610:	8b 52 08             	mov    0x8(%edx),%edx
f0106613:	eb 05                	jmp    f010661a <sched_exit_all_ready_envs+0x145>
f0106615:	ba 00 00 00 00       	mov    $0x0,%edx
f010661a:	89 50 08             	mov    %edx,0x8(%eax)
f010661d:	8b 40 08             	mov    0x8(%eax),%eax
f0106620:	85 c0                	test   %eax,%eax
f0106622:	0f 85 0b ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
f0106628:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010662c:	0f 85 01 ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106632:	ff 45 f0             	incl   -0x10(%ebp)
f0106635:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f010663a:	0f b6 c0             	movzbl %al,%eax
f010663d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106640:	0f 8f b8 fe ff ff    	jg     f01064fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106646:	83 ec 0c             	sub    $0xc,%esp
f0106649:	68 e0 15 6c f0       	push   $0xf06c15e0
f010664e:	e8 5c 97 00 00       	call   f010fdaf <release_spinlock>
f0106653:	83 c4 10             	add    $0x10,%esp
}
f0106656:	90                   	nop
f0106657:	c9                   	leave  
f0106658:	c3                   	ret    

f0106659 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106659:	55                   	push   %ebp
f010665a:	89 e5                	mov    %esp,%ebp
	return ticks;
f010665c:	a1 88 1c 6c f0       	mov    0xf06c1c88,%eax
f0106661:	8b 15 8c 1c 6c f0    	mov    0xf06c1c8c,%edx
}
f0106667:	5d                   	pop    %ebp
f0106668:	c3                   	ret    

f0106669 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106669:	55                   	push   %ebp
f010666a:	89 e5                	mov    %esp,%ebp
f010666c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010666f:	83 ec 04             	sub    $0x4,%esp
f0106672:	68 04 57 12 f0       	push   $0xf0125704
f0106677:	68 8c 02 00 00       	push   $0x28c
f010667c:	68 eb 52 12 f0       	push   $0xf01252eb
f0106681:	e8 b3 9c ff ff       	call   f0100339 <_panic>

f0106686 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106686:	55                   	push   %ebp
f0106687:	89 e5                	mov    %esp,%ebp
f0106689:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010668c:	83 ec 04             	sub    $0x4,%esp
f010668f:	68 04 57 12 f0       	push   $0xf0125704
f0106694:	68 94 02 00 00       	push   $0x294
f0106699:	68 eb 52 12 f0       	push   $0xf01252eb
f010669e:	e8 96 9c ff ff       	call   f0100339 <_panic>

f01066a3 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066a9:	83 ec 04             	sub    $0x4,%esp
f01066ac:	68 04 57 12 f0       	push   $0xf0125704
f01066b1:	68 9c 02 00 00       	push   $0x29c
f01066b6:	68 eb 52 12 f0       	push   $0xf01252eb
f01066bb:	e8 79 9c ff ff       	call   f0100339 <_panic>

f01066c0 <get_load_average>:
}
int get_load_average()
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066c6:	83 ec 04             	sub    $0x4,%esp
f01066c9:	68 04 57 12 f0       	push   $0xf0125704
f01066ce:	68 a4 02 00 00       	push   $0x2a4
f01066d3:	68 eb 52 12 f0       	push   $0xf01252eb
f01066d8:	e8 5c 9c ff ff       	call   f0100339 <_panic>

f01066dd <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066dd:	55                   	push   %ebp
f01066de:	89 e5                	mov    %esp,%ebp
f01066e0:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f01066e5:	85 c0                	test   %eax,%eax
f01066e7:	75 07                	jne    f01066f0 <isSchedMethodRR+0x13>
f01066e9:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ee:	eb 05                	jmp    f01066f5 <isSchedMethodRR+0x18>
f01066f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01066f5:	5d                   	pop    %ebp
f01066f6:	c3                   	ret    

f01066f7 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066f7:	55                   	push   %ebp
f01066f8:	89 e5                	mov    %esp,%ebp
f01066fa:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f01066ff:	83 f8 01             	cmp    $0x1,%eax
f0106702:	75 07                	jne    f010670b <isSchedMethodMLFQ+0x14>
f0106704:	b8 01 00 00 00       	mov    $0x1,%eax
f0106709:	eb 05                	jmp    f0106710 <isSchedMethodMLFQ+0x19>
f010670b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106710:	5d                   	pop    %ebp
f0106711:	c3                   	ret    

f0106712 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106712:	55                   	push   %ebp
f0106713:	89 e5                	mov    %esp,%ebp
f0106715:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f010671a:	83 f8 02             	cmp    $0x2,%eax
f010671d:	75 07                	jne    f0106726 <isSchedMethodBSD+0x14>
f010671f:	b8 01 00 00 00       	mov    $0x1,%eax
f0106724:	eb 05                	jmp    f010672b <isSchedMethodBSD+0x19>
f0106726:	b8 00 00 00 00       	mov    $0x0,%eax
f010672b:	5d                   	pop    %ebp
f010672c:	c3                   	ret    

f010672d <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010672d:	55                   	push   %ebp
f010672e:	89 e5                	mov    %esp,%ebp
f0106730:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106733:	c7 05 b8 17 6c f0 00 	movl   $0x0,0xf06c17b8
f010673a:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010673d:	83 ec 0c             	sub    $0xc,%esp
f0106740:	6a 0a                	push   $0xa
f0106742:	e8 60 02 00 00       	call   f01069a7 <sched_init_RR>
f0106747:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010674a:	83 ec 0c             	sub    $0xc,%esp
f010674d:	68 50 16 6c f0       	push   $0xf06c1650
f0106752:	e8 12 e8 ff ff       	call   f0104f69 <init_queue>
f0106757:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010675a:	83 ec 0c             	sub    $0xc,%esp
f010675d:	68 60 16 6c f0       	push   $0xf06c1660
f0106762:	e8 02 e8 ff ff       	call   f0104f69 <init_queue>
f0106767:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010676a:	e8 9d 09 00 00       	call   f010710c <mycpu>
f010676f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106776:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106779:	83 ec 08             	sub    $0x8,%esp
f010677c:	68 18 57 12 f0       	push   $0xf0125718
f0106781:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106786:	e8 6c 95 00 00       	call   f010fcf7 <init_spinlock>
f010678b:	83 c4 10             	add    $0x10,%esp
}
f010678e:	90                   	nop
f010678f:	c9                   	leave  
f0106790:	c3                   	ret    

f0106791 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106791:	55                   	push   %ebp
f0106792:	89 e5                	mov    %esp,%ebp
f0106794:	53                   	push   %ebx
f0106795:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106798:	9c                   	pushf  
f0106799:	58                   	pop    %eax
f010679a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010679d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067a0:	25 00 02 00 00       	and    $0x200,%eax
f01067a5:	85 c0                	test   %eax,%eax
f01067a7:	74 14                	je     f01067bd <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067a9:	83 ec 04             	sub    $0x4,%esp
f01067ac:	68 2c 57 12 f0       	push   $0xf012572c
f01067b1:	6a 37                	push   $0x37
f01067b3:	68 62 57 12 f0       	push   $0xf0125762
f01067b8:	e8 7c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067bd:	e8 4a 09 00 00       	call   f010710c <mycpu>
f01067c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067cf:	00 00 00 

	chk1();
f01067d2:	e8 bb 86 01 00       	call   f011ee92 <chk1>
	c->scheduler_status = SCH_STARTED;
f01067d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067da:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067e1:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067f2:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067f3:	83 ec 0c             	sub    $0xc,%esp
f01067f6:	68 e0 15 6c f0       	push   $0xf06c15e0
f01067fb:	e8 28 95 00 00       	call   f010fd28 <acquire_spinlock>
f0106800:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106803:	a1 d4 1a 6c f0       	mov    0xf06c1ad4,%eax
f0106808:	8b 04 85 4c f9 17 f0 	mov    -0xfe806b4(,%eax,4),%eax
f010680f:	ff d0                	call   *%eax
f0106811:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106814:	e8 80 52 00 00       	call   f010ba99 <get_cpu_proc>
f0106819:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010681c:	83 ec 0c             	sub    $0xc,%esp
f010681f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106822:	e8 9b 52 00 00       	call   f010bac2 <set_cpu_proc>
f0106827:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010682a:	83 ec 0c             	sub    $0xc,%esp
f010682d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106830:	e8 63 86 01 00       	call   f011ee98 <chk2>
f0106835:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106838:	83 ec 0c             	sub    $0xc,%esp
f010683b:	ff 75 e0             	pushl  -0x20(%ebp)
f010683e:	e8 7f 52 00 00       	call   f010bac2 <set_cpu_proc>
f0106843:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106846:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010684a:	0f 84 d6 00 00 00    	je     f0106926 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106850:	83 ec 0c             	sub    $0xc,%esp
f0106853:	ff 75 e8             	pushl  -0x18(%ebp)
f0106856:	e8 67 52 00 00       	call   f010bac2 <set_cpu_proc>
f010685b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010685e:	83 ec 0c             	sub    $0xc,%esp
f0106861:	ff 75 e8             	pushl  -0x18(%ebp)
f0106864:	e8 d4 54 00 00       	call   f010bd3d <switchuvm>
f0106869:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106879:	8b 40 04             	mov    0x4(%eax),%eax
f010687c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010687f:	83 c2 04             	add    $0x4,%edx
f0106882:	83 ec 08             	sub    $0x8,%esp
f0106885:	50                   	push   %eax
f0106886:	52                   	push   %edx
f0106887:	e8 e5 e2 ff ff       	call   f0104b71 <context_switch>
f010688c:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010688f:	9c                   	pushf  
f0106890:	58                   	pop    %eax
f0106891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106894:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106897:	25 00 02 00 00       	and    $0x200,%eax
f010689c:	85 c0                	test   %eax,%eax
f010689e:	74 14                	je     f01068b4 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068a0:	83 ec 04             	sub    $0x4,%esp
f01068a3:	68 74 57 12 f0       	push   $0xf0125774
f01068a8:	6a 74                	push   $0x74
f01068aa:	68 62 57 12 f0       	push   $0xf0125762
f01068af:	e8 85 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068b4:	e8 01 e4 ff ff       	call   f0104cba <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068b9:	e8 db 51 00 00       	call   f010ba99 <get_cpu_proc>
f01068be:	89 c2                	mov    %eax,%edx
f01068c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068c9:	39 c2                	cmp    %eax,%edx
f01068cb:	74 16                	je     f01068e3 <fos_scheduler+0x152>
f01068cd:	68 ab 57 12 f0       	push   $0xf01257ab
f01068d2:	68 c5 57 12 f0       	push   $0xf01257c5
f01068d7:	6a 7d                	push   $0x7d
f01068d9:	68 62 57 12 f0       	push   $0xf0125762
f01068de:	e8 56 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f01068e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ec:	8b 40 18             	mov    0x18(%eax),%eax
f01068ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068f2:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068f6:	75 16                	jne    f010690e <fos_scheduler+0x17d>
f01068f8:	68 da 57 12 f0       	push   $0xf01257da
f01068fd:	68 c5 57 12 f0       	push   $0xf01257c5
f0106902:	6a 7f                	push   $0x7f
f0106904:	68 62 57 12 f0       	push   $0xf0125762
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010690e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106912:	74 12                	je     f0106926 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106914:	e8 0d 54 00 00       	call   f010bd26 <switchkvm>
					set_cpu_proc(NULL);
f0106919:	83 ec 0c             	sub    $0xc,%esp
f010691c:	6a 00                	push   $0x0
f010691e:	e8 9f 51 00 00       	call   f010bac2 <set_cpu_proc>
f0106923:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010692a:	0f 85 d3 fe ff ff    	jne    f0106803 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106930:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010693e:	eb 3e                	jmp    f010697e <fos_scheduler+0x1ed>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106940:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f0106946:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106949:	89 d0                	mov    %edx,%eax
f010694b:	c1 e0 03             	shl    $0x3,%eax
f010694e:	01 d0                	add    %edx,%eax
f0106950:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106957:	01 d8                	add    %ebx,%eax
f0106959:	01 c0                	add    %eax,%eax
f010695b:	01 d0                	add    %edx,%eax
f010695d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106964:	01 d8                	add    %ebx,%eax
f0106966:	01 d0                	add    %edx,%eax
f0106968:	01 c8                	add    %ecx,%eax
f010696a:	8b 40 18             	mov    0x18(%eax),%eax
f010696d:	83 f8 03             	cmp    $0x3,%eax
f0106970:	75 09                	jne    f010697b <fos_scheduler+0x1ea>
			{
				is_any_blocked = 1;
f0106972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106979:	eb 0d                	jmp    f0106988 <fos_scheduler+0x1f7>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f010697b:	ff 45 f0             	incl   -0x10(%ebp)
f010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106981:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106986:	76 b8                	jbe    f0106940 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106988:	83 ec 0c             	sub    $0xc,%esp
f010698b:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106990:	e8 1a 94 00 00       	call   f010fdaf <release_spinlock>
f0106995:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106998:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699c:	0f 8f 50 fe ff ff    	jg     f01067f2 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a2:	e8 1b b4 ff ff       	call   f0101dc2 <get_into_prompt>

f01069a7 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069a7:	55                   	push   %ebp
f01069a8:	89 e5                	mov    %esp,%ebp
f01069aa:	83 ec 28             	sub    $0x28,%esp
f01069ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b0:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b3:	c6 05 44 2d 6c f0 01 	movb   $0x1,0xf06c2d44
#if USE_KHEAP
	sched_delete_ready_queues();
f01069ba:	e8 5a e8 ff ff       	call   f0105219 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069bf:	83 ec 0c             	sub    $0xc,%esp
f01069c2:	6a 10                	push   $0x10
f01069c4:	e8 d6 2b 00 00       	call   f010959f <kmalloc>
f01069c9:	83 c4 10             	add    $0x10,%esp
f01069cc:	a3 70 16 6c f0       	mov    %eax,0xf06c1670
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f01069d1:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f01069d6:	0f b6 c0             	movzbl %al,%eax
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	50                   	push   %eax
f01069dd:	e8 bd 2b 00 00       	call   f010959f <kmalloc>
f01069e2:	83 c4 10             	add    $0x10,%esp
f01069e5:	a3 a4 19 6c f0       	mov    %eax,0xf06c19a4
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069ea:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f01069ef:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01069f2:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f01069f4:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f01069f9:	8a 00                	mov    (%eax),%al
f01069fb:	0f b6 c0             	movzbl %al,%eax
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	50                   	push   %eax
f0106a02:	e8 7c e3 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106a07:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a0a:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106a0f:	83 ec 0c             	sub    $0xc,%esp
f0106a12:	50                   	push   %eax
f0106a13:	e8 51 e5 ff ff       	call   f0104f69 <init_queue>
f0106a18:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a1b:	e8 c2 e4 ff ff       	call   f0104ee2 <kclock_read_cnt0_latch>
f0106a20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a24:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a28:	83 ec 08             	sub    $0x8,%esp
f0106a2b:	50                   	push   %eax
f0106a2c:	68 f0 57 12 f0       	push   $0xf01257f0
f0106a31:	e8 55 a5 ff ff       	call   f0100f8b <cprintf>
f0106a36:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a39:	e8 ce 06 00 00       	call   f010710c <mycpu>
f0106a3e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a45:	00 00 00 
	scheduler_method = SCH_RR;
f0106a48:	c7 05 d4 1a 6c f0 00 	movl   $0x0,0xf06c1ad4
f0106a4f:	00 00 00 
	//=========================================
	//=========================================
}
f0106a52:	90                   	nop
f0106a53:	c9                   	leave  
f0106a54:	c3                   	ret    

f0106a55 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a55:	55                   	push   %ebp
f0106a56:	89 e5                	mov    %esp,%ebp
f0106a58:	83 ec 18             	sub    $0x18,%esp
f0106a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a5e:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a61:	e8 b3 e7 ff ff       	call   f0105219 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a66:	83 ec 04             	sub    $0x4,%esp
f0106a69:	68 18 58 12 f0       	push   $0xf0125818
f0106a6e:	68 ce 00 00 00       	push   $0xce
f0106a73:	68 62 57 12 f0       	push   $0xf0125762
f0106a78:	e8 bc 98 ff ff       	call   f0100339 <_panic>

f0106a7d <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a7d:	55                   	push   %ebp
f0106a7e:	89 e5                	mov    %esp,%ebp
f0106a80:	83 ec 18             	sub    $0x18,%esp
f0106a83:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a89:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a8c:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a8f:	83 ec 04             	sub    $0x4,%esp
f0106a92:	68 18 58 12 f0       	push   $0xf0125818
f0106a97:	68 e4 00 00 00       	push   $0xe4
f0106a9c:	68 62 57 12 f0       	push   $0xf0125762
f0106aa1:	e8 93 98 ff ff       	call   f0100339 <_panic>

f0106aa6 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106aa6:	55                   	push   %ebp
f0106aa7:	89 e5                	mov    %esp,%ebp
f0106aa9:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aac:	83 ec 0c             	sub    $0xc,%esp
f0106aaf:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106ab4:	e8 88 94 00 00       	call   f010ff41 <holding_spinlock>
f0106ab9:	83 c4 10             	add    $0x10,%esp
f0106abc:	85 c0                	test   %eax,%eax
f0106abe:	75 17                	jne    f0106ad7 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	68 2c 58 12 f0       	push   $0xf012582c
f0106ac8:	68 fe 00 00 00       	push   $0xfe
f0106acd:	68 62 57 12 f0       	push   $0xf0125762
f0106ad2:	e8 62 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ade:	e8 b6 4f 00 00       	call   f010ba99 <get_cpu_proc>
f0106ae3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aea:	74 14                	je     f0106b00 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aec:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106af1:	83 ec 08             	sub    $0x8,%esp
f0106af4:	ff 75 f0             	pushl  -0x10(%ebp)
f0106af7:	50                   	push   %eax
f0106af8:	e8 ad e4 ff ff       	call   f0104faa <enqueue>
f0106afd:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b00:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f0106b05:	83 ec 0c             	sub    $0xc,%esp
f0106b08:	50                   	push   %eax
f0106b09:	e8 2d e5 ff ff       	call   f010503b <dequeue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
f0106b11:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b14:	a1 a4 19 6c f0       	mov    0xf06c19a4,%eax
f0106b19:	8a 00                	mov    (%eax),%al
f0106b1b:	0f b6 c0             	movzbl %al,%eax
f0106b1e:	83 ec 0c             	sub    $0xc,%esp
f0106b21:	50                   	push   %eax
f0106b22:	e8 5c e2 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106b27:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106b3d:	e8 ff 93 00 00       	call   f010ff41 <holding_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
f0106b45:	85 c0                	test   %eax,%eax
f0106b47:	75 17                	jne    f0106b60 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b49:	83 ec 04             	sub    $0x4,%esp
f0106b4c:	68 78 58 12 f0       	push   $0xf0125878
f0106b51:	68 1d 01 00 00       	push   $0x11d
f0106b56:	68 62 57 12 f0       	push   $0xf0125762
f0106b5b:	e8 d9 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b60:	83 ec 04             	sub    $0x4,%esp
f0106b63:	68 18 58 12 f0       	push   $0xf0125818
f0106b68:	68 23 01 00 00       	push   $0x123
f0106b6d:	68 62 57 12 f0       	push   $0xf0125762
f0106b72:	e8 c2 97 ff ff       	call   f0100339 <_panic>

f0106b77 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b77:	55                   	push   %ebp
f0106b78:	89 e5                	mov    %esp,%ebp
f0106b7a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b7d:	83 ec 0c             	sub    $0xc,%esp
f0106b80:	68 e0 15 6c f0       	push   $0xf06c15e0
f0106b85:	e8 b7 93 00 00       	call   f010ff41 <holding_spinlock>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	85 c0                	test   %eax,%eax
f0106b8f:	75 17                	jne    f0106ba8 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b91:	83 ec 04             	sub    $0x4,%esp
f0106b94:	68 c8 58 12 f0       	push   $0xf01258c8
f0106b99:	68 2e 01 00 00       	push   $0x12e
f0106b9e:	68 62 57 12 f0       	push   $0xf0125762
f0106ba3:	e8 91 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ba8:	83 ec 04             	sub    $0x4,%esp
f0106bab:	68 18 58 12 f0       	push   $0xf0125818
f0106bb0:	68 34 01 00 00       	push   $0x134
f0106bb5:	68 62 57 12 f0       	push   $0xf0125762
f0106bba:	e8 7a 97 ff ff       	call   f0100339 <_panic>

f0106bbf <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bbf:	55                   	push   %ebp
f0106bc0:	89 e5                	mov    %esp,%ebp
f0106bc2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bc5:	e8 48 fb ff ff       	call   f0106712 <isSchedMethodBSD>
f0106bca:	85 c0                	test   %eax,%eax
f0106bcc:	74 17                	je     f0106be5 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bce:	83 ec 04             	sub    $0x4,%esp
f0106bd1:	68 18 58 12 f0       	push   $0xf0125818
f0106bd6:	68 43 01 00 00       	push   $0x143
f0106bdb:	68 62 57 12 f0       	push   $0xf0125762
f0106be0:	e8 54 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106be5:	a1 88 1c 6c f0       	mov    0xf06c1c88,%eax
f0106bea:	8b 15 8c 1c 6c f0    	mov    0xf06c1c8c,%edx
f0106bf0:	83 c0 01             	add    $0x1,%eax
f0106bf3:	83 d2 00             	adc    $0x0,%edx
f0106bf6:	a3 88 1c 6c f0       	mov    %eax,0xf06c1c88
f0106bfb:	89 15 8c 1c 6c f0    	mov    %edx,0xf06c1c8c
	struct Env* p = get_cpu_proc();
f0106c01:	e8 93 4e 00 00       	call   f010ba99 <get_cpu_proc>
f0106c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c0d:	74 30                	je     f0106c3f <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c12:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106c18:	8d 50 01             	lea    0x1(%eax),%edx
f0106c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c1e:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c24:	83 ec 0c             	sub    $0xc,%esp
f0106c27:	6a 01                	push   $0x1
f0106c29:	e8 a7 8a 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f0106c2e:	83 c4 10             	add    $0x10,%esp
f0106c31:	85 c0                	test   %eax,%eax
f0106c33:	74 05                	je     f0106c3a <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c35:	e8 08 00 00 00       	call   f0106c42 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c3a:	e8 7c 4f 00 00       	call   f010bbbb <yield>
	}
	/*****************************************/
}
f0106c3f:	90                   	nop
f0106c40:	c9                   	leave  
f0106c41:	c3                   	ret    

f0106c42 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c42:	55                   	push   %ebp
f0106c43:	89 e5                	mov    %esp,%ebp
f0106c45:	53                   	push   %ebx
f0106c46:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c49:	e8 4b 4e 00 00       	call   f010ba99 <get_cpu_proc>
f0106c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c55:	0f 84 a1 01 00 00    	je     f0106dfc <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c67:	eb 78                	jmp    f0106ce1 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6c:	8b 00                	mov    (%eax),%eax
f0106c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c74:	8b 40 64             	mov    0x64(%eax),%eax
f0106c77:	83 ec 08             	sub    $0x8,%esp
f0106c7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c7d:	50                   	push   %eax
f0106c7e:	e8 1a 31 00 00       	call   f0109d9d <pt_get_page_permissions>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c8c:	8b 40 08             	mov    0x8(%eax),%eax
f0106c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c95:	83 e0 20             	and    $0x20,%eax
f0106c98:	85 c0                	test   %eax,%eax
f0106c9a:	74 2b                	je     f0106cc7 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c9f:	c1 e8 02             	shr    $0x2,%eax
f0106ca2:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106ca7:	89 c2                	mov    %eax,%edx
f0106ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cac:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cb2:	8b 40 64             	mov    0x64(%eax),%eax
f0106cb5:	6a 20                	push   $0x20
f0106cb7:	6a 00                	push   $0x0
f0106cb9:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cbc:	50                   	push   %eax
f0106cbd:	e8 17 30 00 00       	call   f0109cd9 <pt_set_page_permissions>
f0106cc2:	83 c4 10             	add    $0x10,%esp
f0106cc5:	eb 0e                	jmp    f0106cd5 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cca:	c1 e8 02             	shr    $0x2,%eax
f0106ccd:	89 c2                	mov    %eax,%edx
f0106ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd2:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cd8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ce5:	74 08                	je     f0106cef <update_WS_time_stamps+0xad>
f0106ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cea:	8b 40 10             	mov    0x10(%eax),%eax
f0106ced:	eb 05                	jmp    f0106cf4 <update_WS_time_stamps+0xb2>
f0106cef:	b8 00 00 00 00       	mov    $0x0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0106cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d00:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106d06:	85 c0                	test   %eax,%eax
f0106d08:	0f 85 5b ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
f0106d0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d12:	0f 85 51 ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d1f:	e9 ce 00 00 00       	jmp    f0106df2 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d24:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d27:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2a:	89 d0                	mov    %edx,%eax
f0106d2c:	01 c0                	add    %eax,%eax
f0106d2e:	01 d0                	add    %edx,%eax
f0106d30:	c1 e0 03             	shl    $0x3,%eax
f0106d33:	01 c8                	add    %ecx,%eax
f0106d35:	05 b0 00 00 00       	add    $0xb0,%eax
f0106d3a:	8a 00                	mov    (%eax),%al
f0106d3c:	3c 01                	cmp    $0x1,%al
f0106d3e:	0f 84 ab 00 00 00    	je     f0106def <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d4a:	89 d0                	mov    %edx,%eax
f0106d4c:	01 c0                	add    %eax,%eax
f0106d4e:	01 d0                	add    %edx,%eax
f0106d50:	c1 e0 03             	shl    $0x3,%eax
f0106d53:	01 c8                	add    %ecx,%eax
f0106d55:	05 ac 00 00 00       	add    $0xac,%eax
f0106d5a:	8b 00                	mov    (%eax),%eax
f0106d5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d65:	89 d0                	mov    %edx,%eax
f0106d67:	01 c0                	add    %eax,%eax
f0106d69:	01 d0                	add    %edx,%eax
f0106d6b:	c1 e0 03             	shl    $0x3,%eax
f0106d6e:	01 c8                	add    %ecx,%eax
f0106d70:	05 b4 00 00 00       	add    $0xb4,%eax
f0106d75:	8b 00                	mov    (%eax),%eax
f0106d77:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d7d:	8b 40 64             	mov    0x64(%eax),%eax
f0106d80:	83 ec 08             	sub    $0x8,%esp
f0106d83:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d86:	50                   	push   %eax
f0106d87:	e8 ed 30 00 00       	call   f0109e79 <pd_is_table_used>
f0106d8c:	83 c4 10             	add    $0x10,%esp
f0106d8f:	85 c0                	test   %eax,%eax
f0106d91:	74 3c                	je     f0106dcf <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d96:	c1 e8 02             	shr    $0x2,%eax
f0106d99:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d9e:	89 c1                	mov    %eax,%ecx
f0106da0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da6:	89 d0                	mov    %edx,%eax
f0106da8:	01 c0                	add    %eax,%eax
f0106daa:	01 d0                	add    %edx,%eax
f0106dac:	c1 e0 03             	shl    $0x3,%eax
f0106daf:	01 d8                	add    %ebx,%eax
f0106db1:	05 b4 00 00 00       	add    $0xb4,%eax
f0106db6:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dbb:	8b 40 64             	mov    0x64(%eax),%eax
f0106dbe:	83 ec 08             	sub    $0x8,%esp
f0106dc1:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dc4:	50                   	push   %eax
f0106dc5:	e8 d3 30 00 00       	call   f0109e9d <pd_set_table_unused>
f0106dca:	83 c4 10             	add    $0x10,%esp
f0106dcd:	eb 20                	jmp    f0106def <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dd2:	c1 e8 02             	shr    $0x2,%eax
f0106dd5:	89 c1                	mov    %eax,%ecx
f0106dd7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dda:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ddd:	89 d0                	mov    %edx,%eax
f0106ddf:	01 c0                	add    %eax,%eax
f0106de1:	01 d0                	add    %edx,%eax
f0106de3:	c1 e0 03             	shl    $0x3,%eax
f0106de6:	01 d8                	add    %ebx,%eax
f0106de8:	05 b4 00 00 00       	add    $0xb4,%eax
f0106ded:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106def:	ff 45 f0             	incl   -0x10(%ebp)
f0106df2:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106df6:	0f 8e 28 ff ff ff    	jle    f0106d24 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106dfc:	90                   	nop
f0106dfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e00:	c9                   	leave  
f0106e01:	c3                   	ret    

f0106e02 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e02:	55                   	push   %ebp
f0106e03:	89 e5                	mov    %esp,%ebp
f0106e05:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e08:	c7 05 ec 8a 69 f0 01 	movl   $0x1,0xf0698aec
f0106e0f:	00 00 00 
f0106e12:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e19:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e1d:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e23:	ee                   	out    %al,(%dx)
f0106e24:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e2b:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e2f:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e35:	ee                   	out    %al,(%dx)
f0106e36:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e3d:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e41:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e47:	ee                   	out    %al,(%dx)
f0106e48:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e4f:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e53:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e56:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e59:	ee                   	out    %al,(%dx)
f0106e5a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e61:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e65:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e6b:	ee                   	out    %al,(%dx)
f0106e6c:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e73:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e77:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e7d:	ee                   	out    %al,(%dx)
f0106e7e:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e85:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e89:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e8f:	ee                   	out    %al,(%dx)
f0106e90:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e97:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e9b:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ea1:	ee                   	out    %al,(%dx)
f0106ea2:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ea9:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ead:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eb3:	ee                   	out    %al,(%dx)
f0106eb4:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ebb:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ebf:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106ec2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106ec5:	ee                   	out    %al,(%dx)
f0106ec6:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ecd:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ed1:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ed4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ed7:	ee                   	out    %al,(%dx)
f0106ed8:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106edf:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ee3:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ee6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106ee9:	ee                   	out    %al,(%dx)
f0106eea:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ef1:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ef5:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ef8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106efb:	ee                   	out    %al,(%dx)
f0106efc:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f03:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f07:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f0d:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f0e:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f14:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f18:	74 15                	je     f0106f2f <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f1a:	66 a1 58 f9 17 f0    	mov    0xf017f958,%ax
f0106f20:	0f b7 c0             	movzwl %ax,%eax
f0106f23:	83 ec 0c             	sub    $0xc,%esp
f0106f26:	50                   	push   %eax
f0106f27:	e8 06 00 00 00       	call   f0106f32 <irq_setmask_8259A>
f0106f2c:	83 c4 10             	add    $0x10,%esp
}
f0106f2f:	90                   	nop
f0106f30:	c9                   	leave  
f0106f31:	c3                   	ret    

f0106f32 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f32:	55                   	push   %ebp
f0106f33:	89 e5                	mov    %esp,%ebp
f0106f35:	83 ec 14             	sub    $0x14,%esp
f0106f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f3b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f3f:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f0106f44:	85 c0                	test   %eax,%eax
f0106f46:	74 34                	je     f0106f7c <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f4b:	0f b6 c0             	movzbl %al,%eax
f0106f4e:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f55:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f58:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f5e:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f62:	66 c1 e8 08          	shr    $0x8,%ax
f0106f66:	0f b6 c0             	movzbl %al,%eax
f0106f69:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f70:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f73:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f76:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f79:	ee                   	out    %al,(%dx)
f0106f7a:	eb 01                	jmp    f0106f7d <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f7c:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f7d:	c9                   	leave  
f0106f7e:	c3                   	ret    

f0106f7f <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f7f:	55                   	push   %ebp
f0106f80:	89 e5                	mov    %esp,%ebp
f0106f82:	53                   	push   %ebx
f0106f83:	83 ec 14             	sub    $0x14,%esp
f0106f86:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f89:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f8c:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f0106f91:	85 c0                	test   %eax,%eax
f0106f93:	74 58                	je     f0106fed <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f95:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f99:	77 08                	ja     f0106fa3 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f9b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fa1:	eb 0a                	jmp    f0106fad <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fa3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fa9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fad:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	89 c2                	mov    %eax,%edx
f0106fb9:	ec                   	in     (%dx),%al
f0106fba:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fbd:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fc0:	88 c2                	mov    %al,%dl
f0106fc2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fc6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fcb:	88 c1                	mov    %al,%cl
f0106fcd:	d3 e3                	shl    %cl,%ebx
f0106fcf:	89 d8                	mov    %ebx,%eax
f0106fd1:	09 d0                	or     %edx,%eax
f0106fd3:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fd6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fda:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fde:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fe1:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fe4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fea:	ee                   	out    %al,(%dx)
f0106feb:	eb 01                	jmp    f0106fee <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fed:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fee:	83 c4 14             	add    $0x14,%esp
f0106ff1:	5b                   	pop    %ebx
f0106ff2:	5d                   	pop    %ebp
f0106ff3:	c3                   	ret    

f0106ff4 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ff4:	55                   	push   %ebp
f0106ff5:	89 e5                	mov    %esp,%ebp
f0106ff7:	53                   	push   %ebx
f0106ff8:	83 ec 14             	sub    $0x14,%esp
f0106ffb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ffe:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107001:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f0107006:	85 c0                	test   %eax,%eax
f0107008:	74 5a                	je     f0107064 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010700a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010700e:	77 08                	ja     f0107018 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107010:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107016:	eb 0a                	jmp    f0107022 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107018:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010701e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107026:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107029:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010702c:	89 c2                	mov    %eax,%edx
f010702e:	ec                   	in     (%dx),%al
f010702f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107032:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107035:	88 c2                	mov    %al,%dl
f0107037:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010703b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107040:	88 c1                	mov    %al,%cl
f0107042:	d3 e3                	shl    %cl,%ebx
f0107044:	89 d8                	mov    %ebx,%eax
f0107046:	f7 d0                	not    %eax
f0107048:	21 d0                	and    %edx,%eax
f010704a:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010704d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107051:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107055:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107058:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010705b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010705e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107061:	ee                   	out    %al,(%dx)
f0107062:	eb 01                	jmp    f0107065 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107064:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107065:	83 c4 14             	add    $0x14,%esp
f0107068:	5b                   	pop    %ebx
f0107069:	5d                   	pop    %ebp
f010706a:	c3                   	ret    

f010706b <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010706b:	55                   	push   %ebp
f010706c:	89 e5                	mov    %esp,%ebp
f010706e:	53                   	push   %ebx
f010706f:	83 ec 14             	sub    $0x14,%esp
f0107072:	8b 45 08             	mov    0x8(%ebp),%eax
f0107075:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107078:	a1 ec 8a 69 f0       	mov    0xf0698aec,%eax
f010707d:	85 c0                	test   %eax,%eax
f010707f:	75 07                	jne    f0107088 <irq_get_mask+0x1d>
		return -1;
f0107081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107086:	eb 45                	jmp    f01070cd <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107088:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010708c:	77 08                	ja     f0107096 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010708e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107094:	eb 0a                	jmp    f01070a0 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107096:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010709c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070aa:	89 c2                	mov    %eax,%edx
f01070ac:	ec                   	in     (%dx),%al
f01070ad:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070b0:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070b3:	88 c2                	mov    %al,%dl
f01070b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070be:	88 c1                	mov    %al,%cl
f01070c0:	d3 e3                	shl    %cl,%ebx
f01070c2:	89 d8                	mov    %ebx,%eax
f01070c4:	21 d0                	and    %edx,%eax
f01070c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070cd:	83 c4 14             	add    $0x14,%esp
f01070d0:	5b                   	pop    %ebx
f01070d1:	5d                   	pop    %ebp
f01070d2:	c3                   	ret    

f01070d3 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070d3:	55                   	push   %ebp
f01070d4:	89 e5                	mov    %esp,%ebp
f01070d6:	83 ec 14             	sub    $0x14,%esp
f01070d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01070dc:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070df:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070e3:	76 12                	jbe    f01070f7 <pic_sendEOI+0x24>
f01070e5:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070ec:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070f0:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070f6:	ee                   	out    %al,(%dx)
f01070f7:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070fe:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107102:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107105:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107108:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107109:	90                   	nop
f010710a:	c9                   	leave  
f010710b:	c3                   	ret    

f010710c <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f010710c:	55                   	push   %ebp
f010710d:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010710f:	b8 c0 17 6c f0       	mov    $0xf06c17c0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107114:	5d                   	pop    %ebp
f0107115:	c3                   	ret    

f0107116 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107116:	55                   	push   %ebp
f0107117:	89 e5                	mov    %esp,%ebp
f0107119:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010711c:	e8 eb ff ff ff       	call   f010710c <mycpu>
f0107121:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107127:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010712e:	00 00 00 
  c->ncli = 0;
f0107131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107134:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010713b:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010713e:	9c                   	pushf  
f010713f:	58                   	pop    %eax
f0107140:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107143:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107146:	25 00 02 00 00       	and    $0x200,%eax
f010714b:	85 c0                	test   %eax,%eax
f010714d:	0f 95 c0             	setne  %al
f0107150:	0f b6 d0             	movzbl %al,%edx
f0107153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107156:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107170:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107173:	8b 45 08             	mov    0x8(%ebp),%eax
f0107176:	40                   	inc    %eax
f0107177:	c1 e0 0f             	shl    $0xf,%eax
f010717a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010717f:	29 c2                	sub    %eax,%edx
f0107181:	89 d0                	mov    %edx,%eax
f0107183:	89 c2                	mov    %eax,%edx
f0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107188:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010718b:	e8 18 01 00 00       	call   f01072a8 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107190:	e8 d4 5f 00 00       	call   f010d169 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	83 c0 0c             	add    $0xc,%eax
f010719b:	83 ec 04             	sub    $0x4,%esp
f010719e:	6a 68                	push   $0x68
f01071a0:	6a 00                	push   $0x0
f01071a2:	50                   	push   %eax
f01071a3:	e8 1c 8d 01 00       	call   f011fec4 <memset>
f01071a8:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ae:	05 a4 00 00 00       	add    $0xa4,%eax
f01071b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071c6:	f0 87 02             	lock xchg %eax,(%edx)
f01071c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071cc:	90                   	nop
f01071cd:	c9                   	leave  
f01071ce:	c3                   	ret    

f01071cf <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071cf:	55                   	push   %ebp
f01071d0:	89 e5                	mov    %esp,%ebp
f01071d2:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071d5:	9c                   	pushf  
f01071d6:	58                   	pop    %eax
f01071d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071e0:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071e1:	e8 26 ff ff ff       	call   f010710c <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	85 c0                	test   %eax,%eax
f01071f4:	75 13                	jne    f0107209 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071f9:	25 00 02 00 00       	and    $0x200,%eax
f01071fe:	89 c2                	mov    %eax,%edx
f0107200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107203:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107212:	8d 50 01             	lea    0x1(%eax),%edx
f0107215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107218:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010721e:	90                   	nop
f010721f:	c9                   	leave  
f0107220:	c3                   	ret    

f0107221 <popcli>:

void popcli(void)
{
f0107221:	55                   	push   %ebp
f0107222:	89 e5                	mov    %esp,%ebp
f0107224:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107227:	9c                   	pushf  
f0107228:	58                   	pop    %eax
f0107229:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010722c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010722f:	25 00 02 00 00       	and    $0x200,%eax
f0107234:	85 c0                	test   %eax,%eax
f0107236:	74 14                	je     f010724c <popcli+0x2b>
    panic("popcli - interruptible");
f0107238:	83 ec 04             	sub    $0x4,%esp
f010723b:	68 15 59 12 f0       	push   $0xf0125915
f0107240:	6a 5e                	push   $0x5e
f0107242:	68 2c 59 12 f0       	push   $0xf012592c
f0107247:	e8 ed 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f010724c:	e8 bb fe ff ff       	call   f010710c <mycpu>
f0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010725d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107272:	85 c0                	test   %eax,%eax
f0107274:	79 14                	jns    f010728a <popcli+0x69>
    panic("popcli");
f0107276:	83 ec 04             	sub    $0x4,%esp
f0107279:	68 3b 59 12 f0       	push   $0xf012593b
f010727e:	6a 61                	push   $0x61
f0107280:	68 2c 59 12 f0       	push   $0xf012592c
f0107285:	e8 af 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010728a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107293:	85 c0                	test   %eax,%eax
f0107295:	75 0e                	jne    f01072a5 <popcli+0x84>
f0107297:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072a0:	85 c0                	test   %eax,%eax
f01072a2:	74 01                	je     f01072a5 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072a4:	fb                   	sti    
    sti();
}
f01072a5:	90                   	nop
f01072a6:	c9                   	leave  
f01072a7:	c3                   	ret    

f01072a8 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072a8:	55                   	push   %ebp
f01072a9:	89 e5                	mov    %esp,%ebp
f01072ab:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072ae:	e8 1c ff ff ff       	call   f01071cf <pushcli>

	c = mycpu();
f01072b3:	e8 54 fe ff ff       	call   f010710c <mycpu>
f01072b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072be:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072c5:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cf:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e1:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072eb:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f1:	83 e2 f0             	and    $0xfffffff0,%edx
f01072f4:	83 ca 0a             	or     $0xa,%edx
f01072f7:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107306:	83 ca 10             	or     $0x10,%edx
f0107309:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107318:	83 e2 9f             	and    $0xffffff9f,%edx
f010731b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107324:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010732a:	83 ca 80             	or     $0xffffff80,%edx
f010732d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107336:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733c:	83 ca 0f             	or     $0xf,%edx
f010733f:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107348:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734e:	83 e2 ef             	and    $0xffffffef,%edx
f0107351:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107360:	83 e2 df             	and    $0xffffffdf,%edx
f0107363:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107372:	83 ca 40             	or     $0x40,%edx
f0107375:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010737e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107384:	83 ca 80             	or     $0xffffff80,%edx
f0107387:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107390:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739a:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073a1:	ff ff 
f01073a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a6:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073ad:	00 00 
f01073af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b2:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c2:	83 e2 f0             	and    $0xfffffff0,%edx
f01073c5:	83 ca 02             	or     $0x2,%edx
f01073c8:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d1:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073d7:	83 ca 10             	or     $0x10,%edx
f01073da:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073e9:	83 e2 9f             	and    $0xffffff9f,%edx
f01073ec:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fb:	83 ca 80             	or     $0xffffff80,%edx
f01073fe:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107407:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010740d:	83 ca 0f             	or     $0xf,%edx
f0107410:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107416:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107419:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741f:	83 e2 ef             	and    $0xffffffef,%edx
f0107422:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107431:	83 e2 df             	and    $0xffffffdf,%edx
f0107434:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107443:	83 ca 40             	or     $0x40,%edx
f0107446:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107455:	83 ca 80             	or     $0xffffff80,%edx
f0107458:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010745e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107461:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107468:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746b:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107472:	ff ff 
f0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107477:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010747e:	00 00 
f0107480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107483:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010748a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107493:	83 e2 f0             	and    $0xfffffff0,%edx
f0107496:	83 ca 0a             	or     $0xa,%edx
f0107499:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074a8:	83 ca 10             	or     $0x10,%edx
f01074ab:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b4:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ba:	83 ca 60             	or     $0x60,%edx
f01074bd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cc:	83 ca 80             	or     $0xffffff80,%edx
f01074cf:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d8:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074de:	83 ca 0f             	or     $0xf,%edx
f01074e1:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ea:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f0:	83 e2 ef             	and    $0xffffffef,%edx
f01074f3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107502:	83 e2 df             	and    $0xffffffdf,%edx
f0107505:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107514:	83 ca 40             	or     $0x40,%edx
f0107517:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107520:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107526:	83 ca 80             	or     $0xffffff80,%edx
f0107529:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010752f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107532:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107539:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753c:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107543:	ff ff 
f0107545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107548:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010754f:	00 00 
f0107551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107554:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107564:	83 e2 f0             	and    $0xfffffff0,%edx
f0107567:	83 ca 02             	or     $0x2,%edx
f010756a:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107573:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107579:	83 ca 10             	or     $0x10,%edx
f010757c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107585:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758b:	83 ca 60             	or     $0x60,%edx
f010758e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759d:	83 ca 80             	or     $0xffffff80,%edx
f01075a0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a9:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075af:	83 ca 0f             	or     $0xf,%edx
f01075b2:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bb:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c1:	83 e2 ef             	and    $0xffffffef,%edx
f01075c4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cd:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d3:	83 e2 df             	and    $0xffffffdf,%edx
f01075d6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075df:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e5:	83 ca 40             	or     $0x40,%edx
f01075e8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f7:	83 ca 80             	or     $0xffffff80,%edx
f01075fa:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107614:	00 00 00 
f0107617:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010761e:	00 00 00 

	popcli();	//enable interrupt
f0107621:	e8 fb fb ff ff       	call   f0107221 <popcli>


}
f0107626:	90                   	nop
f0107627:	c9                   	leave  
f0107628:	c3                   	ret    

f0107629 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107629:	55                   	push   %ebp
f010762a:	89 e5                	mov    %esp,%ebp
f010762c:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010762f:	83 ec 08             	sub    $0x8,%esp
f0107632:	68 00 10 00 00       	push   $0x1000
f0107637:	68 00 10 00 00       	push   $0x1000
f010763c:	e8 42 02 00 00       	call   f0107883 <boot_allocate_space>
f0107641:	83 c4 10             	add    $0x10,%esp
f0107644:	a3 a0 2c 6c f0       	mov    %eax,0xf06c2ca0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107649:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010764e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107651:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107658:	77 14                	ja     f010766e <initialize_kernel_VM+0x45>
f010765a:	ff 75 e0             	pushl  -0x20(%ebp)
f010765d:	68 44 59 12 f0       	push   $0xf0125944
f0107662:	6a 57                	push   $0x57
f0107664:	68 78 59 12 f0       	push   $0xf0125978
f0107669:	e8 cb 8c ff ff       	call   f0100339 <_panic>
f010766e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107671:	05 00 00 00 10       	add    $0x10000000,%eax
f0107676:	a3 e4 2d 6c f0       	mov    %eax,0xf06c2de4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010767b:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f0107682:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107689:	77 14                	ja     f010769f <initialize_kernel_VM+0x76>
f010768b:	ff 75 dc             	pushl  -0x24(%ebp)
f010768e:	68 44 59 12 f0       	push   $0xf0125944
f0107693:	6a 63                	push   $0x63
f0107695:	68 78 59 12 f0       	push   $0xf0125978
f010769a:	e8 9a 8c ff ff       	call   f0100339 <_panic>
f010769f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076a2:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076a8:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01076ad:	83 ec 0c             	sub    $0xc,%esp
f01076b0:	6a 02                	push   $0x2
f01076b2:	52                   	push   %edx
f01076b3:	68 00 80 00 00       	push   $0x8000
f01076b8:	68 00 80 bf ef       	push   $0xefbf8000
f01076bd:	50                   	push   %eax
f01076be:	e8 34 02 00 00       	call   f01078f7 <boot_map_range>
f01076c3:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076cd:	eb 24                	jmp    f01076f3 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d2:	40                   	inc    %eax
f01076d3:	c1 e0 0f             	shl    $0xf,%eax
f01076d6:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076db:	29 c2                	sub    %eax,%edx
f01076dd:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01076e2:	6a 01                	push   $0x1
f01076e4:	6a 00                	push   $0x0
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 ec 25 00 00       	call   f0109cd9 <pt_set_page_permissions>
f01076ed:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076f0:	ff 45 f4             	incl   -0xc(%ebp)
f01076f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076f7:	7e d6                	jle    f01076cf <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076f9:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107700:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010770e:	eb 25                	jmp    f0107735 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107710:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107713:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107716:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010771b:	83 ec 04             	sub    $0x4,%esp
f010771e:	6a 01                	push   $0x1
f0107720:	52                   	push   %edx
f0107721:	50                   	push   %eax
f0107722:	e8 44 02 00 00       	call   f010796b <boot_get_page_table>
f0107727:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010772a:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107731:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107739:	72 d5                	jb     f0107710 <initialize_kernel_VM+0xe7>
f010773b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010773f:	77 06                	ja     f0107747 <initialize_kernel_VM+0x11e>
f0107741:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107745:	76 c9                	jbe    f0107710 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107747:	8b 15 78 18 6c f0    	mov    0xf06c1878,%edx
f010774d:	89 d0                	mov    %edx,%eax
f010774f:	01 c0                	add    %eax,%eax
f0107751:	01 d0                	add    %edx,%eax
f0107753:	c1 e0 03             	shl    $0x3,%eax
f0107756:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107759:	83 ec 08             	sub    $0x8,%esp
f010775c:	68 00 10 00 00       	push   $0x1000
f0107761:	ff 75 d8             	pushl  -0x28(%ebp)
f0107764:	e8 1a 01 00 00       	call   f0107883 <boot_allocate_space>
f0107769:	83 c4 10             	add    $0x10,%esp
f010776c:	a3 e0 1a 6c f0       	mov    %eax,0xf06c1ae0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107771:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107778:	83 ec 08             	sub    $0x8,%esp
f010777b:	68 00 10 00 00       	push   $0x1000
f0107780:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107783:	e8 fb 00 00 00       	call   f0107883 <boot_allocate_space>
f0107788:	83 c4 10             	add    $0x10,%esp
f010778b:	a3 a0 13 6c f0       	mov    %eax,0xf06c13a0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107790:	e8 05 05 00 00       	call   f0107c9a <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	68 ca 02 00 00       	push   $0x2ca
f010779d:	e8 92 6a 01 00       	call   f011e234 <nearest_pow2_ceil>
f01077a2:	83 c4 10             	add    $0x10,%esp
f01077a5:	83 ec 04             	sub    $0x4,%esp
f01077a8:	50                   	push   %eax
f01077a9:	68 ca 02 00 00       	push   $0x2ca
f01077ae:	68 98 59 12 f0       	push   $0xf0125998
f01077b3:	e8 d3 97 ff ff       	call   f0100f8b <cprintf>
f01077b8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077bb:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077c5:	83 ec 08             	sub    $0x8,%esp
f01077c8:	68 00 10 00 00       	push   $0x1000
f01077cd:	50                   	push   %eax
f01077ce:	e8 b0 00 00 00       	call   f0107883 <boot_allocate_space>
f01077d3:	83 c4 10             	add    $0x10,%esp
f01077d6:	a3 f0 8a 69 f0       	mov    %eax,0xf0698af0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077db:	a1 f0 8a 69 f0       	mov    0xf0698af0,%eax
f01077e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077e3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077ea:	77 17                	ja     f0107803 <initialize_kernel_VM+0x1da>
f01077ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01077ef:	68 44 59 12 f0       	push   $0xf0125944
f01077f4:	68 b1 00 00 00       	push   $0xb1
f01077f9:	68 78 59 12 f0       	push   $0xf0125978
f01077fe:	e8 36 8b ff ff       	call   f0100339 <_panic>
f0107803:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107806:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010780c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010780f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107814:	83 ec 0c             	sub    $0xc,%esp
f0107817:	6a 04                	push   $0x4
f0107819:	51                   	push   %ecx
f010781a:	52                   	push   %edx
f010781b:	68 00 00 c0 ee       	push   $0xeec00000
f0107820:	50                   	push   %eax
f0107821:	e8 d1 00 00 00       	call   f01078f7 <boot_map_range>
f0107826:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107829:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010782e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107833:	8b 15 a0 2c 6c f0    	mov    0xf06c2ca0,%edx
f0107839:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010783f:	8b 12                	mov    (%edx),%edx
f0107841:	83 ca 05             	or     $0x5,%edx
f0107844:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107846:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f010784b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107851:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107856:	83 ec 0c             	sub    $0xc,%esp
f0107859:	6a 02                	push   $0x2
f010785b:	6a 00                	push   $0x0
f010785d:	52                   	push   %edx
f010785e:	68 00 00 00 f0       	push   $0xf0000000
f0107863:	50                   	push   %eax
f0107864:	e8 8e 00 00 00       	call   f01078f7 <boot_map_range>
f0107869:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010786c:	e8 96 79 01 00       	call   f011f207 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107871:	c7 05 b0 17 6c f0 19 	movl   $0x19,0xf06c17b0
f0107878:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010787b:	e8 e6 02 00 00       	call   f0107b66 <turn_on_paging>
}
f0107880:	90                   	nop
f0107881:	c9                   	leave  
f0107882:	c3                   	ret    

f0107883 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107883:	55                   	push   %ebp
f0107884:	89 e5                	mov    %esp,%ebp
f0107886:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107889:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f010788e:	85 c0                	test   %eax,%eax
f0107890:	75 0a                	jne    f010789c <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107892:	c7 05 98 1c 6c f0 d0 	movl   $0xf0b0d7d0,0xf06c1c98
f0107899:	d7 b0 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010789c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078a2:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f01078a7:	89 c2                	mov    %eax,%edx
f01078a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ac:	01 d0                	add    %edx,%eax
f01078ae:	48                   	dec    %eax
f01078af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078ba:	f7 75 f4             	divl   -0xc(%ebp)
f01078bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c0:	29 d0                	sub    %edx,%eax
f01078c2:	a3 98 1c 6c f0       	mov    %eax,0xf06c1c98

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078c7:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f01078cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078cf:	8b 15 98 1c 6c f0    	mov    0xf06c1c98,%edx
f01078d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01078d8:	01 d0                	add    %edx,%eax
f01078da:	a3 98 1c 6c f0       	mov    %eax,0xf06c1c98

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078df:	83 ec 04             	sub    $0x4,%esp
f01078e2:	ff 75 08             	pushl  0x8(%ebp)
f01078e5:	6a 00                	push   $0x0
f01078e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ea:	e8 d5 85 01 00       	call   f011fec4 <memset>
f01078ef:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078f2:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078f5:	c9                   	leave  
f01078f6:	c3                   	ret    

f01078f7 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078f7:	55                   	push   %ebp
f01078f8:	89 e5                	mov    %esp,%ebp
f01078fa:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010790b:	eb 53                	jmp    f0107960 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010790d:	83 ec 04             	sub    $0x4,%esp
f0107910:	6a 01                	push   $0x1
f0107912:	ff 75 0c             	pushl  0xc(%ebp)
f0107915:	ff 75 08             	pushl  0x8(%ebp)
f0107918:	e8 4e 00 00 00       	call   f010796b <boot_get_page_table>
f010791d:	83 c4 10             	add    $0x10,%esp
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107923:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107926:	c1 e8 0c             	shr    $0xc,%eax
f0107929:	25 ff 03 00 00       	and    $0x3ff,%eax
f010792e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107931:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107934:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010793e:	01 c2                	add    %eax,%edx
f0107940:	8b 45 18             	mov    0x18(%ebp),%eax
f0107943:	0b 45 14             	or     0x14(%ebp),%eax
f0107946:	83 c8 01             	or     $0x1,%eax
f0107949:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010794b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107952:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107959:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107963:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107966:	72 a5                	jb     f010790d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107968:	90                   	nop
f0107969:	c9                   	leave  
f010796a:	c3                   	ret    

f010796b <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010796b:	55                   	push   %ebp
f010796c:	89 e5                	mov    %esp,%ebp
f010796e:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107974:	c1 e8 16             	shr    $0x16,%eax
f0107977:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010797a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010797d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107984:	8b 45 08             	mov    0x8(%ebp),%eax
f0107987:	01 d0                	add    %edx,%eax
f0107989:	8b 00                	mov    (%eax),%eax
f010798b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010798e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107991:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107996:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107999:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010799c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010799f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079a2:	c1 e8 0c             	shr    $0xc,%eax
f01079a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079a8:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f01079ad:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079b0:	72 17                	jb     f01079c9 <boot_get_page_table+0x5e>
f01079b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079b5:	68 c0 59 12 f0       	push   $0xf01259c0
f01079ba:	68 33 01 00 00       	push   $0x133
f01079bf:	68 78 59 12 f0       	push   $0xf0125978
f01079c4:	e8 70 89 ff ff       	call   f0100339 <_panic>
f01079c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079d8:	75 72                	jne    f0107a4c <boot_get_page_table+0xe1>
	{
		if (create)
f01079da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079de:	74 65                	je     f0107a45 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079e0:	83 ec 08             	sub    $0x8,%esp
f01079e3:	68 00 10 00 00       	push   $0x1000
f01079e8:	68 00 10 00 00       	push   $0x1000
f01079ed:	e8 91 fe ff ff       	call   f0107883 <boot_allocate_space>
f01079f2:	83 c4 10             	add    $0x10,%esp
f01079f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079fe:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a05:	77 17                	ja     f0107a1e <boot_get_page_table+0xb3>
f0107a07:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a0a:	68 44 59 12 f0       	push   $0xf0125944
f0107a0f:	68 39 01 00 00       	push   $0x139
f0107a14:	68 78 59 12 f0       	push   $0xf0125978
f0107a19:	e8 1b 89 ff ff       	call   f0100339 <_panic>
f0107a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a21:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a26:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a33:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a36:	01 d0                	add    %edx,%eax
f0107a38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a3b:	83 ca 03             	or     $0x3,%edx
f0107a3e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a43:	eb 0a                	jmp    f0107a4f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a45:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a4a:	eb 03                	jmp    f0107a4f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a4f:	c9                   	leave  
f0107a50:	c3                   	ret    

f0107a51 <nvram_read>:


int nvram_read(int r)
{
f0107a51:	55                   	push   %ebp
f0107a52:	89 e5                	mov    %esp,%ebp
f0107a54:	53                   	push   %ebx
f0107a55:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a5b:	83 ec 0c             	sub    $0xc,%esp
f0107a5e:	50                   	push   %eax
f0107a5f:	e8 28 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	89 c3                	mov    %eax,%ebx
f0107a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6c:	40                   	inc    %eax
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	50                   	push   %eax
f0107a71:	e8 16 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a76:	83 c4 10             	add    $0x10,%esp
f0107a79:	c1 e0 08             	shl    $0x8,%eax
f0107a7c:	09 d8                	or     %ebx,%eax
}
f0107a7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a81:	c9                   	leave  
f0107a82:	c3                   	ret    

f0107a83 <detect_memory>:

void detect_memory()
{
f0107a83:	55                   	push   %ebp
f0107a84:	89 e5                	mov    %esp,%ebp
f0107a86:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a89:	83 ec 0c             	sub    $0xc,%esp
f0107a8c:	6a 15                	push   $0x15
f0107a8e:	e8 be ff ff ff       	call   f0107a51 <nvram_read>
f0107a93:	83 c4 10             	add    $0x10,%esp
f0107a96:	c1 e0 0a             	shl    $0xa,%eax
f0107a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107aa7:	83 ec 0c             	sub    $0xc,%esp
f0107aaa:	6a 17                	push   $0x17
f0107aac:	e8 a0 ff ff ff       	call   f0107a51 <nvram_read>
f0107ab1:	83 c4 10             	add    $0x10,%esp
f0107ab4:	c1 e0 0a             	shl    $0xa,%eax
f0107ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107abd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107ac5:	83 ec 0c             	sub    $0xc,%esp
f0107ac8:	6a 34                	push   $0x34
f0107aca:	e8 82 ff ff ff       	call   f0107a51 <nvram_read>
f0107acf:	83 c4 10             	add    $0x10,%esp
f0107ad2:	c1 e0 10             	shl    $0x10,%eax
f0107ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107ae7:	74 18                	je     f0107b01 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aec:	05 00 00 00 01       	add    $0x1000000,%eax
f0107af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af7:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107aff:	eb 19                	jmp    f0107b1a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b05:	74 0d                	je     f0107b14 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b0a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b12:	eb 06                	jmp    f0107b1a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b1a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b24:	c1 e8 0c             	shr    $0xc,%eax
f0107b27:	a3 78 18 6c f0       	mov    %eax,0xf06c1878

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2f:	c1 e8 0a             	shr    $0xa,%eax
f0107b32:	83 ec 08             	sub    $0x8,%esp
f0107b35:	50                   	push   %eax
f0107b36:	68 f0 59 12 f0       	push   $0xf01259f0
f0107b3b:	e8 4b 94 ff ff       	call   f0100f8b <cprintf>
f0107b40:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b46:	c1 e8 0a             	shr    $0xa,%eax
f0107b49:	89 c2                	mov    %eax,%edx
f0107b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b4e:	c1 e8 0a             	shr    $0xa,%eax
f0107b51:	83 ec 04             	sub    $0x4,%esp
f0107b54:	52                   	push   %edx
f0107b55:	50                   	push   %eax
f0107b56:	68 13 5a 12 f0       	push   $0xf0125a13
f0107b5b:	e8 2b 94 ff ff       	call   f0100f8b <cprintf>
f0107b60:	83 c4 10             	add    $0x10,%esp
}
f0107b63:	90                   	nop
f0107b64:	c9                   	leave  
f0107b65:	c3                   	ret    

f0107b66 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b66:	55                   	push   %ebp
f0107b67:	89 e5                	mov    %esp,%ebp
f0107b69:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b6c:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b7a:	eb 24                	jmp    f0107ba0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b7c:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107b81:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b84:	c1 e2 02             	shl    $0x2,%edx
f0107b87:	01 c2                	add    %eax,%edx
f0107b89:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107b8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b91:	c1 e1 02             	shl    $0x2,%ecx
f0107b94:	01 c8                	add    %ecx,%eax
f0107b96:	8b 00                	mov    (%eax),%eax
f0107b98:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b9a:	ff 45 f4             	incl   -0xc(%ebp)
f0107b9d:	ff 45 f0             	incl   -0x10(%ebp)
f0107ba0:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f0107ba5:	c1 e8 16             	shr    $0x16,%eax
f0107ba8:	89 c2                	mov    %eax,%edx
f0107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bad:	39 c2                	cmp    %eax,%edx
f0107baf:	77 cb                	ja     f0107b7c <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bb1:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0107bb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bbc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bbf:	0f 20 c0             	mov    %cr0,%eax
f0107bc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bc5:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bcb:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bd2:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bdf:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107be2:	e8 e8 f5 ff ff       	call   f01071cf <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107be7:	e8 20 f5 ff ff       	call   f010710c <mycpu>
f0107bec:	83 c0 74             	add    $0x74,%eax
f0107bef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107bf2:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bfc:	48                   	dec    %eax
f0107bfd:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c04:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c0b:	c1 e8 10             	shr    $0x10,%eax
f0107c0e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c12:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c15:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c18:	e8 04 f6 ff ff       	call   f0107221 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c1d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c22:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c24:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c29:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c2b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c30:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c32:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c37:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c39:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c3e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c40:	ea 47 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c47
	asm volatile("lldt %%ax" :: "a" (0));
f0107c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c4c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c4f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c5d:	eb 19                	jmp    f0107c78 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c5f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107c64:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c67:	c1 e2 02             	shl    $0x2,%edx
f0107c6a:	01 d0                	add    %edx,%eax
f0107c6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c72:	ff 45 ec             	incl   -0x14(%ebp)
f0107c75:	ff 45 e8             	incl   -0x18(%ebp)
f0107c78:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f0107c7d:	c1 e8 16             	shr    $0x16,%eax
f0107c80:	89 c2                	mov    %eax,%edx
f0107c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c85:	39 c2                	cmp    %eax,%edx
f0107c87:	77 d6                	ja     f0107c5f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c89:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0107c8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c94:	0f 22 d8             	mov    %eax,%cr3

}
f0107c97:	90                   	nop
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    

f0107c9a <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c9a:	55                   	push   %ebp
f0107c9b:	89 e5                	mov    %esp,%ebp
f0107c9d:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ca0:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107ca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ca8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107caf:	77 17                	ja     f0107cc8 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cb4:	68 44 59 12 f0       	push   $0xf0125944
f0107cb9:	68 cf 01 00 00       	push   $0x1cf
f0107cbe:	68 78 59 12 f0       	push   $0xf0125978
f0107cc3:	e8 71 86 ff ff       	call   f0100339 <_panic>
f0107cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccb:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cd3:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107cd8:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ce0:	83 ca 03             	or     $0x3,%edx
f0107ce3:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107ce5:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107cea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107cf0:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0107cf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107cf8:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cff:	77 17                	ja     f0107d18 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d01:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d04:	68 44 59 12 f0       	push   $0xf0125944
f0107d09:	68 d4 01 00 00       	push   $0x1d4
f0107d0e:	68 78 59 12 f0       	push   $0xf0125978
f0107d13:	e8 21 86 ff ff       	call   f0100339 <_panic>
f0107d18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d1b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d20:	83 c8 05             	or     $0x5,%eax
f0107d23:	89 02                	mov    %eax,(%edx)

}
f0107d25:	90                   	nop
f0107d26:	c9                   	leave  
f0107d27:	c3                   	ret    

f0107d28 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d28:	55                   	push   %ebp
f0107d29:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d2e:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0107d34:	29 d0                	sub    %edx,%eax
f0107d36:	c1 f8 03             	sar    $0x3,%eax
f0107d39:	89 c2                	mov    %eax,%edx
f0107d3b:	89 d0                	mov    %edx,%eax
f0107d3d:	c1 e0 02             	shl    $0x2,%eax
f0107d40:	01 d0                	add    %edx,%eax
f0107d42:	c1 e0 02             	shl    $0x2,%eax
f0107d45:	01 d0                	add    %edx,%eax
f0107d47:	c1 e0 02             	shl    $0x2,%eax
f0107d4a:	01 d0                	add    %edx,%eax
f0107d4c:	89 c1                	mov    %eax,%ecx
f0107d4e:	c1 e1 08             	shl    $0x8,%ecx
f0107d51:	01 c8                	add    %ecx,%eax
f0107d53:	89 c1                	mov    %eax,%ecx
f0107d55:	c1 e1 10             	shl    $0x10,%ecx
f0107d58:	01 c8                	add    %ecx,%eax
f0107d5a:	01 c0                	add    %eax,%eax
f0107d5c:	01 d0                	add    %edx,%eax
}
f0107d5e:	5d                   	pop    %ebp
f0107d5f:	c3                   	ret    

f0107d60 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d60:	55                   	push   %ebp
f0107d61:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d63:	ff 75 08             	pushl  0x8(%ebp)
f0107d66:	e8 bd ff ff ff       	call   f0107d28 <to_frame_number>
f0107d6b:	83 c4 04             	add    $0x4,%esp
f0107d6e:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d71:	c9                   	leave  
f0107d72:	c3                   	ret    

f0107d73 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d73:	55                   	push   %ebp
f0107d74:	89 e5                	mov    %esp,%ebp
f0107d76:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d7c:	c1 e8 0c             	shr    $0xc,%eax
f0107d7f:	89 c2                	mov    %eax,%edx
f0107d81:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0107d86:	39 c2                	cmp    %eax,%edx
f0107d88:	72 14                	jb     f0107d9e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d8a:	83 ec 04             	sub    $0x4,%esp
f0107d8d:	68 30 5a 12 f0       	push   $0xf0125a30
f0107d92:	6a 56                	push   $0x56
f0107d94:	68 55 5a 12 f0       	push   $0xf0125a55
f0107d99:	e8 9b 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d9e:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0107da4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107da7:	c1 e8 0c             	shr    $0xc,%eax
f0107daa:	89 c1                	mov    %eax,%ecx
f0107dac:	89 c8                	mov    %ecx,%eax
f0107dae:	01 c0                	add    %eax,%eax
f0107db0:	01 c8                	add    %ecx,%eax
f0107db2:	c1 e0 03             	shl    $0x3,%eax
f0107db5:	01 d0                	add    %edx,%eax
}
f0107db7:	c9                   	leave  
f0107db8:	c3                   	ret    

f0107db9 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107db9:	55                   	push   %ebp
f0107dba:	89 e5                	mov    %esp,%ebp
f0107dbc:	83 ec 10             	sub    $0x10,%esp
f0107dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dc8:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dcb:	90                   	nop
f0107dcc:	c9                   	leave  
f0107dcd:	c3                   	ret    

f0107dce <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dce:	55                   	push   %ebp
f0107dcf:	89 e5                	mov    %esp,%ebp
f0107dd1:	53                   	push   %ebx
f0107dd2:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dd5:	c7 05 80 16 6c f0 00 	movl   $0x0,0xf06c1680
f0107ddc:	00 00 00 
f0107ddf:	c7 05 84 16 6c f0 00 	movl   $0x0,0xf06c1684
f0107de6:	00 00 00 
f0107de9:	c7 05 8c 16 6c f0 00 	movl   $0x0,0xf06c168c
f0107df0:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107df3:	c7 05 90 16 6c f0 00 	movl   $0x0,0xf06c1690
f0107dfa:	00 00 00 
f0107dfd:	c7 05 94 16 6c f0 00 	movl   $0x0,0xf06c1694
f0107e04:	00 00 00 
f0107e07:	c7 05 9c 16 6c f0 00 	movl   $0x0,0xf06c169c
f0107e0e:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e11:	83 ec 08             	sub    $0x8,%esp
f0107e14:	68 6f 5a 12 f0       	push   $0xf0125a6f
f0107e19:	68 a0 16 6c f0       	push   $0xf06c16a0
f0107e1e:	e8 d4 7e 00 00       	call   f010fcf7 <init_spinlock>
f0107e23:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e26:	a1 e0 1a 6c f0       	mov    0xf06c1ae0,%eax
f0107e2b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e31:	a1 e0 1a 6c f0       	mov    0xf06c1ae0,%eax
f0107e36:	83 c0 18             	add    $0x18,%eax
f0107e39:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e3f:	a1 e0 1a 6c f0       	mov    0xf06c1ae0,%eax
f0107e44:	83 c0 30             	add    $0x30,%eax
f0107e47:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e4d:	c7 05 7c 1b 6c f0 00 	movl   $0xf0001000,0xf06c1b7c
f0107e54:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e57:	c7 05 4c 2d 6c f0 00 	movl   $0xf0002000,0xf06c2d4c
f0107e5e:	20 00 f0 
	i =0;
f0107e61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e68:	eb 1f                	jmp    f0107e89 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e6a:	8b 15 7c 1b 6c f0    	mov    0xf06c1b7c,%edx
f0107e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e73:	01 d0                	add    %edx,%eax
f0107e75:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e78:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f0107e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e81:	01 d0                	add    %edx,%eax
f0107e83:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e86:	ff 45 f4             	incl   -0xc(%ebp)
f0107e89:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e90:	7e d8                	jle    f0107e6a <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e92:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e9c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ea1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea7:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eac:	f7 75 f0             	divl   -0x10(%ebp)
f0107eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eb2:	29 d0                	sub    %edx,%eax
f0107eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eb7:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107ebe:	e9 e8 00 00 00       	jmp    f0107fab <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ec3:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ecc:	89 d0                	mov    %edx,%eax
f0107ece:	01 c0                	add    %eax,%eax
f0107ed0:	01 d0                	add    %edx,%eax
f0107ed2:	c1 e0 03             	shl    $0x3,%eax
f0107ed5:	01 c8                	add    %ecx,%eax
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	50                   	push   %eax
f0107edb:	e8 b7 02 00 00       	call   f0108197 <initialize_frame_info>
f0107ee0:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ee3:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eec:	89 d0                	mov    %edx,%eax
f0107eee:	01 c0                	add    %eax,%eax
f0107ef0:	01 d0                	add    %edx,%eax
f0107ef2:	c1 e0 03             	shl    $0x3,%eax
f0107ef5:	01 c8                	add    %ecx,%eax
f0107ef7:	85 c0                	test   %eax,%eax
f0107ef9:	75 14                	jne    f0107f0f <initialize_paging+0x141>
f0107efb:	83 ec 04             	sub    $0x4,%esp
f0107efe:	68 80 5a 12 f0       	push   $0xf0125a80
f0107f03:	6a 60                	push   $0x60
f0107f05:	68 a3 5a 12 f0       	push   $0xf0125aa3
f0107f0a:	e8 2a 84 ff ff       	call   f0100339 <_panic>
f0107f0f:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f18:	89 d0                	mov    %edx,%eax
f0107f1a:	01 c0                	add    %eax,%eax
f0107f1c:	01 d0                	add    %edx,%eax
f0107f1e:	c1 e0 03             	shl    $0x3,%eax
f0107f21:	01 c8                	add    %ecx,%eax
f0107f23:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0107f29:	89 10                	mov    %edx,(%eax)
f0107f2b:	8b 00                	mov    (%eax),%eax
f0107f2d:	85 c0                	test   %eax,%eax
f0107f2f:	74 1f                	je     f0107f50 <initialize_paging+0x182>
f0107f31:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0107f37:	8b 1d e0 1a 6c f0    	mov    0xf06c1ae0,%ebx
f0107f3d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f40:	89 c8                	mov    %ecx,%eax
f0107f42:	01 c0                	add    %eax,%eax
f0107f44:	01 c8                	add    %ecx,%eax
f0107f46:	c1 e0 03             	shl    $0x3,%eax
f0107f49:	01 d8                	add    %ebx,%eax
f0107f4b:	89 42 04             	mov    %eax,0x4(%edx)
f0107f4e:	eb 19                	jmp    f0107f69 <initialize_paging+0x19b>
f0107f50:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f59:	89 d0                	mov    %edx,%eax
f0107f5b:	01 c0                	add    %eax,%eax
f0107f5d:	01 d0                	add    %edx,%eax
f0107f5f:	c1 e0 03             	shl    $0x3,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f0107f69:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f72:	89 d0                	mov    %edx,%eax
f0107f74:	01 c0                	add    %eax,%eax
f0107f76:	01 d0                	add    %edx,%eax
f0107f78:	c1 e0 03             	shl    $0x3,%eax
f0107f7b:	01 c8                	add    %ecx,%eax
f0107f7d:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f0107f82:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107f88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f8b:	89 d0                	mov    %edx,%eax
f0107f8d:	01 c0                	add    %eax,%eax
f0107f8f:	01 d0                	add    %edx,%eax
f0107f91:	c1 e0 03             	shl    $0x3,%eax
f0107f94:	01 c8                	add    %ecx,%eax
f0107f96:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f9d:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f0107fa2:	40                   	inc    %eax
f0107fa3:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fa8:	ff 45 f4             	incl   -0xc(%ebp)
f0107fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	79 05                	jns    f0107fb7 <initialize_paging+0x1e9>
f0107fb2:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fb7:	c1 f8 0c             	sar    $0xc,%eax
f0107fba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fbd:	0f 8f 00 ff ff ff    	jg     f0107ec3 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fc3:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fca:	eb 1d                	jmp    f0107fe9 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fcc:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0107fd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fd5:	89 d0                	mov    %edx,%eax
f0107fd7:	01 c0                	add    %eax,%eax
f0107fd9:	01 d0                	add    %edx,%eax
f0107fdb:	c1 e0 03             	shl    $0x3,%eax
f0107fde:	01 c8                	add    %ecx,%eax
f0107fe0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fe9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107ff0:	7e da                	jle    f0107fcc <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107ff2:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107ff9:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f0107ffe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108001:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108008:	77 14                	ja     f010801e <initialize_paging+0x250>
f010800a:	ff 75 e0             	pushl  -0x20(%ebp)
f010800d:	68 c0 5a 12 f0       	push   $0xf0125ac0
f0108012:	6a 68                	push   $0x68
f0108014:	68 a3 5a 12 f0       	push   $0xf0125aa3
f0108019:	e8 1b 83 ff ff       	call   f0100339 <_panic>
f010801e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108021:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010802a:	01 d0                	add    %edx,%eax
f010802c:	48                   	dec    %eax
f010802d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108030:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108033:	ba 00 00 00 00       	mov    $0x0,%edx
f0108038:	f7 75 e4             	divl   -0x1c(%ebp)
f010803b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010803e:	29 d0                	sub    %edx,%eax
f0108040:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108043:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010804a:	eb 1d                	jmp    f0108069 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010804c:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108052:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108055:	89 d0                	mov    %edx,%eax
f0108057:	01 c0                	add    %eax,%eax
f0108059:	01 d0                	add    %edx,%eax
f010805b:	c1 e0 03             	shl    $0x3,%eax
f010805e:	01 c8                	add    %ecx,%eax
f0108060:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108066:	ff 45 f4             	incl   -0xc(%ebp)
f0108069:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010806c:	85 c0                	test   %eax,%eax
f010806e:	79 05                	jns    f0108075 <initialize_paging+0x2a7>
f0108070:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108075:	c1 f8 0c             	sar    $0xc,%eax
f0108078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010807b:	7f cf                	jg     f010804c <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010807d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108080:	85 c0                	test   %eax,%eax
f0108082:	79 05                	jns    f0108089 <initialize_paging+0x2bb>
f0108084:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108089:	c1 f8 0c             	sar    $0xc,%eax
f010808c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010808f:	e9 e8 00 00 00       	jmp    f010817c <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108094:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f010809a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010809d:	89 d0                	mov    %edx,%eax
f010809f:	01 c0                	add    %eax,%eax
f01080a1:	01 d0                	add    %edx,%eax
f01080a3:	c1 e0 03             	shl    $0x3,%eax
f01080a6:	01 c8                	add    %ecx,%eax
f01080a8:	83 ec 0c             	sub    $0xc,%esp
f01080ab:	50                   	push   %eax
f01080ac:	e8 e6 00 00 00       	call   f0108197 <initialize_frame_info>
f01080b1:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080b4:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f01080ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bd:	89 d0                	mov    %edx,%eax
f01080bf:	01 c0                	add    %eax,%eax
f01080c1:	01 d0                	add    %edx,%eax
f01080c3:	c1 e0 03             	shl    $0x3,%eax
f01080c6:	01 c8                	add    %ecx,%eax
f01080c8:	85 c0                	test   %eax,%eax
f01080ca:	75 14                	jne    f01080e0 <initialize_paging+0x312>
f01080cc:	83 ec 04             	sub    $0x4,%esp
f01080cf:	68 80 5a 12 f0       	push   $0xf0125a80
f01080d4:	6a 74                	push   $0x74
f01080d6:	68 a3 5a 12 f0       	push   $0xf0125aa3
f01080db:	e8 59 82 ff ff       	call   f0100339 <_panic>
f01080e0:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f01080e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e9:	89 d0                	mov    %edx,%eax
f01080eb:	01 c0                	add    %eax,%eax
f01080ed:	01 d0                	add    %edx,%eax
f01080ef:	c1 e0 03             	shl    $0x3,%eax
f01080f2:	01 c8                	add    %ecx,%eax
f01080f4:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f01080fa:	89 10                	mov    %edx,(%eax)
f01080fc:	8b 00                	mov    (%eax),%eax
f01080fe:	85 c0                	test   %eax,%eax
f0108100:	74 1f                	je     f0108121 <initialize_paging+0x353>
f0108102:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0108108:	8b 1d e0 1a 6c f0    	mov    0xf06c1ae0,%ebx
f010810e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108111:	89 c8                	mov    %ecx,%eax
f0108113:	01 c0                	add    %eax,%eax
f0108115:	01 c8                	add    %ecx,%eax
f0108117:	c1 e0 03             	shl    $0x3,%eax
f010811a:	01 d8                	add    %ebx,%eax
f010811c:	89 42 04             	mov    %eax,0x4(%edx)
f010811f:	eb 19                	jmp    f010813a <initialize_paging+0x36c>
f0108121:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108127:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010812a:	89 d0                	mov    %edx,%eax
f010812c:	01 c0                	add    %eax,%eax
f010812e:	01 d0                	add    %edx,%eax
f0108130:	c1 e0 03             	shl    $0x3,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f010813a:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108143:	89 d0                	mov    %edx,%eax
f0108145:	01 c0                	add    %eax,%eax
f0108147:	01 d0                	add    %edx,%eax
f0108149:	c1 e0 03             	shl    $0x3,%eax
f010814c:	01 c8                	add    %ecx,%eax
f010814e:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f0108153:	8b 0d e0 1a 6c f0    	mov    0xf06c1ae0,%ecx
f0108159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815c:	89 d0                	mov    %edx,%eax
f010815e:	01 c0                	add    %eax,%eax
f0108160:	01 d0                	add    %edx,%eax
f0108162:	c1 e0 03             	shl    $0x3,%eax
f0108165:	01 c8                	add    %ecx,%eax
f0108167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010816e:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f0108173:	40                   	inc    %eax
f0108174:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108179:	ff 45 f4             	incl   -0xc(%ebp)
f010817c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817f:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0108184:	39 c2                	cmp    %eax,%edx
f0108186:	0f 82 08 ff ff ff    	jb     f0108094 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010818c:	e8 00 bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108191:	90                   	nop
f0108192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108195:	c9                   	leave  
f0108196:	c3                   	ret    

f0108197 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108197:	55                   	push   %ebp
f0108198:	89 e5                	mov    %esp,%ebp
f010819a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010819d:	83 ec 04             	sub    $0x4,%esp
f01081a0:	6a 18                	push   $0x18
f01081a2:	6a 00                	push   $0x0
f01081a4:	ff 75 08             	pushl  0x8(%ebp)
f01081a7:	e8 18 7d 01 00       	call   f011fec4 <memset>
f01081ac:	83 c4 10             	add    $0x10,%esp
}
f01081af:	90                   	nop
f01081b0:	c9                   	leave  
f01081b1:	c3                   	ret    

f01081b2 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081b2:	55                   	push   %ebp
f01081b3:	89 e5                	mov    %esp,%ebp
f01081b5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081b8:	83 ec 0c             	sub    $0xc,%esp
f01081bb:	68 a0 16 6c f0       	push   $0xf06c16a0
f01081c0:	e8 7c 7d 00 00       	call   f010ff41 <holding_spinlock>
f01081c5:	83 c4 10             	add    $0x10,%esp
f01081c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081cf:	75 10                	jne    f01081e1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081d1:	83 ec 0c             	sub    $0xc,%esp
f01081d4:	68 a0 16 6c f0       	push   $0xf06c16a0
f01081d9:	e8 4a 7b 00 00       	call   f010fd28 <acquire_spinlock>
f01081de:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081e1:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f6:	8b 00                	mov    (%eax),%eax
f01081f8:	85 c0                	test   %eax,%eax
f01081fa:	75 17                	jne    f0108213 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081fc:	83 ec 04             	sub    $0x4,%esp
f01081ff:	68 f4 5a 12 f0       	push   $0xf0125af4
f0108204:	68 a2 00 00 00       	push   $0xa2
f0108209:	68 a3 5a 12 f0       	push   $0xf0125aa3
f010820e:	e8 26 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	85 c0                	test   %eax,%eax
f010821a:	75 17                	jne    f0108233 <allocate_frame+0x81>
f010821c:	83 ec 04             	sub    $0x4,%esp
f010821f:	68 41 5b 12 f0       	push   $0xf0125b41
f0108224:	68 a8 00 00 00       	push   $0xa8
f0108229:	68 a3 5a 12 f0       	push   $0xf0125aa3
f010822e:	e8 06 81 ff ff       	call   f0100339 <_panic>
f0108233:	8b 45 08             	mov    0x8(%ebp),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 00                	mov    (%eax),%eax
f010823a:	85 c0                	test   %eax,%eax
f010823c:	74 14                	je     f0108252 <allocate_frame+0xa0>
f010823e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108241:	8b 00                	mov    (%eax),%eax
f0108243:	8b 00                	mov    (%eax),%eax
f0108245:	8b 55 08             	mov    0x8(%ebp),%edx
f0108248:	8b 12                	mov    (%edx),%edx
f010824a:	8b 52 04             	mov    0x4(%edx),%edx
f010824d:	89 50 04             	mov    %edx,0x4(%eax)
f0108250:	eb 0d                	jmp    f010825f <allocate_frame+0xad>
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f010825f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108262:	8b 00                	mov    (%eax),%eax
f0108264:	8b 40 04             	mov    0x4(%eax),%eax
f0108267:	85 c0                	test   %eax,%eax
f0108269:	74 13                	je     f010827e <allocate_frame+0xcc>
f010826b:	8b 45 08             	mov    0x8(%ebp),%eax
f010826e:	8b 00                	mov    (%eax),%eax
f0108270:	8b 40 04             	mov    0x4(%eax),%eax
f0108273:	8b 55 08             	mov    0x8(%ebp),%edx
f0108276:	8b 12                	mov    (%edx),%edx
f0108278:	8b 12                	mov    (%edx),%edx
f010827a:	89 10                	mov    %edx,(%eax)
f010827c:	eb 0c                	jmp    f010828a <allocate_frame+0xd8>
f010827e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108281:	8b 00                	mov    (%eax),%eax
f0108283:	8b 00                	mov    (%eax),%eax
f0108285:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f010828a:	8b 45 08             	mov    0x8(%ebp),%eax
f010828d:	8b 00                	mov    (%eax),%eax
f010828f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108295:	8b 45 08             	mov    0x8(%ebp),%eax
f0108298:	8b 00                	mov    (%eax),%eax
f010829a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082a1:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f01082a6:	48                   	dec    %eax
f01082a7:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01082af:	8b 00                	mov    (%eax),%eax
f01082b1:	8a 40 14             	mov    0x14(%eax),%al
f01082b4:	84 c0                	test   %al,%al
f01082b6:	74 20                	je     f01082d8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082bb:	8b 00                	mov    (%eax),%eax
f01082bd:	8b 50 10             	mov    0x10(%eax),%edx
f01082c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01082c8:	8b 40 64             	mov    0x64(%eax),%eax
f01082cb:	83 ec 08             	sub    $0x8,%esp
f01082ce:	52                   	push   %edx
f01082cf:	50                   	push   %eax
f01082d0:	e8 11 1b 00 00       	call   f0109de6 <pt_clear_page_table_entry>
f01082d5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082db:	8b 00                	mov    (%eax),%eax
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	50                   	push   %eax
f01082e1:	e8 b1 fe ff ff       	call   f0108197 <initialize_frame_info>
f01082e6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082ed:	75 10                	jne    f01082ff <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082ef:	83 ec 0c             	sub    $0xc,%esp
f01082f2:	68 a0 16 6c f0       	push   $0xf06c16a0
f01082f7:	e8 b3 7a 00 00       	call   f010fdaf <release_spinlock>
f01082fc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108304:	c9                   	leave  
f0108305:	c3                   	ret    

f0108306 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108306:	55                   	push   %ebp
f0108307:	89 e5                	mov    %esp,%ebp
f0108309:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010830c:	83 ec 0c             	sub    $0xc,%esp
f010830f:	68 a0 16 6c f0       	push   $0xf06c16a0
f0108314:	e8 28 7c 00 00       	call   f010ff41 <holding_spinlock>
f0108319:	83 c4 10             	add    $0x10,%esp
f010831c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010831f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108323:	75 10                	jne    f0108335 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108325:	83 ec 0c             	sub    $0xc,%esp
f0108328:	68 a0 16 6c f0       	push   $0xf06c16a0
f010832d:	e8 f6 79 00 00       	call   f010fd28 <acquire_spinlock>
f0108332:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108335:	83 ec 0c             	sub    $0xc,%esp
f0108338:	ff 75 08             	pushl  0x8(%ebp)
f010833b:	e8 57 fe ff ff       	call   f0108197 <initialize_frame_info>
f0108340:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108347:	75 17                	jne    f0108360 <free_frame+0x5a>
f0108349:	83 ec 04             	sub    $0x4,%esp
f010834c:	68 80 5a 12 f0       	push   $0xf0125a80
f0108351:	68 cf 00 00 00       	push   $0xcf
f0108356:	68 a3 5a 12 f0       	push   $0xf0125aa3
f010835b:	e8 d9 7f ff ff       	call   f0100339 <_panic>
f0108360:	8b 15 80 16 6c f0    	mov    0xf06c1680,%edx
f0108366:	8b 45 08             	mov    0x8(%ebp),%eax
f0108369:	89 10                	mov    %edx,(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	8b 00                	mov    (%eax),%eax
f0108370:	85 c0                	test   %eax,%eax
f0108372:	74 0d                	je     f0108381 <free_frame+0x7b>
f0108374:	a1 80 16 6c f0       	mov    0xf06c1680,%eax
f0108379:	8b 55 08             	mov    0x8(%ebp),%edx
f010837c:	89 50 04             	mov    %edx,0x4(%eax)
f010837f:	eb 08                	jmp    f0108389 <free_frame+0x83>
f0108381:	8b 45 08             	mov    0x8(%ebp),%eax
f0108384:	a3 84 16 6c f0       	mov    %eax,0xf06c1684
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	a3 80 16 6c f0       	mov    %eax,0xf06c1680
f0108391:	8b 45 08             	mov    0x8(%ebp),%eax
f0108394:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010839b:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f01083a0:	40                   	inc    %eax
f01083a1:	a3 8c 16 6c f0       	mov    %eax,0xf06c168c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083aa:	75 10                	jne    f01083bc <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ac:	83 ec 0c             	sub    $0xc,%esp
f01083af:	68 a0 16 6c f0       	push   $0xf06c16a0
f01083b4:	e8 f6 79 00 00       	call   f010fdaf <release_spinlock>
f01083b9:	83 c4 10             	add    $0x10,%esp
	}
}
f01083bc:	90                   	nop
f01083bd:	c9                   	leave  
f01083be:	c3                   	ret    

f01083bf <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083bf:	55                   	push   %ebp
f01083c0:	89 e5                	mov    %esp,%ebp
f01083c2:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c8:	8b 40 08             	mov    0x8(%eax),%eax
f01083cb:	48                   	dec    %eax
f01083cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01083cf:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083d6:	8b 40 08             	mov    0x8(%eax),%eax
f01083d9:	66 85 c0             	test   %ax,%ax
f01083dc:	75 0e                	jne    f01083ec <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083de:	83 ec 0c             	sub    $0xc,%esp
f01083e1:	ff 75 08             	pushl  0x8(%ebp)
f01083e4:	e8 1d ff ff ff       	call   f0108306 <free_frame>
f01083e9:	83 c4 10             	add    $0x10,%esp
}
f01083ec:	90                   	nop
f01083ed:	c9                   	leave  
f01083ee:	c3                   	ret    

f01083ef <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083ef:	55                   	push   %ebp
f01083f0:	89 e5                	mov    %esp,%ebp
f01083f2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f8:	c1 e8 16             	shr    $0x16,%eax
f01083fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108402:	8b 45 08             	mov    0x8(%ebp),%eax
f0108405:	01 d0                	add    %edx,%eax
f0108407:	8b 00                	mov    (%eax),%eax
f0108409:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010840c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840f:	83 e0 01             	and    $0x1,%eax
f0108412:	85 c0                	test   %eax,%eax
f0108414:	74 74                	je     f010848a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108416:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010841d:	77 1d                	ja     f010843c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010841f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108422:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108427:	83 ec 0c             	sub    $0xc,%esp
f010842a:	50                   	push   %eax
f010842b:	e8 12 15 00 00       	call   f0109942 <kheap_virtual_address>
f0108430:	83 c4 10             	add    $0x10,%esp
f0108433:	89 c2                	mov    %eax,%edx
f0108435:	8b 45 10             	mov    0x10(%ebp),%eax
f0108438:	89 10                	mov    %edx,(%eax)
f010843a:	eb 44                	jmp    f0108480 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010843c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010843f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108444:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010844a:	c1 e8 0c             	shr    $0xc,%eax
f010844d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108450:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0108455:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108458:	72 17                	jb     f0108471 <get_page_table+0x82>
f010845a:	ff 75 f0             	pushl  -0x10(%ebp)
f010845d:	68 60 5b 12 f0       	push   $0xf0125b60
f0108462:	68 fb 00 00 00       	push   $0xfb
f0108467:	68 a3 5a 12 f0       	push   $0xf0125aa3
f010846c:	e8 c8 7e ff ff       	call   f0100339 <_panic>
f0108471:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108474:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108479:	89 c2                	mov    %eax,%edx
f010847b:	8b 45 10             	mov    0x10(%ebp),%eax
f010847e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108480:	b8 00 00 00 00       	mov    $0x0,%eax
f0108485:	e9 b9 00 00 00       	jmp    f0108543 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010848a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010848e:	0f 84 a1 00 00 00    	je     f0108535 <get_page_table+0x146>
f0108494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108497:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010849a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010849d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01084a0:	83 ec 0c             	sub    $0xc,%esp
f01084a3:	6a 00                	push   $0x0
f01084a5:	e8 10 73 00 00       	call   f010f7ba <fault_handler>
f01084aa:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084b0:	c1 e8 16             	shr    $0x16,%eax
f01084b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01084bd:	01 d0                	add    %edx,%eax
f01084bf:	8b 00                	mov    (%eax),%eax
f01084c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084c4:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084cb:	77 1d                	ja     f01084ea <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084d5:	83 ec 0c             	sub    $0xc,%esp
f01084d8:	50                   	push   %eax
f01084d9:	e8 64 14 00 00       	call   f0109942 <kheap_virtual_address>
f01084de:	83 c4 10             	add    $0x10,%esp
f01084e1:	89 c2                	mov    %eax,%edx
f01084e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01084e6:	89 10                	mov    %edx,(%eax)
f01084e8:	eb 44                	jmp    f010852e <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f8:	c1 e8 0c             	shr    $0xc,%eax
f01084fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084fe:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0108503:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108506:	72 17                	jb     f010851f <get_page_table+0x130>
f0108508:	ff 75 e8             	pushl  -0x18(%ebp)
f010850b:	68 60 5b 12 f0       	push   $0xf0125b60
f0108510:	68 13 01 00 00       	push   $0x113
f0108515:	68 a3 5a 12 f0       	push   $0xf0125aa3
f010851a:	e8 1a 7e ff ff       	call   f0100339 <_panic>
f010851f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108522:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108527:	89 c2                	mov    %eax,%edx
f0108529:	8b 45 10             	mov    0x10(%ebp),%eax
f010852c:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010852e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108533:	eb 0e                	jmp    f0108543 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108535:	8b 45 10             	mov    0x10(%ebp),%eax
f0108538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010853e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	53                   	push   %ebx
f0108549:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010854c:	83 ec 0c             	sub    $0xc,%esp
f010854f:	68 00 10 00 00       	push   $0x1000
f0108554:	e8 46 10 00 00       	call   f010959f <kmalloc>
f0108559:	83 c4 10             	add    $0x10,%esp
f010855c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010855f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108563:	75 17                	jne    f010857c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108565:	83 ec 04             	sub    $0x4,%esp
f0108568:	68 8f 5b 12 f0       	push   $0xf0125b8f
f010856d:	68 33 01 00 00       	push   $0x133
f0108572:	68 a3 5a 12 f0       	push   $0xf0125aa3
f0108577:	e8 bd 7d ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010857c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857f:	c1 e8 16             	shr    $0x16,%eax
f0108582:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108589:	8b 45 08             	mov    0x8(%ebp),%eax
f010858c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010858f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108592:	83 ec 0c             	sub    $0xc,%esp
f0108595:	50                   	push   %eax
f0108596:	e8 4a 13 00 00       	call   f01098e5 <kheap_physical_address>
f010859b:	83 c4 10             	add    $0x10,%esp
f010859e:	83 c8 07             	or     $0x7,%eax
f01085a1:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01085a3:	83 ec 04             	sub    $0x4,%esp
f01085a6:	68 00 10 00 00       	push   $0x1000
f01085ab:	6a 00                	push   $0x0
f01085ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01085b0:	e8 0f 79 01 00       	call   f011fec4 <memset>
f01085b5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085b8:	0f 20 d8             	mov    %cr3,%eax
f01085bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085c1:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01085c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01085c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01085ca:	c9                   	leave  
f01085cb:	c3                   	ret    

f01085cc <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01085cc:	55                   	push   %ebp
f01085cd:	89 e5                	mov    %esp,%ebp
f01085cf:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01085d2:	83 ec 0c             	sub    $0xc,%esp
f01085d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01085d8:	50                   	push   %eax
f01085d9:	e8 d4 fb ff ff       	call   f01081b2 <allocate_frame>
f01085de:	83 c4 10             	add    $0x10,%esp
f01085e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01085e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085e7:	83 ec 0c             	sub    $0xc,%esp
f01085ea:	50                   	push   %eax
f01085eb:	e8 70 f7 ff ff       	call   f0107d60 <to_physical_address>
f01085f0:	83 c4 10             	add    $0x10,%esp
f01085f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01085f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085ff:	c1 e8 0c             	shr    $0xc,%eax
f0108602:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108605:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f010860a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010860d:	72 17                	jb     f0108626 <__static_cpt+0x5a>
f010860f:	ff 75 ec             	pushl  -0x14(%ebp)
f0108612:	68 60 5b 12 f0       	push   $0xf0125b60
f0108617:	68 4e 01 00 00       	push   $0x14e
f010861c:	68 a3 5a 12 f0       	push   $0xf0125aa3
f0108621:	e8 13 7d ff ff       	call   f0100339 <_panic>
f0108626:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108629:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010862e:	89 c2                	mov    %eax,%edx
f0108630:	8b 45 10             	mov    0x10(%ebp),%eax
f0108633:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108635:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108638:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010863e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108641:	c1 e8 16             	shr    $0x16,%eax
f0108644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010864b:	8b 45 08             	mov    0x8(%ebp),%eax
f010864e:	01 d0                	add    %edx,%eax
f0108650:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108653:	83 ca 07             	or     $0x7,%edx
f0108656:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108658:	8b 45 10             	mov    0x10(%ebp),%eax
f010865b:	8b 00                	mov    (%eax),%eax
f010865d:	83 ec 04             	sub    $0x4,%esp
f0108660:	68 00 10 00 00       	push   $0x1000
f0108665:	6a 00                	push   $0x0
f0108667:	50                   	push   %eax
f0108668:	e8 57 78 01 00       	call   f011fec4 <memset>
f010866d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108670:	0f 20 d8             	mov    %cr3,%eax
f0108673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108679:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010867c:	90                   	nop
f010867d:	c9                   	leave  
f010867e:	c3                   	ret    

f010867f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010867f:	55                   	push   %ebp
f0108680:	89 e5                	mov    %esp,%ebp
f0108682:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108685:	ff 75 0c             	pushl  0xc(%ebp)
f0108688:	e8 d3 f6 ff ff       	call   f0107d60 <to_physical_address>
f010868d:	83 c4 04             	add    $0x4,%esp
f0108690:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108693:	83 ec 04             	sub    $0x4,%esp
f0108696:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108699:	50                   	push   %eax
f010869a:	ff 75 10             	pushl  0x10(%ebp)
f010869d:	ff 75 08             	pushl  0x8(%ebp)
f01086a0:	e8 4a fd ff ff       	call   f01083ef <get_page_table>
f01086a5:	83 c4 10             	add    $0x10,%esp
f01086a8:	83 f8 01             	cmp    $0x1,%eax
f01086ab:	75 1b                	jne    f01086c8 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01086ad:	83 ec 08             	sub    $0x8,%esp
f01086b0:	ff 75 10             	pushl  0x10(%ebp)
f01086b3:	ff 75 08             	pushl  0x8(%ebp)
f01086b6:	e8 8a fe ff ff       	call   f0108545 <create_page_table>
f01086bb:	83 c4 10             	add    $0x10,%esp
f01086be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01086c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01086c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086cb:	8b 55 10             	mov    0x10(%ebp),%edx
f01086ce:	c1 ea 0c             	shr    $0xc,%edx
f01086d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086d7:	c1 e2 02             	shl    $0x2,%edx
f01086da:	01 d0                	add    %edx,%eax
f01086dc:	8b 00                	mov    (%eax),%eax
f01086de:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01086e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e4:	83 e0 01             	and    $0x1,%eax
f01086e7:	85 c0                	test   %eax,%eax
f01086e9:	74 25                	je     f0108710 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01086eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086f6:	75 07                	jne    f01086ff <map_frame+0x80>
			return 0;
f01086f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01086fd:	eb 68                	jmp    f0108767 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01086ff:	83 ec 08             	sub    $0x8,%esp
f0108702:	ff 75 10             	pushl  0x10(%ebp)
f0108705:	ff 75 08             	pushl  0x8(%ebp)
f0108708:	e8 d2 00 00 00       	call   f01087df <unmap_frame>
f010870d:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108710:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108713:	8b 40 08             	mov    0x8(%eax),%eax
f0108716:	40                   	inc    %eax
f0108717:	8b 55 0c             	mov    0xc(%ebp),%edx
f010871a:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010871e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108721:	8b 55 10             	mov    0x10(%ebp),%edx
f0108724:	c1 ea 0c             	shr    $0xc,%edx
f0108727:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010872d:	c1 e2 02             	shl    $0x2,%edx
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	25 00 0e 00 00       	and    $0xe00,%eax
f0108739:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010873c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010873f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108742:	c1 ea 0c             	shr    $0xc,%edx
f0108745:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010874b:	c1 e2 02             	shl    $0x2,%edx
f010874e:	01 c2                	add    %eax,%edx
f0108750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108753:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108756:	89 c1                	mov    %eax,%ecx
f0108758:	8b 45 14             	mov    0x14(%ebp),%eax
f010875b:	09 c8                	or     %ecx,%eax
f010875d:	83 c8 01             	or     $0x1,%eax
f0108760:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108767:	c9                   	leave  
f0108768:	c3                   	ret    

f0108769 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108769:	55                   	push   %ebp
f010876a:	89 e5                	mov    %esp,%ebp
f010876c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	ff 75 10             	pushl  0x10(%ebp)
f0108775:	ff 75 0c             	pushl  0xc(%ebp)
f0108778:	ff 75 08             	pushl  0x8(%ebp)
f010877b:	e8 6f fc ff ff       	call   f01083ef <get_page_table>
f0108780:	83 c4 10             	add    $0x10,%esp
f0108783:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108786:	8b 45 10             	mov    0x10(%ebp),%eax
f0108789:	8b 00                	mov    (%eax),%eax
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 49                	je     f01087d8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010878f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108792:	c1 e8 0c             	shr    $0xc,%eax
f0108795:	25 ff 03 00 00       	and    $0x3ff,%eax
f010879a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010879d:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a0:	8b 00                	mov    (%eax),%eax
f01087a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01087a5:	c1 e2 02             	shl    $0x2,%edx
f01087a8:	01 d0                	add    %edx,%eax
f01087aa:	8b 00                	mov    (%eax),%eax
f01087ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01087af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 16                	je     f01087d1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	83 ec 0c             	sub    $0xc,%esp
f01087c6:	50                   	push   %eax
f01087c7:	e8 a7 f5 ff ff       	call   f0107d73 <to_frame_info>
f01087cc:	83 c4 10             	add    $0x10,%esp
f01087cf:	eb 0c                	jmp    f01087dd <get_frame_info+0x74>
		}
		return 0;
f01087d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d6:	eb 05                	jmp    f01087dd <get_frame_info+0x74>
	}
	return 0;
f01087d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01087dd:	c9                   	leave  
f01087de:	c3                   	ret    

f01087df <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01087df:	55                   	push   %ebp
f01087e0:	89 e5                	mov    %esp,%ebp
f01087e2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01087e5:	83 ec 04             	sub    $0x4,%esp
f01087e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01087eb:	50                   	push   %eax
f01087ec:	ff 75 0c             	pushl  0xc(%ebp)
f01087ef:	ff 75 08             	pushl  0x8(%ebp)
f01087f2:	e8 72 ff ff ff       	call   f0108769 <get_frame_info>
f01087f7:	83 c4 10             	add    $0x10,%esp
f01087fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01087fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108801:	74 7d                	je     f0108880 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108806:	8a 40 14             	mov    0x14(%eax),%al
f0108809:	84 c0                	test   %al,%al
f010880b:	74 1c                	je     f0108829 <unmap_frame+0x4a>
f010880d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108814:	77 13                	ja     f0108829 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108816:	83 ec 08             	sub    $0x8,%esp
f0108819:	ff 75 0c             	pushl  0xc(%ebp)
f010881c:	68 ac 5b 12 f0       	push   $0xf0125bac
f0108821:	e8 65 87 ff ff       	call   f0100f8b <cprintf>
f0108826:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108829:	83 ec 0c             	sub    $0xc,%esp
f010882c:	ff 75 f4             	pushl  -0xc(%ebp)
f010882f:	e8 8b fb ff ff       	call   f01083bf <decrement_references>
f0108834:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010883a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010883d:	c1 ea 0c             	shr    $0xc,%edx
f0108840:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108846:	c1 e2 02             	shl    $0x2,%edx
f0108849:	01 d0                	add    %edx,%eax
f010884b:	8b 00                	mov    (%eax),%eax
f010884d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108852:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108858:	8b 55 0c             	mov    0xc(%ebp),%edx
f010885b:	c1 ea 0c             	shr    $0xc,%edx
f010885e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108864:	c1 e2 02             	shl    $0x2,%edx
f0108867:	01 c2                	add    %eax,%edx
f0108869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010886e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108871:	83 ec 08             	sub    $0x8,%esp
f0108874:	50                   	push   %eax
f0108875:	ff 75 08             	pushl  0x8(%ebp)
f0108878:	e8 3c f5 ff ff       	call   f0107db9 <tlb_invalidate>
f010887d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108880:	90                   	nop
f0108881:	c9                   	leave  
f0108882:	c3                   	ret    

f0108883 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108883:	55                   	push   %ebp
f0108884:	89 e5                	mov    %esp,%ebp
f0108886:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108889:	ff 75 0c             	pushl  0xc(%ebp)
f010888c:	e8 cf f4 ff ff       	call   f0107d60 <to_physical_address>
f0108891:	83 c4 04             	add    $0x4,%esp
f0108894:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108897:	8b 45 10             	mov    0x10(%ebp),%eax
f010889a:	c1 e8 16             	shr    $0x16,%eax
f010889d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088a7:	01 d0                	add    %edx,%eax
f01088a9:	8b 00                	mov    (%eax),%eax
f01088ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01088ae:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01088b5:	77 19                	ja     f01088d0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088bf:	83 ec 0c             	sub    $0xc,%esp
f01088c2:	50                   	push   %eax
f01088c3:	e8 7a 10 00 00       	call   f0109942 <kheap_virtual_address>
f01088c8:	83 c4 10             	add    $0x10,%esp
f01088cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ce:	eb 40                	jmp    f0108910 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01088db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01088de:	c1 e8 0c             	shr    $0xc,%eax
f01088e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088e4:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f01088e9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01088ec:	72 17                	jb     f0108905 <loadtime_map_frame+0x82>
f01088ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01088f1:	68 60 5b 12 f0       	push   $0xf0125b60
f01088f6:	68 fa 01 00 00       	push   $0x1fa
f01088fb:	68 a3 5a 12 f0       	push   $0xf0125aa3
f0108900:	e8 34 7a ff ff       	call   f0100339 <_panic>
f0108905:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108908:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010890d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108914:	75 14                	jne    f010892a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108916:	83 ec 08             	sub    $0x8,%esp
f0108919:	ff 75 10             	pushl  0x10(%ebp)
f010891c:	ff 75 08             	pushl  0x8(%ebp)
f010891f:	e8 21 fc ff ff       	call   f0108545 <create_page_table>
f0108924:	83 c4 10             	add    $0x10,%esp
f0108927:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010892a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010892d:	8b 40 08             	mov    0x8(%eax),%eax
f0108930:	40                   	inc    %eax
f0108931:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108934:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108938:	8b 45 10             	mov    0x10(%ebp),%eax
f010893b:	c1 e8 0c             	shr    $0xc,%eax
f010893e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010894a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010894d:	01 c2                	add    %eax,%edx
f010894f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108952:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108955:	83 c8 01             	or     $0x1,%eax
f0108958:	89 02                	mov    %eax,(%edx)

	return 0;
f010895a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010895f:	c9                   	leave  
f0108960:	c3                   	ret    

f0108961 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108961:	55                   	push   %ebp
f0108962:	89 e5                	mov    %esp,%ebp
f0108964:	57                   	push   %edi
f0108965:	56                   	push   %esi
f0108966:	53                   	push   %ebx
f0108967:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010896a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108971:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108978:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f010897f:	83 ec 0c             	sub    $0xc,%esp
f0108982:	68 a0 16 6c f0       	push   $0xf06c16a0
f0108987:	e8 b5 75 00 00       	call   f010ff41 <holding_spinlock>
f010898c:	83 c4 10             	add    $0x10,%esp
f010898f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108992:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108996:	75 10                	jne    f01089a8 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108998:	83 ec 0c             	sub    $0xc,%esp
f010899b:	68 a0 16 6c f0       	push   $0xf06c16a0
f01089a0:	e8 83 73 00 00       	call   f010fd28 <acquire_spinlock>
f01089a5:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089a8:	a1 80 16 6c f0       	mov    0xf06c1680,%eax
f01089ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b0:	eb 1a                	jmp    f01089cc <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089b5:	8a 40 14             	mov    0x14(%eax),%al
f01089b8:	84 c0                	test   %al,%al
f01089ba:	74 05                	je     f01089c1 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01089bc:	ff 45 dc             	incl   -0x24(%ebp)
f01089bf:	eb 03                	jmp    f01089c4 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01089c1:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089c4:	a1 88 16 6c f0       	mov    0xf06c1688,%eax
f01089c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089d0:	74 07                	je     f01089d9 <calculate_available_frames+0x78>
f01089d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d5:	8b 00                	mov    (%eax),%eax
f01089d7:	eb 05                	jmp    f01089de <calculate_available_frames+0x7d>
f01089d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01089de:	a3 88 16 6c f0       	mov    %eax,0xf06c1688
f01089e3:	a1 88 16 6c f0       	mov    0xf06c1688,%eax
f01089e8:	85 c0                	test   %eax,%eax
f01089ea:	75 c6                	jne    f01089b2 <calculate_available_frames+0x51>
f01089ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089f0:	75 c0                	jne    f01089b2 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01089f2:	a1 9c 16 6c f0       	mov    0xf06c169c,%eax
f01089f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f01089fa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01089fe:	75 10                	jne    f0108a10 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a00:	83 ec 0c             	sub    $0xc,%esp
f0108a03:	68 a0 16 6c f0       	push   $0xf06c16a0
f0108a08:	e8 a2 73 00 00       	call   f010fdaf <release_spinlock>
f0108a0d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a13:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a19:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108a1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108a1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a25:	89 c3                	mov    %eax,%ebx
f0108a27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108a2a:	ba 03 00 00 00       	mov    $0x3,%edx
f0108a2f:	89 df                	mov    %ebx,%edi
f0108a31:	89 c6                	mov    %eax,%esi
f0108a33:	89 d1                	mov    %edx,%ecx
f0108a35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a3d:	5b                   	pop    %ebx
f0108a3e:	5e                   	pop    %esi
f0108a3f:	5f                   	pop    %edi
f0108a40:	5d                   	pop    %ebp
f0108a41:	c2 04 00             	ret    $0x4

f0108a44 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108a4a:	c7 05 40 15 6c f0 00 	movl   $0x0,0xf06c1540
f0108a51:	00 00 00 
f0108a54:	c7 05 44 15 6c f0 00 	movl   $0x0,0xf06c1544
f0108a5b:	00 00 00 
f0108a5e:	c7 05 4c 15 6c f0 00 	movl   $0x0,0xf06c154c
f0108a65:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108a68:	83 ec 08             	sub    $0x8,%esp
f0108a6b:	68 dc 5b 12 f0       	push   $0xf0125bdc
f0108a70:	68 50 15 6c f0       	push   $0xf06c1550
f0108a75:	e8 7d 72 00 00       	call   f010fcf7 <init_spinlock>
f0108a7a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a7d:	90                   	nop
f0108a7e:	c9                   	leave  
f0108a7f:	c3                   	ret    

f0108a80 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a80:	55                   	push   %ebp
f0108a81:	89 e5                	mov    %esp,%ebp
f0108a83:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a86:	83 ec 08             	sub    $0x8,%esp
f0108a89:	ff 75 0c             	pushl  0xc(%ebp)
f0108a8c:	ff 75 08             	pushl  0x8(%ebp)
f0108a8f:	e8 4b 01 00 00       	call   f0108bdf <get_share>
f0108a94:	83 c4 10             	add    $0x10,%esp
f0108a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9e:	75 07                	jne    f0108aa7 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108aa0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108aa5:	eb 06                	jmp    f0108aad <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108aaa:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108aad:	c9                   	leave  
f0108aae:	c3                   	ret    

f0108aaf <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108aaf:	55                   	push   %ebp
f0108ab0:	89 e5                	mov    %esp,%ebp
f0108ab2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108ab5:	8b 15 8c 16 6c f0    	mov    0xf06c168c,%edx
f0108abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108abe:	39 c2                	cmp    %eax,%edx
f0108ac0:	73 07                	jae    f0108ac9 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ac7:	eb 3c                	jmp    f0108b05 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108acc:	c1 e0 02             	shl    $0x2,%eax
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	50                   	push   %eax
f0108ad3:	e8 c7 0a 00 00       	call   f010959f <kmalloc>
f0108ad8:	83 c4 10             	add    $0x10,%esp
f0108adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108ade:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ae2:	75 07                	jne    f0108aeb <create_frames_storage+0x3c>
f0108ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ae9:	eb 1a                	jmp    f0108b05 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108aeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108aee:	c1 e0 02             	shl    $0x2,%eax
f0108af1:	83 ec 04             	sub    $0x4,%esp
f0108af4:	50                   	push   %eax
f0108af5:	6a 00                	push   $0x0
f0108af7:	ff 75 f4             	pushl  -0xc(%ebp)
f0108afa:	e8 c5 73 01 00       	call   f011fec4 <memset>
f0108aff:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108b05:	c9                   	leave  
f0108b06:	c3                   	ret    

f0108b07 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108b07:	55                   	push   %ebp
f0108b08:	89 e5                	mov    %esp,%ebp
f0108b0a:	83 ec 28             	sub    $0x28,%esp
f0108b0d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108b10:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108b13:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108b1a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b20:	01 d0                	add    %edx,%eax
f0108b22:	48                   	dec    %eax
f0108b23:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b29:	ba 00 00 00 00       	mov    $0x0,%edx
f0108b2e:	f7 75 f4             	divl   -0xc(%ebp)
f0108b31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b34:	29 d0                	sub    %edx,%eax
f0108b36:	c1 e8 0c             	shr    $0xc,%eax
f0108b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108b3c:	83 ec 0c             	sub    $0xc,%esp
f0108b3f:	6a 60                	push   $0x60
f0108b41:	e8 59 0a 00 00       	call   f010959f <kmalloc>
f0108b46:	83 c4 10             	add    $0x10,%esp
f0108b49:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108b4c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108b50:	75 0a                	jne    f0108b5c <create_share+0x55>
f0108b52:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b57:	e9 81 00 00 00       	jmp    f0108bdd <create_share+0xd6>
	created_share->references=1;
f0108b5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b5f:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108b66:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b69:	01 c0                	add    %eax,%eax
f0108b6b:	d1 f8                	sar    %eax
f0108b6d:	89 c2                	mov    %eax,%edx
f0108b6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b72:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b77:	83 ec 0c             	sub    $0xc,%esp
f0108b7a:	50                   	push   %eax
f0108b7b:	e8 2f ff ff ff       	call   f0108aaf <create_frames_storage>
f0108b80:	83 c4 10             	add    $0x10,%esp
f0108b83:	89 c2                	mov    %eax,%edx
f0108b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b88:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108b8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b8e:	8b 40 54             	mov    0x54(%eax),%eax
f0108b91:	85 c0                	test   %eax,%eax
f0108b93:	75 15                	jne    f0108baa <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108b95:	83 ec 0c             	sub    $0xc,%esp
f0108b98:	ff 75 e8             	pushl  -0x18(%ebp)
f0108b9b:	e8 5f 0c 00 00       	call   f01097ff <kfree>
f0108ba0:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ba3:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ba8:	eb 33                	jmp    f0108bdd <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bad:	8b 55 08             	mov    0x8(%ebp),%edx
f0108bb0:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108bb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bb6:	83 c0 08             	add    $0x8,%eax
f0108bb9:	83 ec 08             	sub    $0x8,%esp
f0108bbc:	ff 75 0c             	pushl  0xc(%ebp)
f0108bbf:	50                   	push   %eax
f0108bc0:	e8 60 71 01 00       	call   f011fd25 <strcpy>
f0108bc5:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108bc8:	8b 55 10             	mov    0x10(%ebp),%edx
f0108bcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bce:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108bd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bd4:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108bd7:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108bdd:	c9                   	leave  
f0108bde:	c3                   	ret    

f0108bdf <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bdf:	55                   	push   %ebp
f0108be0:	89 e5                	mov    %esp,%ebp
f0108be2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108be5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108bec:	83 ec 0c             	sub    $0xc,%esp
f0108bef:	68 50 15 6c f0       	push   $0xf06c1550
f0108bf4:	e8 2f 71 00 00       	call   f010fd28 <acquire_spinlock>
f0108bf9:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108bfc:	a1 40 15 6c f0       	mov    0xf06c1540,%eax
f0108c01:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c04:	eb 41                	jmp    f0108c47 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c09:	8b 40 04             	mov    0x4(%eax),%eax
f0108c0c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c0f:	75 2e                	jne    f0108c3f <get_share+0x60>
f0108c11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c14:	83 c0 08             	add    $0x8,%eax
f0108c17:	83 ec 08             	sub    $0x8,%esp
f0108c1a:	ff 75 0c             	pushl  0xc(%ebp)
f0108c1d:	50                   	push   %eax
f0108c1e:	e8 bf 71 01 00       	call   f011fde2 <strcmp>
f0108c23:	83 c4 10             	add    $0x10,%esp
f0108c26:	85 c0                	test   %eax,%eax
f0108c28:	75 15                	jne    f0108c3f <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108c2a:	83 ec 0c             	sub    $0xc,%esp
f0108c2d:	68 50 15 6c f0       	push   $0xf06c1550
f0108c32:	e8 78 71 00 00       	call   f010fdaf <release_spinlock>
f0108c37:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c3d:	eb 44                	jmp    f0108c83 <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108c3f:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f0108c44:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c4b:	74 08                	je     f0108c55 <get_share+0x76>
f0108c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c50:	8b 40 58             	mov    0x58(%eax),%eax
f0108c53:	eb 05                	jmp    f0108c5a <get_share+0x7b>
f0108c55:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c5a:	a3 48 15 6c f0       	mov    %eax,0xf06c1548
f0108c5f:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f0108c64:	85 c0                	test   %eax,%eax
f0108c66:	75 9e                	jne    f0108c06 <get_share+0x27>
f0108c68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c6c:	75 98                	jne    f0108c06 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108c6e:	83 ec 0c             	sub    $0xc,%esp
f0108c71:	68 50 15 6c f0       	push   $0xf06c1550
f0108c76:	e8 34 71 00 00       	call   f010fdaf <release_spinlock>
f0108c7b:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108c7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c83:	c9                   	leave  
f0108c84:	c3                   	ret    

f0108c85 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108c85:	55                   	push   %ebp
f0108c86:	89 e5                	mov    %esp,%ebp
f0108c88:	83 ec 48             	sub    $0x48,%esp
f0108c8b:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c8e:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108c91:	e8 03 2e 00 00       	call   f010ba99 <get_cpu_proc>
f0108c96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108c99:	83 ec 08             	sub    $0x8,%esp
f0108c9c:	ff 75 0c             	pushl  0xc(%ebp)
f0108c9f:	ff 75 08             	pushl  0x8(%ebp)
f0108ca2:	e8 38 ff ff ff       	call   f0108bdf <get_share>
f0108ca7:	83 c4 10             	add    $0x10,%esp
f0108caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108cad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108cb1:	74 0a                	je     f0108cbd <createSharedObject+0x38>
f0108cb3:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108cb8:	e9 7f 01 00 00       	jmp    f0108e3c <createSharedObject+0x1b7>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108cbd:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108cc1:	50                   	push   %eax
f0108cc2:	ff 75 10             	pushl  0x10(%ebp)
f0108cc5:	ff 75 0c             	pushl  0xc(%ebp)
f0108cc8:	ff 75 08             	pushl  0x8(%ebp)
f0108ccb:	e8 37 fe ff ff       	call   f0108b07 <create_share>
f0108cd0:	83 c4 10             	add    $0x10,%esp
f0108cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0108cd6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108cda:	75 0a                	jne    f0108ce6 <createSharedObject+0x61>
f0108cdc:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f0108ce1:	e9 56 01 00 00       	jmp    f0108e3c <createSharedObject+0x1b7>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108ce6:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108ced:	8b 55 10             	mov    0x10(%ebp),%edx
f0108cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108cf3:	01 d0                	add    %edx,%eax
f0108cf5:	48                   	dec    %eax
f0108cf6:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cfc:	ba 00 00 00 00       	mov    $0x0,%edx
f0108d01:	f7 75 e4             	divl   -0x1c(%ebp)
f0108d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d07:	29 d0                	sub    %edx,%eax
f0108d09:	c1 e8 0c             	shr    $0xc,%eax
f0108d0c:	89 45 dc             	mov    %eax,-0x24(%ebp)

	for (int k = 0; k < num_pages; k++)
f0108d0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108d16:	e9 8b 00 00 00       	jmp    f0108da6 <createSharedObject+0x121>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0108d1b:	83 ec 0c             	sub    $0xc,%esp
f0108d1e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108d21:	50                   	push   %eax
f0108d22:	e8 8b f4 ff ff       	call   f01081b2 <allocate_frame>
f0108d27:	83 c4 10             	add    $0x10,%esp
f0108d2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0108d2d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0108d31:	75 5c                	jne    f0108d8f <createSharedObject+0x10a>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f0108d33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d36:	c1 e0 0c             	shl    $0xc,%eax
f0108d39:	89 c2                	mov    %eax,%edx
f0108d3b:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d3e:	01 d0                	add    %edx,%eax
f0108d40:	89 c1                	mov    %eax,%ecx
f0108d42:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108d45:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d48:	8b 40 64             	mov    0x64(%eax),%eax
f0108d4b:	6a 06                	push   $0x6
f0108d4d:	51                   	push   %ecx
f0108d4e:	52                   	push   %edx
f0108d4f:	50                   	push   %eax
f0108d50:	e8 2a f9 ff ff       	call   f010867f <map_frame>
f0108d55:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0108d58:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d5b:	8b 40 54             	mov    0x54(%eax),%eax
f0108d5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d61:	c1 e2 02             	shl    $0x2,%edx
f0108d64:	01 c2                	add    %eax,%edx
f0108d66:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108d69:	89 02                	mov    %eax,(%edx)
			isTableExist[PDX((uint32)(virtual_address + (k * PAGE_SIZE)))]++;
f0108d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d6e:	c1 e0 0c             	shl    $0xc,%eax
f0108d71:	89 c2                	mov    %eax,%edx
f0108d73:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d76:	01 d0                	add    %edx,%eax
f0108d78:	c1 e8 16             	shr    $0x16,%eax
f0108d7b:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f0108d82:	42                   	inc    %edx
f0108d83:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d8a:	ff 45 f4             	incl   -0xc(%ebp)
f0108d8d:	eb 17                	jmp    f0108da6 <createSharedObject+0x121>
			created_share->framesStorage[k] = ptr_frame_info;
			isTableExist[PDX((uint32)(virtual_address + (k * PAGE_SIZE)))]++;
		}
		else
		{
			panic("No Memory");
f0108d8f:	83 ec 04             	sub    $0x4,%esp
f0108d92:	68 e8 5b 12 f0       	push   $0xf0125be8
f0108d97:	68 a7 00 00 00       	push   $0xa7
f0108d9c:	68 f4 5b 12 f0       	push   $0xf0125bf4
f0108da1:	e8 93 75 ff ff       	call   f0100339 <_panic>
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108da6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108da9:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108dac:	0f 82 69 ff ff ff    	jb     f0108d1b <createSharedObject+0x96>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f0108db2:	83 ec 0c             	sub    $0xc,%esp
f0108db5:	68 50 15 6c f0       	push   $0xf06c1550
f0108dba:	e8 69 6f 00 00       	call   f010fd28 <acquire_spinlock>
f0108dbf:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f0108dc2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108dc6:	75 17                	jne    f0108ddf <createSharedObject+0x15a>
f0108dc8:	83 ec 04             	sub    $0x4,%esp
f0108dcb:	68 18 5c 12 f0       	push   $0xf0125c18
f0108dd0:	68 ac 00 00 00       	push   $0xac
f0108dd5:	68 f4 5b 12 f0       	push   $0xf0125bf4
f0108dda:	e8 5a 75 ff ff       	call   f0100339 <_panic>
f0108ddf:	8b 15 44 15 6c f0    	mov    0xf06c1544,%edx
f0108de5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108de8:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108deb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dee:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108df1:	85 c0                	test   %eax,%eax
f0108df3:	74 0d                	je     f0108e02 <createSharedObject+0x17d>
f0108df5:	a1 44 15 6c f0       	mov    0xf06c1544,%eax
f0108dfa:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108dfd:	89 50 58             	mov    %edx,0x58(%eax)
f0108e00:	eb 08                	jmp    f0108e0a <createSharedObject+0x185>
f0108e02:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e05:	a3 40 15 6c f0       	mov    %eax,0xf06c1540
f0108e0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e0d:	a3 44 15 6c f0       	mov    %eax,0xf06c1544
f0108e12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e15:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108e1c:	a1 4c 15 6c f0       	mov    0xf06c154c,%eax
f0108e21:	40                   	inc    %eax
f0108e22:	a3 4c 15 6c f0       	mov    %eax,0xf06c154c
	release_spinlock(&AllShares.shareslock);
f0108e27:	83 ec 0c             	sub    $0xc,%esp
f0108e2a:	68 50 15 6c f0       	push   $0xf06c1550
f0108e2f:	e8 7b 6f 00 00       	call   f010fdaf <release_spinlock>
f0108e34:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f0108e37:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e3a:	8b 00                	mov    (%eax),%eax
}
f0108e3c:	c9                   	leave  
f0108e3d:	c3                   	ret    

f0108e3e <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108e3e:	55                   	push   %ebp
f0108e3f:	89 e5                	mov    %esp,%ebp
f0108e41:	53                   	push   %ebx
f0108e42:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108e45:	e8 4f 2c 00 00       	call   f010ba99 <get_cpu_proc>
f0108e4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0108e4d:	83 ec 08             	sub    $0x8,%esp
f0108e50:	ff 75 0c             	pushl  0xc(%ebp)
f0108e53:	ff 75 08             	pushl  0x8(%ebp)
f0108e56:	e8 84 fd ff ff       	call   f0108bdf <get_share>
f0108e5b:	83 c4 10             	add    $0x10,%esp
f0108e5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0108e61:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108e65:	75 0a                	jne    f0108e71 <getSharedObject+0x33>
f0108e67:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108e6c:	e9 d6 00 00 00       	jmp    f0108f47 <getSharedObject+0x109>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0108e71:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f0108e78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e7b:	8b 40 48             	mov    0x48(%eax),%eax
f0108e7e:	89 c2                	mov    %eax,%edx
f0108e80:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e83:	01 d0                	add    %edx,%eax
f0108e85:	48                   	dec    %eax
f0108e86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108e89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e8c:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e91:	f7 75 e8             	divl   -0x18(%ebp)
f0108e94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e97:	29 d0                	sub    %edx,%eax
f0108e99:	85 c0                	test   %eax,%eax
f0108e9b:	79 05                	jns    f0108ea2 <getSharedObject+0x64>
f0108e9d:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108ea2:	c1 f8 0c             	sar    $0xc,%eax
f0108ea5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f0108ea8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108eaf:	eb 63                	jmp    f0108f14 <getSharedObject+0xd6>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f0108eb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eb4:	8a 40 50             	mov    0x50(%eax),%al
f0108eb7:	0f b6 c0             	movzbl %al,%eax
f0108eba:	01 c0                	add    %eax,%eax
f0108ebc:	83 c8 04             	or     $0x4,%eax
f0108ebf:	89 c3                	mov    %eax,%ebx
f0108ec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ec4:	c1 e0 0c             	shl    $0xc,%eax
f0108ec7:	89 c2                	mov    %eax,%edx
f0108ec9:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ecc:	01 d0                	add    %edx,%eax
f0108ece:	89 c1                	mov    %eax,%ecx
f0108ed0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ed3:	8b 40 54             	mov    0x54(%eax),%eax
f0108ed6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ed9:	c1 e2 02             	shl    $0x2,%edx
f0108edc:	01 d0                	add    %edx,%eax
f0108ede:	8b 10                	mov    (%eax),%edx
f0108ee0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ee3:	8b 40 64             	mov    0x64(%eax),%eax
f0108ee6:	53                   	push   %ebx
f0108ee7:	51                   	push   %ecx
f0108ee8:	52                   	push   %edx
f0108ee9:	50                   	push   %eax
f0108eea:	e8 90 f7 ff ff       	call   f010867f <map_frame>
f0108eef:	83 c4 10             	add    $0x10,%esp
		isTableExist[PDX((uint32)(virtual_address + (i * PAGE_SIZE)))]++;
f0108ef2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ef5:	c1 e0 0c             	shl    $0xc,%eax
f0108ef8:	89 c2                	mov    %eax,%edx
f0108efa:	8b 45 10             	mov    0x10(%ebp),%eax
f0108efd:	01 d0                	add    %edx,%eax
f0108eff:	c1 e8 16             	shr    $0x16,%eax
f0108f02:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f0108f09:	42                   	inc    %edx
f0108f0a:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f0108f11:	ff 45 f4             	incl   -0xc(%ebp)
f0108f14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f17:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0108f1a:	72 95                	jb     f0108eb1 <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
		isTableExist[PDX((uint32)(virtual_address + (i * PAGE_SIZE)))]++;
	}
	shared_obj->references++;
f0108f1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f1f:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108f22:	8d 50 01             	lea    0x1(%eax),%edx
f0108f25:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f28:	89 50 4c             	mov    %edx,0x4c(%eax)
	cprintf("References : %d\n",shared_obj->references);
f0108f2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f2e:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108f31:	83 ec 08             	sub    $0x8,%esp
f0108f34:	50                   	push   %eax
f0108f35:	68 3b 5c 12 f0       	push   $0xf0125c3b
f0108f3a:	e8 4c 80 ff ff       	call   f0100f8b <cprintf>
f0108f3f:	83 c4 10             	add    $0x10,%esp
	return shared_obj->ID;
f0108f42:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f45:	8b 00                	mov    (%eax),%eax
}
f0108f47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108f4a:	c9                   	leave  
f0108f4b:	c3                   	ret    

f0108f4c <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108f4c:	55                   	push   %ebp
f0108f4d:	89 e5                	mov    %esp,%ebp
f0108f4f:	83 ec 08             	sub    $0x8,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0108f52:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108f56:	0f 84 ca 00 00 00    	je     f0109026 <free_share+0xda>
    acquire_spinlock(&AllShares.shareslock);
f0108f5c:	83 ec 0c             	sub    $0xc,%esp
f0108f5f:	68 50 15 6c f0       	push   $0xf06c1550
f0108f64:	e8 bf 6d 00 00       	call   f010fd28 <acquire_spinlock>
f0108f69:	83 c4 10             	add    $0x10,%esp
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
f0108f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108f70:	75 17                	jne    f0108f89 <free_share+0x3d>
f0108f72:	83 ec 04             	sub    $0x4,%esp
f0108f75:	68 4c 5c 12 f0       	push   $0xf0125c4c
f0108f7a:	68 db 00 00 00       	push   $0xdb
f0108f7f:	68 f4 5b 12 f0       	push   $0xf0125bf4
f0108f84:	e8 b0 73 ff ff       	call   f0100339 <_panic>
f0108f89:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f8c:	8b 40 58             	mov    0x58(%eax),%eax
f0108f8f:	85 c0                	test   %eax,%eax
f0108f91:	74 11                	je     f0108fa4 <free_share+0x58>
f0108f93:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f96:	8b 40 58             	mov    0x58(%eax),%eax
f0108f99:	8b 55 08             	mov    0x8(%ebp),%edx
f0108f9c:	8b 52 5c             	mov    0x5c(%edx),%edx
f0108f9f:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108fa2:	eb 0b                	jmp    f0108faf <free_share+0x63>
f0108fa4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fa7:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108faa:	a3 44 15 6c f0       	mov    %eax,0xf06c1544
f0108faf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fb2:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108fb5:	85 c0                	test   %eax,%eax
f0108fb7:	74 11                	je     f0108fca <free_share+0x7e>
f0108fb9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fbc:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108fbf:	8b 55 08             	mov    0x8(%ebp),%edx
f0108fc2:	8b 52 58             	mov    0x58(%edx),%edx
f0108fc5:	89 50 58             	mov    %edx,0x58(%eax)
f0108fc8:	eb 0b                	jmp    f0108fd5 <free_share+0x89>
f0108fca:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fcd:	8b 40 58             	mov    0x58(%eax),%eax
f0108fd0:	a3 40 15 6c f0       	mov    %eax,0xf06c1540
f0108fd5:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fd8:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108fdf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fe2:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f0108fe9:	a1 4c 15 6c f0       	mov    0xf06c154c,%eax
f0108fee:	48                   	dec    %eax
f0108fef:	a3 4c 15 6c f0       	mov    %eax,0xf06c154c
    release_spinlock(&AllShares.shareslock);
f0108ff4:	83 ec 0c             	sub    $0xc,%esp
f0108ff7:	68 50 15 6c f0       	push   $0xf06c1550
f0108ffc:	e8 ae 6d 00 00       	call   f010fdaf <release_spinlock>
f0109001:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare->framesStorage);
f0109004:	8b 45 08             	mov    0x8(%ebp),%eax
f0109007:	8b 40 54             	mov    0x54(%eax),%eax
f010900a:	83 ec 0c             	sub    $0xc,%esp
f010900d:	50                   	push   %eax
f010900e:	e8 ec 07 00 00       	call   f01097ff <kfree>
f0109013:	83 c4 10             	add    $0x10,%esp
    kfree((void*)ptrShare);
f0109016:	83 ec 0c             	sub    $0xc,%esp
f0109019:	ff 75 08             	pushl  0x8(%ebp)
f010901c:	e8 de 07 00 00       	call   f01097ff <kfree>
f0109021:	83 c4 10             	add    $0x10,%esp
f0109024:	eb 01                	jmp    f0109027 <free_share+0xdb>
{
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("free_share is not implemented yet");
    //Your Code is Here...
    if(ptrShare == NULL)return;
f0109026:	90                   	nop
    acquire_spinlock(&AllShares.shareslock);
    LIST_REMOVE(&AllShares.shares_list,ptrShare);
    release_spinlock(&AllShares.shareslock);
    kfree((void*)ptrShare->framesStorage);
    kfree((void*)ptrShare);
}
f0109027:	c9                   	leave  
f0109028:	c3                   	ret    

f0109029 <get_Share_id>:
//========================
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
f0109029:	55                   	push   %ebp
f010902a:	89 e5                	mov    %esp,%ebp
f010902c:	83 ec 18             	sub    $0x18,%esp
    struct Share* founded = NULL;
f010902f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        acquire_spinlock(&AllShares.shareslock);
f0109036:	83 ec 0c             	sub    $0xc,%esp
f0109039:	68 50 15 6c f0       	push   $0xf06c1550
f010903e:	e8 e5 6c 00 00       	call   f010fd28 <acquire_spinlock>
f0109043:	83 c4 10             	add    $0x10,%esp
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109046:	a1 40 15 6c f0       	mov    0xf06c1540,%eax
f010904b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010904e:	eb 40                	jmp    f0109090 <get_Share_id+0x67>
        	cprintf("Found ID : %x - Id : %x \n",founded->ID,sharedObjectID);
f0109050:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109053:	8b 00                	mov    (%eax),%eax
f0109055:	83 ec 04             	sub    $0x4,%esp
f0109058:	ff 75 08             	pushl  0x8(%ebp)
f010905b:	50                   	push   %eax
f010905c:	68 6a 5c 12 f0       	push   $0xf0125c6a
f0109061:	e8 25 7f ff ff       	call   f0100f8b <cprintf>
f0109066:	83 c4 10             	add    $0x10,%esp
            if(founded->ID == sharedObjectID)
f0109069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010906c:	8b 00                	mov    (%eax),%eax
f010906e:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109071:	75 15                	jne    f0109088 <get_Share_id+0x5f>
            {
                release_spinlock(&AllShares.shareslock);
f0109073:	83 ec 0c             	sub    $0xc,%esp
f0109076:	68 50 15 6c f0       	push   $0xf06c1550
f010907b:	e8 2f 6d 00 00       	call   f010fdaf <release_spinlock>
f0109080:	83 c4 10             	add    $0x10,%esp
                return founded;
f0109083:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109086:	eb 44                	jmp    f01090cc <get_Share_id+0xa3>
// [B2] Free Share Object:
//========================
struct Share* get_Share_id(int32 sharedObjectID,void * va){
    struct Share* founded = NULL;
        acquire_spinlock(&AllShares.shareslock);
        LIST_FOREACH(founded, &AllShares.shares_list) {
f0109088:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f010908d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109090:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109094:	74 08                	je     f010909e <get_Share_id+0x75>
f0109096:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109099:	8b 40 58             	mov    0x58(%eax),%eax
f010909c:	eb 05                	jmp    f01090a3 <get_Share_id+0x7a>
f010909e:	b8 00 00 00 00       	mov    $0x0,%eax
f01090a3:	a3 48 15 6c f0       	mov    %eax,0xf06c1548
f01090a8:	a1 48 15 6c f0       	mov    0xf06c1548,%eax
f01090ad:	85 c0                	test   %eax,%eax
f01090af:	75 9f                	jne    f0109050 <get_Share_id+0x27>
f01090b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01090b5:	75 99                	jne    f0109050 <get_Share_id+0x27>
            {
                release_spinlock(&AllShares.shareslock);
                return founded;
            }
        }
        release_spinlock(&AllShares.shareslock);
f01090b7:	83 ec 0c             	sub    $0xc,%esp
f01090ba:	68 50 15 6c f0       	push   $0xf06c1550
f01090bf:	e8 eb 6c 00 00       	call   f010fdaf <release_spinlock>
f01090c4:	83 c4 10             	add    $0x10,%esp
        return NULL;
f01090c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01090cc:	c9                   	leave  
f01090cd:	c3                   	ret    

f01090ce <freeSharedObject>:
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f01090ce:	55                   	push   %ebp
f01090cf:	89 e5                	mov    %esp,%ebp
f01090d1:	83 ec 38             	sub    $0x38,%esp
    //TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
    //COMMENT THE FOLLOWING LINE BEFORE START CODING
//    panic("freeSharedObject is not implemented yet");
    //Your Code is Here...
	struct Env* myenv = get_cpu_proc();
f01090d4:	e8 c0 29 00 00       	call   f010ba99 <get_cpu_proc>
f01090d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct Share* ptr_share= get_Share_id(sharedObjectID,startVA);
f01090dc:	83 ec 08             	sub    $0x8,%esp
f01090df:	ff 75 0c             	pushl  0xc(%ebp)
f01090e2:	ff 75 08             	pushl  0x8(%ebp)
f01090e5:	e8 3f ff ff ff       	call   f0109029 <get_Share_id>
f01090ea:	83 c4 10             	add    $0x10,%esp
f01090ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
        bool page_empty = 0;
f01090f0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        cprintf("245\n");
f01090f7:	83 ec 0c             	sub    $0xc,%esp
f01090fa:	68 84 5c 12 f0       	push   $0xf0125c84
f01090ff:	e8 87 7e ff ff       	call   f0100f8b <cprintf>
f0109104:	83 c4 10             	add    $0x10,%esp
        cprintf("Share : %x \n",ptr_share);
f0109107:	83 ec 08             	sub    $0x8,%esp
f010910a:	ff 75 ec             	pushl  -0x14(%ebp)
f010910d:	68 89 5c 12 f0       	push   $0xf0125c89
f0109112:	e8 74 7e ff ff       	call   f0100f8b <cprintf>
f0109117:	83 c4 10             	add    $0x10,%esp
        if(ptr_share == NULL) return -1;
f010911a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010911e:	75 0a                	jne    f010912a <freeSharedObject+0x5c>
f0109120:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109125:	e9 b4 01 00 00       	jmp    f01092de <freeSharedObject+0x210>
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
f010912a:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0109131:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109134:	8b 40 48             	mov    0x48(%eax),%eax
f0109137:	89 c2                	mov    %eax,%edx
f0109139:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010913c:	01 d0                	add    %edx,%eax
f010913e:	48                   	dec    %eax
f010913f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0109142:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109145:	ba 00 00 00 00       	mov    $0x0,%edx
f010914a:	f7 75 e4             	divl   -0x1c(%ebp)
f010914d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109150:	29 d0                	sub    %edx,%eax
f0109152:	85 c0                	test   %eax,%eax
f0109154:	79 05                	jns    f010915b <freeSharedObject+0x8d>
f0109156:	05 ff 0f 00 00       	add    $0xfff,%eax
f010915b:	c1 f8 0c             	sar    $0xc,%eax
f010915e:	89 45 dc             	mov    %eax,-0x24(%ebp)
        cprintf("Size : %d \n",ptr_share->size);
f0109161:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109164:	8b 40 48             	mov    0x48(%eax),%eax
f0109167:	83 ec 08             	sub    $0x8,%esp
f010916a:	50                   	push   %eax
f010916b:	68 96 5c 12 f0       	push   $0xf0125c96
f0109170:	e8 16 7e ff ff       	call   f0100f8b <cprintf>
f0109175:	83 c4 10             	add    $0x10,%esp
        uint32* ptr_page_table;
        for(int k = 0;k<no_of_pages;k++)
f0109178:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010917f:	e9 ee 00 00 00       	jmp    f0109272 <freeSharedObject+0x1a4>
		{
			unmap_frame(myenv->env_page_directory, (uint32)startVA + k*PAGE_SIZE);
f0109184:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109187:	c1 e0 0c             	shl    $0xc,%eax
f010918a:	89 c2                	mov    %eax,%edx
f010918c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010918f:	01 c2                	add    %eax,%edx
f0109191:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109194:	8b 40 64             	mov    0x64(%eax),%eax
f0109197:	83 ec 08             	sub    $0x8,%esp
f010919a:	52                   	push   %edx
f010919b:	50                   	push   %eax
f010919c:	e8 3e f6 ff ff       	call   f01087df <unmap_frame>
f01091a1:	83 c4 10             	add    $0x10,%esp
			int ret = get_page_table(myenv->env_page_directory, (uint32)startVA+ k*PAGE_SIZE, &ptr_page_table);
f01091a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091a7:	c1 e0 0c             	shl    $0xc,%eax
f01091aa:	89 c2                	mov    %eax,%edx
f01091ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01091af:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01091b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091b5:	8b 40 64             	mov    0x64(%eax),%eax
f01091b8:	83 ec 04             	sub    $0x4,%esp
f01091bb:	8d 55 d0             	lea    -0x30(%ebp),%edx
f01091be:	52                   	push   %edx
f01091bf:	51                   	push   %ecx
f01091c0:	50                   	push   %eax
f01091c1:	e8 29 f2 ff ff       	call   f01083ef <get_page_table>
f01091c6:	83 c4 10             	add    $0x10,%esp
f01091c9:	89 45 d8             	mov    %eax,-0x28(%ebp)
			isTableExist[PDX((uint32)startVA+ k*PAGE_SIZE)]--;
f01091cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091cf:	c1 e0 0c             	shl    $0xc,%eax
f01091d2:	89 c2                	mov    %eax,%edx
f01091d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01091d7:	01 d0                	add    %edx,%eax
f01091d9:	c1 e8 16             	shr    $0x16,%eax
f01091dc:	8b 14 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%edx
f01091e3:	4a                   	dec    %edx
f01091e4:	89 14 85 a0 1c 6c f0 	mov    %edx,-0xf93e360(,%eax,4)
			cprintf("Page Index : %d\n",isTableExist[PDX((uint32)startVA+ k*PAGE_SIZE)]);
f01091eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091ee:	c1 e0 0c             	shl    $0xc,%eax
f01091f1:	89 c2                	mov    %eax,%edx
f01091f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01091f6:	01 d0                	add    %edx,%eax
f01091f8:	c1 e8 16             	shr    $0x16,%eax
f01091fb:	8b 04 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%eax
f0109202:	83 ec 08             	sub    $0x8,%esp
f0109205:	50                   	push   %eax
f0109206:	68 a2 5c 12 f0       	push   $0xf0125ca2
f010920b:	e8 7b 7d ff ff       	call   f0100f8b <cprintf>
f0109210:	83 c4 10             	add    $0x10,%esp
			if(isTableExist[PDX((uint32)startVA+ k*PAGE_SIZE)] <= 1){
f0109213:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109216:	c1 e0 0c             	shl    $0xc,%eax
f0109219:	89 c2                	mov    %eax,%edx
f010921b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010921e:	01 d0                	add    %edx,%eax
f0109220:	c1 e8 16             	shr    $0x16,%eax
f0109223:	8b 04 85 a0 1c 6c f0 	mov    -0xf93e360(,%eax,4),%eax
f010922a:	83 f8 01             	cmp    $0x1,%eax
f010922d:	77 40                	ja     f010926f <freeSharedObject+0x1a1>
				cprintf("264\n");
f010922f:	83 ec 0c             	sub    $0xc,%esp
f0109232:	68 b3 5c 12 f0       	push   $0xf0125cb3
f0109237:	e8 4f 7d ff ff       	call   f0100f8b <cprintf>
f010923c:	83 c4 10             	add    $0x10,%esp
				kfree((void*)ptr_page_table);
f010923f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109242:	83 ec 0c             	sub    $0xc,%esp
f0109245:	50                   	push   %eax
f0109246:	e8 b4 05 00 00       	call   f01097ff <kfree>
f010924b:	83 c4 10             	add    $0x10,%esp
				myenv->env_page_directory[PDX((uint32)startVA+ k*PAGE_SIZE)] = 0;
f010924e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109251:	8b 40 64             	mov    0x64(%eax),%eax
f0109254:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109257:	c1 e2 0c             	shl    $0xc,%edx
f010925a:	89 d1                	mov    %edx,%ecx
f010925c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010925f:	01 ca                	add    %ecx,%edx
f0109261:	c1 ea 16             	shr    $0x16,%edx
f0109264:	c1 e2 02             	shl    $0x2,%edx
f0109267:	01 d0                	add    %edx,%eax
f0109269:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        cprintf("Share : %x \n",ptr_share);
        if(ptr_share == NULL) return -1;
        uint32 no_of_pages = ROUNDUP(ptr_share->size , PAGE_SIZE)/PAGE_SIZE;
        cprintf("Size : %d \n",ptr_share->size);
        uint32* ptr_page_table;
        for(int k = 0;k<no_of_pages;k++)
f010926f:	ff 45 f4             	incl   -0xc(%ebp)
f0109272:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109275:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0109278:	0f 82 06 ff ff ff    	jb     f0109184 <freeSharedObject+0xb6>
				kfree((void*)ptr_page_table);
				myenv->env_page_directory[PDX((uint32)startVA+ k*PAGE_SIZE)] = 0;
			}
		}
        //cprintf("251\n");
        ptr_share->references--;
f010927e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109281:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109284:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109287:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010928a:	89 50 4c             	mov    %edx,0x4c(%eax)
        cprintf("References2 : %d\n",ptr_share->references);
f010928d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109290:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109293:	83 ec 08             	sub    $0x8,%esp
f0109296:	50                   	push   %eax
f0109297:	68 b8 5c 12 f0       	push   $0xf0125cb8
f010929c:	e8 ea 7c ff ff       	call   f0100f8b <cprintf>
f01092a1:	83 c4 10             	add    $0x10,%esp
        if(ptr_share->references <= 1){
f01092a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01092a7:	8b 40 4c             	mov    0x4c(%eax),%eax
f01092aa:	83 f8 01             	cmp    $0x1,%eax
f01092ad:	77 1e                	ja     f01092cd <freeSharedObject+0x1ff>
        	cprintf("269\n");
f01092af:	83 ec 0c             	sub    $0xc,%esp
f01092b2:	68 ca 5c 12 f0       	push   $0xf0125cca
f01092b7:	e8 cf 7c ff ff       	call   f0100f8b <cprintf>
f01092bc:	83 c4 10             	add    $0x10,%esp
            free_share(ptr_share);
f01092bf:	83 ec 0c             	sub    $0xc,%esp
f01092c2:	ff 75 ec             	pushl  -0x14(%ebp)
f01092c5:	e8 82 fc ff ff       	call   f0108f4c <free_share>
f01092ca:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01092cd:	0f 20 d8             	mov    %cr3,%eax
f01092d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01092d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01092d6:	0f 22 d8             	mov    %eax,%cr3
        }
       // cprintf("261\n");
        tlbflush();
        return 0;
f01092d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01092de:	c9                   	leave  
f01092df:	c3                   	ret    

f01092e0 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01092e0:	55                   	push   %ebp
f01092e1:	89 e5                	mov    %esp,%ebp
f01092e3:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f01092e8:	83 f8 01             	cmp    $0x1,%eax
f01092eb:	75 04                	jne    f01092f1 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f01092ed:	b0 01                	mov    $0x1,%al
f01092ef:	eb 02                	jmp    f01092f3 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f01092f1:	b0 00                	mov    $0x0,%al
f01092f3:	5d                   	pop    %ebp
f01092f4:	c3                   	ret    

f01092f5 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f01092f5:	55                   	push   %ebp
f01092f6:	89 e5                	mov    %esp,%ebp
f01092f8:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f01092fd:	83 f8 02             	cmp    $0x2,%eax
f0109300:	75 04                	jne    f0109306 <isKHeapPlacementStrategyBESTFIT+0x11>
f0109302:	b0 01                	mov    $0x1,%al
f0109304:	eb 02                	jmp    f0109308 <isKHeapPlacementStrategyBESTFIT+0x13>
f0109306:	b0 00                	mov    $0x0,%al
f0109308:	5d                   	pop    %ebp
f0109309:	c3                   	ret    

f010930a <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010930a:	55                   	push   %ebp
f010930b:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010930d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109310:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f0109316:	29 d0                	sub    %edx,%eax
f0109318:	c1 f8 03             	sar    $0x3,%eax
f010931b:	89 c2                	mov    %eax,%edx
f010931d:	89 d0                	mov    %edx,%eax
f010931f:	c1 e0 02             	shl    $0x2,%eax
f0109322:	01 d0                	add    %edx,%eax
f0109324:	c1 e0 02             	shl    $0x2,%eax
f0109327:	01 d0                	add    %edx,%eax
f0109329:	c1 e0 02             	shl    $0x2,%eax
f010932c:	01 d0                	add    %edx,%eax
f010932e:	89 c1                	mov    %eax,%ecx
f0109330:	c1 e1 08             	shl    $0x8,%ecx
f0109333:	01 c8                	add    %ecx,%eax
f0109335:	89 c1                	mov    %eax,%ecx
f0109337:	c1 e1 10             	shl    $0x10,%ecx
f010933a:	01 c8                	add    %ecx,%eax
f010933c:	01 c0                	add    %eax,%eax
f010933e:	01 d0                	add    %edx,%eax
}
f0109340:	5d                   	pop    %ebp
f0109341:	c3                   	ret    

f0109342 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0109342:	55                   	push   %ebp
f0109343:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109345:	ff 75 08             	pushl  0x8(%ebp)
f0109348:	e8 bd ff ff ff       	call   f010930a <to_frame_number>
f010934d:	83 c4 04             	add    $0x4,%esp
f0109350:	c1 e0 0c             	shl    $0xc,%eax
}
f0109353:	c9                   	leave  
f0109354:	c3                   	ret    

f0109355 <initialize_kheap_dynamic_allocator>:

uint32 no_pages_alloc[NUM_OF_KHEAP_PAGES];
uint32 to_virtual[1048576];

int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0109355:	55                   	push   %ebp
f0109356:	89 e5                	mov    %esp,%ebp
f0109358:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f010935b:	8b 45 08             	mov    0x8(%ebp),%eax
f010935e:	a3 48 2d 6c f0       	mov    %eax,0xf06c2d48
	hard_limit = daLimit;
f0109363:	8b 45 10             	mov    0x10(%ebp),%eax
f0109366:	a3 74 1b 6c f0       	mov    %eax,0xf06c1b74
	brk = daStart + initSizeToAllocate;
f010936b:	8b 55 08             	mov    0x8(%ebp),%edx
f010936e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109371:	01 d0                	add    %edx,%eax
f0109373:	a3 40 2d 6c f0       	mov    %eax,0xf06c2d40

	if(brk > daLimit) panic("exceeds Limit");
f0109378:	a1 40 2d 6c f0       	mov    0xf06c2d40,%eax
f010937d:	3b 45 10             	cmp    0x10(%ebp),%eax
f0109380:	76 14                	jbe    f0109396 <initialize_kheap_dynamic_allocator+0x41>
f0109382:	83 ec 04             	sub    $0x4,%esp
f0109385:	68 d0 5c 12 f0       	push   $0xf0125cd0
f010938a:	6a 1b                	push   $0x1b
f010938c:	68 de 5c 12 f0       	push   $0xf0125cde
f0109391:	e8 a3 6f ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0109396:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f010939d:	8b 45 10             	mov    0x10(%ebp),%eax
f01093a0:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f01093a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01093a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f01093a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01093ac:	c1 e8 0c             	shr    $0xc,%eax
f01093af:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f01093b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01093b9:	e9 8a 00 00 00       	jmp    f0109448 <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f01093be:	83 ec 0c             	sub    $0xc,%esp
f01093c1:	8d 45 d8             	lea    -0x28(%ebp),%eax
f01093c4:	50                   	push   %eax
f01093c5:	e8 e8 ed ff ff       	call   f01081b2 <allocate_frame>
f01093ca:	83 c4 10             	add    $0x10,%esp
f01093cd:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f01093d0:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f01093d4:	74 5e                	je     f0109434 <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f01093d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093d9:	c1 e0 0c             	shl    $0xc,%eax
f01093dc:	89 c2                	mov    %eax,%edx
f01093de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093e1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01093e4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01093e7:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01093ec:	6a 02                	push   $0x2
f01093ee:	51                   	push   %ecx
f01093ef:	52                   	push   %edx
f01093f0:	50                   	push   %eax
f01093f1:	e8 89 f2 ff ff       	call   f010867f <map_frame>
f01093f6:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f01093f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093fc:	c1 e0 0c             	shl    $0xc,%eax
f01093ff:	89 c2                	mov    %eax,%edx
f0109401:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109404:	01 d0                	add    %edx,%eax
f0109406:	83 ec 0c             	sub    $0xc,%esp
f0109409:	50                   	push   %eax
f010940a:	e8 d6 04 00 00       	call   f01098e5 <kheap_physical_address>
f010940f:	83 c4 10             	add    $0x10,%esp
f0109412:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f0109415:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109418:	c1 e8 0c             	shr    $0xc,%eax
f010941b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010941e:	c1 e2 0c             	shl    $0xc,%edx
f0109421:	89 d1                	mov    %edx,%ecx
f0109423:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109426:	01 ca                	add    %ecx,%edx
f0109428:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f010942f:	ff 45 f4             	incl   -0xc(%ebp)
f0109432:	eb 14                	jmp    f0109448 <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f0109434:	83 ec 04             	sub    $0x4,%esp
f0109437:	68 ef 5c 12 f0       	push   $0xf0125cef
f010943c:	6a 30                	push   $0x30
f010943e:	68 de 5c 12 f0       	push   $0xf0125cde
f0109443:	e8 f1 6e ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109448:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010944b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010944e:	0f 82 6a ff ff ff    	jb     f01093be <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f0109454:	83 ec 08             	sub    $0x8,%esp
f0109457:	ff 75 0c             	pushl  0xc(%ebp)
f010945a:	ff 75 08             	pushl  0x8(%ebp)
f010945d:	e8 43 74 01 00       	call   f01208a5 <initialize_dynamic_allocator>
f0109462:	83 c4 10             	add    $0x10,%esp

	return 0;
f0109465:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010946a:	c9                   	leave  
f010946b:	c3                   	ret    

f010946c <sbrk>:

void* sbrk(int numOfPages)
{
f010946c:	55                   	push   %ebp
f010946d:	89 e5                	mov    %esp,%ebp
f010946f:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f0109472:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109476:	0f 8e d6 00 00 00    	jle    f0109552 <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010947c:	8b 45 08             	mov    0x8(%ebp),%eax
f010947f:	c1 e0 0c             	shl    $0xc,%eax
f0109482:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f0109485:	a1 40 2d 6c f0       	mov    0xf06c2d40,%eax
f010948a:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f010948d:	8b 15 40 2d 6c f0    	mov    0xf06c2d40,%edx
f0109493:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109496:	01 c2                	add    %eax,%edx
f0109498:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f010949d:	39 c2                	cmp    %eax,%edx
f010949f:	76 0a                	jbe    f01094ab <sbrk+0x3f>
f01094a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01094a6:	e9 b9 00 00 00       	jmp    f0109564 <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f01094ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01094b2:	eb 7d                	jmp    f0109531 <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f01094b4:	83 ec 0c             	sub    $0xc,%esp
f01094b7:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01094ba:	50                   	push   %eax
f01094bb:	e8 f2 ec ff ff       	call   f01081b2 <allocate_frame>
f01094c0:	83 c4 10             	add    $0x10,%esp
f01094c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f01094c6:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01094ca:	74 5e                	je     f010952a <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f01094cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094cf:	c1 e0 0c             	shl    $0xc,%eax
f01094d2:	89 c2                	mov    %eax,%edx
f01094d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094d7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f01094da:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01094dd:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01094e2:	6a 02                	push   $0x2
f01094e4:	51                   	push   %ecx
f01094e5:	52                   	push   %edx
f01094e6:	50                   	push   %eax
f01094e7:	e8 93 f1 ff ff       	call   f010867f <map_frame>
f01094ec:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f01094ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094f2:	c1 e0 0c             	shl    $0xc,%eax
f01094f5:	89 c2                	mov    %eax,%edx
f01094f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01094fa:	01 d0                	add    %edx,%eax
f01094fc:	83 ec 0c             	sub    $0xc,%esp
f01094ff:	50                   	push   %eax
f0109500:	e8 e0 03 00 00       	call   f01098e5 <kheap_physical_address>
f0109505:	83 c4 10             	add    $0x10,%esp
f0109508:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f010950b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010950e:	c1 e8 0c             	shr    $0xc,%eax
f0109511:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109514:	c1 e2 0c             	shl    $0xc,%edx
f0109517:	89 d1                	mov    %edx,%ecx
f0109519:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010951c:	01 ca                	add    %ecx,%edx
f010951e:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109525:	ff 45 f4             	incl   -0xc(%ebp)
f0109528:	eb 07                	jmp    f0109531 <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f010952a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010952f:	eb 33                	jmp    f0109564 <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f0109531:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109534:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109537:	0f 8c 77 ff ff ff    	jl     f01094b4 <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f010953d:	8b 15 40 2d 6c f0    	mov    0xf06c2d40,%edx
f0109543:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109546:	01 d0                	add    %edx,%eax
f0109548:	a3 40 2d 6c f0       	mov    %eax,0xf06c2d40
		return (void *)prev_brk;
f010954d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109550:	eb 12                	jmp    f0109564 <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f0109552:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109556:	75 07                	jne    f010955f <sbrk+0xf3>
	{
		return (void *) brk;
f0109558:	a1 40 2d 6c f0       	mov    0xf06c2d40,%eax
f010955d:	eb 05                	jmp    f0109564 <sbrk+0xf8>
	}

	return (void *)-1;
f010955f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f0109564:	c9                   	leave  
f0109565:	c3                   	ret    

f0109566 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f0109566:	55                   	push   %ebp
f0109567:	89 e5                	mov    %esp,%ebp
f0109569:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f010956c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f0109573:	83 ec 04             	sub    $0x4,%esp
f0109576:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109579:	50                   	push   %eax
f010957a:	ff 75 0c             	pushl  0xc(%ebp)
f010957d:	ff 75 08             	pushl  0x8(%ebp)
f0109580:	e8 e4 f1 ff ff       	call   f0108769 <get_frame_info>
f0109585:	83 c4 10             	add    $0x10,%esp
f0109588:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f010958b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010958f:	75 07                	jne    f0109598 <isPageAllocated+0x32>
f0109591:	b8 00 00 00 00       	mov    $0x0,%eax
f0109596:	eb 05                	jmp    f010959d <isPageAllocated+0x37>
	return 1;
f0109598:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010959d:	c9                   	leave  
f010959e:	c3                   	ret    

f010959f <kmalloc>:

void *kmalloc(unsigned int size)
{
f010959f:	55                   	push   %ebp
f01095a0:	89 e5                	mov    %esp,%ebp
f01095a2:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f01095a5:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01095ac:	8b 55 08             	mov    0x8(%ebp),%edx
f01095af:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01095b2:	01 d0                	add    %edx,%eax
f01095b4:	48                   	dec    %eax
f01095b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01095b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095bb:	ba 00 00 00 00       	mov    $0x0,%edx
f01095c0:	f7 75 d8             	divl   -0x28(%ebp)
f01095c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01095c6:	29 d0                	sub    %edx,%eax
f01095c8:	c1 e8 0c             	shr    $0xc,%eax
f01095cb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f01095ce:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f01095d5:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f01095da:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01095dd:	29 c2                	sub    %eax,%edx
f01095df:	89 d0                	mov    %edx,%eax
f01095e1:	48                   	dec    %eax
f01095e2:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01095e5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01095e8:	ba 00 00 00 00       	mov    $0x0,%edx
f01095ed:	f7 75 cc             	divl   -0x34(%ebp)
f01095f0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01095f3:	29 d0                	sub    %edx,%eax
f01095f5:	c1 e8 0c             	shr    $0xc,%eax
f01095f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f01095fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109602:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109609:	77 42                	ja     f010964d <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f010960b:	e8 d0 fc ff ff       	call   f01092e0 <isKHeapPlacementStrategyFIRSTFIT>
f0109610:	84 c0                	test   %al,%al
f0109612:	74 16                	je     f010962a <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f0109614:	83 ec 0c             	sub    $0xc,%esp
f0109617:	ff 75 08             	pushl  0x8(%ebp)
f010961a:	e8 a2 74 01 00       	call   f0120ac1 <alloc_block_FF>
f010961f:	83 c4 10             	add    $0x10,%esp
f0109622:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109625:	e9 d0 01 00 00       	jmp    f01097fa <kmalloc+0x25b>
		else if (isKHeapPlacementStrategyBESTFIT())
f010962a:	e8 c6 fc ff ff       	call   f01092f5 <isKHeapPlacementStrategyBESTFIT>
f010962f:	84 c0                	test   %al,%al
f0109631:	0f 84 c3 01 00 00    	je     f01097fa <kmalloc+0x25b>
			ptr = alloc_block_BF(size);
f0109637:	83 ec 0c             	sub    $0xc,%esp
f010963a:	ff 75 08             	pushl  0x8(%ebp)
f010963d:	e8 3b 79 01 00       	call   f0120f7d <alloc_block_BF>
f0109642:	83 c4 10             	add    $0x10,%esp
f0109645:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109648:	e9 ad 01 00 00       	jmp    f01097fa <kmalloc+0x25b>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f010964d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109650:	48                   	dec    %eax
f0109651:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109654:	0f 86 99 01 00 00    	jbe    f01097f3 <kmalloc+0x254>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f010965a:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f010965f:	05 00 10 00 00       	add    $0x1000,%eax
f0109664:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f0109667:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f010966e:	e9 86 00 00 00       	jmp    f01096f9 <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f0109673:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109678:	83 ec 08             	sub    $0x8,%esp
f010967b:	ff 75 f0             	pushl  -0x10(%ebp)
f010967e:	50                   	push   %eax
f010967f:	e8 e2 fe ff ff       	call   f0109566 <isPageAllocated>
f0109684:	83 c4 10             	add    $0x10,%esp
f0109687:	85 c0                	test   %eax,%eax
f0109689:	75 61                	jne    f01096ec <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f010968b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010968e:	05 00 10 00 00       	add    $0x1000,%eax
f0109693:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f0109696:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f010969d:	eb 3d                	jmp    f01096dc <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f010969f:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f01096a6:	76 0a                	jbe    f01096b2 <kmalloc+0x113>
f01096a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01096ad:	e9 4b 01 00 00       	jmp    f01097fd <kmalloc+0x25e>
					if (isPageAllocated(ptr_page_directory, j))
f01096b2:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01096b7:	83 ec 08             	sub    $0x8,%esp
f01096ba:	ff 75 e8             	pushl  -0x18(%ebp)
f01096bd:	50                   	push   %eax
f01096be:	e8 a3 fe ff ff       	call   f0109566 <isPageAllocated>
f01096c3:	83 c4 10             	add    $0x10,%esp
f01096c6:	85 c0                	test   %eax,%eax
f01096c8:	74 08                	je     f01096d2 <kmalloc+0x133>
					{

						i = j;
f01096ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01096cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f01096d0:	eb 1a                	jmp    f01096ec <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f01096d2:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f01096d9:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f01096dc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01096df:	48                   	dec    %eax
f01096e0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01096e3:	77 ba                	ja     f010969f <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f01096e5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f01096ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01096f0:	75 16                	jne    f0109708 <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f01096f2:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f01096f9:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f0109700:	0f 86 6d ff ff ff    	jbe    f0109673 <kmalloc+0xd4>
f0109706:	eb 01                	jmp    f0109709 <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109708:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f0109709:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010970d:	75 0a                	jne    f0109719 <kmalloc+0x17a>
f010970f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109714:	e9 e4 00 00 00       	jmp    f01097fd <kmalloc+0x25e>
		for (int k = 0; k < num_pages; k++)
f0109719:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109720:	eb 57                	jmp    f0109779 <kmalloc+0x1da>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f0109722:	83 ec 0c             	sub    $0xc,%esp
f0109725:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0109728:	50                   	push   %eax
f0109729:	e8 84 ea ff ff       	call   f01081b2 <allocate_frame>
f010972e:	83 c4 10             	add    $0x10,%esp
f0109731:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (ret != E_NO_MEM)
f0109734:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f0109738:	74 28                	je     f0109762 <kmalloc+0x1c3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
f010973a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010973d:	c1 e0 0c             	shl    $0xc,%eax
f0109740:	89 c2                	mov    %eax,%edx
f0109742:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109745:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109748:	8b 55 b8             	mov    -0x48(%ebp),%edx
f010974b:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109750:	6a 02                	push   $0x2
f0109752:	51                   	push   %ecx
f0109753:	52                   	push   %edx
f0109754:	50                   	push   %eax
f0109755:	e8 25 ef ff ff       	call   f010867f <map_frame>
f010975a:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f010975d:	ff 45 e0             	incl   -0x20(%ebp)
f0109760:	eb 17                	jmp    f0109779 <kmalloc+0x1da>
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE);
				//isTableExist[PDX(i + k * PAGE_SIZE)]++;
			}
			else
			{
				panic("No Memory");
f0109762:	83 ec 04             	sub    $0x4,%esp
f0109765:	68 ef 5c 12 f0       	push   $0xf0125cef
f010976a:	68 b7 00 00 00       	push   $0xb7
f010976f:	68 de 5c 12 f0       	push   $0xf0125cde
f0109774:	e8 c0 6b ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f0109779:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010977c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010977f:	72 a1                	jb     f0109722 <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f0109781:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109784:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f0109787:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f010978c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010978f:	29 c2                	sub    %eax,%edx
f0109791:	89 d0                	mov    %edx,%eax
f0109793:	2d 00 10 00 00       	sub    $0x1000,%eax
f0109798:	c1 e8 0c             	shr    $0xc,%eax
f010979b:	89 c2                	mov    %eax,%edx
f010979d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01097a0:	89 04 95 e0 12 6e f0 	mov    %eax,-0xf91ed20(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f01097a7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01097ae:	eb 39                	jmp    f01097e9 <kmalloc+0x24a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f01097b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01097b3:	c1 e0 0c             	shl    $0xc,%eax
f01097b6:	89 c2                	mov    %eax,%edx
f01097b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01097bb:	01 d0                	add    %edx,%eax
f01097bd:	83 ec 0c             	sub    $0xc,%esp
f01097c0:	50                   	push   %eax
f01097c1:	e8 1f 01 00 00       	call   f01098e5 <kheap_physical_address>
f01097c6:	83 c4 10             	add    $0x10,%esp
f01097c9:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f01097cc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01097cf:	c1 e8 0c             	shr    $0xc,%eax
f01097d2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01097d5:	c1 e2 0c             	shl    $0xc,%edx
f01097d8:	89 d1                	mov    %edx,%ecx
f01097da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01097dd:	01 ca                	add    %ecx,%edx
f01097df:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f01097e6:	ff 45 dc             	incl   -0x24(%ebp)
f01097e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01097ec:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01097ef:	72 bf                	jb     f01097b0 <kmalloc+0x211>
f01097f1:	eb 07                	jmp    f01097fa <kmalloc+0x25b>
		}
	}
	else
	{

		return NULL;
f01097f3:	b8 00 00 00 00       	mov    $0x0,%eax
f01097f8:	eb 03                	jmp    f01097fd <kmalloc+0x25e>
	}
	return ptr;
f01097fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01097fd:	c9                   	leave  
f01097fe:	c3                   	ret    

f01097ff <kfree>:

void kfree(void *va)
{
f01097ff:	55                   	push   %ebp
f0109800:	89 e5                	mov    %esp,%ebp
f0109802:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f0109805:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f010980a:	05 00 10 00 00       	add    $0x1000,%eax
f010980f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f0109812:	8b 55 08             	mov    0x8(%ebp),%edx
f0109815:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f010981a:	39 c2                	cmp    %eax,%edx
f010981c:	73 13                	jae    f0109831 <kfree+0x32>
        free_block(va);
f010981e:	83 ec 0c             	sub    $0xc,%esp
f0109821:	ff 75 08             	pushl  0x8(%ebp)
f0109824:	e8 5c 81 01 00       	call   f0121985 <free_block>
f0109829:	83 c4 10             	add    $0x10,%esp
			//isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f010982c:	e9 b1 00 00 00       	jmp    f01098e2 <kfree+0xe3>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109831:	8b 45 08             	mov    0x8(%ebp),%eax
f0109834:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109837:	0f 82 8e 00 00 00    	jb     f01098cb <kfree+0xcc>
f010983d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109840:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f0109845:	0f 87 80 00 00 00    	ja     f01098cb <kfree+0xcc>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f010984b:	8b 55 08             	mov    0x8(%ebp),%edx
f010984e:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f0109853:	29 c2                	sub    %eax,%edx
f0109855:	89 d0                	mov    %edx,%eax
f0109857:	2d 00 10 00 00       	sub    $0x1000,%eax
f010985c:	c1 e8 0c             	shr    $0xc,%eax
f010985f:	8b 04 85 e0 12 6e f0 	mov    -0xf91ed20(,%eax,4),%eax
f0109866:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f0109869:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109870:	eb 4f                	jmp    f01098c1 <kfree+0xc2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f0109872:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109875:	c1 e0 0c             	shl    $0xc,%eax
f0109878:	89 c2                	mov    %eax,%edx
f010987a:	8b 45 08             	mov    0x8(%ebp),%eax
f010987d:	01 d0                	add    %edx,%eax
f010987f:	83 ec 0c             	sub    $0xc,%esp
f0109882:	50                   	push   %eax
f0109883:	e8 5d 00 00 00       	call   f01098e5 <kheap_physical_address>
f0109888:	83 c4 10             	add    $0x10,%esp
f010988b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f010988e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109891:	c1 e8 0c             	shr    $0xc,%eax
f0109894:	c7 04 85 e0 92 70 f0 	movl   $0x0,-0xf8f6d20(,%eax,4)
f010989b:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f010989f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01098a2:	c1 e0 0c             	shl    $0xc,%eax
f01098a5:	89 c2                	mov    %eax,%edx
f01098a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01098aa:	01 c2                	add    %eax,%edx
f01098ac:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01098b1:	83 ec 08             	sub    $0x8,%esp
f01098b4:	52                   	push   %edx
f01098b5:	50                   	push   %eax
f01098b6:	e8 24 ef ff ff       	call   f01087df <unmap_frame>
f01098bb:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f01098be:	ff 45 f4             	incl   -0xc(%ebp)
f01098c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01098c4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01098c7:	72 a9                	jb     f0109872 <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f01098c9:	eb 17                	jmp    f01098e2 <kfree+0xe3>
			to_virtual[pa / PAGE_SIZE] = 0;
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
			//isTableExist[PDX((uint32)va + i*PAGE_SIZE)]--;
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f01098cb:	83 ec 04             	sub    $0x4,%esp
f01098ce:	68 fc 5c 12 f0       	push   $0xf0125cfc
f01098d3:	68 df 00 00 00       	push   $0xdf
f01098d8:	68 de 5c 12 f0       	push   $0xf0125cde
f01098dd:	e8 57 6a ff ff       	call   f0100339 <_panic>
    }
}
f01098e2:	90                   	nop
f01098e3:	c9                   	leave  
f01098e4:	c3                   	ret    

f01098e5 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f01098e5:	55                   	push   %ebp
f01098e6:	89 e5                	mov    %esp,%ebp
f01098e8:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f01098eb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f01098f2:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01098f7:	83 ec 04             	sub    $0x4,%esp
f01098fa:	8d 55 e8             	lea    -0x18(%ebp),%edx
f01098fd:	52                   	push   %edx
f01098fe:	ff 75 08             	pushl  0x8(%ebp)
f0109901:	50                   	push   %eax
f0109902:	e8 62 ee ff ff       	call   f0108769 <get_frame_info>
f0109907:	83 c4 10             	add    $0x10,%esp
f010990a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f010990d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109911:	75 07                	jne    f010991a <kheap_physical_address+0x35>
		return 0;
f0109913:	b8 00 00 00 00       	mov    $0x0,%eax
f0109918:	eb 26                	jmp    f0109940 <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f010991a:	8b 45 08             	mov    0x8(%ebp),%eax
f010991d:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109922:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f0109925:	83 ec 0c             	sub    $0xc,%esp
f0109928:	ff 75 f4             	pushl  -0xc(%ebp)
f010992b:	e8 12 fa ff ff       	call   f0109342 <to_physical_address>
f0109930:	83 c4 10             	add    $0x10,%esp
f0109933:	89 c2                	mov    %eax,%edx
f0109935:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109938:	01 d0                	add    %edx,%eax
f010993a:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f010993d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0109940:	c9                   	leave  
f0109941:	c3                   	ret    

f0109942 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109942:	55                   	push   %ebp
f0109943:	89 e5                	mov    %esp,%ebp
f0109945:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f0109948:	8b 45 08             	mov    0x8(%ebp),%eax
f010994b:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109950:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f0109953:	8b 45 08             	mov    0x8(%ebp),%eax
f0109956:	c1 e8 0c             	shr    $0xc,%eax
f0109959:	8b 04 85 e0 92 70 f0 	mov    -0xf8f6d20(,%eax,4),%eax
f0109960:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f0109963:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0109967:	74 06                	je     f010996f <kheap_virtual_address+0x2d>
f0109969:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010996c:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f010996f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0109972:	c9                   	leave  
f0109973:	c3                   	ret    

f0109974 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *va, uint32 new_size)
{
f0109974:	55                   	push   %ebp
f0109975:	89 e5                	mov    %esp,%ebp
f0109977:	83 ec 58             	sub    $0x58,%esp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	//return NULL;
//	panic("krealloc() is not implemented yet...!!");
	void *ptr = NULL;
f010997a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(va == NULL){
f0109981:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109985:	75 16                	jne    f010999d <krealloc+0x29>
		ptr = kmalloc(new_size);
f0109987:	83 ec 0c             	sub    $0xc,%esp
f010998a:	ff 75 0c             	pushl  0xc(%ebp)
f010998d:	e8 0d fc ff ff       	call   f010959f <kmalloc>
f0109992:	83 c4 10             	add    $0x10,%esp
f0109995:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109998:	e9 37 03 00 00       	jmp    f0109cd4 <krealloc+0x360>
	} else if(new_size == 0){
f010999d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01099a1:	75 13                	jne    f01099b6 <krealloc+0x42>
		kfree(va);
f01099a3:	83 ec 0c             	sub    $0xc,%esp
f01099a6:	ff 75 08             	pushl  0x8(%ebp)
f01099a9:	e8 51 fe ff ff       	call   f01097ff <kfree>
f01099ae:	83 c4 10             	add    $0x10,%esp
f01099b1:	e9 1e 03 00 00       	jmp    f0109cd4 <krealloc+0x360>
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
f01099b6:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f01099bb:	05 00 10 00 00       	add    $0x1000,%eax
f01099c0:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)va < hard_limit){
f01099c3:	8b 55 08             	mov    0x8(%ebp),%edx
f01099c6:	a1 74 1b 6c f0       	mov    0xf06c1b74,%eax
f01099cb:	39 c2                	cmp    %eax,%edx
f01099cd:	73 19                	jae    f01099e8 <krealloc+0x74>
			ptr = realloc_block_FF(va, new_size);
f01099cf:	83 ec 08             	sub    $0x8,%esp
f01099d2:	ff 75 0c             	pushl  0xc(%ebp)
f01099d5:	ff 75 08             	pushl  0x8(%ebp)
f01099d8:	e8 a8 80 01 00       	call   f0121a85 <realloc_block_FF>
f01099dd:	83 c4 10             	add    $0x10,%esp
f01099e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01099e3:	e9 ec 02 00 00       	jmp    f0109cd4 <krealloc+0x360>
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f01099e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01099eb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01099ee:	0f 82 c8 02 00 00    	jb     f0109cbc <krealloc+0x348>
f01099f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01099f7:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f01099fc:	0f 87 ba 02 00 00    	ja     f0109cbc <krealloc+0x348>
			uint32 num_pages = ROUNDUP(new_size ,PAGE_SIZE) / PAGE_SIZE;
f0109a02:	c7 45 d4 00 10 00 00 	movl   $0x1000,-0x2c(%ebp)
f0109a09:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109a0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109a0f:	01 d0                	add    %edx,%eax
f0109a11:	48                   	dec    %eax
f0109a12:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109a15:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109a18:	ba 00 00 00 00       	mov    $0x0,%edx
f0109a1d:	f7 75 d4             	divl   -0x2c(%ebp)
f0109a20:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109a23:	29 d0                	sub    %edx,%eax
f0109a25:	c1 e8 0c             	shr    $0xc,%eax
f0109a28:	89 45 cc             	mov    %eax,-0x34(%ebp)
			uint32 num_old_pages = no_pages_alloc[(uint32)va / PAGE_SIZE];
f0109a2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a2e:	c1 e8 0c             	shr    $0xc,%eax
f0109a31:	8b 04 85 e0 12 6e f0 	mov    -0xf91ed20(,%eax,4),%eax
f0109a38:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if(num_pages <= num_old_pages){
f0109a3b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109a3e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0109a41:	0f 87 ee 00 00 00    	ja     f0109b35 <krealloc+0x1c1>
				if (new_size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f0109a47:	81 7d 0c 00 08 00 00 	cmpl   $0x800,0xc(%ebp)
f0109a4e:	77 63                	ja     f0109ab3 <krealloc+0x13f>
				{
					if (isKHeapPlacementStrategyFIRSTFIT())
f0109a50:	e8 8b f8 ff ff       	call   f01092e0 <isKHeapPlacementStrategyFIRSTFIT>
f0109a55:	84 c0                	test   %al,%al
f0109a57:	74 13                	je     f0109a6c <krealloc+0xf8>
						ptr = alloc_block_FF(new_size);
f0109a59:	83 ec 0c             	sub    $0xc,%esp
f0109a5c:	ff 75 0c             	pushl  0xc(%ebp)
f0109a5f:	e8 5d 70 01 00       	call   f0120ac1 <alloc_block_FF>
f0109a64:	83 c4 10             	add    $0x10,%esp
f0109a67:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109a6a:	eb 1a                	jmp    f0109a86 <krealloc+0x112>
					else if (isKHeapPlacementStrategyBESTFIT())
f0109a6c:	e8 84 f8 ff ff       	call   f01092f5 <isKHeapPlacementStrategyBESTFIT>
f0109a71:	84 c0                	test   %al,%al
f0109a73:	74 11                	je     f0109a86 <krealloc+0x112>
						ptr = alloc_block_BF(new_size);
f0109a75:	83 ec 0c             	sub    $0xc,%esp
f0109a78:	ff 75 0c             	pushl  0xc(%ebp)
f0109a7b:	e8 fd 74 01 00       	call   f0120f7d <alloc_block_BF>
f0109a80:	83 c4 10             	add    $0x10,%esp
f0109a83:	89 45 f4             	mov    %eax,-0xc(%ebp)
					if(ptr != NULL) memcpy(ptr, va, new_size);
f0109a86:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109a8a:	74 14                	je     f0109aa0 <krealloc+0x12c>
f0109a8c:	83 ec 04             	sub    $0x4,%esp
f0109a8f:	ff 75 0c             	pushl  0xc(%ebp)
f0109a92:	ff 75 08             	pushl  0x8(%ebp)
f0109a95:	ff 75 f4             	pushl  -0xc(%ebp)
f0109a98:	e8 57 64 01 00       	call   f011fef4 <memcpy>
f0109a9d:	83 c4 10             	add    $0x10,%esp
					kfree(va);
f0109aa0:	83 ec 0c             	sub    $0xc,%esp
f0109aa3:	ff 75 08             	pushl  0x8(%ebp)
f0109aa6:	e8 54 fd ff ff       	call   f01097ff <kfree>
f0109aab:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109aae:	e9 20 02 00 00       	jmp    f0109cd3 <krealloc+0x35f>
					else if (isKHeapPlacementStrategyBESTFIT())
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
f0109ab3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ab6:	c1 e0 0c             	shl    $0xc,%eax
f0109ab9:	89 c2                	mov    %eax,%edx
f0109abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109abe:	01 d0                	add    %edx,%eax
f0109ac0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109aca:	eb 4f                	jmp    f0109b1b <krealloc+0x1a7>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
f0109acc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109acf:	c1 e0 0c             	shl    $0xc,%eax
f0109ad2:	89 c2                	mov    %eax,%edx
f0109ad4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109ad7:	01 d0                	add    %edx,%eax
f0109ad9:	83 ec 0c             	sub    $0xc,%esp
f0109adc:	50                   	push   %eax
f0109add:	e8 03 fe ff ff       	call   f01098e5 <kheap_physical_address>
f0109ae2:	83 c4 10             	add    $0x10,%esp
f0109ae5:	89 45 c0             	mov    %eax,-0x40(%ebp)
						to_virtual[pa / PAGE_SIZE] = 0;
f0109ae8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109aeb:	c1 e8 0c             	shr    $0xc,%eax
f0109aee:	c7 04 85 e0 92 70 f0 	movl   $0x0,-0xf8f6d20(,%eax,4)
f0109af5:	00 00 00 00 
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
f0109af9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109afc:	c1 e0 0c             	shl    $0xc,%eax
f0109aff:	89 c2                	mov    %eax,%edx
f0109b01:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109b04:	01 c2                	add    %eax,%edx
f0109b06:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109b0b:	83 ec 08             	sub    $0x8,%esp
f0109b0e:	52                   	push   %edx
f0109b0f:	50                   	push   %eax
f0109b10:	e8 ca ec ff ff       	call   f01087df <unmap_frame>
f0109b15:	83 c4 10             	add    $0x10,%esp
						ptr = alloc_block_BF(new_size);
					if(ptr != NULL) memcpy(ptr, va, new_size);
					kfree(va);
				} else{
					void* va_to_free = (char*)va + (num_pages * PAGE_SIZE);
					for(int i = 0; i < (num_old_pages - num_pages); i++){
f0109b18:	ff 45 f0             	incl   -0x10(%ebp)
f0109b1b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109b1e:	2b 45 cc             	sub    -0x34(%ebp),%eax
f0109b21:	89 c2                	mov    %eax,%edx
f0109b23:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b26:	39 c2                	cmp    %eax,%edx
f0109b28:	77 a2                	ja     f0109acc <krealloc+0x158>
						uint32 pa = kheap_physical_address((uint32)va_to_free + i*PAGE_SIZE);
						to_virtual[pa / PAGE_SIZE] = 0;
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
f0109b2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109b30:	e9 9e 01 00 00       	jmp    f0109cd3 <krealloc+0x35f>
						unmap_frame(ptr_page_directory, (uint32)va_to_free + i*PAGE_SIZE);
					}
					ptr = va;
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
f0109b35:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109b38:	c1 e0 0c             	shl    $0xc,%eax
f0109b3b:	89 c2                	mov    %eax,%edx
f0109b3d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b40:	01 d0                	add    %edx,%eax
f0109b42:	89 45 ec             	mov    %eax,-0x14(%ebp)
				uint32 cnt = 0;
f0109b45:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				bool found_free_pages = 0;
f0109b4c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < (num_pages - num_old_pages))
f0109b53:	eb 33                	jmp    f0109b88 <krealloc+0x214>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
f0109b55:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f0109b5c:	0f 87 19 01 00 00    	ja     f0109c7b <krealloc+0x307>
f0109b62:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109b67:	83 ec 08             	sub    $0x8,%esp
f0109b6a:	ff 75 ec             	pushl  -0x14(%ebp)
f0109b6d:	50                   	push   %eax
f0109b6e:	e8 f3 f9 ff ff       	call   f0109566 <isPageAllocated>
f0109b73:	83 c4 10             	add    $0x10,%esp
f0109b76:	85 c0                	test   %eax,%eax
f0109b78:	0f 85 fd 00 00 00    	jne    f0109c7b <krealloc+0x307>
					j += (uint32)PAGE_SIZE;
f0109b7e:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
					cnt++;
f0109b85:	ff 45 e8             	incl   -0x18(%ebp)
				}
			}else{
				uint32 j = (uint32)va + (num_old_pages * PAGE_SIZE);
				uint32 cnt = 0;
				bool found_free_pages = 0;
				while(cnt < (num_pages - num_old_pages))
f0109b88:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b8b:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109b8e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109b91:	77 c2                	ja     f0109b55 <krealloc+0x1e1>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
f0109b93:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109b9a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0109ba1:	eb 5c                	jmp    f0109bff <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
f0109ba3:	83 ec 0c             	sub    $0xc,%esp
f0109ba6:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0109ba9:	50                   	push   %eax
f0109baa:	e8 03 e6 ff ff       	call   f01081b2 <allocate_frame>
f0109baf:	83 c4 10             	add    $0x10,%esp
f0109bb2:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
f0109bb5:	83 7d bc fc          	cmpl   $0xfffffffc,-0x44(%ebp)
f0109bb9:	74 2d                	je     f0109be8 <krealloc+0x274>
f0109bbb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109bbe:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109bc1:	01 d0                	add    %edx,%eax
f0109bc3:	c1 e0 0c             	shl    $0xc,%eax
f0109bc6:	89 c2                	mov    %eax,%edx
f0109bc8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bcb:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109bce:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f0109bd1:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0109bd6:	6a 02                	push   $0x2
f0109bd8:	51                   	push   %ecx
f0109bd9:	52                   	push   %edx
f0109bda:	50                   	push   %eax
f0109bdb:	e8 9f ea ff ff       	call   f010867f <map_frame>
f0109be0:	83 c4 10             	add    $0x10,%esp
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109be3:	ff 45 e0             	incl   -0x20(%ebp)
f0109be6:	eb 17                	jmp    f0109bff <krealloc+0x28b>
				{
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
f0109be8:	83 ec 04             	sub    $0x4,%esp
f0109beb:	68 ef 5c 12 f0       	push   $0xf0125cef
f0109bf0:	68 4c 01 00 00       	push   $0x14c
f0109bf5:	68 de 5c 12 f0       	push   $0xf0125cde
f0109bfa:	e8 3a 67 ff ff       	call   f0100339 <_panic>
					if(j >= (uint32)KERNEL_HEAP_MAX || isPageAllocated(ptr_page_directory, j)) goto sayed;
					j += (uint32)PAGE_SIZE;
					cnt++;
				}
				found_free_pages = 1;
				for (int k = 0; k < (num_pages - num_old_pages); k++)
f0109bff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109c02:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109c05:	89 c2                	mov    %eax,%edx
f0109c07:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109c0a:	39 c2                	cmp    %eax,%edx
f0109c0c:	77 95                	ja     f0109ba3 <krealloc+0x22f>
					struct FrameInfo *ptr_frame_info;
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
f0109c0e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c11:	c1 e8 0c             	shr    $0xc,%eax
f0109c14:	89 c2                	mov    %eax,%edx
f0109c16:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109c19:	89 04 95 e0 12 6e f0 	mov    %eax,-0xf91ed20(,%edx,4)
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109c20:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0109c27:	eb 43                	jmp    f0109c6c <krealloc+0x2f8>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
f0109c29:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0109c2c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109c2f:	01 d0                	add    %edx,%eax
f0109c31:	c1 e0 0c             	shl    $0xc,%eax
f0109c34:	89 c2                	mov    %eax,%edx
f0109c36:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c39:	01 d0                	add    %edx,%eax
f0109c3b:	83 ec 0c             	sub    $0xc,%esp
f0109c3e:	50                   	push   %eax
f0109c3f:	e8 a1 fc ff ff       	call   f01098e5 <kheap_physical_address>
f0109c44:	83 c4 10             	add    $0x10,%esp
f0109c47:	89 45 b8             	mov    %eax,-0x48(%ebp)
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
f0109c4a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109c4d:	c1 e8 0c             	shr    $0xc,%eax
f0109c50:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0109c53:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0109c56:	01 ca                	add    %ecx,%edx
f0109c58:	89 d1                	mov    %edx,%ecx
f0109c5a:	c1 e1 0c             	shl    $0xc,%ecx
f0109c5d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109c60:	01 ca                	add    %ecx,%edx
f0109c62:	89 14 85 e0 92 70 f0 	mov    %edx,-0xf8f6d20(,%eax,4)
					int ret = allocate_frame(&ptr_frame_info);
					if (ret != E_NO_MEM) map_frame(ptr_page_directory, ptr_frame_info, (uint32)va + (num_old_pages + k) * PAGE_SIZE, PERM_WRITEABLE);
					else panic("No Memory");
				}
				no_pages_alloc[(uint32)va / PAGE_SIZE] = num_pages;
				for(int i = 0; i < (num_pages - num_old_pages); i++){
f0109c69:	ff 45 dc             	incl   -0x24(%ebp)
f0109c6c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109c6f:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109c72:	89 c2                	mov    %eax,%edx
f0109c74:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109c77:	39 c2                	cmp    %eax,%edx
f0109c79:	77 ae                	ja     f0109c29 <krealloc+0x2b5>
					uint32 pa = kheap_physical_address((uint32)va + (num_old_pages + i) * PAGE_SIZE);
					to_virtual[pa / PAGE_SIZE] = (uint32)va + (num_old_pages + i) * PAGE_SIZE;
				}
				sayed:
					if(!found_free_pages){
f0109c7b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109c7f:	75 52                	jne    f0109cd3 <krealloc+0x35f>
						ptr = kmalloc(new_size);
f0109c81:	83 ec 0c             	sub    $0xc,%esp
f0109c84:	ff 75 0c             	pushl  0xc(%ebp)
f0109c87:	e8 13 f9 ff ff       	call   f010959f <kmalloc>
f0109c8c:	83 c4 10             	add    $0x10,%esp
f0109c8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
						if(ptr != NULL) memcpy(ptr, va, new_size);
f0109c92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109c96:	74 14                	je     f0109cac <krealloc+0x338>
f0109c98:	83 ec 04             	sub    $0x4,%esp
f0109c9b:	ff 75 0c             	pushl  0xc(%ebp)
f0109c9e:	ff 75 08             	pushl  0x8(%ebp)
f0109ca1:	ff 75 f4             	pushl  -0xc(%ebp)
f0109ca4:	e8 4b 62 01 00       	call   f011fef4 <memcpy>
f0109ca9:	83 c4 10             	add    $0x10,%esp
						kfree(va);
f0109cac:	83 ec 0c             	sub    $0xc,%esp
f0109caf:	ff 75 08             	pushl  0x8(%ebp)
f0109cb2:	e8 48 fb ff ff       	call   f01097ff <kfree>
f0109cb7:	83 c4 10             	add    $0x10,%esp
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109cba:	eb 17                	jmp    f0109cd3 <krealloc+0x35f>
						if(ptr != NULL) memcpy(ptr, va, new_size);
						kfree(va);
					}
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
f0109cbc:	83 ec 04             	sub    $0x4,%esp
f0109cbf:	68 24 5d 12 f0       	push   $0xf0125d24
f0109cc4:	68 5b 01 00 00       	push   $0x15b
f0109cc9:	68 de 5c 12 f0       	push   $0xf0125cde
f0109cce:	e8 66 66 ff ff       	call   f0100339 <_panic>
		kfree(va);
	}else{
		uint32 pageA_start = hard_limit + PAGE_SIZE;
		if((uint32)va < hard_limit){
			ptr = realloc_block_FF(va, new_size);
		} else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109cd3:	90                   	nop
			}
		} else{
			panic("krealloc: The virtual Address is invalid");
		}
	}
	return ptr;
f0109cd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109cd7:	c9                   	leave  
f0109cd8:	c3                   	ret    

f0109cd9 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109cd9:	55                   	push   %ebp
f0109cda:	89 e5                	mov    %esp,%ebp
f0109cdc:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109cdf:	83 ec 04             	sub    $0x4,%esp
f0109ce2:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109ce5:	50                   	push   %eax
f0109ce6:	ff 75 0c             	pushl  0xc(%ebp)
f0109ce9:	ff 75 08             	pushl  0x8(%ebp)
f0109cec:	e8 fe e6 ff ff       	call   f01083ef <get_page_table>
f0109cf1:	83 c4 10             	add    $0x10,%esp
f0109cf4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109cf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cfa:	85 c0                	test   %eax,%eax
f0109cfc:	74 64                	je     f0109d62 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109cfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d01:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d04:	c1 ea 0c             	shr    $0xc,%edx
f0109d07:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d0d:	c1 e2 02             	shl    $0x2,%edx
f0109d10:	01 c2                	add    %eax,%edx
f0109d12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d15:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109d18:	c1 e9 0c             	shr    $0xc,%ecx
f0109d1b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109d21:	c1 e1 02             	shl    $0x2,%ecx
f0109d24:	01 c8                	add    %ecx,%eax
f0109d26:	8b 00                	mov    (%eax),%eax
f0109d28:	0b 45 10             	or     0x10(%ebp),%eax
f0109d2b:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109d2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d30:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d33:	c1 ea 0c             	shr    $0xc,%edx
f0109d36:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d3c:	c1 e2 02             	shl    $0x2,%edx
f0109d3f:	01 d0                	add    %edx,%eax
f0109d41:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109d44:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109d47:	c1 e9 0c             	shr    $0xc,%ecx
f0109d4a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109d50:	c1 e1 02             	shl    $0x2,%ecx
f0109d53:	01 ca                	add    %ecx,%edx
f0109d55:	8b 12                	mov    (%edx),%edx
f0109d57:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109d5a:	f7 d1                	not    %ecx
f0109d5c:	21 ca                	and    %ecx,%edx
f0109d5e:	89 10                	mov    %edx,(%eax)
f0109d60:	eb 27                	jmp    f0109d89 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109d62:	83 ec 08             	sub    $0x8,%esp
f0109d65:	ff 75 0c             	pushl  0xc(%ebp)
f0109d68:	68 50 5d 12 f0       	push   $0xf0125d50
f0109d6d:	e8 19 72 ff ff       	call   f0100f8b <cprintf>
f0109d72:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109d75:	83 ec 04             	sub    $0x4,%esp
f0109d78:	68 78 5d 12 f0       	push   $0xf0125d78
f0109d7d:	6a 1c                	push   $0x1c
f0109d7f:	68 ec 5d 12 f0       	push   $0xf0125dec
f0109d84:	e8 b0 65 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109d89:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109d8c:	83 ec 08             	sub    $0x8,%esp
f0109d8f:	50                   	push   %eax
f0109d90:	6a 00                	push   $0x0
f0109d92:	e8 22 e0 ff ff       	call   f0107db9 <tlb_invalidate>
f0109d97:	83 c4 10             	add    $0x10,%esp
}
f0109d9a:	90                   	nop
f0109d9b:	c9                   	leave  
f0109d9c:	c3                   	ret    

f0109d9d <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f0109d9d:	55                   	push   %ebp
f0109d9e:	89 e5                	mov    %esp,%ebp
f0109da0:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109da3:	83 ec 04             	sub    $0x4,%esp
f0109da6:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109da9:	50                   	push   %eax
f0109daa:	ff 75 0c             	pushl  0xc(%ebp)
f0109dad:	ff 75 08             	pushl  0x8(%ebp)
f0109db0:	e8 3a e6 ff ff       	call   f01083ef <get_page_table>
f0109db5:	83 c4 10             	add    $0x10,%esp
f0109db8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0109dbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109dbe:	85 c0                	test   %eax,%eax
f0109dc0:	74 1d                	je     f0109ddf <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0109dc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109dc5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109dc8:	c1 ea 0c             	shr    $0xc,%edx
f0109dcb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109dd1:	c1 e2 02             	shl    $0x2,%edx
f0109dd4:	01 d0                	add    %edx,%eax
f0109dd6:	8b 00                	mov    (%eax),%eax
f0109dd8:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109ddd:	eb 05                	jmp    f0109de4 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0109ddf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0109de4:	c9                   	leave  
f0109de5:	c3                   	ret    

f0109de6 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0109de6:	55                   	push   %ebp
f0109de7:	89 e5                	mov    %esp,%ebp
f0109de9:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109dec:	83 ec 04             	sub    $0x4,%esp
f0109def:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109df2:	50                   	push   %eax
f0109df3:	ff 75 0c             	pushl  0xc(%ebp)
f0109df6:	ff 75 08             	pushl  0x8(%ebp)
f0109df9:	e8 f1 e5 ff ff       	call   f01083ef <get_page_table>
f0109dfe:	83 c4 10             	add    $0x10,%esp
f0109e01:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109e04:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e07:	85 c0                	test   %eax,%eax
f0109e09:	74 46                	je     f0109e51 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0109e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e0e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e11:	c1 ea 0c             	shr    $0xc,%edx
f0109e14:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109e1a:	c1 e2 02             	shl    $0x2,%edx
f0109e1d:	01 d0                	add    %edx,%eax
f0109e1f:	8b 00                	mov    (%eax),%eax
f0109e21:	83 ec 04             	sub    $0x4,%esp
f0109e24:	50                   	push   %eax
f0109e25:	ff 75 0c             	pushl  0xc(%ebp)
f0109e28:	68 08 5e 12 f0       	push   $0xf0125e08
f0109e2d:	e8 59 71 ff ff       	call   f0100f8b <cprintf>
f0109e32:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0109e35:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e38:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e3b:	c1 ea 0c             	shr    $0xc,%edx
f0109e3e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109e44:	c1 e2 02             	shl    $0x2,%edx
f0109e47:	01 d0                	add    %edx,%eax
f0109e49:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109e4f:	eb 14                	jmp    f0109e65 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109e51:	83 ec 04             	sub    $0x4,%esp
f0109e54:	68 30 5e 12 f0       	push   $0xf0125e30
f0109e59:	6a 47                	push   $0x47
f0109e5b:	68 ec 5d 12 f0       	push   $0xf0125dec
f0109e60:	e8 d4 64 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109e65:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e68:	83 ec 08             	sub    $0x8,%esp
f0109e6b:	50                   	push   %eax
f0109e6c:	6a 00                	push   $0x0
f0109e6e:	e8 46 df ff ff       	call   f0107db9 <tlb_invalidate>
f0109e73:	83 c4 10             	add    $0x10,%esp
}
f0109e76:	90                   	nop
f0109e77:	c9                   	leave  
f0109e78:	c3                   	ret    

f0109e79 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0109e79:	55                   	push   %ebp
f0109e7a:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109e7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e7f:	c1 e8 16             	shr    $0x16,%eax
f0109e82:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e89:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e8c:	01 d0                	add    %edx,%eax
f0109e8e:	8b 00                	mov    (%eax),%eax
f0109e90:	83 e0 20             	and    $0x20,%eax
f0109e93:	85 c0                	test   %eax,%eax
f0109e95:	0f 95 c0             	setne  %al
f0109e98:	0f b6 c0             	movzbl %al,%eax
}
f0109e9b:	5d                   	pop    %ebp
f0109e9c:	c3                   	ret    

f0109e9d <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0109e9d:	55                   	push   %ebp
f0109e9e:	89 e5                	mov    %esp,%ebp
f0109ea0:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0109ea3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ea6:	c1 e8 16             	shr    $0x16,%eax
f0109ea9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109eb0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109eb3:	01 d0                	add    %edx,%eax
f0109eb5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109eb8:	c1 ea 16             	shr    $0x16,%edx
f0109ebb:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109ec2:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ec5:	01 ca                	add    %ecx,%edx
f0109ec7:	8b 12                	mov    (%edx),%edx
f0109ec9:	83 e2 df             	and    $0xffffffdf,%edx
f0109ecc:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109ece:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ed1:	83 ec 08             	sub    $0x8,%esp
f0109ed4:	50                   	push   %eax
f0109ed5:	6a 00                	push   $0x0
f0109ed7:	e8 dd de ff ff       	call   f0107db9 <tlb_invalidate>
f0109edc:	83 c4 10             	add    $0x10,%esp
}
f0109edf:	90                   	nop
f0109ee0:	c9                   	leave  
f0109ee1:	c3                   	ret    

f0109ee2 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0109ee2:	55                   	push   %ebp
f0109ee3:	89 e5                	mov    %esp,%ebp
f0109ee5:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0109ee8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109eeb:	c1 e8 16             	shr    $0x16,%eax
f0109eee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109ef5:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ef8:	01 d0                	add    %edx,%eax
f0109efa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109f00:	0f 20 d8             	mov    %cr3,%eax
f0109f03:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109f06:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109f09:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109f0c:	90                   	nop
f0109f0d:	c9                   	leave  
f0109f0e:	c3                   	ret    

f0109f0f <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109f0f:	55                   	push   %ebp
f0109f10:	89 e5                	mov    %esp,%ebp
f0109f12:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f0109f15:	83 ec 0c             	sub    $0xc,%esp
f0109f18:	6a 18                	push   $0x18
f0109f1a:	e8 80 f6 ff ff       	call   f010959f <kmalloc>
f0109f1f:	83 c4 10             	add    $0x10,%esp
f0109f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f0109f25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109f29:	75 14                	jne    f0109f3f <env_page_ws_list_create_element+0x30>
f0109f2b:	83 ec 04             	sub    $0x4,%esp
f0109f2e:	68 a8 5e 12 f0       	push   $0xf0125ea8
f0109f33:	6a 19                	push   $0x19
f0109f35:	68 d8 5e 12 f0       	push   $0xf0125ed8
f0109f3a:	e8 fa 63 ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f0109f3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f42:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109f45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f48:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109f4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109f4e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f53:	89 c2                	mov    %eax,%edx
f0109f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f58:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f0109f5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f5d:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f0109f61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f64:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f0109f6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f6e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f0109f75:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f0109f78:	c9                   	leave  
f0109f79:	c3                   	ret    

f0109f7a <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109f7a:	55                   	push   %ebp
f0109f7b:	89 e5                	mov    %esp,%ebp
f0109f7d:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109f80:	83 ec 0c             	sub    $0xc,%esp
f0109f83:	6a 02                	push   $0x2
f0109f85:	e8 4b 57 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f0109f8a:	83 c4 10             	add    $0x10,%esp
f0109f8d:	85 c0                	test   %eax,%eax
f0109f8f:	0f 84 e5 03 00 00    	je     f010a37a <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109f95:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109f9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109fa3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fa6:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109fac:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109faf:	e9 3b 02 00 00       	jmp    f010a1ef <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109fb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fb7:	8b 00                	mov    (%eax),%eax
f0109fb9:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109fbc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109fbf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109fc4:	89 c2                	mov    %eax,%edx
f0109fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109fc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109fcc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109fcf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109fd4:	39 c2                	cmp    %eax,%edx
f0109fd6:	0f 85 07 02 00 00    	jne    f010a1e3 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109fdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fdf:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109fe5:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109fe8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109feb:	8b 10                	mov    (%eax),%edx
f0109fed:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ff0:	8b 40 64             	mov    0x64(%eax),%eax
f0109ff3:	83 ec 08             	sub    $0x8,%esp
f0109ff6:	52                   	push   %edx
f0109ff7:	50                   	push   %eax
f0109ff8:	e8 e2 e7 ff ff       	call   f01087df <unmap_frame>
f0109ffd:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a000:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a004:	75 14                	jne    f010a01a <env_page_ws_invalidate+0xa0>
f010a006:	83 ec 04             	sub    $0x4,%esp
f010a009:	68 f7 5e 12 f0       	push   $0xf0125ef7
f010a00e:	6a 2f                	push   $0x2f
f010a010:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010a015:	e8 1f 63 ff ff       	call   f0100339 <_panic>
f010a01a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a01d:	8b 40 10             	mov    0x10(%eax),%eax
f010a020:	85 c0                	test   %eax,%eax
f010a022:	74 11                	je     f010a035 <env_page_ws_invalidate+0xbb>
f010a024:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a027:	8b 40 10             	mov    0x10(%eax),%eax
f010a02a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a02d:	8b 52 14             	mov    0x14(%edx),%edx
f010a030:	89 50 14             	mov    %edx,0x14(%eax)
f010a033:	eb 0f                	jmp    f010a044 <env_page_ws_invalidate+0xca>
f010a035:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a038:	8b 50 14             	mov    0x14(%eax),%edx
f010a03b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a03e:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a044:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a047:	8b 40 14             	mov    0x14(%eax),%eax
f010a04a:	85 c0                	test   %eax,%eax
f010a04c:	74 11                	je     f010a05f <env_page_ws_invalidate+0xe5>
f010a04e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a051:	8b 40 14             	mov    0x14(%eax),%eax
f010a054:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a057:	8b 52 10             	mov    0x10(%edx),%edx
f010a05a:	89 50 10             	mov    %edx,0x10(%eax)
f010a05d:	eb 0f                	jmp    f010a06e <env_page_ws_invalidate+0xf4>
f010a05f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a062:	8b 50 10             	mov    0x10(%eax),%edx
f010a065:	8b 45 08             	mov    0x8(%ebp),%eax
f010a068:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a06e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a071:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a078:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a07b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a082:	8b 45 08             	mov    0x8(%ebp),%eax
f010a085:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a08b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a08e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a091:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a097:	83 ec 0c             	sub    $0xc,%esp
f010a09a:	ff 75 f0             	pushl  -0x10(%ebp)
f010a09d:	e8 5d f7 ff ff       	call   f01097ff <kfree>
f010a0a2:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a0a5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0a9:	0f 84 2b 01 00 00    	je     f010a1da <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a0af:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0b3:	75 14                	jne    f010a0c9 <env_page_ws_invalidate+0x14f>
f010a0b5:	83 ec 04             	sub    $0x4,%esp
f010a0b8:	68 f7 5e 12 f0       	push   $0xf0125ef7
f010a0bd:	6a 35                	push   $0x35
f010a0bf:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010a0c4:	e8 70 62 ff ff       	call   f0100339 <_panic>
f010a0c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0cc:	8b 40 10             	mov    0x10(%eax),%eax
f010a0cf:	85 c0                	test   %eax,%eax
f010a0d1:	74 11                	je     f010a0e4 <env_page_ws_invalidate+0x16a>
f010a0d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0d6:	8b 40 10             	mov    0x10(%eax),%eax
f010a0d9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a0dc:	8b 52 14             	mov    0x14(%edx),%edx
f010a0df:	89 50 14             	mov    %edx,0x14(%eax)
f010a0e2:	eb 0f                	jmp    f010a0f3 <env_page_ws_invalidate+0x179>
f010a0e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0e7:	8b 50 14             	mov    0x14(%eax),%edx
f010a0ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0ed:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a0f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0f6:	8b 40 14             	mov    0x14(%eax),%eax
f010a0f9:	85 c0                	test   %eax,%eax
f010a0fb:	74 11                	je     f010a10e <env_page_ws_invalidate+0x194>
f010a0fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a100:	8b 40 14             	mov    0x14(%eax),%eax
f010a103:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a106:	8b 52 10             	mov    0x10(%edx),%edx
f010a109:	89 50 10             	mov    %edx,0x10(%eax)
f010a10c:	eb 0f                	jmp    f010a11d <env_page_ws_invalidate+0x1a3>
f010a10e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a111:	8b 50 10             	mov    0x10(%eax),%edx
f010a114:	8b 45 08             	mov    0x8(%ebp),%eax
f010a117:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a11d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a120:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a127:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a12a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a131:	8b 45 08             	mov    0x8(%ebp),%eax
f010a134:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a13a:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a13d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a140:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a146:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a14a:	75 14                	jne    f010a160 <env_page_ws_invalidate+0x1e6>
f010a14c:	83 ec 04             	sub    $0x4,%esp
f010a14f:	68 18 5f 12 f0       	push   $0xf0125f18
f010a154:	6a 36                	push   $0x36
f010a156:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010a15b:	e8 d9 61 ff ff       	call   f0100339 <_panic>
f010a160:	8b 45 08             	mov    0x8(%ebp),%eax
f010a163:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010a169:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a16c:	89 50 14             	mov    %edx,0x14(%eax)
f010a16f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a172:	8b 40 14             	mov    0x14(%eax),%eax
f010a175:	85 c0                	test   %eax,%eax
f010a177:	74 11                	je     f010a18a <env_page_ws_invalidate+0x210>
f010a179:	8b 45 08             	mov    0x8(%ebp),%eax
f010a17c:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a182:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a185:	89 50 10             	mov    %edx,0x10(%eax)
f010a188:	eb 0c                	jmp    f010a196 <env_page_ws_invalidate+0x21c>
f010a18a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a18d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a190:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010a196:	8b 45 08             	mov    0x8(%ebp),%eax
f010a199:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a19c:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a1a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1a5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a1ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1af:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a1b5:	8d 50 01             	lea    0x1(%eax),%edx
f010a1b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1bb:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a1c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1c4:	8b 10                	mov    (%eax),%edx
f010a1c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c9:	8b 40 64             	mov    0x64(%eax),%eax
f010a1cc:	6a 00                	push   $0x0
f010a1ce:	6a 01                	push   $0x1
f010a1d0:	52                   	push   %edx
f010a1d1:	50                   	push   %eax
f010a1d2:	e8 02 fb ff ff       	call   f0109cd9 <pt_set_page_permissions>
f010a1d7:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a1da:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a1e1:	eb 43                	jmp    f010a226 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a1e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1e6:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a1ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a1ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a1f3:	74 08                	je     f010a1fd <env_page_ws_invalidate+0x283>
f010a1f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a1f8:	8b 40 10             	mov    0x10(%eax),%eax
f010a1fb:	eb 05                	jmp    f010a202 <env_page_ws_invalidate+0x288>
f010a1fd:	b8 00 00 00 00       	mov    $0x0,%eax
f010a202:	8b 55 08             	mov    0x8(%ebp),%edx
f010a205:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a20b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a20e:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a214:	85 c0                	test   %eax,%eax
f010a216:	0f 85 98 fd ff ff    	jne    f0109fb4 <env_page_ws_invalidate+0x3a>
f010a21c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a220:	0f 85 8e fd ff ff    	jne    f0109fb4 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a226:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a22a:	0f 85 a4 02 00 00    	jne    f010a4d4 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a230:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a237:	8b 45 08             	mov    0x8(%ebp),%eax
f010a23a:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a240:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a243:	e9 f6 00 00 00       	jmp    f010a33e <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a248:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a24b:	8b 00                	mov    (%eax),%eax
f010a24d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a250:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a253:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a258:	89 c2                	mov    %eax,%edx
f010a25a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a25d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a260:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a263:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a268:	39 c2                	cmp    %eax,%edx
f010a26a:	0f 85 c2 00 00 00    	jne    f010a332 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a270:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a273:	8b 10                	mov    (%eax),%edx
f010a275:	8b 45 08             	mov    0x8(%ebp),%eax
f010a278:	8b 40 64             	mov    0x64(%eax),%eax
f010a27b:	83 ec 08             	sub    $0x8,%esp
f010a27e:	52                   	push   %edx
f010a27f:	50                   	push   %eax
f010a280:	e8 5a e5 ff ff       	call   f01087df <unmap_frame>
f010a285:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a288:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a28c:	75 14                	jne    f010a2a2 <env_page_ws_invalidate+0x328>
f010a28e:	83 ec 04             	sub    $0x4,%esp
f010a291:	68 f7 5e 12 f0       	push   $0xf0125ef7
f010a296:	6a 46                	push   $0x46
f010a298:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010a29d:	e8 97 60 ff ff       	call   f0100339 <_panic>
f010a2a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2a5:	8b 40 10             	mov    0x10(%eax),%eax
f010a2a8:	85 c0                	test   %eax,%eax
f010a2aa:	74 11                	je     f010a2bd <env_page_ws_invalidate+0x343>
f010a2ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2af:	8b 40 10             	mov    0x10(%eax),%eax
f010a2b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2b5:	8b 52 14             	mov    0x14(%edx),%edx
f010a2b8:	89 50 14             	mov    %edx,0x14(%eax)
f010a2bb:	eb 0f                	jmp    f010a2cc <env_page_ws_invalidate+0x352>
f010a2bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2c0:	8b 50 14             	mov    0x14(%eax),%edx
f010a2c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2c6:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a2cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2cf:	8b 40 14             	mov    0x14(%eax),%eax
f010a2d2:	85 c0                	test   %eax,%eax
f010a2d4:	74 11                	je     f010a2e7 <env_page_ws_invalidate+0x36d>
f010a2d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2d9:	8b 40 14             	mov    0x14(%eax),%eax
f010a2dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2df:	8b 52 10             	mov    0x10(%edx),%edx
f010a2e2:	89 50 10             	mov    %edx,0x10(%eax)
f010a2e5:	eb 0f                	jmp    f010a2f6 <env_page_ws_invalidate+0x37c>
f010a2e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2ea:	8b 50 10             	mov    0x10(%eax),%edx
f010a2ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2f0:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010a2f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2f9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a300:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a303:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a30a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a30d:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a313:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a316:	8b 45 08             	mov    0x8(%ebp),%eax
f010a319:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f010a31f:	83 ec 0c             	sub    $0xc,%esp
f010a322:	ff 75 f0             	pushl  -0x10(%ebp)
f010a325:	e8 d5 f4 ff ff       	call   f01097ff <kfree>
f010a32a:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a32d:	e9 a2 01 00 00       	jmp    f010a4d4 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a332:	8b 45 08             	mov    0x8(%ebp),%eax
f010a335:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a33b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a33e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a342:	74 08                	je     f010a34c <env_page_ws_invalidate+0x3d2>
f010a344:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a347:	8b 40 10             	mov    0x10(%eax),%eax
f010a34a:	eb 05                	jmp    f010a351 <env_page_ws_invalidate+0x3d7>
f010a34c:	b8 00 00 00 00       	mov    $0x0,%eax
f010a351:	8b 55 08             	mov    0x8(%ebp),%edx
f010a354:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a35a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a35d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a363:	85 c0                	test   %eax,%eax
f010a365:	0f 85 dd fe ff ff    	jne    f010a248 <env_page_ws_invalidate+0x2ce>
f010a36b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a36f:	0f 85 d3 fe ff ff    	jne    f010a248 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a375:	e9 5a 01 00 00       	jmp    f010a4d4 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a37a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a37d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a383:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a386:	e9 10 01 00 00       	jmp    f010a49b <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a38b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a38e:	8b 00                	mov    (%eax),%eax
f010a390:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a393:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a396:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a39b:	89 c2                	mov    %eax,%edx
f010a39d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a3a0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a3a3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a3a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3ab:	39 c2                	cmp    %eax,%edx
f010a3ad:	0f 85 dc 00 00 00    	jne    f010a48f <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a3b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3b6:	8b 10                	mov    (%eax),%edx
f010a3b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3bb:	8b 40 64             	mov    0x64(%eax),%eax
f010a3be:	83 ec 08             	sub    $0x8,%esp
f010a3c1:	52                   	push   %edx
f010a3c2:	50                   	push   %eax
f010a3c3:	e8 17 e4 ff ff       	call   f01087df <unmap_frame>
f010a3c8:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a3cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3ce:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a3d4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a3d7:	75 0f                	jne    f010a3e8 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a3d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3dc:	8b 50 10             	mov    0x10(%eax),%edx
f010a3df:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3e2:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a3e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a3ec:	75 14                	jne    f010a402 <env_page_ws_invalidate+0x488>
f010a3ee:	83 ec 04             	sub    $0x4,%esp
f010a3f1:	68 f7 5e 12 f0       	push   $0xf0125ef7
f010a3f6:	6a 5c                	push   $0x5c
f010a3f8:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010a3fd:	e8 37 5f ff ff       	call   f0100339 <_panic>
f010a402:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a405:	8b 40 10             	mov    0x10(%eax),%eax
f010a408:	85 c0                	test   %eax,%eax
f010a40a:	74 11                	je     f010a41d <env_page_ws_invalidate+0x4a3>
f010a40c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a40f:	8b 40 10             	mov    0x10(%eax),%eax
f010a412:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a415:	8b 52 14             	mov    0x14(%edx),%edx
f010a418:	89 50 14             	mov    %edx,0x14(%eax)
f010a41b:	eb 0f                	jmp    f010a42c <env_page_ws_invalidate+0x4b2>
f010a41d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a420:	8b 50 14             	mov    0x14(%eax),%edx
f010a423:	8b 45 08             	mov    0x8(%ebp),%eax
f010a426:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a42c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a42f:	8b 40 14             	mov    0x14(%eax),%eax
f010a432:	85 c0                	test   %eax,%eax
f010a434:	74 11                	je     f010a447 <env_page_ws_invalidate+0x4cd>
f010a436:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a439:	8b 40 14             	mov    0x14(%eax),%eax
f010a43c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a43f:	8b 52 10             	mov    0x10(%edx),%edx
f010a442:	89 50 10             	mov    %edx,0x10(%eax)
f010a445:	eb 0f                	jmp    f010a456 <env_page_ws_invalidate+0x4dc>
f010a447:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a44a:	8b 50 10             	mov    0x10(%eax),%edx
f010a44d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a450:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a456:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a459:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a460:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a463:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a46a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a46d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a473:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a476:	8b 45 08             	mov    0x8(%ebp),%eax
f010a479:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a47f:	83 ec 0c             	sub    $0xc,%esp
f010a482:	ff 75 ec             	pushl  -0x14(%ebp)
f010a485:	e8 75 f3 ff ff       	call   f01097ff <kfree>
f010a48a:	83 c4 10             	add    $0x10,%esp

				break;
f010a48d:	eb 45                	jmp    f010a4d4 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a48f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a492:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a498:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a49b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a49f:	74 08                	je     f010a4a9 <env_page_ws_invalidate+0x52f>
f010a4a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a4a4:	8b 40 10             	mov    0x10(%eax),%eax
f010a4a7:	eb 05                	jmp    f010a4ae <env_page_ws_invalidate+0x534>
f010a4a9:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4ae:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4b1:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a4b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4ba:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a4c0:	85 c0                	test   %eax,%eax
f010a4c2:	0f 85 c3 fe ff ff    	jne    f010a38b <env_page_ws_invalidate+0x411>
f010a4c8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a4cc:	0f 85 b9 fe ff ff    	jne    f010a38b <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a4d2:	eb 00                	jmp    f010a4d4 <env_page_ws_invalidate+0x55a>
f010a4d4:	90                   	nop
f010a4d5:	c9                   	leave  
f010a4d6:	c3                   	ret    

f010a4d7 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a4d7:	55                   	push   %ebp
f010a4d8:	89 e5                	mov    %esp,%ebp
f010a4da:	53                   	push   %ebx
f010a4db:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a4de:	83 ec 0c             	sub    $0xc,%esp
f010a4e1:	6a 02                	push   $0x2
f010a4e3:	e8 ed 51 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010a4e8:	83 c4 10             	add    $0x10,%esp
f010a4eb:	85 c0                	test   %eax,%eax
f010a4ed:	0f 84 fe 00 00 00    	je     f010a5f1 <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a4f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a4fa:	83 ec 0c             	sub    $0xc,%esp
f010a4fd:	68 3b 5f 12 f0       	push   $0xf0125f3b
f010a502:	e8 84 6a ff ff       	call   f0100f8b <cprintf>
f010a507:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a50a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a50d:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010a513:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a516:	eb 2c                	jmp    f010a544 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a518:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a51b:	8b 10                	mov    (%eax),%edx
f010a51d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a520:	8d 48 01             	lea    0x1(%eax),%ecx
f010a523:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a526:	83 ec 04             	sub    $0x4,%esp
f010a529:	52                   	push   %edx
f010a52a:	50                   	push   %eax
f010a52b:	68 55 5f 12 f0       	push   $0xf0125f55
f010a530:	e8 56 6a ff ff       	call   f0100f8b <cprintf>
f010a535:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a538:	8b 45 08             	mov    0x8(%ebp),%eax
f010a53b:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a541:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a544:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a548:	74 08                	je     f010a552 <env_page_ws_print+0x7b>
f010a54a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a54d:	8b 40 10             	mov    0x10(%eax),%eax
f010a550:	eb 05                	jmp    f010a557 <env_page_ws_print+0x80>
f010a552:	b8 00 00 00 00       	mov    $0x0,%eax
f010a557:	8b 55 08             	mov    0x8(%ebp),%edx
f010a55a:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f010a560:	8b 45 08             	mov    0x8(%ebp),%eax
f010a563:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a569:	85 c0                	test   %eax,%eax
f010a56b:	75 ab                	jne    f010a518 <env_page_ws_print+0x41>
f010a56d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a571:	75 a5                	jne    f010a518 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a573:	83 ec 0c             	sub    $0xc,%esp
f010a576:	68 5d 5f 12 f0       	push   $0xf0125f5d
f010a57b:	e8 0b 6a ff ff       	call   f0100f8b <cprintf>
f010a580:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a583:	8b 45 08             	mov    0x8(%ebp),%eax
f010a586:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a58c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a58f:	eb 2c                	jmp    f010a5bd <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a591:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a594:	8b 10                	mov    (%eax),%edx
f010a596:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a599:	8d 48 01             	lea    0x1(%eax),%ecx
f010a59c:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a59f:	83 ec 04             	sub    $0x4,%esp
f010a5a2:	52                   	push   %edx
f010a5a3:	50                   	push   %eax
f010a5a4:	68 55 5f 12 f0       	push   $0xf0125f55
f010a5a9:	e8 dd 69 ff ff       	call   f0100f8b <cprintf>
f010a5ae:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a5b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5b4:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a5ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a5bd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a5c1:	74 08                	je     f010a5cb <env_page_ws_print+0xf4>
f010a5c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5c6:	8b 40 10             	mov    0x10(%eax),%eax
f010a5c9:	eb 05                	jmp    f010a5d0 <env_page_ws_print+0xf9>
f010a5cb:	b8 00 00 00 00       	mov    $0x0,%eax
f010a5d0:	8b 55 08             	mov    0x8(%ebp),%edx
f010a5d3:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f010a5d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5dc:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a5e2:	85 c0                	test   %eax,%eax
f010a5e4:	75 ab                	jne    f010a591 <env_page_ws_print+0xba>
f010a5e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a5ea:	75 a5                	jne    f010a591 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a5ec:	e9 5a 01 00 00       	jmp    f010a74b <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a5f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a5f8:	83 ec 0c             	sub    $0xc,%esp
f010a5fb:	68 78 5f 12 f0       	push   $0xf0125f78
f010a600:	e8 86 69 ff ff       	call   f0100f8b <cprintf>
f010a605:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a608:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a60f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a612:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a618:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a61b:	e9 d1 00 00 00       	jmp    f010a6f1 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a620:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a623:	8b 00                	mov    (%eax),%eax
f010a625:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a628:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a62b:	8b 40 08             	mov    0x8(%eax),%eax
f010a62e:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a631:	8b 45 08             	mov    0x8(%ebp),%eax
f010a634:	8b 40 64             	mov    0x64(%eax),%eax
f010a637:	83 ec 08             	sub    $0x8,%esp
f010a63a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a63d:	50                   	push   %eax
f010a63e:	e8 5a f7 ff ff       	call   f0109d9d <pt_get_page_permissions>
f010a643:	83 c4 10             	add    $0x10,%esp
f010a646:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a649:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a64c:	83 e0 40             	and    $0x40,%eax
f010a64f:	85 c0                	test   %eax,%eax
f010a651:	0f 95 c0             	setne  %al
f010a654:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a657:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a65a:	83 e0 20             	and    $0x20,%eax
f010a65d:	85 c0                	test   %eax,%eax
f010a65f:	0f 95 c0             	setne  %al
f010a662:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a665:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a668:	25 00 02 00 00       	and    $0x200,%eax
f010a66d:	85 c0                	test   %eax,%eax
f010a66f:	0f 95 c0             	setne  %al
f010a672:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a675:	83 ec 04             	sub    $0x4,%esp
f010a678:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a67b:	ff 75 ec             	pushl  -0x14(%ebp)
f010a67e:	68 82 5f 12 f0       	push   $0xf0125f82
f010a683:	e8 03 69 ff ff       	call   f0100f8b <cprintf>
f010a688:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a68b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a68e:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a691:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a695:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a699:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a69d:	83 ec 08             	sub    $0x8,%esp
f010a6a0:	53                   	push   %ebx
f010a6a1:	ff 75 e0             	pushl  -0x20(%ebp)
f010a6a4:	51                   	push   %ecx
f010a6a5:	52                   	push   %edx
f010a6a6:	50                   	push   %eax
f010a6a7:	68 8c 5f 12 f0       	push   $0xf0125f8c
f010a6ac:	e8 da 68 ff ff       	call   f0100f8b <cprintf>
f010a6b1:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a6b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6b7:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a6bd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a6c0:	75 10                	jne    f010a6d2 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a6c2:	83 ec 0c             	sub    $0xc,%esp
f010a6c5:	68 d3 5f 12 f0       	push   $0xf0125fd3
f010a6ca:	e8 bc 68 ff ff       	call   f0100f8b <cprintf>
f010a6cf:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a6d2:	83 ec 0c             	sub    $0xc,%esp
f010a6d5:	68 d8 5f 12 f0       	push   $0xf0125fd8
f010a6da:	e8 ac 68 ff ff       	call   f0100f8b <cprintf>
f010a6df:	83 c4 10             	add    $0x10,%esp
			i++;
f010a6e2:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a6e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6e8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a6ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a6f1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a6f5:	74 08                	je     f010a6ff <env_page_ws_print+0x228>
f010a6f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a6fa:	8b 40 10             	mov    0x10(%eax),%eax
f010a6fd:	eb 05                	jmp    f010a704 <env_page_ws_print+0x22d>
f010a6ff:	b8 00 00 00 00       	mov    $0x0,%eax
f010a704:	8b 55 08             	mov    0x8(%ebp),%edx
f010a707:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a70d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a710:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a716:	85 c0                	test   %eax,%eax
f010a718:	0f 85 02 ff ff ff    	jne    f010a620 <env_page_ws_print+0x149>
f010a71e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a722:	0f 85 f8 fe ff ff    	jne    f010a620 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a728:	eb 13                	jmp    f010a73d <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a72a:	83 ec 0c             	sub    $0xc,%esp
f010a72d:	68 da 5f 12 f0       	push   $0xf0125fda
f010a732:	e8 54 68 ff ff       	call   f0100f8b <cprintf>
f010a737:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a73a:	ff 45 ec             	incl   -0x14(%ebp)
f010a73d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a740:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a746:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a749:	77 df                	ja     f010a72a <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a74b:	90                   	nop
f010a74c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a74f:	c9                   	leave  
f010a750:	c3                   	ret    

f010a751 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a751:	55                   	push   %ebp
f010a752:	89 e5                	mov    %esp,%ebp
f010a754:	53                   	push   %ebx
f010a755:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a758:	83 ec 0c             	sub    $0xc,%esp
f010a75b:	68 ec 5f 12 f0       	push   $0xf0125fec
f010a760:	e8 26 68 ff ff       	call   f0100f8b <cprintf>
f010a765:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a768:	83 ec 0c             	sub    $0xc,%esp
f010a76b:	68 21 60 12 f0       	push   $0xf0126021
f010a770:	e8 16 68 ff ff       	call   f0100f8b <cprintf>
f010a775:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a778:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a77f:	e9 16 01 00 00       	jmp    f010a89a <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a784:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a787:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a78a:	89 d0                	mov    %edx,%eax
f010a78c:	01 c0                	add    %eax,%eax
f010a78e:	01 d0                	add    %edx,%eax
f010a790:	c1 e0 03             	shl    $0x3,%eax
f010a793:	01 c8                	add    %ecx,%eax
f010a795:	05 b0 00 00 00       	add    $0xb0,%eax
f010a79a:	8a 00                	mov    (%eax),%al
f010a79c:	84 c0                	test   %al,%al
f010a79e:	74 43                	je     f010a7e3 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a7a0:	83 ec 0c             	sub    $0xc,%esp
f010a7a3:	68 2c 60 12 f0       	push   $0xf012602c
f010a7a8:	e8 de 67 ff ff       	call   f0100f8b <cprintf>
f010a7ad:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a7b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7b3:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a7b9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a7bc:	75 10                	jne    f010a7ce <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a7be:	83 ec 0c             	sub    $0xc,%esp
f010a7c1:	68 3b 60 12 f0       	push   $0xf012603b
f010a7c6:	e8 c0 67 ff ff       	call   f0100f8b <cprintf>
f010a7cb:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a7ce:	83 ec 0c             	sub    $0xc,%esp
f010a7d1:	68 d8 5f 12 f0       	push   $0xf0125fd8
f010a7d6:	e8 b0 67 ff ff       	call   f0100f8b <cprintf>
f010a7db:	83 c4 10             	add    $0x10,%esp
			continue;
f010a7de:	e9 b4 00 00 00       	jmp    f010a897 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a7e3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7e9:	89 d0                	mov    %edx,%eax
f010a7eb:	01 c0                	add    %eax,%eax
f010a7ed:	01 d0                	add    %edx,%eax
f010a7ef:	c1 e0 03             	shl    $0x3,%eax
f010a7f2:	01 c8                	add    %ecx,%eax
f010a7f4:	05 ac 00 00 00       	add    $0xac,%eax
f010a7f9:	8b 00                	mov    (%eax),%eax
f010a7fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a7fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a801:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a804:	89 d0                	mov    %edx,%eax
f010a806:	01 c0                	add    %eax,%eax
f010a808:	01 d0                	add    %edx,%eax
f010a80a:	c1 e0 03             	shl    $0x3,%eax
f010a80d:	01 c8                	add    %ecx,%eax
f010a80f:	05 ac 00 00 00       	add    $0xac,%eax
f010a814:	8b 00                	mov    (%eax),%eax
f010a816:	83 ec 04             	sub    $0x4,%esp
f010a819:	50                   	push   %eax
f010a81a:	ff 75 f4             	pushl  -0xc(%ebp)
f010a81d:	68 41 60 12 f0       	push   $0xf0126041
f010a822:	e8 64 67 ff ff       	call   f0100f8b <cprintf>
f010a827:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a82a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a82d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a830:	89 d0                	mov    %edx,%eax
f010a832:	01 c0                	add    %eax,%eax
f010a834:	01 d0                	add    %edx,%eax
f010a836:	c1 e0 03             	shl    $0x3,%eax
f010a839:	01 c8                	add    %ecx,%eax
f010a83b:	05 b4 00 00 00       	add    $0xb4,%eax
f010a840:	8b 18                	mov    (%eax),%ebx
f010a842:	8b 45 08             	mov    0x8(%ebp),%eax
f010a845:	8b 40 64             	mov    0x64(%eax),%eax
f010a848:	83 ec 08             	sub    $0x8,%esp
f010a84b:	ff 75 f0             	pushl  -0x10(%ebp)
f010a84e:	50                   	push   %eax
f010a84f:	e8 25 f6 ff ff       	call   f0109e79 <pd_is_table_used>
f010a854:	83 c4 10             	add    $0x10,%esp
f010a857:	83 ec 04             	sub    $0x4,%esp
f010a85a:	53                   	push   %ebx
f010a85b:	50                   	push   %eax
f010a85c:	68 58 60 12 f0       	push   $0xf0126058
f010a861:	e8 25 67 ff ff       	call   f0100f8b <cprintf>
f010a866:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a869:	8b 45 08             	mov    0x8(%ebp),%eax
f010a86c:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a872:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a875:	75 10                	jne    f010a887 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a877:	83 ec 0c             	sub    $0xc,%esp
f010a87a:	68 d3 5f 12 f0       	push   $0xf0125fd3
f010a87f:	e8 07 67 ff ff       	call   f0100f8b <cprintf>
f010a884:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a887:	83 ec 0c             	sub    $0xc,%esp
f010a88a:	68 d8 5f 12 f0       	push   $0xf0125fd8
f010a88f:	e8 f7 66 ff ff       	call   f0100f8b <cprintf>
f010a894:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a897:	ff 45 f4             	incl   -0xc(%ebp)
f010a89a:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a89e:	0f 86 e0 fe ff ff    	jbe    f010a784 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a8a4:	90                   	nop
f010a8a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a8a8:	c9                   	leave  
f010a8a9:	c3                   	ret    

f010a8aa <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a8aa:	55                   	push   %ebp
f010a8ab:	89 e5                	mov    %esp,%ebp
f010a8ad:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a8b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a8b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a8be:	eb 22                	jmp    f010a8e2 <env_table_ws_get_size+0x38>
f010a8c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8c3:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a8c6:	89 d0                	mov    %edx,%eax
f010a8c8:	01 c0                	add    %eax,%eax
f010a8ca:	01 d0                	add    %edx,%eax
f010a8cc:	c1 e0 03             	shl    $0x3,%eax
f010a8cf:	01 c8                	add    %ecx,%eax
f010a8d1:	05 b0 00 00 00       	add    $0xb0,%eax
f010a8d6:	8a 00                	mov    (%eax),%al
f010a8d8:	84 c0                	test   %al,%al
f010a8da:	75 03                	jne    f010a8df <env_table_ws_get_size+0x35>
f010a8dc:	ff 45 f8             	incl   -0x8(%ebp)
f010a8df:	ff 45 fc             	incl   -0x4(%ebp)
f010a8e2:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a8e6:	7e d8                	jle    f010a8c0 <env_table_ws_get_size+0x16>
	return counter;
f010a8e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a8eb:	c9                   	leave  
f010a8ec:	c3                   	ret    

f010a8ed <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a8ed:	55                   	push   %ebp
f010a8ee:	89 e5                	mov    %esp,%ebp
f010a8f0:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a8f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a8fa:	eb 4e                	jmp    f010a94a <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a8fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a902:	89 d0                	mov    %edx,%eax
f010a904:	01 c0                	add    %eax,%eax
f010a906:	01 d0                	add    %edx,%eax
f010a908:	c1 e0 03             	shl    $0x3,%eax
f010a90b:	01 c8                	add    %ecx,%eax
f010a90d:	05 ac 00 00 00       	add    $0xac,%eax
f010a912:	8b 00                	mov    (%eax),%eax
f010a914:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a917:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a91a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a91f:	89 c2                	mov    %eax,%edx
f010a921:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a924:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a927:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a92a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a92f:	39 c2                	cmp    %eax,%edx
f010a931:	75 14                	jne    f010a947 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a933:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a936:	83 ec 08             	sub    $0x8,%esp
f010a939:	50                   	push   %eax
f010a93a:	ff 75 08             	pushl  0x8(%ebp)
f010a93d:	e8 bc 00 00 00       	call   f010a9fe <env_table_ws_clear_entry>
f010a942:	83 c4 10             	add    $0x10,%esp
			break;
f010a945:	eb 09                	jmp    f010a950 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a947:	ff 45 f4             	incl   -0xc(%ebp)
f010a94a:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a94e:	7e ac                	jle    f010a8fc <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a950:	90                   	nop
f010a951:	c9                   	leave  
f010a952:	c3                   	ret    

f010a953 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a953:	55                   	push   %ebp
f010a954:	89 e5                	mov    %esp,%ebp
f010a956:	53                   	push   %ebx
f010a957:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a95a:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a95e:	76 19                	jbe    f010a979 <env_table_ws_set_entry+0x26>
f010a960:	68 7c 60 12 f0       	push   $0xf012607c
f010a965:	68 ad 60 12 f0       	push   $0xf01260ad
f010a96a:	68 3f 01 00 00       	push   $0x13f
f010a96f:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010a974:	e8 c0 59 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a979:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a980:	76 19                	jbe    f010a99b <env_table_ws_set_entry+0x48>
f010a982:	68 c4 60 12 f0       	push   $0xf01260c4
f010a987:	68 ad 60 12 f0       	push   $0xf01260ad
f010a98c:	68 40 01 00 00       	push   $0x140
f010a991:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010a996:	e8 9e 59 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a99b:	8b 45 10             	mov    0x10(%ebp),%eax
f010a99e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a9a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9a4:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a9a9:	89 c1                	mov    %eax,%ecx
f010a9ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a9ae:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9b1:	89 d0                	mov    %edx,%eax
f010a9b3:	01 c0                	add    %eax,%eax
f010a9b5:	01 d0                	add    %edx,%eax
f010a9b7:	c1 e0 03             	shl    $0x3,%eax
f010a9ba:	01 d8                	add    %ebx,%eax
f010a9bc:	05 ac 00 00 00       	add    $0xac,%eax
f010a9c1:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a9c3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9c6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9c9:	89 d0                	mov    %edx,%eax
f010a9cb:	01 c0                	add    %eax,%eax
f010a9cd:	01 d0                	add    %edx,%eax
f010a9cf:	c1 e0 03             	shl    $0x3,%eax
f010a9d2:	01 c8                	add    %ecx,%eax
f010a9d4:	05 b0 00 00 00       	add    $0xb0,%eax
f010a9d9:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010a9dc:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9df:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9e2:	89 d0                	mov    %edx,%eax
f010a9e4:	01 c0                	add    %eax,%eax
f010a9e6:	01 d0                	add    %edx,%eax
f010a9e8:	c1 e0 03             	shl    $0x3,%eax
f010a9eb:	01 c8                	add    %ecx,%eax
f010a9ed:	05 b4 00 00 00       	add    $0xb4,%eax
f010a9f2:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010a9f8:	90                   	nop
}
f010a9f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a9fc:	c9                   	leave  
f010a9fd:	c3                   	ret    

f010a9fe <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010a9fe:	55                   	push   %ebp
f010a9ff:	89 e5                	mov    %esp,%ebp
f010aa01:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa04:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa08:	76 19                	jbe    f010aa23 <env_table_ws_clear_entry+0x25>
f010aa0a:	68 7c 60 12 f0       	push   $0xf012607c
f010aa0f:	68 ad 60 12 f0       	push   $0xf01260ad
f010aa14:	68 4b 01 00 00       	push   $0x14b
f010aa19:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010aa1e:	e8 16 59 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010aa23:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa26:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa29:	89 d0                	mov    %edx,%eax
f010aa2b:	01 c0                	add    %eax,%eax
f010aa2d:	01 d0                	add    %edx,%eax
f010aa2f:	c1 e0 03             	shl    $0x3,%eax
f010aa32:	01 c8                	add    %ecx,%eax
f010aa34:	05 ac 00 00 00       	add    $0xac,%eax
f010aa39:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010aa3f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa42:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa45:	89 d0                	mov    %edx,%eax
f010aa47:	01 c0                	add    %eax,%eax
f010aa49:	01 d0                	add    %edx,%eax
f010aa4b:	c1 e0 03             	shl    $0x3,%eax
f010aa4e:	01 c8                	add    %ecx,%eax
f010aa50:	05 b0 00 00 00       	add    $0xb0,%eax
f010aa55:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010aa58:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa5b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa5e:	89 d0                	mov    %edx,%eax
f010aa60:	01 c0                	add    %eax,%eax
f010aa62:	01 d0                	add    %edx,%eax
f010aa64:	c1 e0 03             	shl    $0x3,%eax
f010aa67:	01 c8                	add    %ecx,%eax
f010aa69:	05 b4 00 00 00       	add    $0xb4,%eax
f010aa6e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010aa74:	90                   	nop
f010aa75:	c9                   	leave  
f010aa76:	c3                   	ret    

f010aa77 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010aa77:	55                   	push   %ebp
f010aa78:	89 e5                	mov    %esp,%ebp
f010aa7a:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa7d:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa81:	76 19                	jbe    f010aa9c <env_table_ws_get_virtual_address+0x25>
f010aa83:	68 7c 60 12 f0       	push   $0xf012607c
f010aa88:	68 ad 60 12 f0       	push   $0xf01260ad
f010aa8d:	68 53 01 00 00       	push   $0x153
f010aa92:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010aa97:	e8 9d 58 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010aa9c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa9f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aaa2:	89 d0                	mov    %edx,%eax
f010aaa4:	01 c0                	add    %eax,%eax
f010aaa6:	01 d0                	add    %edx,%eax
f010aaa8:	c1 e0 03             	shl    $0x3,%eax
f010aaab:	01 c8                	add    %ecx,%eax
f010aaad:	05 ac 00 00 00       	add    $0xac,%eax
f010aab2:	8b 00                	mov    (%eax),%eax
f010aab4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaba:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010aabf:	c9                   	leave  
f010aac0:	c3                   	ret    

f010aac1 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010aac1:	55                   	push   %ebp
f010aac2:	89 e5                	mov    %esp,%ebp
f010aac4:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aac7:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aacb:	76 19                	jbe    f010aae6 <env_table_ws_get_time_stamp+0x25>
f010aacd:	68 7c 60 12 f0       	push   $0xf012607c
f010aad2:	68 ad 60 12 f0       	push   $0xf01260ad
f010aad7:	68 5a 01 00 00       	push   $0x15a
f010aadc:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010aae1:	e8 53 58 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010aae6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aae9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aaec:	89 d0                	mov    %edx,%eax
f010aaee:	01 c0                	add    %eax,%eax
f010aaf0:	01 d0                	add    %edx,%eax
f010aaf2:	c1 e0 03             	shl    $0x3,%eax
f010aaf5:	01 c8                	add    %ecx,%eax
f010aaf7:	05 b4 00 00 00       	add    $0xb4,%eax
f010aafc:	8b 00                	mov    (%eax),%eax
}
f010aafe:	c9                   	leave  
f010aaff:	c3                   	ret    

f010ab00 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010ab00:	55                   	push   %ebp
f010ab01:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010ab03:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab06:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ab09:	89 d0                	mov    %edx,%eax
f010ab0b:	01 c0                	add    %eax,%eax
f010ab0d:	01 d0                	add    %edx,%eax
f010ab0f:	c1 e0 03             	shl    $0x3,%eax
f010ab12:	01 c8                	add    %ecx,%eax
f010ab14:	05 b0 00 00 00       	add    $0xb0,%eax
f010ab19:	8a 00                	mov    (%eax),%al
f010ab1b:	0f b6 c0             	movzbl %al,%eax
}
f010ab1e:	5d                   	pop    %ebp
f010ab1f:	c3                   	ret    

f010ab20 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010ab20:	55                   	push   %ebp
f010ab21:	89 e5                	mov    %esp,%ebp
f010ab23:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab26:	83 ec 04             	sub    $0x4,%esp
f010ab29:	68 f7 60 12 f0       	push   $0xf01260f7
f010ab2e:	68 6a 01 00 00       	push   $0x16a
f010ab33:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010ab38:	e8 fc 57 ff ff       	call   f0100339 <_panic>

f010ab3d <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010ab3d:	55                   	push   %ebp
f010ab3e:	89 e5                	mov    %esp,%ebp
f010ab40:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab43:	83 ec 04             	sub    $0x4,%esp
f010ab46:	68 f7 60 12 f0       	push   $0xf01260f7
f010ab4b:	68 6f 01 00 00       	push   $0x16f
f010ab50:	68 d8 5e 12 f0       	push   $0xf0125ed8
f010ab55:	e8 df 57 ff ff       	call   f0100339 <_panic>

f010ab5a <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ab5a:	55                   	push   %ebp
f010ab5b:	89 e5                	mov    %esp,%ebp
f010ab5d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010ab60:	83 ec 04             	sub    $0x4,%esp
f010ab63:	68 08 61 12 f0       	push   $0xf0126108
f010ab68:	6a 22                	push   $0x22
f010ab6a:	68 36 61 12 f0       	push   $0xf0126136
f010ab6f:	e8 c5 57 ff ff       	call   f0100339 <_panic>

f010ab74 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ab74:	55                   	push   %ebp
f010ab75:	89 e5                	mov    %esp,%ebp
f010ab77:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ab7a:	83 ec 04             	sub    $0x4,%esp
f010ab7d:	68 54 61 12 f0       	push   $0xf0126154
f010ab82:	6a 35                	push   $0x35
f010ab84:	68 36 61 12 f0       	push   $0xf0126136
f010ab89:	e8 ab 57 ff ff       	call   f0100339 <_panic>

f010ab8e <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010ab8e:	55                   	push   %ebp
f010ab8f:	89 e5                	mov    %esp,%ebp
f010ab91:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010ab94:	83 ec 04             	sub    $0x4,%esp
f010ab97:	68 84 61 12 f0       	push   $0xf0126184
f010ab9c:	6a 45                	push   $0x45
f010ab9e:	68 36 61 12 f0       	push   $0xf0126136
f010aba3:	e8 91 57 ff ff       	call   f0100339 <_panic>

f010aba8 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010aba8:	55                   	push   %ebp
f010aba9:	89 e5                	mov    %esp,%ebp
f010abab:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010abae:	83 ec 04             	sub    $0x4,%esp
f010abb1:	68 b0 61 12 f0       	push   $0xf01261b0
f010abb6:	6a 53                	push   $0x53
f010abb8:	68 36 61 12 f0       	push   $0xf0126136
f010abbd:	e8 77 57 ff ff       	call   f0100339 <_panic>

f010abc2 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010abc2:	55                   	push   %ebp
f010abc3:	89 e5                	mov    %esp,%ebp
f010abc5:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010abc8:	83 ec 04             	sub    $0x4,%esp
f010abcb:	68 e0 61 12 f0       	push   $0xf01261e0
f010abd0:	6a 5d                	push   $0x5d
f010abd2:	68 36 61 12 f0       	push   $0xf0126136
f010abd7:	e8 5d 57 ff ff       	call   f0100339 <_panic>

f010abdc <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010abdc:	55                   	push   %ebp
f010abdd:	89 e5                	mov    %esp,%ebp
f010abdf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010abe2:	83 ec 04             	sub    $0x4,%esp
f010abe5:	68 18 62 12 f0       	push   $0xf0126218
f010abea:	6a 6a                	push   $0x6a
f010abec:	68 36 61 12 f0       	push   $0xf0126136
f010abf1:	e8 43 57 ff ff       	call   f0100339 <_panic>

f010abf6 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010abf6:	55                   	push   %ebp
f010abf7:	89 e5                	mov    %esp,%ebp
f010abf9:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010abfc:	e8 98 0e 00 00       	call   f010ba99 <get_cpu_proc>
f010ac01:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010ac04:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ac08:	7e 61                	jle    f010ac6b <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010ac0a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac0d:	c1 e0 0c             	shl    $0xc,%eax
f010ac10:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010ac13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac16:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ac19:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010ac1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac1f:	8b 50 7c             	mov    0x7c(%eax),%edx
f010ac22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac25:	01 c2                	add    %eax,%edx
f010ac27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac2a:	8b 40 78             	mov    0x78(%eax),%eax
f010ac2d:	39 c2                	cmp    %eax,%edx
f010ac2f:	77 09                	ja     f010ac3a <sys_sbrk+0x44>
f010ac31:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f010ac36:	85 c0                	test   %eax,%eax
f010ac38:	75 07                	jne    f010ac41 <sys_sbrk+0x4b>
f010ac3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ac3f:	eb 3d                	jmp    f010ac7e <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010ac41:	83 ec 04             	sub    $0x4,%esp
f010ac44:	ff 75 f0             	pushl  -0x10(%ebp)
f010ac47:	ff 75 ec             	pushl  -0x14(%ebp)
f010ac4a:	ff 75 f4             	pushl  -0xc(%ebp)
f010ac4d:	e8 2e 00 00 00       	call   f010ac80 <allocate_user_mem>
f010ac52:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010ac55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac58:	8b 50 7c             	mov    0x7c(%eax),%edx
f010ac5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac5e:	01 c2                	add    %eax,%edx
f010ac60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac63:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010ac66:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac69:	eb 13                	jmp    f010ac7e <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010ac6b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ac6f:	75 08                	jne    f010ac79 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010ac71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac74:	8b 40 7c             	mov    0x7c(%eax),%eax
f010ac77:	eb 05                	jmp    f010ac7e <sys_sbrk+0x88>
	}

	return (void *)-1;
f010ac79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010ac7e:	c9                   	leave  
f010ac7f:	c3                   	ret    

f010ac80 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac80:	55                   	push   %ebp
f010ac81:	89 e5                	mov    %esp,%ebp
f010ac83:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010ac86:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010ac8d:	8b 55 10             	mov    0x10(%ebp),%edx
f010ac90:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ac93:	01 d0                	add    %edx,%eax
f010ac95:	48                   	dec    %eax
f010ac96:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ac99:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ac9c:	ba 00 00 00 00       	mov    $0x0,%edx
f010aca1:	f7 75 f0             	divl   -0x10(%ebp)
f010aca4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010aca7:	29 d0                	sub    %edx,%eax
f010aca9:	c1 e8 0c             	shr    $0xc,%eax
f010acac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010acaf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010acb6:	eb 78                	jmp    f010ad30 <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010acb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010acbb:	c1 e0 0c             	shl    $0xc,%eax
f010acbe:	89 c2                	mov    %eax,%edx
f010acc0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acc3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010acc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010acc9:	8b 40 64             	mov    0x64(%eax),%eax
f010accc:	83 ec 04             	sub    $0x4,%esp
f010accf:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010acd2:	52                   	push   %edx
f010acd3:	51                   	push   %ecx
f010acd4:	50                   	push   %eax
f010acd5:	e8 15 d7 ff ff       	call   f01083ef <get_page_table>
f010acda:	83 c4 10             	add    $0x10,%esp
f010acdd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010ace0:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010ace4:	75 23                	jne    f010ad09 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010ace6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ace9:	c1 e0 0c             	shl    $0xc,%eax
f010acec:	89 c2                	mov    %eax,%edx
f010acee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acf1:	01 c2                	add    %eax,%edx
f010acf3:	8b 45 08             	mov    0x8(%ebp),%eax
f010acf6:	8b 40 64             	mov    0x64(%eax),%eax
f010acf9:	83 ec 08             	sub    $0x8,%esp
f010acfc:	52                   	push   %edx
f010acfd:	50                   	push   %eax
f010acfe:	e8 42 d8 ff ff       	call   f0108545 <create_page_table>
f010ad03:	83 c4 10             	add    $0x10,%esp
f010ad06:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010ad09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad0c:	c1 e0 0c             	shl    $0xc,%eax
f010ad0f:	89 c2                	mov    %eax,%edx
f010ad11:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad14:	01 c2                	add    %eax,%edx
f010ad16:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad19:	8b 40 64             	mov    0x64(%eax),%eax
f010ad1c:	6a 00                	push   $0x0
f010ad1e:	68 00 02 00 00       	push   $0x200
f010ad23:	52                   	push   %edx
f010ad24:	50                   	push   %eax
f010ad25:	e8 af ef ff ff       	call   f0109cd9 <pt_set_page_permissions>
f010ad2a:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010ad2d:	ff 45 f4             	incl   -0xc(%ebp)
f010ad30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad33:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010ad36:	72 80                	jb     f010acb8 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010ad38:	90                   	nop
f010ad39:	c9                   	leave  
f010ad3a:	c3                   	ret    

f010ad3b <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ad3b:	55                   	push   %ebp
f010ad3c:	89 e5                	mov    %esp,%ebp
f010ad3e:	83 ec 28             	sub    $0x28,%esp

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010ad41:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010ad48:	8b 55 10             	mov    0x10(%ebp),%edx
f010ad4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ad4e:	01 d0                	add    %edx,%eax
f010ad50:	48                   	dec    %eax
f010ad51:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ad54:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ad57:	ba 00 00 00 00       	mov    $0x0,%edx
f010ad5c:	f7 75 f0             	divl   -0x10(%ebp)
f010ad5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ad62:	29 d0                	sub    %edx,%eax
f010ad64:	c1 e8 0c             	shr    $0xc,%eax
f010ad67:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f010ad6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ad71:	e9 86 00 00 00       	jmp    f010adfc <free_user_mem+0xc1>
			pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010ad76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad79:	c1 e0 0c             	shl    $0xc,%eax
f010ad7c:	89 c2                	mov    %eax,%edx
f010ad7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad81:	01 c2                	add    %eax,%edx
f010ad83:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad86:	8b 40 64             	mov    0x64(%eax),%eax
f010ad89:	68 00 02 00 00       	push   $0x200
f010ad8e:	6a 00                	push   $0x0
f010ad90:	52                   	push   %edx
f010ad91:	50                   	push   %eax
f010ad92:	e8 42 ef ff ff       	call   f0109cd9 <pt_set_page_permissions>
f010ad97:	83 c4 10             	add    $0x10,%esp
			int ret = pf_read_env_page(e,(void*)((i*PAGE_SIZE)+virtual_address));
f010ad9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad9d:	c1 e0 0c             	shl    $0xc,%eax
f010ada0:	89 c2                	mov    %eax,%edx
f010ada2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ada5:	01 d0                	add    %edx,%eax
f010ada7:	83 ec 08             	sub    $0x8,%esp
f010adaa:	50                   	push   %eax
f010adab:	ff 75 08             	pushl  0x8(%ebp)
f010adae:	e8 2e 97 ff ff       	call   f01044e1 <pf_read_env_page>
f010adb3:	83 c4 10             	add    $0x10,%esp
f010adb6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
f010adb9:	83 7d e4 f7          	cmpl   $0xfffffff7,-0x1c(%ebp)
f010adbd:	75 1e                	jne    f010addd <free_user_mem+0xa2>
f010adbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010adc2:	c1 e0 0c             	shl    $0xc,%eax
f010adc5:	89 c2                	mov    %eax,%edx
f010adc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010adca:	01 d0                	add    %edx,%eax
f010adcc:	83 ec 08             	sub    $0x8,%esp
f010adcf:	50                   	push   %eax
f010add0:	ff 75 08             	pushl  0x8(%ebp)
f010add3:	e8 a2 f1 ff ff       	call   f0109f7a <env_page_ws_invalidate>
f010add8:	83 c4 10             	add    $0x10,%esp
f010addb:	eb 1c                	jmp    f010adf9 <free_user_mem+0xbe>
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);
f010addd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ade0:	c1 e0 0c             	shl    $0xc,%eax
f010ade3:	89 c2                	mov    %eax,%edx
f010ade5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ade8:	01 d0                	add    %edx,%eax
f010adea:	83 ec 08             	sub    $0x8,%esp
f010aded:	50                   	push   %eax
f010adee:	ff 75 08             	pushl  0x8(%ebp)
f010adf1:	e8 ae 97 ff ff       	call   f01045a4 <pf_remove_env_page>
f010adf6:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
		for(int i = 0; i < no_of_pages; i++){
f010adf9:	ff 45 f4             	incl   -0xc(%ebp)
f010adfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010adff:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010ae02:	0f 82 6e ff ff ff    	jb     f010ad76 <free_user_mem+0x3b>
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);


		}
}
f010ae08:	90                   	nop
f010ae09:	c9                   	leave  
f010ae0a:	c3                   	ret    

f010ae0b <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ae0b:	55                   	push   %ebp
f010ae0c:	89 e5                	mov    %esp,%ebp
f010ae0e:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010ae11:	83 ec 04             	sub    $0x4,%esp
f010ae14:	68 50 62 12 f0       	push   $0xf0126250
f010ae19:	68 e0 00 00 00       	push   $0xe0
f010ae1e:	68 36 61 12 f0       	push   $0xf0126136
f010ae23:	e8 11 55 ff ff       	call   f0100339 <_panic>

f010ae28 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ae28:	55                   	push   %ebp
f010ae29:	89 e5                	mov    %esp,%ebp
f010ae2b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010ae2e:	83 ec 04             	sub    $0x4,%esp
f010ae31:	68 90 62 12 f0       	push   $0xf0126290
f010ae36:	68 ea 00 00 00       	push   $0xea
f010ae3b:	68 36 61 12 f0       	push   $0xf0126136
f010ae40:	e8 f4 54 ff ff       	call   f0100339 <_panic>

f010ae45 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010ae45:	55                   	push   %ebp
f010ae46:	89 e5                	mov    %esp,%ebp
f010ae48:	56                   	push   %esi
f010ae49:	53                   	push   %ebx
f010ae4a:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010ae4d:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010ae54:	e9 b0 01 00 00       	jmp    f010b009 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010ae59:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010ae5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae62:	89 d0                	mov    %edx,%eax
f010ae64:	c1 e0 03             	shl    $0x3,%eax
f010ae67:	01 d0                	add    %edx,%eax
f010ae69:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae70:	01 d8                	add    %ebx,%eax
f010ae72:	01 c0                	add    %eax,%eax
f010ae74:	01 d0                	add    %edx,%eax
f010ae76:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010ae7d:	01 d8                	add    %ebx,%eax
f010ae7f:	01 d0                	add    %edx,%eax
f010ae81:	01 c8                	add    %ecx,%eax
f010ae83:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010ae8a:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010ae90:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae93:	89 d0                	mov    %edx,%eax
f010ae95:	c1 e0 03             	shl    $0x3,%eax
f010ae98:	01 d0                	add    %edx,%eax
f010ae9a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aea1:	01 d8                	add    %ebx,%eax
f010aea3:	01 c0                	add    %eax,%eax
f010aea5:	01 d0                	add    %edx,%eax
f010aea7:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aeae:	01 d8                	add    %ebx,%eax
f010aeb0:	01 d0                	add    %edx,%eax
f010aeb2:	01 c8                	add    %ecx,%eax
f010aeb4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010aebb:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010aec1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aec4:	89 d0                	mov    %edx,%eax
f010aec6:	c1 e0 03             	shl    $0x3,%eax
f010aec9:	01 d0                	add    %edx,%eax
f010aecb:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aed2:	01 d8                	add    %ebx,%eax
f010aed4:	01 c0                	add    %eax,%eax
f010aed6:	01 d0                	add    %edx,%eax
f010aed8:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010aedf:	01 d8                	add    %ebx,%eax
f010aee1:	01 d0                	add    %edx,%eax
f010aee3:	01 c8                	add    %ecx,%eax
f010aee5:	85 c0                	test   %eax,%eax
f010aee7:	75 14                	jne    f010aefd <env_init+0xb8>
f010aee9:	83 ec 04             	sub    $0x4,%esp
f010aeec:	68 bc 62 12 f0       	push   $0xf01262bc
f010aef1:	6a 65                	push   $0x65
f010aef3:	68 df 62 12 f0       	push   $0xf01262df
f010aef8:	e8 3c 54 ff ff       	call   f0100339 <_panic>
f010aefd:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010af03:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af06:	89 d0                	mov    %edx,%eax
f010af08:	c1 e0 03             	shl    $0x3,%eax
f010af0b:	01 d0                	add    %edx,%eax
f010af0d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af14:	01 d8                	add    %ebx,%eax
f010af16:	01 c0                	add    %eax,%eax
f010af18:	01 d0                	add    %edx,%eax
f010af1a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af21:	01 d8                	add    %ebx,%eax
f010af23:	01 d0                	add    %edx,%eax
f010af25:	01 c8                	add    %ecx,%eax
f010af27:	8b 15 f4 8a 69 f0    	mov    0xf0698af4,%edx
f010af2d:	89 50 08             	mov    %edx,0x8(%eax)
f010af30:	8b 40 08             	mov    0x8(%eax),%eax
f010af33:	85 c0                	test   %eax,%eax
f010af35:	74 35                	je     f010af6c <env_init+0x127>
f010af37:	8b 0d f4 8a 69 f0    	mov    0xf0698af4,%ecx
f010af3d:	8b 1d f0 8a 69 f0    	mov    0xf0698af0,%ebx
f010af43:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af46:	89 d0                	mov    %edx,%eax
f010af48:	c1 e0 03             	shl    $0x3,%eax
f010af4b:	01 d0                	add    %edx,%eax
f010af4d:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010af54:	01 f0                	add    %esi,%eax
f010af56:	01 c0                	add    %eax,%eax
f010af58:	01 d0                	add    %edx,%eax
f010af5a:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010af61:	01 f0                	add    %esi,%eax
f010af63:	01 d0                	add    %edx,%eax
f010af65:	01 d8                	add    %ebx,%eax
f010af67:	89 41 0c             	mov    %eax,0xc(%ecx)
f010af6a:	eb 2f                	jmp    f010af9b <env_init+0x156>
f010af6c:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010af72:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af75:	89 d0                	mov    %edx,%eax
f010af77:	c1 e0 03             	shl    $0x3,%eax
f010af7a:	01 d0                	add    %edx,%eax
f010af7c:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af83:	01 d8                	add    %ebx,%eax
f010af85:	01 c0                	add    %eax,%eax
f010af87:	01 d0                	add    %edx,%eax
f010af89:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010af90:	01 d8                	add    %ebx,%eax
f010af92:	01 d0                	add    %edx,%eax
f010af94:	01 c8                	add    %ecx,%eax
f010af96:	a3 f8 8a 69 f0       	mov    %eax,0xf0698af8
f010af9b:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010afa1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010afa4:	89 d0                	mov    %edx,%eax
f010afa6:	c1 e0 03             	shl    $0x3,%eax
f010afa9:	01 d0                	add    %edx,%eax
f010afab:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010afb2:	01 d8                	add    %ebx,%eax
f010afb4:	01 c0                	add    %eax,%eax
f010afb6:	01 d0                	add    %edx,%eax
f010afb8:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010afbf:	01 d8                	add    %ebx,%eax
f010afc1:	01 d0                	add    %edx,%eax
f010afc3:	01 c8                	add    %ecx,%eax
f010afc5:	a3 f4 8a 69 f0       	mov    %eax,0xf0698af4
f010afca:	8b 0d f0 8a 69 f0    	mov    0xf0698af0,%ecx
f010afd0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010afd3:	89 d0                	mov    %edx,%eax
f010afd5:	c1 e0 03             	shl    $0x3,%eax
f010afd8:	01 d0                	add    %edx,%eax
f010afda:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010afe1:	01 d8                	add    %ebx,%eax
f010afe3:	01 c0                	add    %eax,%eax
f010afe5:	01 d0                	add    %edx,%eax
f010afe7:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010afee:	01 d8                	add    %ebx,%eax
f010aff0:	01 d0                	add    %edx,%eax
f010aff2:	01 c8                	add    %ecx,%eax
f010aff4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010affb:	a1 00 8b 69 f0       	mov    0xf0698b00,%eax
f010b000:	40                   	inc    %eax
f010b001:	a3 00 8b 69 f0       	mov    %eax,0xf0698b00
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010b006:	ff 4d f4             	decl   -0xc(%ebp)
f010b009:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b00d:	0f 89 46 fe ff ff    	jns    f010ae59 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010b013:	90                   	nop
f010b014:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b017:	5b                   	pop    %ebx
f010b018:	5e                   	pop    %esi
f010b019:	5d                   	pop    %ebp
f010b01a:	c3                   	ret    

f010b01b <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010b01b:	55                   	push   %ebp
f010b01c:	89 e5                	mov    %esp,%ebp
f010b01e:	57                   	push   %edi
f010b01f:	56                   	push   %esi
f010b020:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010b026:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010b02d:	83 ec 0c             	sub    $0xc,%esp
f010b030:	ff 75 08             	pushl  0x8(%ebp)
f010b033:	e8 b8 1e 00 00       	call   f010cef0 <get_user_program_info>
f010b038:	83 c4 10             	add    $0x10,%esp
f010b03b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010b03e:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b042:	75 0a                	jne    f010b04e <env_create+0x33>
	{
		return NULL;
f010b044:	b8 00 00 00 00       	mov    $0x0,%eax
f010b049:	e9 aa 09 00 00       	jmp    f010b9f8 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010b04e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b051:	8b 40 08             	mov    0x8(%eax),%eax
f010b054:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010b057:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010b05e:	00 00 00 
	if(allocate_environment(&e) < 0)
f010b061:	83 ec 0c             	sub    $0xc,%esp
f010b064:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010b06a:	50                   	push   %eax
f010b06b:	e8 96 0e 00 00       	call   f010bf06 <allocate_environment>
f010b070:	83 c4 10             	add    $0x10,%esp
f010b073:	85 c0                	test   %eax,%eax
f010b075:	79 0a                	jns    f010b081 <env_create+0x66>
	{
		return NULL;
f010b077:	b8 00 00 00 00       	mov    $0x0,%eax
f010b07c:	e9 77 09 00 00       	jmp    f010b9f8 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010b081:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b084:	8b 00                	mov    (%eax),%eax
f010b086:	83 ec 0c             	sub    $0xc,%esp
f010b089:	50                   	push   %eax
f010b08a:	e8 47 4c 01 00       	call   f011fcd6 <strlen>
f010b08f:	83 c4 10             	add    $0x10,%esp
f010b092:	83 f8 3f             	cmp    $0x3f,%eax
f010b095:	7f 1d                	jg     f010b0b4 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010b097:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b09a:	8b 00                	mov    (%eax),%eax
f010b09c:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b0a2:	83 c2 20             	add    $0x20,%edx
f010b0a5:	83 ec 08             	sub    $0x8,%esp
f010b0a8:	50                   	push   %eax
f010b0a9:	52                   	push   %edx
f010b0aa:	e8 76 4c 01 00       	call   f011fd25 <strcpy>
f010b0af:	83 c4 10             	add    $0x10,%esp
f010b0b2:	eb 1d                	jmp    f010b0d1 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010b0b4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b0b7:	8b 00                	mov    (%eax),%eax
f010b0b9:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b0bf:	83 c2 20             	add    $0x20,%edx
f010b0c2:	83 ec 04             	sub    $0x4,%esp
f010b0c5:	6a 3f                	push   $0x3f
f010b0c7:	50                   	push   %eax
f010b0c8:	52                   	push   %edx
f010b0c9:	e8 85 4c 01 00       	call   f011fd53 <strncpy>
f010b0ce:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010b0d1:	e8 fc 13 00 00       	call   f010c4d2 <create_user_directory>
f010b0d6:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b0d9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b0dc:	83 ec 0c             	sub    $0xc,%esp
f010b0df:	50                   	push   %eax
f010b0e0:	e8 00 e8 ff ff       	call   f01098e5 <kheap_physical_address>
f010b0e5:	83 c4 10             	add    $0x10,%esp
f010b0e8:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010b0eb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0f1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b0f4:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b0fa:	83 ec 0c             	sub    $0xc,%esp
f010b0fd:	6a 02                	push   $0x2
f010b0ff:	e8 d1 45 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010b104:	83 c4 10             	add    $0x10,%esp
f010b107:	85 c0                	test   %eax,%eax
f010b109:	74 21                	je     f010b12c <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010b10b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b111:	8b 55 10             	mov    0x10(%ebp),%edx
f010b114:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b11a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b120:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b123:	2b 55 10             	sub    0x10(%ebp),%edx
f010b126:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b12c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b130:	75 12                	jne    f010b144 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b132:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b138:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010b13f:	00 00 00 
f010b142:	eb 0f                	jmp    f010b153 <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b144:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b14a:	8b 55 14             	mov    0x14(%ebp),%edx
f010b14d:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b153:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b159:	83 ec 04             	sub    $0x4,%esp
f010b15c:	ff 75 bc             	pushl  -0x44(%ebp)
f010b15f:	ff 75 c0             	pushl  -0x40(%ebp)
f010b162:	50                   	push   %eax
f010b163:	e8 c8 14 00 00       	call   f010c630 <initialize_environment>
f010b168:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b16b:	e8 5f c0 ff ff       	call   f01071cf <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b170:	0f 20 d8             	mov    %cr3,%eax
f010b173:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b176:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b179:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b17c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b182:	8b 40 68             	mov    0x68(%eax),%eax
f010b185:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b18b:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b191:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b194:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b19b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b1a2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1a8:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b1ae:	48                   	dec    %eax
f010b1af:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b1b2:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b1b9:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b1bc:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b1c2:	83 ec 08             	sub    $0x8,%esp
f010b1c5:	ff 75 c8             	pushl  -0x38(%ebp)
f010b1c8:	50                   	push   %eax
f010b1c9:	e8 34 1a 00 00       	call   f010cc02 <PROGRAM_SEGMENT_FIRST>
f010b1ce:	83 c4 0c             	add    $0xc,%esp
f010b1d1:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b1d7:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b1dd:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b1e2:	89 c7                	mov    %eax,%edi
f010b1e4:	89 d6                	mov    %edx,%esi
f010b1e6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b1e8:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b1ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b1f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b1f4:	8b 40 10             	mov    0x10(%eax),%eax
f010b1f7:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b1fa:	75 07                	jne    f010b203 <env_create+0x1e8>
f010b1fc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b203:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b206:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b209:	e9 fa 02 00 00       	jmp    f010b508 <env_create+0x4ed>
		{
			segment_counter++;
f010b20e:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b211:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b218:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b21b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b221:	83 ec 0c             	sub    $0xc,%esp
f010b224:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b22a:	52                   	push   %edx
f010b22b:	ff 75 ec             	pushl  -0x14(%ebp)
f010b22e:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b234:	52                   	push   %edx
f010b235:	ff 75 f4             	pushl  -0xc(%ebp)
f010b238:	50                   	push   %eax
f010b239:	e8 86 0d 00 00       	call   f010bfc4 <program_segment_alloc_map_copy_workingset>
f010b23e:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b241:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b247:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b24a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b24d:	8b 00                	mov    (%eax),%eax
f010b24f:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b252:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b255:	8b 40 0c             	mov    0xc(%eax),%eax
f010b258:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b25b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b25e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b261:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b264:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b269:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b26c:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b273:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b276:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b279:	01 d0                	add    %edx,%eax
f010b27b:	48                   	dec    %eax
f010b27c:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b27f:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b282:	ba 00 00 00 00       	mov    $0x0,%edx
f010b287:	f7 75 9c             	divl   -0x64(%ebp)
f010b28a:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b28d:	29 d0                	sub    %edx,%eax
f010b28f:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b292:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b295:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b298:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b29b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b29e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b2a1:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f010b2a7:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b2aa:	01 d0                	add    %edx,%eax
f010b2ac:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b2af:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b2b3:	74 73                	je     f010b328 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b2b5:	a1 4c 2d 6c f0       	mov    0xf06c2d4c,%eax
f010b2ba:	83 ec 04             	sub    $0x4,%esp
f010b2bd:	68 00 10 00 00       	push   $0x1000
f010b2c2:	6a 00                	push   $0x0
f010b2c4:	50                   	push   %eax
f010b2c5:	e8 fa 4b 01 00       	call   f011fec4 <memset>
f010b2ca:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b2cd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b2d0:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b2d3:	eb 13                	jmp    f010b2e8 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b2d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2d8:	8a 10                	mov    (%eax),%dl
f010b2da:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b2dd:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b2df:	ff 45 dc             	incl   -0x24(%ebp)
f010b2e2:	ff 45 e4             	incl   -0x1c(%ebp)
f010b2e5:	ff 45 e0             	incl   -0x20(%ebp)
f010b2e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b2eb:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b2ee:	72 e5                	jb     f010b2d5 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b2f0:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f010b2f6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2fc:	83 ec 04             	sub    $0x4,%esp
f010b2ff:	52                   	push   %edx
f010b300:	ff 75 a0             	pushl  -0x60(%ebp)
f010b303:	50                   	push   %eax
f010b304:	e8 28 8f ff ff       	call   f0104231 <pf_add_env_page>
f010b309:	83 c4 10             	add    $0x10,%esp
f010b30c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b30f:	75 17                	jne    f010b328 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b311:	83 ec 04             	sub    $0x4,%esp
f010b314:	68 fc 62 12 f0       	push   $0xf01262fc
f010b319:	68 f5 00 00 00       	push   $0xf5
f010b31e:	68 df 62 12 f0       	push   $0xf01262df
f010b323:	e8 11 50 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b328:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b32b:	8b 50 04             	mov    0x4(%eax),%edx
f010b32e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b331:	01 d0                	add    %edx,%eax
f010b333:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b336:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b339:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b33e:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b341:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b344:	8b 50 04             	mov    0x4(%eax),%edx
f010b347:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b34a:	01 d0                	add    %edx,%eax
f010b34c:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b34f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b352:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b355:	eb 43                	jmp    f010b39a <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b357:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b35a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b360:	83 ec 04             	sub    $0x4,%esp
f010b363:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b366:	52                   	push   %edx
f010b367:	50                   	push   %eax
f010b368:	e8 c4 8e ff ff       	call   f0104231 <pf_add_env_page>
f010b36d:	83 c4 10             	add    $0x10,%esp
f010b370:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b373:	75 17                	jne    f010b38c <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b375:	83 ec 04             	sub    $0x4,%esp
f010b378:	68 fc 62 12 f0       	push   $0xf01262fc
f010b37d:	68 02 01 00 00       	push   $0x102
f010b382:	68 df 62 12 f0       	push   $0xf01262df
f010b387:	e8 ad 4f ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b38c:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b393:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b39a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b39d:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b3a0:	72 b5                	jb     f010b357 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b3a2:	a1 4c 2d 6c f0       	mov    0xf06c2d4c,%eax
f010b3a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b3aa:	83 ec 04             	sub    $0x4,%esp
f010b3ad:	68 00 10 00 00       	push   $0x1000
f010b3b2:	6a 00                	push   $0x0
f010b3b4:	ff 75 e0             	pushl  -0x20(%ebp)
f010b3b7:	e8 08 4b 01 00       	call   f011fec4 <memset>
f010b3bc:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b3bf:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b3c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b3c5:	eb 13                	jmp    f010b3da <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b3c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b3ca:	8a 10                	mov    (%eax),%dl
f010b3cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b3cf:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b3d1:	ff 45 dc             	incl   -0x24(%ebp)
f010b3d4:	ff 45 e4             	incl   -0x1c(%ebp)
f010b3d7:	ff 45 e0             	incl   -0x20(%ebp)
f010b3da:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b3dd:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b3e0:	72 e5                	jb     f010b3c7 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b3e2:	8b 15 4c 2d 6c f0    	mov    0xf06c2d4c,%edx
f010b3e8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b3ee:	83 ec 04             	sub    $0x4,%esp
f010b3f1:	52                   	push   %edx
f010b3f2:	ff 75 88             	pushl  -0x78(%ebp)
f010b3f5:	50                   	push   %eax
f010b3f6:	e8 36 8e ff ff       	call   f0104231 <pf_add_env_page>
f010b3fb:	83 c4 10             	add    $0x10,%esp
f010b3fe:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b401:	75 17                	jne    f010b41a <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b403:	83 ec 04             	sub    $0x4,%esp
f010b406:	68 fc 62 12 f0       	push   $0xf01262fc
f010b40b:	68 11 01 00 00       	push   $0x111
f010b410:	68 df 62 12 f0       	push   $0xf01262df
f010b415:	e8 1f 4f ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b41a:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b421:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b424:	8b 50 04             	mov    0x4(%eax),%edx
f010b427:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b42a:	01 c2                	add    %eax,%edx
f010b42c:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b42f:	01 d0                	add    %edx,%eax
f010b431:	48                   	dec    %eax
f010b432:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b438:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b43e:	ba 00 00 00 00       	mov    $0x0,%edx
f010b443:	f7 75 80             	divl   -0x80(%ebp)
f010b446:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b44c:	29 d0                	sub    %edx,%eax
f010b44e:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b451:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b454:	8b 50 08             	mov    0x8(%eax),%edx
f010b457:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b45a:	01 d0                	add    %edx,%eax
f010b45c:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b45f:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b465:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b46c:	eb 41                	jmp    f010b4af <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b46e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b474:	83 ec 04             	sub    $0x4,%esp
f010b477:	6a 01                	push   $0x1
f010b479:	ff 75 d8             	pushl  -0x28(%ebp)
f010b47c:	50                   	push   %eax
f010b47d:	e8 7e 8c ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b482:	83 c4 10             	add    $0x10,%esp
f010b485:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b488:	75 17                	jne    f010b4a1 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b48a:	83 ec 04             	sub    $0x4,%esp
f010b48d:	68 fc 62 12 f0       	push   $0xf01262fc
f010b492:	68 1e 01 00 00       	push   $0x11e
f010b497:	68 df 62 12 f0       	push   $0xf01262df
f010b49c:	e8 98 4e ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b4a1:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b4a8:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b4af:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b4b6:	10 00 00 
f010b4b9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b4bf:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b4c5:	01 d0                	add    %edx,%eax
f010b4c7:	48                   	dec    %eax
f010b4c8:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b4ce:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b4d4:	ba 00 00 00 00       	mov    $0x0,%edx
f010b4d9:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b4df:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b4e5:	29 d0                	sub    %edx,%eax
f010b4e7:	89 c2                	mov    %eax,%edx
f010b4e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b4ec:	39 c2                	cmp    %eax,%edx
f010b4ee:	0f 87 7a ff ff ff    	ja     f010b46e <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b4f4:	83 ec 08             	sub    $0x8,%esp
f010b4f7:	ff 75 c8             	pushl  -0x38(%ebp)
f010b4fa:	ff 75 f4             	pushl  -0xc(%ebp)
f010b4fd:	e8 f5 15 00 00       	call   f010caf7 <PROGRAM_SEGMENT_NEXT>
f010b502:	83 c4 10             	add    $0x10,%esp
f010b505:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b508:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b50c:	0f 85 fc fc ff ff    	jne    f010b20e <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b512:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b518:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b51e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b521:	eb 77                	jmp    f010b59a <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b523:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b526:	8b 00                	mov    (%eax),%eax
f010b528:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b52e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b534:	8b 40 64             	mov    0x64(%eax),%eax
f010b537:	83 ec 04             	sub    $0x4,%esp
f010b53a:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b540:	52                   	push   %edx
f010b541:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b547:	50                   	push   %eax
f010b548:	e8 a2 ce ff ff       	call   f01083ef <get_page_table>
f010b54d:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b550:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010b556:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010b55c:	c1 ea 0c             	shr    $0xc,%edx
f010b55f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b565:	c1 e2 02             	shl    $0x2,%edx
f010b568:	01 d0                	add    %edx,%eax
f010b56a:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010b570:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010b576:	c1 e9 0c             	shr    $0xc,%ecx
f010b579:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b57f:	c1 e1 02             	shl    $0x2,%ecx
f010b582:	01 ca                	add    %ecx,%edx
f010b584:	8b 12                	mov    (%edx),%edx
f010b586:	83 e2 bf             	and    $0xffffffbf,%edx
f010b589:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b58b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b591:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b597:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b59a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5a0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b5a4:	74 08                	je     f010b5ae <env_create+0x593>
f010b5a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b5a9:	8b 52 10             	mov    0x10(%edx),%edx
f010b5ac:	eb 05                	jmp    f010b5b3 <env_create+0x598>
f010b5ae:	ba 00 00 00 00       	mov    $0x0,%edx
f010b5b3:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010b5b9:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b5bf:	85 c0                	test   %eax,%eax
f010b5c1:	0f 85 5c ff ff ff    	jne    f010b523 <env_create+0x508>
f010b5c7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b5cb:	0f 85 52 ff ff ff    	jne    f010b523 <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b5d1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b5d4:	8b 50 08             	mov    0x8(%eax),%edx
f010b5d7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5dd:	83 ec 08             	sub    $0x8,%esp
f010b5e0:	52                   	push   %edx
f010b5e1:	50                   	push   %eax
f010b5e2:	e8 d0 14 00 00       	call   f010cab7 <set_environment_entry_point>
f010b5e7:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b5ea:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5f0:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b5f7:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010b5fe:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b601:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b608:	e9 42 03 00 00       	jmp    f010b94f <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b60d:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010b614:	00 00 00 
			allocate_frame(&pp);
f010b617:	83 ec 0c             	sub    $0xc,%esp
f010b61a:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010b620:	50                   	push   %eax
f010b621:	e8 8c cb ff ff       	call   f01081b2 <allocate_frame>
f010b626:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b629:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010b62f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b635:	8b 40 64             	mov    0x64(%eax),%eax
f010b638:	6a 06                	push   $0x6
f010b63a:	ff 75 d0             	pushl  -0x30(%ebp)
f010b63d:	52                   	push   %edx
f010b63e:	50                   	push   %eax
f010b63f:	e8 3f d2 ff ff       	call   f0108883 <loadtime_map_frame>
f010b644:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b647:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b64a:	83 ec 04             	sub    $0x4,%esp
f010b64d:	68 00 10 00 00       	push   $0x1000
f010b652:	6a 00                	push   $0x0
f010b654:	50                   	push   %eax
f010b655:	e8 6a 48 01 00       	call   f011fec4 <memset>
f010b65a:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b65d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b663:	83 ec 08             	sub    $0x8,%esp
f010b666:	ff 75 d0             	pushl  -0x30(%ebp)
f010b669:	50                   	push   %eax
f010b66a:	e8 a0 e8 ff ff       	call   f0109f0f <env_page_ws_list_create_element>
f010b66f:	83 c4 10             	add    $0x10,%esp
f010b672:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b675:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b679:	75 17                	jne    f010b692 <env_create+0x677>
f010b67b:	83 ec 04             	sub    $0x4,%esp
f010b67e:	68 44 63 12 f0       	push   $0xf0126344
f010b683:	68 5d 01 00 00       	push   $0x15d
f010b688:	68 df 62 12 f0       	push   $0xf01262df
f010b68d:	e8 a7 4c ff ff       	call   f0100339 <_panic>
f010b692:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b698:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b69e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6a1:	89 50 14             	mov    %edx,0x14(%eax)
f010b6a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6a7:	8b 40 14             	mov    0x14(%eax),%eax
f010b6aa:	85 c0                	test   %eax,%eax
f010b6ac:	74 14                	je     f010b6c2 <env_create+0x6a7>
f010b6ae:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6b4:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b6ba:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6bd:	89 50 10             	mov    %edx,0x10(%eax)
f010b6c0:	eb 0f                	jmp    f010b6d1 <env_create+0x6b6>
f010b6c2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6c8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6cb:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b6d1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6d7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b6da:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b6e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b6e3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b6ea:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6f0:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b6f6:	42                   	inc    %edx
f010b6f7:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b6fd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b703:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b709:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b70f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b715:	39 c2                	cmp    %eax,%edx
f010b717:	75 1a                	jne    f010b733 <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b719:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b71f:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b725:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b72b:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b731:	eb 10                	jmp    f010b743 <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b733:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b739:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b740:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b743:	83 ec 0c             	sub    $0xc,%esp
f010b746:	6a 02                	push   $0x2
f010b748:	e8 88 3f 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010b74d:	83 c4 10             	add    $0x10,%esp
f010b750:	85 c0                	test   %eax,%eax
f010b752:	0f 84 d3 01 00 00    	je     f010b92b <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b758:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b75c:	75 17                	jne    f010b775 <env_create+0x75a>
f010b75e:	83 ec 04             	sub    $0x4,%esp
f010b761:	68 67 63 12 f0       	push   $0xf0126367
f010b766:	68 6a 01 00 00       	push   $0x16a
f010b76b:	68 df 62 12 f0       	push   $0xf01262df
f010b770:	e8 c4 4b ff ff       	call   f0100339 <_panic>
f010b775:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b778:	8b 40 10             	mov    0x10(%eax),%eax
f010b77b:	85 c0                	test   %eax,%eax
f010b77d:	74 11                	je     f010b790 <env_create+0x775>
f010b77f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b782:	8b 40 10             	mov    0x10(%eax),%eax
f010b785:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b788:	8b 52 14             	mov    0x14(%edx),%edx
f010b78b:	89 50 14             	mov    %edx,0x14(%eax)
f010b78e:	eb 12                	jmp    f010b7a2 <env_create+0x787>
f010b790:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b796:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b799:	8b 52 14             	mov    0x14(%edx),%edx
f010b79c:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b7a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7a5:	8b 40 14             	mov    0x14(%eax),%eax
f010b7a8:	85 c0                	test   %eax,%eax
f010b7aa:	74 11                	je     f010b7bd <env_create+0x7a2>
f010b7ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7af:	8b 40 14             	mov    0x14(%eax),%eax
f010b7b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7b5:	8b 52 10             	mov    0x10(%edx),%edx
f010b7b8:	89 50 10             	mov    %edx,0x10(%eax)
f010b7bb:	eb 12                	jmp    f010b7cf <env_create+0x7b4>
f010b7bd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7c3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b7c6:	8b 52 10             	mov    0x10(%edx),%edx
f010b7c9:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b7cf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7d2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b7d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b7dc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b7e3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7e9:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b7ef:	4a                   	dec    %edx
f010b7f0:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b7f6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7fc:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b802:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b808:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b80e:	39 c2                	cmp    %eax,%edx
f010b810:	0f 83 8d 00 00 00    	jae    f010b8a3 <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b816:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b81a:	75 17                	jne    f010b833 <env_create+0x818>
f010b81c:	83 ec 04             	sub    $0x4,%esp
f010b81f:	68 bc 62 12 f0       	push   $0xf01262bc
f010b824:	68 6f 01 00 00       	push   $0x16f
f010b829:	68 df 62 12 f0       	push   $0xf01262df
f010b82e:	e8 06 4b ff ff       	call   f0100339 <_panic>
f010b833:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b839:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b83f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b842:	89 50 10             	mov    %edx,0x10(%eax)
f010b845:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b848:	8b 40 10             	mov    0x10(%eax),%eax
f010b84b:	85 c0                	test   %eax,%eax
f010b84d:	74 14                	je     f010b863 <env_create+0x848>
f010b84f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b855:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b85b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b85e:	89 50 14             	mov    %edx,0x14(%eax)
f010b861:	eb 0f                	jmp    f010b872 <env_create+0x857>
f010b863:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b869:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b86c:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b872:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b878:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b87b:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b881:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b884:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b88b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b891:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b897:	42                   	inc    %edx
f010b898:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b89e:	e9 88 00 00 00       	jmp    f010b92b <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b8a3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b8a7:	75 17                	jne    f010b8c0 <env_create+0x8a5>
f010b8a9:	83 ec 04             	sub    $0x4,%esp
f010b8ac:	68 bc 62 12 f0       	push   $0xf01262bc
f010b8b1:	68 73 01 00 00       	push   $0x173
f010b8b6:	68 df 62 12 f0       	push   $0xf01262df
f010b8bb:	e8 79 4a ff ff       	call   f0100339 <_panic>
f010b8c0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8c6:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010b8cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b8cf:	89 50 10             	mov    %edx,0x10(%eax)
f010b8d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b8d5:	8b 40 10             	mov    0x10(%eax),%eax
f010b8d8:	85 c0                	test   %eax,%eax
f010b8da:	74 14                	je     f010b8f0 <env_create+0x8d5>
f010b8dc:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8e2:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b8e8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b8eb:	89 50 14             	mov    %edx,0x14(%eax)
f010b8ee:	eb 0f                	jmp    f010b8ff <env_create+0x8e4>
f010b8f0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b8f6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b8f9:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b8ff:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b905:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b908:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010b90e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b911:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b918:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b91e:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010b924:	42                   	inc    %edx
f010b925:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b92b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b931:	83 ec 04             	sub    $0x4,%esp
f010b934:	6a 01                	push   $0x1
f010b936:	ff 75 d0             	pushl  -0x30(%ebp)
f010b939:	50                   	push   %eax
f010b93a:	e8 c1 87 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b93f:	83 c4 10             	add    $0x10,%esp
f010b942:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b948:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010b94f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b952:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010b958:	0f 83 af fc ff ff    	jae    f010b60d <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b95e:	83 ec 0c             	sub    $0xc,%esp
f010b961:	6a 02                	push   $0x2
f010b963:	e8 6d 3d 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010b968:	83 c4 10             	add    $0x10,%esp
f010b96b:	85 c0                	test   %eax,%eax
f010b96d:	74 72                	je     f010b9e1 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010b96f:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b976:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b97c:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b982:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b985:	eb 2b                	jmp    f010b9b2 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b987:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b98a:	8b 10                	mov    (%eax),%edx
f010b98c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b992:	8b 40 64             	mov    0x64(%eax),%eax
f010b995:	6a 01                	push   $0x1
f010b997:	6a 00                	push   $0x0
f010b999:	52                   	push   %edx
f010b99a:	50                   	push   %eax
f010b99b:	e8 39 e3 ff ff       	call   f0109cd9 <pt_set_page_permissions>
f010b9a0:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b9a3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9a9:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b9af:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b9b2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9b8:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b9bc:	74 08                	je     f010b9c6 <env_create+0x9ab>
f010b9be:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b9c1:	8b 52 10             	mov    0x10(%edx),%edx
f010b9c4:	eb 05                	jmp    f010b9cb <env_create+0x9b0>
f010b9c6:	ba 00 00 00 00       	mov    $0x0,%edx
f010b9cb:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b9d1:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b9d7:	85 c0                	test   %eax,%eax
f010b9d9:	75 ac                	jne    f010b987 <env_create+0x96c>
f010b9db:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b9df:	75 a6                	jne    f010b987 <env_create+0x96c>
f010b9e1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b9e4:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b9e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b9ea:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b9ed:	e8 2f b8 ff ff       	call   f0107221 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b9f2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010b9f8:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b9fb:	5e                   	pop    %esi
f010b9fc:	5f                   	pop    %edi
f010b9fd:	5d                   	pop    %ebp
f010b9fe:	c3                   	ret    

f010b9ff <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b9ff:	55                   	push   %ebp
f010ba00:	89 e5                	mov    %esp,%ebp
f010ba02:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010ba05:	83 ec 0c             	sub    $0xc,%esp
f010ba08:	68 e0 15 6c f0       	push   $0xf06c15e0
f010ba0d:	e8 9d 43 00 00       	call   f010fdaf <release_spinlock>
f010ba12:	83 c4 10             	add    $0x10,%esp

	if (first)
f010ba15:	a1 60 f9 17 f0       	mov    0xf017f960,%eax
f010ba1a:	85 c0                	test   %eax,%eax
f010ba1c:	74 30                	je     f010ba4e <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010ba1e:	e8 76 00 00 00       	call   f010ba99 <get_cpu_proc>
f010ba23:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010ba26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba29:	8b 40 10             	mov    0x10(%eax),%eax
f010ba2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ba2f:	83 c2 20             	add    $0x20,%edx
f010ba32:	83 ec 04             	sub    $0x4,%esp
f010ba35:	50                   	push   %eax
f010ba36:	52                   	push   %edx
f010ba37:	68 85 63 12 f0       	push   $0xf0126385
f010ba3c:	e8 4a 55 ff ff       	call   f0100f8b <cprintf>
f010ba41:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010ba44:	c7 05 60 f9 17 f0 00 	movl   $0x0,0xf017f960
f010ba4b:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010ba4e:	90                   	nop
f010ba4f:	c9                   	leave  
f010ba50:	c3                   	ret    

f010ba51 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010ba51:	55                   	push   %ebp
f010ba52:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010ba54:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010ba55:	5d                   	pop    %ebp
f010ba56:	c3                   	ret    

f010ba57 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010ba57:	55                   	push   %ebp
f010ba58:	89 e5                	mov    %esp,%ebp
f010ba5a:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ba5d:	e8 37 00 00 00       	call   f010ba99 <get_cpu_proc>
f010ba62:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ba65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ba69:	75 19                	jne    f010ba84 <env_exit+0x2d>
f010ba6b:	68 9b 63 12 f0       	push   $0xf012639b
f010ba70:	68 ab 63 12 f0       	push   $0xf01263ab
f010ba75:	68 ed 01 00 00       	push   $0x1ed
f010ba7a:	68 df 62 12 f0       	push   $0xf01262df
f010ba7f:	e8 b5 48 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010ba84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba87:	8b 40 10             	mov    0x10(%eax),%eax
f010ba8a:	83 ec 0c             	sub    $0xc,%esp
f010ba8d:	50                   	push   %eax
f010ba8e:	e8 96 9d ff ff       	call   f0105829 <sched_exit_env>
f010ba93:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010ba96:	90                   	nop
f010ba97:	c9                   	leave  
f010ba98:	c3                   	ret    

f010ba99 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010ba99:	55                   	push   %ebp
f010ba9a:	89 e5                	mov    %esp,%ebp
f010ba9c:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010ba9f:	e8 2b b7 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010baa4:	e8 63 b6 ff ff       	call   f010710c <mycpu>
f010baa9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010baac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baaf:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bab5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010bab8:	e8 64 b7 ff ff       	call   f0107221 <popcli>
	return p;
f010babd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010bac0:	c9                   	leave  
f010bac1:	c3                   	ret    

f010bac2 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010bac2:	55                   	push   %ebp
f010bac3:	89 e5                	mov    %esp,%ebp
f010bac5:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010bac8:	e8 02 b7 ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010bacd:	e8 3a b6 ff ff       	call   f010710c <mycpu>
f010bad2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010bad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bad8:	8b 55 08             	mov    0x8(%ebp),%edx
f010badb:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010bae1:	e8 3b b7 ff ff       	call   f0107221 <popcli>
}
f010bae6:	90                   	nop
f010bae7:	c9                   	leave  
f010bae8:	c3                   	ret    

f010bae9 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010bae9:	55                   	push   %ebp
f010baea:	89 e5                	mov    %esp,%ebp
f010baec:	53                   	push   %ebx
f010baed:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010baf0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010baf4:	75 16                	jne    f010bb0c <envid2env+0x23>
		*env_store = get_cpu_proc();
f010baf6:	e8 9e ff ff ff       	call   f010ba99 <get_cpu_proc>
f010bafb:	89 c2                	mov    %eax,%edx
f010bafd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb00:	89 10                	mov    %edx,(%eax)
		return 0;
f010bb02:	b8 00 00 00 00       	mov    $0x0,%eax
f010bb07:	e9 aa 00 00 00       	jmp    f010bbb6 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010bb0c:	8b 1d f0 8a 69 f0    	mov    0xf0698af0,%ebx
f010bb12:	83 ec 0c             	sub    $0xc,%esp
f010bb15:	68 ca 02 00 00       	push   $0x2ca
f010bb1a:	e8 15 27 01 00       	call   f011e234 <nearest_pow2_ceil>
f010bb1f:	83 c4 10             	add    $0x10,%esp
f010bb22:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bb25:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb28:	21 c2                	and    %eax,%edx
f010bb2a:	89 d0                	mov    %edx,%eax
f010bb2c:	c1 e0 03             	shl    $0x3,%eax
f010bb2f:	01 d0                	add    %edx,%eax
f010bb31:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bb38:	01 c8                	add    %ecx,%eax
f010bb3a:	01 c0                	add    %eax,%eax
f010bb3c:	01 d0                	add    %edx,%eax
f010bb3e:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010bb45:	01 c8                	add    %ecx,%eax
f010bb47:	01 d0                	add    %edx,%eax
f010bb49:	01 d8                	add    %ebx,%eax
f010bb4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bb4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb51:	8b 40 18             	mov    0x18(%eax),%eax
f010bb54:	85 c0                	test   %eax,%eax
f010bb56:	74 0b                	je     f010bb63 <envid2env+0x7a>
f010bb58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb5b:	8b 40 10             	mov    0x10(%eax),%eax
f010bb5e:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bb61:	74 10                	je     f010bb73 <envid2env+0x8a>
		*env_store = 0;
f010bb63:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb66:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bb6c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bb71:	eb 43                	jmp    f010bbb6 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010bb73:	e8 21 ff ff ff       	call   f010ba99 <get_cpu_proc>
f010bb78:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010bb7b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010bb7f:	74 28                	je     f010bba9 <envid2env+0xc0>
f010bb81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb84:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010bb87:	74 20                	je     f010bba9 <envid2env+0xc0>
f010bb89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb8c:	8b 50 14             	mov    0x14(%eax),%edx
f010bb8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb92:	8b 40 10             	mov    0x10(%eax),%eax
f010bb95:	39 c2                	cmp    %eax,%edx
f010bb97:	74 10                	je     f010bba9 <envid2env+0xc0>
		*env_store = 0;
f010bb99:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb9c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bba2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bba7:	eb 0d                	jmp    f010bbb6 <envid2env+0xcd>
	}

	*env_store = e;
f010bba9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bbaf:	89 10                	mov    %edx,(%eax)
	return 0;
f010bbb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bbb6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bbb9:	c9                   	leave  
f010bbba:	c3                   	ret    

f010bbbb <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010bbbb:	55                   	push   %ebp
f010bbbc:	89 e5                	mov    %esp,%ebp
f010bbbe:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bbc1:	83 ec 0c             	sub    $0xc,%esp
f010bbc4:	68 e0 15 6c f0       	push   $0xf06c15e0
f010bbc9:	e8 5a 41 00 00       	call   f010fd28 <acquire_spinlock>
f010bbce:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bbd1:	e8 c3 fe ff ff       	call   f010ba99 <get_cpu_proc>
f010bbd6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bbd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bbdd:	75 19                	jne    f010bbf8 <yield+0x3d>
f010bbdf:	68 c0 63 12 f0       	push   $0xf01263c0
f010bbe4:	68 ab 63 12 f0       	push   $0xf01263ab
f010bbe9:	68 4c 02 00 00       	push   $0x24c
f010bbee:	68 df 62 12 f0       	push   $0xf01262df
f010bbf3:	e8 41 47 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010bbf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bbfb:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010bc02:	e8 13 00 00 00       	call   f010bc1a <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010bc07:	83 ec 0c             	sub    $0xc,%esp
f010bc0a:	68 e0 15 6c f0       	push   $0xf06c15e0
f010bc0f:	e8 9b 41 00 00       	call   f010fdaf <release_spinlock>
f010bc14:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bc17:	90                   	nop
f010bc18:	c9                   	leave  
f010bc19:	c3                   	ret    

f010bc1a <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bc1a:	55                   	push   %ebp
f010bc1b:	89 e5                	mov    %esp,%ebp
f010bc1d:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bc20:	e8 74 fe ff ff       	call   f010ba99 <get_cpu_proc>
f010bc25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bc28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bc2c:	75 19                	jne    f010bc47 <sched+0x2d>
f010bc2e:	68 c0 63 12 f0       	push   $0xf01263c0
f010bc33:	68 ab 63 12 f0       	push   $0xf01263ab
f010bc38:	68 60 02 00 00       	push   $0x260
f010bc3d:	68 df 62 12 f0       	push   $0xf01262df
f010bc42:	e8 f2 46 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010bc47:	83 ec 0c             	sub    $0xc,%esp
f010bc4a:	68 e0 15 6c f0       	push   $0xf06c15e0
f010bc4f:	e8 ed 42 00 00       	call   f010ff41 <holding_spinlock>
f010bc54:	83 c4 10             	add    $0x10,%esp
f010bc57:	85 c0                	test   %eax,%eax
f010bc59:	75 17                	jne    f010bc72 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bc5b:	83 ec 04             	sub    $0x4,%esp
f010bc5e:	68 cc 63 12 f0       	push   $0xf01263cc
f010bc63:	68 64 02 00 00       	push   $0x264
f010bc68:	68 df 62 12 f0       	push   $0xf01262df
f010bc6d:	e8 c7 46 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010bc72:	e8 95 b4 ff ff       	call   f010710c <mycpu>
f010bc77:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bc7d:	83 f8 01             	cmp    $0x1,%eax
f010bc80:	74 20                	je     f010bca2 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bc82:	e8 85 b4 ff ff       	call   f010710c <mycpu>
f010bc87:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bc8d:	50                   	push   %eax
f010bc8e:	68 0e 64 12 f0       	push   $0xf012640e
f010bc93:	68 67 02 00 00       	push   $0x267
f010bc98:	68 df 62 12 f0       	push   $0xf01262df
f010bc9d:	e8 97 46 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bca2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bca5:	8b 40 18             	mov    0x18(%eax),%eax
f010bca8:	83 f8 02             	cmp    $0x2,%eax
f010bcab:	75 17                	jne    f010bcc4 <sched+0xaa>
		panic("sched a running process");
f010bcad:	83 ec 04             	sub    $0x4,%esp
f010bcb0:	68 25 64 12 f0       	push   $0xf0126425
f010bcb5:	68 6a 02 00 00       	push   $0x26a
f010bcba:	68 df 62 12 f0       	push   $0xf01262df
f010bcbf:	e8 75 46 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bcc4:	9c                   	pushf  
f010bcc5:	58                   	pop    %eax
f010bcc6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bcc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bccc:	25 00 02 00 00       	and    $0x200,%eax
f010bcd1:	85 c0                	test   %eax,%eax
f010bcd3:	74 17                	je     f010bcec <sched+0xd2>
		panic("sched is interruptible!");
f010bcd5:	83 ec 04             	sub    $0x4,%esp
f010bcd8:	68 3d 64 12 f0       	push   $0xf012643d
f010bcdd:	68 6c 02 00 00       	push   $0x26c
f010bce2:	68 df 62 12 f0       	push   $0xf01262df
f010bce7:	e8 4d 46 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010bcec:	e8 1b b4 ff ff       	call   f010710c <mycpu>
f010bcf1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bcf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bcfa:	e8 0d b4 ff ff       	call   f010710c <mycpu>
f010bcff:	8b 40 04             	mov    0x4(%eax),%eax
f010bd02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd05:	83 c2 04             	add    $0x4,%edx
f010bd08:	83 ec 08             	sub    $0x8,%esp
f010bd0b:	50                   	push   %eax
f010bd0c:	52                   	push   %edx
f010bd0d:	e8 5f 8e ff ff       	call   f0104b71 <context_switch>
f010bd12:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bd15:	e8 f2 b3 ff ff       	call   f010710c <mycpu>
f010bd1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bd1d:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bd23:	90                   	nop
f010bd24:	c9                   	leave  
f010bd25:	c3                   	ret    

f010bd26 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bd26:	55                   	push   %ebp
f010bd27:	89 e5                	mov    %esp,%ebp
f010bd29:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bd2c:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f010bd31:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bd34:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bd37:	0f 22 d8             	mov    %eax,%cr3
}
f010bd3a:	90                   	nop
f010bd3b:	c9                   	leave  
f010bd3c:	c3                   	ret    

f010bd3d <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bd3d:	55                   	push   %ebp
f010bd3e:	89 e5                	mov    %esp,%ebp
f010bd40:	53                   	push   %ebx
f010bd41:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bd44:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bd48:	75 17                	jne    f010bd61 <switchuvm+0x24>
		panic("switchuvm: no process");
f010bd4a:	83 ec 04             	sub    $0x4,%esp
f010bd4d:	68 55 64 12 f0       	push   $0xf0126455
f010bd52:	68 81 02 00 00       	push   $0x281
f010bd57:	68 df 62 12 f0       	push   $0xf01262df
f010bd5c:	e8 d8 45 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010bd61:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd64:	8b 40 70             	mov    0x70(%eax),%eax
f010bd67:	85 c0                	test   %eax,%eax
f010bd69:	75 17                	jne    f010bd82 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bd6b:	83 ec 04             	sub    $0x4,%esp
f010bd6e:	68 6b 64 12 f0       	push   $0xf012646b
f010bd73:	68 83 02 00 00       	push   $0x283
f010bd78:	68 df 62 12 f0       	push   $0xf01262df
f010bd7d:	e8 b7 45 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010bd82:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd85:	8b 40 64             	mov    0x64(%eax),%eax
f010bd88:	85 c0                	test   %eax,%eax
f010bd8a:	75 17                	jne    f010bda3 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010bd8c:	83 ec 04             	sub    $0x4,%esp
f010bd8f:	68 80 64 12 f0       	push   $0xf0126480
f010bd94:	68 85 02 00 00       	push   $0x285
f010bd99:	68 df 62 12 f0       	push   $0xf01262df
f010bd9e:	e8 96 45 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010bda3:	e8 27 b4 ff ff       	call   f01071cf <pushcli>
	struct cpu* c = mycpu();
f010bda8:	e8 5f b3 ff ff       	call   f010710c <mycpu>
f010bdad:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010bdb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdb3:	8b 55 08             	mov    0x8(%ebp),%edx
f010bdb6:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bdbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdbf:	83 c0 0c             	add    $0xc,%eax
f010bdc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdc5:	83 c2 0c             	add    $0xc,%edx
f010bdc8:	c1 ea 10             	shr    $0x10,%edx
f010bdcb:	88 d3                	mov    %dl,%bl
f010bdcd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdd0:	83 c2 0c             	add    $0xc,%edx
f010bdd3:	c1 ea 18             	shr    $0x18,%edx
f010bdd6:	88 d1                	mov    %dl,%cl
f010bdd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bddb:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bde2:	68 00 
f010bde4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bde7:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bdee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdf1:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bdf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdfa:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be00:	83 e2 f0             	and    $0xfffffff0,%edx
f010be03:	83 ca 09             	or     $0x9,%edx
f010be06:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be0f:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be15:	83 ca 10             	or     $0x10,%edx
f010be18:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be21:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be27:	83 e2 9f             	and    $0xffffff9f,%edx
f010be2a:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be33:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be39:	83 ca 80             	or     $0xffffff80,%edx
f010be3c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be45:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be4b:	83 e2 f0             	and    $0xfffffff0,%edx
f010be4e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be57:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be5d:	83 e2 ef             	and    $0xffffffef,%edx
f010be60:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be69:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be6f:	83 e2 df             	and    $0xffffffdf,%edx
f010be72:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be7b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be81:	83 ca 40             	or     $0x40,%edx
f010be84:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be8d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be93:	83 e2 7f             	and    $0x7f,%edx
f010be96:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be9f:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010bea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bea8:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010beae:	83 e2 ef             	and    $0xffffffef,%edx
f010beb1:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010beb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010beba:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bec0:	8b 40 70             	mov    0x70(%eax),%eax
f010bec3:	05 00 80 00 00       	add    $0x8000,%eax
f010bec8:	89 c2                	mov    %eax,%edx
f010beca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010becd:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010bed0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bed3:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010bed9:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010bedf:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010bee3:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010bee6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bee9:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010beef:	8b 40 68             	mov    0x68(%eax),%eax
f010bef2:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bef5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bef8:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010befb:	e8 21 b3 ff ff       	call   f0107221 <popcli>
}
f010bf00:	90                   	nop
f010bf01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bf04:	c9                   	leave  
f010bf05:	c3                   	ret    

f010bf06 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010bf06:	55                   	push   %ebp
f010bf07:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010bf09:	8b 15 f4 8a 69 f0    	mov    0xf0698af4,%edx
f010bf0f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf12:	89 10                	mov    %edx,(%eax)
f010bf14:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf17:	8b 00                	mov    (%eax),%eax
f010bf19:	85 c0                	test   %eax,%eax
f010bf1b:	75 07                	jne    f010bf24 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010bf1d:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010bf22:	eb 11                	jmp    f010bf35 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010bf24:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf27:	8b 00                	mov    (%eax),%eax
f010bf29:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010bf30:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bf35:	5d                   	pop    %ebp
f010bf36:	c3                   	ret    

f010bf37 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010bf37:	55                   	push   %ebp
f010bf38:	89 e5                	mov    %esp,%ebp
f010bf3a:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010bf3d:	83 ec 04             	sub    $0x4,%esp
f010bf40:	68 bc 05 00 00       	push   $0x5bc
f010bf45:	6a 00                	push   $0x0
f010bf47:	ff 75 08             	pushl  0x8(%ebp)
f010bf4a:	e8 75 3f 01 00       	call   f011fec4 <memset>
f010bf4f:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010bf52:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf55:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010bf5c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bf60:	75 17                	jne    f010bf79 <free_environment+0x42>
f010bf62:	83 ec 04             	sub    $0x4,%esp
f010bf65:	68 bc 62 12 f0       	push   $0xf01262bc
f010bf6a:	68 c0 02 00 00       	push   $0x2c0
f010bf6f:	68 df 62 12 f0       	push   $0xf01262df
f010bf74:	e8 c0 43 ff ff       	call   f0100339 <_panic>
f010bf79:	8b 15 f4 8a 69 f0    	mov    0xf0698af4,%edx
f010bf7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf82:	89 50 08             	mov    %edx,0x8(%eax)
f010bf85:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf88:	8b 40 08             	mov    0x8(%eax),%eax
f010bf8b:	85 c0                	test   %eax,%eax
f010bf8d:	74 0d                	je     f010bf9c <free_environment+0x65>
f010bf8f:	a1 f4 8a 69 f0       	mov    0xf0698af4,%eax
f010bf94:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf97:	89 50 0c             	mov    %edx,0xc(%eax)
f010bf9a:	eb 08                	jmp    f010bfa4 <free_environment+0x6d>
f010bf9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf9f:	a3 f8 8a 69 f0       	mov    %eax,0xf0698af8
f010bfa4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfa7:	a3 f4 8a 69 f0       	mov    %eax,0xf0698af4
f010bfac:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfaf:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bfb6:	a1 00 8b 69 f0       	mov    0xf0698b00,%eax
f010bfbb:	40                   	inc    %eax
f010bfbc:	a3 00 8b 69 f0       	mov    %eax,0xf0698b00
}
f010bfc1:	90                   	nop
f010bfc2:	c9                   	leave  
f010bfc3:	c3                   	ret    

f010bfc4 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010bfc4:	55                   	push   %ebp
f010bfc5:	89 e5                	mov    %esp,%ebp
f010bfc7:	53                   	push   %ebx
f010bfc8:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010bfcb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bfce:	8b 40 0c             	mov    0xc(%eax),%eax
f010bfd1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010bfd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bfd7:	8b 40 08             	mov    0x8(%eax),%eax
f010bfda:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010bfdd:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010bfe4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010bfe7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bfea:	01 c2                	add    %eax,%edx
f010bfec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bfef:	01 d0                	add    %edx,%eax
f010bff1:	48                   	dec    %eax
f010bff2:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bff5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bff8:	ba 00 00 00 00       	mov    $0x0,%edx
f010bffd:	f7 75 dc             	divl   -0x24(%ebp)
f010c000:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c003:	29 d0                	sub    %edx,%eax
f010c005:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010c008:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c00b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010c00e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c011:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c016:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010c019:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010c020:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010c027:	8b 45 10             	mov    0x10(%ebp),%eax
f010c02a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010c030:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010c037:	0f 85 f5 03 00 00    	jne    f010c432 <program_segment_alloc_map_copy_workingset+0x46e>
f010c03d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c040:	83 c0 20             	add    $0x20,%eax
f010c043:	83 ec 08             	sub    $0x8,%esp
f010c046:	68 94 64 12 f0       	push   $0xf0126494
f010c04b:	50                   	push   %eax
f010c04c:	e8 91 3d 01 00       	call   f011fde2 <strcmp>
f010c051:	83 c4 10             	add    $0x10,%esp
f010c054:	85 c0                	test   %eax,%eax
f010c056:	0f 84 d6 03 00 00    	je     f010c432 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010c05c:	8b 45 14             	mov    0x14(%ebp),%eax
f010c05f:	83 f8 06             	cmp    $0x6,%eax
f010c062:	76 05                	jbe    f010c069 <program_segment_alloc_map_copy_workingset+0xa5>
f010c064:	b8 06 00 00 00       	mov    $0x6,%eax
f010c069:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c06c:	e9 c1 03 00 00       	jmp    f010c432 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010c071:	83 ec 0c             	sub    $0xc,%esp
f010c074:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010c077:	50                   	push   %eax
f010c078:	e8 35 c1 ff ff       	call   f01081b2 <allocate_frame>
f010c07d:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010c080:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010c083:	8b 45 08             	mov    0x8(%ebp),%eax
f010c086:	8b 40 64             	mov    0x64(%eax),%eax
f010c089:	6a 06                	push   $0x6
f010c08b:	ff 75 f4             	pushl  -0xc(%ebp)
f010c08e:	52                   	push   %edx
f010c08f:	50                   	push   %eax
f010c090:	e8 ee c7 ff ff       	call   f0108883 <loadtime_map_frame>
f010c095:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c098:	83 ec 08             	sub    $0x8,%esp
f010c09b:	ff 75 f4             	pushl  -0xc(%ebp)
f010c09e:	ff 75 08             	pushl  0x8(%ebp)
f010c0a1:	e8 69 de ff ff       	call   f0109f0f <env_page_ws_list_create_element>
f010c0a6:	83 c4 10             	add    $0x10,%esp
f010c0a9:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c0ac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0af:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c0b6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c0ba:	75 17                	jne    f010c0d3 <program_segment_alloc_map_copy_workingset+0x10f>
f010c0bc:	83 ec 04             	sub    $0x4,%esp
f010c0bf:	68 44 63 12 f0       	push   $0xf0126344
f010c0c4:	68 ea 02 00 00       	push   $0x2ea
f010c0c9:	68 df 62 12 f0       	push   $0xf01262df
f010c0ce:	e8 66 42 ff ff       	call   f0100339 <_panic>
f010c0d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0d6:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010c0dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0df:	89 50 14             	mov    %edx,0x14(%eax)
f010c0e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0e5:	8b 40 14             	mov    0x14(%eax),%eax
f010c0e8:	85 c0                	test   %eax,%eax
f010c0ea:	74 11                	je     f010c0fd <program_segment_alloc_map_copy_workingset+0x139>
f010c0ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0ef:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010c0f5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0f8:	89 50 10             	mov    %edx,0x10(%eax)
f010c0fb:	eb 0c                	jmp    f010c109 <program_segment_alloc_map_copy_workingset+0x145>
f010c0fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c100:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c103:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c109:	8b 45 08             	mov    0x8(%ebp),%eax
f010c10c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c10f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c115:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c118:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c11f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c122:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c128:	8d 50 01             	lea    0x1(%eax),%edx
f010c12b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c12e:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c134:	83 ec 0c             	sub    $0xc,%esp
f010c137:	6a 02                	push   $0x2
f010c139:	e8 97 35 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010c13e:	83 c4 10             	add    $0x10,%esp
f010c141:	85 c0                	test   %eax,%eax
f010c143:	0f 84 b3 01 00 00    	je     f010c2fc <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c149:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c14d:	75 17                	jne    f010c166 <program_segment_alloc_map_copy_workingset+0x1a2>
f010c14f:	83 ec 04             	sub    $0x4,%esp
f010c152:	68 67 63 12 f0       	push   $0xf0126367
f010c157:	68 f6 02 00 00       	push   $0x2f6
f010c15c:	68 df 62 12 f0       	push   $0xf01262df
f010c161:	e8 d3 41 ff ff       	call   f0100339 <_panic>
f010c166:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c169:	8b 40 10             	mov    0x10(%eax),%eax
f010c16c:	85 c0                	test   %eax,%eax
f010c16e:	74 11                	je     f010c181 <program_segment_alloc_map_copy_workingset+0x1bd>
f010c170:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c173:	8b 40 10             	mov    0x10(%eax),%eax
f010c176:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c179:	8b 52 14             	mov    0x14(%edx),%edx
f010c17c:	89 50 14             	mov    %edx,0x14(%eax)
f010c17f:	eb 0f                	jmp    f010c190 <program_segment_alloc_map_copy_workingset+0x1cc>
f010c181:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c184:	8b 50 14             	mov    0x14(%eax),%edx
f010c187:	8b 45 08             	mov    0x8(%ebp),%eax
f010c18a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c190:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c193:	8b 40 14             	mov    0x14(%eax),%eax
f010c196:	85 c0                	test   %eax,%eax
f010c198:	74 11                	je     f010c1ab <program_segment_alloc_map_copy_workingset+0x1e7>
f010c19a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c19d:	8b 40 14             	mov    0x14(%eax),%eax
f010c1a0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1a3:	8b 52 10             	mov    0x10(%edx),%edx
f010c1a6:	89 50 10             	mov    %edx,0x10(%eax)
f010c1a9:	eb 0f                	jmp    f010c1ba <program_segment_alloc_map_copy_workingset+0x1f6>
f010c1ab:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1ae:	8b 50 10             	mov    0x10(%eax),%edx
f010c1b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b4:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c1ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1bd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c1c4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1c7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c1ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1d1:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c1d7:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c1da:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1dd:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c1e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e6:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010c1ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1ef:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c1f5:	48                   	dec    %eax
f010c1f6:	39 c2                	cmp    %eax,%edx
f010c1f8:	0f 83 80 00 00 00    	jae    f010c27e <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c1fe:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c202:	75 17                	jne    f010c21b <program_segment_alloc_map_copy_workingset+0x257>
f010c204:	83 ec 04             	sub    $0x4,%esp
f010c207:	68 bc 62 12 f0       	push   $0xf01262bc
f010c20c:	68 fa 02 00 00       	push   $0x2fa
f010c211:	68 df 62 12 f0       	push   $0xf01262df
f010c216:	e8 1e 41 ff ff       	call   f0100339 <_panic>
f010c21b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c21e:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c224:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c227:	89 50 10             	mov    %edx,0x10(%eax)
f010c22a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c22d:	8b 40 10             	mov    0x10(%eax),%eax
f010c230:	85 c0                	test   %eax,%eax
f010c232:	74 11                	je     f010c245 <program_segment_alloc_map_copy_workingset+0x281>
f010c234:	8b 45 08             	mov    0x8(%ebp),%eax
f010c237:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c23d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c240:	89 50 14             	mov    %edx,0x14(%eax)
f010c243:	eb 0c                	jmp    f010c251 <program_segment_alloc_map_copy_workingset+0x28d>
f010c245:	8b 45 08             	mov    0x8(%ebp),%eax
f010c248:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c24b:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c251:	8b 45 08             	mov    0x8(%ebp),%eax
f010c254:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c257:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010c25d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c267:	8b 45 08             	mov    0x8(%ebp),%eax
f010c26a:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010c270:	8d 50 01             	lea    0x1(%eax),%edx
f010c273:	8b 45 08             	mov    0x8(%ebp),%eax
f010c276:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c27c:	eb 7e                	jmp    f010c2fc <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c27e:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c282:	75 17                	jne    f010c29b <program_segment_alloc_map_copy_workingset+0x2d7>
f010c284:	83 ec 04             	sub    $0x4,%esp
f010c287:	68 bc 62 12 f0       	push   $0xf01262bc
f010c28c:	68 ff 02 00 00       	push   $0x2ff
f010c291:	68 df 62 12 f0       	push   $0xf01262df
f010c296:	e8 9e 40 ff ff       	call   f0100339 <_panic>
f010c29b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c29e:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c2a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2a7:	89 50 10             	mov    %edx,0x10(%eax)
f010c2aa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2ad:	8b 40 10             	mov    0x10(%eax),%eax
f010c2b0:	85 c0                	test   %eax,%eax
f010c2b2:	74 11                	je     f010c2c5 <program_segment_alloc_map_copy_workingset+0x301>
f010c2b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2b7:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c2bd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2c0:	89 50 14             	mov    %edx,0x14(%eax)
f010c2c3:	eb 0c                	jmp    f010c2d1 <program_segment_alloc_map_copy_workingset+0x30d>
f010c2c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2cb:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c2d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2d4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2d7:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c2dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2e0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c2e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2ea:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010c2f0:	8d 50 01             	lea    0x1(%eax),%edx
f010c2f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f6:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c2fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2ff:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c305:	8b 45 08             	mov    0x8(%ebp),%eax
f010c308:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c30e:	39 c2                	cmp    %eax,%edx
f010c310:	75 14                	jne    f010c326 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c312:	8b 45 08             	mov    0x8(%ebp),%eax
f010c315:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c31b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c31e:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c324:	eb 0d                	jmp    f010c333 <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c326:	8b 45 08             	mov    0x8(%ebp),%eax
f010c329:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c330:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c336:	c1 e8 16             	shr    $0x16,%eax
f010c339:	89 c2                	mov    %eax,%edx
f010c33b:	8b 45 18             	mov    0x18(%ebp),%eax
f010c33e:	8b 00                	mov    (%eax),%eax
f010c340:	39 c2                	cmp    %eax,%edx
f010c342:	0f 84 d3 00 00 00    	je     f010c41b <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c348:	8b 45 08             	mov    0x8(%ebp),%eax
f010c34b:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c351:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c354:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c357:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c35a:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c35f:	89 c1                	mov    %eax,%ecx
f010c361:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c364:	89 d0                	mov    %edx,%eax
f010c366:	01 c0                	add    %eax,%eax
f010c368:	01 d0                	add    %edx,%eax
f010c36a:	c1 e0 03             	shl    $0x3,%eax
f010c36d:	01 d8                	add    %ebx,%eax
f010c36f:	05 ac 00 00 00       	add    $0xac,%eax
f010c374:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c376:	8b 45 08             	mov    0x8(%ebp),%eax
f010c379:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c37f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c382:	89 d0                	mov    %edx,%eax
f010c384:	01 c0                	add    %eax,%eax
f010c386:	01 d0                	add    %edx,%eax
f010c388:	c1 e0 03             	shl    $0x3,%eax
f010c38b:	01 c8                	add    %ecx,%eax
f010c38d:	05 b0 00 00 00       	add    $0xb0,%eax
f010c392:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c395:	8b 45 08             	mov    0x8(%ebp),%eax
f010c398:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010c39e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c3a1:	89 d0                	mov    %edx,%eax
f010c3a3:	01 c0                	add    %eax,%eax
f010c3a5:	01 d0                	add    %edx,%eax
f010c3a7:	c1 e0 03             	shl    $0x3,%eax
f010c3aa:	01 c8                	add    %ecx,%eax
f010c3ac:	05 b4 00 00 00       	add    $0xb4,%eax
f010c3b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c3b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ba:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c3c0:	8d 50 01             	lea    0x1(%eax),%edx
f010c3c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3c6:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c3cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3cf:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c3d5:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c3da:	ba 00 00 00 00       	mov    $0x0,%edx
f010c3df:	f7 f1                	div    %ecx
f010c3e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3e4:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010c3ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ed:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010c3f3:	85 c0                	test   %eax,%eax
f010c3f5:	75 17                	jne    f010c40e <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c3f7:	83 ec 04             	sub    $0x4,%esp
f010c3fa:	68 98 64 12 f0       	push   $0xf0126498
f010c3ff:	68 27 03 00 00       	push   $0x327
f010c404:	68 df 62 12 f0       	push   $0xf01262df
f010c409:	e8 2b 3f ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c40e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c411:	c1 e8 16             	shr    $0x16,%eax
f010c414:	89 c2                	mov    %eax,%edx
f010c416:	8b 45 18             	mov    0x18(%ebp),%eax
f010c419:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c41b:	8b 45 10             	mov    0x10(%ebp),%eax
f010c41e:	8b 00                	mov    (%eax),%eax
f010c420:	8d 50 01             	lea    0x1(%eax),%edx
f010c423:	8b 45 10             	mov    0x10(%ebp),%eax
f010c426:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c428:	ff 45 f0             	incl   -0x10(%ebp)
f010c42b:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c432:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c435:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c438:	73 0c                	jae    f010c446 <program_segment_alloc_map_copy_workingset+0x482>
f010c43a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c43d:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c440:	0f 82 2b fc ff ff    	jb     f010c071 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c446:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c449:	8b 00                	mov    (%eax),%eax
f010c44b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c44e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c451:	8b 40 0c             	mov    0xc(%eax),%eax
f010c454:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c457:	eb 10                	jmp    f010c469 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c459:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c45c:	8a 10                	mov    (%eax),%dl
f010c45e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c461:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c463:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c466:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c46c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c46f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c472:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c477:	89 c2                	mov    %eax,%edx
f010c479:	8b 45 10             	mov    0x10(%ebp),%eax
f010c47c:	8b 00                	mov    (%eax),%eax
f010c47e:	c1 e0 0c             	shl    $0xc,%eax
f010c481:	01 c2                	add    %eax,%edx
f010c483:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c486:	39 c2                	cmp    %eax,%edx
f010c488:	76 1d                	jbe    f010c4a7 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c48a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c48d:	8b 50 04             	mov    0x4(%eax),%edx
f010c490:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c493:	01 c2                	add    %eax,%edx
f010c495:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c498:	39 c2                	cmp    %eax,%edx
f010c49a:	77 bd                	ja     f010c459 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c49c:	eb 09                	jmp    f010c4a7 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c49e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c4a1:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c4a4:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c4a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c4aa:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c4ad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c4b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c4b5:	89 c2                	mov    %eax,%edx
f010c4b7:	8b 45 10             	mov    0x10(%ebp),%eax
f010c4ba:	8b 00                	mov    (%eax),%eax
f010c4bc:	c1 e0 0c             	shl    $0xc,%eax
f010c4bf:	01 c2                	add    %eax,%edx
f010c4c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c4c4:	39 c2                	cmp    %eax,%edx
f010c4c6:	77 d6                	ja     f010c49e <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c4c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c4cd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c4d0:	c9                   	leave  
f010c4d1:	c3                   	ret    

f010c4d2 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c4d2:	55                   	push   %ebp
f010c4d3:	89 e5                	mov    %esp,%ebp
f010c4d5:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c4d8:	83 ec 0c             	sub    $0xc,%esp
f010c4db:	68 00 10 00 00       	push   $0x1000
f010c4e0:	e8 ba d0 ff ff       	call   f010959f <kmalloc>
f010c4e5:	83 c4 10             	add    $0x10,%esp
f010c4e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c4eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c4ef:	75 17                	jne    f010c508 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c4f1:	83 ec 04             	sub    $0x4,%esp
f010c4f4:	68 3b 65 12 f0       	push   $0xf012653b
f010c4f9:	68 57 03 00 00       	push   $0x357
f010c4fe:	68 df 62 12 f0       	push   $0xf01262df
f010c503:	e8 31 3e ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c508:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c50b:	c9                   	leave  
f010c50c:	c3                   	ret    

f010c50d <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c50d:	55                   	push   %ebp
f010c50e:	89 e5                	mov    %esp,%ebp
f010c510:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010c513:	83 ec 0c             	sub    $0xc,%esp
f010c516:	68 00 80 00 00       	push   $0x8000
f010c51b:	e8 7f d0 ff ff       	call   f010959f <kmalloc>
f010c520:	83 c4 10             	add    $0x10,%esp
f010c523:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010c526:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010c52d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c530:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010c535:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010c538:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c53b:	ba 00 00 00 00       	mov    $0x0,%edx
f010c540:	f7 75 ec             	divl   -0x14(%ebp)
f010c543:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c546:	29 d0                	sub    %edx,%eax
f010c548:	85 c0                	test   %eax,%eax
f010c54a:	79 05                	jns    f010c551 <create_user_kern_stack+0x44>
f010c54c:	05 ff 0f 00 00       	add    $0xfff,%eax
f010c551:	c1 f8 0c             	sar    $0xc,%eax
f010c554:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010c557:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010c55e:	eb 72                	jmp    f010c5d2 <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010c560:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010c567:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c56a:	c1 e0 0c             	shl    $0xc,%eax
f010c56d:	89 c2                	mov    %eax,%edx
f010c56f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c572:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010c575:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010c57a:	83 ec 04             	sub    $0x4,%esp
f010c57d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010c580:	52                   	push   %edx
f010c581:	51                   	push   %ecx
f010c582:	50                   	push   %eax
f010c583:	e8 e1 c1 ff ff       	call   f0108769 <get_frame_info>
f010c588:	83 c4 10             	add    $0x10,%esp
f010c58b:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010c58e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c591:	c1 e0 0c             	shl    $0xc,%eax
f010c594:	89 c2                	mov    %eax,%edx
f010c596:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c599:	01 d0                	add    %edx,%eax
f010c59b:	6a 01                	push   $0x1
f010c59d:	50                   	push   %eax
f010c59e:	ff 75 e0             	pushl  -0x20(%ebp)
f010c5a1:	ff 75 08             	pushl  0x8(%ebp)
f010c5a4:	e8 d6 c0 ff ff       	call   f010867f <map_frame>
f010c5a9:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010c5ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c5b0:	75 1d                	jne    f010c5cf <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010c5b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5b5:	c1 e0 0c             	shl    $0xc,%eax
f010c5b8:	89 c2                	mov    %eax,%edx
f010c5ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c5bd:	01 d0                	add    %edx,%eax
f010c5bf:	6a 01                	push   $0x1
f010c5c1:	6a 00                	push   $0x0
f010c5c3:	50                   	push   %eax
f010c5c4:	ff 75 08             	pushl  0x8(%ebp)
f010c5c7:	e8 0d d7 ff ff       	call   f0109cd9 <pt_set_page_permissions>
f010c5cc:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010c5cf:	ff 45 f4             	incl   -0xc(%ebp)
f010c5d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5d5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010c5d8:	72 86                	jb     f010c560 <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010c5da:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010c5dd:	c9                   	leave  
f010c5de:	c3                   	ret    

f010c5df <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c5df:	55                   	push   %ebp
f010c5e0:	89 e5                	mov    %esp,%ebp
f010c5e2:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c5e5:	83 ec 04             	sub    $0x4,%esp
f010c5e8:	68 58 65 12 f0       	push   $0xf0126558
f010c5ed:	68 8e 03 00 00       	push   $0x38e
f010c5f2:	68 df 62 12 f0       	push   $0xf01262df
f010c5f7:	e8 3d 3d ff ff       	call   f0100339 <_panic>

f010c5fc <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010c5fc:	55                   	push   %ebp
f010c5fd:	89 e5                	mov    %esp,%ebp
f010c5ff:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010c602:	8b 45 08             	mov    0x8(%ebp),%eax
f010c605:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c608:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010c60b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c60e:	8b 55 10             	mov    0x10(%ebp),%edx
f010c611:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010c614:	8b 45 08             	mov    0x8(%ebp),%eax
f010c617:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c61a:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010c61d:	83 ec 08             	sub    $0x8,%esp
f010c620:	6a 00                	push   $0x0
f010c622:	ff 75 0c             	pushl  0xc(%ebp)
f010c625:	e8 7b 42 01 00       	call   f01208a5 <initialize_dynamic_allocator>
f010c62a:	83 c4 10             	add    $0x10,%esp
}
f010c62d:	90                   	nop
f010c62e:	c9                   	leave  
f010c62f:	c3                   	ret    

f010c630 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c630:	55                   	push   %ebp
f010c631:	89 e5                	mov    %esp,%ebp
f010c633:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c636:	8b 45 08             	mov    0x8(%ebp),%eax
f010c639:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c63c:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c63f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c642:	8b 55 10             	mov    0x10(%ebp),%edx
f010c645:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c648:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c64f:	eb 17                	jmp    f010c668 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c651:	8b 45 08             	mov    0x8(%ebp),%eax
f010c654:	8b 40 64             	mov    0x64(%eax),%eax
f010c657:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c65a:	c1 e2 02             	shl    $0x2,%edx
f010c65d:	01 d0                	add    %edx,%eax
f010c65f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c665:	ff 45 f4             	incl   -0xc(%ebp)
f010c668:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c66b:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c670:	76 df                	jbe    f010c651 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c672:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c679:	eb 22                	jmp    f010c69d <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c67b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c67e:	8b 40 64             	mov    0x64(%eax),%eax
f010c681:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c684:	c1 e2 02             	shl    $0x2,%edx
f010c687:	01 c2                	add    %eax,%edx
f010c689:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f010c68e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c691:	c1 e1 02             	shl    $0x2,%ecx
f010c694:	01 c8                	add    %ecx,%eax
f010c696:	8b 00                	mov    (%eax),%eax
f010c698:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c69a:	ff 45 f4             	incl   -0xc(%ebp)
f010c69d:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c6a4:	7e d5                	jle    f010c67b <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c6a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6a9:	8b 40 64             	mov    0x64(%eax),%eax
f010c6ac:	83 ec 0c             	sub    $0xc,%esp
f010c6af:	50                   	push   %eax
f010c6b0:	e8 58 fe ff ff       	call   f010c50d <create_user_kern_stack>
f010c6b5:	83 c4 10             	add    $0x10,%esp
f010c6b8:	89 c2                	mov    %eax,%edx
f010c6ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6bd:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c6c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6c3:	8b 40 70             	mov    0x70(%eax),%eax
f010c6c6:	05 00 80 00 00       	add    $0x8000,%eax
f010c6cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c6ce:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c6d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c6d8:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c6da:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c6de:	ba 1e e7 10 f0       	mov    $0xf010e71e,%edx
f010c6e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c6e6:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c6e8:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c6ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c6f2:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c6f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6f8:	8b 40 04             	mov    0x4(%eax),%eax
f010c6fb:	83 ec 04             	sub    $0x4,%esp
f010c6fe:	6a 20                	push   $0x20
f010c700:	6a 00                	push   $0x0
f010c702:	50                   	push   %eax
f010c703:	e8 bc 37 01 00       	call   f011fec4 <memset>
f010c708:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c70b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c70e:	8b 40 04             	mov    0x4(%eax),%eax
f010c711:	ba ff b9 10 f0       	mov    $0xf010b9ff,%edx
f010c716:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c719:	8b 45 08             	mov    0x8(%ebp),%eax
f010c71c:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c723:	00 00 00 
f010c726:	8b 45 08             	mov    0x8(%ebp),%eax
f010c729:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c730:	00 00 00 
f010c733:	8b 45 08             	mov    0x8(%ebp),%eax
f010c736:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c73d:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c740:	83 ec 0c             	sub    $0xc,%esp
f010c743:	6a 02                	push   $0x2
f010c745:	e8 8b 2f 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010c74a:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c74d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c754:	eb 54                	jmp    f010c7aa <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c756:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c759:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c75c:	89 d0                	mov    %edx,%eax
f010c75e:	01 c0                	add    %eax,%eax
f010c760:	01 d0                	add    %edx,%eax
f010c762:	c1 e0 03             	shl    $0x3,%eax
f010c765:	01 c8                	add    %ecx,%eax
f010c767:	05 ac 00 00 00       	add    $0xac,%eax
f010c76c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c772:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c775:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c778:	89 d0                	mov    %edx,%eax
f010c77a:	01 c0                	add    %eax,%eax
f010c77c:	01 d0                	add    %edx,%eax
f010c77e:	c1 e0 03             	shl    $0x3,%eax
f010c781:	01 c8                	add    %ecx,%eax
f010c783:	05 b0 00 00 00       	add    $0xb0,%eax
f010c788:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c78b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c78e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c791:	89 d0                	mov    %edx,%eax
f010c793:	01 c0                	add    %eax,%eax
f010c795:	01 d0                	add    %edx,%eax
f010c797:	c1 e0 03             	shl    $0x3,%eax
f010c79a:	01 c8                	add    %ecx,%eax
f010c79c:	05 b4 00 00 00       	add    $0xb4,%eax
f010c7a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c7a7:	ff 45 f4             	incl   -0xc(%ebp)
f010c7aa:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c7ae:	7e a6                	jle    f010c756 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c7b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7b3:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010c7ba:	00 00 00 

	e->pageFaultsCounter=0;
f010c7bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c0:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010c7c7:	00 00 00 
	e->tableFaultsCounter=0;
f010c7ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7cd:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010c7d4:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c7d7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7da:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c7e1:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c7e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7e7:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c7ee:	00 00 00 

	e->nModifiedPages=0;
f010c7f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7f4:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c7fb:	00 00 00 
	e->nNotModifiedPages=0;
f010c7fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010c801:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c808:	00 00 00 
	e->nClocks = 0;
f010c80b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c80e:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c815:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c818:	8b 45 08             	mov    0x8(%ebp),%eax
f010c81b:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c822:	00 00 00 
	e->nPageOut = 0;
f010c825:	8b 45 08             	mov    0x8(%ebp),%eax
f010c828:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c82f:	00 00 00 
	e->nNewPageAdded = 0;
f010c832:	8b 45 08             	mov    0x8(%ebp),%eax
f010c835:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c83c:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010c83f:	83 ec 04             	sub    $0x4,%esp
f010c842:	68 00 00 00 82       	push   $0x82000000
f010c847:	68 00 00 00 80       	push   $0x80000000
f010c84c:	ff 75 08             	pushl  0x8(%ebp)
f010c84f:	e8 a8 fd ff ff       	call   f010c5fc <initialize_uheap_dynamic_allocator>
f010c854:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c857:	83 ec 0c             	sub    $0xc,%esp
f010c85a:	ff 75 08             	pushl  0x8(%ebp)
f010c85d:	e8 06 00 00 00       	call   f010c868 <complete_environment_initialization>
f010c862:	83 c4 10             	add    $0x10,%esp
}
f010c865:	90                   	nop
f010c866:	c9                   	leave  
f010c867:	c3                   	ret    

f010c868 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c868:	55                   	push   %ebp
f010c869:	89 e5                	mov    %esp,%ebp
f010c86b:	53                   	push   %ebx
f010c86c:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c86f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c872:	8b 40 64             	mov    0x64(%eax),%eax
f010c875:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c87b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c87e:	8b 40 68             	mov    0x68(%eax),%eax
f010c881:	83 c8 03             	or     $0x3,%eax
f010c884:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c886:	8b 45 08             	mov    0x8(%ebp),%eax
f010c889:	8b 40 64             	mov    0x64(%eax),%eax
f010c88c:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c892:	8b 45 08             	mov    0x8(%ebp),%eax
f010c895:	8b 40 68             	mov    0x68(%eax),%eax
f010c898:	83 c8 05             	or     $0x5,%eax
f010c89b:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c89d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8a0:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c8a7:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010c8aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8ad:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010c8b4:	00 00 00 
	e->disk_env_tabledir = 0;
f010c8b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8ba:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c8c1:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010c8c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8c7:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c8ce:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c8d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8d4:	8b 58 10             	mov    0x10(%eax),%ebx
f010c8d7:	83 ec 0c             	sub    $0xc,%esp
f010c8da:	68 ca 02 00 00       	push   $0x2ca
f010c8df:	e8 85 19 01 00       	call   f011e269 <log2_ceil>
f010c8e4:	83 c4 10             	add    $0x10,%esp
f010c8e7:	ba 01 00 00 00       	mov    $0x1,%edx
f010c8ec:	88 c1                	mov    %al,%cl
f010c8ee:	d3 e2                	shl    %cl,%edx
f010c8f0:	89 d0                	mov    %edx,%eax
f010c8f2:	01 d8                	add    %ebx,%eax
f010c8f4:	89 c3                	mov    %eax,%ebx
f010c8f6:	83 ec 0c             	sub    $0xc,%esp
f010c8f9:	68 ca 02 00 00       	push   $0x2ca
f010c8fe:	e8 31 19 01 00       	call   f011e234 <nearest_pow2_ceil>
f010c903:	83 c4 10             	add    $0x10,%esp
f010c906:	f7 d8                	neg    %eax
f010c908:	21 d8                	and    %ebx,%eax
f010c90a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c90d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c911:	7f 1e                	jg     f010c931 <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010c913:	83 ec 0c             	sub    $0xc,%esp
f010c916:	68 ca 02 00 00       	push   $0x2ca
f010c91b:	e8 49 19 01 00       	call   f011e269 <log2_ceil>
f010c920:	83 c4 10             	add    $0x10,%esp
f010c923:	ba 01 00 00 00       	mov    $0x1,%edx
f010c928:	88 c1                	mov    %al,%cl
f010c92a:	d3 e2                	shl    %cl,%edx
f010c92c:	89 d0                	mov    %edx,%eax
f010c92e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c931:	8b 45 08             	mov    0x8(%ebp),%eax
f010c934:	8b 15 f0 8a 69 f0    	mov    0xf0698af0,%edx
f010c93a:	29 d0                	sub    %edx,%eax
f010c93c:	c1 f8 02             	sar    $0x2,%eax
f010c93f:	89 c2                	mov    %eax,%edx
f010c941:	89 d0                	mov    %edx,%eax
f010c943:	c1 e0 03             	shl    $0x3,%eax
f010c946:	01 d0                	add    %edx,%eax
f010c948:	c1 e0 03             	shl    $0x3,%eax
f010c94b:	01 d0                	add    %edx,%eax
f010c94d:	c1 e0 02             	shl    $0x2,%eax
f010c950:	01 d0                	add    %edx,%eax
f010c952:	01 c0                	add    %eax,%eax
f010c954:	01 d0                	add    %edx,%eax
f010c956:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010c95d:	01 c8                	add    %ecx,%eax
f010c95f:	c1 e0 02             	shl    $0x2,%eax
f010c962:	01 d0                	add    %edx,%eax
f010c964:	c1 e0 03             	shl    $0x3,%eax
f010c967:	01 d0                	add    %edx,%eax
f010c969:	c1 e0 05             	shl    $0x5,%eax
f010c96c:	29 d0                	sub    %edx,%eax
f010c96e:	c1 e0 02             	shl    $0x2,%eax
f010c971:	01 d0                	add    %edx,%eax
f010c973:	01 c0                	add    %eax,%eax
f010c975:	01 d0                	add    %edx,%eax
f010c977:	c1 e0 03             	shl    $0x3,%eax
f010c97a:	01 d0                	add    %edx,%eax
f010c97c:	c1 e0 04             	shl    $0x4,%eax
f010c97f:	29 d0                	sub    %edx,%eax
f010c981:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c984:	89 c2                	mov    %eax,%edx
f010c986:	8b 45 08             	mov    0x8(%ebp),%eax
f010c989:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c98c:	e8 08 f1 ff ff       	call   f010ba99 <get_cpu_proc>
f010c991:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c994:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c998:	75 0c                	jne    f010c9a6 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010c99a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c99d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c9a4:	eb 0c                	jmp    f010c9b2 <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c9a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c9a9:	8b 50 10             	mov    0x10(%eax),%edx
f010c9ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9af:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c9b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9b5:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c9bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9bf:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c9c6:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c9c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9cc:	8b 00                	mov    (%eax),%eax
f010c9ce:	83 ec 04             	sub    $0x4,%esp
f010c9d1:	6a 44                	push   $0x44
f010c9d3:	6a 00                	push   $0x0
f010c9d5:	50                   	push   %eax
f010c9d6:	e8 e9 34 01 00       	call   f011fec4 <memset>
f010c9db:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c9de:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9e1:	8b 00                	mov    (%eax),%eax
f010c9e3:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c9e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9ec:	8b 00                	mov    (%eax),%eax
f010c9ee:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c9f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9f7:	8b 00                	mov    (%eax),%eax
f010c9f9:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c9ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca02:	8b 00                	mov    (%eax),%eax
f010ca04:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010ca0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca0e:	8b 00                	mov    (%eax),%eax
f010ca10:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010ca16:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca19:	8b 00                	mov    (%eax),%eax
f010ca1b:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca1e:	8b 12                	mov    (%edx),%edx
f010ca20:	8b 52 38             	mov    0x38(%edx),%edx
f010ca23:	80 ce 02             	or     $0x2,%dh
f010ca26:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010ca29:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ca2d:	75 17                	jne    f010ca46 <complete_environment_initialization+0x1de>
f010ca2f:	83 ec 04             	sub    $0x4,%esp
f010ca32:	68 67 63 12 f0       	push   $0xf0126367
f010ca37:	68 67 04 00 00       	push   $0x467
f010ca3c:	68 df 62 12 f0       	push   $0xf01262df
f010ca41:	e8 f3 38 ff ff       	call   f0100339 <_panic>
f010ca46:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca49:	8b 40 08             	mov    0x8(%eax),%eax
f010ca4c:	85 c0                	test   %eax,%eax
f010ca4e:	74 11                	je     f010ca61 <complete_environment_initialization+0x1f9>
f010ca50:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca53:	8b 40 08             	mov    0x8(%eax),%eax
f010ca56:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca59:	8b 52 0c             	mov    0xc(%edx),%edx
f010ca5c:	89 50 0c             	mov    %edx,0xc(%eax)
f010ca5f:	eb 0b                	jmp    f010ca6c <complete_environment_initialization+0x204>
f010ca61:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca64:	8b 40 0c             	mov    0xc(%eax),%eax
f010ca67:	a3 f8 8a 69 f0       	mov    %eax,0xf0698af8
f010ca6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca6f:	8b 40 0c             	mov    0xc(%eax),%eax
f010ca72:	85 c0                	test   %eax,%eax
f010ca74:	74 11                	je     f010ca87 <complete_environment_initialization+0x21f>
f010ca76:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca79:	8b 40 0c             	mov    0xc(%eax),%eax
f010ca7c:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca7f:	8b 52 08             	mov    0x8(%edx),%edx
f010ca82:	89 50 08             	mov    %edx,0x8(%eax)
f010ca85:	eb 0b                	jmp    f010ca92 <complete_environment_initialization+0x22a>
f010ca87:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca8a:	8b 40 08             	mov    0x8(%eax),%eax
f010ca8d:	a3 f4 8a 69 f0       	mov    %eax,0xf0698af4
f010ca92:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca95:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010ca9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca9f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010caa6:	a1 00 8b 69 f0       	mov    0xf0698b00,%eax
f010caab:	48                   	dec    %eax
f010caac:	a3 00 8b 69 f0       	mov    %eax,0xf0698b00
	return ;
f010cab1:	90                   	nop
}
f010cab2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cab5:	c9                   	leave  
f010cab6:	c3                   	ret    

f010cab7 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010cab7:	55                   	push   %ebp
f010cab8:	89 e5                	mov    %esp,%ebp
f010caba:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cabd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cac3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cac6:	8b 00                	mov    (%eax),%eax
f010cac8:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cacd:	74 17                	je     f010cae6 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010cacf:	83 ec 04             	sub    $0x4,%esp
f010cad2:	68 8d 65 12 f0       	push   $0xf012658d
f010cad7:	68 73 04 00 00       	push   $0x473
f010cadc:	68 df 62 12 f0       	push   $0xf01262df
f010cae1:	e8 53 38 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010cae6:	8b 45 08             	mov    0x8(%ebp),%eax
f010cae9:	8b 00                	mov    (%eax),%eax
f010caeb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010caee:	8b 52 18             	mov    0x18(%edx),%edx
f010caf1:	89 50 30             	mov    %edx,0x30(%eax)
}
f010caf4:	90                   	nop
f010caf5:	c9                   	leave  
f010caf6:	c3                   	ret    

f010caf7 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010caf7:	55                   	push   %ebp
f010caf8:	89 e5                	mov    %esp,%ebp
f010cafa:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010cafd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb00:	8b 40 10             	mov    0x10(%eax),%eax
f010cb03:	8d 48 01             	lea    0x1(%eax),%ecx
f010cb06:	8b 55 08             	mov    0x8(%ebp),%edx
f010cb09:	89 4a 10             	mov    %ecx,0x10(%edx)
f010cb0c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cb0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb12:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cb15:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb18:	8b 00                	mov    (%eax),%eax
f010cb1a:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cb1f:	74 17                	je     f010cb38 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010cb21:	83 ec 04             	sub    $0x4,%esp
f010cb24:	68 8d 65 12 f0       	push   $0xf012658d
f010cb29:	68 81 04 00 00       	push   $0x481
f010cb2e:	68 df 62 12 f0       	push   $0xf01262df
f010cb33:	e8 01 38 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cb38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb3b:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cb3e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb41:	01 d0                	add    %edx,%eax
f010cb43:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010cb46:	eb 0f                	jmp    f010cb57 <PROGRAM_SEGMENT_NEXT+0x60>
f010cb48:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb4b:	8b 40 10             	mov    0x10(%eax),%eax
f010cb4e:	8d 50 01             	lea    0x1(%eax),%edx
f010cb51:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb54:	89 50 10             	mov    %edx,0x10(%eax)
f010cb57:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb5a:	8b 40 10             	mov    0x10(%eax),%eax
f010cb5d:	c1 e0 05             	shl    $0x5,%eax
f010cb60:	89 c2                	mov    %eax,%edx
f010cb62:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb65:	01 d0                	add    %edx,%eax
f010cb67:	8b 00                	mov    (%eax),%eax
f010cb69:	83 f8 01             	cmp    $0x1,%eax
f010cb6c:	74 13                	je     f010cb81 <PROGRAM_SEGMENT_NEXT+0x8a>
f010cb6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb71:	8b 50 10             	mov    0x10(%eax),%edx
f010cb74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb77:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb7a:	0f b7 c0             	movzwl %ax,%eax
f010cb7d:	39 c2                	cmp    %eax,%edx
f010cb7f:	72 c7                	jb     f010cb48 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010cb81:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb84:	8b 40 10             	mov    0x10(%eax),%eax
f010cb87:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010cb8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb8d:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb90:	0f b7 c0             	movzwl %ax,%eax
f010cb93:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010cb96:	7e 63                	jle    f010cbfb <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cb98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb9b:	c1 e0 05             	shl    $0x5,%eax
f010cb9e:	89 c2                	mov    %eax,%edx
f010cba0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cba3:	01 d0                	add    %edx,%eax
f010cba5:	8b 50 04             	mov    0x4(%eax),%edx
f010cba8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cbab:	01 c2                	add    %eax,%edx
f010cbad:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbb0:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010cbb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cbb5:	c1 e0 05             	shl    $0x5,%eax
f010cbb8:	89 c2                	mov    %eax,%edx
f010cbba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cbbd:	01 d0                	add    %edx,%eax
f010cbbf:	8b 50 14             	mov    0x14(%eax),%edx
f010cbc2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbc5:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010cbc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cbcb:	c1 e0 05             	shl    $0x5,%eax
f010cbce:	89 c2                	mov    %eax,%edx
f010cbd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cbd3:	01 d0                	add    %edx,%eax
f010cbd5:	8b 50 10             	mov    0x10(%eax),%edx
f010cbd8:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbdb:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010cbde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cbe1:	c1 e0 05             	shl    $0x5,%eax
f010cbe4:	89 c2                	mov    %eax,%edx
f010cbe6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cbe9:	01 d0                	add    %edx,%eax
f010cbeb:	8b 40 08             	mov    0x8(%eax),%eax
f010cbee:	89 c2                	mov    %eax,%edx
f010cbf0:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbf3:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010cbf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbf9:	eb 05                	jmp    f010cc00 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010cbfb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010cc00:	c9                   	leave  
f010cc01:	c3                   	ret    

f010cc02 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010cc02:	55                   	push   %ebp
f010cc03:	89 e5                	mov    %esp,%ebp
f010cc05:	57                   	push   %edi
f010cc06:	56                   	push   %esi
f010cc07:	53                   	push   %ebx
f010cc08:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010cc0b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cc12:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cc15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cc18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cc1b:	8b 00                	mov    (%eax),%eax
f010cc1d:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cc22:	74 17                	je     f010cc3b <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010cc24:	83 ec 04             	sub    $0x4,%esp
f010cc27:	68 8d 65 12 f0       	push   $0xf012658d
f010cc2c:	68 9d 04 00 00       	push   $0x49d
f010cc31:	68 df 62 12 f0       	push   $0xf01262df
f010cc36:	e8 fe 36 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cc3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cc3e:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cc41:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cc44:	01 d0                	add    %edx,%eax
f010cc46:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010cc49:	eb 07                	jmp    f010cc52 <PROGRAM_SEGMENT_FIRST+0x50>
f010cc4b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc4e:	40                   	inc    %eax
f010cc4f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cc52:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc55:	c1 e0 05             	shl    $0x5,%eax
f010cc58:	89 c2                	mov    %eax,%edx
f010cc5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc5d:	01 d0                	add    %edx,%eax
f010cc5f:	8b 00                	mov    (%eax),%eax
f010cc61:	83 f8 01             	cmp    $0x1,%eax
f010cc64:	74 10                	je     f010cc76 <PROGRAM_SEGMENT_FIRST+0x74>
f010cc66:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010cc69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cc6c:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cc6f:	0f b7 c0             	movzwl %ax,%eax
f010cc72:	39 c2                	cmp    %eax,%edx
f010cc74:	72 d5                	jb     f010cc4b <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cc76:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc79:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cc7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cc7f:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cc82:	0f b7 c0             	movzwl %ax,%eax
f010cc85:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cc88:	7e 68                	jle    f010ccf2 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cc8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc8d:	c1 e0 05             	shl    $0x5,%eax
f010cc90:	89 c2                	mov    %eax,%edx
f010cc92:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc95:	01 d0                	add    %edx,%eax
f010cc97:	8b 50 04             	mov    0x4(%eax),%edx
f010cc9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cc9d:	01 d0                	add    %edx,%eax
f010cc9f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cca2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cca5:	c1 e0 05             	shl    $0x5,%eax
f010cca8:	89 c2                	mov    %eax,%edx
f010ccaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ccad:	01 d0                	add    %edx,%eax
f010ccaf:	8b 40 14             	mov    0x14(%eax),%eax
f010ccb2:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010ccb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ccb8:	c1 e0 05             	shl    $0x5,%eax
f010ccbb:	89 c2                	mov    %eax,%edx
f010ccbd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ccc0:	01 d0                	add    %edx,%eax
f010ccc2:	8b 40 10             	mov    0x10(%eax),%eax
f010ccc5:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010ccc8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cccb:	c1 e0 05             	shl    $0x5,%eax
f010ccce:	89 c2                	mov    %eax,%edx
f010ccd0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ccd3:	01 d0                	add    %edx,%eax
f010ccd5:	8b 40 08             	mov    0x8(%eax),%eax
f010ccd8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010ccdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccde:	89 c3                	mov    %eax,%ebx
f010cce0:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cce3:	ba 05 00 00 00       	mov    $0x5,%edx
f010cce8:	89 df                	mov    %ebx,%edi
f010ccea:	89 c6                	mov    %eax,%esi
f010ccec:	89 d1                	mov    %edx,%ecx
f010ccee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010ccf0:	eb 1c                	jmp    f010cd0e <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010ccf2:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010ccf9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccfc:	89 c3                	mov    %eax,%ebx
f010ccfe:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cd01:	ba 05 00 00 00       	mov    $0x5,%edx
f010cd06:	89 df                	mov    %ebx,%edi
f010cd08:	89 c6                	mov    %eax,%esi
f010cd0a:	89 d1                	mov    %edx,%ecx
f010cd0c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cd0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd11:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cd14:	5b                   	pop    %ebx
f010cd15:	5e                   	pop    %esi
f010cd16:	5f                   	pop    %edi
f010cd17:	5d                   	pop    %ebp
f010cd18:	c2 04 00             	ret    $0x4

f010cd1b <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cd1b:	55                   	push   %ebp
f010cd1c:	89 e5                	mov    %esp,%ebp
f010cd1e:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cd21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010cd28:	83 ec 0c             	sub    $0xc,%esp
f010cd2b:	68 a0 16 6c f0       	push   $0xf06c16a0
f010cd30:	e8 f3 2f 00 00       	call   f010fd28 <acquire_spinlock>
f010cd35:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cd38:	a1 90 16 6c f0       	mov    0xf06c1690,%eax
f010cd3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cd40:	e9 c3 00 00 00       	jmp    f010ce08 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010cd45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd48:	8b 40 0c             	mov    0xc(%eax),%eax
f010cd4b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cd4e:	0f 85 ac 00 00 00    	jne    f010ce00 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010cd54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd57:	8b 50 10             	mov    0x10(%eax),%edx
f010cd5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd5d:	8b 40 0c             	mov    0xc(%eax),%eax
f010cd60:	8b 40 64             	mov    0x64(%eax),%eax
f010cd63:	83 ec 08             	sub    $0x8,%esp
f010cd66:	52                   	push   %edx
f010cd67:	50                   	push   %eax
f010cd68:	e8 79 d0 ff ff       	call   f0109de6 <pt_clear_page_table_entry>
f010cd6d:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cd70:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cd74:	75 17                	jne    f010cd8d <cleanup_buffers+0x72>
f010cd76:	83 ec 04             	sub    $0x4,%esp
f010cd79:	68 67 63 12 f0       	push   $0xf0126367
f010cd7e:	68 c6 04 00 00       	push   $0x4c6
f010cd83:	68 df 62 12 f0       	push   $0xf01262df
f010cd88:	e8 ac 35 ff ff       	call   f0100339 <_panic>
f010cd8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd90:	8b 00                	mov    (%eax),%eax
f010cd92:	85 c0                	test   %eax,%eax
f010cd94:	74 10                	je     f010cda6 <cleanup_buffers+0x8b>
f010cd96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd99:	8b 00                	mov    (%eax),%eax
f010cd9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd9e:	8b 52 04             	mov    0x4(%edx),%edx
f010cda1:	89 50 04             	mov    %edx,0x4(%eax)
f010cda4:	eb 0b                	jmp    f010cdb1 <cleanup_buffers+0x96>
f010cda6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cda9:	8b 40 04             	mov    0x4(%eax),%eax
f010cdac:	a3 94 16 6c f0       	mov    %eax,0xf06c1694
f010cdb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cdb4:	8b 40 04             	mov    0x4(%eax),%eax
f010cdb7:	85 c0                	test   %eax,%eax
f010cdb9:	74 0f                	je     f010cdca <cleanup_buffers+0xaf>
f010cdbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cdbe:	8b 40 04             	mov    0x4(%eax),%eax
f010cdc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cdc4:	8b 12                	mov    (%edx),%edx
f010cdc6:	89 10                	mov    %edx,(%eax)
f010cdc8:	eb 0a                	jmp    f010cdd4 <cleanup_buffers+0xb9>
f010cdca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cdcd:	8b 00                	mov    (%eax),%eax
f010cdcf:	a3 90 16 6c f0       	mov    %eax,0xf06c1690
f010cdd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cdd7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cde0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010cde7:	a1 9c 16 6c f0       	mov    0xf06c169c,%eax
f010cdec:	48                   	dec    %eax
f010cded:	a3 9c 16 6c f0       	mov    %eax,0xf06c169c

				free_frame(ptr_fi);
f010cdf2:	83 ec 0c             	sub    $0xc,%esp
f010cdf5:	ff 75 f4             	pushl  -0xc(%ebp)
f010cdf8:	e8 09 b5 ff ff       	call   f0108306 <free_frame>
f010cdfd:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010ce00:	a1 98 16 6c f0       	mov    0xf06c1698,%eax
f010ce05:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ce08:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ce0c:	74 07                	je     f010ce15 <cleanup_buffers+0xfa>
f010ce0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ce11:	8b 00                	mov    (%eax),%eax
f010ce13:	eb 05                	jmp    f010ce1a <cleanup_buffers+0xff>
f010ce15:	b8 00 00 00 00       	mov    $0x0,%eax
f010ce1a:	a3 98 16 6c f0       	mov    %eax,0xf06c1698
f010ce1f:	a1 98 16 6c f0       	mov    0xf06c1698,%eax
f010ce24:	85 c0                	test   %eax,%eax
f010ce26:	0f 85 19 ff ff ff    	jne    f010cd45 <cleanup_buffers+0x2a>
f010ce2c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ce30:	0f 85 0f ff ff ff    	jne    f010cd45 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010ce36:	83 ec 0c             	sub    $0xc,%esp
f010ce39:	68 a0 16 6c f0       	push   $0xf06c16a0
f010ce3e:	e8 6c 2f 00 00       	call   f010fdaf <release_spinlock>
f010ce43:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010ce46:	90                   	nop
f010ce47:	c9                   	leave  
f010ce48:	c3                   	ret    

f010ce49 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010ce49:	55                   	push   %ebp
f010ce4a:	89 e5                	mov    %esp,%ebp
f010ce4c:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010ce4f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010ce53:	7e 06                	jle    f010ce5b <set_program_priority+0x12>
f010ce55:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010ce59:	7e 14                	jle    f010ce6f <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010ce5b:	83 ec 04             	sub    $0x4,%esp
f010ce5e:	68 a4 65 12 f0       	push   $0xf01265a4
f010ce63:	6a 10                	push   $0x10
f010ce65:	68 c8 65 12 f0       	push   $0xf01265c8
f010ce6a:	e8 ca 34 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010ce6f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ce73:	74 78                	je     f010ceed <set_program_priority+0xa4>
		return;
	switch(priority)
f010ce75:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010ce79:	77 56                	ja     f010ced1 <set_program_priority+0x88>
f010ce7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ce7e:	c1 e0 02             	shl    $0x2,%eax
f010ce81:	05 04 66 12 f0       	add    $0xf0126604,%eax
f010ce86:	8b 00                	mov    (%eax),%eax
f010ce88:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010ce8a:	83 ec 08             	sub    $0x8,%esp
f010ce8d:	6a 01                	push   $0x1
f010ce8f:	ff 75 08             	pushl  0x8(%ebp)
f010ce92:	e8 a6 dc ff ff       	call   f010ab3d <half_WS_Size>
f010ce97:	83 c4 10             	add    $0x10,%esp
			break;
f010ce9a:	eb 35                	jmp    f010ced1 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010ce9c:	83 ec 08             	sub    $0x8,%esp
f010ce9f:	6a 00                	push   $0x0
f010cea1:	ff 75 08             	pushl  0x8(%ebp)
f010cea4:	e8 94 dc ff ff       	call   f010ab3d <half_WS_Size>
f010cea9:	83 c4 10             	add    $0x10,%esp
			break;
f010ceac:	eb 23                	jmp    f010ced1 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010ceae:	83 ec 08             	sub    $0x8,%esp
f010ceb1:	6a 01                	push   $0x1
f010ceb3:	ff 75 08             	pushl  0x8(%ebp)
f010ceb6:	e8 65 dc ff ff       	call   f010ab20 <double_WS_Size>
f010cebb:	83 c4 10             	add    $0x10,%esp
			break;
f010cebe:	eb 11                	jmp    f010ced1 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010cec0:	83 ec 08             	sub    $0x8,%esp
f010cec3:	6a 00                	push   $0x0
f010cec5:	ff 75 08             	pushl  0x8(%ebp)
f010cec8:	e8 53 dc ff ff       	call   f010ab20 <double_WS_Size>
f010cecd:	83 c4 10             	add    $0x10,%esp
			break;
f010ced0:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010ced1:	8b 45 08             	mov    0x8(%ebp),%eax
f010ced4:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010ceda:	83 ec 08             	sub    $0x8,%esp
f010cedd:	50                   	push   %eax
f010cede:	68 e5 65 12 f0       	push   $0xf01265e5
f010cee3:	e8 a3 40 ff ff       	call   f0100f8b <cprintf>
f010cee8:	83 c4 10             	add    $0x10,%esp
f010ceeb:	eb 01                	jmp    f010ceee <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010ceed:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010ceee:	c9                   	leave  
f010ceef:	c3                   	ret    

f010cef0 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010cef0:	55                   	push   %ebp
f010cef1:	89 e5                	mov    %esp,%ebp
f010cef3:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cef6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cefd:	eb 29                	jmp    f010cf28 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010ceff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf02:	89 d0                	mov    %edx,%eax
f010cf04:	01 c0                	add    %eax,%eax
f010cf06:	01 d0                	add    %edx,%eax
f010cf08:	c1 e0 02             	shl    $0x2,%eax
f010cf0b:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010cf10:	8b 00                	mov    (%eax),%eax
f010cf12:	83 ec 08             	sub    $0x8,%esp
f010cf15:	50                   	push   %eax
f010cf16:	ff 75 08             	pushl  0x8(%ebp)
f010cf19:	e8 c4 2e 01 00       	call   f011fde2 <strcmp>
f010cf1e:	83 c4 10             	add    $0x10,%esp
f010cf21:	85 c0                	test   %eax,%eax
f010cf23:	74 0f                	je     f010cf34 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cf25:	ff 45 f4             	incl   -0xc(%ebp)
f010cf28:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cf2d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cf30:	7c cd                	jl     f010ceff <get_user_program_info+0xf>
f010cf32:	eb 01                	jmp    f010cf35 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010cf34:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cf35:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cf3a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cf3d:	75 1a                	jne    f010cf59 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010cf3f:	83 ec 08             	sub    $0x8,%esp
f010cf42:	ff 75 08             	pushl  0x8(%ebp)
f010cf45:	68 69 73 12 f0       	push   $0xf0127369
f010cf4a:	e8 3c 40 ff ff       	call   f0100f8b <cprintf>
f010cf4f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cf52:	b8 00 00 00 00       	mov    $0x0,%eax
f010cf57:	eb 11                	jmp    f010cf6a <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010cf59:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf5c:	89 d0                	mov    %edx,%eax
f010cf5e:	01 c0                	add    %eax,%eax
f010cf60:	01 d0                	add    %edx,%eax
f010cf62:	c1 e0 02             	shl    $0x2,%eax
f010cf65:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010cf6a:	c9                   	leave  
f010cf6b:	c3                   	ret    

f010cf6c <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010cf6c:	55                   	push   %ebp
f010cf6d:	89 e5                	mov    %esp,%ebp
f010cf6f:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cf72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cf79:	eb 2d                	jmp    f010cfa8 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010cf7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf7e:	89 d0                	mov    %edx,%eax
f010cf80:	01 c0                	add    %eax,%eax
f010cf82:	01 d0                	add    %edx,%eax
f010cf84:	c1 e0 02             	shl    $0x2,%eax
f010cf87:	05 80 f9 17 f0       	add    $0xf017f980,%eax
f010cf8c:	8b 00                	mov    (%eax),%eax
f010cf8e:	8b 55 08             	mov    0x8(%ebp),%edx
f010cf91:	83 c2 20             	add    $0x20,%edx
f010cf94:	83 ec 08             	sub    $0x8,%esp
f010cf97:	50                   	push   %eax
f010cf98:	52                   	push   %edx
f010cf99:	e8 44 2e 01 00       	call   f011fde2 <strcmp>
f010cf9e:	83 c4 10             	add    $0x10,%esp
f010cfa1:	85 c0                	test   %eax,%eax
f010cfa3:	74 0f                	je     f010cfb4 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cfa5:	ff 45 f4             	incl   -0xc(%ebp)
f010cfa8:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cfad:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cfb0:	7c c9                	jl     f010cf7b <get_user_program_info_by_env+0xf>
f010cfb2:	eb 01                	jmp    f010cfb5 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010cfb4:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cfb5:	a1 e4 fc 17 f0       	mov    0xf017fce4,%eax
f010cfba:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cfbd:	75 17                	jne    f010cfd6 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010cfbf:	83 ec 0c             	sub    $0xc,%esp
f010cfc2:	68 84 73 12 f0       	push   $0xf0127384
f010cfc7:	e8 bf 3f ff ff       	call   f0100f8b <cprintf>
f010cfcc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cfcf:	b8 00 00 00 00       	mov    $0x0,%eax
f010cfd4:	eb 11                	jmp    f010cfe7 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010cfd6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cfd9:	89 d0                	mov    %edx,%eax
f010cfdb:	01 c0                	add    %eax,%eax
f010cfdd:	01 d0                	add    %edx,%eax
f010cfdf:	c1 e0 02             	shl    $0x2,%eax
f010cfe2:	05 80 f9 17 f0       	add    $0xf017f980,%eax
}
f010cfe7:	c9                   	leave  
f010cfe8:	c3                   	ret    

f010cfe9 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010cfe9:	55                   	push   %ebp
f010cfea:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010cfec:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfef:	83 f8 13             	cmp    $0x13,%eax
f010cff2:	77 0c                	ja     f010d000 <trapname+0x17>
		return excnames[trapno];
f010cff4:	8b 45 08             	mov    0x8(%ebp),%eax
f010cff7:	8b 04 85 60 77 12 f0 	mov    -0xfed88a0(,%eax,4),%eax
f010cffe:	eb 2c                	jmp    f010d02c <trapname+0x43>
	if (trapno == T_SYSCALL)
f010d000:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010d004:	75 07                	jne    f010d00d <trapname+0x24>
		return "System call";
f010d006:	b8 a0 73 12 f0       	mov    $0xf01273a0,%eax
f010d00b:	eb 1f                	jmp    f010d02c <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010d00d:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010d011:	75 07                	jne    f010d01a <trapname+0x31>
		return "Clock Interrupt";
f010d013:	b8 ac 73 12 f0       	mov    $0xf01273ac,%eax
f010d018:	eb 12                	jmp    f010d02c <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010d01a:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010d01e:	75 07                	jne    f010d027 <trapname+0x3e>
		return "Keyboard Interrupt";
f010d020:	b8 bc 73 12 f0       	mov    $0xf01273bc,%eax
f010d025:	eb 05                	jmp    f010d02c <trapname+0x43>
	return "(unknown trap)";
f010d027:	b8 cf 73 12 f0       	mov    $0xf01273cf,%eax
}
f010d02c:	5d                   	pop    %ebp
f010d02d:	c3                   	ret    

f010d02e <ts_init>:


void ts_init(void)
{
f010d02e:	55                   	push   %ebp
f010d02f:	89 e5                	mov    %esp,%ebp
f010d031:	53                   	push   %ebx
f010d032:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010d035:	e8 95 a1 ff ff       	call   f01071cf <pushcli>

	struct cpu* c = mycpu();
f010d03a:	e8 cd a0 ff ff       	call   f010710c <mycpu>
f010d03f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010d042:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d045:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010d04c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d04f:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010d055:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d058:	83 c0 0c             	add    $0xc,%eax
f010d05b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d05e:	83 c2 0c             	add    $0xc,%edx
f010d061:	c1 ea 10             	shr    $0x10,%edx
f010d064:	88 d3                	mov    %dl,%bl
f010d066:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d069:	83 c2 0c             	add    $0xc,%edx
f010d06c:	c1 ea 18             	shr    $0x18,%edx
f010d06f:	88 d1                	mov    %dl,%cl
f010d071:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d074:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d07b:	68 00 
f010d07d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d080:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d087:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d08a:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d090:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d093:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d099:	83 e2 f0             	and    $0xfffffff0,%edx
f010d09c:	83 ca 09             	or     $0x9,%edx
f010d09f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d0a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0a8:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d0ae:	83 ca 10             	or     $0x10,%edx
f010d0b1:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d0b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0ba:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d0c0:	83 e2 9f             	and    $0xffffff9f,%edx
f010d0c3:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d0c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0cc:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d0d2:	83 ca 80             	or     $0xffffff80,%edx
f010d0d5:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d0db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0de:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0e4:	83 e2 f0             	and    $0xfffffff0,%edx
f010d0e7:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0f0:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0f6:	83 e2 ef             	and    $0xffffffef,%edx
f010d0f9:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d102:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d108:	83 e2 df             	and    $0xffffffdf,%edx
f010d10b:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d111:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d114:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d11a:	83 ca 40             	or     $0x40,%edx
f010d11d:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d123:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d126:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d12c:	83 e2 7f             	and    $0x7f,%edx
f010d12f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d135:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d138:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d13e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d141:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d147:	83 e2 ef             	and    $0xffffffef,%edx
f010d14a:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d150:	e8 cc a0 ff ff       	call   f0107221 <popcli>
f010d155:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d15b:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d15f:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d162:	90                   	nop
f010d163:	83 c4 14             	add    $0x14,%esp
f010d166:	5b                   	pop    %ebx
f010d167:	5d                   	pop    %ebp
f010d168:	c3                   	ret    

f010d169 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d169:	55                   	push   %ebp
f010d16a:	89 e5                	mov    %esp,%ebp
f010d16c:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d16f:	b8 18 e6 10 f0       	mov    $0xf010e618,%eax
f010d174:	66 a3 60 8b 69 f0    	mov    %ax,0xf0698b60
f010d17a:	66 c7 05 62 8b 69 f0 	movw   $0x8,0xf0698b62
f010d181:	08 00 
f010d183:	a0 64 8b 69 f0       	mov    0xf0698b64,%al
f010d188:	83 e0 e0             	and    $0xffffffe0,%eax
f010d18b:	a2 64 8b 69 f0       	mov    %al,0xf0698b64
f010d190:	a0 64 8b 69 f0       	mov    0xf0698b64,%al
f010d195:	83 e0 1f             	and    $0x1f,%eax
f010d198:	a2 64 8b 69 f0       	mov    %al,0xf0698b64
f010d19d:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d1a2:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1a5:	83 c8 0e             	or     $0xe,%eax
f010d1a8:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d1ad:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d1b2:	83 e0 ef             	and    $0xffffffef,%eax
f010d1b5:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d1ba:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d1bf:	83 e0 9f             	and    $0xffffff9f,%eax
f010d1c2:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d1c7:	a0 65 8b 69 f0       	mov    0xf0698b65,%al
f010d1cc:	83 c8 80             	or     $0xffffff80,%eax
f010d1cf:	a2 65 8b 69 f0       	mov    %al,0xf0698b65
f010d1d4:	b8 18 e6 10 f0       	mov    $0xf010e618,%eax
f010d1d9:	c1 e8 10             	shr    $0x10,%eax
f010d1dc:	66 a3 66 8b 69 f0    	mov    %ax,0xf0698b66
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d1e2:	b8 20 e6 10 f0       	mov    $0xf010e620,%eax
f010d1e7:	66 a3 90 8b 69 f0    	mov    %ax,0xf0698b90
f010d1ed:	66 c7 05 92 8b 69 f0 	movw   $0x8,0xf0698b92
f010d1f4:	08 00 
f010d1f6:	a0 94 8b 69 f0       	mov    0xf0698b94,%al
f010d1fb:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1fe:	a2 94 8b 69 f0       	mov    %al,0xf0698b94
f010d203:	a0 94 8b 69 f0       	mov    0xf0698b94,%al
f010d208:	83 e0 1f             	and    $0x1f,%eax
f010d20b:	a2 94 8b 69 f0       	mov    %al,0xf0698b94
f010d210:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d215:	83 e0 f0             	and    $0xfffffff0,%eax
f010d218:	83 c8 0e             	or     $0xe,%eax
f010d21b:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d220:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d225:	83 e0 ef             	and    $0xffffffef,%eax
f010d228:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d22d:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d232:	83 e0 9f             	and    $0xffffff9f,%eax
f010d235:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d23a:	a0 95 8b 69 f0       	mov    0xf0698b95,%al
f010d23f:	83 c8 80             	or     $0xffffff80,%eax
f010d242:	a2 95 8b 69 f0       	mov    %al,0xf0698b95
f010d247:	b8 20 e6 10 f0       	mov    $0xf010e620,%eax
f010d24c:	c1 e8 10             	shr    $0x10,%eax
f010d24f:	66 a3 96 8b 69 f0    	mov    %ax,0xf0698b96
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d255:	b8 28 e6 10 f0       	mov    $0xf010e628,%eax
f010d25a:	66 a3 20 8c 69 f0    	mov    %ax,0xf0698c20
f010d260:	66 c7 05 22 8c 69 f0 	movw   $0x8,0xf0698c22
f010d267:	08 00 
f010d269:	a0 24 8c 69 f0       	mov    0xf0698c24,%al
f010d26e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d271:	a2 24 8c 69 f0       	mov    %al,0xf0698c24
f010d276:	a0 24 8c 69 f0       	mov    0xf0698c24,%al
f010d27b:	83 e0 1f             	and    $0x1f,%eax
f010d27e:	a2 24 8c 69 f0       	mov    %al,0xf0698c24
f010d283:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d288:	83 e0 f0             	and    $0xfffffff0,%eax
f010d28b:	83 c8 0e             	or     $0xe,%eax
f010d28e:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d293:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d298:	83 e0 ef             	and    $0xffffffef,%eax
f010d29b:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d2a0:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d2a5:	83 c8 60             	or     $0x60,%eax
f010d2a8:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d2ad:	a0 25 8c 69 f0       	mov    0xf0698c25,%al
f010d2b2:	83 c8 80             	or     $0xffffff80,%eax
f010d2b5:	a2 25 8c 69 f0       	mov    %al,0xf0698c25
f010d2ba:	b8 28 e6 10 f0       	mov    $0xf010e628,%eax
f010d2bf:	c1 e8 10             	shr    $0x10,%eax
f010d2c2:	66 a3 26 8c 69 f0    	mov    %ax,0xf0698c26
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d2c8:	b8 32 e6 10 f0       	mov    $0xf010e632,%eax
f010d2cd:	66 a3 28 8c 69 f0    	mov    %ax,0xf0698c28
f010d2d3:	66 c7 05 2a 8c 69 f0 	movw   $0x8,0xf0698c2a
f010d2da:	08 00 
f010d2dc:	a0 2c 8c 69 f0       	mov    0xf0698c2c,%al
f010d2e1:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2e4:	a2 2c 8c 69 f0       	mov    %al,0xf0698c2c
f010d2e9:	a0 2c 8c 69 f0       	mov    0xf0698c2c,%al
f010d2ee:	83 e0 1f             	and    $0x1f,%eax
f010d2f1:	a2 2c 8c 69 f0       	mov    %al,0xf0698c2c
f010d2f6:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d2fb:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2fe:	83 c8 0e             	or     $0xe,%eax
f010d301:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d306:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d30b:	83 e0 ef             	and    $0xffffffef,%eax
f010d30e:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d313:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d318:	83 c8 60             	or     $0x60,%eax
f010d31b:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d320:	a0 2d 8c 69 f0       	mov    0xf0698c2d,%al
f010d325:	83 c8 80             	or     $0xffffff80,%eax
f010d328:	a2 2d 8c 69 f0       	mov    %al,0xf0698c2d
f010d32d:	b8 32 e6 10 f0       	mov    $0xf010e632,%eax
f010d332:	c1 e8 10             	shr    $0x10,%eax
f010d335:	66 a3 2e 8c 69 f0    	mov    %ax,0xf0698c2e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d33b:	b8 3c e6 10 f0       	mov    $0xf010e63c,%eax
f010d340:	66 a3 a0 8c 69 f0    	mov    %ax,0xf0698ca0
f010d346:	66 c7 05 a2 8c 69 f0 	movw   $0x8,0xf0698ca2
f010d34d:	08 00 
f010d34f:	a0 a4 8c 69 f0       	mov    0xf0698ca4,%al
f010d354:	83 e0 e0             	and    $0xffffffe0,%eax
f010d357:	a2 a4 8c 69 f0       	mov    %al,0xf0698ca4
f010d35c:	a0 a4 8c 69 f0       	mov    0xf0698ca4,%al
f010d361:	83 e0 1f             	and    $0x1f,%eax
f010d364:	a2 a4 8c 69 f0       	mov    %al,0xf0698ca4
f010d369:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d36e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d371:	83 c8 0e             	or     $0xe,%eax
f010d374:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d379:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d37e:	83 e0 ef             	and    $0xffffffef,%eax
f010d381:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d386:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d38b:	83 c8 60             	or     $0x60,%eax
f010d38e:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d393:	a0 a5 8c 69 f0       	mov    0xf0698ca5,%al
f010d398:	83 c8 80             	or     $0xffffff80,%eax
f010d39b:	a2 a5 8c 69 f0       	mov    %al,0xf0698ca5
f010d3a0:	b8 3c e6 10 f0       	mov    $0xf010e63c,%eax
f010d3a5:	c1 e8 10             	shr    $0x10,%eax
f010d3a8:	66 a3 a6 8c 69 f0    	mov    %ax,0xf0698ca6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d3ae:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010d3b3:	66 a3 20 8b 69 f0    	mov    %ax,0xf0698b20
f010d3b9:	66 c7 05 22 8b 69 f0 	movw   $0x8,0xf0698b22
f010d3c0:	08 00 
f010d3c2:	a0 24 8b 69 f0       	mov    0xf0698b24,%al
f010d3c7:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3ca:	a2 24 8b 69 f0       	mov    %al,0xf0698b24
f010d3cf:	a0 24 8b 69 f0       	mov    0xf0698b24,%al
f010d3d4:	83 e0 1f             	and    $0x1f,%eax
f010d3d7:	a2 24 8b 69 f0       	mov    %al,0xf0698b24
f010d3dc:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d3e1:	83 e0 f0             	and    $0xfffffff0,%eax
f010d3e4:	83 c8 0e             	or     $0xe,%eax
f010d3e7:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d3ec:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d3f1:	83 e0 ef             	and    $0xffffffef,%eax
f010d3f4:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d3f9:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d3fe:	83 c8 60             	or     $0x60,%eax
f010d401:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d406:	a0 25 8b 69 f0       	mov    0xf0698b25,%al
f010d40b:	83 c8 80             	or     $0xffffff80,%eax
f010d40e:	a2 25 8b 69 f0       	mov    %al,0xf0698b25
f010d413:	b8 46 e6 10 f0       	mov    $0xf010e646,%eax
f010d418:	c1 e8 10             	shr    $0x10,%eax
f010d41b:	66 a3 26 8b 69 f0    	mov    %ax,0xf0698b26
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d421:	b8 50 e6 10 f0       	mov    $0xf010e650,%eax
f010d426:	66 a3 28 8b 69 f0    	mov    %ax,0xf0698b28
f010d42c:	66 c7 05 2a 8b 69 f0 	movw   $0x8,0xf0698b2a
f010d433:	08 00 
f010d435:	a0 2c 8b 69 f0       	mov    0xf0698b2c,%al
f010d43a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d43d:	a2 2c 8b 69 f0       	mov    %al,0xf0698b2c
f010d442:	a0 2c 8b 69 f0       	mov    0xf0698b2c,%al
f010d447:	83 e0 1f             	and    $0x1f,%eax
f010d44a:	a2 2c 8b 69 f0       	mov    %al,0xf0698b2c
f010d44f:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d454:	83 c8 0f             	or     $0xf,%eax
f010d457:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d45c:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d461:	83 e0 ef             	and    $0xffffffef,%eax
f010d464:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d469:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d46e:	83 c8 60             	or     $0x60,%eax
f010d471:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d476:	a0 2d 8b 69 f0       	mov    0xf0698b2d,%al
f010d47b:	83 c8 80             	or     $0xffffff80,%eax
f010d47e:	a2 2d 8b 69 f0       	mov    %al,0xf0698b2d
f010d483:	b8 50 e6 10 f0       	mov    $0xf010e650,%eax
f010d488:	c1 e8 10             	shr    $0x10,%eax
f010d48b:	66 a3 2e 8b 69 f0    	mov    %ax,0xf0698b2e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d491:	b8 5a e6 10 f0       	mov    $0xf010e65a,%eax
f010d496:	66 a3 30 8b 69 f0    	mov    %ax,0xf0698b30
f010d49c:	66 c7 05 32 8b 69 f0 	movw   $0x8,0xf0698b32
f010d4a3:	08 00 
f010d4a5:	a0 34 8b 69 f0       	mov    0xf0698b34,%al
f010d4aa:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4ad:	a2 34 8b 69 f0       	mov    %al,0xf0698b34
f010d4b2:	a0 34 8b 69 f0       	mov    0xf0698b34,%al
f010d4b7:	83 e0 1f             	and    $0x1f,%eax
f010d4ba:	a2 34 8b 69 f0       	mov    %al,0xf0698b34
f010d4bf:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d4c4:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4c7:	83 c8 0e             	or     $0xe,%eax
f010d4ca:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d4cf:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d4d4:	83 e0 ef             	and    $0xffffffef,%eax
f010d4d7:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d4dc:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d4e1:	83 c8 60             	or     $0x60,%eax
f010d4e4:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d4e9:	a0 35 8b 69 f0       	mov    0xf0698b35,%al
f010d4ee:	83 c8 80             	or     $0xffffff80,%eax
f010d4f1:	a2 35 8b 69 f0       	mov    %al,0xf0698b35
f010d4f6:	b8 5a e6 10 f0       	mov    $0xf010e65a,%eax
f010d4fb:	c1 e8 10             	shr    $0x10,%eax
f010d4fe:	66 a3 36 8b 69 f0    	mov    %ax,0xf0698b36
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d504:	b8 64 e6 10 f0       	mov    $0xf010e664,%eax
f010d509:	66 a3 38 8b 69 f0    	mov    %ax,0xf0698b38
f010d50f:	66 c7 05 3a 8b 69 f0 	movw   $0x8,0xf0698b3a
f010d516:	08 00 
f010d518:	a0 3c 8b 69 f0       	mov    0xf0698b3c,%al
f010d51d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d520:	a2 3c 8b 69 f0       	mov    %al,0xf0698b3c
f010d525:	a0 3c 8b 69 f0       	mov    0xf0698b3c,%al
f010d52a:	83 e0 1f             	and    $0x1f,%eax
f010d52d:	a2 3c 8b 69 f0       	mov    %al,0xf0698b3c
f010d532:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d537:	83 c8 0f             	or     $0xf,%eax
f010d53a:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d53f:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d544:	83 e0 ef             	and    $0xffffffef,%eax
f010d547:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d54c:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d551:	83 c8 60             	or     $0x60,%eax
f010d554:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d559:	a0 3d 8b 69 f0       	mov    0xf0698b3d,%al
f010d55e:	83 c8 80             	or     $0xffffff80,%eax
f010d561:	a2 3d 8b 69 f0       	mov    %al,0xf0698b3d
f010d566:	b8 64 e6 10 f0       	mov    $0xf010e664,%eax
f010d56b:	c1 e8 10             	shr    $0x10,%eax
f010d56e:	66 a3 3e 8b 69 f0    	mov    %ax,0xf0698b3e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d574:	b8 6e e6 10 f0       	mov    $0xf010e66e,%eax
f010d579:	66 a3 40 8b 69 f0    	mov    %ax,0xf0698b40
f010d57f:	66 c7 05 42 8b 69 f0 	movw   $0x8,0xf0698b42
f010d586:	08 00 
f010d588:	a0 44 8b 69 f0       	mov    0xf0698b44,%al
f010d58d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d590:	a2 44 8b 69 f0       	mov    %al,0xf0698b44
f010d595:	a0 44 8b 69 f0       	mov    0xf0698b44,%al
f010d59a:	83 e0 1f             	and    $0x1f,%eax
f010d59d:	a2 44 8b 69 f0       	mov    %al,0xf0698b44
f010d5a2:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d5a7:	83 c8 0f             	or     $0xf,%eax
f010d5aa:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d5af:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d5b4:	83 e0 ef             	and    $0xffffffef,%eax
f010d5b7:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d5bc:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d5c1:	83 c8 60             	or     $0x60,%eax
f010d5c4:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d5c9:	a0 45 8b 69 f0       	mov    0xf0698b45,%al
f010d5ce:	83 c8 80             	or     $0xffffff80,%eax
f010d5d1:	a2 45 8b 69 f0       	mov    %al,0xf0698b45
f010d5d6:	b8 6e e6 10 f0       	mov    $0xf010e66e,%eax
f010d5db:	c1 e8 10             	shr    $0x10,%eax
f010d5de:	66 a3 46 8b 69 f0    	mov    %ax,0xf0698b46
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d5e4:	b8 78 e6 10 f0       	mov    $0xf010e678,%eax
f010d5e9:	66 a3 48 8b 69 f0    	mov    %ax,0xf0698b48
f010d5ef:	66 c7 05 4a 8b 69 f0 	movw   $0x8,0xf0698b4a
f010d5f6:	08 00 
f010d5f8:	a0 4c 8b 69 f0       	mov    0xf0698b4c,%al
f010d5fd:	83 e0 e0             	and    $0xffffffe0,%eax
f010d600:	a2 4c 8b 69 f0       	mov    %al,0xf0698b4c
f010d605:	a0 4c 8b 69 f0       	mov    0xf0698b4c,%al
f010d60a:	83 e0 1f             	and    $0x1f,%eax
f010d60d:	a2 4c 8b 69 f0       	mov    %al,0xf0698b4c
f010d612:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d617:	83 e0 f0             	and    $0xfffffff0,%eax
f010d61a:	83 c8 0e             	or     $0xe,%eax
f010d61d:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d622:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d627:	83 e0 ef             	and    $0xffffffef,%eax
f010d62a:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d62f:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d634:	83 c8 60             	or     $0x60,%eax
f010d637:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d63c:	a0 4d 8b 69 f0       	mov    0xf0698b4d,%al
f010d641:	83 c8 80             	or     $0xffffff80,%eax
f010d644:	a2 4d 8b 69 f0       	mov    %al,0xf0698b4d
f010d649:	b8 78 e6 10 f0       	mov    $0xf010e678,%eax
f010d64e:	c1 e8 10             	shr    $0x10,%eax
f010d651:	66 a3 4e 8b 69 f0    	mov    %ax,0xf0698b4e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d657:	b8 82 e6 10 f0       	mov    $0xf010e682,%eax
f010d65c:	66 a3 50 8b 69 f0    	mov    %ax,0xf0698b50
f010d662:	66 c7 05 52 8b 69 f0 	movw   $0x8,0xf0698b52
f010d669:	08 00 
f010d66b:	a0 54 8b 69 f0       	mov    0xf0698b54,%al
f010d670:	83 e0 e0             	and    $0xffffffe0,%eax
f010d673:	a2 54 8b 69 f0       	mov    %al,0xf0698b54
f010d678:	a0 54 8b 69 f0       	mov    0xf0698b54,%al
f010d67d:	83 e0 1f             	and    $0x1f,%eax
f010d680:	a2 54 8b 69 f0       	mov    %al,0xf0698b54
f010d685:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d68a:	83 e0 f0             	and    $0xfffffff0,%eax
f010d68d:	83 c8 0e             	or     $0xe,%eax
f010d690:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d695:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d69a:	83 e0 ef             	and    $0xffffffef,%eax
f010d69d:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d6a2:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d6a7:	83 c8 60             	or     $0x60,%eax
f010d6aa:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d6af:	a0 55 8b 69 f0       	mov    0xf0698b55,%al
f010d6b4:	83 c8 80             	or     $0xffffff80,%eax
f010d6b7:	a2 55 8b 69 f0       	mov    %al,0xf0698b55
f010d6bc:	b8 82 e6 10 f0       	mov    $0xf010e682,%eax
f010d6c1:	c1 e8 10             	shr    $0x10,%eax
f010d6c4:	66 a3 56 8b 69 f0    	mov    %ax,0xf0698b56
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d6ca:	b8 8c e6 10 f0       	mov    $0xf010e68c,%eax
f010d6cf:	66 a3 58 8b 69 f0    	mov    %ax,0xf0698b58
f010d6d5:	66 c7 05 5a 8b 69 f0 	movw   $0x8,0xf0698b5a
f010d6dc:	08 00 
f010d6de:	a0 5c 8b 69 f0       	mov    0xf0698b5c,%al
f010d6e3:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6e6:	a2 5c 8b 69 f0       	mov    %al,0xf0698b5c
f010d6eb:	a0 5c 8b 69 f0       	mov    0xf0698b5c,%al
f010d6f0:	83 e0 1f             	and    $0x1f,%eax
f010d6f3:	a2 5c 8b 69 f0       	mov    %al,0xf0698b5c
f010d6f8:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d6fd:	83 e0 f0             	and    $0xfffffff0,%eax
f010d700:	83 c8 0e             	or     $0xe,%eax
f010d703:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d708:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d70d:	83 e0 ef             	and    $0xffffffef,%eax
f010d710:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d715:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d71a:	83 c8 60             	or     $0x60,%eax
f010d71d:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d722:	a0 5d 8b 69 f0       	mov    0xf0698b5d,%al
f010d727:	83 c8 80             	or     $0xffffff80,%eax
f010d72a:	a2 5d 8b 69 f0       	mov    %al,0xf0698b5d
f010d72f:	b8 8c e6 10 f0       	mov    $0xf010e68c,%eax
f010d734:	c1 e8 10             	shr    $0x10,%eax
f010d737:	66 a3 5e 8b 69 f0    	mov    %ax,0xf0698b5e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d73d:	b8 92 e6 10 f0       	mov    $0xf010e692,%eax
f010d742:	66 a3 70 8b 69 f0    	mov    %ax,0xf0698b70
f010d748:	66 c7 05 72 8b 69 f0 	movw   $0x8,0xf0698b72
f010d74f:	08 00 
f010d751:	a0 74 8b 69 f0       	mov    0xf0698b74,%al
f010d756:	83 e0 e0             	and    $0xffffffe0,%eax
f010d759:	a2 74 8b 69 f0       	mov    %al,0xf0698b74
f010d75e:	a0 74 8b 69 f0       	mov    0xf0698b74,%al
f010d763:	83 e0 1f             	and    $0x1f,%eax
f010d766:	a2 74 8b 69 f0       	mov    %al,0xf0698b74
f010d76b:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d770:	83 e0 f0             	and    $0xfffffff0,%eax
f010d773:	83 c8 0e             	or     $0xe,%eax
f010d776:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d77b:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d780:	83 e0 ef             	and    $0xffffffef,%eax
f010d783:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d788:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d78d:	83 c8 60             	or     $0x60,%eax
f010d790:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d795:	a0 75 8b 69 f0       	mov    0xf0698b75,%al
f010d79a:	83 c8 80             	or     $0xffffff80,%eax
f010d79d:	a2 75 8b 69 f0       	mov    %al,0xf0698b75
f010d7a2:	b8 92 e6 10 f0       	mov    $0xf010e692,%eax
f010d7a7:	c1 e8 10             	shr    $0x10,%eax
f010d7aa:	66 a3 76 8b 69 f0    	mov    %ax,0xf0698b76
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d7b0:	b8 96 e6 10 f0       	mov    $0xf010e696,%eax
f010d7b5:	66 a3 78 8b 69 f0    	mov    %ax,0xf0698b78
f010d7bb:	66 c7 05 7a 8b 69 f0 	movw   $0x8,0xf0698b7a
f010d7c2:	08 00 
f010d7c4:	a0 7c 8b 69 f0       	mov    0xf0698b7c,%al
f010d7c9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7cc:	a2 7c 8b 69 f0       	mov    %al,0xf0698b7c
f010d7d1:	a0 7c 8b 69 f0       	mov    0xf0698b7c,%al
f010d7d6:	83 e0 1f             	and    $0x1f,%eax
f010d7d9:	a2 7c 8b 69 f0       	mov    %al,0xf0698b7c
f010d7de:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d7e3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7e6:	83 c8 0e             	or     $0xe,%eax
f010d7e9:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d7ee:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d7f3:	83 e0 ef             	and    $0xffffffef,%eax
f010d7f6:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d7fb:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d800:	83 c8 60             	or     $0x60,%eax
f010d803:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d808:	a0 7d 8b 69 f0       	mov    0xf0698b7d,%al
f010d80d:	83 c8 80             	or     $0xffffff80,%eax
f010d810:	a2 7d 8b 69 f0       	mov    %al,0xf0698b7d
f010d815:	b8 96 e6 10 f0       	mov    $0xf010e696,%eax
f010d81a:	c1 e8 10             	shr    $0x10,%eax
f010d81d:	66 a3 7e 8b 69 f0    	mov    %ax,0xf0698b7e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d823:	b8 9a e6 10 f0       	mov    $0xf010e69a,%eax
f010d828:	66 a3 80 8b 69 f0    	mov    %ax,0xf0698b80
f010d82e:	66 c7 05 82 8b 69 f0 	movw   $0x8,0xf0698b82
f010d835:	08 00 
f010d837:	a0 84 8b 69 f0       	mov    0xf0698b84,%al
f010d83c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d83f:	a2 84 8b 69 f0       	mov    %al,0xf0698b84
f010d844:	a0 84 8b 69 f0       	mov    0xf0698b84,%al
f010d849:	83 e0 1f             	and    $0x1f,%eax
f010d84c:	a2 84 8b 69 f0       	mov    %al,0xf0698b84
f010d851:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d856:	83 e0 f0             	and    $0xfffffff0,%eax
f010d859:	83 c8 0e             	or     $0xe,%eax
f010d85c:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d861:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d866:	83 e0 ef             	and    $0xffffffef,%eax
f010d869:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d86e:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d873:	83 c8 60             	or     $0x60,%eax
f010d876:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d87b:	a0 85 8b 69 f0       	mov    0xf0698b85,%al
f010d880:	83 c8 80             	or     $0xffffff80,%eax
f010d883:	a2 85 8b 69 f0       	mov    %al,0xf0698b85
f010d888:	b8 9a e6 10 f0       	mov    $0xf010e69a,%eax
f010d88d:	c1 e8 10             	shr    $0x10,%eax
f010d890:	66 a3 86 8b 69 f0    	mov    %ax,0xf0698b86
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d896:	b8 9e e6 10 f0       	mov    $0xf010e69e,%eax
f010d89b:	66 a3 88 8b 69 f0    	mov    %ax,0xf0698b88
f010d8a1:	66 c7 05 8a 8b 69 f0 	movw   $0x8,0xf0698b8a
f010d8a8:	08 00 
f010d8aa:	a0 8c 8b 69 f0       	mov    0xf0698b8c,%al
f010d8af:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8b2:	a2 8c 8b 69 f0       	mov    %al,0xf0698b8c
f010d8b7:	a0 8c 8b 69 f0       	mov    0xf0698b8c,%al
f010d8bc:	83 e0 1f             	and    $0x1f,%eax
f010d8bf:	a2 8c 8b 69 f0       	mov    %al,0xf0698b8c
f010d8c4:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d8c9:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8cc:	83 c8 0e             	or     $0xe,%eax
f010d8cf:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d8d4:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d8d9:	83 e0 ef             	and    $0xffffffef,%eax
f010d8dc:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d8e1:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d8e6:	83 c8 60             	or     $0x60,%eax
f010d8e9:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d8ee:	a0 8d 8b 69 f0       	mov    0xf0698b8d,%al
f010d8f3:	83 c8 80             	or     $0xffffff80,%eax
f010d8f6:	a2 8d 8b 69 f0       	mov    %al,0xf0698b8d
f010d8fb:	b8 9e e6 10 f0       	mov    $0xf010e69e,%eax
f010d900:	c1 e8 10             	shr    $0x10,%eax
f010d903:	66 a3 8e 8b 69 f0    	mov    %ax,0xf0698b8e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d909:	b8 a2 e6 10 f0       	mov    $0xf010e6a2,%eax
f010d90e:	66 a3 a0 8b 69 f0    	mov    %ax,0xf0698ba0
f010d914:	66 c7 05 a2 8b 69 f0 	movw   $0x8,0xf0698ba2
f010d91b:	08 00 
f010d91d:	a0 a4 8b 69 f0       	mov    0xf0698ba4,%al
f010d922:	83 e0 e0             	and    $0xffffffe0,%eax
f010d925:	a2 a4 8b 69 f0       	mov    %al,0xf0698ba4
f010d92a:	a0 a4 8b 69 f0       	mov    0xf0698ba4,%al
f010d92f:	83 e0 1f             	and    $0x1f,%eax
f010d932:	a2 a4 8b 69 f0       	mov    %al,0xf0698ba4
f010d937:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d93c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d93f:	83 c8 0e             	or     $0xe,%eax
f010d942:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d947:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d94c:	83 e0 ef             	and    $0xffffffef,%eax
f010d94f:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d954:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d959:	83 c8 60             	or     $0x60,%eax
f010d95c:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d961:	a0 a5 8b 69 f0       	mov    0xf0698ba5,%al
f010d966:	83 c8 80             	or     $0xffffff80,%eax
f010d969:	a2 a5 8b 69 f0       	mov    %al,0xf0698ba5
f010d96e:	b8 a2 e6 10 f0       	mov    $0xf010e6a2,%eax
f010d973:	c1 e8 10             	shr    $0x10,%eax
f010d976:	66 a3 a6 8b 69 f0    	mov    %ax,0xf0698ba6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d97c:	b8 a8 e6 10 f0       	mov    $0xf010e6a8,%eax
f010d981:	66 a3 a8 8b 69 f0    	mov    %ax,0xf0698ba8
f010d987:	66 c7 05 aa 8b 69 f0 	movw   $0x8,0xf0698baa
f010d98e:	08 00 
f010d990:	a0 ac 8b 69 f0       	mov    0xf0698bac,%al
f010d995:	83 e0 e0             	and    $0xffffffe0,%eax
f010d998:	a2 ac 8b 69 f0       	mov    %al,0xf0698bac
f010d99d:	a0 ac 8b 69 f0       	mov    0xf0698bac,%al
f010d9a2:	83 e0 1f             	and    $0x1f,%eax
f010d9a5:	a2 ac 8b 69 f0       	mov    %al,0xf0698bac
f010d9aa:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d9af:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9b2:	83 c8 0e             	or     $0xe,%eax
f010d9b5:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d9ba:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d9bf:	83 e0 ef             	and    $0xffffffef,%eax
f010d9c2:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d9c7:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d9cc:	83 c8 60             	or     $0x60,%eax
f010d9cf:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d9d4:	a0 ad 8b 69 f0       	mov    0xf0698bad,%al
f010d9d9:	83 c8 80             	or     $0xffffff80,%eax
f010d9dc:	a2 ad 8b 69 f0       	mov    %al,0xf0698bad
f010d9e1:	b8 a8 e6 10 f0       	mov    $0xf010e6a8,%eax
f010d9e6:	c1 e8 10             	shr    $0x10,%eax
f010d9e9:	66 a3 ae 8b 69 f0    	mov    %ax,0xf0698bae
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d9ef:	b8 ac e6 10 f0       	mov    $0xf010e6ac,%eax
f010d9f4:	66 a3 b0 8b 69 f0    	mov    %ax,0xf0698bb0
f010d9fa:	66 c7 05 b2 8b 69 f0 	movw   $0x8,0xf0698bb2
f010da01:	08 00 
f010da03:	a0 b4 8b 69 f0       	mov    0xf0698bb4,%al
f010da08:	83 e0 e0             	and    $0xffffffe0,%eax
f010da0b:	a2 b4 8b 69 f0       	mov    %al,0xf0698bb4
f010da10:	a0 b4 8b 69 f0       	mov    0xf0698bb4,%al
f010da15:	83 e0 1f             	and    $0x1f,%eax
f010da18:	a2 b4 8b 69 f0       	mov    %al,0xf0698bb4
f010da1d:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010da22:	83 e0 f0             	and    $0xfffffff0,%eax
f010da25:	83 c8 0e             	or     $0xe,%eax
f010da28:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010da2d:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010da32:	83 e0 ef             	and    $0xffffffef,%eax
f010da35:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010da3a:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010da3f:	83 c8 60             	or     $0x60,%eax
f010da42:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010da47:	a0 b5 8b 69 f0       	mov    0xf0698bb5,%al
f010da4c:	83 c8 80             	or     $0xffffff80,%eax
f010da4f:	a2 b5 8b 69 f0       	mov    %al,0xf0698bb5
f010da54:	b8 ac e6 10 f0       	mov    $0xf010e6ac,%eax
f010da59:	c1 e8 10             	shr    $0x10,%eax
f010da5c:	66 a3 b6 8b 69 f0    	mov    %ax,0xf0698bb6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010da62:	b8 b2 e6 10 f0       	mov    $0xf010e6b2,%eax
f010da67:	66 a3 b8 8b 69 f0    	mov    %ax,0xf0698bb8
f010da6d:	66 c7 05 ba 8b 69 f0 	movw   $0x8,0xf0698bba
f010da74:	08 00 
f010da76:	a0 bc 8b 69 f0       	mov    0xf0698bbc,%al
f010da7b:	83 e0 e0             	and    $0xffffffe0,%eax
f010da7e:	a2 bc 8b 69 f0       	mov    %al,0xf0698bbc
f010da83:	a0 bc 8b 69 f0       	mov    0xf0698bbc,%al
f010da88:	83 e0 1f             	and    $0x1f,%eax
f010da8b:	a2 bc 8b 69 f0       	mov    %al,0xf0698bbc
f010da90:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010da95:	83 e0 f0             	and    $0xfffffff0,%eax
f010da98:	83 c8 0e             	or     $0xe,%eax
f010da9b:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010daa0:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010daa5:	83 e0 ef             	and    $0xffffffef,%eax
f010daa8:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010daad:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010dab2:	83 c8 60             	or     $0x60,%eax
f010dab5:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010daba:	a0 bd 8b 69 f0       	mov    0xf0698bbd,%al
f010dabf:	83 c8 80             	or     $0xffffff80,%eax
f010dac2:	a2 bd 8b 69 f0       	mov    %al,0xf0698bbd
f010dac7:	b8 b2 e6 10 f0       	mov    $0xf010e6b2,%eax
f010dacc:	c1 e8 10             	shr    $0x10,%eax
f010dacf:	66 a3 be 8b 69 f0    	mov    %ax,0xf0698bbe

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010dad5:	b8 b8 e6 10 f0       	mov    $0xf010e6b8,%eax
f010dada:	66 a3 30 8c 69 f0    	mov    %ax,0xf0698c30
f010dae0:	66 c7 05 32 8c 69 f0 	movw   $0x8,0xf0698c32
f010dae7:	08 00 
f010dae9:	a0 34 8c 69 f0       	mov    0xf0698c34,%al
f010daee:	83 e0 e0             	and    $0xffffffe0,%eax
f010daf1:	a2 34 8c 69 f0       	mov    %al,0xf0698c34
f010daf6:	a0 34 8c 69 f0       	mov    0xf0698c34,%al
f010dafb:	83 e0 1f             	and    $0x1f,%eax
f010dafe:	a2 34 8c 69 f0       	mov    %al,0xf0698c34
f010db03:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010db08:	83 e0 f0             	and    $0xfffffff0,%eax
f010db0b:	83 c8 0e             	or     $0xe,%eax
f010db0e:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010db13:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010db18:	83 e0 ef             	and    $0xffffffef,%eax
f010db1b:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010db20:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010db25:	83 c8 60             	or     $0x60,%eax
f010db28:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010db2d:	a0 35 8c 69 f0       	mov    0xf0698c35,%al
f010db32:	83 c8 80             	or     $0xffffff80,%eax
f010db35:	a2 35 8c 69 f0       	mov    %al,0xf0698c35
f010db3a:	b8 b8 e6 10 f0       	mov    $0xf010e6b8,%eax
f010db3f:	c1 e8 10             	shr    $0x10,%eax
f010db42:	66 a3 36 8c 69 f0    	mov    %ax,0xf0698c36
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010db48:	b8 be e6 10 f0       	mov    $0xf010e6be,%eax
f010db4d:	66 a3 38 8c 69 f0    	mov    %ax,0xf0698c38
f010db53:	66 c7 05 3a 8c 69 f0 	movw   $0x8,0xf0698c3a
f010db5a:	08 00 
f010db5c:	a0 3c 8c 69 f0       	mov    0xf0698c3c,%al
f010db61:	83 e0 e0             	and    $0xffffffe0,%eax
f010db64:	a2 3c 8c 69 f0       	mov    %al,0xf0698c3c
f010db69:	a0 3c 8c 69 f0       	mov    0xf0698c3c,%al
f010db6e:	83 e0 1f             	and    $0x1f,%eax
f010db71:	a2 3c 8c 69 f0       	mov    %al,0xf0698c3c
f010db76:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010db7b:	83 e0 f0             	and    $0xfffffff0,%eax
f010db7e:	83 c8 0e             	or     $0xe,%eax
f010db81:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010db86:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010db8b:	83 e0 ef             	and    $0xffffffef,%eax
f010db8e:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010db93:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010db98:	83 c8 60             	or     $0x60,%eax
f010db9b:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010dba0:	a0 3d 8c 69 f0       	mov    0xf0698c3d,%al
f010dba5:	83 c8 80             	or     $0xffffff80,%eax
f010dba8:	a2 3d 8c 69 f0       	mov    %al,0xf0698c3d
f010dbad:	b8 be e6 10 f0       	mov    $0xf010e6be,%eax
f010dbb2:	c1 e8 10             	shr    $0x10,%eax
f010dbb5:	66 a3 3e 8c 69 f0    	mov    %ax,0xf0698c3e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010dbbb:	b8 c4 e6 10 f0       	mov    $0xf010e6c4,%eax
f010dbc0:	66 a3 40 8c 69 f0    	mov    %ax,0xf0698c40
f010dbc6:	66 c7 05 42 8c 69 f0 	movw   $0x8,0xf0698c42
f010dbcd:	08 00 
f010dbcf:	a0 44 8c 69 f0       	mov    0xf0698c44,%al
f010dbd4:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbd7:	a2 44 8c 69 f0       	mov    %al,0xf0698c44
f010dbdc:	a0 44 8c 69 f0       	mov    0xf0698c44,%al
f010dbe1:	83 e0 1f             	and    $0x1f,%eax
f010dbe4:	a2 44 8c 69 f0       	mov    %al,0xf0698c44
f010dbe9:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010dbee:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbf1:	83 c8 0e             	or     $0xe,%eax
f010dbf4:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dbf9:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010dbfe:	83 e0 ef             	and    $0xffffffef,%eax
f010dc01:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dc06:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010dc0b:	83 c8 60             	or     $0x60,%eax
f010dc0e:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dc13:	a0 45 8c 69 f0       	mov    0xf0698c45,%al
f010dc18:	83 c8 80             	or     $0xffffff80,%eax
f010dc1b:	a2 45 8c 69 f0       	mov    %al,0xf0698c45
f010dc20:	b8 c4 e6 10 f0       	mov    $0xf010e6c4,%eax
f010dc25:	c1 e8 10             	shr    $0x10,%eax
f010dc28:	66 a3 46 8c 69 f0    	mov    %ax,0xf0698c46
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010dc2e:	b8 ca e6 10 f0       	mov    $0xf010e6ca,%eax
f010dc33:	66 a3 48 8c 69 f0    	mov    %ax,0xf0698c48
f010dc39:	66 c7 05 4a 8c 69 f0 	movw   $0x8,0xf0698c4a
f010dc40:	08 00 
f010dc42:	a0 4c 8c 69 f0       	mov    0xf0698c4c,%al
f010dc47:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc4a:	a2 4c 8c 69 f0       	mov    %al,0xf0698c4c
f010dc4f:	a0 4c 8c 69 f0       	mov    0xf0698c4c,%al
f010dc54:	83 e0 1f             	and    $0x1f,%eax
f010dc57:	a2 4c 8c 69 f0       	mov    %al,0xf0698c4c
f010dc5c:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc61:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc64:	83 c8 0e             	or     $0xe,%eax
f010dc67:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc6c:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc71:	83 e0 ef             	and    $0xffffffef,%eax
f010dc74:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc79:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc7e:	83 c8 60             	or     $0x60,%eax
f010dc81:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc86:	a0 4d 8c 69 f0       	mov    0xf0698c4d,%al
f010dc8b:	83 c8 80             	or     $0xffffff80,%eax
f010dc8e:	a2 4d 8c 69 f0       	mov    %al,0xf0698c4d
f010dc93:	b8 ca e6 10 f0       	mov    $0xf010e6ca,%eax
f010dc98:	c1 e8 10             	shr    $0x10,%eax
f010dc9b:	66 a3 4e 8c 69 f0    	mov    %ax,0xf0698c4e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010dca1:	b8 d0 e6 10 f0       	mov    $0xf010e6d0,%eax
f010dca6:	66 a3 50 8c 69 f0    	mov    %ax,0xf0698c50
f010dcac:	66 c7 05 52 8c 69 f0 	movw   $0x8,0xf0698c52
f010dcb3:	08 00 
f010dcb5:	a0 54 8c 69 f0       	mov    0xf0698c54,%al
f010dcba:	83 e0 e0             	and    $0xffffffe0,%eax
f010dcbd:	a2 54 8c 69 f0       	mov    %al,0xf0698c54
f010dcc2:	a0 54 8c 69 f0       	mov    0xf0698c54,%al
f010dcc7:	83 e0 1f             	and    $0x1f,%eax
f010dcca:	a2 54 8c 69 f0       	mov    %al,0xf0698c54
f010dccf:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dcd4:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcd7:	83 c8 0e             	or     $0xe,%eax
f010dcda:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dcdf:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dce4:	83 e0 ef             	and    $0xffffffef,%eax
f010dce7:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dcec:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dcf1:	83 c8 60             	or     $0x60,%eax
f010dcf4:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dcf9:	a0 55 8c 69 f0       	mov    0xf0698c55,%al
f010dcfe:	83 c8 80             	or     $0xffffff80,%eax
f010dd01:	a2 55 8c 69 f0       	mov    %al,0xf0698c55
f010dd06:	b8 d0 e6 10 f0       	mov    $0xf010e6d0,%eax
f010dd0b:	c1 e8 10             	shr    $0x10,%eax
f010dd0e:	66 a3 56 8c 69 f0    	mov    %ax,0xf0698c56
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dd14:	b8 d6 e6 10 f0       	mov    $0xf010e6d6,%eax
f010dd19:	66 a3 58 8c 69 f0    	mov    %ax,0xf0698c58
f010dd1f:	66 c7 05 5a 8c 69 f0 	movw   $0x8,0xf0698c5a
f010dd26:	08 00 
f010dd28:	a0 5c 8c 69 f0       	mov    0xf0698c5c,%al
f010dd2d:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd30:	a2 5c 8c 69 f0       	mov    %al,0xf0698c5c
f010dd35:	a0 5c 8c 69 f0       	mov    0xf0698c5c,%al
f010dd3a:	83 e0 1f             	and    $0x1f,%eax
f010dd3d:	a2 5c 8c 69 f0       	mov    %al,0xf0698c5c
f010dd42:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dd47:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd4a:	83 c8 0e             	or     $0xe,%eax
f010dd4d:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dd52:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dd57:	83 e0 ef             	and    $0xffffffef,%eax
f010dd5a:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dd5f:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dd64:	83 c8 60             	or     $0x60,%eax
f010dd67:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dd6c:	a0 5d 8c 69 f0       	mov    0xf0698c5d,%al
f010dd71:	83 c8 80             	or     $0xffffff80,%eax
f010dd74:	a2 5d 8c 69 f0       	mov    %al,0xf0698c5d
f010dd79:	b8 d6 e6 10 f0       	mov    $0xf010e6d6,%eax
f010dd7e:	c1 e8 10             	shr    $0x10,%eax
f010dd81:	66 a3 5e 8c 69 f0    	mov    %ax,0xf0698c5e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010dd87:	b8 dc e6 10 f0       	mov    $0xf010e6dc,%eax
f010dd8c:	66 a3 60 8c 69 f0    	mov    %ax,0xf0698c60
f010dd92:	66 c7 05 62 8c 69 f0 	movw   $0x8,0xf0698c62
f010dd99:	08 00 
f010dd9b:	a0 64 8c 69 f0       	mov    0xf0698c64,%al
f010dda0:	83 e0 e0             	and    $0xffffffe0,%eax
f010dda3:	a2 64 8c 69 f0       	mov    %al,0xf0698c64
f010dda8:	a0 64 8c 69 f0       	mov    0xf0698c64,%al
f010ddad:	83 e0 1f             	and    $0x1f,%eax
f010ddb0:	a2 64 8c 69 f0       	mov    %al,0xf0698c64
f010ddb5:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010ddba:	83 e0 f0             	and    $0xfffffff0,%eax
f010ddbd:	83 c8 0e             	or     $0xe,%eax
f010ddc0:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010ddc5:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010ddca:	83 e0 ef             	and    $0xffffffef,%eax
f010ddcd:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010ddd2:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010ddd7:	83 c8 60             	or     $0x60,%eax
f010ddda:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010dddf:	a0 65 8c 69 f0       	mov    0xf0698c65,%al
f010dde4:	83 c8 80             	or     $0xffffff80,%eax
f010dde7:	a2 65 8c 69 f0       	mov    %al,0xf0698c65
f010ddec:	b8 dc e6 10 f0       	mov    $0xf010e6dc,%eax
f010ddf1:	c1 e8 10             	shr    $0x10,%eax
f010ddf4:	66 a3 66 8c 69 f0    	mov    %ax,0xf0698c66
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010ddfa:	b8 e2 e6 10 f0       	mov    $0xf010e6e2,%eax
f010ddff:	66 a3 68 8c 69 f0    	mov    %ax,0xf0698c68
f010de05:	66 c7 05 6a 8c 69 f0 	movw   $0x8,0xf0698c6a
f010de0c:	08 00 
f010de0e:	a0 6c 8c 69 f0       	mov    0xf0698c6c,%al
f010de13:	83 e0 e0             	and    $0xffffffe0,%eax
f010de16:	a2 6c 8c 69 f0       	mov    %al,0xf0698c6c
f010de1b:	a0 6c 8c 69 f0       	mov    0xf0698c6c,%al
f010de20:	83 e0 1f             	and    $0x1f,%eax
f010de23:	a2 6c 8c 69 f0       	mov    %al,0xf0698c6c
f010de28:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010de2d:	83 e0 f0             	and    $0xfffffff0,%eax
f010de30:	83 c8 0e             	or     $0xe,%eax
f010de33:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010de38:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010de3d:	83 e0 ef             	and    $0xffffffef,%eax
f010de40:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010de45:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010de4a:	83 c8 60             	or     $0x60,%eax
f010de4d:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010de52:	a0 6d 8c 69 f0       	mov    0xf0698c6d,%al
f010de57:	83 c8 80             	or     $0xffffff80,%eax
f010de5a:	a2 6d 8c 69 f0       	mov    %al,0xf0698c6d
f010de5f:	b8 e2 e6 10 f0       	mov    $0xf010e6e2,%eax
f010de64:	c1 e8 10             	shr    $0x10,%eax
f010de67:	66 a3 6e 8c 69 f0    	mov    %ax,0xf0698c6e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010de6d:	b8 e8 e6 10 f0       	mov    $0xf010e6e8,%eax
f010de72:	66 a3 70 8c 69 f0    	mov    %ax,0xf0698c70
f010de78:	66 c7 05 72 8c 69 f0 	movw   $0x8,0xf0698c72
f010de7f:	08 00 
f010de81:	a0 74 8c 69 f0       	mov    0xf0698c74,%al
f010de86:	83 e0 e0             	and    $0xffffffe0,%eax
f010de89:	a2 74 8c 69 f0       	mov    %al,0xf0698c74
f010de8e:	a0 74 8c 69 f0       	mov    0xf0698c74,%al
f010de93:	83 e0 1f             	and    $0x1f,%eax
f010de96:	a2 74 8c 69 f0       	mov    %al,0xf0698c74
f010de9b:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010dea0:	83 e0 f0             	and    $0xfffffff0,%eax
f010dea3:	83 c8 0e             	or     $0xe,%eax
f010dea6:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010deab:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010deb0:	83 e0 ef             	and    $0xffffffef,%eax
f010deb3:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010deb8:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010debd:	83 c8 60             	or     $0x60,%eax
f010dec0:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010dec5:	a0 75 8c 69 f0       	mov    0xf0698c75,%al
f010deca:	83 c8 80             	or     $0xffffff80,%eax
f010decd:	a2 75 8c 69 f0       	mov    %al,0xf0698c75
f010ded2:	b8 e8 e6 10 f0       	mov    $0xf010e6e8,%eax
f010ded7:	c1 e8 10             	shr    $0x10,%eax
f010deda:	66 a3 76 8c 69 f0    	mov    %ax,0xf0698c76
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010dee0:	b8 ee e6 10 f0       	mov    $0xf010e6ee,%eax
f010dee5:	66 a3 78 8c 69 f0    	mov    %ax,0xf0698c78
f010deeb:	66 c7 05 7a 8c 69 f0 	movw   $0x8,0xf0698c7a
f010def2:	08 00 
f010def4:	a0 7c 8c 69 f0       	mov    0xf0698c7c,%al
f010def9:	83 e0 e0             	and    $0xffffffe0,%eax
f010defc:	a2 7c 8c 69 f0       	mov    %al,0xf0698c7c
f010df01:	a0 7c 8c 69 f0       	mov    0xf0698c7c,%al
f010df06:	83 e0 1f             	and    $0x1f,%eax
f010df09:	a2 7c 8c 69 f0       	mov    %al,0xf0698c7c
f010df0e:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010df13:	83 e0 f0             	and    $0xfffffff0,%eax
f010df16:	83 c8 0e             	or     $0xe,%eax
f010df19:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010df1e:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010df23:	83 e0 ef             	and    $0xffffffef,%eax
f010df26:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010df2b:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010df30:	83 c8 60             	or     $0x60,%eax
f010df33:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010df38:	a0 7d 8c 69 f0       	mov    0xf0698c7d,%al
f010df3d:	83 c8 80             	or     $0xffffff80,%eax
f010df40:	a2 7d 8c 69 f0       	mov    %al,0xf0698c7d
f010df45:	b8 ee e6 10 f0       	mov    $0xf010e6ee,%eax
f010df4a:	c1 e8 10             	shr    $0x10,%eax
f010df4d:	66 a3 7e 8c 69 f0    	mov    %ax,0xf0698c7e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010df53:	b8 f4 e6 10 f0       	mov    $0xf010e6f4,%eax
f010df58:	66 a3 80 8c 69 f0    	mov    %ax,0xf0698c80
f010df5e:	66 c7 05 82 8c 69 f0 	movw   $0x8,0xf0698c82
f010df65:	08 00 
f010df67:	a0 84 8c 69 f0       	mov    0xf0698c84,%al
f010df6c:	83 e0 e0             	and    $0xffffffe0,%eax
f010df6f:	a2 84 8c 69 f0       	mov    %al,0xf0698c84
f010df74:	a0 84 8c 69 f0       	mov    0xf0698c84,%al
f010df79:	83 e0 1f             	and    $0x1f,%eax
f010df7c:	a2 84 8c 69 f0       	mov    %al,0xf0698c84
f010df81:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010df86:	83 e0 f0             	and    $0xfffffff0,%eax
f010df89:	83 c8 0e             	or     $0xe,%eax
f010df8c:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010df91:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010df96:	83 e0 ef             	and    $0xffffffef,%eax
f010df99:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010df9e:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010dfa3:	83 c8 60             	or     $0x60,%eax
f010dfa6:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010dfab:	a0 85 8c 69 f0       	mov    0xf0698c85,%al
f010dfb0:	83 c8 80             	or     $0xffffff80,%eax
f010dfb3:	a2 85 8c 69 f0       	mov    %al,0xf0698c85
f010dfb8:	b8 f4 e6 10 f0       	mov    $0xf010e6f4,%eax
f010dfbd:	c1 e8 10             	shr    $0x10,%eax
f010dfc0:	66 a3 86 8c 69 f0    	mov    %ax,0xf0698c86
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010dfc6:	b8 fa e6 10 f0       	mov    $0xf010e6fa,%eax
f010dfcb:	66 a3 88 8c 69 f0    	mov    %ax,0xf0698c88
f010dfd1:	66 c7 05 8a 8c 69 f0 	movw   $0x8,0xf0698c8a
f010dfd8:	08 00 
f010dfda:	a0 8c 8c 69 f0       	mov    0xf0698c8c,%al
f010dfdf:	83 e0 e0             	and    $0xffffffe0,%eax
f010dfe2:	a2 8c 8c 69 f0       	mov    %al,0xf0698c8c
f010dfe7:	a0 8c 8c 69 f0       	mov    0xf0698c8c,%al
f010dfec:	83 e0 1f             	and    $0x1f,%eax
f010dfef:	a2 8c 8c 69 f0       	mov    %al,0xf0698c8c
f010dff4:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010dff9:	83 e0 f0             	and    $0xfffffff0,%eax
f010dffc:	83 c8 0e             	or     $0xe,%eax
f010dfff:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010e004:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010e009:	83 e0 ef             	and    $0xffffffef,%eax
f010e00c:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010e011:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010e016:	83 c8 60             	or     $0x60,%eax
f010e019:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010e01e:	a0 8d 8c 69 f0       	mov    0xf0698c8d,%al
f010e023:	83 c8 80             	or     $0xffffff80,%eax
f010e026:	a2 8d 8c 69 f0       	mov    %al,0xf0698c8d
f010e02b:	b8 fa e6 10 f0       	mov    $0xf010e6fa,%eax
f010e030:	c1 e8 10             	shr    $0x10,%eax
f010e033:	66 a3 8e 8c 69 f0    	mov    %ax,0xf0698c8e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010e039:	b8 00 e7 10 f0       	mov    $0xf010e700,%eax
f010e03e:	66 a3 90 8c 69 f0    	mov    %ax,0xf0698c90
f010e044:	66 c7 05 92 8c 69 f0 	movw   $0x8,0xf0698c92
f010e04b:	08 00 
f010e04d:	a0 94 8c 69 f0       	mov    0xf0698c94,%al
f010e052:	83 e0 e0             	and    $0xffffffe0,%eax
f010e055:	a2 94 8c 69 f0       	mov    %al,0xf0698c94
f010e05a:	a0 94 8c 69 f0       	mov    0xf0698c94,%al
f010e05f:	83 e0 1f             	and    $0x1f,%eax
f010e062:	a2 94 8c 69 f0       	mov    %al,0xf0698c94
f010e067:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e06c:	83 e0 f0             	and    $0xfffffff0,%eax
f010e06f:	83 c8 0e             	or     $0xe,%eax
f010e072:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e077:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e07c:	83 e0 ef             	and    $0xffffffef,%eax
f010e07f:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e084:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e089:	83 c8 60             	or     $0x60,%eax
f010e08c:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e091:	a0 95 8c 69 f0       	mov    0xf0698c95,%al
f010e096:	83 c8 80             	or     $0xffffff80,%eax
f010e099:	a2 95 8c 69 f0       	mov    %al,0xf0698c95
f010e09e:	b8 00 e7 10 f0       	mov    $0xf010e700,%eax
f010e0a3:	c1 e8 10             	shr    $0x10,%eax
f010e0a6:	66 a3 96 8c 69 f0    	mov    %ax,0xf0698c96
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010e0ac:	b8 06 e7 10 f0       	mov    $0xf010e706,%eax
f010e0b1:	66 a3 98 8c 69 f0    	mov    %ax,0xf0698c98
f010e0b7:	66 c7 05 9a 8c 69 f0 	movw   $0x8,0xf0698c9a
f010e0be:	08 00 
f010e0c0:	a0 9c 8c 69 f0       	mov    0xf0698c9c,%al
f010e0c5:	83 e0 e0             	and    $0xffffffe0,%eax
f010e0c8:	a2 9c 8c 69 f0       	mov    %al,0xf0698c9c
f010e0cd:	a0 9c 8c 69 f0       	mov    0xf0698c9c,%al
f010e0d2:	83 e0 1f             	and    $0x1f,%eax
f010e0d5:	a2 9c 8c 69 f0       	mov    %al,0xf0698c9c
f010e0da:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e0df:	83 e0 f0             	and    $0xfffffff0,%eax
f010e0e2:	83 c8 0e             	or     $0xe,%eax
f010e0e5:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e0ea:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e0ef:	83 e0 ef             	and    $0xffffffef,%eax
f010e0f2:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e0f7:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e0fc:	83 c8 60             	or     $0x60,%eax
f010e0ff:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e104:	a0 9d 8c 69 f0       	mov    0xf0698c9d,%al
f010e109:	83 c8 80             	or     $0xffffff80,%eax
f010e10c:	a2 9d 8c 69 f0       	mov    %al,0xf0698c9d
f010e111:	b8 06 e7 10 f0       	mov    $0xf010e706,%eax
f010e116:	c1 e8 10             	shr    $0x10,%eax
f010e119:	66 a3 9e 8c 69 f0    	mov    %ax,0xf0698c9e
f010e11f:	c7 45 fc 20 8b 69 f0 	movl   $0xf0698b20,-0x4(%ebp)
f010e126:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e12d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e130:	48                   	dec    %eax
f010e131:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e135:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e138:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e13c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e13f:	c1 e8 10             	shr    $0x10,%eax
f010e142:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e146:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e149:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e14c:	90                   	nop
f010e14d:	c9                   	leave  
f010e14e:	c3                   	ret    

f010e14f <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e14f:	55                   	push   %ebp
f010e150:	89 e5                	mov    %esp,%ebp
f010e152:	53                   	push   %ebx
f010e153:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e156:	83 ec 08             	sub    $0x8,%esp
f010e159:	ff 75 08             	pushl  0x8(%ebp)
f010e15c:	68 de 73 12 f0       	push   $0xf01273de
f010e161:	e8 25 2e ff ff       	call   f0100f8b <cprintf>
f010e166:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e169:	8b 45 08             	mov    0x8(%ebp),%eax
f010e16c:	83 ec 0c             	sub    $0xc,%esp
f010e16f:	50                   	push   %eax
f010e170:	e8 fd 00 00 00       	call   f010e272 <print_regs>
f010e175:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e178:	8b 45 08             	mov    0x8(%ebp),%eax
f010e17b:	8b 40 20             	mov    0x20(%eax),%eax
f010e17e:	0f b7 c0             	movzwl %ax,%eax
f010e181:	83 ec 08             	sub    $0x8,%esp
f010e184:	50                   	push   %eax
f010e185:	68 f0 73 12 f0       	push   $0xf01273f0
f010e18a:	e8 fc 2d ff ff       	call   f0100f8b <cprintf>
f010e18f:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e192:	8b 45 08             	mov    0x8(%ebp),%eax
f010e195:	8b 40 24             	mov    0x24(%eax),%eax
f010e198:	0f b7 c0             	movzwl %ax,%eax
f010e19b:	83 ec 08             	sub    $0x8,%esp
f010e19e:	50                   	push   %eax
f010e19f:	68 03 74 12 f0       	push   $0xf0127403
f010e1a4:	e8 e2 2d ff ff       	call   f0100f8b <cprintf>
f010e1a9:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e1ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1af:	8b 58 28             	mov    0x28(%eax),%ebx
f010e1b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1b5:	8b 40 28             	mov    0x28(%eax),%eax
f010e1b8:	83 ec 0c             	sub    $0xc,%esp
f010e1bb:	50                   	push   %eax
f010e1bc:	e8 28 ee ff ff       	call   f010cfe9 <trapname>
f010e1c1:	83 c4 10             	add    $0x10,%esp
f010e1c4:	89 c2                	mov    %eax,%edx
f010e1c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1c9:	8b 40 28             	mov    0x28(%eax),%eax
f010e1cc:	53                   	push   %ebx
f010e1cd:	52                   	push   %edx
f010e1ce:	50                   	push   %eax
f010e1cf:	68 16 74 12 f0       	push   $0xf0127416
f010e1d4:	e8 b2 2d ff ff       	call   f0100f8b <cprintf>
f010e1d9:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e1dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1df:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e1e2:	83 ec 08             	sub    $0x8,%esp
f010e1e5:	50                   	push   %eax
f010e1e6:	68 2d 74 12 f0       	push   $0xf012742d
f010e1eb:	e8 9b 2d ff ff       	call   f0100f8b <cprintf>
f010e1f0:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e1f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1f6:	8b 40 30             	mov    0x30(%eax),%eax
f010e1f9:	83 ec 08             	sub    $0x8,%esp
f010e1fc:	50                   	push   %eax
f010e1fd:	68 3c 74 12 f0       	push   $0xf012743c
f010e202:	e8 84 2d ff ff       	call   f0100f8b <cprintf>
f010e207:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e20a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e20d:	8b 40 34             	mov    0x34(%eax),%eax
f010e210:	0f b7 c0             	movzwl %ax,%eax
f010e213:	83 ec 08             	sub    $0x8,%esp
f010e216:	50                   	push   %eax
f010e217:	68 4b 74 12 f0       	push   $0xf012744b
f010e21c:	e8 6a 2d ff ff       	call   f0100f8b <cprintf>
f010e221:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e224:	8b 45 08             	mov    0x8(%ebp),%eax
f010e227:	8b 40 38             	mov    0x38(%eax),%eax
f010e22a:	83 ec 08             	sub    $0x8,%esp
f010e22d:	50                   	push   %eax
f010e22e:	68 5e 74 12 f0       	push   $0xf012745e
f010e233:	e8 53 2d ff ff       	call   f0100f8b <cprintf>
f010e238:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e23b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e23e:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e241:	83 ec 08             	sub    $0x8,%esp
f010e244:	50                   	push   %eax
f010e245:	68 6d 74 12 f0       	push   $0xf012746d
f010e24a:	e8 3c 2d ff ff       	call   f0100f8b <cprintf>
f010e24f:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e252:	8b 45 08             	mov    0x8(%ebp),%eax
f010e255:	8b 40 40             	mov    0x40(%eax),%eax
f010e258:	0f b7 c0             	movzwl %ax,%eax
f010e25b:	83 ec 08             	sub    $0x8,%esp
f010e25e:	50                   	push   %eax
f010e25f:	68 7c 74 12 f0       	push   $0xf012747c
f010e264:	e8 22 2d ff ff       	call   f0100f8b <cprintf>
f010e269:	83 c4 10             	add    $0x10,%esp
}
f010e26c:	90                   	nop
f010e26d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e270:	c9                   	leave  
f010e271:	c3                   	ret    

f010e272 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e272:	55                   	push   %ebp
f010e273:	89 e5                	mov    %esp,%ebp
f010e275:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e278:	8b 45 08             	mov    0x8(%ebp),%eax
f010e27b:	8b 00                	mov    (%eax),%eax
f010e27d:	83 ec 08             	sub    $0x8,%esp
f010e280:	50                   	push   %eax
f010e281:	68 8f 74 12 f0       	push   $0xf012748f
f010e286:	e8 00 2d ff ff       	call   f0100f8b <cprintf>
f010e28b:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e28e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e291:	8b 40 04             	mov    0x4(%eax),%eax
f010e294:	83 ec 08             	sub    $0x8,%esp
f010e297:	50                   	push   %eax
f010e298:	68 9e 74 12 f0       	push   $0xf012749e
f010e29d:	e8 e9 2c ff ff       	call   f0100f8b <cprintf>
f010e2a2:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e2a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2a8:	8b 40 08             	mov    0x8(%eax),%eax
f010e2ab:	83 ec 08             	sub    $0x8,%esp
f010e2ae:	50                   	push   %eax
f010e2af:	68 ad 74 12 f0       	push   $0xf01274ad
f010e2b4:	e8 d2 2c ff ff       	call   f0100f8b <cprintf>
f010e2b9:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e2bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2bf:	8b 40 0c             	mov    0xc(%eax),%eax
f010e2c2:	83 ec 08             	sub    $0x8,%esp
f010e2c5:	50                   	push   %eax
f010e2c6:	68 bc 74 12 f0       	push   $0xf01274bc
f010e2cb:	e8 bb 2c ff ff       	call   f0100f8b <cprintf>
f010e2d0:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e2d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2d6:	8b 40 10             	mov    0x10(%eax),%eax
f010e2d9:	83 ec 08             	sub    $0x8,%esp
f010e2dc:	50                   	push   %eax
f010e2dd:	68 cb 74 12 f0       	push   $0xf01274cb
f010e2e2:	e8 a4 2c ff ff       	call   f0100f8b <cprintf>
f010e2e7:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e2ea:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2ed:	8b 40 14             	mov    0x14(%eax),%eax
f010e2f0:	83 ec 08             	sub    $0x8,%esp
f010e2f3:	50                   	push   %eax
f010e2f4:	68 da 74 12 f0       	push   $0xf01274da
f010e2f9:	e8 8d 2c ff ff       	call   f0100f8b <cprintf>
f010e2fe:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e301:	8b 45 08             	mov    0x8(%ebp),%eax
f010e304:	8b 40 18             	mov    0x18(%eax),%eax
f010e307:	83 ec 08             	sub    $0x8,%esp
f010e30a:	50                   	push   %eax
f010e30b:	68 e9 74 12 f0       	push   $0xf01274e9
f010e310:	e8 76 2c ff ff       	call   f0100f8b <cprintf>
f010e315:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e318:	8b 45 08             	mov    0x8(%ebp),%eax
f010e31b:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e31e:	83 ec 08             	sub    $0x8,%esp
f010e321:	50                   	push   %eax
f010e322:	68 f8 74 12 f0       	push   $0xf01274f8
f010e327:	e8 5f 2c ff ff       	call   f0100f8b <cprintf>
f010e32c:	83 c4 10             	add    $0x10,%esp
}
f010e32f:	90                   	nop
f010e330:	c9                   	leave  
f010e331:	c3                   	ret    

f010e332 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e332:	55                   	push   %ebp
f010e333:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e335:	8b 45 08             	mov    0x8(%ebp),%eax
f010e338:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e33b:	89 14 85 20 93 69 f0 	mov    %edx,-0xf966ce0(,%eax,4)
}
f010e342:	90                   	nop
f010e343:	5d                   	pop    %ebp
f010e344:	c3                   	ret    

f010e345 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e345:	55                   	push   %ebp
f010e346:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e348:	8b 45 08             	mov    0x8(%ebp),%eax
f010e34b:	c7 04 85 20 93 69 f0 	movl   $0x0,-0xf966ce0(,%eax,4)
f010e352:	00 00 00 00 
}
f010e356:	90                   	nop
f010e357:	5d                   	pop    %ebp
f010e358:	c3                   	ret    

f010e359 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e359:	55                   	push   %ebp
f010e35a:	89 e5                	mov    %esp,%ebp
f010e35c:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e35f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e362:	8b 40 28             	mov    0x28(%eax),%eax
f010e365:	83 e8 20             	sub    $0x20,%eax
f010e368:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e36b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e36e:	8b 04 85 20 93 69 f0 	mov    -0xf966ce0(,%eax,4),%eax
f010e375:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e378:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e37c:	74 0e                	je     f010e38c <irq_dispatch+0x33>
	{
		handler(tf);
f010e37e:	83 ec 0c             	sub    $0xc,%esp
f010e381:	ff 75 08             	pushl  0x8(%ebp)
f010e384:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e387:	ff d0                	call   *%eax
f010e389:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e38c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e38f:	0f b6 c0             	movzbl %al,%eax
f010e392:	83 ec 0c             	sub    $0xc,%esp
f010e395:	50                   	push   %eax
f010e396:	e8 38 8d ff ff       	call   f01070d3 <pic_sendEOI>
f010e39b:	83 c4 10             	add    $0x10,%esp
}
f010e39e:	90                   	nop
f010e39f:	c9                   	leave  
f010e3a0:	c3                   	ret    

f010e3a1 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e3a1:	55                   	push   %ebp
f010e3a2:	89 e5                	mov    %esp,%ebp
f010e3a4:	57                   	push   %edi
f010e3a5:	56                   	push   %esi
f010e3a6:	53                   	push   %ebx
f010e3a7:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e3aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3ad:	8b 40 28             	mov    0x28(%eax),%eax
f010e3b0:	83 f8 0e             	cmp    $0xe,%eax
f010e3b3:	75 51                	jne    f010e406 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e3b5:	a0 60 93 69 f0       	mov    0xf0699360,%al
f010e3ba:	84 c0                	test   %al,%al
f010e3bc:	74 1f                	je     f010e3dd <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e3be:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3c1:	8b 40 30             	mov    0x30(%eax),%eax
f010e3c4:	89 c2                	mov    %eax,%edx
f010e3c6:	a0 60 93 69 f0       	mov    0xf0699360,%al
f010e3cb:	0f b6 c0             	movzbl %al,%eax
f010e3ce:	01 d0                	add    %edx,%eax
f010e3d0:	89 c2                	mov    %eax,%edx
f010e3d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3d5:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e3d8:	e9 0c 01 00 00       	jmp    f010e4e9 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e3dd:	83 ec 0c             	sub    $0xc,%esp
f010e3e0:	6a 01                	push   $0x1
f010e3e2:	e8 ee 12 00 00       	call   f010f6d5 <isPageReplacmentAlgorithmLRU>
f010e3e7:	83 c4 10             	add    $0x10,%esp
f010e3ea:	85 c0                	test   %eax,%eax
f010e3ec:	74 05                	je     f010e3f3 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e3ee:	e8 4f 88 ff ff       	call   f0106c42 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e3f3:	83 ec 0c             	sub    $0xc,%esp
f010e3f6:	ff 75 08             	pushl  0x8(%ebp)
f010e3f9:	e8 bc 13 00 00       	call   f010f7ba <fault_handler>
f010e3fe:	83 c4 10             	add    $0x10,%esp
f010e401:	e9 e3 00 00 00       	jmp    f010e4e9 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e406:	8b 45 08             	mov    0x8(%ebp),%eax
f010e409:	8b 40 28             	mov    0x28(%eax),%eax
f010e40c:	83 f8 30             	cmp    $0x30,%eax
f010e40f:	75 6e                	jne    f010e47f <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e411:	8b 45 08             	mov    0x8(%ebp),%eax
f010e414:	8b 40 38             	mov    0x38(%eax),%eax
f010e417:	25 00 02 00 00       	and    $0x200,%eax
f010e41c:	85 c0                	test   %eax,%eax
f010e41e:	74 06                	je     f010e426 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e420:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e421:	e8 bc 68 ff ff       	call   f0104ce2 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e426:	8b 45 08             	mov    0x8(%ebp),%eax
f010e429:	8b 78 04             	mov    0x4(%eax),%edi
f010e42c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e42f:	8b 30                	mov    (%eax),%esi
f010e431:	8b 45 08             	mov    0x8(%ebp),%eax
f010e434:	8b 58 10             	mov    0x10(%eax),%ebx
f010e437:	8b 45 08             	mov    0x8(%ebp),%eax
f010e43a:	8b 48 18             	mov    0x18(%eax),%ecx
f010e43d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e440:	8b 50 14             	mov    0x14(%eax),%edx
f010e443:	8b 45 08             	mov    0x8(%ebp),%eax
f010e446:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e449:	83 ec 08             	sub    $0x8,%esp
f010e44c:	57                   	push   %edi
f010e44d:	56                   	push   %esi
f010e44e:	53                   	push   %ebx
f010e44f:	51                   	push   %ecx
f010e450:	52                   	push   %edx
f010e451:	50                   	push   %eax
f010e452:	e8 a5 09 00 00       	call   f010edfc <syscall>
f010e457:	83 c4 20             	add    $0x20,%esp
f010e45a:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e45d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e460:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e463:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e466:	9c                   	pushf  
f010e467:	58                   	pop    %eax
f010e468:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e46b:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e46e:	25 00 02 00 00       	and    $0x200,%eax
f010e473:	85 c0                	test   %eax,%eax
f010e475:	74 72                	je     f010e4e9 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e477:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e478:	e8 3d 68 ff ff       	call   f0104cba <kclock_stop>
f010e47d:	eb 6a                	jmp    f010e4e9 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e47f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e482:	8b 40 28             	mov    0x28(%eax),%eax
f010e485:	83 f8 08             	cmp    $0x8,%eax
f010e488:	75 17                	jne    f010e4a1 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e48a:	83 ec 04             	sub    $0x4,%esp
f010e48d:	68 07 75 12 f0       	push   $0xf0127507
f010e492:	68 22 01 00 00       	push   $0x122
f010e497:	68 16 75 12 f0       	push   $0xf0127516
f010e49c:	e8 98 1e ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e4a1:	83 ec 0c             	sub    $0xc,%esp
f010e4a4:	ff 75 08             	pushl  0x8(%ebp)
f010e4a7:	e8 a3 fc ff ff       	call   f010e14f <print_trapframe>
f010e4ac:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e4af:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4b2:	8b 40 34             	mov    0x34(%eax),%eax
f010e4b5:	66 83 f8 08          	cmp    $0x8,%ax
f010e4b9:	75 17                	jne    f010e4d2 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e4bb:	83 ec 04             	sub    $0x4,%esp
f010e4be:	68 27 75 12 f0       	push   $0xf0127527
f010e4c3:	68 2a 01 00 00       	push   $0x12a
f010e4c8:	68 16 75 12 f0       	push   $0xf0127516
f010e4cd:	e8 67 1e ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e4d2:	83 ec 04             	sub    $0x4,%esp
f010e4d5:	68 40 75 12 f0       	push   $0xf0127540
f010e4da:	68 2f 01 00 00       	push   $0x12f
f010e4df:	68 16 75 12 f0       	push   $0xf0127516
f010e4e4:	e8 50 1e ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e4e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e4ec:	5b                   	pop    %ebx
f010e4ed:	5e                   	pop    %esi
f010e4ee:	5f                   	pop    %edi
f010e4ef:	5d                   	pop    %ebp
f010e4f0:	c3                   	ret    

f010e4f1 <trap>:

void trap(struct Trapframe *tf)
{
f010e4f1:	55                   	push   %ebp
f010e4f2:	89 e5                	mov    %esp,%ebp
f010e4f4:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e4f7:	e8 be 67 ff ff       	call   f0104cba <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e4fc:	9c                   	pushf  
f010e4fd:	58                   	pop    %eax
f010e4fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e501:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e504:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e507:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e50a:	25 00 02 00 00       	and    $0x200,%eax
f010e50f:	85 c0                	test   %eax,%eax
f010e511:	74 25                	je     f010e538 <trap+0x47>
	{
		print_trapframe(tf);
f010e513:	83 ec 0c             	sub    $0xc,%esp
f010e516:	ff 75 08             	pushl  0x8(%ebp)
f010e519:	e8 31 fc ff ff       	call   f010e14f <print_trapframe>
f010e51e:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e521:	83 ec 04             	sub    $0x4,%esp
f010e524:	68 60 75 12 f0       	push   $0xf0127560
f010e529:	68 45 01 00 00       	push   $0x145
f010e52e:	68 16 75 12 f0       	push   $0xf0127516
f010e533:	e8 01 1e ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e538:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e53f:	e8 55 d5 ff ff       	call   f010ba99 <get_cpu_proc>
f010e544:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e547:	8b 45 08             	mov    0x8(%ebp),%eax
f010e54a:	8b 40 34             	mov    0x34(%eax),%eax
f010e54d:	0f b7 c0             	movzwl %ax,%eax
f010e550:	83 e0 03             	and    $0x3,%eax
f010e553:	83 f8 03             	cmp    $0x3,%eax
f010e556:	75 54                	jne    f010e5ac <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e558:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e55c:	74 0b                	je     f010e569 <trap+0x78>
f010e55e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e561:	8b 40 18             	mov    0x18(%eax),%eax
f010e564:	83 f8 02             	cmp    $0x2,%eax
f010e567:	74 19                	je     f010e582 <trap+0x91>
f010e569:	68 a4 75 12 f0       	push   $0xf01275a4
f010e56e:	68 d2 75 12 f0       	push   $0xf01275d2
f010e573:	68 4d 01 00 00       	push   $0x14d
f010e578:	68 16 75 12 f0       	push   $0xf0127516
f010e57d:	e8 b7 1d ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e582:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e585:	8b 00                	mov    (%eax),%eax
f010e587:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e58a:	74 19                	je     f010e5a5 <trap+0xb4>
f010e58c:	68 e7 75 12 f0       	push   $0xf01275e7
f010e591:	68 d2 75 12 f0       	push   $0xf01275d2
f010e596:	68 4f 01 00 00       	push   $0x14f
f010e59b:	68 16 75 12 f0       	push   $0xf0127516
f010e5a0:	e8 94 1d ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010e5a5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e5ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5af:	8b 40 28             	mov    0x28(%eax),%eax
f010e5b2:	83 f8 1f             	cmp    $0x1f,%eax
f010e5b5:	76 1b                	jbe    f010e5d2 <trap+0xe1>
f010e5b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5ba:	8b 40 28             	mov    0x28(%eax),%eax
f010e5bd:	83 f8 2f             	cmp    $0x2f,%eax
f010e5c0:	77 10                	ja     f010e5d2 <trap+0xe1>
	{
		irq_dispatch(tf);
f010e5c2:	83 ec 0c             	sub    $0xc,%esp
f010e5c5:	ff 75 08             	pushl  0x8(%ebp)
f010e5c8:	e8 8c fd ff ff       	call   f010e359 <irq_dispatch>
f010e5cd:	83 c4 10             	add    $0x10,%esp
f010e5d0:	eb 0e                	jmp    f010e5e0 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010e5d2:	83 ec 0c             	sub    $0xc,%esp
f010e5d5:	ff 75 08             	pushl  0x8(%ebp)
f010e5d8:	e8 c4 fd ff ff       	call   f010e3a1 <trap_dispatch>
f010e5dd:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e5e0:	9c                   	pushf  
f010e5e1:	58                   	pop    %eax
f010e5e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010e5e5:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e5e8:	25 00 02 00 00       	and    $0x200,%eax
f010e5ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010e5f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010e5f4:	74 19                	je     f010e60f <trap+0x11e>
f010e5f6:	68 fd 75 12 f0       	push   $0xf01275fd
f010e5fb:	68 d2 75 12 f0       	push   $0xf01275d2
f010e600:	68 66 01 00 00       	push   $0x166
f010e605:	68 16 75 12 f0       	push   $0xf0127516
f010e60a:	e8 2a 1d ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e60f:	e8 ce 66 ff ff       	call   f0104ce2 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e614:	90                   	nop
f010e615:	c9                   	leave  
f010e616:	c3                   	ret    
f010e617:	90                   	nop

f010e618 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e618:	6a 08                	push   $0x8
f010e61a:	e9 ed 00 00 00       	jmp    f010e70c <_alltraps>
f010e61f:	90                   	nop

f010e620 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e620:	6a 0e                	push   $0xe
f010e622:	e9 e5 00 00 00       	jmp    f010e70c <_alltraps>
f010e627:	90                   	nop

f010e628 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e628:	6a 00                	push   $0x0
f010e62a:	6a 20                	push   $0x20
f010e62c:	e9 db 00 00 00       	jmp    f010e70c <_alltraps>
f010e631:	90                   	nop

f010e632 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e632:	6a 00                	push   $0x0
f010e634:	6a 21                	push   $0x21
f010e636:	e9 d1 00 00 00       	jmp    f010e70c <_alltraps>
f010e63b:	90                   	nop

f010e63c <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e63c:	6a 00                	push   $0x0
f010e63e:	6a 30                	push   $0x30
f010e640:	e9 c7 00 00 00       	jmp    f010e70c <_alltraps>
f010e645:	90                   	nop

f010e646 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e646:	6a 00                	push   $0x0
f010e648:	6a 00                	push   $0x0
f010e64a:	e9 bd 00 00 00       	jmp    f010e70c <_alltraps>
f010e64f:	90                   	nop

f010e650 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e650:	6a 00                	push   $0x0
f010e652:	6a 01                	push   $0x1
f010e654:	e9 b3 00 00 00       	jmp    f010e70c <_alltraps>
f010e659:	90                   	nop

f010e65a <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e65a:	6a 00                	push   $0x0
f010e65c:	6a 02                	push   $0x2
f010e65e:	e9 a9 00 00 00       	jmp    f010e70c <_alltraps>
f010e663:	90                   	nop

f010e664 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e664:	6a 00                	push   $0x0
f010e666:	6a 03                	push   $0x3
f010e668:	e9 9f 00 00 00       	jmp    f010e70c <_alltraps>
f010e66d:	90                   	nop

f010e66e <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e66e:	6a 00                	push   $0x0
f010e670:	6a 04                	push   $0x4
f010e672:	e9 95 00 00 00       	jmp    f010e70c <_alltraps>
f010e677:	90                   	nop

f010e678 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e678:	6a 00                	push   $0x0
f010e67a:	6a 05                	push   $0x5
f010e67c:	e9 8b 00 00 00       	jmp    f010e70c <_alltraps>
f010e681:	90                   	nop

f010e682 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e682:	6a 00                	push   $0x0
f010e684:	6a 06                	push   $0x6
f010e686:	e9 81 00 00 00       	jmp    f010e70c <_alltraps>
f010e68b:	90                   	nop

f010e68c <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e68c:	6a 00                	push   $0x0
f010e68e:	6a 07                	push   $0x7
f010e690:	eb 7a                	jmp    f010e70c <_alltraps>

f010e692 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e692:	6a 0a                	push   $0xa
f010e694:	eb 76                	jmp    f010e70c <_alltraps>

f010e696 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e696:	6a 0b                	push   $0xb
f010e698:	eb 72                	jmp    f010e70c <_alltraps>

f010e69a <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e69a:	6a 0c                	push   $0xc
f010e69c:	eb 6e                	jmp    f010e70c <_alltraps>

f010e69e <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e69e:	6a 0d                	push   $0xd
f010e6a0:	eb 6a                	jmp    f010e70c <_alltraps>

f010e6a2 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e6a2:	6a 00                	push   $0x0
f010e6a4:	6a 10                	push   $0x10
f010e6a6:	eb 64                	jmp    f010e70c <_alltraps>

f010e6a8 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e6a8:	6a 11                	push   $0x11
f010e6aa:	eb 60                	jmp    f010e70c <_alltraps>

f010e6ac <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e6ac:	6a 00                	push   $0x0
f010e6ae:	6a 12                	push   $0x12
f010e6b0:	eb 5a                	jmp    f010e70c <_alltraps>

f010e6b2 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e6b2:	6a 00                	push   $0x0
f010e6b4:	6a 13                	push   $0x13
f010e6b6:	eb 54                	jmp    f010e70c <_alltraps>

f010e6b8 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e6b8:	6a 00                	push   $0x0
f010e6ba:	6a 22                	push   $0x22
f010e6bc:	eb 4e                	jmp    f010e70c <_alltraps>

f010e6be <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e6be:	6a 00                	push   $0x0
f010e6c0:	6a 23                	push   $0x23
f010e6c2:	eb 48                	jmp    f010e70c <_alltraps>

f010e6c4 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e6c4:	6a 00                	push   $0x0
f010e6c6:	6a 24                	push   $0x24
f010e6c8:	eb 42                	jmp    f010e70c <_alltraps>

f010e6ca <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e6ca:	6a 00                	push   $0x0
f010e6cc:	6a 25                	push   $0x25
f010e6ce:	eb 3c                	jmp    f010e70c <_alltraps>

f010e6d0 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e6d0:	6a 00                	push   $0x0
f010e6d2:	6a 26                	push   $0x26
f010e6d4:	eb 36                	jmp    f010e70c <_alltraps>

f010e6d6 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e6d6:	6a 00                	push   $0x0
f010e6d8:	6a 27                	push   $0x27
f010e6da:	eb 30                	jmp    f010e70c <_alltraps>

f010e6dc <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e6dc:	6a 00                	push   $0x0
f010e6de:	6a 28                	push   $0x28
f010e6e0:	eb 2a                	jmp    f010e70c <_alltraps>

f010e6e2 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e6e2:	6a 00                	push   $0x0
f010e6e4:	6a 29                	push   $0x29
f010e6e6:	eb 24                	jmp    f010e70c <_alltraps>

f010e6e8 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e6e8:	6a 00                	push   $0x0
f010e6ea:	6a 2a                	push   $0x2a
f010e6ec:	eb 1e                	jmp    f010e70c <_alltraps>

f010e6ee <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e6ee:	6a 00                	push   $0x0
f010e6f0:	6a 2b                	push   $0x2b
f010e6f2:	eb 18                	jmp    f010e70c <_alltraps>

f010e6f4 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e6f4:	6a 00                	push   $0x0
f010e6f6:	6a 2c                	push   $0x2c
f010e6f8:	eb 12                	jmp    f010e70c <_alltraps>

f010e6fa <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e6fa:	6a 00                	push   $0x0
f010e6fc:	6a 2d                	push   $0x2d
f010e6fe:	eb 0c                	jmp    f010e70c <_alltraps>

f010e700 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e700:	6a 00                	push   $0x0
f010e702:	6a 2e                	push   $0x2e
f010e704:	eb 06                	jmp    f010e70c <_alltraps>

f010e706 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e706:	6a 00                	push   $0x0
f010e708:	6a 2f                	push   $0x2f
f010e70a:	eb 00                	jmp    f010e70c <_alltraps>

f010e70c <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e70c:	1e                   	push   %ds
push 	%es
f010e70d:	06                   	push   %es
pushal
f010e70e:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e70f:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e713:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e715:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e717:	54                   	push   %esp
call 	trap
f010e718:	e8 d4 fd ff ff       	call   f010e4f1 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e71d:	59                   	pop    %ecx

f010e71e <trapret>:
.globl trapret
trapret:
popal
f010e71e:	61                   	popa   
pop 	%es
f010e71f:	07                   	pop    %es
pop 	%ds
f010e720:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e721:	83 c4 08             	add    $0x8,%esp
iret
f010e724:	cf                   	iret   

f010e725 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e725:	55                   	push   %ebp
f010e726:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e728:	8b 45 08             	mov    0x8(%ebp),%eax
f010e72b:	8b 15 e0 1a 6c f0    	mov    0xf06c1ae0,%edx
f010e731:	29 d0                	sub    %edx,%eax
f010e733:	c1 f8 03             	sar    $0x3,%eax
f010e736:	89 c2                	mov    %eax,%edx
f010e738:	89 d0                	mov    %edx,%eax
f010e73a:	c1 e0 02             	shl    $0x2,%eax
f010e73d:	01 d0                	add    %edx,%eax
f010e73f:	c1 e0 02             	shl    $0x2,%eax
f010e742:	01 d0                	add    %edx,%eax
f010e744:	c1 e0 02             	shl    $0x2,%eax
f010e747:	01 d0                	add    %edx,%eax
f010e749:	89 c1                	mov    %eax,%ecx
f010e74b:	c1 e1 08             	shl    $0x8,%ecx
f010e74e:	01 c8                	add    %ecx,%eax
f010e750:	89 c1                	mov    %eax,%ecx
f010e752:	c1 e1 10             	shl    $0x10,%ecx
f010e755:	01 c8                	add    %ecx,%eax
f010e757:	01 c0                	add    %eax,%eax
f010e759:	01 d0                	add    %edx,%eax
}
f010e75b:	5d                   	pop    %ebp
f010e75c:	c3                   	ret    

f010e75d <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e75d:	55                   	push   %ebp
f010e75e:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e760:	ff 75 08             	pushl  0x8(%ebp)
f010e763:	e8 bd ff ff ff       	call   f010e725 <to_frame_number>
f010e768:	83 c4 04             	add    $0x4,%esp
f010e76b:	c1 e0 0c             	shl    $0xc,%eax
}
f010e76e:	c9                   	leave  
f010e76f:	c3                   	ret    

f010e770 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e770:	55                   	push   %ebp
f010e771:	89 e5                	mov    %esp,%ebp
f010e773:	83 ec 18             	sub    $0x18,%esp
f010e776:	8b 45 10             	mov    0x10(%ebp),%eax
f010e779:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010e77c:	e8 4e 8a ff ff       	call   f01071cf <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010e781:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010e785:	74 23                	je     f010e7aa <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e787:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010e78c:	8b 40 10             	mov    0x10(%eax),%eax
f010e78f:	8b 15 e0 92 b0 f0    	mov    0xf0b092e0,%edx
f010e795:	83 c2 20             	add    $0x20,%edx
f010e798:	83 ec 04             	sub    $0x4,%esp
f010e79b:	50                   	push   %eax
f010e79c:	52                   	push   %edx
f010e79d:	68 b0 77 12 f0       	push   $0xf01277b0
f010e7a2:	e8 e4 27 ff ff       	call   f0100f8b <cprintf>
f010e7a7:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010e7aa:	83 ec 04             	sub    $0x4,%esp
f010e7ad:	ff 75 08             	pushl  0x8(%ebp)
f010e7b0:	ff 75 0c             	pushl  0xc(%ebp)
f010e7b3:	68 b9 77 12 f0       	push   $0xf01277b9
f010e7b8:	e8 ce 27 ff ff       	call   f0100f8b <cprintf>
f010e7bd:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010e7c0:	e8 5c 8a ff ff       	call   f0107221 <popcli>
}
f010e7c5:	90                   	nop
f010e7c6:	c9                   	leave  
f010e7c7:	c3                   	ret    

f010e7c8 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e7c8:	55                   	push   %ebp
f010e7c9:	89 e5                	mov    %esp,%ebp
f010e7cb:	83 ec 18             	sub    $0x18,%esp
f010e7ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7d1:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e7d4:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e7d8:	83 ec 08             	sub    $0x8,%esp
f010e7db:	50                   	push   %eax
f010e7dc:	68 be 77 12 f0       	push   $0xf01277be
f010e7e1:	e8 a5 27 ff ff       	call   f0100f8b <cprintf>
f010e7e6:	83 c4 10             	add    $0x10,%esp
}
f010e7e9:	90                   	nop
f010e7ea:	c9                   	leave  
f010e7eb:	c3                   	ret    

f010e7ec <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e7ec:	55                   	push   %ebp
f010e7ed:	89 e5                	mov    %esp,%ebp
f010e7ef:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e7f2:	9c                   	pushf  
f010e7f3:	58                   	pop    %eax
f010e7f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e7f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e7fa:	25 00 02 00 00       	and    $0x200,%eax
f010e7ff:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e802:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e806:	74 10                	je     f010e818 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e808:	e8 b7 25 ff ff       	call   f0100dc4 <cons_getc2>
f010e80d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e810:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e814:	74 f2                	je     f010e808 <sys_cgetc+0x1c>
f010e816:	eb 0e                	jmp    f010e826 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e818:	e8 4c 25 ff ff       	call   f0100d69 <cons_getc>
f010e81d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e820:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e824:	74 f2                	je     f010e818 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e826:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e829:	c9                   	leave  
f010e82a:	c3                   	ret    

f010e82b <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e82b:	55                   	push   %ebp
f010e82c:	89 e5                	mov    %esp,%ebp
f010e82e:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e831:	e8 7a 26 ff ff       	call   f0100eb0 <cons_lock>
}
f010e836:	90                   	nop
f010e837:	c9                   	leave  
f010e838:	c3                   	ret    

f010e839 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e839:	55                   	push   %ebp
f010e83a:	89 e5                	mov    %esp,%ebp
f010e83c:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e83f:	e8 b3 26 ff ff       	call   f0100ef7 <cons_unlock>
}
f010e844:	90                   	nop
f010e845:	c9                   	leave  
f010e846:	c3                   	ret    

f010e847 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e847:	55                   	push   %ebp
f010e848:	89 e5                	mov    %esp,%ebp
f010e84a:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010e84d:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010e852:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010e855:	83 ec 0c             	sub    $0xc,%esp
f010e858:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e85b:	50                   	push   %eax
f010e85c:	e8 51 99 ff ff       	call   f01081b2 <allocate_frame>
f010e861:	83 c4 10             	add    $0x10,%esp
f010e864:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e867:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e86b:	75 08                	jne    f010e875 <__sys_allocate_page+0x2e>
		return r ;
f010e86d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e870:	e9 e9 00 00 00       	jmp    f010e95e <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e875:	8b 45 08             	mov    0x8(%ebp),%eax
f010e878:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e87d:	77 0c                	ja     f010e88b <__sys_allocate_page+0x44>
f010e87f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e882:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e887:	85 c0                	test   %eax,%eax
f010e889:	74 0a                	je     f010e895 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010e88b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e890:	e9 c9 00 00 00       	jmp    f010e95e <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e895:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e898:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e89d:	83 f8 04             	cmp    $0x4,%eax
f010e8a0:	74 0a                	je     f010e8ac <__sys_allocate_page+0x65>
		return E_INVAL;
f010e8a2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e8a7:	e9 b2 00 00 00       	jmp    f010e95e <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010e8ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8af:	83 ec 0c             	sub    $0xc,%esp
f010e8b2:	50                   	push   %eax
f010e8b3:	e8 a5 fe ff ff       	call   f010e75d <to_physical_address>
f010e8b8:	83 c4 10             	add    $0x10,%esp
f010e8bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010e8be:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e8c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e8c4:	8b 40 64             	mov    0x64(%eax),%eax
f010e8c7:	6a 02                	push   $0x2
f010e8c9:	68 00 00 80 ef       	push   $0xef800000
f010e8ce:	52                   	push   %edx
f010e8cf:	50                   	push   %eax
f010e8d0:	e8 aa 9d ff ff       	call   f010867f <map_frame>
f010e8d5:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010e8d8:	83 ec 04             	sub    $0x4,%esp
f010e8db:	68 00 10 00 00       	push   $0x1000
f010e8e0:	6a 00                	push   $0x0
f010e8e2:	68 00 00 80 ef       	push   $0xef800000
f010e8e7:	e8 d8 15 01 00       	call   f011fec4 <memset>
f010e8ec:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010e8ef:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e8f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8f5:	8b 40 08             	mov    0x8(%eax),%eax
f010e8f8:	40                   	inc    %eax
f010e8f9:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010e8fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e900:	8b 40 64             	mov    0x64(%eax),%eax
f010e903:	83 ec 08             	sub    $0x8,%esp
f010e906:	68 00 00 80 ef       	push   $0xef800000
f010e90b:	50                   	push   %eax
f010e90c:	e8 ce 9e ff ff       	call   f01087df <unmap_frame>
f010e911:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010e914:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e917:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e91a:	8b 40 08             	mov    0x8(%eax),%eax
f010e91d:	48                   	dec    %eax
f010e91e:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010e922:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e925:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e928:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e92b:	8b 40 64             	mov    0x64(%eax),%eax
f010e92e:	ff 75 0c             	pushl  0xc(%ebp)
f010e931:	51                   	push   %ecx
f010e932:	52                   	push   %edx
f010e933:	50                   	push   %eax
f010e934:	e8 46 9d ff ff       	call   f010867f <map_frame>
f010e939:	83 c4 10             	add    $0x10,%esp
f010e93c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e93f:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e943:	75 14                	jne    f010e959 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010e945:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e948:	83 ec 0c             	sub    $0xc,%esp
f010e94b:	50                   	push   %eax
f010e94c:	e8 6e 9a ff ff       	call   f01083bf <decrement_references>
f010e951:	83 c4 10             	add    $0x10,%esp
		return r;
f010e954:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e957:	eb 05                	jmp    f010e95e <__sys_allocate_page+0x117>
	}
	return 0 ;
f010e959:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e95e:	c9                   	leave  
f010e95f:	c3                   	ret    

f010e960 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e960:	55                   	push   %ebp
f010e961:	89 e5                	mov    %esp,%ebp
f010e963:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e966:	83 ec 04             	sub    $0x4,%esp
f010e969:	68 c1 77 12 f0       	push   $0xf01277c1
f010e96e:	68 dc 00 00 00       	push   $0xdc
f010e973:	68 df 77 12 f0       	push   $0xf01277df
f010e978:	e8 bc 19 ff ff       	call   f0100339 <_panic>

f010e97d <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010e97d:	55                   	push   %ebp
f010e97e:	89 e5                	mov    %esp,%ebp
f010e980:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010e983:	83 ec 04             	sub    $0x4,%esp
f010e986:	68 f4 77 12 f0       	push   $0xf01277f4
f010e98b:	68 ed 00 00 00       	push   $0xed
f010e990:	68 df 77 12 f0       	push   $0xf01277df
f010e995:	e8 9f 19 ff ff       	call   f0100339 <_panic>

f010e99a <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e99a:	55                   	push   %ebp
f010e99b:	89 e5                	mov    %esp,%ebp
f010e99d:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e9a0:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010e9a5:	8b 40 64             	mov    0x64(%eax),%eax
f010e9a8:	83 ec 04             	sub    $0x4,%esp
f010e9ab:	ff 75 0c             	pushl  0xc(%ebp)
f010e9ae:	ff 75 08             	pushl  0x8(%ebp)
f010e9b1:	50                   	push   %eax
f010e9b2:	e8 25 c2 ff ff       	call   f010abdc <calculate_required_frames>
f010e9b7:	83 c4 10             	add    $0x10,%esp
}
f010e9ba:	c9                   	leave  
f010e9bb:	c3                   	ret    

f010e9bc <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e9bc:	55                   	push   %ebp
f010e9bd:	89 e5                	mov    %esp,%ebp
f010e9bf:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e9c2:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9c5:	83 ec 0c             	sub    $0xc,%esp
f010e9c8:	50                   	push   %eax
f010e9c9:	e8 93 9f ff ff       	call   f0108961 <calculate_available_frames>
f010e9ce:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e9d1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e9d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e9d7:	01 d0                	add    %edx,%eax
}
f010e9d9:	c9                   	leave  
f010e9da:	c3                   	ret    

f010e9db <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e9db:	55                   	push   %ebp
f010e9dc:	89 e5                	mov    %esp,%ebp
f010e9de:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e9e1:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9e4:	83 ec 0c             	sub    $0xc,%esp
f010e9e7:	50                   	push   %eax
f010e9e8:	e8 74 9f ff ff       	call   f0108961 <calculate_available_frames>
f010e9ed:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e9f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e9f3:	c9                   	leave  
f010e9f4:	c3                   	ret    

f010e9f5 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e9f5:	55                   	push   %ebp
f010e9f6:	89 e5                	mov    %esp,%ebp
f010e9f8:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e9fb:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9fe:	83 ec 0c             	sub    $0xc,%esp
f010ea01:	50                   	push   %eax
f010ea02:	e8 5a 9f ff ff       	call   f0108961 <calculate_available_frames>
f010ea07:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010ea0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010ea0d:	c9                   	leave  
f010ea0e:	c3                   	ret    

f010ea0f <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010ea0f:	55                   	push   %ebp
f010ea10:	89 e5                	mov    %esp,%ebp
f010ea12:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010ea15:	83 ec 0c             	sub    $0xc,%esp
f010ea18:	ff 75 08             	pushl  0x8(%ebp)
f010ea1b:	e8 4d 00 01 00       	call   f011ea6d <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010ea20:	83 c4 10             	add    $0x10,%esp
}
f010ea23:	c9                   	leave  
f010ea24:	c3                   	ret    

f010ea25 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010ea25:	55                   	push   %ebp
f010ea26:	89 e5                	mov    %esp,%ebp
f010ea28:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010ea2b:	e8 68 ff 00 00       	call   f011e998 <scarce_memory>
}
f010ea30:	90                   	nop
f010ea31:	c9                   	leave  
f010ea32:	c3                   	ret    

f010ea33 <sys_clearFFL>:

void sys_clearFFL()
{
f010ea33:	55                   	push   %ebp
f010ea34:	89 e5                	mov    %esp,%ebp
f010ea36:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010ea39:	83 ec 0c             	sub    $0xc,%esp
f010ea3c:	68 a0 16 6c f0       	push   $0xf06c16a0
f010ea41:	e8 e2 12 00 00       	call   f010fd28 <acquire_spinlock>
f010ea46:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010ea49:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f010ea4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ea51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ea58:	eb 12                	jmp    f010ea6c <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010ea5a:	83 ec 0c             	sub    $0xc,%esp
f010ea5d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ea60:	50                   	push   %eax
f010ea61:	e8 4c 97 ff ff       	call   f01081b2 <allocate_frame>
f010ea66:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ea69:	ff 45 f4             	incl   -0xc(%ebp)
f010ea6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea6f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ea72:	7c e6                	jl     f010ea5a <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010ea74:	83 ec 0c             	sub    $0xc,%esp
f010ea77:	68 a0 16 6c f0       	push   $0xf06c16a0
f010ea7c:	e8 2e 13 00 00       	call   f010fdaf <release_spinlock>
f010ea81:	83 c4 10             	add    $0x10,%esp
}
f010ea84:	90                   	nop
f010ea85:	c9                   	leave  
f010ea86:	c3                   	ret    

f010ea87 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010ea87:	55                   	push   %ebp
f010ea88:	89 e5                	mov    %esp,%ebp
f010ea8a:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010ea8d:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ea92:	83 ec 0c             	sub    $0xc,%esp
f010ea95:	50                   	push   %eax
f010ea96:	e8 64 5d ff ff       	call   f01047ff <pf_calculate_allocated_pages>
f010ea9b:	83 c4 10             	add    $0x10,%esp
}
f010ea9e:	c9                   	leave  
f010ea9f:	c3                   	ret    

f010eaa0 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010eaa0:	55                   	push   %ebp
f010eaa1:	89 e5                	mov    %esp,%ebp
f010eaa3:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010eaa6:	e8 ed 0c 00 00       	call   f010f798 <isBufferingEnabled>
f010eaab:	84 c0                	test   %al,%al
f010eaad:	74 19                	je     f010eac8 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010eaaf:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eab4:	83 ec 04             	sub    $0x4,%esp
f010eab7:	ff 75 0c             	pushl  0xc(%ebp)
f010eaba:	ff 75 08             	pushl  0x8(%ebp)
f010eabd:	50                   	push   %eax
f010eabe:	e8 48 c3 ff ff       	call   f010ae0b <__free_user_mem_with_buffering>
f010eac3:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010eac6:	eb 18                	jmp    f010eae0 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010eac8:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eacd:	83 ec 04             	sub    $0x4,%esp
f010ead0:	ff 75 0c             	pushl  0xc(%ebp)
f010ead3:	ff 75 08             	pushl  0x8(%ebp)
f010ead6:	50                   	push   %eax
f010ead7:	e8 5f c2 ff ff       	call   f010ad3b <free_user_mem>
f010eadc:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010eadf:	90                   	nop
}
f010eae0:	c9                   	leave  
f010eae1:	c3                   	ret    

f010eae2 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010eae2:	55                   	push   %ebp
f010eae3:	89 e5                	mov    %esp,%ebp
f010eae5:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010eae8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010eaec:	75 07                	jne    f010eaf5 <check_Param+0x13>
	{
		env_exit();
f010eaee:	e8 64 cf ff ff       	call   f010ba57 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010eaf3:	eb 25                	jmp    f010eb1a <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010eaf5:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010eafc:	77 07                	ja     f010eb05 <check_Param+0x23>
f010eafe:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb01:	85 c0                	test   %eax,%eax
f010eb03:	78 07                	js     f010eb0c <check_Param+0x2a>
	{
		env_exit();
f010eb05:	e8 4d cf ff ff       	call   f010ba57 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010eb0a:	eb 0e                	jmp    f010eb1a <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010eb0c:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010eb13:	76 05                	jbe    f010eb1a <check_Param+0x38>
	{
		env_exit();
f010eb15:	e8 3d cf ff ff       	call   f010ba57 <env_exit>
	}
}
f010eb1a:	90                   	nop
f010eb1b:	c9                   	leave  
f010eb1c:	c3                   	ret    

f010eb1d <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010eb1d:	55                   	push   %ebp
f010eb1e:	89 e5                	mov    %esp,%ebp
f010eb20:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010eb23:	83 ec 0c             	sub    $0xc,%esp
f010eb26:	ff 75 08             	pushl  0x8(%ebp)
f010eb29:	e8 b4 ff ff ff       	call   f010eae2 <check_Param>
f010eb2e:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010eb31:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eb36:	83 ec 04             	sub    $0x4,%esp
f010eb39:	ff 75 0c             	pushl  0xc(%ebp)
f010eb3c:	ff 75 08             	pushl  0x8(%ebp)
f010eb3f:	50                   	push   %eax
f010eb40:	e8 3b c1 ff ff       	call   f010ac80 <allocate_user_mem>
f010eb45:	83 c4 10             	add    $0x10,%esp
	return;
f010eb48:	90                   	nop
}
f010eb49:	c9                   	leave  
f010eb4a:	c3                   	ret    

f010eb4b <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010eb4b:	55                   	push   %ebp
f010eb4c:	89 e5                	mov    %esp,%ebp
f010eb4e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010eb51:	83 ec 0c             	sub    $0xc,%esp
f010eb54:	ff 75 08             	pushl  0x8(%ebp)
f010eb57:	e8 86 ff ff ff       	call   f010eae2 <check_Param>
f010eb5c:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010eb5f:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eb64:	8b 40 64             	mov    0x64(%eax),%eax
f010eb67:	ff 75 10             	pushl  0x10(%ebp)
f010eb6a:	ff 75 0c             	pushl  0xc(%ebp)
f010eb6d:	ff 75 08             	pushl  0x8(%ebp)
f010eb70:	50                   	push   %eax
f010eb71:	e8 32 c0 ff ff       	call   f010aba8 <allocate_chunk>
f010eb76:	83 c4 10             	add    $0x10,%esp
	return;
f010eb79:	90                   	nop
}
f010eb7a:	c9                   	leave  
f010eb7b:	c3                   	ret    

f010eb7c <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010eb7c:	55                   	push   %ebp
f010eb7d:	89 e5                	mov    %esp,%ebp
f010eb7f:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010eb82:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eb87:	ff 75 10             	pushl  0x10(%ebp)
f010eb8a:	ff 75 0c             	pushl  0xc(%ebp)
f010eb8d:	ff 75 08             	pushl  0x8(%ebp)
f010eb90:	50                   	push   %eax
f010eb91:	e8 92 c2 ff ff       	call   f010ae28 <move_user_mem>
f010eb96:	83 c4 10             	add    $0x10,%esp
	return;
f010eb99:	90                   	nop
}
f010eb9a:	c9                   	leave  
f010eb9b:	c3                   	ret    

f010eb9c <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010eb9c:	55                   	push   %ebp
f010eb9d:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010eb9f:	a1 c4 1a 6c f0       	mov    0xf06c1ac4,%eax
}
f010eba4:	5d                   	pop    %ebp
f010eba5:	c3                   	ret    

f010eba6 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010eba6:	55                   	push   %ebp
f010eba7:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010eba9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebac:	a3 c4 1a 6c f0       	mov    %eax,0xf06c1ac4
}
f010ebb1:	90                   	nop
f010ebb2:	5d                   	pop    %ebp
f010ebb3:	c3                   	ret    

f010ebb4 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010ebb4:	55                   	push   %ebp
f010ebb5:	89 e5                	mov    %esp,%ebp
f010ebb7:	83 ec 18             	sub    $0x18,%esp
f010ebba:	8b 45 10             	mov    0x10(%ebp),%eax
f010ebbd:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010ebc0:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010ebc4:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ebc9:	8b 40 10             	mov    0x10(%eax),%eax
f010ebcc:	83 ec 0c             	sub    $0xc,%esp
f010ebcf:	ff 75 14             	pushl  0x14(%ebp)
f010ebd2:	52                   	push   %edx
f010ebd3:	ff 75 0c             	pushl  0xc(%ebp)
f010ebd6:	ff 75 08             	pushl  0x8(%ebp)
f010ebd9:	50                   	push   %eax
f010ebda:	e8 a6 a0 ff ff       	call   f0108c85 <createSharedObject>
f010ebdf:	83 c4 20             	add    $0x20,%esp
}
f010ebe2:	c9                   	leave  
f010ebe3:	c3                   	ret    

f010ebe4 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010ebe4:	55                   	push   %ebp
f010ebe5:	89 e5                	mov    %esp,%ebp
f010ebe7:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010ebea:	83 ec 08             	sub    $0x8,%esp
f010ebed:	ff 75 0c             	pushl  0xc(%ebp)
f010ebf0:	ff 75 08             	pushl  0x8(%ebp)
f010ebf3:	e8 88 9e ff ff       	call   f0108a80 <getSizeOfSharedObject>
f010ebf8:	83 c4 10             	add    $0x10,%esp
}
f010ebfb:	c9                   	leave  
f010ebfc:	c3                   	ret    

f010ebfd <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010ebfd:	55                   	push   %ebp
f010ebfe:	89 e5                	mov    %esp,%ebp
f010ec00:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010ec03:	83 ec 04             	sub    $0x4,%esp
f010ec06:	ff 75 10             	pushl  0x10(%ebp)
f010ec09:	ff 75 0c             	pushl  0xc(%ebp)
f010ec0c:	ff 75 08             	pushl  0x8(%ebp)
f010ec0f:	e8 2a a2 ff ff       	call   f0108e3e <getSharedObject>
f010ec14:	83 c4 10             	add    $0x10,%esp
}
f010ec17:	c9                   	leave  
f010ec18:	c3                   	ret    

f010ec19 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010ec19:	55                   	push   %ebp
f010ec1a:	89 e5                	mov    %esp,%ebp
f010ec1c:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010ec1f:	83 ec 08             	sub    $0x8,%esp
f010ec22:	ff 75 0c             	pushl  0xc(%ebp)
f010ec25:	ff 75 08             	pushl  0x8(%ebp)
f010ec28:	e8 a1 a4 ff ff       	call   f01090ce <freeSharedObject>
f010ec2d:	83 c4 10             	add    $0x10,%esp
}
f010ec30:	c9                   	leave  
f010ec31:	c3                   	ret    

f010ec32 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010ec32:	55                   	push   %ebp
f010ec33:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010ec35:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ec3a:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ec3d:	5d                   	pop    %ebp
f010ec3e:	c3                   	ret    

f010ec3f <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010ec3f:	55                   	push   %ebp
f010ec40:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010ec42:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ec47:	89 c2                	mov    %eax,%edx
f010ec49:	a1 f0 8a 69 f0       	mov    0xf0698af0,%eax
f010ec4e:	29 c2                	sub    %eax,%edx
f010ec50:	89 d0                	mov    %edx,%eax
f010ec52:	c1 f8 02             	sar    $0x2,%eax
f010ec55:	89 c2                	mov    %eax,%edx
f010ec57:	89 d0                	mov    %edx,%eax
f010ec59:	c1 e0 03             	shl    $0x3,%eax
f010ec5c:	01 d0                	add    %edx,%eax
f010ec5e:	c1 e0 03             	shl    $0x3,%eax
f010ec61:	01 d0                	add    %edx,%eax
f010ec63:	c1 e0 02             	shl    $0x2,%eax
f010ec66:	01 d0                	add    %edx,%eax
f010ec68:	01 c0                	add    %eax,%eax
f010ec6a:	01 d0                	add    %edx,%eax
f010ec6c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ec73:	01 c8                	add    %ecx,%eax
f010ec75:	c1 e0 02             	shl    $0x2,%eax
f010ec78:	01 d0                	add    %edx,%eax
f010ec7a:	c1 e0 03             	shl    $0x3,%eax
f010ec7d:	01 d0                	add    %edx,%eax
f010ec7f:	c1 e0 05             	shl    $0x5,%eax
f010ec82:	29 d0                	sub    %edx,%eax
f010ec84:	c1 e0 02             	shl    $0x2,%eax
f010ec87:	01 d0                	add    %edx,%eax
f010ec89:	01 c0                	add    %eax,%eax
f010ec8b:	01 d0                	add    %edx,%eax
f010ec8d:	c1 e0 03             	shl    $0x3,%eax
f010ec90:	01 d0                	add    %edx,%eax
f010ec92:	c1 e0 04             	shl    $0x4,%eax
f010ec95:	29 d0                	sub    %edx,%eax
}
f010ec97:	5d                   	pop    %ebp
f010ec98:	c3                   	ret    

f010ec99 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ec99:	55                   	push   %ebp
f010ec9a:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010ec9c:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010eca1:	8b 40 14             	mov    0x14(%eax),%eax
}
f010eca4:	5d                   	pop    %ebp
f010eca5:	c3                   	ret    

f010eca6 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010eca6:	55                   	push   %ebp
f010eca7:	89 e5                	mov    %esp,%ebp
f010eca9:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010ecac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ecb0:	75 0a                	jne    f010ecbc <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010ecb2:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ecb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ecba:	eb 22                	jmp    f010ecde <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ecbc:	83 ec 04             	sub    $0x4,%esp
f010ecbf:	6a 00                	push   $0x0
f010ecc1:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010ecc4:	50                   	push   %eax
f010ecc5:	ff 75 08             	pushl  0x8(%ebp)
f010ecc8:	e8 1c ce ff ff       	call   f010bae9 <envid2env>
f010eccd:	83 c4 10             	add    $0x10,%esp
f010ecd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ecd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ecd7:	79 05                	jns    f010ecde <sys_destroy_env+0x38>
	{
		return r;
f010ecd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecdc:	eb 5e                	jmp    f010ed3c <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010ecde:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ece1:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ece6:	39 c2                	cmp    %eax,%edx
f010ece8:	75 1b                	jne    f010ed05 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ecea:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ecef:	8b 40 10             	mov    0x10(%eax),%eax
f010ecf2:	83 ec 08             	sub    $0x8,%esp
f010ecf5:	50                   	push   %eax
f010ecf6:	68 13 78 12 f0       	push   $0xf0127813
f010ecfb:	e8 8b 22 ff ff       	call   f0100f8b <cprintf>
f010ed00:	83 c4 10             	add    $0x10,%esp
f010ed03:	eb 20                	jmp    f010ed25 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ed05:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed08:	8b 50 10             	mov    0x10(%eax),%edx
f010ed0b:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ed10:	8b 40 10             	mov    0x10(%eax),%eax
f010ed13:	83 ec 04             	sub    $0x4,%esp
f010ed16:	52                   	push   %edx
f010ed17:	50                   	push   %eax
f010ed18:	68 2e 78 12 f0       	push   $0xf012782e
f010ed1d:	e8 69 22 ff ff       	call   f0100f8b <cprintf>
f010ed22:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010ed25:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed28:	8b 40 10             	mov    0x10(%eax),%eax
f010ed2b:	83 ec 0c             	sub    $0xc,%esp
f010ed2e:	50                   	push   %eax
f010ed2f:	e8 84 6d ff ff       	call   f0105ab8 <sched_kill_env>
f010ed34:	83 c4 10             	add    $0x10,%esp

	return 0;
f010ed37:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed3c:	c9                   	leave  
f010ed3d:	c3                   	ret    

f010ed3e <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010ed3e:	55                   	push   %ebp
f010ed3f:	89 e5                	mov    %esp,%ebp
f010ed41:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010ed44:	e8 0e cd ff ff       	call   f010ba57 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010ed49:	90                   	nop
f010ed4a:	c9                   	leave  
f010ed4b:	c3                   	ret    

f010ed4c <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ed4c:	55                   	push   %ebp
f010ed4d:	89 e5                	mov    %esp,%ebp
f010ed4f:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010ed52:	ff 75 14             	pushl  0x14(%ebp)
f010ed55:	ff 75 10             	pushl  0x10(%ebp)
f010ed58:	ff 75 0c             	pushl  0xc(%ebp)
f010ed5b:	ff 75 08             	pushl  0x8(%ebp)
f010ed5e:	e8 b8 c2 ff ff       	call   f010b01b <env_create>
f010ed63:	83 c4 10             	add    $0x10,%esp
f010ed66:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010ed69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ed6d:	75 07                	jne    f010ed76 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ed6f:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ed74:	eb 14                	jmp    f010ed8a <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ed76:	83 ec 0c             	sub    $0xc,%esp
f010ed79:	ff 75 f4             	pushl  -0xc(%ebp)
f010ed7c:	e8 9b 69 ff ff       	call   f010571c <sched_new_env>
f010ed81:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ed84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed87:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ed8a:	c9                   	leave  
f010ed8b:	c3                   	ret    

f010ed8c <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ed8c:	55                   	push   %ebp
f010ed8d:	89 e5                	mov    %esp,%ebp
f010ed8f:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ed92:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed95:	83 ec 0c             	sub    $0xc,%esp
f010ed98:	50                   	push   %eax
f010ed99:	e8 d4 69 ff ff       	call   f0105772 <sched_run_env>
f010ed9e:	83 c4 10             	add    $0x10,%esp
}
f010eda1:	90                   	nop
f010eda2:	c9                   	leave  
f010eda3:	c3                   	ret    

f010eda4 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010eda4:	55                   	push   %ebp
f010eda5:	89 e5                	mov    %esp,%ebp
f010eda7:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010edaa:	0f 31                	rdtsc  
f010edac:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010edaf:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010edb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010edb5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010edb8:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010edbb:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010edbe:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010edc1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010edc4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010edc7:	89 01                	mov    %eax,(%ecx)
f010edc9:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010edcc:	8b 45 08             	mov    0x8(%ebp),%eax
f010edcf:	c9                   	leave  
f010edd0:	c2 04 00             	ret    $0x4

f010edd3 <sys_rcr2>:

uint32 sys_rcr2()
{
f010edd3:	55                   	push   %ebp
f010edd4:	89 e5                	mov    %esp,%ebp
f010edd6:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010edd9:	0f 20 d0             	mov    %cr2,%eax
f010eddc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010eddf:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010ede2:	90                   	nop
}
f010ede3:	c9                   	leave  
f010ede4:	c3                   	ret    

f010ede5 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010ede5:	55                   	push   %ebp
f010ede6:	89 e5                	mov    %esp,%ebp
f010ede8:	83 ec 04             	sub    $0x4,%esp
f010edeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010edee:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010edf1:	8a 45 fc             	mov    -0x4(%ebp),%al
f010edf4:	a2 60 93 69 f0       	mov    %al,0xf0699360
}
f010edf9:	90                   	nop
f010edfa:	c9                   	leave  
f010edfb:	c3                   	ret    

f010edfc <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010edfc:	55                   	push   %ebp
f010edfd:	89 e5                	mov    %esp,%ebp
f010edff:	56                   	push   %esi
f010ee00:	53                   	push   %ebx
f010ee01:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010ee04:	e8 90 cc ff ff       	call   f010ba99 <get_cpu_proc>
f010ee09:	a3 e0 92 b0 f0       	mov    %eax,0xf0b092e0
	assert(cur_env != NULL);
f010ee0e:	a1 e0 92 b0 f0       	mov    0xf0b092e0,%eax
f010ee13:	85 c0                	test   %eax,%eax
f010ee15:	75 19                	jne    f010ee30 <syscall+0x34>
f010ee17:	68 46 78 12 f0       	push   $0xf0127846
f010ee1c:	68 56 78 12 f0       	push   $0xf0127856
f010ee21:	68 05 02 00 00       	push   $0x205
f010ee26:	68 df 77 12 f0       	push   $0xf01277df
f010ee2b:	e8 09 15 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010ee30:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010ee34:	0f 87 06 04 00 00    	ja     f010f240 <syscall+0x444>
f010ee3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee3d:	c1 e0 02             	shl    $0x2,%eax
f010ee40:	05 6c 78 12 f0       	add    $0xf012786c,%eax
f010ee45:	8b 00                	mov    (%eax),%eax
f010ee47:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010ee49:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee4c:	83 ec 0c             	sub    $0xc,%esp
f010ee4f:	50                   	push   %eax
f010ee50:	e8 a1 bd ff ff       	call   f010abf6 <sys_sbrk>
f010ee55:	83 c4 10             	add    $0x10,%esp
f010ee58:	e9 e8 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010ee5d:	83 ec 08             	sub    $0x8,%esp
f010ee60:	ff 75 10             	pushl  0x10(%ebp)
f010ee63:	ff 75 0c             	pushl  0xc(%ebp)
f010ee66:	e8 35 fc ff ff       	call   f010eaa0 <sys_free_user_mem>
f010ee6b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee6e:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee73:	e9 cd 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010ee78:	83 ec 08             	sub    $0x8,%esp
f010ee7b:	ff 75 10             	pushl  0x10(%ebp)
f010ee7e:	ff 75 0c             	pushl  0xc(%ebp)
f010ee81:	e8 97 fc ff ff       	call   f010eb1d <sys_allocate_user_mem>
f010ee86:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee89:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee8e:	e9 b2 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010ee93:	8b 45 14             	mov    0x14(%ebp),%eax
f010ee96:	0f b6 d0             	movzbl %al,%edx
f010ee99:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee9c:	83 ec 04             	sub    $0x4,%esp
f010ee9f:	52                   	push   %edx
f010eea0:	ff 75 10             	pushl  0x10(%ebp)
f010eea3:	50                   	push   %eax
f010eea4:	e8 c7 f8 ff ff       	call   f010e770 <sys_cputs>
f010eea9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eeac:	b8 00 00 00 00       	mov    $0x0,%eax
f010eeb1:	e9 8f 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010eeb6:	e8 31 f9 ff ff       	call   f010e7ec <sys_cgetc>
f010eebb:	e9 85 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010eec0:	e8 66 f9 ff ff       	call   f010e82b <sys_lock_cons>
		return 0;
f010eec5:	b8 00 00 00 00       	mov    $0x0,%eax
f010eeca:	e9 76 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010eecf:	e8 65 f9 ff ff       	call   f010e839 <sys_unlock_cons>
		return 0;
f010eed4:	b8 00 00 00 00       	mov    $0x0,%eax
f010eed9:	e9 67 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010eede:	83 ec 08             	sub    $0x8,%esp
f010eee1:	ff 75 10             	pushl  0x10(%ebp)
f010eee4:	ff 75 0c             	pushl  0xc(%ebp)
f010eee7:	e8 ae fa ff ff       	call   f010e99a <sys_calculate_required_frames>
f010eeec:	83 c4 10             	add    $0x10,%esp
f010eeef:	e9 51 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010eef4:	e8 c3 fa ff ff       	call   f010e9bc <sys_calculate_free_frames>
f010eef9:	e9 47 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010eefe:	e8 d8 fa ff ff       	call   f010e9db <sys_calculate_modified_frames>
f010ef03:	e9 3d 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010ef08:	e8 e8 fa ff ff       	call   f010e9f5 <sys_calculate_notmod_frames>
f010ef0d:	e9 33 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010ef12:	e8 70 fb ff ff       	call   f010ea87 <sys_pf_calculate_allocated_pages>
f010ef17:	e9 29 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010ef1c:	83 ec 0c             	sub    $0xc,%esp
f010ef1f:	ff 75 0c             	pushl  0xc(%ebp)
f010ef22:	e8 e8 fa ff ff       	call   f010ea0f <sys_calculate_pages_tobe_removed_ready_exit>
f010ef27:	83 c4 10             	add    $0x10,%esp
f010ef2a:	e9 16 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010ef2f:	e8 f1 fa ff ff       	call   f010ea25 <sys_scarce_memory>
		return 0;
f010ef34:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef39:	e9 07 03 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010ef3e:	83 ec 04             	sub    $0x4,%esp
f010ef41:	ff 75 14             	pushl  0x14(%ebp)
f010ef44:	ff 75 10             	pushl  0x10(%ebp)
f010ef47:	ff 75 0c             	pushl  0xc(%ebp)
f010ef4a:	e8 fc fb ff ff       	call   f010eb4b <sys_allocate_chunk>
f010ef4f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef52:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef57:	e9 e9 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010ef5c:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef62:	83 ec 08             	sub    $0x8,%esp
f010ef65:	52                   	push   %edx
f010ef66:	50                   	push   %eax
f010ef67:	e8 db f8 ff ff       	call   f010e847 <__sys_allocate_page>
f010ef6c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef6f:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef74:	e9 cc 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010ef79:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010ef7c:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010ef7f:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010ef82:	8b 55 10             	mov    0x10(%ebp),%edx
f010ef85:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef88:	83 ec 0c             	sub    $0xc,%esp
f010ef8b:	56                   	push   %esi
f010ef8c:	53                   	push   %ebx
f010ef8d:	51                   	push   %ecx
f010ef8e:	52                   	push   %edx
f010ef8f:	50                   	push   %eax
f010ef90:	e8 cb f9 ff ff       	call   f010e960 <__sys_map_frame>
f010ef95:	83 c4 20             	add    $0x20,%esp
		return 0;
f010ef98:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef9d:	e9 a3 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010efa2:	8b 55 10             	mov    0x10(%ebp),%edx
f010efa5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efa8:	83 ec 08             	sub    $0x8,%esp
f010efab:	52                   	push   %edx
f010efac:	50                   	push   %eax
f010efad:	e8 cb f9 ff ff       	call   f010e97d <__sys_unmap_frame>
f010efb2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010efb5:	b8 00 00 00 00       	mov    $0x0,%eax
f010efba:	e9 86 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010efbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efc2:	0f be c0             	movsbl %al,%eax
f010efc5:	83 ec 0c             	sub    $0xc,%esp
f010efc8:	50                   	push   %eax
f010efc9:	e8 fa f7 ff ff       	call   f010e7c8 <sys_cputc>
f010efce:	83 c4 10             	add    $0x10,%esp
		return 0;
f010efd1:	b8 00 00 00 00       	mov    $0x0,%eax
f010efd6:	e9 6a 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010efdb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efde:	0f be c0             	movsbl %al,%eax
f010efe1:	83 ec 0c             	sub    $0xc,%esp
f010efe4:	50                   	push   %eax
f010efe5:	e8 49 fa ff ff       	call   f010ea33 <sys_clearFFL>
f010efea:	83 c4 10             	add    $0x10,%esp
		return 0;
f010efed:	b8 00 00 00 00       	mov    $0x0,%eax
f010eff2:	e9 4e 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010eff7:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010effa:	8b 45 14             	mov    0x14(%ebp),%eax
f010effd:	0f b6 d0             	movzbl %al,%edx
f010f000:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f003:	51                   	push   %ecx
f010f004:	52                   	push   %edx
f010f005:	ff 75 10             	pushl  0x10(%ebp)
f010f008:	50                   	push   %eax
f010f009:	e8 a6 fb ff ff       	call   f010ebb4 <sys_createSharedObject>
f010f00e:	83 c4 10             	add    $0x10,%esp
f010f011:	e9 2f 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010f016:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f019:	8b 55 10             	mov    0x10(%ebp),%edx
f010f01c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f01f:	83 ec 04             	sub    $0x4,%esp
f010f022:	51                   	push   %ecx
f010f023:	52                   	push   %edx
f010f024:	50                   	push   %eax
f010f025:	e8 d3 fb ff ff       	call   f010ebfd <sys_getSharedObject>
f010f02a:	83 c4 10             	add    $0x10,%esp
f010f02d:	e9 13 02 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010f032:	8b 55 10             	mov    0x10(%ebp),%edx
f010f035:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f038:	83 ec 08             	sub    $0x8,%esp
f010f03b:	52                   	push   %edx
f010f03c:	50                   	push   %eax
f010f03d:	e8 d7 fb ff ff       	call   f010ec19 <sys_freeSharedObject>
f010f042:	83 c4 10             	add    $0x10,%esp
f010f045:	e9 fb 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010f04a:	8b 55 10             	mov    0x10(%ebp),%edx
f010f04d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f050:	83 ec 08             	sub    $0x8,%esp
f010f053:	52                   	push   %edx
f010f054:	50                   	push   %eax
f010f055:	e8 8a fb ff ff       	call   f010ebe4 <sys_getSizeOfSharedObject>
f010f05a:	83 c4 10             	add    $0x10,%esp
f010f05d:	e9 e3 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f062:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f065:	ff 75 18             	pushl  0x18(%ebp)
f010f068:	ff 75 14             	pushl  0x14(%ebp)
f010f06b:	ff 75 10             	pushl  0x10(%ebp)
f010f06e:	50                   	push   %eax
f010f06f:	e8 d8 fc ff ff       	call   f010ed4c <sys_create_env>
f010f074:	83 c4 10             	add    $0x10,%esp
f010f077:	e9 c9 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f07c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f07f:	83 ec 0c             	sub    $0xc,%esp
f010f082:	50                   	push   %eax
f010f083:	e8 04 fd ff ff       	call   f010ed8c <sys_run_env>
f010f088:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f08b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f090:	e9 b0 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f095:	e8 a5 fb ff ff       	call   f010ec3f <sys_getenvindex>
f010f09a:	e9 a6 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f09f:	e8 8e fb ff ff       	call   f010ec32 <sys_getenvid>
f010f0a4:	e9 9c 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f0a9:	e8 eb fb ff ff       	call   f010ec99 <sys_getparentenvid>
f010f0ae:	e9 92 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f0b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0b6:	83 ec 0c             	sub    $0xc,%esp
f010f0b9:	50                   	push   %eax
f010f0ba:	e8 e7 fb ff ff       	call   f010eca6 <sys_destroy_env>
f010f0bf:	83 c4 10             	add    $0x10,%esp
f010f0c2:	e9 7e 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f0c7:	e8 72 fc ff ff       	call   f010ed3e <sys_exit_env>
		return 0;
f010f0cc:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0d1:	e9 6f 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f0d6:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010f0d9:	83 ec 0c             	sub    $0xc,%esp
f010f0dc:	50                   	push   %eax
f010f0dd:	e8 c2 fc ff ff       	call   f010eda4 <sys_get_virtual_time>
f010f0e2:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f0e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f0eb:	8b 45 10             	mov    0x10(%ebp),%eax
f010f0ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010f0f1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f0f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f0f7:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f0f9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f0fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f0ff:	89 10                	mov    %edx,(%eax)
		return 0;
f010f101:	b8 00 00 00 00       	mov    $0x0,%eax
f010f106:	e9 3a 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f10b:	83 ec 04             	sub    $0x4,%esp
f010f10e:	ff 75 14             	pushl  0x14(%ebp)
f010f111:	ff 75 10             	pushl  0x10(%ebp)
f010f114:	ff 75 0c             	pushl  0xc(%ebp)
f010f117:	e8 60 fa ff ff       	call   f010eb7c <sys_move_user_mem>
f010f11c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f11f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f124:	e9 1c 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f129:	e8 a5 fc ff ff       	call   f010edd3 <sys_rcr2>
f010f12e:	e9 12 01 00 00       	jmp    f010f245 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f133:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f136:	0f b6 c0             	movzbl %al,%eax
f010f139:	83 ec 0c             	sub    $0xc,%esp
f010f13c:	50                   	push   %eax
f010f13d:	e8 a3 fc ff ff       	call   f010ede5 <sys_bypassPageFault>
f010f142:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f145:	b8 00 00 00 00       	mov    $0x0,%eax
f010f14a:	e9 f6 00 00 00       	jmp    f010f245 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010f14f:	e8 f8 ee 00 00       	call   f011e04c <rsttst>
		return 0;
f010f154:	b8 00 00 00 00       	mov    $0x0,%eax
f010f159:	e9 e7 00 00 00       	jmp    f010f245 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010f15e:	e8 31 ef 00 00       	call   f011e094 <inctst>
		return 0;
f010f163:	b8 00 00 00 00       	mov    $0x0,%eax
f010f168:	e9 d8 00 00 00       	jmp    f010f245 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010f16d:	83 ec 0c             	sub    $0xc,%esp
f010f170:	ff 75 0c             	pushl  0xc(%ebp)
f010f173:	e8 5e f0 00 00       	call   f011e1d6 <chktst>
f010f178:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f17b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f180:	e9 c0 00 00 00       	jmp    f010f245 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010f185:	e8 3e ef 00 00       	call   f011e0c8 <gettst>
f010f18a:	e9 b6 00 00 00       	jmp    f010f245 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f18f:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f192:	8b 45 18             	mov    0x18(%ebp),%eax
f010f195:	0f be c0             	movsbl %al,%eax
f010f198:	83 ec 0c             	sub    $0xc,%esp
f010f19b:	52                   	push   %edx
f010f19c:	50                   	push   %eax
f010f19d:	ff 75 14             	pushl  0x14(%ebp)
f010f1a0:	ff 75 10             	pushl  0x10(%ebp)
f010f1a3:	ff 75 0c             	pushl  0xc(%ebp)
f010f1a6:	e8 27 ef 00 00       	call   f011e0d2 <tst>
f010f1ab:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f1ae:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1b3:	e9 8d 00 00 00       	jmp    f010f245 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f1b8:	e8 df f9 ff ff       	call   f010eb9c <sys_get_heap_strategy>
f010f1bd:	e9 83 00 00 00       	jmp    f010f245 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f1c2:	83 ec 0c             	sub    $0xc,%esp
f010f1c5:	ff 75 0c             	pushl  0xc(%ebp)
f010f1c8:	e8 d9 f9 ff ff       	call   f010eba6 <sys_set_uheap_strategy>
f010f1cd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1d0:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1d5:	eb 6e                	jmp    f010f245 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f1d7:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f1da:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f1dd:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1e3:	53                   	push   %ebx
f010f1e4:	51                   	push   %ecx
f010f1e5:	52                   	push   %edx
f010f1e6:	50                   	push   %eax
f010f1e7:	e8 b3 1d 00 00       	call   f0110f9f <sys_check_LRU_lists>
f010f1ec:	83 c4 10             	add    $0x10,%esp
f010f1ef:	eb 54                	jmp    f010f245 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f1f1:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1f7:	83 ec 08             	sub    $0x8,%esp
f010f1fa:	52                   	push   %edx
f010f1fb:	50                   	push   %eax
f010f1fc:	e8 60 1f 00 00       	call   f0111161 <sys_check_LRU_lists_free>
f010f201:	83 c4 10             	add    $0x10,%esp
f010f204:	eb 3f                	jmp    f010f245 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f206:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f209:	8b 55 10             	mov    0x10(%ebp),%edx
f010f20c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f20f:	51                   	push   %ecx
f010f210:	ff 75 14             	pushl  0x14(%ebp)
f010f213:	52                   	push   %edx
f010f214:	50                   	push   %eax
f010f215:	e8 d4 20 00 00       	call   f01112ee <sys_check_WS_list>
f010f21a:	83 c4 10             	add    $0x10,%esp
f010f21d:	eb 26                	jmp    f010f245 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f21f:	8b 55 10             	mov    0x10(%ebp),%edx
f010f222:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f225:	83 ec 08             	sub    $0x8,%esp
f010f228:	52                   	push   %edx
f010f229:	50                   	push   %eax
f010f22a:	e8 a8 f1 00 00       	call   f011e3d7 <sys_utilities>
f010f22f:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f232:	b8 00 00 00 00       	mov    $0x0,%eax
f010f237:	eb 0c                	jmp    f010f245 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f239:	b8 03 00 00 00       	mov    $0x3,%eax
f010f23e:	eb 05                	jmp    f010f245 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f240:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f245:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f248:	5b                   	pop    %ebx
f010f249:	5e                   	pop    %esi
f010f24a:	5d                   	pop    %ebp
f010f24b:	c3                   	ret    

f010f24c <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f24c:	55                   	push   %ebp
f010f24d:	89 e5                	mov    %esp,%ebp
f010f24f:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f252:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f255:	8b 00                	mov    (%eax),%eax
f010f257:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f25a:	8b 45 10             	mov    0x10(%ebp),%eax
f010f25d:	8b 00                	mov    (%eax),%eax
f010f25f:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f262:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f269:	e9 ca 00 00 00       	jmp    f010f338 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f26e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f271:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f274:	01 d0                	add    %edx,%eax
f010f276:	89 c2                	mov    %eax,%edx
f010f278:	c1 ea 1f             	shr    $0x1f,%edx
f010f27b:	01 d0                	add    %edx,%eax
f010f27d:	d1 f8                	sar    %eax
f010f27f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f282:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f285:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f288:	eb 03                	jmp    f010f28d <stab_binsearch+0x41>
			m--;
f010f28a:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f28d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f290:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f293:	7c 1e                	jl     f010f2b3 <stab_binsearch+0x67>
f010f295:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f298:	89 d0                	mov    %edx,%eax
f010f29a:	01 c0                	add    %eax,%eax
f010f29c:	01 d0                	add    %edx,%eax
f010f29e:	c1 e0 02             	shl    $0x2,%eax
f010f2a1:	89 c2                	mov    %eax,%edx
f010f2a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2a6:	01 d0                	add    %edx,%eax
f010f2a8:	8a 40 04             	mov    0x4(%eax),%al
f010f2ab:	0f b6 c0             	movzbl %al,%eax
f010f2ae:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f2b1:	75 d7                	jne    f010f28a <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f2b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f2b6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f2b9:	7d 09                	jge    f010f2c4 <stab_binsearch+0x78>
			l = true_m + 1;
f010f2bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f2be:	40                   	inc    %eax
f010f2bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f2c2:	eb 74                	jmp    f010f338 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f2c4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f2cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f2ce:	89 d0                	mov    %edx,%eax
f010f2d0:	01 c0                	add    %eax,%eax
f010f2d2:	01 d0                	add    %edx,%eax
f010f2d4:	c1 e0 02             	shl    $0x2,%eax
f010f2d7:	89 c2                	mov    %eax,%edx
f010f2d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2dc:	01 d0                	add    %edx,%eax
f010f2de:	8b 40 08             	mov    0x8(%eax),%eax
f010f2e1:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f2e4:	73 11                	jae    f010f2f7 <stab_binsearch+0xab>
			*region_left = m;
f010f2e6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2e9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f2ec:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f2ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f2f1:	40                   	inc    %eax
f010f2f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f2f5:	eb 41                	jmp    f010f338 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f2f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f2fa:	89 d0                	mov    %edx,%eax
f010f2fc:	01 c0                	add    %eax,%eax
f010f2fe:	01 d0                	add    %edx,%eax
f010f300:	c1 e0 02             	shl    $0x2,%eax
f010f303:	89 c2                	mov    %eax,%edx
f010f305:	8b 45 08             	mov    0x8(%ebp),%eax
f010f308:	01 d0                	add    %edx,%eax
f010f30a:	8b 40 08             	mov    0x8(%eax),%eax
f010f30d:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f310:	76 14                	jbe    f010f326 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f312:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f315:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f318:	8b 45 10             	mov    0x10(%ebp),%eax
f010f31b:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f31d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f320:	48                   	dec    %eax
f010f321:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f324:	eb 12                	jmp    f010f338 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f326:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f32c:	89 10                	mov    %edx,(%eax)
			l = m;
f010f32e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f331:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f334:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f338:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f33b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f33e:	0f 8e 2a ff ff ff    	jle    f010f26e <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f344:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f348:	75 0f                	jne    f010f359 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f34a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f34d:	8b 00                	mov    (%eax),%eax
f010f34f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f352:	8b 45 10             	mov    0x10(%ebp),%eax
f010f355:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f357:	eb 3d                	jmp    f010f396 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f359:	8b 45 10             	mov    0x10(%ebp),%eax
f010f35c:	8b 00                	mov    (%eax),%eax
f010f35e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f361:	eb 03                	jmp    f010f366 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f363:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f366:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f369:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f36b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f36e:	7d 1e                	jge    f010f38e <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f370:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f373:	89 d0                	mov    %edx,%eax
f010f375:	01 c0                	add    %eax,%eax
f010f377:	01 d0                	add    %edx,%eax
f010f379:	c1 e0 02             	shl    $0x2,%eax
f010f37c:	89 c2                	mov    %eax,%edx
f010f37e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f381:	01 d0                	add    %edx,%eax
f010f383:	8a 40 04             	mov    0x4(%eax),%al
f010f386:	0f b6 c0             	movzbl %al,%eax
f010f389:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f38c:	75 d5                	jne    f010f363 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f38e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f391:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f394:	89 10                	mov    %edx,(%eax)
	}
}
f010f396:	90                   	nop
f010f397:	c9                   	leave  
f010f398:	c3                   	ret    

f010f399 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f399:	55                   	push   %ebp
f010f39a:	89 e5                	mov    %esp,%ebp
f010f39c:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f39f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3a2:	c7 00 28 79 12 f0    	movl   $0xf0127928,(%eax)
	info->eip_line = 0;
f010f3a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3ab:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f3b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3b5:	c7 40 08 28 79 12 f0 	movl   $0xf0127928,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f3bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3bf:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f3c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3c9:	8b 55 08             	mov    0x8(%ebp),%edx
f010f3cc:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f3cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3d2:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f3d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3dc:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f3e1:	76 1e                	jbe    f010f401 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f3e3:	c7 45 f4 bc 16 13 f0 	movl   $0xf01316bc,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f3ea:	c7 45 f0 7c 50 16 f0 	movl   $0xf016507c,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f3f1:	c7 45 ec 7d 50 16 f0 	movl   $0xf016507d,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f3f8:	c7 45 e8 9c 6c 17 f0 	movl   $0xf0176c9c,-0x18(%ebp)
f010f3ff:	eb 2a                	jmp    f010f42b <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f401:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f408:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f40b:	8b 00                	mov    (%eax),%eax
f010f40d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f410:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f413:	8b 40 04             	mov    0x4(%eax),%eax
f010f416:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f419:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f41c:	8b 40 08             	mov    0x8(%eax),%eax
f010f41f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f422:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f425:	8b 40 0c             	mov    0xc(%eax),%eax
f010f428:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f42b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f42e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f431:	76 0a                	jbe    f010f43d <debuginfo_eip+0xa4>
f010f433:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f436:	48                   	dec    %eax
f010f437:	8a 00                	mov    (%eax),%al
f010f439:	84 c0                	test   %al,%al
f010f43b:	74 0a                	je     f010f447 <debuginfo_eip+0xae>
		return -1;
f010f43d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f442:	e9 01 02 00 00       	jmp    f010f648 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f447:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f44e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f451:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f454:	29 c2                	sub    %eax,%edx
f010f456:	89 d0                	mov    %edx,%eax
f010f458:	c1 f8 02             	sar    $0x2,%eax
f010f45b:	89 c2                	mov    %eax,%edx
f010f45d:	89 d0                	mov    %edx,%eax
f010f45f:	c1 e0 02             	shl    $0x2,%eax
f010f462:	01 d0                	add    %edx,%eax
f010f464:	c1 e0 02             	shl    $0x2,%eax
f010f467:	01 d0                	add    %edx,%eax
f010f469:	c1 e0 02             	shl    $0x2,%eax
f010f46c:	01 d0                	add    %edx,%eax
f010f46e:	89 c1                	mov    %eax,%ecx
f010f470:	c1 e1 08             	shl    $0x8,%ecx
f010f473:	01 c8                	add    %ecx,%eax
f010f475:	89 c1                	mov    %eax,%ecx
f010f477:	c1 e1 10             	shl    $0x10,%ecx
f010f47a:	01 c8                	add    %ecx,%eax
f010f47c:	01 c0                	add    %eax,%eax
f010f47e:	01 d0                	add    %edx,%eax
f010f480:	48                   	dec    %eax
f010f481:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f484:	ff 75 08             	pushl  0x8(%ebp)
f010f487:	6a 64                	push   $0x64
f010f489:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f48c:	50                   	push   %eax
f010f48d:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f490:	50                   	push   %eax
f010f491:	ff 75 f4             	pushl  -0xc(%ebp)
f010f494:	e8 b3 fd ff ff       	call   f010f24c <stab_binsearch>
f010f499:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f49c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f49f:	85 c0                	test   %eax,%eax
f010f4a1:	75 0a                	jne    f010f4ad <debuginfo_eip+0x114>
		return -1;
f010f4a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f4a8:	e9 9b 01 00 00       	jmp    f010f648 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f4ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f4b0:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f4b3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f4b6:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f4b9:	ff 75 08             	pushl  0x8(%ebp)
f010f4bc:	6a 24                	push   $0x24
f010f4be:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f4c1:	50                   	push   %eax
f010f4c2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f4c5:	50                   	push   %eax
f010f4c6:	ff 75 f4             	pushl  -0xc(%ebp)
f010f4c9:	e8 7e fd ff ff       	call   f010f24c <stab_binsearch>
f010f4ce:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f4d1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f4d4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f4d7:	39 c2                	cmp    %eax,%edx
f010f4d9:	0f 8f 86 00 00 00    	jg     f010f565 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f4df:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f4e2:	89 c2                	mov    %eax,%edx
f010f4e4:	89 d0                	mov    %edx,%eax
f010f4e6:	01 c0                	add    %eax,%eax
f010f4e8:	01 d0                	add    %edx,%eax
f010f4ea:	c1 e0 02             	shl    $0x2,%eax
f010f4ed:	89 c2                	mov    %eax,%edx
f010f4ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f4f2:	01 d0                	add    %edx,%eax
f010f4f4:	8b 00                	mov    (%eax),%eax
f010f4f6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f4f9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f4fc:	29 d1                	sub    %edx,%ecx
f010f4fe:	89 ca                	mov    %ecx,%edx
f010f500:	39 d0                	cmp    %edx,%eax
f010f502:	73 22                	jae    f010f526 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f504:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f507:	89 c2                	mov    %eax,%edx
f010f509:	89 d0                	mov    %edx,%eax
f010f50b:	01 c0                	add    %eax,%eax
f010f50d:	01 d0                	add    %edx,%eax
f010f50f:	c1 e0 02             	shl    $0x2,%eax
f010f512:	89 c2                	mov    %eax,%edx
f010f514:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f517:	01 d0                	add    %edx,%eax
f010f519:	8b 10                	mov    (%eax),%edx
f010f51b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f51e:	01 c2                	add    %eax,%edx
f010f520:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f523:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f526:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f529:	89 c2                	mov    %eax,%edx
f010f52b:	89 d0                	mov    %edx,%eax
f010f52d:	01 c0                	add    %eax,%eax
f010f52f:	01 d0                	add    %edx,%eax
f010f531:	c1 e0 02             	shl    $0x2,%eax
f010f534:	89 c2                	mov    %eax,%edx
f010f536:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f539:	01 d0                	add    %edx,%eax
f010f53b:	8b 50 08             	mov    0x8(%eax),%edx
f010f53e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f541:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f544:	8b 55 08             	mov    0x8(%ebp),%edx
f010f547:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f54a:	8b 40 10             	mov    0x10(%eax),%eax
f010f54d:	29 c2                	sub    %eax,%edx
f010f54f:	89 d0                	mov    %edx,%eax
f010f551:	c1 f8 02             	sar    $0x2,%eax
f010f554:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f557:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f55a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f55d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f560:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f563:	eb 15                	jmp    f010f57a <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f565:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f568:	8b 55 08             	mov    0x8(%ebp),%edx
f010f56b:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f56e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f571:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f574:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f577:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f57a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f57d:	8b 40 08             	mov    0x8(%eax),%eax
f010f580:	83 ec 08             	sub    $0x8,%esp
f010f583:	6a 3a                	push   $0x3a
f010f585:	50                   	push   %eax
f010f586:	e8 0d 09 01 00       	call   f011fe98 <strfind>
f010f58b:	83 c4 10             	add    $0x10,%esp
f010f58e:	89 c2                	mov    %eax,%edx
f010f590:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f593:	8b 40 08             	mov    0x8(%eax),%eax
f010f596:	29 c2                	sub    %eax,%edx
f010f598:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f59b:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f59e:	eb 03                	jmp    f010f5a3 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f5a0:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f5a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f5a6:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f5a9:	7c 4e                	jl     f010f5f9 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f5ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f5ae:	89 d0                	mov    %edx,%eax
f010f5b0:	01 c0                	add    %eax,%eax
f010f5b2:	01 d0                	add    %edx,%eax
f010f5b4:	c1 e0 02             	shl    $0x2,%eax
f010f5b7:	89 c2                	mov    %eax,%edx
f010f5b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f5bc:	01 d0                	add    %edx,%eax
f010f5be:	8a 40 04             	mov    0x4(%eax),%al
f010f5c1:	3c 84                	cmp    $0x84,%al
f010f5c3:	74 34                	je     f010f5f9 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f5c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f5c8:	89 d0                	mov    %edx,%eax
f010f5ca:	01 c0                	add    %eax,%eax
f010f5cc:	01 d0                	add    %edx,%eax
f010f5ce:	c1 e0 02             	shl    $0x2,%eax
f010f5d1:	89 c2                	mov    %eax,%edx
f010f5d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f5d6:	01 d0                	add    %edx,%eax
f010f5d8:	8a 40 04             	mov    0x4(%eax),%al
f010f5db:	3c 64                	cmp    $0x64,%al
f010f5dd:	75 c1                	jne    f010f5a0 <debuginfo_eip+0x207>
f010f5df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f5e2:	89 d0                	mov    %edx,%eax
f010f5e4:	01 c0                	add    %eax,%eax
f010f5e6:	01 d0                	add    %edx,%eax
f010f5e8:	c1 e0 02             	shl    $0x2,%eax
f010f5eb:	89 c2                	mov    %eax,%edx
f010f5ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f5f0:	01 d0                	add    %edx,%eax
f010f5f2:	8b 40 08             	mov    0x8(%eax),%eax
f010f5f5:	85 c0                	test   %eax,%eax
f010f5f7:	74 a7                	je     f010f5a0 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f5f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f5fc:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f5ff:	7c 42                	jl     f010f643 <debuginfo_eip+0x2aa>
f010f601:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f604:	89 d0                	mov    %edx,%eax
f010f606:	01 c0                	add    %eax,%eax
f010f608:	01 d0                	add    %edx,%eax
f010f60a:	c1 e0 02             	shl    $0x2,%eax
f010f60d:	89 c2                	mov    %eax,%edx
f010f60f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f612:	01 d0                	add    %edx,%eax
f010f614:	8b 00                	mov    (%eax),%eax
f010f616:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f619:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f61c:	29 d1                	sub    %edx,%ecx
f010f61e:	89 ca                	mov    %ecx,%edx
f010f620:	39 d0                	cmp    %edx,%eax
f010f622:	73 1f                	jae    f010f643 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f624:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f627:	89 d0                	mov    %edx,%eax
f010f629:	01 c0                	add    %eax,%eax
f010f62b:	01 d0                	add    %edx,%eax
f010f62d:	c1 e0 02             	shl    $0x2,%eax
f010f630:	89 c2                	mov    %eax,%edx
f010f632:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f635:	01 d0                	add    %edx,%eax
f010f637:	8b 10                	mov    (%eax),%edx
f010f639:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f63c:	01 c2                	add    %eax,%edx
f010f63e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f641:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f643:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f648:	c9                   	leave  
f010f649:	c3                   	ret    

f010f64a <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f64a:	55                   	push   %ebp
f010f64b:	89 e5                	mov    %esp,%ebp
f010f64d:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f650:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f654:	74 1c                	je     f010f672 <setPageReplacmentAlgorithmLRU+0x28>
f010f656:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f65a:	74 16                	je     f010f672 <setPageReplacmentAlgorithmLRU+0x28>
f010f65c:	68 34 79 12 f0       	push   $0xf0127934
f010f661:	68 7e 79 12 f0       	push   $0xf012797e
f010f666:	6a 1a                	push   $0x1a
f010f668:	68 93 79 12 f0       	push   $0xf0127993
f010f66d:	e8 c7 0c ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f672:	8b 45 08             	mov    0x8(%ebp),%eax
f010f675:	a3 50 2d 6c f0       	mov    %eax,0xf06c2d50
}
f010f67a:	90                   	nop
f010f67b:	c9                   	leave  
f010f67c:	c3                   	ret    

f010f67d <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f67d:	55                   	push   %ebp
f010f67e:	89 e5                	mov    %esp,%ebp
f010f680:	c7 05 50 2d 6c f0 03 	movl   $0x3,0xf06c2d50
f010f687:	00 00 00 
f010f68a:	90                   	nop
f010f68b:	5d                   	pop    %ebp
f010f68c:	c3                   	ret    

f010f68d <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f68d:	55                   	push   %ebp
f010f68e:	89 e5                	mov    %esp,%ebp
f010f690:	c7 05 50 2d 6c f0 04 	movl   $0x4,0xf06c2d50
f010f697:	00 00 00 
f010f69a:	90                   	nop
f010f69b:	5d                   	pop    %ebp
f010f69c:	c3                   	ret    

f010f69d <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f69d:	55                   	push   %ebp
f010f69e:	89 e5                	mov    %esp,%ebp
f010f6a0:	c7 05 50 2d 6c f0 05 	movl   $0x5,0xf06c2d50
f010f6a7:	00 00 00 
f010f6aa:	90                   	nop
f010f6ab:	5d                   	pop    %ebp
f010f6ac:	c3                   	ret    

f010f6ad <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f6ad:	55                   	push   %ebp
f010f6ae:	89 e5                	mov    %esp,%ebp
f010f6b0:	c7 05 50 2d 6c f0 07 	movl   $0x7,0xf06c2d50
f010f6b7:	00 00 00 
f010f6ba:	90                   	nop
f010f6bb:	5d                   	pop    %ebp
f010f6bc:	c3                   	ret    

f010f6bd <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f6bd:	55                   	push   %ebp
f010f6be:	89 e5                	mov    %esp,%ebp
f010f6c0:	c7 05 50 2d 6c f0 06 	movl   $0x6,0xf06c2d50
f010f6c7:	00 00 00 
f010f6ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6cd:	a3 74 16 6c f0       	mov    %eax,0xf06c1674
f010f6d2:	90                   	nop
f010f6d3:	5d                   	pop    %ebp
f010f6d4:	c3                   	ret    

f010f6d5 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f6d5:	55                   	push   %ebp
f010f6d6:	89 e5                	mov    %esp,%ebp
f010f6d8:	8b 15 50 2d 6c f0    	mov    0xf06c2d50,%edx
f010f6de:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6e1:	39 c2                	cmp    %eax,%edx
f010f6e3:	0f 94 c0             	sete   %al
f010f6e6:	0f b6 c0             	movzbl %al,%eax
f010f6e9:	5d                   	pop    %ebp
f010f6ea:	c3                   	ret    

f010f6eb <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f6eb:	55                   	push   %ebp
f010f6ec:	89 e5                	mov    %esp,%ebp
f010f6ee:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f6f3:	83 f8 03             	cmp    $0x3,%eax
f010f6f6:	75 07                	jne    f010f6ff <isPageReplacmentAlgorithmCLOCK+0x14>
f010f6f8:	b8 01 00 00 00       	mov    $0x1,%eax
f010f6fd:	eb 05                	jmp    f010f704 <isPageReplacmentAlgorithmCLOCK+0x19>
f010f6ff:	b8 00 00 00 00       	mov    $0x0,%eax
f010f704:	5d                   	pop    %ebp
f010f705:	c3                   	ret    

f010f706 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f706:	55                   	push   %ebp
f010f707:	89 e5                	mov    %esp,%ebp
f010f709:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f70e:	83 f8 04             	cmp    $0x4,%eax
f010f711:	75 07                	jne    f010f71a <isPageReplacmentAlgorithmFIFO+0x14>
f010f713:	b8 01 00 00 00       	mov    $0x1,%eax
f010f718:	eb 05                	jmp    f010f71f <isPageReplacmentAlgorithmFIFO+0x19>
f010f71a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f71f:	5d                   	pop    %ebp
f010f720:	c3                   	ret    

f010f721 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f721:	55                   	push   %ebp
f010f722:	89 e5                	mov    %esp,%ebp
f010f724:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f729:	83 f8 05             	cmp    $0x5,%eax
f010f72c:	75 07                	jne    f010f735 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f72e:	b8 01 00 00 00       	mov    $0x1,%eax
f010f733:	eb 05                	jmp    f010f73a <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f735:	b8 00 00 00 00       	mov    $0x0,%eax
f010f73a:	5d                   	pop    %ebp
f010f73b:	c3                   	ret    

f010f73c <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f73c:	55                   	push   %ebp
f010f73d:	89 e5                	mov    %esp,%ebp
f010f73f:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f744:	83 f8 07             	cmp    $0x7,%eax
f010f747:	75 07                	jne    f010f750 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f749:	b8 01 00 00 00       	mov    $0x1,%eax
f010f74e:	eb 05                	jmp    f010f755 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f750:	b8 00 00 00 00       	mov    $0x0,%eax
f010f755:	5d                   	pop    %ebp
f010f756:	c3                   	ret    

f010f757 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f757:	55                   	push   %ebp
f010f758:	89 e5                	mov    %esp,%ebp
f010f75a:	a1 50 2d 6c f0       	mov    0xf06c2d50,%eax
f010f75f:	83 f8 06             	cmp    $0x6,%eax
f010f762:	75 07                	jne    f010f76b <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f764:	b8 01 00 00 00       	mov    $0x1,%eax
f010f769:	eb 05                	jmp    f010f770 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f76b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f770:	5d                   	pop    %ebp
f010f771:	c3                   	ret    

f010f772 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f772:	55                   	push   %ebp
f010f773:	89 e5                	mov    %esp,%ebp
f010f775:	8b 45 08             	mov    0x8(%ebp),%eax
f010f778:	a3 d8 1a 6c f0       	mov    %eax,0xf06c1ad8
f010f77d:	90                   	nop
f010f77e:	5d                   	pop    %ebp
f010f77f:	c3                   	ret    

f010f780 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f780:	55                   	push   %ebp
f010f781:	89 e5                	mov    %esp,%ebp
f010f783:	a1 d8 1a 6c f0       	mov    0xf06c1ad8,%eax
f010f788:	5d                   	pop    %ebp
f010f789:	c3                   	ret    

f010f78a <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f78a:	55                   	push   %ebp
f010f78b:	89 e5                	mov    %esp,%ebp
f010f78d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f790:	a3 d4 2d 6c f0       	mov    %eax,0xf06c2dd4
f010f795:	90                   	nop
f010f796:	5d                   	pop    %ebp
f010f797:	c3                   	ret    

f010f798 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f798:	55                   	push   %ebp
f010f799:	89 e5                	mov    %esp,%ebp
f010f79b:	a1 d4 2d 6c f0       	mov    0xf06c2dd4,%eax
f010f7a0:	5d                   	pop    %ebp
f010f7a1:	c3                   	ret    

f010f7a2 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f7a2:	55                   	push   %ebp
f010f7a3:	89 e5                	mov    %esp,%ebp
f010f7a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7a8:	a3 70 2e 6c f0       	mov    %eax,0xf06c2e70
f010f7ad:	90                   	nop
f010f7ae:	5d                   	pop    %ebp
f010f7af:	c3                   	ret    

f010f7b0 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f7b0:	55                   	push   %ebp
f010f7b1:	89 e5                	mov    %esp,%ebp
f010f7b3:	a1 70 2e 6c f0       	mov    0xf06c2e70,%eax
f010f7b8:	5d                   	pop    %ebp
f010f7b9:	c3                   	ret    

f010f7ba <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f7ba:	55                   	push   %ebp
f010f7bb:	89 e5                	mov    %esp,%ebp
f010f7bd:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f7c0:	0f 20 d0             	mov    %cr2,%eax
f010f7c3:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f7c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f7c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f7cc:	e8 c8 c2 ff ff       	call   f010ba99 <get_cpu_proc>
f010f7d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f7d4:	a1 6c 93 69 f0       	mov    0xf069936c,%eax
f010f7d9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f7dc:	75 50                	jne    f010f82e <fault_handler+0x74>
f010f7de:	a1 78 93 69 f0       	mov    0xf0699378,%eax
f010f7e3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f7e6:	75 46                	jne    f010f82e <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f7e8:	a0 74 93 69 f0       	mov    0xf0699374,%al
f010f7ed:	40                   	inc    %eax
f010f7ee:	a2 74 93 69 f0       	mov    %al,0xf0699374
		if (num_repeated_fault == 3)
f010f7f3:	a0 74 93 69 f0       	mov    0xf0699374,%al
f010f7f8:	3c 03                	cmp    $0x3,%al
f010f7fa:	75 4d                	jne    f010f849 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f7fc:	83 ec 0c             	sub    $0xc,%esp
f010f7ff:	ff 75 08             	pushl  0x8(%ebp)
f010f802:	e8 48 e9 ff ff       	call   f010e14f <print_trapframe>
f010f807:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f80a:	8b 15 68 93 69 f0    	mov    0xf0699368,%edx
f010f810:	a1 70 93 69 f0       	mov    0xf0699370,%eax
f010f815:	83 ec 08             	sub    $0x8,%esp
f010f818:	ff 75 ec             	pushl  -0x14(%ebp)
f010f81b:	52                   	push   %edx
f010f81c:	50                   	push   %eax
f010f81d:	68 b0 79 12 f0       	push   $0xf01279b0
f010f822:	6a 58                	push   $0x58
f010f824:	68 93 79 12 f0       	push   $0xf0127993
f010f829:	e8 0b 0b ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f82e:	a1 6c 93 69 f0       	mov    0xf069936c,%eax
f010f833:	a3 70 93 69 f0       	mov    %eax,0xf0699370
		before_last_eip = last_eip;
f010f838:	a1 64 93 69 f0       	mov    0xf0699364,%eax
f010f83d:	a3 68 93 69 f0       	mov    %eax,0xf0699368
		num_repeated_fault = 0;
f010f842:	c6 05 74 93 69 f0 00 	movb   $0x0,0xf0699374
	}
	last_eip = (uint32)tf->tf_eip;
f010f849:	8b 45 08             	mov    0x8(%ebp),%eax
f010f84c:	8b 40 30             	mov    0x30(%eax),%eax
f010f84f:	a3 64 93 69 f0       	mov    %eax,0xf0699364
	last_fault_va = fault_va ;
f010f854:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f857:	a3 6c 93 69 f0       	mov    %eax,0xf069936c
	last_faulted_env = cur_env;
f010f85c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f85f:	a3 78 93 69 f0       	mov    %eax,0xf0699378
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f864:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010f86b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f86e:	8b 40 34             	mov    0x34(%eax),%eax
f010f871:	0f b7 c0             	movzwl %ax,%eax
f010f874:	83 e0 03             	and    $0x3,%eax
f010f877:	83 f8 03             	cmp    $0x3,%eax
f010f87a:	75 07                	jne    f010f883 <fault_handler+0xc9>
		userTrap = 1;
f010f87c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010f883:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f887:	0f 85 c2 00 00 00    	jne    f010f94f <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010f88d:	e8 7a 78 ff ff       	call   f010710c <mycpu>
f010f892:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010f895:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010f899:	74 2f                	je     f010f8ca <fault_handler+0x110>
f010f89b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f89e:	8b 40 70             	mov    0x70(%eax),%eax
f010f8a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f8a4:	77 24                	ja     f010f8ca <fault_handler+0x110>
f010f8a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f8a9:	8b 40 70             	mov    0x70(%eax),%eax
f010f8ac:	05 00 10 00 00       	add    $0x1000,%eax
f010f8b1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f8b4:	76 14                	jbe    f010f8ca <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010f8b6:	83 ec 04             	sub    $0x4,%esp
f010f8b9:	68 20 7a 12 f0       	push   $0xf0127a20
f010f8be:	6a 6f                	push   $0x6f
f010f8c0:	68 93 79 12 f0       	push   $0xf0127993
f010f8c5:	e8 6f 0a ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010f8ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f8cd:	8b 40 08             	mov    0x8(%eax),%eax
f010f8d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f8d3:	77 5d                	ja     f010f932 <fault_handler+0x178>
f010f8d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f8d8:	8b 40 08             	mov    0x8(%eax),%eax
f010f8db:	05 00 10 00 00       	add    $0x1000,%eax
f010f8e0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f8e3:	76 4d                	jbe    f010f932 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010f8e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f8e8:	ba c0 17 6c f0       	mov    $0xf06c17c0,%edx
f010f8ed:	29 d0                	sub    %edx,%eax
f010f8ef:	c1 f8 03             	sar    $0x3,%eax
f010f8f2:	89 c2                	mov    %eax,%edx
f010f8f4:	89 d0                	mov    %edx,%eax
f010f8f6:	c1 e0 02             	shl    $0x2,%eax
f010f8f9:	01 d0                	add    %edx,%eax
f010f8fb:	01 c0                	add    %eax,%eax
f010f8fd:	01 d0                	add    %edx,%eax
f010f8ff:	c1 e0 03             	shl    $0x3,%eax
f010f902:	01 d0                	add    %edx,%eax
f010f904:	89 c1                	mov    %eax,%ecx
f010f906:	c1 e1 0b             	shl    $0xb,%ecx
f010f909:	01 c8                	add    %ecx,%eax
f010f90b:	c1 e0 05             	shl    $0x5,%eax
f010f90e:	01 d0                	add    %edx,%eax
f010f910:	c1 e0 02             	shl    $0x2,%eax
f010f913:	01 d0                	add    %edx,%eax
f010f915:	01 c0                	add    %eax,%eax
f010f917:	01 d0                	add    %edx,%eax
f010f919:	c1 e0 03             	shl    $0x3,%eax
f010f91c:	01 d0                	add    %edx,%eax
f010f91e:	f7 d8                	neg    %eax
f010f920:	50                   	push   %eax
f010f921:	68 48 7a 12 f0       	push   $0xf0127a48
f010f926:	6a 71                	push   $0x71
f010f928:	68 93 79 12 f0       	push   $0xf0127993
f010f92d:	e8 07 0a ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010f932:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010f939:	76 3a                	jbe    f010f975 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010f93b:	83 ec 04             	sub    $0x4,%esp
f010f93e:	68 7c 7a 12 f0       	push   $0xf0127a7c
f010f943:	6a 74                	push   $0x74
f010f945:	68 93 79 12 f0       	push   $0xf0127993
f010f94a:	e8 ea 09 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010f94f:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010f956:	76 1d                	jbe    f010f975 <fault_handler+0x1bb>
f010f958:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010f95f:	77 14                	ja     f010f975 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010f961:	83 ec 04             	sub    $0x4,%esp
f010f964:	68 a0 7a 12 f0       	push   $0xf0127aa0
f010f969:	6a 7c                	push   $0x7c
f010f96b:	68 93 79 12 f0       	push   $0xf0127993
f010f970:	e8 c4 09 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010f975:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f978:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010f97b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010f97f:	75 25                	jne    f010f9a6 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010f981:	83 ec 0c             	sub    $0xc,%esp
f010f984:	ff 75 08             	pushl  0x8(%ebp)
f010f987:	e8 c3 e7 ff ff       	call   f010e14f <print_trapframe>
f010f98c:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010f98f:	83 ec 04             	sub    $0x4,%esp
f010f992:	68 c1 7a 12 f0       	push   $0xf0127ac1
f010f997:	68 85 00 00 00       	push   $0x85
f010f99c:	68 93 79 12 f0       	push   $0xf0127993
f010f9a1:	e8 93 09 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010f9a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9a9:	8b 40 64             	mov    0x64(%eax),%eax
f010f9ac:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f9af:	c1 ea 16             	shr    $0x16,%edx
f010f9b2:	c1 e2 02             	shl    $0x2,%edx
f010f9b5:	01 d0                	add    %edx,%eax
f010f9b7:	8b 00                	mov    (%eax),%eax
f010f9b9:	83 e0 01             	and    $0x1,%eax
f010f9bc:	85 c0                	test   %eax,%eax
f010f9be:	75 2b                	jne    f010f9eb <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010f9c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9c3:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010f9c9:	8d 50 01             	lea    0x1(%eax),%edx
f010f9cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9cf:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010f9d5:	83 ec 08             	sub    $0x8,%esp
f010f9d8:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9db:	ff 75 e0             	pushl  -0x20(%ebp)
f010f9de:	e8 1e 01 00 00       	call   f010fb01 <table_fault_handler>
f010f9e3:	83 c4 10             	add    $0x10,%esp
f010f9e6:	e9 07 01 00 00       	jmp    f010faf2 <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010f9eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f9ef:	0f 84 82 00 00 00    	je     f010fa77 <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010f9f5:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010f9fc:	76 07                	jbe    f010fa05 <fault_handler+0x24b>
			{
				env_exit();
f010f9fe:	e8 54 c0 ff ff       	call   f010ba57 <env_exit>
f010fa03:	eb 72                	jmp    f010fa77 <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010fa05:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa08:	8b 40 64             	mov    0x64(%eax),%eax
f010fa0b:	83 ec 08             	sub    $0x8,%esp
f010fa0e:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa11:	50                   	push   %eax
f010fa12:	e8 86 a3 ff ff       	call   f0109d9d <pt_get_page_permissions>
f010fa17:	83 c4 10             	add    $0x10,%esp
f010fa1a:	25 00 02 00 00       	and    $0x200,%eax
f010fa1f:	85 c0                	test   %eax,%eax
f010fa21:	75 17                	jne    f010fa3a <fault_handler+0x280>
f010fa23:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fa26:	85 c0                	test   %eax,%eax
f010fa28:	79 10                	jns    f010fa3a <fault_handler+0x280>
f010fa2a:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010fa31:	77 07                	ja     f010fa3a <fault_handler+0x280>
			{
				env_exit();
f010fa33:	e8 1f c0 ff ff       	call   f010ba57 <env_exit>
f010fa38:	eb 3d                	jmp    f010fa77 <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && (!(pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010fa3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa3d:	8b 40 64             	mov    0x64(%eax),%eax
f010fa40:	83 ec 08             	sub    $0x8,%esp
f010fa43:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa46:	50                   	push   %eax
f010fa47:	e8 51 a3 ff ff       	call   f0109d9d <pt_get_page_permissions>
f010fa4c:	83 c4 10             	add    $0x10,%esp
f010fa4f:	83 e0 01             	and    $0x1,%eax
f010fa52:	85 c0                	test   %eax,%eax
f010fa54:	74 21                	je     f010fa77 <fault_handler+0x2bd>
f010fa56:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa59:	8b 40 64             	mov    0x64(%eax),%eax
f010fa5c:	83 ec 08             	sub    $0x8,%esp
f010fa5f:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa62:	50                   	push   %eax
f010fa63:	e8 35 a3 ff ff       	call   f0109d9d <pt_get_page_permissions>
f010fa68:	83 c4 10             	add    $0x10,%esp
f010fa6b:	83 e0 02             	and    $0x2,%eax
f010fa6e:	85 c0                	test   %eax,%eax
f010fa70:	75 05                	jne    f010fa77 <fault_handler+0x2bd>
			{
				env_exit();
f010fa72:	e8 e0 bf ff ff       	call   f010ba57 <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fa77:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa7a:	8b 40 64             	mov    0x64(%eax),%eax
f010fa7d:	83 ec 08             	sub    $0x8,%esp
f010fa80:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa83:	50                   	push   %eax
f010fa84:	e8 14 a3 ff ff       	call   f0109d9d <pt_get_page_permissions>
f010fa89:	83 c4 10             	add    $0x10,%esp
f010fa8c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fa8f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fa92:	83 e0 01             	and    $0x1,%eax
f010fa95:	85 c0                	test   %eax,%eax
f010fa97:	74 17                	je     f010fab0 <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fa99:	ff 75 ec             	pushl  -0x14(%ebp)
f010fa9c:	68 d8 7a 12 f0       	push   $0xf0127ad8
f010faa1:	68 ad 00 00 00       	push   $0xad
f010faa6:	68 93 79 12 f0       	push   $0xf0127993
f010faab:	e8 89 08 ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fab0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fab3:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010fab9:	8d 50 01             	lea    0x1(%eax),%edx
f010fabc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fabf:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010fac5:	e8 ce fc ff ff       	call   f010f798 <isBufferingEnabled>
f010faca:	84 c0                	test   %al,%al
f010facc:	74 13                	je     f010fae1 <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010face:	83 ec 08             	sub    $0x8,%esp
f010fad1:	ff 75 ec             	pushl  -0x14(%ebp)
f010fad4:	ff 75 e0             	pushl  -0x20(%ebp)
f010fad7:	e8 fe 01 00 00       	call   f010fcda <__page_fault_handler_with_buffering>
f010fadc:	83 c4 10             	add    $0x10,%esp
f010fadf:	eb 11                	jmp    f010faf2 <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010fae1:	83 ec 08             	sub    $0x8,%esp
f010fae4:	ff 75 ec             	pushl  -0x14(%ebp)
f010fae7:	ff 75 e0             	pushl  -0x20(%ebp)
f010faea:	e8 33 00 00 00       	call   f010fb22 <page_fault_handler>
f010faef:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010faf2:	0f 20 d8             	mov    %cr3,%eax
f010faf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010faf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fafb:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fafe:	90                   	nop
f010faff:	c9                   	leave  
f010fb00:	c3                   	ret    

f010fb01 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fb01:	55                   	push   %ebp
f010fb02:	89 e5                	mov    %esp,%ebp
f010fb04:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fb07:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb0a:	8b 40 64             	mov    0x64(%eax),%eax
f010fb0d:	83 ec 08             	sub    $0x8,%esp
f010fb10:	ff 75 0c             	pushl  0xc(%ebp)
f010fb13:	50                   	push   %eax
f010fb14:	e8 2c 8a ff ff       	call   f0108545 <create_page_table>
f010fb19:	83 c4 10             	add    $0x10,%esp
f010fb1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fb1f:	90                   	nop
f010fb20:	c9                   	leave  
f010fb21:	c3                   	ret    

f010fb22 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fb22:	55                   	push   %ebp
f010fb23:	89 e5                	mov    %esp,%ebp
f010fb25:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010fb28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fb2f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb32:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fb38:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010fb3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb3e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fb44:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fb47:	0f 86 74 01 00 00    	jbe    f010fcc1 <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010fb4d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb50:	83 ec 08             	sub    $0x8,%esp
f010fb53:	50                   	push   %eax
f010fb54:	ff 75 08             	pushl  0x8(%ebp)
f010fb57:	e8 85 49 ff ff       	call   f01044e1 <pf_read_env_page>
f010fb5c:	83 c4 10             	add    $0x10,%esp
f010fb5f:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010fb62:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010fb66:	75 45                	jne    f010fbad <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010fb68:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb6b:	85 c0                	test   %eax,%eax
f010fb6d:	79 09                	jns    f010fb78 <page_fault_handler+0x56>
f010fb6f:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010fb76:	76 35                	jbe    f010fbad <page_fault_handler+0x8b>
f010fb78:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010fb7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb82:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010fb87:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010fb8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb8d:	ba 00 00 00 00       	mov    $0x0,%edx
f010fb92:	f7 75 e8             	divl   -0x18(%ebp)
f010fb95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb98:	29 d0                	sub    %edx,%eax
f010fb9a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fb9d:	77 09                	ja     f010fba8 <page_fault_handler+0x86>
f010fb9f:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010fba6:	76 05                	jbe    f010fbad <page_fault_handler+0x8b>
			{
				env_exit();
f010fba8:	e8 aa be ff ff       	call   f010ba57 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010fbad:	83 ec 0c             	sub    $0xc,%esp
f010fbb0:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010fbb3:	50                   	push   %eax
f010fbb4:	e8 f9 85 ff ff       	call   f01081b2 <allocate_frame>
f010fbb9:	83 c4 10             	add    $0x10,%esp
f010fbbc:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010fbbf:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010fbc3:	74 34                	je     f010fbf9 <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010fbc5:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010fbc8:	8b 45 08             	mov    0x8(%ebp),%eax
f010fbcb:	8b 40 64             	mov    0x64(%eax),%eax
f010fbce:	6a 06                	push   $0x6
f010fbd0:	ff 75 0c             	pushl  0xc(%ebp)
f010fbd3:	52                   	push   %edx
f010fbd4:	50                   	push   %eax
f010fbd5:	e8 a5 8a ff ff       	call   f010867f <map_frame>
f010fbda:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010fbdd:	83 ec 08             	sub    $0x8,%esp
f010fbe0:	ff 75 0c             	pushl  0xc(%ebp)
f010fbe3:	ff 75 08             	pushl  0x8(%ebp)
f010fbe6:	e8 24 a3 ff ff       	call   f0109f0f <env_page_ws_list_create_element>
f010fbeb:	83 c4 10             	add    $0x10,%esp
f010fbee:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fbf1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010fbf5:	75 30                	jne    f010fc27 <page_fault_handler+0x105>
f010fbf7:	eb 17                	jmp    f010fc10 <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010fbf9:	83 ec 04             	sub    $0x4,%esp
f010fbfc:	68 1c 7b 12 f0       	push   $0xf0127b1c
f010fc01:	68 03 01 00 00       	push   $0x103
f010fc06:	68 93 79 12 f0       	push   $0xf0127993
f010fc0b:	e8 29 07 ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010fc10:	83 ec 04             	sub    $0x4,%esp
f010fc13:	68 34 7b 12 f0       	push   $0xf0127b34
f010fc18:	68 05 01 00 00       	push   $0x105
f010fc1d:	68 93 79 12 f0       	push   $0xf0127993
f010fc22:	e8 12 07 ff ff       	call   f0100339 <_panic>
f010fc27:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc2a:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010fc30:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc33:	89 50 14             	mov    %edx,0x14(%eax)
f010fc36:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc39:	8b 40 14             	mov    0x14(%eax),%eax
f010fc3c:	85 c0                	test   %eax,%eax
f010fc3e:	74 11                	je     f010fc51 <page_fault_handler+0x12f>
f010fc40:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc43:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010fc49:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fc4c:	89 50 10             	mov    %edx,0x10(%eax)
f010fc4f:	eb 0c                	jmp    f010fc5d <page_fault_handler+0x13b>
f010fc51:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc54:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fc57:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010fc5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc60:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fc63:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010fc69:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fc6c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010fc73:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc76:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010fc7c:	8d 50 01             	lea    0x1(%eax),%edx
f010fc7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc82:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010fc88:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc8b:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010fc91:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc94:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010fc9a:	39 c2                	cmp    %eax,%edx
f010fc9c:	75 14                	jne    f010fcb2 <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010fc9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fca1:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010fca7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcaa:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fcb0:	eb 26                	jmp    f010fcd8 <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010fcb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcb5:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010fcbc:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010fcbf:	eb 17                	jmp    f010fcd8 <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010fcc1:	83 ec 04             	sub    $0x4,%esp
f010fcc4:	68 58 7b 12 f0       	push   $0xf0127b58
f010fcc9:	68 15 01 00 00       	push   $0x115
f010fcce:	68 93 79 12 f0       	push   $0xf0127993
f010fcd3:	e8 61 06 ff ff       	call   f0100339 <_panic>
	}
}
f010fcd8:	c9                   	leave  
f010fcd9:	c3                   	ret    

f010fcda <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010fcda:	55                   	push   %ebp
f010fcdb:	89 e5                	mov    %esp,%ebp
f010fcdd:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010fce0:	83 ec 04             	sub    $0x4,%esp
f010fce3:	68 98 7b 12 f0       	push   $0xf0127b98
f010fce8:	68 1d 01 00 00       	push   $0x11d
f010fced:	68 93 79 12 f0       	push   $0xf0127993
f010fcf2:	e8 42 06 ff ff       	call   f0100339 <_panic>

f010fcf7 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010fcf7:	55                   	push   %ebp
f010fcf8:	89 e5                	mov    %esp,%ebp
f010fcfa:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fcfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd00:	83 c0 04             	add    $0x4,%eax
f010fd03:	83 ec 08             	sub    $0x8,%esp
f010fd06:	ff 75 0c             	pushl  0xc(%ebp)
f010fd09:	50                   	push   %eax
f010fd0a:	e8 16 00 01 00       	call   f011fd25 <strcpy>
f010fd0f:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fd12:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd15:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fd1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd1e:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fd25:	90                   	nop
f010fd26:	c9                   	leave  
f010fd27:	c3                   	ret    

f010fd28 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010fd28:	55                   	push   %ebp
f010fd29:	89 e5                	mov    %esp,%ebp
f010fd2b:	53                   	push   %ebx
f010fd2c:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010fd2f:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd32:	83 ec 0c             	sub    $0xc,%esp
f010fd35:	50                   	push   %eax
f010fd36:	e8 06 02 00 00       	call   f010ff41 <holding_spinlock>
f010fd3b:	83 c4 10             	add    $0x10,%esp
f010fd3e:	85 c0                	test   %eax,%eax
f010fd40:	74 18                	je     f010fd5a <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010fd42:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd45:	83 c0 04             	add    $0x4,%eax
f010fd48:	50                   	push   %eax
f010fd49:	68 dc 7b 12 f0       	push   $0xf0127bdc
f010fd4e:	6a 1f                	push   $0x1f
f010fd50:	68 19 7c 12 f0       	push   $0xf0127c19
f010fd55:	e8 df 05 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010fd5a:	e8 70 74 ff ff       	call   f01071cf <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010fd5f:	90                   	nop
f010fd60:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd63:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010fd66:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fd6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010fd70:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fd73:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010fd76:	f0 87 02             	lock xchg %eax,(%edx)
f010fd79:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010fd7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fd7f:	85 c0                	test   %eax,%eax
f010fd81:	75 dd                	jne    f010fd60 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010fd83:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010fd88:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010fd8b:	e8 7c 73 ff ff       	call   f010710c <mycpu>
f010fd90:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010fd93:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd96:	83 c0 48             	add    $0x48,%eax
f010fd99:	83 ec 08             	sub    $0x8,%esp
f010fd9c:	50                   	push   %eax
f010fd9d:	8d 45 08             	lea    0x8(%ebp),%eax
f010fda0:	50                   	push   %eax
f010fda1:	e8 74 00 00 00       	call   f010fe1a <getcallerpcs>
f010fda6:	83 c4 10             	add    $0x10,%esp

}
f010fda9:	90                   	nop
f010fdaa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fdad:	c9                   	leave  
f010fdae:	c3                   	ret    

f010fdaf <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010fdaf:	55                   	push   %ebp
f010fdb0:	89 e5                	mov    %esp,%ebp
f010fdb2:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010fdb5:	83 ec 0c             	sub    $0xc,%esp
f010fdb8:	ff 75 08             	pushl  0x8(%ebp)
f010fdbb:	e8 81 01 00 00       	call   f010ff41 <holding_spinlock>
f010fdc0:	83 c4 10             	add    $0x10,%esp
f010fdc3:	85 c0                	test   %eax,%eax
f010fdc5:	75 26                	jne    f010fded <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010fdc7:	83 ec 0c             	sub    $0xc,%esp
f010fdca:	ff 75 08             	pushl  0x8(%ebp)
f010fdcd:	e8 08 01 00 00       	call   f010feda <printcallstack>
f010fdd2:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010fdd5:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdd8:	83 c0 04             	add    $0x4,%eax
f010fddb:	50                   	push   %eax
f010fddc:	68 30 7c 12 f0       	push   $0xf0127c30
f010fde1:	6a 3c                	push   $0x3c
f010fde3:	68 19 7c 12 f0       	push   $0xf0127c19
f010fde8:	e8 4c 05 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010fded:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdf0:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010fdf7:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdfa:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010fe01:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010fe06:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe09:	8b 55 08             	mov    0x8(%ebp),%edx
f010fe0c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010fe12:	e8 0a 74 ff ff       	call   f0107221 <popcli>
}
f010fe17:	90                   	nop
f010fe18:	c9                   	leave  
f010fe19:	c3                   	ret    

f010fe1a <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010fe1a:	55                   	push   %ebp
f010fe1b:	89 e5                	mov    %esp,%ebp
f010fe1d:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010fe20:	e8 74 bc ff ff       	call   f010ba99 <get_cpu_proc>
f010fe25:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010fe28:	e8 df 72 ff ff       	call   f010710c <mycpu>
f010fe2d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010fe30:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe33:	83 e8 08             	sub    $0x8,%eax
f010fe36:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010fe39:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010fe40:	eb 67                	jmp    f010fea9 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fe42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fe46:	74 67                	je     f010feaf <getcallerpcs+0x95>
f010fe48:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010fe4f:	76 5e                	jbe    f010feaf <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fe51:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe54:	8b 40 08             	mov    0x8(%eax),%eax
f010fe57:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fe5c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fe5f:	77 10                	ja     f010fe71 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fe61:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe64:	8b 40 08             	mov    0x8(%eax),%eax
f010fe67:	05 00 90 00 00       	add    $0x9000,%eax
f010fe6c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fe6f:	77 3e                	ja     f010feaf <getcallerpcs+0x95>
f010fe71:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fe75:	74 10                	je     f010fe87 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010fe77:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fe7a:	8b 40 70             	mov    0x70(%eax),%eax
f010fe7d:	05 00 80 00 00       	add    $0x8000,%eax
f010fe82:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fe85:	76 28                	jbe    f010feaf <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010fe87:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe8a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fe91:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe94:	01 c2                	add    %eax,%edx
f010fe96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe99:	8b 40 04             	mov    0x4(%eax),%eax
f010fe9c:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010fe9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fea1:	8b 00                	mov    (%eax),%eax
f010fea3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010fea6:	ff 45 f0             	incl   -0x10(%ebp)
f010fea9:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fead:	7e 93                	jle    f010fe42 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010feaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010feb2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010feb5:	eb 18                	jmp    f010fecf <getcallerpcs+0xb5>
		pcs[i] = 0;
f010feb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010feba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fec1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fec4:	01 d0                	add    %edx,%eax
f010fec6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010fecc:	ff 45 f0             	incl   -0x10(%ebp)
f010fecf:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010fed3:	7e e2                	jle    f010feb7 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010fed5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010fed8:	c9                   	leave  
f010fed9:	c3                   	ret    

f010feda <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010feda:	55                   	push   %ebp
f010fedb:	89 e5                	mov    %esp,%ebp
f010fedd:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010fee0:	83 ec 0c             	sub    $0xc,%esp
f010fee3:	68 6e 7c 12 f0       	push   $0xf0127c6e
f010fee8:	e8 9e 10 ff ff       	call   f0100f8b <cprintf>
f010feed:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010fef0:	8b 45 08             	mov    0x8(%ebp),%eax
f010fef3:	83 c0 48             	add    $0x48,%eax
f010fef6:	83 ec 08             	sub    $0x8,%esp
f010fef9:	50                   	push   %eax
f010fefa:	8d 45 08             	lea    0x8(%ebp),%eax
f010fefd:	50                   	push   %eax
f010fefe:	e8 17 ff ff ff       	call   f010fe1a <getcallerpcs>
f010ff03:	83 c4 10             	add    $0x10,%esp
f010ff06:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010ff09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ff10:	eb 24                	jmp    f010ff36 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010ff12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ff18:	83 c2 10             	add    $0x10,%edx
f010ff1b:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010ff1f:	83 ec 04             	sub    $0x4,%esp
f010ff22:	50                   	push   %eax
f010ff23:	ff 75 f4             	pushl  -0xc(%ebp)
f010ff26:	68 7e 7c 12 f0       	push   $0xf0127c7e
f010ff2b:	e8 5b 10 ff ff       	call   f0100f8b <cprintf>
f010ff30:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010ff33:	ff 45 f4             	incl   -0xc(%ebp)
f010ff36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ff39:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ff3c:	7c d4                	jl     f010ff12 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010ff3e:	90                   	nop
f010ff3f:	c9                   	leave  
f010ff40:	c3                   	ret    

f010ff41 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010ff41:	55                   	push   %ebp
f010ff42:	89 e5                	mov    %esp,%ebp
f010ff44:	53                   	push   %ebx
f010ff45:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010ff48:	e8 82 72 ff ff       	call   f01071cf <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010ff4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff50:	8b 00                	mov    (%eax),%eax
f010ff52:	85 c0                	test   %eax,%eax
f010ff54:	74 16                	je     f010ff6c <holding_spinlock+0x2b>
f010ff56:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff59:	8b 58 44             	mov    0x44(%eax),%ebx
f010ff5c:	e8 ab 71 ff ff       	call   f010710c <mycpu>
f010ff61:	39 c3                	cmp    %eax,%ebx
f010ff63:	75 07                	jne    f010ff6c <holding_spinlock+0x2b>
f010ff65:	b8 01 00 00 00       	mov    $0x1,%eax
f010ff6a:	eb 05                	jmp    f010ff71 <holding_spinlock+0x30>
f010ff6c:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff71:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010ff74:	e8 a8 72 ff ff       	call   f0107221 <popcli>
	return r;
f010ff79:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ff7c:	83 c4 14             	add    $0x14,%esp
f010ff7f:	5b                   	pop    %ebx
f010ff80:	5d                   	pop    %ebp
f010ff81:	c3                   	ret    

f010ff82 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010ff82:	55                   	push   %ebp
f010ff83:	89 e5                	mov    %esp,%ebp
f010ff85:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010ff88:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff8b:	83 c0 74             	add    $0x74,%eax
f010ff8e:	83 ec 08             	sub    $0x8,%esp
f010ff91:	68 8d 7c 12 f0       	push   $0xf0127c8d
f010ff96:	50                   	push   %eax
f010ff97:	e8 4c 01 00 00       	call   f01100e8 <init_channel>
f010ff9c:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ff9f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa2:	83 c0 04             	add    $0x4,%eax
f010ffa5:	83 ec 08             	sub    $0x8,%esp
f010ffa8:	68 a0 7c 12 f0       	push   $0xf0127ca0
f010ffad:	50                   	push   %eax
f010ffae:	e8 44 fd ff ff       	call   f010fcf7 <init_spinlock>
f010ffb3:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010ffb6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffb9:	05 c4 00 00 00       	add    $0xc4,%eax
f010ffbe:	83 ec 08             	sub    $0x8,%esp
f010ffc1:	ff 75 0c             	pushl  0xc(%ebp)
f010ffc4:	50                   	push   %eax
f010ffc5:	e8 5b fd 00 00       	call   f011fd25 <strcpy>
f010ffca:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ffcd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffd0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010ffd6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffd9:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010ffe0:	00 00 00 
}
f010ffe3:	90                   	nop
f010ffe4:	c9                   	leave  
f010ffe5:	c3                   	ret    

f010ffe6 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010ffe6:	55                   	push   %ebp
f010ffe7:	89 e5                	mov    %esp,%ebp
f010ffe9:	53                   	push   %ebx
f010ffea:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ffed:	8b 45 08             	mov    0x8(%ebp),%eax
f010fff0:	83 c0 04             	add    $0x4,%eax
f010fff3:	83 ec 0c             	sub    $0xc,%esp
f010fff6:	50                   	push   %eax
f010fff7:	e8 2c fd ff ff       	call   f010fd28 <acquire_spinlock>
f010fffc:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010ffff:	8b 45 08             	mov    0x8(%ebp),%eax
f0110002:	8b 00                	mov    (%eax),%eax
f0110004:	85 c0                	test   %eax,%eax
f0110006:	74 1c                	je     f0110024 <holding_sleeplock+0x3e>
f0110008:	8b 45 08             	mov    0x8(%ebp),%eax
f011000b:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f0110011:	e8 83 ba ff ff       	call   f010ba99 <get_cpu_proc>
f0110016:	8b 40 10             	mov    0x10(%eax),%eax
f0110019:	39 c3                	cmp    %eax,%ebx
f011001b:	75 07                	jne    f0110024 <holding_sleeplock+0x3e>
f011001d:	b8 01 00 00 00       	mov    $0x1,%eax
f0110022:	eb 05                	jmp    f0110029 <holding_sleeplock+0x43>
f0110024:	b8 00 00 00 00       	mov    $0x0,%eax
f0110029:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f011002c:	8b 45 08             	mov    0x8(%ebp),%eax
f011002f:	83 c0 04             	add    $0x4,%eax
f0110032:	83 ec 0c             	sub    $0xc,%esp
f0110035:	50                   	push   %eax
f0110036:	e8 74 fd ff ff       	call   f010fdaf <release_spinlock>
f011003b:	83 c4 10             	add    $0x10,%esp
	return r;
f011003e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110041:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110044:	c9                   	leave  
f0110045:	c3                   	ret    

f0110046 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f0110046:	55                   	push   %ebp
f0110047:	89 e5                	mov    %esp,%ebp
f0110049:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f011004c:	8b 45 08             	mov    0x8(%ebp),%eax
f011004f:	83 c0 04             	add    $0x4,%eax
f0110052:	83 ec 0c             	sub    $0xc,%esp
f0110055:	50                   	push   %eax
f0110056:	e8 cd fc ff ff       	call   f010fd28 <acquire_spinlock>
f011005b:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f011005e:	eb 19                	jmp    f0110079 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f0110060:	8b 45 08             	mov    0x8(%ebp),%eax
f0110063:	8d 50 04             	lea    0x4(%eax),%edx
f0110066:	8b 45 08             	mov    0x8(%ebp),%eax
f0110069:	83 c0 74             	add    $0x74,%eax
f011006c:	83 ec 08             	sub    $0x8,%esp
f011006f:	52                   	push   %edx
f0110070:	50                   	push   %eax
f0110071:	e8 9f 00 00 00       	call   f0110115 <sleep>
f0110076:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f0110079:	8b 45 08             	mov    0x8(%ebp),%eax
f011007c:	8b 00                	mov    (%eax),%eax
f011007e:	85 c0                	test   %eax,%eax
f0110080:	75 de                	jne    f0110060 <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f0110082:	8b 45 08             	mov    0x8(%ebp),%eax
f0110085:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f011008b:	8b 45 08             	mov    0x8(%ebp),%eax
f011008e:	83 c0 04             	add    $0x4,%eax
f0110091:	83 ec 0c             	sub    $0xc,%esp
f0110094:	50                   	push   %eax
f0110095:	e8 15 fd ff ff       	call   f010fdaf <release_spinlock>
f011009a:	83 c4 10             	add    $0x10,%esp

}
f011009d:	90                   	nop
f011009e:	c9                   	leave  
f011009f:	c3                   	ret    

f01100a0 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f01100a0:	55                   	push   %ebp
f01100a1:	89 e5                	mov    %esp,%ebp
f01100a3:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f01100a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01100a9:	83 c0 04             	add    $0x4,%eax
f01100ac:	83 ec 0c             	sub    $0xc,%esp
f01100af:	50                   	push   %eax
f01100b0:	e8 73 fc ff ff       	call   f010fd28 <acquire_spinlock>
f01100b5:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f01100b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01100bb:	83 c0 74             	add    $0x74,%eax
f01100be:	83 ec 0c             	sub    $0xc,%esp
f01100c1:	50                   	push   %eax
f01100c2:	e8 3f 01 00 00       	call   f0110206 <wakeup_all>
f01100c7:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f01100ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01100cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f01100d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01100d6:	83 c0 04             	add    $0x4,%eax
f01100d9:	83 ec 0c             	sub    $0xc,%esp
f01100dc:	50                   	push   %eax
f01100dd:	e8 cd fc ff ff       	call   f010fdaf <release_spinlock>
f01100e2:	83 c4 10             	add    $0x10,%esp
}
f01100e5:	90                   	nop
f01100e6:	c9                   	leave  
f01100e7:	c3                   	ret    

f01100e8 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f01100e8:	55                   	push   %ebp
f01100e9:	89 e5                	mov    %esp,%ebp
f01100eb:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f01100ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01100f1:	83 c0 10             	add    $0x10,%eax
f01100f4:	83 ec 08             	sub    $0x8,%esp
f01100f7:	ff 75 0c             	pushl  0xc(%ebp)
f01100fa:	50                   	push   %eax
f01100fb:	e8 25 fc 00 00       	call   f011fd25 <strcpy>
f0110100:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f0110103:	8b 45 08             	mov    0x8(%ebp),%eax
f0110106:	83 ec 0c             	sub    $0xc,%esp
f0110109:	50                   	push   %eax
f011010a:	e8 5a 4e ff ff       	call   f0104f69 <init_queue>
f011010f:	83 c4 10             	add    $0x10,%esp
}
f0110112:	90                   	nop
f0110113:	c9                   	leave  
f0110114:	c3                   	ret    

f0110115 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f0110115:	55                   	push   %ebp
f0110116:	89 e5                	mov    %esp,%ebp
f0110118:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f011011b:	83 ec 0c             	sub    $0xc,%esp
f011011e:	68 e0 15 6c f0       	push   $0xf06c15e0
f0110123:	e8 00 fc ff ff       	call   f010fd28 <acquire_spinlock>
f0110128:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f011012b:	e8 69 b9 ff ff       	call   f010ba99 <get_cpu_proc>
f0110130:	89 c2                	mov    %eax,%edx
f0110132:	8b 45 08             	mov    0x8(%ebp),%eax
f0110135:	83 ec 08             	sub    $0x8,%esp
f0110138:	52                   	push   %edx
f0110139:	50                   	push   %eax
f011013a:	e8 6b 4e ff ff       	call   f0104faa <enqueue>
f011013f:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f0110142:	e8 52 b9 ff ff       	call   f010ba99 <get_cpu_proc>
f0110147:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f011014e:	83 ec 0c             	sub    $0xc,%esp
f0110151:	ff 75 0c             	pushl  0xc(%ebp)
f0110154:	e8 56 fc ff ff       	call   f010fdaf <release_spinlock>
f0110159:	83 c4 10             	add    $0x10,%esp
	sched();
f011015c:	e8 b9 ba ff ff       	call   f010bc1a <sched>
	release_spinlock(&(ProcessQueues.qlock));
f0110161:	83 ec 0c             	sub    $0xc,%esp
f0110164:	68 e0 15 6c f0       	push   $0xf06c15e0
f0110169:	e8 41 fc ff ff       	call   f010fdaf <release_spinlock>
f011016e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f0110171:	83 ec 0c             	sub    $0xc,%esp
f0110174:	ff 75 0c             	pushl  0xc(%ebp)
f0110177:	e8 ac fb ff ff       	call   f010fd28 <acquire_spinlock>
f011017c:	83 c4 10             	add    $0x10,%esp
}
f011017f:	90                   	nop
f0110180:	c9                   	leave  
f0110181:	c3                   	ret    

f0110182 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f0110182:	55                   	push   %ebp
f0110183:	89 e5                	mov    %esp,%ebp
f0110185:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f0110188:	8b 45 08             	mov    0x8(%ebp),%eax
f011018b:	83 ec 0c             	sub    $0xc,%esp
f011018e:	50                   	push   %eax
f011018f:	e8 fe 4d ff ff       	call   f0104f92 <queue_size>
f0110194:	83 c4 10             	add    $0x10,%esp
f0110197:	85 c0                	test   %eax,%eax
f0110199:	74 68                	je     f0110203 <wakeup_one+0x81>
		bool locked_by_me = 0;
f011019b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f01101a2:	83 ec 0c             	sub    $0xc,%esp
f01101a5:	68 e0 15 6c f0       	push   $0xf06c15e0
f01101aa:	e8 92 fd ff ff       	call   f010ff41 <holding_spinlock>
f01101af:	83 c4 10             	add    $0x10,%esp
f01101b2:	85 c0                	test   %eax,%eax
f01101b4:	75 17                	jne    f01101cd <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f01101b6:	83 ec 0c             	sub    $0xc,%esp
f01101b9:	68 e0 15 6c f0       	push   $0xf06c15e0
f01101be:	e8 65 fb ff ff       	call   f010fd28 <acquire_spinlock>
f01101c3:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f01101c6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f01101cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01101d0:	83 ec 0c             	sub    $0xc,%esp
f01101d3:	50                   	push   %eax
f01101d4:	e8 62 4e ff ff       	call   f010503b <dequeue>
f01101d9:	83 c4 10             	add    $0x10,%esp
f01101dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f01101df:	83 ec 0c             	sub    $0xc,%esp
f01101e2:	ff 75 f0             	pushl  -0x10(%ebp)
f01101e5:	e8 8c 50 ff ff       	call   f0105276 <sched_insert_ready0>
f01101ea:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f01101ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01101f1:	74 10                	je     f0110203 <wakeup_one+0x81>
f01101f3:	83 ec 0c             	sub    $0xc,%esp
f01101f6:	68 e0 15 6c f0       	push   $0xf06c15e0
f01101fb:	e8 af fb ff ff       	call   f010fdaf <release_spinlock>
f0110200:	83 c4 10             	add    $0x10,%esp
	}
}
f0110203:	90                   	nop
f0110204:	c9                   	leave  
f0110205:	c3                   	ret    

f0110206 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f0110206:	55                   	push   %ebp
f0110207:	89 e5                	mov    %esp,%ebp
f0110209:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f011020c:	83 ec 0c             	sub    $0xc,%esp
f011020f:	68 e0 15 6c f0       	push   $0xf06c15e0
f0110214:	e8 0f fb ff ff       	call   f010fd28 <acquire_spinlock>
f0110219:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f011021c:	eb 0e                	jmp    f011022c <wakeup_all+0x26>
		wakeup_one(chan);
f011021e:	83 ec 0c             	sub    $0xc,%esp
f0110221:	ff 75 08             	pushl  0x8(%ebp)
f0110224:	e8 59 ff ff ff       	call   f0110182 <wakeup_one>
f0110229:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f011022c:	8b 45 08             	mov    0x8(%ebp),%eax
f011022f:	83 ec 0c             	sub    $0xc,%esp
f0110232:	50                   	push   %eax
f0110233:	e8 5a 4d ff ff       	call   f0104f92 <queue_size>
f0110238:	83 c4 10             	add    $0x10,%esp
f011023b:	85 c0                	test   %eax,%eax
f011023d:	75 df                	jne    f011021e <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f011023f:	83 ec 0c             	sub    $0xc,%esp
f0110242:	68 e0 15 6c f0       	push   $0xf06c15e0
f0110247:	e8 63 fb ff ff       	call   f010fdaf <release_spinlock>
f011024c:	83 c4 10             	add    $0x10,%esp
}
f011024f:	90                   	nop
f0110250:	c9                   	leave  
f0110251:	c3                   	ret    

f0110252 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f0110252:	55                   	push   %ebp
f0110253:	89 e5                	mov    %esp,%ebp
f0110255:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f0110258:	83 ec 04             	sub    $0x4,%esp
f011025b:	68 b4 7c 12 f0       	push   $0xf0127cb4
f0110260:	6a 13                	push   $0x13
f0110262:	68 db 7c 12 f0       	push   $0xf0127cdb
f0110267:	e8 cd 00 ff ff       	call   f0100339 <_panic>

f011026c <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f011026c:	55                   	push   %ebp
f011026d:	89 e5                	mov    %esp,%ebp
f011026f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f0110272:	83 ec 04             	sub    $0x4,%esp
f0110275:	68 f4 7c 12 f0       	push   $0xf0127cf4
f011027a:	6a 1b                	push   $0x1b
f011027c:	68 db 7c 12 f0       	push   $0xf0127cdb
f0110281:	e8 b3 00 ff ff       	call   f0100339 <_panic>

f0110286 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f0110286:	55                   	push   %ebp
f0110287:	89 e5                	mov    %esp,%ebp
f0110289:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f011028c:	83 ec 04             	sub    $0x4,%esp
f011028f:	68 1c 7d 12 f0       	push   $0xf0127d1c
f0110294:	6a 24                	push   $0x24
f0110296:	68 db 7c 12 f0       	push   $0xf0127cdb
f011029b:	e8 99 00 ff ff       	call   f0100339 <_panic>

f01102a0 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f01102a0:	55                   	push   %ebp
f01102a1:	89 e5                	mov    %esp,%ebp
f01102a3:	c7 05 78 1b 6c f0 01 	movl   $0x1,0xf06c1b78
f01102aa:	00 00 00 
f01102ad:	90                   	nop
f01102ae:	5d                   	pop    %ebp
f01102af:	c3                   	ret    

f01102b0 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f01102b0:	55                   	push   %ebp
f01102b1:	89 e5                	mov    %esp,%ebp
f01102b3:	c7 05 78 1b 6c f0 02 	movl   $0x2,0xf06c1b78
f01102ba:	00 00 00 
f01102bd:	90                   	nop
f01102be:	5d                   	pop    %ebp
f01102bf:	c3                   	ret    

f01102c0 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f01102c0:	55                   	push   %ebp
f01102c1:	89 e5                	mov    %esp,%ebp
f01102c3:	c7 05 78 1b 6c f0 03 	movl   $0x3,0xf06c1b78
f01102ca:	00 00 00 
f01102cd:	90                   	nop
f01102ce:	5d                   	pop    %ebp
f01102cf:	c3                   	ret    

f01102d0 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01102d0:	55                   	push   %ebp
f01102d1:	89 e5                	mov    %esp,%ebp
f01102d3:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f01102d8:	83 f8 01             	cmp    $0x1,%eax
f01102db:	75 04                	jne    f01102e1 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f01102dd:	b0 01                	mov    $0x1,%al
f01102df:	eb 02                	jmp    f01102e3 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f01102e1:	b0 00                	mov    $0x0,%al
f01102e3:	5d                   	pop    %ebp
f01102e4:	c3                   	ret    

f01102e5 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f01102e5:	55                   	push   %ebp
f01102e6:	89 e5                	mov    %esp,%ebp
f01102e8:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f01102ed:	83 f8 02             	cmp    $0x2,%eax
f01102f0:	75 04                	jne    f01102f6 <isKHeapPlacementStrategyBESTFIT+0x11>
f01102f2:	b0 01                	mov    $0x1,%al
f01102f4:	eb 02                	jmp    f01102f8 <isKHeapPlacementStrategyBESTFIT+0x13>
f01102f6:	b0 00                	mov    $0x0,%al
f01102f8:	5d                   	pop    %ebp
f01102f9:	c3                   	ret    

f01102fa <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f01102fa:	55                   	push   %ebp
f01102fb:	89 e5                	mov    %esp,%ebp
f01102fd:	a1 78 1b 6c f0       	mov    0xf06c1b78,%eax
f0110302:	83 f8 03             	cmp    $0x3,%eax
f0110305:	75 04                	jne    f011030b <isKHeapPlacementStrategyNEXTFIT+0x11>
f0110307:	b0 01                	mov    $0x1,%al
f0110309:	eb 02                	jmp    f011030d <isKHeapPlacementStrategyNEXTFIT+0x13>
f011030b:	b0 00                	mov    $0x0,%al
f011030d:	5d                   	pop    %ebp
f011030e:	c3                   	ret    

f011030f <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f011030f:	55                   	push   %ebp
f0110310:	89 e5                	mov    %esp,%ebp
f0110312:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110315:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011031c:	eb 26                	jmp    f0110344 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f011031e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110321:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110328:	8b 45 0c             	mov    0xc(%ebp),%eax
f011032b:	01 c2                	add    %eax,%edx
f011032d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110330:	40                   	inc    %eax
f0110331:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110338:	8b 45 0c             	mov    0xc(%ebp),%eax
f011033b:	01 c8                	add    %ecx,%eax
f011033d:	8b 00                	mov    (%eax),%eax
f011033f:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110341:	ff 45 f4             	incl   -0xc(%ebp)
f0110344:	8b 45 08             	mov    0x8(%ebp),%eax
f0110347:	48                   	dec    %eax
f0110348:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011034b:	7f d1                	jg     f011031e <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f011034d:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f0110350:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110357:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011035e:	eb 35                	jmp    f0110395 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f0110360:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110363:	89 d0                	mov    %edx,%eax
f0110365:	01 c0                	add    %eax,%eax
f0110367:	01 d0                	add    %edx,%eax
f0110369:	c1 e0 02             	shl    $0x2,%eax
f011036c:	05 00 fd 17 f0       	add    $0xf017fd00,%eax
f0110371:	8b 10                	mov    (%eax),%edx
f0110373:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110376:	8b 00                	mov    (%eax),%eax
f0110378:	83 ec 08             	sub    $0x8,%esp
f011037b:	52                   	push   %edx
f011037c:	50                   	push   %eax
f011037d:	e8 60 fa 00 00       	call   f011fde2 <strcmp>
f0110382:	83 c4 10             	add    $0x10,%esp
f0110385:	85 c0                	test   %eax,%eax
f0110387:	75 09                	jne    f0110392 <tst_handler+0x83>
		{
			test_found = 1;
f0110389:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f0110390:	eb 0f                	jmp    f01103a1 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110392:	ff 45 ec             	incl   -0x14(%ebp)
f0110395:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110398:	a1 b4 fd 17 f0       	mov    0xf017fdb4,%eax
f011039d:	39 c2                	cmp    %eax,%edx
f011039f:	72 bf                	jb     f0110360 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f01103a1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103a5:	74 29                	je     f01103d0 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f01103a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01103aa:	89 d0                	mov    %edx,%eax
f01103ac:	01 c0                	add    %eax,%eax
f01103ae:	01 d0                	add    %edx,%eax
f01103b0:	c1 e0 02             	shl    $0x2,%eax
f01103b3:	05 08 fd 17 f0       	add    $0xf017fd08,%eax
f01103b8:	8b 00                	mov    (%eax),%eax
f01103ba:	83 ec 08             	sub    $0x8,%esp
f01103bd:	ff 75 0c             	pushl  0xc(%ebp)
f01103c0:	ff 75 08             	pushl  0x8(%ebp)
f01103c3:	ff d0                	call   *%eax
f01103c5:	83 c4 10             	add    $0x10,%esp
f01103c8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f01103cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01103ce:	eb 1b                	jmp    f01103eb <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f01103d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103d3:	8b 00                	mov    (%eax),%eax
f01103d5:	83 ec 08             	sub    $0x8,%esp
f01103d8:	50                   	push   %eax
f01103d9:	68 5c 80 12 f0       	push   $0xf012805c
f01103de:	e8 a8 0b ff ff       	call   f0100f8b <cprintf>
f01103e3:	83 c4 10             	add    $0x10,%esp
		return 0;
f01103e6:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f01103eb:	c9                   	leave  
f01103ec:	c3                   	ret    

f01103ed <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f01103ed:	55                   	push   %ebp
f01103ee:	89 e5                	mov    %esp,%ebp
f01103f0:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f01103f3:	e8 69 d0 00 00       	call   f011d461 <test_three_creation_functions>
	return 0;
f01103f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103fd:	c9                   	leave  
f01103fe:	c3                   	ret    

f01103ff <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f01103ff:	55                   	push   %ebp
f0110400:	89 e5                	mov    %esp,%ebp
f0110402:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f0110405:	e8 03 69 00 00       	call   f0116d0d <test_priority_normal_and_higher>
	return 0;
f011040a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011040f:	c9                   	leave  
f0110410:	c3                   	ret    

f0110411 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0110411:	55                   	push   %ebp
f0110412:	89 e5                	mov    %esp,%ebp
f0110414:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f0110417:	e8 0b 69 00 00       	call   f0116d27 <test_priority_normal_and_lower>
	return 0;
f011041c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110421:	c9                   	leave  
f0110422:	c3                   	ret    

f0110423 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f0110423:	55                   	push   %ebp
f0110424:	89 e5                	mov    %esp,%ebp
f0110426:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f0110429:	e8 e6 d1 00 00       	call   f011d614 <test_kfreeall>
	return 0;
f011042e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110433:	c9                   	leave  
f0110434:	c3                   	ret    

f0110435 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f0110435:	55                   	push   %ebp
f0110436:	89 e5                	mov    %esp,%ebp
f0110438:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f011043b:	e8 f1 d1 00 00       	call   f011d631 <test_kexpand>
	return 0;
f0110440:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110445:	c9                   	leave  
f0110446:	c3                   	ret    

f0110447 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f0110447:	55                   	push   %ebp
f0110448:	89 e5                	mov    %esp,%ebp
f011044a:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f011044d:	e8 fc d1 00 00       	call   f011d64e <test_kshrink>
	return 0;
f0110452:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110457:	c9                   	leave  
f0110458:	c3                   	ret    

f0110459 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f0110459:	55                   	push   %ebp
f011045a:	89 e5                	mov    %esp,%ebp
f011045c:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f011045f:	e8 07 d2 00 00       	call   f011d66b <test_kfreelast>
	return 0;
f0110464:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110469:	c9                   	leave  
f011046a:	c3                   	ret    

f011046b <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f011046b:	55                   	push   %ebp
f011046c:	89 e5                	mov    %esp,%ebp
f011046e:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f0110471:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110474:	83 c0 04             	add    $0x4,%eax
f0110477:	8b 00                	mov    (%eax),%eax
f0110479:	83 ec 04             	sub    $0x4,%esp
f011047c:	6a 0a                	push   $0xa
f011047e:	6a 00                	push   $0x0
f0110480:	50                   	push   %eax
f0110481:	e8 b0 fb 00 00       	call   f0120036 <strtol>
f0110486:	83 c4 10             	add    $0x10,%esp
f0110489:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f011048c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f0110493:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f011049a:	83 ec 0c             	sub    $0xc,%esp
f011049d:	68 e0 15 6c f0       	push   $0xf06c15e0
f01104a2:	e8 81 f8 ff ff       	call   f010fd28 <acquire_spinlock>
f01104a7:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f01104aa:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f01104af:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01104b2:	eb 3b                	jmp    f01104ef <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f01104b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01104b7:	83 c0 20             	add    $0x20,%eax
f01104ba:	83 ec 08             	sub    $0x8,%esp
f01104bd:	68 6f 80 12 f0       	push   $0xf012806f
f01104c2:	50                   	push   %eax
f01104c3:	e8 1a f9 00 00       	call   f011fde2 <strcmp>
f01104c8:	83 c4 10             	add    $0x10,%esp
f01104cb:	85 c0                	test   %eax,%eax
f01104cd:	75 12                	jne    f01104e1 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f01104cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01104d3:	74 07                	je     f01104dc <tst_sc_MLFQ+0x71>
					firstTime = 0;
f01104d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f01104dc:	ff 45 f4             	incl   -0xc(%ebp)
f01104df:	eb 06                	jmp    f01104e7 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f01104e1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01104e5:	74 31                	je     f0110518 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f01104e7:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f01104ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01104ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01104f3:	74 08                	je     f01104fd <tst_sc_MLFQ+0x92>
f01104f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01104f8:	8b 40 08             	mov    0x8(%eax),%eax
f01104fb:	eb 05                	jmp    f0110502 <tst_sc_MLFQ+0x97>
f01104fd:	b8 00 00 00 00       	mov    $0x0,%eax
f0110502:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f0110507:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011050c:	85 c0                	test   %eax,%eax
f011050e:	75 a4                	jne    f01104b4 <tst_sc_MLFQ+0x49>
f0110510:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110514:	75 9e                	jne    f01104b4 <tst_sc_MLFQ+0x49>
f0110516:	eb 01                	jmp    f0110519 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f0110518:	90                   	nop
			}
		if(cnt == numOfSlave2)
f0110519:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011051c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011051f:	75 12                	jne    f0110533 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0110521:	83 ec 0c             	sub    $0xc,%esp
f0110524:	68 78 80 12 f0       	push   $0xf0128078
f0110529:	e8 5d 0a ff ff       	call   f0100f8b <cprintf>
f011052e:	83 c4 10             	add    $0x10,%esp
f0110531:	eb 17                	jmp    f011054a <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f0110533:	83 ec 04             	sub    $0x4,%esp
f0110536:	68 b1 80 12 f0       	push   $0xf01280b1
f011053b:	68 9b 00 00 00       	push   $0x9b
f0110540:	68 c7 80 12 f0       	push   $0xf01280c7
f0110545:	e8 ef fd fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011054a:	83 ec 0c             	sub    $0xc,%esp
f011054d:	68 e0 15 6c f0       	push   $0xf06c15e0
f0110552:	e8 58 f8 ff ff       	call   f010fdaf <release_spinlock>
f0110557:	83 c4 10             	add    $0x10,%esp
	return 0;
f011055a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011055f:	c9                   	leave  
f0110560:	c3                   	ret    

f0110561 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f0110561:	55                   	push   %ebp
f0110562:	89 e5                	mov    %esp,%ebp
f0110564:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0110567:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011056b:	74 17                	je     f0110584 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f011056d:	83 ec 0c             	sub    $0xc,%esp
f0110570:	68 e0 80 12 f0       	push   $0xf01280e0
f0110575:	e8 11 0a ff ff       	call   f0100f8b <cprintf>
f011057a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011057d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110582:	eb 45                	jmp    f01105c9 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0110584:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110587:	83 c0 04             	add    $0x4,%eax
f011058a:	8b 00                	mov    (%eax),%eax
f011058c:	83 ec 04             	sub    $0x4,%esp
f011058f:	6a 0a                	push   $0xa
f0110591:	6a 00                	push   $0x0
f0110593:	50                   	push   %eax
f0110594:	e8 9d fa 00 00       	call   f0120036 <strtol>
f0110599:	83 c4 10             	add    $0x10,%esp
f011059c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f011059f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105a2:	83 f8 01             	cmp    $0x1,%eax
f01105a5:	74 10                	je     f01105b7 <tst_bsd_nice+0x56>
f01105a7:	83 f8 02             	cmp    $0x2,%eax
f01105aa:	74 12                	je     f01105be <tst_bsd_nice+0x5d>
f01105ac:	85 c0                	test   %eax,%eax
f01105ae:	75 14                	jne    f01105c4 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f01105b0:	e8 b9 d2 00 00       	call   f011d86e <test_bsd_nice_0>
		break;
f01105b5:	eb 0d                	jmp    f01105c4 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f01105b7:	e8 3c d5 00 00       	call   f011daf8 <test_bsd_nice_1>
		break;
f01105bc:	eb 06                	jmp    f01105c4 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f01105be:	e8 49 d7 00 00       	call   f011dd0c <test_bsd_nice_2>
		break;
f01105c3:	90                   	nop
	}
	return 0;
f01105c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105c9:	c9                   	leave  
f01105ca:	c3                   	ret    

f01105cb <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f01105cb:	55                   	push   %ebp
f01105cc:	89 e5                	mov    %esp,%ebp
f01105ce:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f01105d1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01105d5:	74 17                	je     f01105ee <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f01105d7:	83 ec 0c             	sub    $0xc,%esp
f01105da:	68 20 81 12 f0       	push   $0xf0128120
f01105df:	e8 a7 09 ff ff       	call   f0100f8b <cprintf>
f01105e4:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105e7:	b8 00 00 00 00       	mov    $0x0,%eax
f01105ec:	eb 0a                	jmp    f01105f8 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f01105ee:	e8 3f 15 00 00       	call   f0111b32 <test_str2lower_function>
	return 0;
f01105f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105f8:	c9                   	leave  
f01105f9:	c3                   	ret    

f01105fa <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01105fa:	55                   	push   %ebp
f01105fb:	89 e5                	mov    %esp,%ebp
f01105fd:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f0110600:	e8 63 11 00 00       	call   f0111768 <TestAutoCompleteCommand>
f0110605:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f0110608:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011060d:	c9                   	leave  
f011060e:	c3                   	ret    

f011060f <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f011060f:	55                   	push   %ebp
f0110610:	89 e5                	mov    %esp,%ebp
f0110612:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110615:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110619:	74 1a                	je     f0110635 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f011061b:	83 ec 0c             	sub    $0xc,%esp
f011061e:	68 54 81 12 f0       	push   $0xf0128154
f0110623:	e8 63 09 ff ff       	call   f0100f8b <cprintf>
f0110628:	83 c4 10             	add    $0x10,%esp
		return 0;
f011062b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110630:	e9 2f 01 00 00       	jmp    f0110764 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f0110635:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110638:	83 c0 04             	add    $0x4,%eax
f011063b:	8b 00                	mov    (%eax),%eax
f011063d:	83 ec 08             	sub    $0x8,%esp
f0110640:	68 91 81 12 f0       	push   $0xf0128191
f0110645:	50                   	push   %eax
f0110646:	e8 97 f7 00 00       	call   f011fde2 <strcmp>
f011064b:	83 c4 10             	add    $0x10,%esp
f011064e:	85 c0                	test   %eax,%eax
f0110650:	75 0a                	jne    f011065c <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f0110652:	e8 40 08 00 00       	call   f0110e97 <test_initialize_dynamic_allocator>
f0110657:	e9 03 01 00 00       	jmp    f011075f <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f011065c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011065f:	83 c0 04             	add    $0x4,%eax
f0110662:	8b 00                	mov    (%eax),%eax
f0110664:	83 ec 08             	sub    $0x8,%esp
f0110667:	68 96 81 12 f0       	push   $0xf0128196
f011066c:	50                   	push   %eax
f011066d:	e8 70 f7 00 00       	call   f011fde2 <strcmp>
f0110672:	83 c4 10             	add    $0x10,%esp
f0110675:	85 c0                	test   %eax,%eax
f0110677:	75 0a                	jne    f0110683 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f0110679:	e8 4d 08 00 00       	call   f0110ecb <test_alloc_block_FF>
f011067e:	e9 dc 00 00 00       	jmp    f011075f <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f0110683:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110686:	83 c0 04             	add    $0x4,%eax
f0110689:	8b 00                	mov    (%eax),%eax
f011068b:	83 ec 08             	sub    $0x8,%esp
f011068e:	68 9e 81 12 f0       	push   $0xf012819e
f0110693:	50                   	push   %eax
f0110694:	e8 49 f7 00 00       	call   f011fde2 <strcmp>
f0110699:	83 c4 10             	add    $0x10,%esp
f011069c:	85 c0                	test   %eax,%eax
f011069e:	75 0a                	jne    f01106aa <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f01106a0:	e8 43 08 00 00       	call   f0110ee8 <test_alloc_block_BF>
f01106a5:	e9 b5 00 00 00       	jmp    f011075f <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f01106aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106ad:	83 c0 04             	add    $0x4,%eax
f01106b0:	8b 00                	mov    (%eax),%eax
f01106b2:	83 ec 08             	sub    $0x8,%esp
f01106b5:	68 a6 81 12 f0       	push   $0xf01281a6
f01106ba:	50                   	push   %eax
f01106bb:	e8 22 f7 00 00       	call   f011fde2 <strcmp>
f01106c0:	83 c4 10             	add    $0x10,%esp
f01106c3:	85 c0                	test   %eax,%eax
f01106c5:	75 0a                	jne    f01106d1 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f01106c7:	e8 3c 08 00 00       	call   f0110f08 <test_alloc_block_NF>
f01106cc:	e9 8e 00 00 00       	jmp    f011075f <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f01106d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106d4:	83 c0 04             	add    $0x4,%eax
f01106d7:	8b 00                	mov    (%eax),%eax
f01106d9:	83 ec 08             	sub    $0x8,%esp
f01106dc:	68 ae 81 12 f0       	push   $0xf01281ae
f01106e1:	50                   	push   %eax
f01106e2:	e8 fb f6 00 00       	call   f011fde2 <strcmp>
f01106e7:	83 c4 10             	add    $0x10,%esp
f01106ea:	85 c0                	test   %eax,%eax
f01106ec:	75 07                	jne    f01106f5 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f01106ee:	e8 1b 08 00 00       	call   f0110f0e <test_free_block_FF>
f01106f3:	eb 6a                	jmp    f011075f <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f01106f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106f8:	83 c0 04             	add    $0x4,%eax
f01106fb:	8b 00                	mov    (%eax),%eax
f01106fd:	83 ec 08             	sub    $0x8,%esp
f0110700:	68 b5 81 12 f0       	push   $0xf01281b5
f0110705:	50                   	push   %eax
f0110706:	e8 d7 f6 00 00       	call   f011fde2 <strcmp>
f011070b:	83 c4 10             	add    $0x10,%esp
f011070e:	85 c0                	test   %eax,%eax
f0110710:	75 07                	jne    f0110719 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f0110712:	e8 14 08 00 00       	call   f0110f2b <test_free_block_BF>
f0110717:	eb 46                	jmp    f011075f <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f0110719:	8b 45 0c             	mov    0xc(%ebp),%eax
f011071c:	83 c0 04             	add    $0x4,%eax
f011071f:	8b 00                	mov    (%eax),%eax
f0110721:	83 ec 08             	sub    $0x8,%esp
f0110724:	68 bc 81 12 f0       	push   $0xf01281bc
f0110729:	50                   	push   %eax
f011072a:	e8 b3 f6 00 00       	call   f011fde2 <strcmp>
f011072f:	83 c4 10             	add    $0x10,%esp
f0110732:	85 c0                	test   %eax,%eax
f0110734:	75 07                	jne    f011073d <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f0110736:	e8 0d 08 00 00       	call   f0110f48 <test_free_block_NF>
f011073b:	eb 22                	jmp    f011075f <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f011073d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110740:	83 c0 04             	add    $0x4,%eax
f0110743:	8b 00                	mov    (%eax),%eax
f0110745:	83 ec 08             	sub    $0x8,%esp
f0110748:	68 c3 81 12 f0       	push   $0xf01281c3
f011074d:	50                   	push   %eax
f011074e:	e8 8f f6 00 00       	call   f011fde2 <strcmp>
f0110753:	83 c4 10             	add    $0x10,%esp
f0110756:	85 c0                	test   %eax,%eax
f0110758:	75 05                	jne    f011075f <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f011075a:	e8 06 08 00 00       	call   f0110f65 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f011075f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110764:	c9                   	leave  
f0110765:	c3                   	ret    

f0110766 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f0110766:	55                   	push   %ebp
f0110767:	89 e5                	mov    %esp,%ebp
f0110769:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011076c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110770:	74 1a                	je     f011078c <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f0110772:	83 ec 0c             	sub    $0xc,%esp
f0110775:	68 d0 81 12 f0       	push   $0xf01281d0
f011077a:	e8 0c 08 ff ff       	call   f0100f8b <cprintf>
f011077f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110782:	b8 00 00 00 00       	mov    $0x0,%eax
f0110787:	e9 e1 00 00 00       	jmp    f011086d <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f011078c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011078f:	83 c0 04             	add    $0x4,%eax
f0110792:	8b 00                	mov    (%eax),%eax
f0110794:	83 ec 08             	sub    $0x8,%esp
f0110797:	68 09 82 12 f0       	push   $0xf0128209
f011079c:	50                   	push   %eax
f011079d:	e8 40 f6 00 00       	call   f011fde2 <strcmp>
f01107a2:	83 c4 10             	add    $0x10,%esp
f01107a5:	85 c0                	test   %eax,%eax
f01107a7:	75 0a                	jne    f01107b3 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f01107a9:	e8 97 1c 00 00       	call   f0112445 <test_cut_paste_pages>
f01107ae:	e9 b5 00 00 00       	jmp    f0110868 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01107b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107b6:	83 c0 04             	add    $0x4,%eax
f01107b9:	8b 00                	mov    (%eax),%eax
f01107bb:	83 ec 08             	sub    $0x8,%esp
f01107be:	68 12 82 12 f0       	push   $0xf0128212
f01107c3:	50                   	push   %eax
f01107c4:	e8 19 f6 00 00       	call   f011fde2 <strcmp>
f01107c9:	83 c4 10             	add    $0x10,%esp
f01107cc:	85 c0                	test   %eax,%eax
f01107ce:	75 0a                	jne    f01107da <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01107d0:	e8 bb 26 00 00       	call   f0112e90 <test_copy_paste_chunk>
f01107d5:	e9 8e 00 00 00       	jmp    f0110868 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01107da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107dd:	83 c0 04             	add    $0x4,%eax
f01107e0:	8b 00                	mov    (%eax),%eax
f01107e2:	83 ec 08             	sub    $0x8,%esp
f01107e5:	68 1c 82 12 f0       	push   $0xf012821c
f01107ea:	50                   	push   %eax
f01107eb:	e8 f2 f5 00 00       	call   f011fde2 <strcmp>
f01107f0:	83 c4 10             	add    $0x10,%esp
f01107f3:	85 c0                	test   %eax,%eax
f01107f5:	75 07                	jne    f01107fe <tst_chunks+0x98>
	{
		test_share_chunk();
f01107f7:	e8 92 37 00 00       	call   f0113f8e <test_share_chunk>
f01107fc:	eb 6a                	jmp    f0110868 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f01107fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110801:	83 c0 04             	add    $0x4,%eax
f0110804:	8b 00                	mov    (%eax),%eax
f0110806:	83 ec 08             	sub    $0x8,%esp
f0110809:	68 22 82 12 f0       	push   $0xf0128222
f011080e:	50                   	push   %eax
f011080f:	e8 ce f5 00 00       	call   f011fde2 <strcmp>
f0110814:	83 c4 10             	add    $0x10,%esp
f0110817:	85 c0                	test   %eax,%eax
f0110819:	75 07                	jne    f0110822 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f011081b:	e8 96 41 00 00       	call   f01149b6 <test_allocate_chunk>
f0110820:	eb 46                	jmp    f0110868 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110822:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110825:	83 c0 04             	add    $0x4,%eax
f0110828:	8b 00                	mov    (%eax),%eax
f011082a:	83 ec 08             	sub    $0x8,%esp
f011082d:	68 2b 82 12 f0       	push   $0xf012822b
f0110832:	50                   	push   %eax
f0110833:	e8 aa f5 00 00       	call   f011fde2 <strcmp>
f0110838:	83 c4 10             	add    $0x10,%esp
f011083b:	85 c0                	test   %eax,%eax
f011083d:	75 07                	jne    f0110846 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f011083f:	e8 79 4a 00 00       	call   f01152bd <test_calculate_required_frames>
f0110844:	eb 22                	jmp    f0110868 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110846:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110849:	83 c0 04             	add    $0x4,%eax
f011084c:	8b 00                	mov    (%eax),%eax
f011084e:	83 ec 08             	sub    $0x8,%esp
f0110851:	68 3a 82 12 f0       	push   $0xf012823a
f0110856:	50                   	push   %eax
f0110857:	e8 86 f5 00 00       	call   f011fde2 <strcmp>
f011085c:	83 c4 10             	add    $0x10,%esp
f011085f:	85 c0                	test   %eax,%eax
f0110861:	75 05                	jne    f0110868 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110863:	e8 c9 52 00 00       	call   f0115b31 <test_calculate_allocated_space>
	}
	return 0;
f0110868:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011086d:	c9                   	leave  
f011086e:	c3                   	ret    

f011086f <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f011086f:	55                   	push   %ebp
f0110870:	89 e5                	mov    %esp,%ebp
f0110872:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110875:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110879:	74 1a                	je     f0110895 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f011087b:	83 ec 0c             	sub    $0xc,%esp
f011087e:	68 4c 82 12 f0       	push   $0xf012824c
f0110883:	e8 03 07 ff ff       	call   f0100f8b <cprintf>
f0110888:	83 c4 10             	add    $0x10,%esp
		return 0;
f011088b:	b8 00 00 00 00       	mov    $0x0,%eax
f0110890:	e9 ba 00 00 00       	jmp    f011094f <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110895:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110898:	83 c0 04             	add    $0x4,%eax
f011089b:	8b 00                	mov    (%eax),%eax
f011089d:	83 ec 08             	sub    $0x8,%esp
f01108a0:	68 82 82 12 f0       	push   $0xf0128282
f01108a5:	50                   	push   %eax
f01108a6:	e8 37 f5 00 00       	call   f011fde2 <strcmp>
f01108ab:	83 c4 10             	add    $0x10,%esp
f01108ae:	85 c0                	test   %eax,%eax
f01108b0:	75 0a                	jne    f01108bc <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01108b2:	e8 01 16 00 00       	call   f0111eb8 <test_pt_set_page_permissions>
f01108b7:	e9 8e 00 00 00       	jmp    f011094a <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01108bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108bf:	83 c0 04             	add    $0x4,%eax
f01108c2:	8b 00                	mov    (%eax),%eax
f01108c4:	83 ec 08             	sub    $0x8,%esp
f01108c7:	68 8a 82 12 f0       	push   $0xf012828a
f01108cc:	50                   	push   %eax
f01108cd:	e8 10 f5 00 00       	call   f011fde2 <strcmp>
f01108d2:	83 c4 10             	add    $0x10,%esp
f01108d5:	85 c0                	test   %eax,%eax
f01108d7:	75 07                	jne    f01108e0 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f01108d9:	e8 49 18 00 00       	call   f0112127 <test_pt_set_page_permissions_invalid_va>
f01108de:	eb 6a                	jmp    f011094a <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f01108e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108e3:	83 c0 04             	add    $0x4,%eax
f01108e6:	8b 00                	mov    (%eax),%eax
f01108e8:	83 ec 08             	sub    $0x8,%esp
f01108eb:	68 92 82 12 f0       	push   $0xf0128292
f01108f0:	50                   	push   %eax
f01108f1:	e8 ec f4 00 00       	call   f011fde2 <strcmp>
f01108f6:	83 c4 10             	add    $0x10,%esp
f01108f9:	85 c0                	test   %eax,%eax
f01108fb:	75 07                	jne    f0110904 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f01108fd:	e8 6e 18 00 00       	call   f0112170 <test_pt_get_page_permissions>
f0110902:	eb 46                	jmp    f011094a <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f0110904:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110907:	83 c0 04             	add    $0x4,%eax
f011090a:	8b 00                	mov    (%eax),%eax
f011090c:	83 ec 08             	sub    $0x8,%esp
f011090f:	68 9a 82 12 f0       	push   $0xf012829a
f0110914:	50                   	push   %eax
f0110915:	e8 c8 f4 00 00       	call   f011fde2 <strcmp>
f011091a:	83 c4 10             	add    $0x10,%esp
f011091d:	85 c0                	test   %eax,%eax
f011091f:	75 07                	jne    f0110928 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f0110921:	e8 8e 19 00 00       	call   f01122b4 <test_pt_clear_page_table_entry>
f0110926:	eb 22                	jmp    f011094a <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110928:	8b 45 0c             	mov    0xc(%ebp),%eax
f011092b:	83 c0 04             	add    $0x4,%eax
f011092e:	8b 00                	mov    (%eax),%eax
f0110930:	83 ec 08             	sub    $0x8,%esp
f0110933:	68 a1 82 12 f0       	push   $0xf01282a1
f0110938:	50                   	push   %eax
f0110939:	e8 a4 f4 00 00       	call   f011fde2 <strcmp>
f011093e:	83 c4 10             	add    $0x10,%esp
f0110941:	85 c0                	test   %eax,%eax
f0110943:	75 05                	jne    f011094a <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110945:	e8 c3 1a 00 00       	call   f011240d <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f011094a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011094f:	c9                   	leave  
f0110950:	c3                   	ret    

f0110951 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f0110951:	55                   	push   %ebp
f0110952:	89 e5                	mov    %esp,%ebp
f0110954:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110957:	8b 45 0c             	mov    0xc(%ebp),%eax
f011095a:	83 c0 08             	add    $0x8,%eax
f011095d:	8b 00                	mov    (%eax),%eax
f011095f:	83 ec 08             	sub    $0x8,%esp
f0110962:	68 a8 82 12 f0       	push   $0xf01282a8
f0110967:	50                   	push   %eax
f0110968:	e8 75 f4 00 00       	call   f011fde2 <strcmp>
f011096d:	83 c4 10             	add    $0x10,%esp
f0110970:	85 c0                	test   %eax,%eax
f0110972:	75 20                	jne    f0110994 <tst_kheap+0x43>
f0110974:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110978:	74 1a                	je     f0110994 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f011097a:	83 ec 0c             	sub    $0xc,%esp
f011097d:	68 b0 82 12 f0       	push   $0xf01282b0
f0110982:	e8 04 06 ff ff       	call   f0100f8b <cprintf>
f0110987:	83 c4 10             	add    $0x10,%esp
		return 0;
f011098a:	b8 00 00 00 00       	mov    $0x0,%eax
f011098f:	e9 42 04 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110994:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110997:	83 c0 08             	add    $0x8,%eax
f011099a:	8b 00                	mov    (%eax),%eax
f011099c:	83 ec 08             	sub    $0x8,%esp
f011099f:	68 a8 82 12 f0       	push   $0xf01282a8
f01109a4:	50                   	push   %eax
f01109a5:	e8 38 f4 00 00       	call   f011fde2 <strcmp>
f01109aa:	83 c4 10             	add    $0x10,%esp
f01109ad:	85 c0                	test   %eax,%eax
f01109af:	74 43                	je     f01109f4 <tst_kheap+0xa3>
f01109b1:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01109b5:	74 3d                	je     f01109f4 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f01109b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109ba:	83 c0 08             	add    $0x8,%eax
f01109bd:	8b 00                	mov    (%eax),%eax
f01109bf:	83 ec 08             	sub    $0x8,%esp
f01109c2:	68 00 83 12 f0       	push   $0xf0128300
f01109c7:	50                   	push   %eax
f01109c8:	e8 15 f4 00 00       	call   f011fde2 <strcmp>
f01109cd:	83 c4 10             	add    $0x10,%esp
f01109d0:	85 c0                	test   %eax,%eax
f01109d2:	74 20                	je     f01109f4 <tst_kheap+0xa3>
f01109d4:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f01109d8:	74 1a                	je     f01109f4 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f01109da:	83 ec 0c             	sub    $0xc,%esp
f01109dd:	68 0c 83 12 f0       	push   $0xf012830c
f01109e2:	e8 a4 05 ff ff       	call   f0100f8b <cprintf>
f01109e7:	83 c4 10             	add    $0x10,%esp
			return 0;
f01109ea:	b8 00 00 00 00       	mov    $0x0,%eax
f01109ef:	e9 e2 03 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f01109f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109f7:	83 c0 04             	add    $0x4,%eax
f01109fa:	8b 00                	mov    (%eax),%eax
f01109fc:	83 ec 08             	sub    $0x8,%esp
f01109ff:	68 51 83 12 f0       	push   $0xf0128351
f0110a04:	50                   	push   %eax
f0110a05:	e8 d8 f3 00 00       	call   f011fde2 <strcmp>
f0110a0a:	83 c4 10             	add    $0x10,%esp
f0110a0d:	85 c0                	test   %eax,%eax
f0110a0f:	74 1d                	je     f0110a2e <tst_kheap+0xdd>
f0110a11:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a14:	83 c0 04             	add    $0x4,%eax
f0110a17:	8b 00                	mov    (%eax),%eax
f0110a19:	83 ec 08             	sub    $0x8,%esp
f0110a1c:	68 54 83 12 f0       	push   $0xf0128354
f0110a21:	50                   	push   %eax
f0110a22:	e8 bb f3 00 00       	call   f011fde2 <strcmp>
f0110a27:	83 c4 10             	add    $0x10,%esp
f0110a2a:	85 c0                	test   %eax,%eax
f0110a2c:	75 1a                	jne    f0110a48 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f0110a2e:	e8 6d f8 ff ff       	call   f01102a0 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110a33:	83 ec 0c             	sub    $0xc,%esp
f0110a36:	68 58 83 12 f0       	push   $0xf0128358
f0110a3b:	e8 4b 05 ff ff       	call   f0100f8b <cprintf>
f0110a40:	83 c4 10             	add    $0x10,%esp
f0110a43:	e9 a0 00 00 00       	jmp    f0110ae8 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110a48:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a4b:	83 c0 04             	add    $0x4,%eax
f0110a4e:	8b 00                	mov    (%eax),%eax
f0110a50:	83 ec 08             	sub    $0x8,%esp
f0110a53:	68 85 83 12 f0       	push   $0xf0128385
f0110a58:	50                   	push   %eax
f0110a59:	e8 84 f3 00 00       	call   f011fde2 <strcmp>
f0110a5e:	83 c4 10             	add    $0x10,%esp
f0110a61:	85 c0                	test   %eax,%eax
f0110a63:	74 1d                	je     f0110a82 <tst_kheap+0x131>
f0110a65:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a68:	83 c0 04             	add    $0x4,%eax
f0110a6b:	8b 00                	mov    (%eax),%eax
f0110a6d:	83 ec 08             	sub    $0x8,%esp
f0110a70:	68 88 83 12 f0       	push   $0xf0128388
f0110a75:	50                   	push   %eax
f0110a76:	e8 67 f3 00 00       	call   f011fde2 <strcmp>
f0110a7b:	83 c4 10             	add    $0x10,%esp
f0110a7e:	85 c0                	test   %eax,%eax
f0110a80:	75 17                	jne    f0110a99 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110a82:	e8 29 f8 ff ff       	call   f01102b0 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110a87:	83 ec 0c             	sub    $0xc,%esp
f0110a8a:	68 8c 83 12 f0       	push   $0xf012838c
f0110a8f:	e8 f7 04 ff ff       	call   f0100f8b <cprintf>
f0110a94:	83 c4 10             	add    $0x10,%esp
f0110a97:	eb 4f                	jmp    f0110ae8 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110a99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a9c:	83 c0 04             	add    $0x4,%eax
f0110a9f:	8b 00                	mov    (%eax),%eax
f0110aa1:	83 ec 08             	sub    $0x8,%esp
f0110aa4:	68 b8 83 12 f0       	push   $0xf01283b8
f0110aa9:	50                   	push   %eax
f0110aaa:	e8 33 f3 00 00       	call   f011fde2 <strcmp>
f0110aaf:	83 c4 10             	add    $0x10,%esp
f0110ab2:	85 c0                	test   %eax,%eax
f0110ab4:	74 1d                	je     f0110ad3 <tst_kheap+0x182>
f0110ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ab9:	83 c0 04             	add    $0x4,%eax
f0110abc:	8b 00                	mov    (%eax),%eax
f0110abe:	83 ec 08             	sub    $0x8,%esp
f0110ac1:	68 bb 83 12 f0       	push   $0xf01283bb
f0110ac6:	50                   	push   %eax
f0110ac7:	e8 16 f3 00 00       	call   f011fde2 <strcmp>
f0110acc:	83 c4 10             	add    $0x10,%esp
f0110acf:	85 c0                	test   %eax,%eax
f0110ad1:	75 15                	jne    f0110ae8 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f0110ad3:	e8 e8 f7 ff ff       	call   f01102c0 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110ad8:	83 ec 0c             	sub    $0xc,%esp
f0110adb:	68 c0 83 12 f0       	push   $0xf01283c0
f0110ae0:	e8 a6 04 ff ff       	call   f0100f8b <cprintf>
f0110ae5:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110ae8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110aeb:	83 c0 08             	add    $0x8,%eax
f0110aee:	8b 00                	mov    (%eax),%eax
f0110af0:	83 ec 08             	sub    $0x8,%esp
f0110af3:	68 a8 82 12 f0       	push   $0xf01282a8
f0110af8:	50                   	push   %eax
f0110af9:	e8 e4 f2 00 00       	call   f011fde2 <strcmp>
f0110afe:	83 c4 10             	add    $0x10,%esp
f0110b01:	85 c0                	test   %eax,%eax
f0110b03:	0f 85 13 01 00 00    	jne    f0110c1c <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110b09:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b0c:	83 c0 0c             	add    $0xc,%eax
f0110b0f:	8b 00                	mov    (%eax),%eax
f0110b11:	83 ec 04             	sub    $0x4,%esp
f0110b14:	6a 0a                	push   $0xa
f0110b16:	6a 00                	push   $0x0
f0110b18:	50                   	push   %eax
f0110b19:	e8 18 f5 00 00       	call   f0120036 <strtol>
f0110b1e:	83 c4 10             	add    $0x10,%esp
f0110b21:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110b24:	e8 a7 f7 ff ff       	call   f01102d0 <isKHeapPlacementStrategyFIRSTFIT>
f0110b29:	84 c0                	test   %al,%al
f0110b2b:	74 54                	je     f0110b81 <tst_kheap+0x230>
		{
			if (testNum == 0)
f0110b2d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b31:	75 1a                	jne    f0110b4d <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110b33:	83 ec 0c             	sub    $0xc,%esp
f0110b36:	68 ec 83 12 f0       	push   $0xf01283ec
f0110b3b:	e8 4b 04 ff ff       	call   f0100f8b <cprintf>
f0110b40:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110b43:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b48:	e9 89 02 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f0110b4d:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110b51:	75 0a                	jne    f0110b5d <tst_kheap+0x20c>
				test_kmalloc();
f0110b53:	e8 ec 61 00 00       	call   f0116d44 <test_kmalloc>
f0110b58:	e9 b5 00 00 00       	jmp    f0110c12 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110b5d:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110b61:	75 0a                	jne    f0110b6d <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110b63:	e8 68 6d 00 00       	call   f01178d0 <test_kmalloc_firstfit1>
f0110b68:	e9 a5 00 00 00       	jmp    f0110c12 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110b6d:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110b71:	0f 85 9b 00 00 00    	jne    f0110c12 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110b77:	e8 38 78 00 00       	call   f01183b4 <test_kmalloc_firstfit2>
f0110b7c:	e9 91 00 00 00       	jmp    f0110c12 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f0110b81:	e8 5f f7 ff ff       	call   f01102e5 <isKHeapPlacementStrategyBESTFIT>
f0110b86:	84 c0                	test   %al,%al
f0110b88:	74 47                	je     f0110bd1 <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110b8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b8e:	75 1a                	jne    f0110baa <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f0110b90:	83 ec 0c             	sub    $0xc,%esp
f0110b93:	68 3c 84 12 f0       	push   $0xf012843c
f0110b98:	e8 ee 03 ff ff       	call   f0100f8b <cprintf>
f0110b9d:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110ba0:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ba5:	e9 2c 02 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110baa:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110bae:	75 07                	jne    f0110bb7 <tst_kheap+0x266>
				test_kmalloc();
f0110bb0:	e8 8f 61 00 00       	call   f0116d44 <test_kmalloc>
f0110bb5:	eb 5b                	jmp    f0110c12 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0110bb7:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110bbb:	75 07                	jne    f0110bc4 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f0110bbd:	e8 2b c8 00 00       	call   f011d3ed <test_kmalloc_bestfit1>
f0110bc2:	eb 4e                	jmp    f0110c12 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0110bc4:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0110bc8:	75 48                	jne    f0110c12 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0110bca:	e8 3b c8 00 00       	call   f011d40a <test_kmalloc_bestfit2>
f0110bcf:	eb 41                	jmp    f0110c12 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f0110bd1:	e8 24 f7 ff ff       	call   f01102fa <isKHeapPlacementStrategyNEXTFIT>
f0110bd6:	84 c0                	test   %al,%al
f0110bd8:	74 38                	je     f0110c12 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f0110bda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110bde:	75 1a                	jne    f0110bfa <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f0110be0:	83 ec 0c             	sub    $0xc,%esp
f0110be3:	68 8c 84 12 f0       	push   $0xf012848c
f0110be8:	e8 9e 03 ff ff       	call   f0100f8b <cprintf>
f0110bed:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110bf0:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bf5:	e9 dc 01 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f0110bfa:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0110bfe:	75 07                	jne    f0110c07 <tst_kheap+0x2b6>
				test_kmalloc();
f0110c00:	e8 3f 61 00 00       	call   f0116d44 <test_kmalloc>
f0110c05:	eb 0b                	jmp    f0110c12 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f0110c07:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0110c0b:	75 05                	jne    f0110c12 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f0110c0d:	e8 be c7 00 00       	call   f011d3d0 <test_kmalloc_nextfit>
		}
		return 0;
f0110c12:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c17:	e9 ba 01 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f0110c1c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c1f:	83 c0 08             	add    $0x8,%eax
f0110c22:	8b 00                	mov    (%eax),%eax
f0110c24:	83 ec 08             	sub    $0x8,%esp
f0110c27:	68 da 84 12 f0       	push   $0xf01284da
f0110c2c:	50                   	push   %eax
f0110c2d:	e8 b0 f1 00 00       	call   f011fde2 <strcmp>
f0110c32:	83 c4 10             	add    $0x10,%esp
f0110c35:	85 c0                	test   %eax,%eax
f0110c37:	75 2f                	jne    f0110c68 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110c39:	e8 92 f6 ff ff       	call   f01102d0 <isKHeapPlacementStrategyFIRSTFIT>
f0110c3e:	84 c0                	test   %al,%al
f0110c40:	74 0f                	je     f0110c51 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110c42:	e8 74 82 00 00       	call   f0118ebb <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0110c4c:	e9 85 01 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f0110c51:	83 ec 04             	sub    $0x4,%esp
f0110c54:	68 e0 84 12 f0       	push   $0xf01284e0
f0110c59:	68 ac 01 00 00       	push   $0x1ac
f0110c5e:	68 c7 80 12 f0       	push   $0xf01280c7
f0110c63:	e8 d1 f6 fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110c68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c6b:	83 c0 08             	add    $0x8,%eax
f0110c6e:	8b 00                	mov    (%eax),%eax
f0110c70:	83 ec 08             	sub    $0x8,%esp
f0110c73:	68 21 85 12 f0       	push   $0xf0128521
f0110c78:	50                   	push   %eax
f0110c79:	e8 64 f1 00 00       	call   f011fde2 <strcmp>
f0110c7e:	83 c4 10             	add    $0x10,%esp
f0110c81:	85 c0                	test   %eax,%eax
f0110c83:	75 28                	jne    f0110cad <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110c85:	e8 5b f6 ff ff       	call   f01102e5 <isKHeapPlacementStrategyBESTFIT>
f0110c8a:	84 c0                	test   %al,%al
f0110c8c:	75 09                	jne    f0110c97 <tst_kheap+0x346>
f0110c8e:	e8 3d f6 ff ff       	call   f01102d0 <isKHeapPlacementStrategyFIRSTFIT>
f0110c93:	84 c0                	test   %al,%al
f0110c95:	74 07                	je     f0110c9e <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110c97:	e8 ee 8a 00 00       	call   f011978a <test_kfree_bestfirstfit>
f0110c9c:	eb 05                	jmp    f0110ca3 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f0110c9e:	e8 a1 c7 00 00       	call   f011d444 <test_kfree>
		}
		return 0;
f0110ca3:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ca8:	e9 29 01 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110cad:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cb0:	83 c0 08             	add    $0x8,%eax
f0110cb3:	8b 00                	mov    (%eax),%eax
f0110cb5:	83 ec 08             	sub    $0x8,%esp
f0110cb8:	68 27 85 12 f0       	push   $0xf0128527
f0110cbd:	50                   	push   %eax
f0110cbe:	e8 1f f1 00 00       	call   f011fde2 <strcmp>
f0110cc3:	83 c4 10             	add    $0x10,%esp
f0110cc6:	85 c0                	test   %eax,%eax
f0110cc8:	75 0f                	jne    f0110cd9 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0110cca:	e8 17 a1 00 00       	call   f011ade6 <test_kheap_phys_addr>
		return 0;
f0110ccf:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cd4:	e9 fd 00 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110cd9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cdc:	83 c0 08             	add    $0x8,%eax
f0110cdf:	8b 00                	mov    (%eax),%eax
f0110ce1:	83 ec 08             	sub    $0x8,%esp
f0110ce4:	68 31 85 12 f0       	push   $0xf0128531
f0110ce9:	50                   	push   %eax
f0110cea:	e8 f3 f0 00 00       	call   f011fde2 <strcmp>
f0110cef:	83 c4 10             	add    $0x10,%esp
f0110cf2:	85 c0                	test   %eax,%eax
f0110cf4:	75 0f                	jne    f0110d05 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f0110cf6:	e8 ce ae 00 00       	call   f011bbc9 <test_kheap_virt_addr>
		return 0;
f0110cfb:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d00:	e9 d1 00 00 00       	jmp    f0110dd6 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110d05:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d08:	83 c0 08             	add    $0x8,%eax
f0110d0b:	8b 00                	mov    (%eax),%eax
f0110d0d:	83 ec 08             	sub    $0x8,%esp
f0110d10:	68 00 83 12 f0       	push   $0xf0128300
f0110d15:	50                   	push   %eax
f0110d16:	e8 c7 f0 00 00       	call   f011fde2 <strcmp>
f0110d1b:	83 c4 10             	add    $0x10,%esp
f0110d1e:	85 c0                	test   %eax,%eax
f0110d20:	0f 85 89 00 00 00    	jne    f0110daf <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110d26:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d29:	83 c0 0c             	add    $0xc,%eax
f0110d2c:	8b 00                	mov    (%eax),%eax
f0110d2e:	83 ec 04             	sub    $0x4,%esp
f0110d31:	6a 0a                	push   $0xa
f0110d33:	6a 00                	push   $0x0
f0110d35:	50                   	push   %eax
f0110d36:	e8 fb f2 00 00       	call   f0120036 <strtol>
f0110d3b:	83 c4 10             	add    $0x10,%esp
f0110d3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110d41:	e8 8a f5 ff ff       	call   f01102d0 <isKHeapPlacementStrategyFIRSTFIT>
f0110d46:	84 c0                	test   %al,%al
f0110d48:	74 42                	je     f0110d8c <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110d4a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110d4e:	75 17                	jne    f0110d67 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110d50:	83 ec 0c             	sub    $0xc,%esp
f0110d53:	68 ec 83 12 f0       	push   $0xf01283ec
f0110d58:	e8 2e 02 ff ff       	call   f0100f8b <cprintf>
f0110d5d:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110d60:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d65:	eb 6f                	jmp    f0110dd6 <tst_kheap+0x485>
			}
			if (testNum==1)
f0110d67:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110d6b:	75 07                	jne    f0110d74 <tst_kheap+0x423>
				test_krealloc_FF1();
f0110d6d:	e8 50 c9 00 00       	call   f011d6c2 <test_krealloc_FF1>
f0110d72:	eb 18                	jmp    f0110d8c <tst_kheap+0x43b>
			else if (testNum==2)
f0110d74:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110d78:	75 07                	jne    f0110d81 <tst_kheap+0x430>
				test_krealloc_FF2();
f0110d7a:	e8 60 c9 00 00       	call   f011d6df <test_krealloc_FF2>
f0110d7f:	eb 0b                	jmp    f0110d8c <tst_kheap+0x43b>
			else if (testNum==3)
f0110d81:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110d85:	75 05                	jne    f0110d8c <tst_kheap+0x43b>
				test_krealloc_FF3();
f0110d87:	e8 70 c9 00 00       	call   f011d6fc <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f0110d8c:	e8 69 f5 ff ff       	call   f01102fa <isKHeapPlacementStrategyNEXTFIT>
f0110d91:	84 c0                	test   %al,%al
f0110d93:	74 05                	je     f0110d9a <tst_kheap+0x449>
		{
			test_krealloc();
f0110d95:	e8 ee c8 00 00       	call   f011d688 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0110d9a:	e8 46 f5 ff ff       	call   f01102e5 <isKHeapPlacementStrategyBESTFIT>
f0110d9f:	84 c0                	test   %al,%al
f0110da1:	74 05                	je     f0110da8 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0110da3:	e8 fd c8 00 00       	call   f011d6a5 <test_krealloc_BF>
		}
		return 0;
f0110da8:	b8 00 00 00 00       	mov    $0x0,%eax
f0110dad:	eb 27                	jmp    f0110dd6 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f0110daf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110db2:	83 c0 08             	add    $0x8,%eax
f0110db5:	8b 00                	mov    (%eax),%eax
f0110db7:	83 ec 08             	sub    $0x8,%esp
f0110dba:	68 3b 85 12 f0       	push   $0xf012853b
f0110dbf:	50                   	push   %eax
f0110dc0:	e8 1d f0 00 00       	call   f011fde2 <strcmp>
f0110dc5:	83 c4 10             	add    $0x10,%esp
f0110dc8:	85 c0                	test   %eax,%eax
f0110dca:	75 05                	jne    f0110dd1 <tst_kheap+0x480>
	{
		test_ksbrk();
f0110dcc:	e8 1d bb 00 00       	call   f011c8ee <test_ksbrk>
	}
	return 0;
f0110dd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110dd6:	c9                   	leave  
f0110dd7:	c3                   	ret    

f0110dd8 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f0110dd8:	55                   	push   %ebp
f0110dd9:	89 e5                	mov    %esp,%ebp
f0110ddb:	83 ec 28             	sub    $0x28,%esp
f0110dde:	8b 45 14             	mov    0x14(%ebp),%eax
f0110de1:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f0110de4:	8b 45 08             	mov    0x8(%ebp),%eax
f0110de7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110dea:	74 1d                	je     f0110e09 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f0110dec:	83 ec 04             	sub    $0x4,%esp
f0110def:	ff 75 08             	pushl  0x8(%ebp)
f0110df2:	ff 75 0c             	pushl  0xc(%ebp)
f0110df5:	68 40 85 12 f0       	push   $0xf0128540
f0110dfa:	e8 8c 01 ff ff       	call   f0100f8b <cprintf>
f0110dff:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e02:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e07:	eb 55                	jmp    f0110e5e <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f0110e09:	8b 45 08             	mov    0x8(%ebp),%eax
f0110e0c:	8b 40 fc             	mov    -0x4(%eax),%eax
f0110e0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0110e12:	8b 45 10             	mov    0x10(%ebp),%eax
f0110e15:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110e18:	8b 45 08             	mov    0x8(%ebp),%eax
f0110e1b:	01 d0                	add    %edx,%eax
f0110e1d:	8b 00                	mov    (%eax),%eax
f0110e1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0110e22:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110e26:	0b 45 10             	or     0x10(%ebp),%eax
f0110e29:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f0110e2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110e2f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110e32:	75 08                	jne    f0110e3c <check_block+0x64>
f0110e34:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110e37:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110e3a:	74 1d                	je     f0110e59 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f0110e3c:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e3f:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e42:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e45:	68 70 85 12 f0       	push   $0xf0128570
f0110e4a:	e8 3c 01 ff ff       	call   f0100f8b <cprintf>
f0110e4f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e52:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e57:	eb 05                	jmp    f0110e5e <check_block+0x86>
	}
	return 1;
f0110e59:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110e5e:	c9                   	leave  
f0110e5f:	c3                   	ret    

f0110e60 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0110e60:	55                   	push   %ebp
f0110e61:	89 e5                	mov    %esp,%ebp
f0110e63:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0110e66:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0110e6b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0110e6e:	74 20                	je     f0110e90 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f0110e70:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0110e75:	83 ec 04             	sub    $0x4,%esp
f0110e78:	50                   	push   %eax
f0110e79:	ff 75 08             	pushl  0x8(%ebp)
f0110e7c:	68 ac 85 12 f0       	push   $0xf01285ac
f0110e81:	e8 05 01 ff ff       	call   f0100f8b <cprintf>
f0110e86:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e89:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e8e:	eb 05                	jmp    f0110e95 <check_list_size+0x35>
	}
	return 1;
f0110e90:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110e95:	c9                   	leave  
f0110e96:	c3                   	ret    

f0110e97 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110e97:	55                   	push   %ebp
f0110e98:	89 e5                	mov    %esp,%ebp
f0110e9a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f0110e9d:	83 ec 04             	sub    $0x4,%esp
f0110ea0:	68 e0 85 12 f0       	push   $0xf01285e0
f0110ea5:	6a 3f                	push   $0x3f
f0110ea7:	68 40 86 12 f0       	push   $0xf0128640
f0110eac:	e8 88 f4 fe ff       	call   f0100339 <_panic>

f0110eb1 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f0110eb1:	55                   	push   %ebp
f0110eb2:	89 e5                	mov    %esp,%ebp
f0110eb4:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110eb7:	83 ec 04             	sub    $0x4,%esp
f0110eba:	68 64 86 12 f0       	push   $0xf0128664
f0110ebf:	6a 61                	push   $0x61
f0110ec1:	68 40 86 12 f0       	push   $0xf0128640
f0110ec6:	e8 6e f4 fe ff       	call   f0100339 <_panic>

f0110ecb <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f0110ecb:	55                   	push   %ebp
f0110ecc:	89 e5                	mov    %esp,%ebp
f0110ece:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110ed1:	83 ec 04             	sub    $0x4,%esp
f0110ed4:	68 b4 86 12 f0       	push   $0xf01286b4
f0110ed9:	68 e7 00 00 00       	push   $0xe7
f0110ede:	68 40 86 12 f0       	push   $0xf0128640
f0110ee3:	e8 51 f4 fe ff       	call   f0100339 <_panic>

f0110ee8 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f0110ee8:	55                   	push   %ebp
f0110ee9:	89 e5                	mov    %esp,%ebp
f0110eeb:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110ef1:	83 ec 04             	sub    $0x4,%esp
f0110ef4:	68 08 87 12 f0       	push   $0xf0128708
f0110ef9:	68 88 01 00 00       	push   $0x188
f0110efe:	68 40 86 12 f0       	push   $0xf0128640
f0110f03:	e8 31 f4 fe ff       	call   f0100339 <_panic>

f0110f08 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f0110f08:	55                   	push   %ebp
f0110f09:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f0110f0b:	90                   	nop
f0110f0c:	5d                   	pop    %ebp
f0110f0d:	c3                   	ret    

f0110f0e <test_free_block_FF>:

void test_free_block_FF()
{
f0110f0e:	55                   	push   %ebp
f0110f0f:	89 e5                	mov    %esp,%ebp
f0110f11:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110f14:	83 ec 04             	sub    $0x4,%esp
f0110f17:	68 5c 87 12 f0       	push   $0xf012875c
f0110f1c:	68 4e 02 00 00       	push   $0x24e
f0110f21:	68 40 86 12 f0       	push   $0xf0128640
f0110f26:	e8 0e f4 fe ff       	call   f0100339 <_panic>

f0110f2b <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0110f2b:	55                   	push   %ebp
f0110f2c:	89 e5                	mov    %esp,%ebp
f0110f2e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110f31:	83 ec 04             	sub    $0x4,%esp
f0110f34:	68 5c 87 12 f0       	push   $0xf012875c
f0110f39:	68 9a 03 00 00       	push   $0x39a
f0110f3e:	68 40 86 12 f0       	push   $0xf0128640
f0110f43:	e8 f1 f3 fe ff       	call   f0100339 <_panic>

f0110f48 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0110f48:	55                   	push   %ebp
f0110f49:	89 e5                	mov    %esp,%ebp
f0110f4b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0110f4e:	83 ec 04             	sub    $0x4,%esp
f0110f51:	68 a9 87 12 f0       	push   $0xf01287a9
f0110f56:	68 ba 04 00 00       	push   $0x4ba
f0110f5b:	68 40 86 12 f0       	push   $0xf0128640
f0110f60:	e8 d4 f3 fe ff       	call   f0100339 <_panic>

f0110f65 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110f65:	55                   	push   %ebp
f0110f66:	89 e5                	mov    %esp,%ebp
f0110f68:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110f6b:	83 ec 04             	sub    $0x4,%esp
f0110f6e:	68 5c 87 12 f0       	push   $0xf012875c
f0110f73:	68 c0 04 00 00       	push   $0x4c0
f0110f78:	68 40 86 12 f0       	push   $0xf0128640
f0110f7d:	e8 b7 f3 fe ff       	call   f0100339 <_panic>

f0110f82 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110f82:	55                   	push   %ebp
f0110f83:	89 e5                	mov    %esp,%ebp
f0110f85:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110f88:	83 ec 04             	sub    $0x4,%esp
f0110f8b:	68 5c 87 12 f0       	push   $0xf012875c
f0110f90:	68 e7 05 00 00       	push   $0x5e7
f0110f95:	68 40 86 12 f0       	push   $0xf0128640
f0110f9a:	e8 9a f3 fe ff       	call   f0100339 <_panic>

f0110f9f <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0110f9f:	55                   	push   %ebp
f0110fa0:	89 e5                	mov    %esp,%ebp
f0110fa2:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110fa5:	e8 ef aa ff ff       	call   f010ba99 <get_cpu_proc>
f0110faa:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0110fad:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110fb1:	75 16                	jne    f0110fc9 <sys_check_LRU_lists+0x2a>
f0110fb3:	68 bc 87 12 f0       	push   $0xf01287bc
f0110fb8:	68 cc 87 12 f0       	push   $0xf01287cc
f0110fbd:	6a 10                	push   $0x10
f0110fbf:	68 e1 87 12 f0       	push   $0xf01287e1
f0110fc4:	e8 70 f3 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0110fc9:	83 ec 0c             	sub    $0xc,%esp
f0110fcc:	68 00 88 12 f0       	push   $0xf0128800
f0110fd1:	e8 b5 ff fe ff       	call   f0100f8b <cprintf>
f0110fd6:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0110fd9:	83 ec 0c             	sub    $0xc,%esp
f0110fdc:	ff 75 e0             	pushl  -0x20(%ebp)
f0110fdf:	e8 f3 94 ff ff       	call   f010a4d7 <env_page_ws_print>
f0110fe4:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0110fe7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110fea:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0110fed:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0110ff4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0110ffb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110fff:	0f 84 a5 00 00 00    	je     f01110aa <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0111005:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f011100c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011100f:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0111015:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111018:	eb 4a                	jmp    f0111064 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f011101a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011101d:	8b 00                	mov    (%eax),%eax
f011101f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111022:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111025:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011102a:	89 c2                	mov    %eax,%edx
f011102c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011102f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111036:	8b 45 08             	mov    0x8(%ebp),%eax
f0111039:	01 c8                	add    %ecx,%eax
f011103b:	8b 00                	mov    (%eax),%eax
f011103d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111040:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111043:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111048:	39 c2                	cmp    %eax,%edx
f011104a:	74 09                	je     f0111055 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f011104c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111053:	eb 3e                	jmp    f0111093 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0111055:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111058:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011105b:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111061:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111064:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111068:	74 08                	je     f0111072 <sys_check_LRU_lists+0xd3>
f011106a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011106d:	8b 40 10             	mov    0x10(%eax),%eax
f0111070:	eb 05                	jmp    f0111077 <sys_check_LRU_lists+0xd8>
f0111072:	b8 00 00 00 00       	mov    $0x0,%eax
f0111077:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011107a:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0111080:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111083:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111089:	85 c0                	test   %eax,%eax
f011108b:	75 8d                	jne    f011101a <sys_check_LRU_lists+0x7b>
f011108d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111091:	75 87                	jne    f011101a <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0111093:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111096:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f011109c:	8b 45 10             	mov    0x10(%ebp),%eax
f011109f:	39 c2                	cmp    %eax,%edx
f01110a1:	74 07                	je     f01110aa <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f01110a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f01110aa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01110ae:	0f 84 a5 00 00 00    	je     f0111159 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f01110b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01110bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110be:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01110c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01110c7:	eb 4a                	jmp    f0111113 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f01110c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110cc:	8b 00                	mov    (%eax),%eax
f01110ce:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01110d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01110d4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110d9:	89 c2                	mov    %eax,%edx
f01110db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01110de:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01110e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01110e8:	01 c8                	add    %ecx,%eax
f01110ea:	8b 00                	mov    (%eax),%eax
f01110ec:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01110ef:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01110f2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110f7:	39 c2                	cmp    %eax,%edx
f01110f9:	74 09                	je     f0111104 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01110fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f0111102:	eb 3e                	jmp    f0111142 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f0111104:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111107:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011110a:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111110:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111113:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111117:	74 08                	je     f0111121 <sys_check_LRU_lists+0x182>
f0111119:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011111c:	8b 40 10             	mov    0x10(%eax),%eax
f011111f:	eb 05                	jmp    f0111126 <sys_check_LRU_lists+0x187>
f0111121:	b8 00 00 00 00       	mov    $0x0,%eax
f0111126:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111129:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f011112f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111132:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111138:	85 c0                	test   %eax,%eax
f011113a:	75 8d                	jne    f01110c9 <sys_check_LRU_lists+0x12a>
f011113c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111140:	75 87                	jne    f01110c9 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0111142:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111145:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f011114b:	8b 45 14             	mov    0x14(%ebp),%eax
f011114e:	39 c2                	cmp    %eax,%edx
f0111150:	74 07                	je     f0111159 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0111152:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0111159:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011115c:	23 45 f0             	and    -0x10(%ebp),%eax
}
f011115f:	c9                   	leave  
f0111160:	c3                   	ret    

f0111161 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0111161:	55                   	push   %ebp
f0111162:	89 e5                	mov    %esp,%ebp
f0111164:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0111167:	e8 2d a9 ff ff       	call   f010ba99 <get_cpu_proc>
f011116c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f011116f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111173:	75 16                	jne    f011118b <sys_check_LRU_lists_free+0x2a>
f0111175:	68 bc 87 12 f0       	push   $0xf01287bc
f011117a:	68 cc 87 12 f0       	push   $0xf01287cc
f011117f:	6a 45                	push   $0x45
f0111181:	68 e1 87 12 f0       	push   $0xf01287e1
f0111186:	e8 ae f1 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011118b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011118e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0111191:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111198:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011119b:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f01111a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01111a4:	eb 65                	jmp    f011120b <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f01111a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01111ad:	eb 3a                	jmp    f01111e9 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01111af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01111b2:	8b 00                	mov    (%eax),%eax
f01111b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01111b7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01111ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111bf:	89 c2                	mov    %eax,%edx
f01111c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111c4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01111cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01111ce:	01 c8                	add    %ecx,%eax
f01111d0:	8b 00                	mov    (%eax),%eax
f01111d2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01111d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01111d8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111dd:	39 c2                	cmp    %eax,%edx
f01111df:	75 05                	jne    f01111e6 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f01111e1:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01111e4:	eb 0b                	jmp    f01111f1 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01111e6:	ff 45 ec             	incl   -0x14(%ebp)
f01111e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111ec:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01111ef:	7c be                	jl     f01111af <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01111f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01111f5:	7e 08                	jle    f01111ff <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01111f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01111fa:	e9 ed 00 00 00       	jmp    f01112ec <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01111ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111202:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111208:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011120b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011120f:	74 08                	je     f0111219 <sys_check_LRU_lists_free+0xb8>
f0111211:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111214:	8b 40 10             	mov    0x10(%eax),%eax
f0111217:	eb 05                	jmp    f011121e <sys_check_LRU_lists_free+0xbd>
f0111219:	b8 00 00 00 00       	mov    $0x0,%eax
f011121e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111221:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0111227:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011122a:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111230:	85 c0                	test   %eax,%eax
f0111232:	0f 85 6e ff ff ff    	jne    f01111a6 <sys_check_LRU_lists_free+0x45>
f0111238:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011123c:	0f 85 64 ff ff ff    	jne    f01111a6 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111242:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111245:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f011124b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011124e:	eb 62                	jmp    f01112b2 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111250:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111257:	eb 3a                	jmp    f0111293 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111259:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011125c:	8b 00                	mov    (%eax),%eax
f011125e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0111261:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111264:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111269:	89 c2                	mov    %eax,%edx
f011126b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011126e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111275:	8b 45 08             	mov    0x8(%ebp),%eax
f0111278:	01 c8                	add    %ecx,%eax
f011127a:	8b 00                	mov    (%eax),%eax
f011127c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011127f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111282:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111287:	39 c2                	cmp    %eax,%edx
f0111289:	75 05                	jne    f0111290 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f011128b:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011128e:	eb 0b                	jmp    f011129b <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0111290:	ff 45 e8             	incl   -0x18(%ebp)
f0111293:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111296:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111299:	7c be                	jl     f0111259 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f011129b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011129f:	7e 05                	jle    f01112a6 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f01112a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01112a4:	eb 46                	jmp    f01112ec <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01112a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01112a9:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01112af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01112b2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01112b6:	74 08                	je     f01112c0 <sys_check_LRU_lists_free+0x15f>
f01112b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112bb:	8b 40 10             	mov    0x10(%eax),%eax
f01112be:	eb 05                	jmp    f01112c5 <sys_check_LRU_lists_free+0x164>
f01112c0:	b8 00 00 00 00       	mov    $0x0,%eax
f01112c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01112c8:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f01112ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01112d1:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01112d7:	85 c0                	test   %eax,%eax
f01112d9:	0f 85 71 ff ff ff    	jne    f0111250 <sys_check_LRU_lists_free+0xef>
f01112df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01112e3:	0f 85 67 ff ff ff    	jne    f0111250 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01112e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01112ec:	c9                   	leave  
f01112ed:	c3                   	ret    

f01112ee <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01112ee:	55                   	push   %ebp
f01112ef:	89 e5                	mov    %esp,%ebp
f01112f1:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f01112f4:	e8 a0 a7 ff ff       	call   f010ba99 <get_cpu_proc>
f01112f9:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01112fc:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0111300:	75 16                	jne    f0111318 <sys_check_WS_list+0x2a>
f0111302:	68 bc 87 12 f0       	push   $0xf01287bc
f0111307:	68 cc 87 12 f0       	push   $0xf01287cc
f011130c:	6a 79                	push   $0x79
f011130e:	68 e1 87 12 f0       	push   $0xf01287e1
f0111313:	e8 21 f0 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0111318:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011131b:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f011131e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f0111325:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111329:	74 06                	je     f0111331 <sys_check_WS_list+0x43>
f011132b:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f011132f:	75 1f                	jne    f0111350 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111331:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111334:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f011133a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011133d:	39 c2                	cmp    %eax,%edx
f011133f:	74 0f                	je     f0111350 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111341:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111348:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011134b:	e9 15 03 00 00       	jmp    f0111665 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111350:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111354:	74 39                	je     f011138f <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111356:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111359:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011135f:	8b 00                	mov    (%eax),%eax
f0111361:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0111364:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111367:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011136c:	89 c2                	mov    %eax,%edx
f011136e:	8b 45 10             	mov    0x10(%ebp),%eax
f0111371:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0111374:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111377:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011137c:	39 c2                	cmp    %eax,%edx
f011137e:	74 0f                	je     f011138f <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0111380:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111387:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011138a:	e9 d6 02 00 00       	jmp    f0111665 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f011138f:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111393:	0f 85 3c 01 00 00    	jne    f01114d5 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0111399:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f01113a0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01113a4:	74 4c                	je     f01113f2 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01113a6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01113ad:	eb 3b                	jmp    f01113ea <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f01113af:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01113b2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01113b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01113bc:	01 d0                	add    %edx,%eax
f01113be:	8b 00                	mov    (%eax),%eax
f01113c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01113c3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01113c6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01113cb:	89 c2                	mov    %eax,%edx
f01113cd:	8b 45 10             	mov    0x10(%ebp),%eax
f01113d0:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01113d3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01113d6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01113db:	39 c2                	cmp    %eax,%edx
f01113dd:	75 08                	jne    f01113e7 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f01113df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01113e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f01113e5:	eb 0b                	jmp    f01113f2 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01113e7:	ff 45 e8             	incl   -0x18(%ebp)
f01113ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01113ed:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113f0:	7c bd                	jl     f01113af <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f01113f2:	83 ec 08             	sub    $0x8,%esp
f01113f5:	ff 75 ec             	pushl  -0x14(%ebp)
f01113f8:	68 28 88 12 f0       	push   $0xf0128828
f01113fd:	e8 89 fb fe ff       	call   f0100f8b <cprintf>
f0111402:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0111405:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111408:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011140e:	85 c0                	test   %eax,%eax
f0111410:	74 0e                	je     f0111420 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0111412:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111415:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011141b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011141e:	eb 0c                	jmp    f011142c <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111420:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111423:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111429:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f011142c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011142f:	8b 00                	mov    (%eax),%eax
f0111431:	83 ec 08             	sub    $0x8,%esp
f0111434:	50                   	push   %eax
f0111435:	68 47 88 12 f0       	push   $0xf0128847
f011143a:	e8 4c fb fe ff       	call   f0100f8b <cprintf>
f011143f:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111442:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0111449:	eb 79                	jmp    f01114c4 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f011144b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011144e:	8b 00                	mov    (%eax),%eax
f0111450:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111453:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111456:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011145b:	89 c2                	mov    %eax,%edx
f011145d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111460:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111467:	8b 45 08             	mov    0x8(%ebp),%eax
f011146a:	01 c8                	add    %ecx,%eax
f011146c:	8b 00                	mov    (%eax),%eax
f011146e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111471:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111474:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111479:	39 c2                	cmp    %eax,%edx
f011147b:	74 0c                	je     f0111489 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f011147d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111484:	e9 d9 01 00 00       	jmp    f0111662 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0111489:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011148c:	40                   	inc    %eax
f011148d:	89 c2                	mov    %eax,%edx
f011148f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111492:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f0111498:	89 d0                	mov    %edx,%eax
f011149a:	ba 00 00 00 00       	mov    $0x0,%edx
f011149f:	f7 f1                	div    %ecx
f01114a1:	89 d0                	mov    %edx,%eax
f01114a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f01114a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114a9:	8b 40 10             	mov    0x10(%eax),%eax
f01114ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f01114af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01114b3:	75 0c                	jne    f01114c1 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01114b5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114b8:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01114be:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f01114c1:	ff 45 e4             	incl   -0x1c(%ebp)
f01114c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01114c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01114ca:	0f 8c 7b ff ff ff    	jl     f011144b <sys_check_WS_list+0x15d>
f01114d0:	e9 8d 01 00 00       	jmp    f0111662 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f01114d5:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01114d9:	74 0a                	je     f01114e5 <sys_check_WS_list+0x1f7>
f01114db:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f01114df:	0f 85 be 00 00 00    	jne    f01115a3 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01114e5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01114ec:	e9 a1 00 00 00       	jmp    f0111592 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f01114f1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01114f8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114fb:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111501:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111504:	eb 47                	jmp    f011154d <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0111506:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111509:	8b 00                	mov    (%eax),%eax
f011150b:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011150e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111511:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111516:	89 c2                	mov    %eax,%edx
f0111518:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011151b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111522:	8b 45 08             	mov    0x8(%ebp),%eax
f0111525:	01 c8                	add    %ecx,%eax
f0111527:	8b 00                	mov    (%eax),%eax
f0111529:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f011152c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011152f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111534:	39 c2                	cmp    %eax,%edx
f0111536:	75 09                	jne    f0111541 <sys_check_WS_list+0x253>
				{
					found = 1;
f0111538:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f011153f:	eb 3b                	jmp    f011157c <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111541:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111544:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f011154a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011154d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111551:	74 08                	je     f011155b <sys_check_WS_list+0x26d>
f0111553:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111556:	8b 40 10             	mov    0x10(%eax),%eax
f0111559:	eb 05                	jmp    f0111560 <sys_check_WS_list+0x272>
f011155b:	b8 00 00 00 00       	mov    $0x0,%eax
f0111560:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111563:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0111569:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011156c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111572:	85 c0                	test   %eax,%eax
f0111574:	75 90                	jne    f0111506 <sys_check_WS_list+0x218>
f0111576:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011157a:	75 8a                	jne    f0111506 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f011157c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111580:	75 0d                	jne    f011158f <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0111582:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111589:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011158a:	e9 d3 00 00 00       	jmp    f0111662 <sys_check_WS_list+0x374>
f011158f:	ff 45 e0             	incl   -0x20(%ebp)
f0111592:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111595:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111598:	0f 8c 53 ff ff ff    	jl     f01114f1 <sys_check_WS_list+0x203>
f011159e:	e9 bf 00 00 00       	jmp    f0111662 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f01115a3:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f01115a7:	0f 85 b5 00 00 00    	jne    f0111662 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01115ad:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01115b4:	e9 9d 00 00 00       	jmp    f0111656 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f01115b9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01115c0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115c3:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01115c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115cc:	eb 47                	jmp    f0111615 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01115ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115d1:	8b 00                	mov    (%eax),%eax
f01115d3:	89 45 b0             	mov    %eax,-0x50(%ebp)
f01115d6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01115d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115de:	89 c2                	mov    %eax,%edx
f01115e0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01115e3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01115ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01115ed:	01 c8                	add    %ecx,%eax
f01115ef:	8b 00                	mov    (%eax),%eax
f01115f1:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01115f4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01115f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115fc:	39 c2                	cmp    %eax,%edx
f01115fe:	75 09                	jne    f0111609 <sys_check_WS_list+0x31b>
				{
					found = 1;
f0111600:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f0111607:	eb 3b                	jmp    f0111644 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111609:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011160c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0111612:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111615:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111619:	74 08                	je     f0111623 <sys_check_WS_list+0x335>
f011161b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011161e:	8b 40 10             	mov    0x10(%eax),%eax
f0111621:	eb 05                	jmp    f0111628 <sys_check_WS_list+0x33a>
f0111623:	b8 00 00 00 00       	mov    $0x0,%eax
f0111628:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011162b:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0111631:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111634:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f011163a:	85 c0                	test   %eax,%eax
f011163c:	75 90                	jne    f01115ce <sys_check_WS_list+0x2e0>
f011163e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111642:	75 8a                	jne    f01115ce <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f0111644:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0111648:	74 09                	je     f0111653 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f011164a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111651:	eb 0f                	jmp    f0111662 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111653:	ff 45 d8             	incl   -0x28(%ebp)
f0111656:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111659:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011165c:	0f 8c 57 ff ff ff    	jl     f01115b9 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f0111662:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0111665:	c9                   	leave  
f0111666:	c3                   	ret    

f0111667 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111667:	55                   	push   %ebp
f0111668:	89 e5                	mov    %esp,%ebp
f011166a:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f011166d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111674:	8b 15 64 2d 6c f0    	mov    0xf06c2d64,%edx
f011167a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011167d:	39 c2                	cmp    %eax,%edx
f011167f:	74 0a                	je     f011168b <hasExpectedCommands+0x24>
		return 0;
f0111681:	b8 00 00 00 00       	mov    $0x0,%eax
f0111686:	e9 8b 00 00 00       	jmp    f0111716 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f011168b:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0111690:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111693:	eb 55                	jmp    f01116ea <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111695:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011169c:	eb 2a                	jmp    f01116c8 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011169e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01116a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01116ab:	01 d0                	add    %edx,%eax
f01116ad:	8b 10                	mov    (%eax),%edx
f01116af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01116b2:	8b 00                	mov    (%eax),%eax
f01116b4:	83 ec 08             	sub    $0x8,%esp
f01116b7:	52                   	push   %edx
f01116b8:	50                   	push   %eax
f01116b9:	e8 24 e7 00 00       	call   f011fde2 <strcmp>
f01116be:	83 c4 10             	add    $0x10,%esp
f01116c1:	85 c0                	test   %eax,%eax
f01116c3:	74 0d                	je     f01116d2 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01116c5:	ff 45 f0             	incl   -0x10(%ebp)
f01116c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116cb:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01116ce:	7c ce                	jl     f011169e <hasExpectedCommands+0x37>
f01116d0:	eb 01                	jmp    f01116d3 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f01116d2:	90                   	nop
		if (i == commandsCount)
f01116d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01116d9:	75 07                	jne    f01116e2 <hasExpectedCommands+0x7b>
			return 0;
f01116db:	b8 00 00 00 00       	mov    $0x0,%eax
f01116e0:	eb 34                	jmp    f0111716 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f01116e2:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f01116e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01116ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01116ee:	74 08                	je     f01116f8 <hasExpectedCommands+0x91>
f01116f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01116f3:	8b 40 10             	mov    0x10(%eax),%eax
f01116f6:	eb 05                	jmp    f01116fd <hasExpectedCommands+0x96>
f01116f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01116fd:	a3 60 2d 6c f0       	mov    %eax,0xf06c2d60
f0111702:	a1 60 2d 6c f0       	mov    0xf06c2d60,%eax
f0111707:	85 c0                	test   %eax,%eax
f0111709:	75 8a                	jne    f0111695 <hasExpectedCommands+0x2e>
f011170b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011170f:	75 84                	jne    f0111695 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0111711:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111716:	c9                   	leave  
f0111717:	c3                   	ret    

f0111718 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0111718:	55                   	push   %ebp
f0111719:	89 e5                	mov    %esp,%ebp
f011171b:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011171e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111725:	eb 2e                	jmp    f0111755 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0111727:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011172a:	89 d0                	mov    %edx,%eax
f011172c:	01 c0                	add    %eax,%eax
f011172e:	01 d0                	add    %edx,%eax
f0111730:	c1 e0 03             	shl    $0x3,%eax
f0111733:	05 40 f5 17 f0       	add    $0xf017f540,%eax
f0111738:	8b 00                	mov    (%eax),%eax
f011173a:	83 ec 08             	sub    $0x8,%esp
f011173d:	ff 75 08             	pushl  0x8(%ebp)
f0111740:	50                   	push   %eax
f0111741:	e8 9c e6 00 00       	call   f011fde2 <strcmp>
f0111746:	83 c4 10             	add    $0x10,%esp
f0111749:	85 c0                	test   %eax,%eax
f011174b:	75 05                	jne    f0111752 <getIndexOfCommand+0x3a>
			return i;
f011174d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111750:	eb 14                	jmp    f0111766 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111752:	ff 45 f4             	incl   -0xc(%ebp)
f0111755:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111758:	a1 48 f9 17 f0       	mov    0xf017f948,%eax
f011175d:	39 c2                	cmp    %eax,%edx
f011175f:	72 c6                	jb     f0111727 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0111761:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111766:	c9                   	leave  
f0111767:	c3                   	ret    

f0111768 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111768:	55                   	push   %ebp
f0111769:	89 e5                	mov    %esp,%ebp
f011176b:	57                   	push   %edi
f011176c:	56                   	push   %esi
f011176d:	53                   	push   %ebx
f011176e:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111774:	83 ec 0c             	sub    $0xc,%esp
f0111777:	68 80 88 12 f0       	push   $0xf0128880
f011177c:	e8 0a f8 fe ff       	call   f0100f8b <cprintf>
f0111781:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111784:	83 ec 0c             	sub    $0xc,%esp
f0111787:	68 a4 88 12 f0       	push   $0xf01288a4
f011178c:	e8 fa f7 fe ff       	call   f0100f8b <cprintf>
f0111791:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111794:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f011179b:	c7 45 8c bf 88 12 f0 	movl   $0xf01288bf,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f01117a2:	83 ec 08             	sub    $0x8,%esp
f01117a5:	8d 45 8c             	lea    -0x74(%ebp),%eax
f01117a8:	50                   	push   %eax
f01117a9:	6a 01                	push   $0x1
f01117ab:	e8 20 0a ff ff       	call   f01021d0 <process_command>
f01117b0:	83 c4 10             	add    $0x10,%esp
f01117b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01117b6:	83 ec 0c             	sub    $0xc,%esp
f01117b9:	68 cc 88 12 f0       	push   $0xf01288cc
f01117be:	e8 c8 f7 fe ff       	call   f0100f8b <cprintf>
f01117c3:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f01117c6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01117c9:	83 ec 0c             	sub    $0xc,%esp
f01117cc:	50                   	push   %eax
f01117cd:	e8 46 ff ff ff       	call   f0111718 <getIndexOfCommand>
f01117d2:	83 c4 10             	add    $0x10,%esp
f01117d5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01117d8:	75 0f                	jne    f01117e9 <TestAutoCompleteCommand+0x81>
f01117da:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f01117df:	85 c0                	test   %eax,%eax
f01117e1:	75 06                	jne    f01117e9 <TestAutoCompleteCommand+0x81>
		eval += 15;
f01117e3:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01117e7:	eb 10                	jmp    f01117f9 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01117e9:	83 ec 0c             	sub    $0xc,%esp
f01117ec:	68 fc 88 12 f0       	push   $0xf01288fc
f01117f1:	e8 95 f7 fe ff       	call   f0100f8b <cprintf>
f01117f6:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01117f9:	83 ec 0c             	sub    $0xc,%esp
f01117fc:	68 4c 89 12 f0       	push   $0xf012894c
f0111801:	e8 85 f7 fe ff       	call   f0100f8b <cprintf>
f0111806:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0111809:	c7 45 88 72 89 12 f0 	movl   $0xf0128972,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f0111810:	83 ec 08             	sub    $0x8,%esp
f0111813:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111816:	50                   	push   %eax
f0111817:	6a 01                	push   $0x1
f0111819:	e8 b2 09 ff ff       	call   f01021d0 <process_command>
f011181e:	83 c4 10             	add    $0x10,%esp
f0111821:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111824:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111828:	75 30                	jne    f011185a <TestAutoCompleteCommand+0xf2>
f011182a:	8d 45 90             	lea    -0x70(%ebp),%eax
f011182d:	bb 50 8d 12 f0       	mov    $0xf0128d50,%ebx
f0111832:	ba 03 00 00 00       	mov    $0x3,%edx
f0111837:	89 c7                	mov    %eax,%edi
f0111839:	89 de                	mov    %ebx,%esi
f011183b:	89 d1                	mov    %edx,%ecx
f011183d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011183f:	83 ec 08             	sub    $0x8,%esp
f0111842:	6a 03                	push   $0x3
f0111844:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111847:	50                   	push   %eax
f0111848:	e8 1a fe ff ff       	call   f0111667 <hasExpectedCommands>
f011184d:	83 c4 10             	add    $0x10,%esp
f0111850:	85 c0                	test   %eax,%eax
f0111852:	74 06                	je     f011185a <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111854:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111858:	eb 10                	jmp    f011186a <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011185a:	83 ec 0c             	sub    $0xc,%esp
f011185d:	68 78 89 12 f0       	push   $0xf0128978
f0111862:	e8 24 f7 fe ff       	call   f0100f8b <cprintf>
f0111867:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f011186a:	83 ec 0c             	sub    $0xc,%esp
f011186d:	68 c8 89 12 f0       	push   $0xf01289c8
f0111872:	e8 14 f7 fe ff       	call   f0100f8b <cprintf>
f0111877:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f011187a:	c7 45 84 ed 89 12 f0 	movl   $0xf01289ed,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0111881:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111884:	83 ec 04             	sub    $0x4,%esp
f0111887:	50                   	push   %eax
f0111888:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011188b:	50                   	push   %eax
f011188c:	68 f0 89 12 f0       	push   $0xf01289f0
f0111891:	e8 f5 f6 fe ff       	call   f0100f8b <cprintf>
f0111896:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111899:	83 ec 08             	sub    $0x8,%esp
f011189c:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011189f:	50                   	push   %eax
f01118a0:	6a 01                	push   $0x1
f01118a2:	e8 29 09 ff ff       	call   f01021d0 <process_command>
f01118a7:	83 c4 10             	add    $0x10,%esp
f01118aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f01118ad:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01118b1:	75 1b                	jne    f01118ce <TestAutoCompleteCommand+0x166>
f01118b3:	83 ec 08             	sub    $0x8,%esp
f01118b6:	6a 01                	push   $0x1
f01118b8:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01118bb:	50                   	push   %eax
f01118bc:	e8 a6 fd ff ff       	call   f0111667 <hasExpectedCommands>
f01118c1:	83 c4 10             	add    $0x10,%esp
f01118c4:	85 c0                	test   %eax,%eax
f01118c6:	74 06                	je     f01118ce <TestAutoCompleteCommand+0x166>
		eval += 15;
f01118c8:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01118cc:	eb 10                	jmp    f01118de <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01118ce:	83 ec 0c             	sub    $0xc,%esp
f01118d1:	68 10 8a 12 f0       	push   $0xf0128a10
f01118d6:	e8 b0 f6 fe ff       	call   f0100f8b <cprintf>
f01118db:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01118de:	83 ec 0c             	sub    $0xc,%esp
f01118e1:	68 68 8a 12 f0       	push   $0xf0128a68
f01118e6:	e8 a0 f6 fe ff       	call   f0100f8b <cprintf>
f01118eb:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01118ee:	c7 45 80 8e 8a 12 f0 	movl   $0xf0128a8e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01118f5:	83 ec 08             	sub    $0x8,%esp
f01118f8:	8d 45 80             	lea    -0x80(%ebp),%eax
f01118fb:	50                   	push   %eax
f01118fc:	6a 01                	push   $0x1
f01118fe:	e8 cd 08 ff ff       	call   f01021d0 <process_command>
f0111903:	83 c4 10             	add    $0x10,%esp
f0111906:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111909:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f011190d:	75 0f                	jne    f011191e <TestAutoCompleteCommand+0x1b6>
f011190f:	a1 64 2d 6c f0       	mov    0xf06c2d64,%eax
f0111914:	85 c0                	test   %eax,%eax
f0111916:	75 06                	jne    f011191e <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111918:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011191c:	eb 10                	jmp    f011192e <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011191e:	83 ec 0c             	sub    $0xc,%esp
f0111921:	68 94 8a 12 f0       	push   $0xf0128a94
f0111926:	e8 60 f6 fe ff       	call   f0100f8b <cprintf>
f011192b:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f011192e:	83 ec 0c             	sub    $0xc,%esp
f0111931:	68 e4 8a 12 f0       	push   $0xf0128ae4
f0111936:	e8 50 f6 fe ff       	call   f0100f8b <cprintf>
f011193b:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011193e:	c7 85 7c ff ff ff 09 	movl   $0xf0128b09,-0x84(%ebp)
f0111945:	8b 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111948:	83 ec 08             	sub    $0x8,%esp
f011194b:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f0111951:	50                   	push   %eax
f0111952:	6a 01                	push   $0x1
f0111954:	e8 77 08 ff ff       	call   f01021d0 <process_command>
f0111959:	83 c4 10             	add    $0x10,%esp
f011195c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011195f:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111963:	75 30                	jne    f0111995 <TestAutoCompleteCommand+0x22d>
f0111965:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111968:	bb e0 8d 12 f0       	mov    $0xf0128de0,%ebx
f011196d:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111972:	89 c7                	mov    %eax,%edi
f0111974:	89 de                	mov    %ebx,%esi
f0111976:	89 d1                	mov    %edx,%ecx
f0111978:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011197a:	83 ec 08             	sub    $0x8,%esp
f011197d:	6a 0c                	push   $0xc
f011197f:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111982:	50                   	push   %eax
f0111983:	e8 df fc ff ff       	call   f0111667 <hasExpectedCommands>
f0111988:	83 c4 10             	add    $0x10,%esp
f011198b:	85 c0                	test   %eax,%eax
f011198d:	74 06                	je     f0111995 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f011198f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111993:	eb 10                	jmp    f01119a5 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111995:	83 ec 0c             	sub    $0xc,%esp
f0111998:	68 0c 8b 12 f0       	push   $0xf0128b0c
f011199d:	e8 e9 f5 fe ff       	call   f0100f8b <cprintf>
f01119a2:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f01119a5:	83 ec 0c             	sub    $0xc,%esp
f01119a8:	68 64 8b 12 f0       	push   $0xf0128b64
f01119ad:	e8 d9 f5 fe ff       	call   f0100f8b <cprintf>
f01119b2:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01119b5:	c7 85 78 ff ff ff 89 	movl   $0xf0128b89,-0x88(%ebp)
f01119bc:	8b 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01119bf:	83 ec 08             	sub    $0x8,%esp
f01119c2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01119c8:	50                   	push   %eax
f01119c9:	6a 01                	push   $0x1
f01119cb:	e8 00 08 ff ff       	call   f01021d0 <process_command>
f01119d0:	83 c4 10             	add    $0x10,%esp
f01119d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01119d6:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01119da:	75 30                	jne    f0111a0c <TestAutoCompleteCommand+0x2a4>
f01119dc:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01119df:	bb 28 8e 12 f0       	mov    $0xf0128e28,%ebx
f01119e4:	ba 05 00 00 00       	mov    $0x5,%edx
f01119e9:	89 c7                	mov    %eax,%edi
f01119eb:	89 de                	mov    %ebx,%esi
f01119ed:	89 d1                	mov    %edx,%ecx
f01119ef:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01119f1:	83 ec 08             	sub    $0x8,%esp
f01119f4:	6a 05                	push   $0x5
f01119f6:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01119f9:	50                   	push   %eax
f01119fa:	e8 68 fc ff ff       	call   f0111667 <hasExpectedCommands>
f01119ff:	83 c4 10             	add    $0x10,%esp
f0111a02:	85 c0                	test   %eax,%eax
f0111a04:	74 06                	je     f0111a0c <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0111a06:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111a0a:	eb 10                	jmp    f0111a1c <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111a0c:	83 ec 0c             	sub    $0xc,%esp
f0111a0f:	68 8c 8b 12 f0       	push   $0xf0128b8c
f0111a14:	e8 72 f5 fe ff       	call   f0100f8b <cprintf>
f0111a19:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111a1c:	83 ec 0c             	sub    $0xc,%esp
f0111a1f:	68 e4 8b 12 f0       	push   $0xf0128be4
f0111a24:	e8 62 f5 fe ff       	call   f0100f8b <cprintf>
f0111a29:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111a2c:	c7 85 70 ff ff ff 10 	movl   $0xf0128c10,-0x90(%ebp)
f0111a33:	8c 12 f0 
f0111a36:	c7 85 74 ff ff ff 15 	movl   $0xf0128c15,-0x8c(%ebp)
f0111a3d:	8c 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111a40:	83 ec 08             	sub    $0x8,%esp
f0111a43:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111a49:	50                   	push   %eax
f0111a4a:	6a 02                	push   $0x2
f0111a4c:	e8 7f 07 ff ff       	call   f01021d0 <process_command>
f0111a51:	83 c4 10             	add    $0x10,%esp
f0111a54:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111a57:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111a5d:	83 ec 0c             	sub    $0xc,%esp
f0111a60:	50                   	push   %eax
f0111a61:	e8 b2 fc ff ff       	call   f0111718 <getIndexOfCommand>
f0111a66:	83 c4 10             	add    $0x10,%esp
f0111a69:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111a6c:	75 0f                	jne    f0111a7d <TestAutoCompleteCommand+0x315>
f0111a6e:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0111a73:	85 c0                	test   %eax,%eax
f0111a75:	75 06                	jne    f0111a7d <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111a77:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111a7b:	eb 10                	jmp    f0111a8d <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a7d:	83 ec 0c             	sub    $0xc,%esp
f0111a80:	68 1c 8c 12 f0       	push   $0xf0128c1c
f0111a85:	e8 01 f5 fe ff       	call   f0100f8b <cprintf>
f0111a8a:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111a8d:	83 ec 0c             	sub    $0xc,%esp
f0111a90:	68 6c 8c 12 f0       	push   $0xf0128c6c
f0111a95:	e8 f1 f4 fe ff       	call   f0100f8b <cprintf>
f0111a9a:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111a9d:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111aa3:	bb 50 8e 12 f0       	mov    $0xf0128e50,%ebx
f0111aa8:	ba 03 00 00 00       	mov    $0x3,%edx
f0111aad:	89 c7                	mov    %eax,%edi
f0111aaf:	89 de                	mov    %ebx,%esi
f0111ab1:	89 d1                	mov    %edx,%ecx
f0111ab3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111ab5:	83 ec 08             	sub    $0x8,%esp
f0111ab8:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111abe:	50                   	push   %eax
f0111abf:	6a 03                	push   $0x3
f0111ac1:	e8 0a 07 ff ff       	call   f01021d0 <process_command>
f0111ac6:	83 c4 10             	add    $0x10,%esp
f0111ac9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111acc:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111ad2:	83 ec 0c             	sub    $0xc,%esp
f0111ad5:	50                   	push   %eax
f0111ad6:	e8 3d fc ff ff       	call   f0111718 <getIndexOfCommand>
f0111adb:	83 c4 10             	add    $0x10,%esp
f0111ade:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111ae1:	75 0f                	jne    f0111af2 <TestAutoCompleteCommand+0x38a>
f0111ae3:	a1 58 2d 6c f0       	mov    0xf06c2d58,%eax
f0111ae8:	85 c0                	test   %eax,%eax
f0111aea:	75 06                	jne    f0111af2 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111aec:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111af0:	eb 10                	jmp    f0111b02 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111af2:	83 ec 0c             	sub    $0xc,%esp
f0111af5:	68 a0 8c 12 f0       	push   $0xf0128ca0
f0111afa:	e8 8c f4 fe ff       	call   f0100f8b <cprintf>
f0111aff:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0111b02:	83 ec 08             	sub    $0x8,%esp
f0111b05:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111b08:	68 f0 8c 12 f0       	push   $0xf0128cf0
f0111b0d:	e8 79 f4 fe ff       	call   f0100f8b <cprintf>
f0111b12:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111b15:	83 ec 0c             	sub    $0xc,%esp
f0111b18:	68 20 8d 12 f0       	push   $0xf0128d20
f0111b1d:	e8 69 f4 fe ff       	call   f0100f8b <cprintf>
f0111b22:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111b25:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111b2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111b2d:	5b                   	pop    %ebx
f0111b2e:	5e                   	pop    %esi
f0111b2f:	5f                   	pop    %edi
f0111b30:	5d                   	pop    %ebp
f0111b31:	c3                   	ret    

f0111b32 <test_str2lower_function>:

int test_str2lower_function()
{
f0111b32:	55                   	push   %ebp
f0111b33:	89 e5                	mov    %esp,%ebp
f0111b35:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111b3b:	83 ec 0c             	sub    $0xc,%esp
f0111b3e:	68 5c 8e 12 f0       	push   $0xf0128e5c
f0111b43:	e8 43 f4 fe ff       	call   f0100f8b <cprintf>
f0111b48:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111b4b:	83 ec 0c             	sub    $0xc,%esp
f0111b4e:	68 7d 8e 12 f0       	push   $0xf0128e7d
f0111b53:	e8 33 f4 fe ff       	call   f0100f8b <cprintf>
f0111b58:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111b5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111b62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111b69:	c7 45 ec 97 8e 12 f0 	movl   $0xf0128e97,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111b70:	83 ec 08             	sub    $0x8,%esp
f0111b73:	ff 75 ec             	pushl  -0x14(%ebp)
f0111b76:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111b7c:	50                   	push   %eax
f0111b7d:	e8 3d e8 00 00       	call   f01203bf <str2lower>
f0111b82:	83 c4 10             	add    $0x10,%esp
f0111b85:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111b88:	83 ec 0c             	sub    $0xc,%esp
f0111b8b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b8e:	e8 43 e1 00 00       	call   f011fcd6 <strlen>
f0111b93:	83 c4 10             	add    $0x10,%esp
f0111b96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111b99:	83 ec 08             	sub    $0x8,%esp
f0111b9c:	68 a2 8e 12 f0       	push   $0xf0128ea2
f0111ba1:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ba4:	e8 39 e2 00 00       	call   f011fde2 <strcmp>
f0111ba9:	83 c4 10             	add    $0x10,%esp
f0111bac:	85 c0                	test   %eax,%eax
f0111bae:	75 13                	jne    f0111bc3 <test_str2lower_function+0x91>
f0111bb0:	83 ec 0c             	sub    $0xc,%esp
f0111bb3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111bb6:	e8 1b e1 00 00       	call   f011fcd6 <strlen>
f0111bbb:	83 c4 10             	add    $0x10,%esp
f0111bbe:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111bc1:	74 15                	je     f0111bd8 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111bc3:	83 ec 08             	sub    $0x8,%esp
f0111bc6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111bc9:	68 b0 8e 12 f0       	push   $0xf0128eb0
f0111bce:	e8 b8 f3 fe ff       	call   f0100f8b <cprintf>
f0111bd3:	83 c4 10             	add    $0x10,%esp
f0111bd6:	eb 04                	jmp    f0111bdc <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111bd8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111bdc:	c7 45 e0 12 8f 12 f0 	movl   $0xf0128f12,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111be3:	83 ec 08             	sub    $0x8,%esp
f0111be6:	ff 75 e0             	pushl  -0x20(%ebp)
f0111be9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111bef:	50                   	push   %eax
f0111bf0:	e8 ca e7 00 00       	call   f01203bf <str2lower>
f0111bf5:	83 c4 10             	add    $0x10,%esp
f0111bf8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111bfb:	83 ec 0c             	sub    $0xc,%esp
f0111bfe:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c01:	e8 d0 e0 00 00       	call   f011fcd6 <strlen>
f0111c06:	83 c4 10             	add    $0x10,%esp
f0111c09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111c0c:	83 ec 08             	sub    $0x8,%esp
f0111c0f:	68 12 8f 12 f0       	push   $0xf0128f12
f0111c14:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c17:	e8 c6 e1 00 00       	call   f011fde2 <strcmp>
f0111c1c:	83 c4 10             	add    $0x10,%esp
f0111c1f:	85 c0                	test   %eax,%eax
f0111c21:	75 13                	jne    f0111c36 <test_str2lower_function+0x104>
f0111c23:	83 ec 0c             	sub    $0xc,%esp
f0111c26:	ff 75 e0             	pushl  -0x20(%ebp)
f0111c29:	e8 a8 e0 00 00       	call   f011fcd6 <strlen>
f0111c2e:	83 c4 10             	add    $0x10,%esp
f0111c31:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111c34:	74 15                	je     f0111c4b <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111c36:	83 ec 08             	sub    $0x8,%esp
f0111c39:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c3c:	68 14 8f 12 f0       	push   $0xf0128f14
f0111c41:	e8 45 f3 fe ff       	call   f0100f8b <cprintf>
f0111c46:	83 c4 10             	add    $0x10,%esp
f0111c49:	eb 04                	jmp    f0111c4f <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111c4b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111c4f:	c7 45 dc 6c 8f 12 f0 	movl   $0xf0128f6c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111c56:	83 ec 08             	sub    $0x8,%esp
f0111c59:	ff 75 dc             	pushl  -0x24(%ebp)
f0111c5c:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111c62:	50                   	push   %eax
f0111c63:	e8 57 e7 00 00       	call   f01203bf <str2lower>
f0111c68:	83 c4 10             	add    $0x10,%esp
f0111c6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111c6e:	83 ec 0c             	sub    $0xc,%esp
f0111c71:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c74:	e8 5d e0 00 00       	call   f011fcd6 <strlen>
f0111c79:	83 c4 10             	add    $0x10,%esp
f0111c7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111c7f:	83 ec 08             	sub    $0x8,%esp
f0111c82:	68 6c 8f 12 f0       	push   $0xf0128f6c
f0111c87:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c8a:	e8 53 e1 00 00       	call   f011fde2 <strcmp>
f0111c8f:	83 c4 10             	add    $0x10,%esp
f0111c92:	85 c0                	test   %eax,%eax
f0111c94:	75 13                	jne    f0111ca9 <test_str2lower_function+0x177>
f0111c96:	83 ec 0c             	sub    $0xc,%esp
f0111c99:	ff 75 dc             	pushl  -0x24(%ebp)
f0111c9c:	e8 35 e0 00 00       	call   f011fcd6 <strlen>
f0111ca1:	83 c4 10             	add    $0x10,%esp
f0111ca4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111ca7:	74 15                	je     f0111cbe <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111ca9:	83 ec 08             	sub    $0x8,%esp
f0111cac:	ff 75 e8             	pushl  -0x18(%ebp)
f0111caf:	68 78 8f 12 f0       	push   $0xf0128f78
f0111cb4:	e8 d2 f2 fe ff       	call   f0100f8b <cprintf>
f0111cb9:	83 c4 10             	add    $0x10,%esp
f0111cbc:	eb 04                	jmp    f0111cc2 <test_str2lower_function+0x190>
	else
		eval += 15;
f0111cbe:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111cc2:	c7 45 d8 db 8f 12 f0 	movl   $0xf0128fdb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111cc9:	83 ec 08             	sub    $0x8,%esp
f0111ccc:	ff 75 d8             	pushl  -0x28(%ebp)
f0111ccf:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111cd5:	50                   	push   %eax
f0111cd6:	e8 e4 e6 00 00       	call   f01203bf <str2lower>
f0111cdb:	83 c4 10             	add    $0x10,%esp
f0111cde:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111ce1:	83 ec 0c             	sub    $0xc,%esp
f0111ce4:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ce7:	e8 ea df 00 00       	call   f011fcd6 <strlen>
f0111cec:	83 c4 10             	add    $0x10,%esp
f0111cef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111cf2:	83 ec 08             	sub    $0x8,%esp
f0111cf5:	68 db 8f 12 f0       	push   $0xf0128fdb
f0111cfa:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cfd:	e8 e0 e0 00 00       	call   f011fde2 <strcmp>
f0111d02:	83 c4 10             	add    $0x10,%esp
f0111d05:	85 c0                	test   %eax,%eax
f0111d07:	75 13                	jne    f0111d1c <test_str2lower_function+0x1ea>
f0111d09:	83 ec 0c             	sub    $0xc,%esp
f0111d0c:	ff 75 d8             	pushl  -0x28(%ebp)
f0111d0f:	e8 c2 df 00 00       	call   f011fcd6 <strlen>
f0111d14:	83 c4 10             	add    $0x10,%esp
f0111d17:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d1a:	74 15                	je     f0111d31 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111d1c:	83 ec 08             	sub    $0x8,%esp
f0111d1f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d22:	68 e8 8f 12 f0       	push   $0xf0128fe8
f0111d27:	e8 5f f2 fe ff       	call   f0100f8b <cprintf>
f0111d2c:	83 c4 10             	add    $0x10,%esp
f0111d2f:	eb 04                	jmp    f0111d35 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111d31:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111d35:	c7 45 d4 4a 90 12 f0 	movl   $0xf012904a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111d3c:	83 ec 08             	sub    $0x8,%esp
f0111d3f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111d42:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111d48:	50                   	push   %eax
f0111d49:	e8 71 e6 00 00       	call   f01203bf <str2lower>
f0111d4e:	83 c4 10             	add    $0x10,%esp
f0111d51:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d54:	83 ec 0c             	sub    $0xc,%esp
f0111d57:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d5a:	e8 77 df 00 00       	call   f011fcd6 <strlen>
f0111d5f:	83 c4 10             	add    $0x10,%esp
f0111d62:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111d65:	83 ec 08             	sub    $0x8,%esp
f0111d68:	68 60 90 12 f0       	push   $0xf0129060
f0111d6d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d70:	e8 6d e0 00 00       	call   f011fde2 <strcmp>
f0111d75:	83 c4 10             	add    $0x10,%esp
f0111d78:	85 c0                	test   %eax,%eax
f0111d7a:	75 13                	jne    f0111d8f <test_str2lower_function+0x25d>
f0111d7c:	83 ec 0c             	sub    $0xc,%esp
f0111d7f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111d82:	e8 4f df 00 00       	call   f011fcd6 <strlen>
f0111d87:	83 c4 10             	add    $0x10,%esp
f0111d8a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d8d:	74 15                	je     f0111da4 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111d8f:	83 ec 08             	sub    $0x8,%esp
f0111d92:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d95:	68 78 90 12 f0       	push   $0xf0129078
f0111d9a:	e8 ec f1 fe ff       	call   f0100f8b <cprintf>
f0111d9f:	83 c4 10             	add    $0x10,%esp
f0111da2:	eb 04                	jmp    f0111da8 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111da4:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111da8:	c7 45 d0 e5 90 12 f0 	movl   $0xf01290e5,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111daf:	83 ec 08             	sub    $0x8,%esp
f0111db2:	ff 75 d0             	pushl  -0x30(%ebp)
f0111db5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111dbb:	50                   	push   %eax
f0111dbc:	e8 fe e5 00 00       	call   f01203bf <str2lower>
f0111dc1:	83 c4 10             	add    $0x10,%esp
f0111dc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111dc7:	83 ec 0c             	sub    $0xc,%esp
f0111dca:	ff 75 e8             	pushl  -0x18(%ebp)
f0111dcd:	e8 04 df 00 00       	call   f011fcd6 <strlen>
f0111dd2:	83 c4 10             	add    $0x10,%esp
f0111dd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111dd8:	83 ec 08             	sub    $0x8,%esp
f0111ddb:	68 f1 90 12 f0       	push   $0xf01290f1
f0111de0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111de3:	e8 fa df 00 00       	call   f011fde2 <strcmp>
f0111de8:	83 c4 10             	add    $0x10,%esp
f0111deb:	85 c0                	test   %eax,%eax
f0111ded:	75 13                	jne    f0111e02 <test_str2lower_function+0x2d0>
f0111def:	83 ec 0c             	sub    $0xc,%esp
f0111df2:	ff 75 d0             	pushl  -0x30(%ebp)
f0111df5:	e8 dc de 00 00       	call   f011fcd6 <strlen>
f0111dfa:	83 c4 10             	add    $0x10,%esp
f0111dfd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e00:	74 15                	je     f0111e17 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111e02:	83 ec 08             	sub    $0x8,%esp
f0111e05:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e08:	68 00 91 12 f0       	push   $0xf0129100
f0111e0d:	e8 79 f1 fe ff       	call   f0100f8b <cprintf>
f0111e12:	83 c4 10             	add    $0x10,%esp
f0111e15:	eb 04                	jmp    f0111e1b <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111e17:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111e1b:	c7 45 cc 63 91 12 f0 	movl   $0xf0129163,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111e22:	83 ec 08             	sub    $0x8,%esp
f0111e25:	ff 75 cc             	pushl  -0x34(%ebp)
f0111e28:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111e2e:	50                   	push   %eax
f0111e2f:	e8 8b e5 00 00       	call   f01203bf <str2lower>
f0111e34:	83 c4 10             	add    $0x10,%esp
f0111e37:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111e3a:	83 ec 0c             	sub    $0xc,%esp
f0111e3d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e40:	e8 91 de 00 00       	call   f011fcd6 <strlen>
f0111e45:	83 c4 10             	add    $0x10,%esp
f0111e48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111e4b:	83 ec 08             	sub    $0x8,%esp
f0111e4e:	68 7e 91 12 f0       	push   $0xf012917e
f0111e53:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e56:	e8 87 df 00 00       	call   f011fde2 <strcmp>
f0111e5b:	83 c4 10             	add    $0x10,%esp
f0111e5e:	85 c0                	test   %eax,%eax
f0111e60:	75 13                	jne    f0111e75 <test_str2lower_function+0x343>
f0111e62:	83 ec 0c             	sub    $0xc,%esp
f0111e65:	ff 75 cc             	pushl  -0x34(%ebp)
f0111e68:	e8 69 de 00 00       	call   f011fcd6 <strlen>
f0111e6d:	83 c4 10             	add    $0x10,%esp
f0111e70:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e73:	74 15                	je     f0111e8a <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111e75:	83 ec 08             	sub    $0x8,%esp
f0111e78:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e7b:	68 9c 91 12 f0       	push   $0xf012919c
f0111e80:	e8 06 f1 fe ff       	call   f0100f8b <cprintf>
f0111e85:	83 c4 10             	add    $0x10,%esp
f0111e88:	eb 04                	jmp    f0111e8e <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111e8a:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111e8e:	83 ec 08             	sub    $0x8,%esp
f0111e91:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e94:	68 10 92 12 f0       	push   $0xf0129210
f0111e99:	e8 ed f0 fe ff       	call   f0100f8b <cprintf>
f0111e9e:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111ea1:	83 ec 0c             	sub    $0xc,%esp
f0111ea4:	68 20 8d 12 f0       	push   $0xf0128d20
f0111ea9:	e8 dd f0 fe ff       	call   f0100f8b <cprintf>
f0111eae:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111eb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111eb6:	c9                   	leave  
f0111eb7:	c3                   	ret    

f0111eb8 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111eb8:	55                   	push   %ebp
f0111eb9:	89 e5                	mov    %esp,%ebp
f0111ebb:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111ebe:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111ec5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111ecc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ed3:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111ed8:	ff 75 ec             	pushl  -0x14(%ebp)
f0111edb:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ede:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ee1:	50                   	push   %eax
f0111ee2:	e8 f2 7d ff ff       	call   f0109cd9 <pt_set_page_permissions>
f0111ee7:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111eea:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111eef:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ef2:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ef5:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ef8:	50                   	push   %eax
f0111ef9:	e8 74 4b 00 00       	call   f0116a72 <CP>
f0111efe:	83 c4 10             	add    $0x10,%esp
f0111f01:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f04:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f08:	74 17                	je     f0111f21 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0111f0a:	83 ec 04             	sub    $0x4,%esp
f0111f0d:	68 40 92 12 f0       	push   $0xf0129240
f0111f12:	68 23 01 00 00       	push   $0x123
f0111f17:	68 62 92 12 f0       	push   $0xf0129262
f0111f1c:	e8 18 e4 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0111f21:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111f28:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0111f2f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f36:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111f3b:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f3e:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f41:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f44:	50                   	push   %eax
f0111f45:	e8 8f 7d ff ff       	call   f0109cd9 <pt_set_page_permissions>
f0111f4a:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f4d:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111f52:	ff 75 ec             	pushl  -0x14(%ebp)
f0111f55:	ff 75 f0             	pushl  -0x10(%ebp)
f0111f58:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f5b:	50                   	push   %eax
f0111f5c:	e8 11 4b 00 00       	call   f0116a72 <CP>
f0111f61:	83 c4 10             	add    $0x10,%esp
f0111f64:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111f67:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111f6b:	74 17                	je     f0111f84 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0111f6d:	83 ec 04             	sub    $0x4,%esp
f0111f70:	68 80 92 12 f0       	push   $0xf0129280
f0111f75:	68 2f 01 00 00       	push   $0x12f
f0111f7a:	68 62 92 12 f0       	push   $0xf0129262
f0111f7f:	e8 b5 e3 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111f84:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0111f8b:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111f92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111f99:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111f9e:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fa1:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fa4:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fa7:	50                   	push   %eax
f0111fa8:	e8 2c 7d ff ff       	call   f0109cd9 <pt_set_page_permissions>
f0111fad:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fb0:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0111fb5:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fb8:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fbb:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fbe:	50                   	push   %eax
f0111fbf:	e8 ae 4a 00 00       	call   f0116a72 <CP>
f0111fc4:	83 c4 10             	add    $0x10,%esp
f0111fc7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111fca:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111fce:	74 17                	je     f0111fe7 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0111fd0:	83 ec 04             	sub    $0x4,%esp
f0111fd3:	68 a4 92 12 f0       	push   $0xf01292a4
f0111fd8:	68 3a 01 00 00       	push   $0x13a
f0111fdd:	68 62 92 12 f0       	push   $0xf0129262
f0111fe2:	e8 52 e3 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0111fe7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0111fee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0111ff5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ffc:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112001:	ff 75 ec             	pushl  -0x14(%ebp)
f0112004:	ff 75 f0             	pushl  -0x10(%ebp)
f0112007:	ff 75 f4             	pushl  -0xc(%ebp)
f011200a:	50                   	push   %eax
f011200b:	e8 c9 7c ff ff       	call   f0109cd9 <pt_set_page_permissions>
f0112010:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112013:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112018:	ff 75 ec             	pushl  -0x14(%ebp)
f011201b:	ff 75 f0             	pushl  -0x10(%ebp)
f011201e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112021:	50                   	push   %eax
f0112022:	e8 4b 4a 00 00       	call   f0116a72 <CP>
f0112027:	83 c4 10             	add    $0x10,%esp
f011202a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011202d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112031:	74 17                	je     f011204a <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0112033:	83 ec 04             	sub    $0x4,%esp
f0112036:	68 c8 92 12 f0       	push   $0xf01292c8
f011203b:	68 46 01 00 00       	push   $0x146
f0112040:	68 62 92 12 f0       	push   $0xf0129262
f0112045:	e8 ef e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f011204a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0112051:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0112058:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011205f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112064:	ff 75 ec             	pushl  -0x14(%ebp)
f0112067:	ff 75 f0             	pushl  -0x10(%ebp)
f011206a:	ff 75 f4             	pushl  -0xc(%ebp)
f011206d:	50                   	push   %eax
f011206e:	e8 66 7c ff ff       	call   f0109cd9 <pt_set_page_permissions>
f0112073:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112076:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011207b:	ff 75 ec             	pushl  -0x14(%ebp)
f011207e:	ff 75 f0             	pushl  -0x10(%ebp)
f0112081:	ff 75 f4             	pushl  -0xc(%ebp)
f0112084:	50                   	push   %eax
f0112085:	e8 e8 49 00 00       	call   f0116a72 <CP>
f011208a:	83 c4 10             	add    $0x10,%esp
f011208d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112090:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112094:	74 17                	je     f01120ad <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0112096:	83 ec 04             	sub    $0x4,%esp
f0112099:	68 ec 92 12 f0       	push   $0xf01292ec
f011209e:	68 52 01 00 00       	push   $0x152
f01120a3:	68 62 92 12 f0       	push   $0xf0129262
f01120a8:	e8 8c e2 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f01120ad:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01120b4:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f01120bb:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120c2:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01120c7:	ff 75 ec             	pushl  -0x14(%ebp)
f01120ca:	ff 75 f0             	pushl  -0x10(%ebp)
f01120cd:	ff 75 f4             	pushl  -0xc(%ebp)
f01120d0:	50                   	push   %eax
f01120d1:	e8 03 7c ff ff       	call   f0109cd9 <pt_set_page_permissions>
f01120d6:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120d9:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01120de:	ff 75 ec             	pushl  -0x14(%ebp)
f01120e1:	ff 75 f0             	pushl  -0x10(%ebp)
f01120e4:	ff 75 f4             	pushl  -0xc(%ebp)
f01120e7:	50                   	push   %eax
f01120e8:	e8 85 49 00 00       	call   f0116a72 <CP>
f01120ed:	83 c4 10             	add    $0x10,%esp
f01120f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01120f3:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01120f7:	74 17                	je     f0112110 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01120f9:	83 ec 04             	sub    $0x4,%esp
f01120fc:	68 10 93 12 f0       	push   $0xf0129310
f0112101:	68 5e 01 00 00       	push   $0x15e
f0112106:	68 62 92 12 f0       	push   $0xf0129262
f011210b:	e8 29 e2 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112110:	83 ec 0c             	sub    $0xc,%esp
f0112113:	68 3c 93 12 f0       	push   $0xf012933c
f0112118:	e8 6e ee fe ff       	call   f0100f8b <cprintf>
f011211d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112120:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112125:	c9                   	leave  
f0112126:	c3                   	ret    

f0112127 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0112127:	55                   	push   %ebp
f0112128:	89 e5                	mov    %esp,%ebp
f011212a:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f011212d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112134:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f011213b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112142:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112147:	ff 75 ec             	pushl  -0x14(%ebp)
f011214a:	ff 75 f0             	pushl  -0x10(%ebp)
f011214d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112150:	50                   	push   %eax
f0112151:	e8 83 7b ff ff       	call   f0109cd9 <pt_set_page_permissions>
f0112156:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0112159:	83 ec 04             	sub    $0x4,%esp
f011215c:	68 8c 93 12 f0       	push   $0xf012938c
f0112161:	68 6b 01 00 00       	push   $0x16b
f0112166:	68 62 92 12 f0       	push   $0xf0129262
f011216b:	e8 c9 e1 fe ff       	call   f0100339 <_panic>

f0112170 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0112170:	55                   	push   %ebp
f0112171:	89 e5                	mov    %esp,%ebp
f0112173:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112176:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f011217d:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112182:	83 ec 08             	sub    $0x8,%esp
f0112185:	ff 75 f4             	pushl  -0xc(%ebp)
f0112188:	50                   	push   %eax
f0112189:	e8 0f 7c ff ff       	call   f0109d9d <pt_get_page_permissions>
f011218e:	83 c4 10             	add    $0x10,%esp
f0112191:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112194:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0112198:	74 17                	je     f01121b1 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f011219a:	83 ec 04             	sub    $0x4,%esp
f011219d:	68 28 94 12 f0       	push   $0xf0129428
f01121a2:	68 79 01 00 00       	push   $0x179
f01121a7:	68 62 92 12 f0       	push   $0xf0129262
f01121ac:	e8 88 e1 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01121b1:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01121b8:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01121bd:	83 ec 08             	sub    $0x8,%esp
f01121c0:	ff 75 f4             	pushl  -0xc(%ebp)
f01121c3:	50                   	push   %eax
f01121c4:	e8 d4 7b ff ff       	call   f0109d9d <pt_get_page_permissions>
f01121c9:	83 c4 10             	add    $0x10,%esp
f01121cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f01121cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01121d3:	74 17                	je     f01121ec <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f01121d5:	83 ec 04             	sub    $0x4,%esp
f01121d8:	68 4c 94 12 f0       	push   $0xf012944c
f01121dd:	68 81 01 00 00       	push   $0x181
f01121e2:	68 62 92 12 f0       	push   $0xf0129262
f01121e7:	e8 4d e1 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f01121ec:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01121f3:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01121f8:	83 ec 08             	sub    $0x8,%esp
f01121fb:	ff 75 f4             	pushl  -0xc(%ebp)
f01121fe:	50                   	push   %eax
f01121ff:	e8 99 7b ff ff       	call   f0109d9d <pt_get_page_permissions>
f0112204:	83 c4 10             	add    $0x10,%esp
f0112207:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011220a:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011220e:	74 17                	je     f0112227 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112210:	83 ec 04             	sub    $0x4,%esp
f0112213:	68 70 94 12 f0       	push   $0xf0129470
f0112218:	68 89 01 00 00       	push   $0x189
f011221d:	68 62 92 12 f0       	push   $0xf0129262
f0112222:	e8 12 e1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f0112227:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011222e:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112233:	83 ec 08             	sub    $0x8,%esp
f0112236:	ff 75 f4             	pushl  -0xc(%ebp)
f0112239:	50                   	push   %eax
f011223a:	e8 5e 7b ff ff       	call   f0109d9d <pt_get_page_permissions>
f011223f:	83 c4 10             	add    $0x10,%esp
f0112242:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112245:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112249:	74 17                	je     f0112262 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f011224b:	83 ec 04             	sub    $0x4,%esp
f011224e:	68 94 94 12 f0       	push   $0xf0129494
f0112253:	68 90 01 00 00       	push   $0x190
f0112258:	68 62 92 12 f0       	push   $0xf0129262
f011225d:	e8 d7 e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0112262:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112269:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011226e:	83 ec 08             	sub    $0x8,%esp
f0112271:	ff 75 f4             	pushl  -0xc(%ebp)
f0112274:	50                   	push   %eax
f0112275:	e8 23 7b ff ff       	call   f0109d9d <pt_get_page_permissions>
f011227a:	83 c4 10             	add    $0x10,%esp
f011227d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0112280:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112284:	74 17                	je     f011229d <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112286:	83 ec 04             	sub    $0x4,%esp
f0112289:	68 b8 94 12 f0       	push   $0xf01294b8
f011228e:	68 97 01 00 00       	push   $0x197
f0112293:	68 62 92 12 f0       	push   $0xf0129262
f0112298:	e8 9c e0 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f011229d:	83 ec 0c             	sub    $0xc,%esp
f01122a0:	68 dc 94 12 f0       	push   $0xf01294dc
f01122a5:	e8 e1 ec fe ff       	call   f0100f8b <cprintf>
f01122aa:	83 c4 10             	add    $0x10,%esp
	return 0;
f01122ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01122b2:	c9                   	leave  
f01122b3:	c3                   	ret    

f01122b4 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f01122b4:	55                   	push   %ebp
f01122b5:	89 e5                	mov    %esp,%ebp
f01122b7:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f01122ba:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01122c1:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01122c6:	83 ec 08             	sub    $0x8,%esp
f01122c9:	ff 75 f4             	pushl  -0xc(%ebp)
f01122cc:	50                   	push   %eax
f01122cd:	e8 14 7b ff ff       	call   f0109de6 <pt_clear_page_table_entry>
f01122d2:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f01122d5:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01122da:	83 ec 08             	sub    $0x8,%esp
f01122dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01122e0:	50                   	push   %eax
f01122e1:	e8 e8 46 00 00       	call   f01169ce <CE>
f01122e6:	83 c4 10             	add    $0x10,%esp
f01122e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01122ec:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01122f0:	74 17                	je     f0112309 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f01122f2:	83 ec 04             	sub    $0x4,%esp
f01122f5:	68 24 95 12 f0       	push   $0xf0129524
f01122fa:	68 a7 01 00 00       	push   $0x1a7
f01122ff:	68 62 92 12 f0       	push   $0xf0129262
f0112304:	e8 30 e0 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0112309:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112310:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112315:	83 ec 08             	sub    $0x8,%esp
f0112318:	ff 75 f4             	pushl  -0xc(%ebp)
f011231b:	50                   	push   %eax
f011231c:	e8 c5 7a ff ff       	call   f0109de6 <pt_clear_page_table_entry>
f0112321:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112324:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112329:	83 ec 08             	sub    $0x8,%esp
f011232c:	ff 75 f4             	pushl  -0xc(%ebp)
f011232f:	50                   	push   %eax
f0112330:	e8 99 46 00 00       	call   f01169ce <CE>
f0112335:	83 c4 10             	add    $0x10,%esp
f0112338:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011233b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011233f:	74 17                	je     f0112358 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112341:	83 ec 04             	sub    $0x4,%esp
f0112344:	68 50 95 12 f0       	push   $0xf0129550
f0112349:	68 af 01 00 00       	push   $0x1af
f011234e:	68 62 92 12 f0       	push   $0xf0129262
f0112353:	e8 e1 df fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0112358:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011235f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112364:	83 ec 08             	sub    $0x8,%esp
f0112367:	ff 75 f4             	pushl  -0xc(%ebp)
f011236a:	50                   	push   %eax
f011236b:	e8 76 7a ff ff       	call   f0109de6 <pt_clear_page_table_entry>
f0112370:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112373:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f0112378:	83 ec 08             	sub    $0x8,%esp
f011237b:	ff 75 f4             	pushl  -0xc(%ebp)
f011237e:	50                   	push   %eax
f011237f:	e8 4a 46 00 00       	call   f01169ce <CE>
f0112384:	83 c4 10             	add    $0x10,%esp
f0112387:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011238a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011238e:	74 17                	je     f01123a7 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0112390:	83 ec 04             	sub    $0x4,%esp
f0112393:	68 7c 95 12 f0       	push   $0xf012957c
f0112398:	68 b7 01 00 00       	push   $0x1b7
f011239d:	68 62 92 12 f0       	push   $0xf0129262
f01123a2:	e8 92 df fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f01123a7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01123ae:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01123b3:	83 ec 08             	sub    $0x8,%esp
f01123b6:	ff 75 f4             	pushl  -0xc(%ebp)
f01123b9:	50                   	push   %eax
f01123ba:	e8 27 7a ff ff       	call   f0109de6 <pt_clear_page_table_entry>
f01123bf:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01123c2:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f01123c7:	83 ec 08             	sub    $0x8,%esp
f01123ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01123cd:	50                   	push   %eax
f01123ce:	e8 fb 45 00 00       	call   f01169ce <CE>
f01123d3:	83 c4 10             	add    $0x10,%esp
f01123d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01123d9:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01123dd:	74 17                	je     f01123f6 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01123df:	83 ec 04             	sub    $0x4,%esp
f01123e2:	68 a8 95 12 f0       	push   $0xf01295a8
f01123e7:	68 bf 01 00 00       	push   $0x1bf
f01123ec:	68 62 92 12 f0       	push   $0xf0129262
f01123f1:	e8 43 df fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01123f6:	83 ec 0c             	sub    $0xc,%esp
f01123f9:	68 d4 95 12 f0       	push   $0xf01295d4
f01123fe:	e8 88 eb fe ff       	call   f0100f8b <cprintf>
f0112403:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112406:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011240b:	c9                   	leave  
f011240c:	c3                   	ret    

f011240d <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f011240d:	55                   	push   %ebp
f011240e:	89 e5                	mov    %esp,%ebp
f0112410:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112413:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011241a:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011241f:	83 ec 08             	sub    $0x8,%esp
f0112422:	ff 75 f4             	pushl  -0xc(%ebp)
f0112425:	50                   	push   %eax
f0112426:	e8 bb 79 ff ff       	call   f0109de6 <pt_clear_page_table_entry>
f011242b:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f011242e:	83 ec 04             	sub    $0x4,%esp
f0112431:	68 20 96 12 f0       	push   $0xf0129620
f0112436:	68 ca 01 00 00       	push   $0x1ca
f011243b:	68 62 92 12 f0       	push   $0xf0129262
f0112440:	e8 f4 de fe ff       	call   f0100339 <_panic>

f0112445 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0112445:	55                   	push   %ebp
f0112446:	89 e5                	mov    %esp,%ebp
f0112448:	57                   	push   %edi
f0112449:	56                   	push   %esi
f011244a:	53                   	push   %ebx
f011244b:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112451:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112457:	bb 64 99 12 f0       	mov    $0xf0129964,%ebx
f011245c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112461:	89 c7                	mov    %eax,%edi
f0112463:	89 de                	mov    %ebx,%esi
f0112465:	89 d1                	mov    %edx,%ecx
f0112467:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112469:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f011246f:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112474:	b0 00                	mov    $0x0,%al
f0112476:	89 d7                	mov    %edx,%edi
f0112478:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011247a:	6a 00                	push   $0x0
f011247c:	6a 0a                	push   $0xa
f011247e:	6a 14                	push   $0x14
f0112480:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112486:	50                   	push   %eax
f0112487:	e8 8f 8b ff ff       	call   f010b01b <env_create>
f011248c:	83 c4 10             	add    $0x10,%esp
f011248f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112492:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112495:	8b 40 64             	mov    0x64(%eax),%eax
f0112498:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f011249b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011249e:	8b 40 68             	mov    0x68(%eax),%eax
f01124a1:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01124a4:	8b 45 90             	mov    -0x70(%ebp),%eax
f01124a7:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01124aa:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f01124b1:	75 70 20 
f01124b4:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f01124bb:	00 00 00 
f01124be:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f01124c4:	b9 03 00 00 00       	mov    $0x3,%ecx
f01124c9:	b8 00 00 00 00       	mov    $0x0,%eax
f01124ce:	89 d7                	mov    %edx,%edi
f01124d0:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01124d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01124d5:	8b 40 10             	mov    0x10(%eax),%eax
f01124d8:	83 ec 08             	sub    $0x8,%esp
f01124db:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01124e1:	52                   	push   %edx
f01124e2:	50                   	push   %eax
f01124e3:	e8 94 dc 00 00       	call   f012017c <ltostr>
f01124e8:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01124eb:	83 ec 04             	sub    $0x4,%esp
f01124ee:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01124f4:	50                   	push   %eax
f01124f5:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f01124fb:	50                   	push   %eax
f01124fc:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112502:	50                   	push   %eax
f0112503:	e8 4d dd 00 00       	call   f0120255 <strcconcat>
f0112508:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f011250b:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0112512:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0112519:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0112520:	83 ec 0c             	sub    $0xc,%esp
f0112523:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112526:	e8 85 45 00 00       	call   f0116ab0 <ClearUserSpace>
f011252b:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f011252e:	83 ec 04             	sub    $0x4,%esp
f0112531:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112537:	50                   	push   %eax
f0112538:	68 b6 96 12 f0       	push   $0xf01296b6
f011253d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112543:	50                   	push   %eax
f0112544:	e8 0c dd 00 00       	call   f0120255 <strcconcat>
f0112549:	83 c4 10             	add    $0x10,%esp
f011254c:	83 ec 0c             	sub    $0xc,%esp
f011254f:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112555:	50                   	push   %eax
f0112556:	e8 a0 f9 fe ff       	call   f0101efb <execute_command>
f011255b:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f011255e:	83 ec 04             	sub    $0x4,%esp
f0112561:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112567:	50                   	push   %eax
f0112568:	68 c1 96 12 f0       	push   $0xf01296c1
f011256d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112573:	50                   	push   %eax
f0112574:	e8 dc dc 00 00       	call   f0120255 <strcconcat>
f0112579:	83 c4 10             	add    $0x10,%esp
f011257c:	83 ec 0c             	sub    $0xc,%esp
f011257f:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112585:	50                   	push   %eax
f0112586:	e8 70 f9 fe ff       	call   f0101efb <execute_command>
f011258b:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f011258e:	83 ec 04             	sub    $0x4,%esp
f0112591:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112597:	50                   	push   %eax
f0112598:	68 cc 96 12 f0       	push   $0xf01296cc
f011259d:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01125a3:	50                   	push   %eax
f01125a4:	e8 ac dc 00 00       	call   f0120255 <strcconcat>
f01125a9:	83 c4 10             	add    $0x10,%esp
f01125ac:	83 ec 0c             	sub    $0xc,%esp
f01125af:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01125b5:	50                   	push   %eax
f01125b6:	e8 40 f9 fe ff       	call   f0101efb <execute_command>
f01125bb:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f01125be:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f01125c5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01125c8:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f01125cb:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f01125d2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01125d5:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f01125d8:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f01125df:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01125e2:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f01125e5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01125e8:	83 ec 08             	sub    $0x8,%esp
f01125eb:	50                   	push   %eax
f01125ec:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125ef:	e8 9d 44 00 00       	call   f0116a91 <GP>
f01125f4:	83 c4 10             	add    $0x10,%esp
f01125f7:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f01125fa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0112601:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0112608:	e8 af c3 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011260d:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0112610:	83 ec 0c             	sub    $0xc,%esp
f0112613:	68 d8 96 12 f0       	push   $0xf01296d8
f0112618:	e8 6e e9 fe ff       	call   f0100f8b <cprintf>
f011261d:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0112620:	6a 03                	push   $0x3
f0112622:	68 00 00 90 02       	push   $0x2900000
f0112627:	68 00 00 80 02       	push   $0x2800000
f011262c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011262f:	e8 26 85 ff ff       	call   f010ab5a <cut_paste_pages>
f0112634:	83 c4 10             	add    $0x10,%esp
f0112637:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f011263a:	e8 7d c3 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011263f:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112642:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0112649:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011264d:	75 08                	jne    f0112657 <test_cut_paste_pages+0x212>
f011264f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112652:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112655:	74 2b                	je     f0112682 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112657:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011265a:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011265d:	83 ec 0c             	sub    $0xc,%esp
f0112660:	50                   	push   %eax
f0112661:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112664:	68 08 97 12 f0       	push   $0xf0129708
f0112669:	68 04 02 00 00       	push   $0x204
f011266e:	68 62 92 12 f0       	push   $0xf0129262
f0112673:	e8 5e de fe ff       	call   f01004d6 <_warn>
f0112678:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011267b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0112682:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112686:	74 04                	je     f011268c <test_cut_paste_pages+0x247>
f0112688:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011268c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112693:	83 ec 08             	sub    $0x8,%esp
f0112696:	6a 00                	push   $0x0
f0112698:	6a 01                	push   $0x1
f011269a:	6a 00                	push   $0x0
f011269c:	68 ff 0f 00 00       	push   $0xfff
f01126a1:	ff 75 bc             	pushl  -0x44(%ebp)
f01126a4:	6a 01                	push   $0x1
f01126a6:	68 00 30 00 00       	push   $0x3000
f01126ab:	68 00 00 90 02       	push   $0x2900000
f01126b0:	68 00 00 80 02       	push   $0x2800000
f01126b5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01126b8:	e8 27 44 00 00       	call   f0116ae4 <CCP>
f01126bd:	83 c4 30             	add    $0x30,%esp
f01126c0:	83 f8 01             	cmp    $0x1,%eax
f01126c3:	74 21                	je     f01126e6 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01126c5:	83 ec 04             	sub    $0x4,%esp
f01126c8:	68 5c 97 12 f0       	push   $0xf012975c
f01126cd:	68 0c 02 00 00       	push   $0x20c
f01126d2:	68 62 92 12 f0       	push   $0xf0129262
f01126d7:	e8 fa dd fe ff       	call   f01004d6 <_warn>
f01126dc:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01126df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f01126e6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01126ea:	74 04                	je     f01126f0 <test_cut_paste_pages+0x2ab>
f01126ec:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f01126f0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f01126f7:	83 ec 04             	sub    $0x4,%esp
f01126fa:	6a 00                	push   $0x0
f01126fc:	68 00 00 90 02       	push   $0x2900000
f0112701:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112704:	e8 b7 41 00 00       	call   f01168c0 <CB>
f0112709:	83 c4 10             	add    $0x10,%esp
f011270c:	85 c0                	test   %eax,%eax
f011270e:	0f 84 f6 00 00 00    	je     f011280a <test_cut_paste_pages+0x3c5>
f0112714:	83 ec 04             	sub    $0x4,%esp
f0112717:	6a 00                	push   $0x0
f0112719:	68 00 10 90 02       	push   $0x2901000
f011271e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112721:	e8 9a 41 00 00       	call   f01168c0 <CB>
f0112726:	83 c4 10             	add    $0x10,%esp
f0112729:	85 c0                	test   %eax,%eax
f011272b:	0f 84 d9 00 00 00    	je     f011280a <test_cut_paste_pages+0x3c5>
f0112731:	83 ec 04             	sub    $0x4,%esp
f0112734:	6a 00                	push   $0x0
f0112736:	68 00 20 90 02       	push   $0x2902000
f011273b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011273e:	e8 7d 41 00 00       	call   f01168c0 <CB>
f0112743:	83 c4 10             	add    $0x10,%esp
f0112746:	85 c0                	test   %eax,%eax
f0112748:	0f 84 bc 00 00 00    	je     f011280a <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f011274e:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112755:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f011275c:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112763:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112766:	8a 00                	mov    (%eax),%al
f0112768:	3c 61                	cmp    $0x61,%al
f011276a:	75 12                	jne    f011277e <test_cut_paste_pages+0x339>
f011276c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011276f:	8a 00                	mov    (%eax),%al
f0112771:	3c 62                	cmp    $0x62,%al
f0112773:	75 09                	jne    f011277e <test_cut_paste_pages+0x339>
f0112775:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112778:	8a 00                	mov    (%eax),%al
f011277a:	3c 63                	cmp    $0x63,%al
f011277c:	74 21                	je     f011279f <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011277e:	83 ec 04             	sub    $0x4,%esp
f0112781:	68 a8 97 12 f0       	push   $0xf01297a8
f0112786:	68 19 02 00 00       	push   $0x219
f011278b:	68 62 92 12 f0       	push   $0xf0129262
f0112790:	e8 41 dd fe ff       	call   f01004d6 <_warn>
f0112795:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112798:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011279f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127a3:	74 04                	je     f01127a9 <test_cut_paste_pages+0x364>
f01127a5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01127a9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f01127b0:	83 ec 04             	sub    $0x4,%esp
f01127b3:	6a 01                	push   $0x1
f01127b5:	68 00 10 90 02       	push   $0x2901000
f01127ba:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127bd:	e8 fe 40 00 00       	call   f01168c0 <CB>
f01127c2:	83 c4 10             	add    $0x10,%esp
f01127c5:	85 c0                	test   %eax,%eax
f01127c7:	74 41                	je     f011280a <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f01127c9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01127cc:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f01127cf:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01127d2:	8a 00                	mov    (%eax),%al
f01127d4:	3c 79                	cmp    $0x79,%al
f01127d6:	74 21                	je     f01127f9 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01127d8:	83 ec 04             	sub    $0x4,%esp
f01127db:	68 a8 97 12 f0       	push   $0xf01297a8
f01127e0:	68 24 02 00 00       	push   $0x224
f01127e5:	68 62 92 12 f0       	push   $0xf0129262
f01127ea:	e8 e7 dc fe ff       	call   f01004d6 <_warn>
f01127ef:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01127f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01127f9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127fd:	74 04                	je     f0112803 <test_cut_paste_pages+0x3be>
f01127ff:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112803:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f011280a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011280d:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112810:	6a 02                	push   $0x2
f0112812:	68 00 f0 bf 02       	push   $0x2bff000
f0112817:	68 00 10 90 02       	push   $0x2901000
f011281c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011281f:	e8 36 83 ff ff       	call   f010ab5a <cut_paste_pages>
f0112824:	83 c4 10             	add    $0x10,%esp
f0112827:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f011282a:	e8 8d c1 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011282f:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112832:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112836:	75 0b                	jne    f0112843 <test_cut_paste_pages+0x3fe>
f0112838:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011283b:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011283e:	83 f8 01             	cmp    $0x1,%eax
f0112841:	74 2b                	je     f011286e <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112843:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112846:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112849:	83 ec 0c             	sub    $0xc,%esp
f011284c:	50                   	push   %eax
f011284d:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112850:	68 08 97 12 f0       	push   $0xf0129708
f0112855:	68 35 02 00 00       	push   $0x235
f011285a:	68 62 92 12 f0       	push   $0xf0129262
f011285f:	e8 72 dc fe ff       	call   f01004d6 <_warn>
f0112864:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112867:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011286e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112872:	74 04                	je     f0112878 <test_cut_paste_pages+0x433>
f0112874:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112878:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011287f:	83 ec 08             	sub    $0x8,%esp
f0112882:	6a 00                	push   $0x0
f0112884:	6a 01                	push   $0x1
f0112886:	6a 00                	push   $0x0
f0112888:	68 ff 0f 00 00       	push   $0xfff
f011288d:	ff 75 bc             	pushl  -0x44(%ebp)
f0112890:	6a 01                	push   $0x1
f0112892:	68 00 20 00 00       	push   $0x2000
f0112897:	68 00 f0 bf 02       	push   $0x2bff000
f011289c:	68 00 10 90 02       	push   $0x2901000
f01128a1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01128a4:	e8 3b 42 00 00       	call   f0116ae4 <CCP>
f01128a9:	83 c4 30             	add    $0x30,%esp
f01128ac:	83 f8 01             	cmp    $0x1,%eax
f01128af:	74 21                	je     f01128d2 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01128b1:	83 ec 04             	sub    $0x4,%esp
f01128b4:	68 5c 97 12 f0       	push   $0xf012975c
f01128b9:	68 3d 02 00 00       	push   $0x23d
f01128be:	68 62 92 12 f0       	push   $0xf0129262
f01128c3:	e8 0e dc fe ff       	call   f01004d6 <_warn>
f01128c8:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01128cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01128d2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01128d6:	74 04                	je     f01128dc <test_cut_paste_pages+0x497>
f01128d8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01128dc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f01128e3:	83 ec 04             	sub    $0x4,%esp
f01128e6:	6a 00                	push   $0x0
f01128e8:	68 ff f7 bf 02       	push   $0x2bff7ff
f01128ed:	ff 75 d4             	pushl  -0x2c(%ebp)
f01128f0:	e8 cb 3f 00 00       	call   f01168c0 <CB>
f01128f5:	83 c4 10             	add    $0x10,%esp
f01128f8:	85 c0                	test   %eax,%eax
f01128fa:	74 6b                	je     f0112967 <test_cut_paste_pages+0x522>
f01128fc:	83 ec 04             	sub    $0x4,%esp
f01128ff:	6a 00                	push   $0x0
f0112901:	68 ff 0f c0 02       	push   $0x2c00fff
f0112906:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112909:	e8 b2 3f 00 00       	call   f01168c0 <CB>
f011290e:	83 c4 10             	add    $0x10,%esp
f0112911:	85 c0                	test   %eax,%eax
f0112913:	74 52                	je     f0112967 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112915:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f011291c:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112923:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112926:	8a 00                	mov    (%eax),%al
f0112928:	3c 79                	cmp    $0x79,%al
f011292a:	75 09                	jne    f0112935 <test_cut_paste_pages+0x4f0>
f011292c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011292f:	8a 00                	mov    (%eax),%al
f0112931:	3c 63                	cmp    $0x63,%al
f0112933:	74 21                	je     f0112956 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112935:	83 ec 04             	sub    $0x4,%esp
f0112938:	68 a8 97 12 f0       	push   $0xf01297a8
f011293d:	68 49 02 00 00       	push   $0x249
f0112942:	68 62 92 12 f0       	push   $0xf0129262
f0112947:	e8 8a db fe ff       	call   f01004d6 <_warn>
f011294c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011294f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112956:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011295a:	74 04                	je     f0112960 <test_cut_paste_pages+0x51b>
f011295c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112960:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112967:	83 ec 0c             	sub    $0xc,%esp
f011296a:	68 e1 97 12 f0       	push   $0xf01297e1
f011296f:	e8 17 e6 fe ff       	call   f0100f8b <cprintf>
f0112974:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112977:	83 ec 0c             	sub    $0xc,%esp
f011297a:	68 f0 97 12 f0       	push   $0xf01297f0
f011297f:	e8 07 e6 fe ff       	call   f0100f8b <cprintf>
f0112984:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112987:	83 ec 04             	sub    $0x4,%esp
f011298a:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112990:	50                   	push   %eax
f0112991:	68 19 98 12 f0       	push   $0xf0129819
f0112996:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011299c:	50                   	push   %eax
f011299d:	e8 b3 d8 00 00       	call   f0120255 <strcconcat>
f01129a2:	83 c4 10             	add    $0x10,%esp
f01129a5:	83 ec 0c             	sub    $0xc,%esp
f01129a8:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01129ae:	50                   	push   %eax
f01129af:	e8 47 f5 fe ff       	call   f0101efb <execute_command>
f01129b4:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01129b7:	83 ec 04             	sub    $0x4,%esp
f01129ba:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01129c0:	50                   	push   %eax
f01129c1:	68 24 98 12 f0       	push   $0xf0129824
f01129c6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01129cc:	50                   	push   %eax
f01129cd:	e8 83 d8 00 00       	call   f0120255 <strcconcat>
f01129d2:	83 c4 10             	add    $0x10,%esp
f01129d5:	83 ec 0c             	sub    $0xc,%esp
f01129d8:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01129de:	50                   	push   %eax
f01129df:	e8 17 f5 fe ff       	call   f0101efb <execute_command>
f01129e4:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f01129e7:	83 ec 04             	sub    $0x4,%esp
f01129ea:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01129f0:	50                   	push   %eax
f01129f1:	68 2f 98 12 f0       	push   $0xf012982f
f01129f6:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01129fc:	50                   	push   %eax
f01129fd:	e8 53 d8 00 00       	call   f0120255 <strcconcat>
f0112a02:	83 c4 10             	add    $0x10,%esp
f0112a05:	83 ec 0c             	sub    $0xc,%esp
f0112a08:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112a0e:	50                   	push   %eax
f0112a0f:	e8 e7 f4 fe ff       	call   f0101efb <execute_command>
f0112a14:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112a17:	83 ec 04             	sub    $0x4,%esp
f0112a1a:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112a20:	50                   	push   %eax
f0112a21:	68 3a 98 12 f0       	push   $0xf012983a
f0112a26:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112a2c:	50                   	push   %eax
f0112a2d:	e8 23 d8 00 00       	call   f0120255 <strcconcat>
f0112a32:	83 c4 10             	add    $0x10,%esp
f0112a35:	83 ec 0c             	sub    $0xc,%esp
f0112a38:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112a3e:	50                   	push   %eax
f0112a3f:	e8 b7 f4 fe ff       	call   f0101efb <execute_command>
f0112a44:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112a47:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112a4e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a51:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112a54:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112a5b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a5e:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112a61:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112a68:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a6b:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112a6e:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112a75:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a78:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112a7b:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112a82:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a85:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112a88:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112a8f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a92:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112a95:	83 ec 08             	sub    $0x8,%esp
f0112a98:	68 00 00 c0 01       	push   $0x1c00000
f0112a9d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112aa0:	e8 ec 3f 00 00       	call   f0116a91 <GP>
f0112aa5:	83 c4 10             	add    $0x10,%esp
f0112aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112aab:	83 ec 08             	sub    $0x8,%esp
f0112aae:	68 00 00 40 01       	push   $0x1400000
f0112ab3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ab6:	e8 d6 3f 00 00       	call   f0116a91 <GP>
f0112abb:	83 c4 10             	add    $0x10,%esp
f0112abe:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112ac1:	e8 f6 be ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0112ac6:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112ac9:	6a 01                	push   $0x1
f0112acb:	68 00 00 40 01       	push   $0x1400000
f0112ad0:	68 00 00 c0 01       	push   $0x1c00000
f0112ad5:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ad8:	e8 7d 80 ff ff       	call   f010ab5a <cut_paste_pages>
f0112add:	83 c4 10             	add    $0x10,%esp
f0112ae0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112ae3:	e8 d4 be ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0112ae8:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112aeb:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112aef:	75 08                	jne    f0112af9 <test_cut_paste_pages+0x6b4>
f0112af1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112af4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112af7:	74 2b                	je     f0112b24 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112af9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112afc:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112aff:	83 ec 0c             	sub    $0xc,%esp
f0112b02:	50                   	push   %eax
f0112b03:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112b06:	68 48 98 12 f0       	push   $0xf0129848
f0112b0b:	68 6c 02 00 00       	push   $0x26c
f0112b10:	68 62 92 12 f0       	push   $0xf0129262
f0112b15:	e8 bc d9 fe ff       	call   f01004d6 <_warn>
f0112b1a:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112b1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112b24:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b28:	74 04                	je     f0112b2e <test_cut_paste_pages+0x6e9>
f0112b2a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112b2e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112b35:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112b3c:	83 ec 08             	sub    $0x8,%esp
f0112b3f:	6a 00                	push   $0x0
f0112b41:	68 ff 0f 00 00       	push   $0xfff
f0112b46:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112b49:	68 ff 0f 00 00       	push   $0xfff
f0112b4e:	ff 75 a0             	pushl  -0x60(%ebp)
f0112b51:	6a 01                	push   $0x1
f0112b53:	68 00 10 00 00       	push   $0x1000
f0112b58:	68 00 00 40 01       	push   $0x1400000
f0112b5d:	68 00 00 c0 01       	push   $0x1c00000
f0112b62:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b65:	e8 7a 3f 00 00       	call   f0116ae4 <CCP>
f0112b6a:	83 c4 30             	add    $0x30,%esp
f0112b6d:	83 f8 01             	cmp    $0x1,%eax
f0112b70:	74 28                	je     f0112b9a <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112b72:	83 ec 04             	sub    $0x4,%esp
f0112b75:	68 5c 97 12 f0       	push   $0xf012975c
f0112b7a:	68 75 02 00 00       	push   $0x275
f0112b7f:	68 62 92 12 f0       	push   $0xf0129262
f0112b84:	e8 4d d9 fe ff       	call   f01004d6 <_warn>
f0112b89:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112b8c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112b93:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112b9a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b9e:	74 04                	je     f0112ba4 <test_cut_paste_pages+0x75f>
f0112ba0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112ba4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112bab:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112baf:	0f 84 92 00 00 00    	je     f0112c47 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0112bb5:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112bbc:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112bc3:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112bca:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112bd1:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112bd8:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112bdf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112be2:	8a 00                	mov    (%eax),%al
f0112be4:	3c 61                	cmp    $0x61,%al
f0112be6:	75 2d                	jne    f0112c15 <test_cut_paste_pages+0x7d0>
f0112be8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112beb:	8a 00                	mov    (%eax),%al
f0112bed:	3c 78                	cmp    $0x78,%al
f0112bef:	75 24                	jne    f0112c15 <test_cut_paste_pages+0x7d0>
f0112bf1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112bf4:	8a 00                	mov    (%eax),%al
f0112bf6:	3c 62                	cmp    $0x62,%al
f0112bf8:	75 1b                	jne    f0112c15 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112bfa:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112bfd:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112bff:	3c 79                	cmp    $0x79,%al
f0112c01:	75 12                	jne    f0112c15 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112c03:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112c06:	8a 00                	mov    (%eax),%al
f0112c08:	3c 63                	cmp    $0x63,%al
f0112c0a:	75 09                	jne    f0112c15 <test_cut_paste_pages+0x7d0>
f0112c0c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112c0f:	8a 00                	mov    (%eax),%al
f0112c11:	3c 7a                	cmp    $0x7a,%al
f0112c13:	74 21                	je     f0112c36 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112c15:	83 ec 04             	sub    $0x4,%esp
f0112c18:	68 a8 97 12 f0       	push   $0xf01297a8
f0112c1d:	68 87 02 00 00       	push   $0x287
f0112c22:	68 62 92 12 f0       	push   $0xf0129262
f0112c27:	e8 aa d8 fe ff       	call   f01004d6 <_warn>
f0112c2c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112c2f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112c36:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c3a:	74 04                	je     f0112c40 <test_cut_paste_pages+0x7fb>
f0112c3c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112c40:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112c47:	e8 70 bd ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0112c4c:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0112c4f:	6a 03                	push   $0x3
f0112c51:	68 00 f0 bf 01       	push   $0x1bff000
f0112c56:	68 00 00 40 01       	push   $0x1400000
f0112c5b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c5e:	e8 f7 7e ff ff       	call   f010ab5a <cut_paste_pages>
f0112c63:	83 c4 10             	add    $0x10,%esp
f0112c66:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112c69:	e8 4e bd ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0112c6e:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112c71:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112c75:	75 08                	jne    f0112c7f <test_cut_paste_pages+0x83a>
f0112c77:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c7a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112c7d:	74 2b                	je     f0112caa <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112c7f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c82:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112c85:	83 ec 0c             	sub    $0xc,%esp
f0112c88:	50                   	push   %eax
f0112c89:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112c8c:	68 48 98 12 f0       	push   $0xf0129848
f0112c91:	68 96 02 00 00       	push   $0x296
f0112c96:	68 62 92 12 f0       	push   $0xf0129262
f0112c9b:	e8 36 d8 fe ff       	call   f01004d6 <_warn>
f0112ca0:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112ca3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112caa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112cae:	74 04                	je     f0112cb4 <test_cut_paste_pages+0x86f>
f0112cb0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112cb4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0112cbb:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112cc2:	83 ec 04             	sub    $0x4,%esp
f0112cc5:	6a 00                	push   $0x0
f0112cc7:	68 00 00 40 01       	push   $0x1400000
f0112ccc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ccf:	e8 ec 3b 00 00       	call   f01168c0 <CB>
f0112cd4:	83 c4 10             	add    $0x10,%esp
f0112cd7:	83 f8 01             	cmp    $0x1,%eax
f0112cda:	0f 85 80 00 00 00    	jne    f0112d60 <test_cut_paste_pages+0x91b>
f0112ce0:	83 ec 04             	sub    $0x4,%esp
f0112ce3:	6a 00                	push   $0x0
f0112ce5:	68 00 10 40 01       	push   $0x1401000
f0112cea:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ced:	e8 ce 3b 00 00       	call   f01168c0 <CB>
f0112cf2:	83 c4 10             	add    $0x10,%esp
f0112cf5:	83 f8 01             	cmp    $0x1,%eax
f0112cf8:	75 66                	jne    f0112d60 <test_cut_paste_pages+0x91b>
f0112cfa:	83 ec 04             	sub    $0x4,%esp
f0112cfd:	6a 00                	push   $0x0
f0112cff:	68 00 20 40 01       	push   $0x1402000
f0112d04:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d07:	e8 b4 3b 00 00       	call   f01168c0 <CB>
f0112d0c:	83 c4 10             	add    $0x10,%esp
f0112d0f:	83 f8 01             	cmp    $0x1,%eax
f0112d12:	75 4c                	jne    f0112d60 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112d14:	83 ec 04             	sub    $0x4,%esp
f0112d17:	6a 00                	push   $0x0
f0112d19:	68 00 f0 bf 01       	push   $0x1bff000
f0112d1e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d21:	e8 9a 3b 00 00       	call   f01168c0 <CB>
f0112d26:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112d29:	85 c0                	test   %eax,%eax
f0112d2b:	75 33                	jne    f0112d60 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112d2d:	83 ec 04             	sub    $0x4,%esp
f0112d30:	6a 00                	push   $0x0
f0112d32:	68 00 00 c0 01       	push   $0x1c00000
f0112d37:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d3a:	e8 81 3b 00 00       	call   f01168c0 <CB>
f0112d3f:	83 c4 10             	add    $0x10,%esp
f0112d42:	83 f8 01             	cmp    $0x1,%eax
f0112d45:	75 19                	jne    f0112d60 <test_cut_paste_pages+0x91b>
f0112d47:	83 ec 04             	sub    $0x4,%esp
f0112d4a:	6a 00                	push   $0x0
f0112d4c:	68 00 10 c0 01       	push   $0x1c01000
f0112d51:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d54:	e8 67 3b 00 00       	call   f01168c0 <CB>
f0112d59:	83 c4 10             	add    $0x10,%esp
f0112d5c:	85 c0                	test   %eax,%eax
f0112d5e:	74 28                	je     f0112d88 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112d60:	83 ec 04             	sub    $0x4,%esp
f0112d63:	68 a8 98 12 f0       	push   $0xf01298a8
f0112d68:	68 9f 02 00 00       	push   $0x29f
f0112d6d:	68 62 92 12 f0       	push   $0xf0129262
f0112d72:	e8 5f d7 fe ff       	call   f01004d6 <_warn>
f0112d77:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112d7a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112d81:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112d88:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d8c:	74 04                	je     f0112d92 <test_cut_paste_pages+0x94d>
f0112d8e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112d92:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112d99:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112d9d:	0f 84 99 00 00 00    	je     f0112e3c <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112da3:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112daa:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112db1:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112db8:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112dbf:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112dc6:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112dcd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112dd0:	8a 00                	mov    (%eax),%al
f0112dd2:	3c 61                	cmp    $0x61,%al
f0112dd4:	75 2d                	jne    f0112e03 <test_cut_paste_pages+0x9be>
f0112dd6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112dd9:	8a 00                	mov    (%eax),%al
f0112ddb:	3c 78                	cmp    $0x78,%al
f0112ddd:	75 24                	jne    f0112e03 <test_cut_paste_pages+0x9be>
f0112ddf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112de2:	8a 00                	mov    (%eax),%al
f0112de4:	3c 62                	cmp    $0x62,%al
f0112de6:	75 1b                	jne    f0112e03 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112de8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112deb:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112ded:	3c 79                	cmp    $0x79,%al
f0112def:	75 12                	jne    f0112e03 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112df1:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112df4:	8a 00                	mov    (%eax),%al
f0112df6:	3c 63                	cmp    $0x63,%al
f0112df8:	75 09                	jne    f0112e03 <test_cut_paste_pages+0x9be>
f0112dfa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112dfd:	8a 00                	mov    (%eax),%al
f0112dff:	3c 7a                	cmp    $0x7a,%al
f0112e01:	74 28                	je     f0112e2b <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112e03:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112e0a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112e11:	83 ec 04             	sub    $0x4,%esp
f0112e14:	68 a8 97 12 f0       	push   $0xf01297a8
f0112e19:	68 b3 02 00 00       	push   $0x2b3
f0112e1e:	68 62 92 12 f0       	push   $0xf0129262
f0112e23:	e8 ae d6 fe ff       	call   f01004d6 <_warn>
f0112e28:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112e2b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112e2f:	74 04                	je     f0112e35 <test_cut_paste_pages+0x9f0>
f0112e31:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112e35:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0112e3c:	83 ec 0c             	sub    $0xc,%esp
f0112e3f:	68 e1 98 12 f0       	push   $0xf01298e1
f0112e44:	e8 42 e1 fe ff       	call   f0100f8b <cprintf>
f0112e49:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0112e4c:	83 ec 08             	sub    $0x8,%esp
f0112e4f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112e52:	68 f0 98 12 f0       	push   $0xf01298f0
f0112e57:	e8 2f e1 fe ff       	call   f0100f8b <cprintf>
f0112e5c:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112e5f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112e63:	75 10                	jne    f0112e75 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112e65:	83 ec 0c             	sub    $0xc,%esp
f0112e68:	68 24 99 12 f0       	push   $0xf0129924
f0112e6d:	e8 19 e1 fe ff       	call   f0100f8b <cprintf>
f0112e72:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112e75:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0112e7a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112e7d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112e80:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112e83:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112e88:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112e8b:	5b                   	pop    %ebx
f0112e8c:	5e                   	pop    %esi
f0112e8d:	5f                   	pop    %edi
f0112e8e:	5d                   	pop    %ebp
f0112e8f:	c3                   	ret    

f0112e90 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0112e90:	55                   	push   %ebp
f0112e91:	89 e5                	mov    %esp,%ebp
f0112e93:	57                   	push   %edi
f0112e94:	56                   	push   %esi
f0112e95:	53                   	push   %ebx
f0112e96:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112e9c:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112ea2:	bb 64 99 12 f0       	mov    $0xf0129964,%ebx
f0112ea7:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112eac:	89 c7                	mov    %eax,%edi
f0112eae:	89 de                	mov    %ebx,%esi
f0112eb0:	89 d1                	mov    %edx,%ecx
f0112eb2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112eb4:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0112eba:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112ebf:	b0 00                	mov    $0x0,%al
f0112ec1:	89 d7                	mov    %edx,%edi
f0112ec3:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112ec5:	6a 00                	push   $0x0
f0112ec7:	6a 0a                	push   $0xa
f0112ec9:	6a 14                	push   $0x14
f0112ecb:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112ed1:	50                   	push   %eax
f0112ed2:	e8 44 81 ff ff       	call   f010b01b <env_create>
f0112ed7:	83 c4 10             	add    $0x10,%esp
f0112eda:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112edd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112ee0:	8b 40 64             	mov    0x64(%eax),%eax
f0112ee3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112ee6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112ee9:	8b 40 68             	mov    0x68(%eax),%eax
f0112eec:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0112ef2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112ef8:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112efb:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0112f02:	75 70 20 
f0112f05:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0112f0c:	00 00 00 
f0112f0f:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112f15:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112f1a:	b8 00 00 00 00       	mov    $0x0,%eax
f0112f1f:	89 d7                	mov    %edx,%edi
f0112f21:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112f23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112f26:	8b 40 10             	mov    0x10(%eax),%eax
f0112f29:	83 ec 08             	sub    $0x8,%esp
f0112f2c:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112f32:	52                   	push   %edx
f0112f33:	50                   	push   %eax
f0112f34:	e8 43 d2 00 00       	call   f012017c <ltostr>
f0112f39:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112f3c:	83 ec 04             	sub    $0x4,%esp
f0112f3f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f45:	50                   	push   %eax
f0112f46:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0112f4c:	50                   	push   %eax
f0112f4d:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112f53:	50                   	push   %eax
f0112f54:	e8 fc d2 00 00       	call   f0120255 <strcconcat>
f0112f59:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0112f5c:	83 ec 0c             	sub    $0xc,%esp
f0112f5f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f62:	e8 49 3b 00 00       	call   f0116ab0 <ClearUserSpace>
f0112f67:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112f6a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0112f71:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112f78:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0112f7f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112f86:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112f8d:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112f94:	83 ec 0c             	sub    $0xc,%esp
f0112f97:	68 98 99 12 f0       	push   $0xf0129998
f0112f9c:	e8 ea df fe ff       	call   f0100f8b <cprintf>
f0112fa1:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112fa4:	83 ec 04             	sub    $0x4,%esp
f0112fa7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112fad:	50                   	push   %eax
f0112fae:	68 ce 99 12 f0       	push   $0xf01299ce
f0112fb3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112fb9:	50                   	push   %eax
f0112fba:	e8 96 d2 00 00       	call   f0120255 <strcconcat>
f0112fbf:	83 c4 10             	add    $0x10,%esp
f0112fc2:	83 ec 0c             	sub    $0xc,%esp
f0112fc5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112fcb:	50                   	push   %eax
f0112fcc:	e8 2a ef fe ff       	call   f0101efb <execute_command>
f0112fd1:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0112fd4:	83 ec 04             	sub    $0x4,%esp
f0112fd7:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112fdd:	50                   	push   %eax
f0112fde:	68 d3 99 12 f0       	push   $0xf01299d3
f0112fe3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112fe9:	50                   	push   %eax
f0112fea:	e8 66 d2 00 00       	call   f0120255 <strcconcat>
f0112fef:	83 c4 10             	add    $0x10,%esp
f0112ff2:	83 ec 0c             	sub    $0xc,%esp
f0112ff5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112ffb:	50                   	push   %eax
f0112ffc:	e8 fa ee fe ff       	call   f0101efb <execute_command>
f0113001:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0113004:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011300a:	bb d9 9c 12 f0       	mov    $0xf0129cd9,%ebx
f011300f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113014:	89 c7                	mov    %eax,%edi
f0113016:	89 de                	mov    %ebx,%esi
f0113018:	89 d1                	mov    %edx,%ecx
f011301a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011301c:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113022:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113027:	b0 00                	mov    $0x0,%al
f0113029:	89 d7                	mov    %edx,%edi
f011302b:	f3 aa                	rep stos %al,%es:(%edi)
f011302d:	83 ec 0c             	sub    $0xc,%esp
f0113030:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113036:	50                   	push   %eax
f0113037:	e8 bf ee fe ff       	call   f0101efb <execute_command>
f011303c:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f011303f:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113045:	bb 3d 9d 12 f0       	mov    $0xf0129d3d,%ebx
f011304a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011304f:	89 c7                	mov    %eax,%edi
f0113051:	89 de                	mov    %ebx,%esi
f0113053:	89 d1                	mov    %edx,%ecx
f0113055:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113057:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f011305d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113062:	b0 00                	mov    $0x0,%al
f0113064:	89 d7                	mov    %edx,%edi
f0113066:	f3 aa                	rep stos %al,%es:(%edi)
f0113068:	83 ec 0c             	sub    $0xc,%esp
f011306b:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113071:	50                   	push   %eax
f0113072:	e8 84 ee fe ff       	call   f0101efb <execute_command>
f0113077:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f011307a:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113080:	bb a1 9d 12 f0       	mov    $0xf0129da1,%ebx
f0113085:	ba 0f 00 00 00       	mov    $0xf,%edx
f011308a:	89 c7                	mov    %eax,%edi
f011308c:	89 de                	mov    %ebx,%esi
f011308e:	89 d1                	mov    %edx,%ecx
f0113090:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113092:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113098:	b9 55 00 00 00       	mov    $0x55,%ecx
f011309d:	b0 00                	mov    $0x0,%al
f011309f:	89 d7                	mov    %edx,%edi
f01130a1:	f3 aa                	rep stos %al,%es:(%edi)
f01130a3:	83 ec 0c             	sub    $0xc,%esp
f01130a6:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01130ac:	50                   	push   %eax
f01130ad:	e8 49 ee fe ff       	call   f0101efb <execute_command>
f01130b2:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f01130b5:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01130bb:	bb 05 9e 12 f0       	mov    $0xf0129e05,%ebx
f01130c0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01130c5:	89 c7                	mov    %eax,%edi
f01130c7:	89 de                	mov    %ebx,%esi
f01130c9:	89 d1                	mov    %edx,%ecx
f01130cb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01130cd:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01130d3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01130d8:	b0 00                	mov    $0x0,%al
f01130da:	89 d7                	mov    %edx,%edi
f01130dc:	f3 aa                	rep stos %al,%es:(%edi)
f01130de:	83 ec 0c             	sub    $0xc,%esp
f01130e1:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01130e7:	50                   	push   %eax
f01130e8:	e8 0e ee fe ff       	call   f0101efb <execute_command>
f01130ed:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f01130f0:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01130f6:	bb 69 9e 12 f0       	mov    $0xf0129e69,%ebx
f01130fb:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113100:	89 c7                	mov    %eax,%edi
f0113102:	89 de                	mov    %ebx,%esi
f0113104:	89 d1                	mov    %edx,%ecx
f0113106:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113108:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011310e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113113:	b0 00                	mov    $0x0,%al
f0113115:	89 d7                	mov    %edx,%edi
f0113117:	f3 aa                	rep stos %al,%es:(%edi)
f0113119:	83 ec 0c             	sub    $0xc,%esp
f011311c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113122:	50                   	push   %eax
f0113123:	e8 d3 ed fe ff       	call   f0101efb <execute_command>
f0113128:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f011312b:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113131:	bb cd 9e 12 f0       	mov    $0xf0129ecd,%ebx
f0113136:	ba 0f 00 00 00       	mov    $0xf,%edx
f011313b:	89 c7                	mov    %eax,%edi
f011313d:	89 de                	mov    %ebx,%esi
f011313f:	89 d1                	mov    %edx,%ecx
f0113141:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113143:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0113149:	b9 55 00 00 00       	mov    $0x55,%ecx
f011314e:	b0 00                	mov    $0x0,%al
f0113150:	89 d7                	mov    %edx,%edi
f0113152:	f3 aa                	rep stos %al,%es:(%edi)
f0113154:	83 ec 0c             	sub    $0xc,%esp
f0113157:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011315d:	50                   	push   %eax
f011315e:	e8 98 ed fe ff       	call   f0101efb <execute_command>
f0113163:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0113166:	83 ec 04             	sub    $0x4,%esp
f0113169:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011316f:	50                   	push   %eax
f0113170:	68 db 99 12 f0       	push   $0xf01299db
f0113175:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011317b:	50                   	push   %eax
f011317c:	e8 d4 d0 00 00       	call   f0120255 <strcconcat>
f0113181:	83 c4 10             	add    $0x10,%esp
f0113184:	83 ec 0c             	sub    $0xc,%esp
f0113187:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011318d:	50                   	push   %eax
f011318e:	e8 68 ed fe ff       	call   f0101efb <execute_command>
f0113193:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113196:	83 ec 04             	sub    $0x4,%esp
f0113199:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011319f:	50                   	push   %eax
f01131a0:	68 e5 99 12 f0       	push   $0xf01299e5
f01131a5:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01131ab:	50                   	push   %eax
f01131ac:	e8 a4 d0 00 00       	call   f0120255 <strcconcat>
f01131b1:	83 c4 10             	add    $0x10,%esp
f01131b4:	83 ec 0c             	sub    $0xc,%esp
f01131b7:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01131bd:	50                   	push   %eax
f01131be:	e8 38 ed fe ff       	call   f0101efb <execute_command>
f01131c3:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f01131c6:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01131cc:	bb 31 9f 12 f0       	mov    $0xf0129f31,%ebx
f01131d1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131d6:	89 c7                	mov    %eax,%edi
f01131d8:	89 de                	mov    %ebx,%esi
f01131da:	89 d1                	mov    %edx,%ecx
f01131dc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01131de:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f01131e4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01131e9:	b0 00                	mov    $0x0,%al
f01131eb:	89 d7                	mov    %edx,%edi
f01131ed:	f3 aa                	rep stos %al,%es:(%edi)
f01131ef:	83 ec 0c             	sub    $0xc,%esp
f01131f2:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01131f8:	50                   	push   %eax
f01131f9:	e8 fd ec fe ff       	call   f0101efb <execute_command>
f01131fe:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0113201:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113207:	bb 95 9f 12 f0       	mov    $0xf0129f95,%ebx
f011320c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113211:	89 c7                	mov    %eax,%edi
f0113213:	89 de                	mov    %ebx,%esi
f0113215:	89 d1                	mov    %edx,%ecx
f0113217:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113219:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011321f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113224:	b0 00                	mov    $0x0,%al
f0113226:	89 d7                	mov    %edx,%edi
f0113228:	f3 aa                	rep stos %al,%es:(%edi)
f011322a:	83 ec 0c             	sub    $0xc,%esp
f011322d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113233:	50                   	push   %eax
f0113234:	e8 c2 ec fe ff       	call   f0101efb <execute_command>
f0113239:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f011323c:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113242:	bb f9 9f 12 f0       	mov    $0xf0129ff9,%ebx
f0113247:	ba 0f 00 00 00       	mov    $0xf,%edx
f011324c:	89 c7                	mov    %eax,%edi
f011324e:	89 de                	mov    %ebx,%esi
f0113250:	89 d1                	mov    %edx,%ecx
f0113252:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113254:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f011325a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011325f:	b0 00                	mov    $0x0,%al
f0113261:	89 d7                	mov    %edx,%edi
f0113263:	f3 aa                	rep stos %al,%es:(%edi)
f0113265:	83 ec 0c             	sub    $0xc,%esp
f0113268:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011326e:	50                   	push   %eax
f011326f:	e8 87 ec fe ff       	call   f0101efb <execute_command>
f0113274:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113277:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f011327e:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113285:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f011328c:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0113293:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f011329a:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f01132a1:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f01132a8:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f01132af:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f01132b6:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f01132bd:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f01132c4:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f01132cb:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01132ce:	8a 00                	mov    (%eax),%al
f01132d0:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f01132d6:	8b 45 98             	mov    -0x68(%ebp),%eax
f01132d9:	8a 00                	mov    (%eax),%al
f01132db:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f01132e1:	8b 45 90             	mov    -0x70(%ebp),%eax
f01132e4:	8a 00                	mov    (%eax),%al
f01132e6:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01132ec:	e8 cb b6 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01132f1:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f01132f4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01132f7:	89 d0                	mov    %edx,%eax
f01132f9:	01 c0                	add    %eax,%eax
f01132fb:	01 d0                	add    %edx,%eax
f01132fd:	01 c0                	add    %eax,%eax
f01132ff:	50                   	push   %eax
f0113300:	68 00 00 10 00       	push   $0x100000
f0113305:	6a 00                	push   $0x0
f0113307:	ff 75 d4             	pushl  -0x2c(%ebp)
f011330a:	e8 65 78 ff ff       	call   f010ab74 <copy_paste_chunk>
f011330f:	83 c4 10             	add    $0x10,%esp
f0113312:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113315:	e8 a2 b6 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011331a:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f011331d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113324:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0113328:	75 08                	jne    f0113332 <test_copy_paste_chunk+0x4a2>
f011332a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011332d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113330:	74 2b                	je     f011335d <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113332:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113335:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113338:	83 ec 0c             	sub    $0xc,%esp
f011333b:	50                   	push   %eax
f011333c:	ff 75 88             	pushl  -0x78(%ebp)
f011333f:	68 f4 99 12 f0       	push   $0xf01299f4
f0113344:	68 06 03 00 00       	push   $0x306
f0113349:	68 62 92 12 f0       	push   $0xf0129262
f011334e:	e8 83 d1 fe ff       	call   f01004d6 <_warn>
f0113353:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113356:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011335d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113361:	74 04                	je     f0113367 <test_copy_paste_chunk+0x4d7>
f0113363:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113367:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f011336e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113371:	8a 00                	mov    (%eax),%al
f0113373:	3c 61                	cmp    $0x61,%al
f0113375:	75 75                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f0113377:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011337a:	8a 00                	mov    (%eax),%al
f011337c:	3c 78                	cmp    $0x78,%al
f011337e:	75 6c                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f0113380:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113383:	8a 00                	mov    (%eax),%al
f0113385:	3c 62                	cmp    $0x62,%al
f0113387:	75 63                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f0113389:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011338c:	8a 00                	mov    (%eax),%al
f011338e:	3c 79                	cmp    $0x79,%al
f0113390:	75 5a                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f0113392:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113395:	8a 00                	mov    (%eax),%al
f0113397:	3c 63                	cmp    $0x63,%al
f0113399:	75 51                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f011339b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011339e:	8a 00                	mov    (%eax),%al
f01133a0:	3c 7a                	cmp    $0x7a,%al
f01133a2:	75 48                	jne    f01133ec <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f01133a4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01133a7:	8a 00                	mov    (%eax),%al
f01133a9:	3c 64                	cmp    $0x64,%al
f01133ab:	75 3f                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f01133ad:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01133b0:	8a 10                	mov    (%eax),%dl
f01133b2:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f01133b8:	38 c2                	cmp    %al,%dl
f01133ba:	75 30                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f01133bc:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01133bf:	8a 00                	mov    (%eax),%al
f01133c1:	3c 65                	cmp    $0x65,%al
f01133c3:	75 27                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f01133c5:	8b 45 98             	mov    -0x68(%ebp),%eax
f01133c8:	8a 10                	mov    (%eax),%dl
f01133ca:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f01133d0:	38 c2                	cmp    %al,%dl
f01133d2:	75 18                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f01133d4:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01133d7:	8a 00                	mov    (%eax),%al
f01133d9:	3c 66                	cmp    $0x66,%al
f01133db:	75 0f                	jne    f01133ec <test_copy_paste_chunk+0x55c>
f01133dd:	8b 45 90             	mov    -0x70(%ebp),%eax
f01133e0:	8a 10                	mov    (%eax),%dl
f01133e2:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01133e8:	38 c2                	cmp    %al,%dl
f01133ea:	74 21                	je     f011340d <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01133ec:	83 ec 04             	sub    $0x4,%esp
f01133ef:	68 58 9a 12 f0       	push   $0xf0129a58
f01133f4:	68 0f 03 00 00       	push   $0x30f
f01133f9:	68 62 92 12 f0       	push   $0xf0129262
f01133fe:	e8 d3 d0 fe ff       	call   f01004d6 <_warn>
f0113403:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113406:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011340d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113411:	74 04                	je     f0113417 <test_copy_paste_chunk+0x587>
f0113413:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113417:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f011341e:	83 ec 0c             	sub    $0xc,%esp
f0113421:	68 92 9a 12 f0       	push   $0xf0129a92
f0113426:	e8 60 db fe ff       	call   f0100f8b <cprintf>
f011342b:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f011342e:	83 ec 0c             	sub    $0xc,%esp
f0113431:	68 a4 9a 12 f0       	push   $0xf0129aa4
f0113436:	e8 50 db fe ff       	call   f0100f8b <cprintf>
f011343b:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f011343e:	83 ec 04             	sub    $0x4,%esp
f0113441:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113447:	50                   	push   %eax
f0113448:	68 da 9a 12 f0       	push   $0xf0129ada
f011344d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113453:	50                   	push   %eax
f0113454:	e8 fc cd 00 00       	call   f0120255 <strcconcat>
f0113459:	83 c4 10             	add    $0x10,%esp
f011345c:	83 ec 0c             	sub    $0xc,%esp
f011345f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113465:	50                   	push   %eax
f0113466:	e8 90 ea fe ff       	call   f0101efb <execute_command>
f011346b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f011346e:	83 ec 04             	sub    $0x4,%esp
f0113471:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113477:	50                   	push   %eax
f0113478:	68 e4 9a 12 f0       	push   $0xf0129ae4
f011347d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113483:	50                   	push   %eax
f0113484:	e8 cc cd 00 00       	call   f0120255 <strcconcat>
f0113489:	83 c4 10             	add    $0x10,%esp
f011348c:	83 ec 0c             	sub    $0xc,%esp
f011348f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113495:	50                   	push   %eax
f0113496:	e8 60 ea fe ff       	call   f0101efb <execute_command>
f011349b:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f011349e:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01134a4:	bb 5d a0 12 f0       	mov    $0xf012a05d,%ebx
f01134a9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134ae:	89 c7                	mov    %eax,%edi
f01134b0:	89 de                	mov    %ebx,%esi
f01134b2:	89 d1                	mov    %edx,%ecx
f01134b4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134b6:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01134bc:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134c1:	b0 00                	mov    $0x0,%al
f01134c3:	89 d7                	mov    %edx,%edi
f01134c5:	f3 aa                	rep stos %al,%es:(%edi)
f01134c7:	83 ec 0c             	sub    $0xc,%esp
f01134ca:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01134d0:	50                   	push   %eax
f01134d1:	e8 25 ea fe ff       	call   f0101efb <execute_command>
f01134d6:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f01134d9:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01134df:	bb c1 a0 12 f0       	mov    $0xf012a0c1,%ebx
f01134e4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134e9:	89 c7                	mov    %eax,%edi
f01134eb:	89 de                	mov    %ebx,%esi
f01134ed:	89 d1                	mov    %edx,%ecx
f01134ef:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134f1:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01134f7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134fc:	b0 00                	mov    $0x0,%al
f01134fe:	89 d7                	mov    %edx,%edi
f0113500:	f3 aa                	rep stos %al,%es:(%edi)
f0113502:	83 ec 0c             	sub    $0xc,%esp
f0113505:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011350b:	50                   	push   %eax
f011350c:	e8 ea e9 fe ff       	call   f0101efb <execute_command>
f0113511:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0113514:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011351a:	bb 25 a1 12 f0       	mov    $0xf012a125,%ebx
f011351f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113524:	89 c7                	mov    %eax,%edi
f0113526:	89 de                	mov    %ebx,%esi
f0113528:	89 d1                	mov    %edx,%ecx
f011352a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011352c:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113532:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113537:	b0 00                	mov    $0x0,%al
f0113539:	89 d7                	mov    %edx,%edi
f011353b:	f3 aa                	rep stos %al,%es:(%edi)
f011353d:	83 ec 0c             	sub    $0xc,%esp
f0113540:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113546:	50                   	push   %eax
f0113547:	e8 af e9 fe ff       	call   f0101efb <execute_command>
f011354c:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f011354f:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113555:	bb 89 a1 12 f0       	mov    $0xf012a189,%ebx
f011355a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011355f:	89 c7                	mov    %eax,%edi
f0113561:	89 de                	mov    %ebx,%esi
f0113563:	89 d1                	mov    %edx,%ecx
f0113565:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113567:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f011356d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113572:	b0 00                	mov    $0x0,%al
f0113574:	89 d7                	mov    %edx,%edi
f0113576:	f3 aa                	rep stos %al,%es:(%edi)
f0113578:	83 ec 0c             	sub    $0xc,%esp
f011357b:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113581:	50                   	push   %eax
f0113582:	e8 74 e9 fe ff       	call   f0101efb <execute_command>
f0113587:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f011358a:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113590:	bb ed a1 12 f0       	mov    $0xf012a1ed,%ebx
f0113595:	ba 0f 00 00 00       	mov    $0xf,%edx
f011359a:	89 c7                	mov    %eax,%edi
f011359c:	89 de                	mov    %ebx,%esi
f011359e:	89 d1                	mov    %edx,%ecx
f01135a0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135a2:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01135a8:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135ad:	b0 00                	mov    $0x0,%al
f01135af:	89 d7                	mov    %edx,%edi
f01135b1:	f3 aa                	rep stos %al,%es:(%edi)
f01135b3:	83 ec 0c             	sub    $0xc,%esp
f01135b6:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01135bc:	50                   	push   %eax
f01135bd:	e8 39 e9 fe ff       	call   f0101efb <execute_command>
f01135c2:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f01135c5:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01135cb:	bb 51 a2 12 f0       	mov    $0xf012a251,%ebx
f01135d0:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135d5:	89 c7                	mov    %eax,%edi
f01135d7:	89 de                	mov    %ebx,%esi
f01135d9:	89 d1                	mov    %edx,%ecx
f01135db:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135dd:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01135e3:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135e8:	b0 00                	mov    $0x0,%al
f01135ea:	89 d7                	mov    %edx,%edi
f01135ec:	f3 aa                	rep stos %al,%es:(%edi)
f01135ee:	83 ec 0c             	sub    $0xc,%esp
f01135f1:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01135f7:	50                   	push   %eax
f01135f8:	e8 fe e8 fe ff       	call   f0101efb <execute_command>
f01135fd:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0113600:	83 ec 04             	sub    $0x4,%esp
f0113603:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113609:	50                   	push   %eax
f011360a:	68 ee 9a 12 f0       	push   $0xf0129aee
f011360f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113615:	50                   	push   %eax
f0113616:	e8 3a cc 00 00       	call   f0120255 <strcconcat>
f011361b:	83 c4 10             	add    $0x10,%esp
f011361e:	83 ec 0c             	sub    $0xc,%esp
f0113621:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113627:	50                   	push   %eax
f0113628:	e8 ce e8 fe ff       	call   f0101efb <execute_command>
f011362d:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113630:	83 ec 04             	sub    $0x4,%esp
f0113633:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113639:	50                   	push   %eax
f011363a:	68 f8 9a 12 f0       	push   $0xf0129af8
f011363f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113645:	50                   	push   %eax
f0113646:	e8 0a cc 00 00       	call   f0120255 <strcconcat>
f011364b:	83 c4 10             	add    $0x10,%esp
f011364e:	83 ec 0c             	sub    $0xc,%esp
f0113651:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113657:	50                   	push   %eax
f0113658:	e8 9e e8 fe ff       	call   f0101efb <execute_command>
f011365d:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0113660:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113666:	bb b5 a2 12 f0       	mov    $0xf012a2b5,%ebx
f011366b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113670:	89 c7                	mov    %eax,%edi
f0113672:	89 de                	mov    %ebx,%esi
f0113674:	89 d1                	mov    %edx,%ecx
f0113676:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113678:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011367e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113683:	b0 00                	mov    $0x0,%al
f0113685:	89 d7                	mov    %edx,%edi
f0113687:	f3 aa                	rep stos %al,%es:(%edi)
f0113689:	83 ec 0c             	sub    $0xc,%esp
f011368c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113692:	50                   	push   %eax
f0113693:	e8 63 e8 fe ff       	call   f0101efb <execute_command>
f0113698:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f011369b:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01136a1:	bb 19 a3 12 f0       	mov    $0xf012a319,%ebx
f01136a6:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136ab:	89 c7                	mov    %eax,%edi
f01136ad:	89 de                	mov    %ebx,%esi
f01136af:	89 d1                	mov    %edx,%ecx
f01136b1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136b3:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01136b9:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136be:	b0 00                	mov    $0x0,%al
f01136c0:	89 d7                	mov    %edx,%edi
f01136c2:	f3 aa                	rep stos %al,%es:(%edi)
f01136c4:	83 ec 0c             	sub    $0xc,%esp
f01136c7:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01136cd:	50                   	push   %eax
f01136ce:	e8 28 e8 fe ff       	call   f0101efb <execute_command>
f01136d3:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f01136d6:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01136dc:	bb 7d a3 12 f0       	mov    $0xf012a37d,%ebx
f01136e1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136e6:	89 c7                	mov    %eax,%edi
f01136e8:	89 de                	mov    %ebx,%esi
f01136ea:	89 d1                	mov    %edx,%ecx
f01136ec:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136ee:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01136f4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136f9:	b0 00                	mov    $0x0,%al
f01136fb:	89 d7                	mov    %edx,%edi
f01136fd:	f3 aa                	rep stos %al,%es:(%edi)
f01136ff:	83 ec 0c             	sub    $0xc,%esp
f0113702:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113708:	50                   	push   %eax
f0113709:	e8 ed e7 fe ff       	call   f0101efb <execute_command>
f011370e:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0113711:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113718:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f011371f:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113726:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f011372d:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113734:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f011373b:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113742:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113749:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113750:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113757:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f011375e:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113765:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113768:	8a 00                	mov    (%eax),%al
f011376a:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113770:	e8 47 b2 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0113775:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113778:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011377b:	89 d0                	mov    %edx,%eax
f011377d:	01 c0                	add    %eax,%eax
f011377f:	01 d0                	add    %edx,%eax
f0113781:	01 c0                	add    %eax,%eax
f0113783:	50                   	push   %eax
f0113784:	68 00 00 40 00       	push   $0x400000
f0113789:	68 00 00 20 00       	push   $0x200000
f011378e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113791:	e8 de 73 ff ff       	call   f010ab74 <copy_paste_chunk>
f0113796:	83 c4 10             	add    $0x10,%esp
f0113799:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011379c:	e8 1b b2 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01137a1:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01137a4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01137ab:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01137af:	75 08                	jne    f01137b9 <test_copy_paste_chunk+0x929>
f01137b1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01137b4:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01137b7:	74 2b                	je     f01137e4 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01137b9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01137bc:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01137bf:	83 ec 0c             	sub    $0xc,%esp
f01137c2:	50                   	push   %eax
f01137c3:	ff 75 80             	pushl  -0x80(%ebp)
f01137c6:	68 04 9b 12 f0       	push   $0xf0129b04
f01137cb:	68 3f 03 00 00       	push   $0x33f
f01137d0:	68 62 92 12 f0       	push   $0xf0129262
f01137d5:	e8 fc cc fe ff       	call   f01004d6 <_warn>
f01137da:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01137dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01137e4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01137e8:	74 04                	je     f01137ee <test_copy_paste_chunk+0x95e>
f01137ea:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01137ee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f01137f5:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f01137fc:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01137ff:	83 ec 08             	sub    $0x8,%esp
f0113802:	6a 01                	push   $0x1
f0113804:	6a 07                	push   $0x7
f0113806:	6a 07                	push   $0x7
f0113808:	6a 07                	push   $0x7
f011380a:	6a 07                	push   $0x7
f011380c:	6a 01                	push   $0x1
f011380e:	68 00 20 00 00       	push   $0x2000
f0113813:	68 00 00 40 00       	push   $0x400000
f0113818:	68 00 00 20 00       	push   $0x200000
f011381d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113820:	e8 bf 32 00 00       	call   f0116ae4 <CCP>
f0113825:	83 c4 30             	add    $0x30,%esp
f0113828:	83 f8 01             	cmp    $0x1,%eax
f011382b:	74 2b                	je     f0113858 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f011382d:	83 ec 04             	sub    $0x4,%esp
f0113830:	68 58 9b 12 f0       	push   $0xf0129b58
f0113835:	68 48 03 00 00       	push   $0x348
f011383a:	68 62 92 12 f0       	push   $0xf0129262
f011383f:	e8 92 cc fe ff       	call   f01004d6 <_warn>
f0113844:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113847:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f011384e:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113855:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113858:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011385c:	74 04                	je     f0113862 <test_copy_paste_chunk+0x9d2>
f011385e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113862:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113869:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011386c:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011386f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113872:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113875:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113878:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f011387b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011387e:	8a 00                	mov    (%eax),%al
f0113880:	3c 61                	cmp    $0x61,%al
f0113882:	75 69                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f0113884:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113887:	8a 00                	mov    (%eax),%al
f0113889:	3c 61                	cmp    $0x61,%al
f011388b:	75 60                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f011388d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113890:	8a 00                	mov    (%eax),%al
f0113892:	3c 79                	cmp    $0x79,%al
f0113894:	75 57                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f0113896:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113899:	8a 00                	mov    (%eax),%al
f011389b:	3c 62                	cmp    $0x62,%al
f011389d:	75 4e                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f011389f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01138a2:	8a 00                	mov    (%eax),%al
f01138a4:	3c 63                	cmp    $0x63,%al
f01138a6:	75 45                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f01138a8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01138ab:	8a 00                	mov    (%eax),%al
f01138ad:	3c 7a                	cmp    $0x7a,%al
f01138af:	75 3c                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01138b1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01138b4:	8a 00                	mov    (%eax),%al
f01138b6:	3c 77                	cmp    $0x77,%al
f01138b8:	75 33                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f01138ba:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01138bd:	8a 00                	mov    (%eax),%al
f01138bf:	3c 64                	cmp    $0x64,%al
f01138c1:	75 2a                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f01138c3:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01138c6:	8a 00                	mov    (%eax),%al
f01138c8:	3c 65                	cmp    $0x65,%al
f01138ca:	75 21                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f01138cc:	8b 45 98             	mov    -0x68(%ebp),%eax
f01138cf:	8a 00                	mov    (%eax),%al
f01138d1:	3c 65                	cmp    $0x65,%al
f01138d3:	75 18                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f01138d5:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01138d8:	8a 00                	mov    (%eax),%al
f01138da:	3c 66                	cmp    $0x66,%al
f01138dc:	75 0f                	jne    f01138ed <test_copy_paste_chunk+0xa5d>
f01138de:	8b 45 90             	mov    -0x70(%ebp),%eax
f01138e1:	8a 10                	mov    (%eax),%dl
f01138e3:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01138e9:	38 c2                	cmp    %al,%dl
f01138eb:	74 21                	je     f011390e <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01138ed:	83 ec 04             	sub    $0x4,%esp
f01138f0:	68 58 9a 12 f0       	push   $0xf0129a58
f01138f5:	68 56 03 00 00       	push   $0x356
f01138fa:	68 62 92 12 f0       	push   $0xf0129262
f01138ff:	e8 d2 cb fe ff       	call   f01004d6 <_warn>
f0113904:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113907:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011390e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113912:	74 04                	je     f0113918 <test_copy_paste_chunk+0xa88>
f0113914:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113918:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f011391f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113922:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113925:	e8 92 b0 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011392a:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f011392d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113930:	89 c2                	mov    %eax,%edx
f0113932:	01 d2                	add    %edx,%edx
f0113934:	01 d0                	add    %edx,%eax
f0113936:	50                   	push   %eax
f0113937:	68 00 08 20 00       	push   $0x200800
f011393c:	68 00 08 40 00       	push   $0x400800
f0113941:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113944:	e8 2b 72 ff ff       	call   f010ab74 <copy_paste_chunk>
f0113949:	83 c4 10             	add    $0x10,%esp
f011394c:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011394f:	e8 68 b0 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0113954:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113957:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f011395b:	75 08                	jne    f0113965 <test_copy_paste_chunk+0xad5>
f011395d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113960:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113963:	74 2b                	je     f0113990 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113965:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113968:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011396b:	83 ec 0c             	sub    $0xc,%esp
f011396e:	50                   	push   %eax
f011396f:	ff 75 80             	pushl  -0x80(%ebp)
f0113972:	68 04 9b 12 f0       	push   $0xf0129b04
f0113977:	68 66 03 00 00       	push   $0x366
f011397c:	68 62 92 12 f0       	push   $0xf0129262
f0113981:	e8 50 cb fe ff       	call   f01004d6 <_warn>
f0113986:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113989:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113990:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113994:	74 04                	je     f011399a <test_copy_paste_chunk+0xb0a>
f0113996:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011399a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01139a1:	83 ec 08             	sub    $0x8,%esp
f01139a4:	6a 01                	push   $0x1
f01139a6:	6a 07                	push   $0x7
f01139a8:	6a 07                	push   $0x7
f01139aa:	6a 07                	push   $0x7
f01139ac:	6a 07                	push   $0x7
f01139ae:	6a 01                	push   $0x1
f01139b0:	68 00 20 00 00       	push   $0x2000
f01139b5:	68 00 00 20 00       	push   $0x200000
f01139ba:	68 00 00 40 00       	push   $0x400000
f01139bf:	ff 75 d4             	pushl  -0x2c(%ebp)
f01139c2:	e8 1d 31 00 00       	call   f0116ae4 <CCP>
f01139c7:	83 c4 30             	add    $0x30,%esp
f01139ca:	83 f8 01             	cmp    $0x1,%eax
f01139cd:	74 21                	je     f01139f0 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01139cf:	83 ec 04             	sub    $0x4,%esp
f01139d2:	68 a4 9b 12 f0       	push   $0xf0129ba4
f01139d7:	68 6e 03 00 00       	push   $0x36e
f01139dc:	68 62 92 12 f0       	push   $0xf0129262
f01139e1:	e8 f0 ca fe ff       	call   f01004d6 <_warn>
f01139e6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01139e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01139f0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01139f4:	74 04                	je     f01139fa <test_copy_paste_chunk+0xb6a>
f01139f6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01139fa:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113a01:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a04:	8a 00                	mov    (%eax),%al
f0113a06:	3c 61                	cmp    $0x61,%al
f0113a08:	75 69                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a0a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a0d:	8a 00                	mov    (%eax),%al
f0113a0f:	3c 61                	cmp    $0x61,%al
f0113a11:	75 60                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a13:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a16:	8a 00                	mov    (%eax),%al
f0113a18:	3c 79                	cmp    $0x79,%al
f0113a1a:	75 57                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a1c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113a1f:	8a 00                	mov    (%eax),%al
f0113a21:	3c 62                	cmp    $0x62,%al
f0113a23:	75 4e                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a25:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113a28:	8a 00                	mov    (%eax),%al
f0113a2a:	3c 7a                	cmp    $0x7a,%al
f0113a2c:	75 45                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a2e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113a31:	8a 00                	mov    (%eax),%al
f0113a33:	3c 7a                	cmp    $0x7a,%al
f0113a35:	75 3c                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113a37:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113a3a:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113a3c:	3c 64                	cmp    $0x64,%al
f0113a3e:	75 33                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113a40:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113a43:	8a 00                	mov    (%eax),%al
f0113a45:	3c 64                	cmp    $0x64,%al
f0113a47:	75 2a                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a49:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113a4c:	8a 00                	mov    (%eax),%al
f0113a4e:	3c 65                	cmp    $0x65,%al
f0113a50:	75 21                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a52:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113a55:	8a 00                	mov    (%eax),%al
f0113a57:	3c 78                	cmp    $0x78,%al
f0113a59:	75 18                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a5b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113a5e:	8a 00                	mov    (%eax),%al
f0113a60:	3c 66                	cmp    $0x66,%al
f0113a62:	75 0f                	jne    f0113a73 <test_copy_paste_chunk+0xbe3>
f0113a64:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113a67:	8a 10                	mov    (%eax),%dl
f0113a69:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113a6f:	38 c2                	cmp    %al,%dl
f0113a71:	74 21                	je     f0113a94 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113a73:	83 ec 04             	sub    $0x4,%esp
f0113a76:	68 58 9a 12 f0       	push   $0xf0129a58
f0113a7b:	68 77 03 00 00       	push   $0x377
f0113a80:	68 62 92 12 f0       	push   $0xf0129262
f0113a85:	e8 4c ca fe ff       	call   f01004d6 <_warn>
f0113a8a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113a94:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113a98:	74 04                	je     f0113a9e <test_copy_paste_chunk+0xc0e>
f0113a9a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113a9e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113aa5:	83 ec 0c             	sub    $0xc,%esp
f0113aa8:	68 ef 9b 12 f0       	push   $0xf0129bef
f0113aad:	e8 d9 d4 fe ff       	call   f0100f8b <cprintf>
f0113ab2:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0113ab5:	83 ec 0c             	sub    $0xc,%esp
f0113ab8:	68 00 9c 12 f0       	push   $0xf0129c00
f0113abd:	e8 c9 d4 fe ff       	call   f0100f8b <cprintf>
f0113ac2:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113ac5:	83 ec 04             	sub    $0x4,%esp
f0113ac8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ace:	50                   	push   %eax
f0113acf:	68 34 9c 12 f0       	push   $0xf0129c34
f0113ad4:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ada:	50                   	push   %eax
f0113adb:	e8 75 c7 00 00       	call   f0120255 <strcconcat>
f0113ae0:	83 c4 10             	add    $0x10,%esp
f0113ae3:	83 ec 0c             	sub    $0xc,%esp
f0113ae6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113aec:	50                   	push   %eax
f0113aed:	e8 09 e4 fe ff       	call   f0101efb <execute_command>
f0113af2:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113af5:	83 ec 04             	sub    $0x4,%esp
f0113af8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113afe:	50                   	push   %eax
f0113aff:	68 3e 9c 12 f0       	push   $0xf0129c3e
f0113b04:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113b0a:	50                   	push   %eax
f0113b0b:	e8 45 c7 00 00       	call   f0120255 <strcconcat>
f0113b10:	83 c4 10             	add    $0x10,%esp
f0113b13:	83 ec 0c             	sub    $0xc,%esp
f0113b16:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113b1c:	50                   	push   %eax
f0113b1d:	e8 d9 e3 fe ff       	call   f0101efb <execute_command>
f0113b22:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113b25:	83 ec 04             	sub    $0x4,%esp
f0113b28:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113b2e:	50                   	push   %eax
f0113b2f:	68 48 9c 12 f0       	push   $0xf0129c48
f0113b34:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113b3a:	50                   	push   %eax
f0113b3b:	e8 15 c7 00 00       	call   f0120255 <strcconcat>
f0113b40:	83 c4 10             	add    $0x10,%esp
f0113b43:	83 ec 0c             	sub    $0xc,%esp
f0113b46:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113b4c:	50                   	push   %eax
f0113b4d:	e8 a9 e3 fe ff       	call   f0101efb <execute_command>
f0113b52:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113b55:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113b5b:	bb e1 a3 12 f0       	mov    $0xf012a3e1,%ebx
f0113b60:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b65:	89 c7                	mov    %eax,%edi
f0113b67:	89 de                	mov    %ebx,%esi
f0113b69:	89 d1                	mov    %edx,%ecx
f0113b6b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b6d:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113b73:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b78:	b0 00                	mov    $0x0,%al
f0113b7a:	89 d7                	mov    %edx,%edi
f0113b7c:	f3 aa                	rep stos %al,%es:(%edi)
f0113b7e:	83 ec 0c             	sub    $0xc,%esp
f0113b81:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113b87:	50                   	push   %eax
f0113b88:	e8 6e e3 fe ff       	call   f0101efb <execute_command>
f0113b8d:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0113b90:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b96:	bb 45 a4 12 f0       	mov    $0xf012a445,%ebx
f0113b9b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ba0:	89 c7                	mov    %eax,%edi
f0113ba2:	89 de                	mov    %ebx,%esi
f0113ba4:	89 d1                	mov    %edx,%ecx
f0113ba6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ba8:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113bae:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113bb3:	b0 00                	mov    $0x0,%al
f0113bb5:	89 d7                	mov    %edx,%edi
f0113bb7:	f3 aa                	rep stos %al,%es:(%edi)
f0113bb9:	83 ec 0c             	sub    $0xc,%esp
f0113bbc:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113bc2:	50                   	push   %eax
f0113bc3:	e8 33 e3 fe ff       	call   f0101efb <execute_command>
f0113bc8:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0113bcb:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113bd1:	bb a9 a4 12 f0       	mov    $0xf012a4a9,%ebx
f0113bd6:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113bdb:	89 c7                	mov    %eax,%edi
f0113bdd:	89 de                	mov    %ebx,%esi
f0113bdf:	89 d1                	mov    %edx,%ecx
f0113be1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113be3:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113be9:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113bee:	b0 00                	mov    $0x0,%al
f0113bf0:	89 d7                	mov    %edx,%edi
f0113bf2:	f3 aa                	rep stos %al,%es:(%edi)
f0113bf4:	83 ec 0c             	sub    $0xc,%esp
f0113bf7:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113bfd:	50                   	push   %eax
f0113bfe:	e8 f8 e2 fe ff       	call   f0101efb <execute_command>
f0113c03:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113c06:	e8 b1 ad ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0113c0b:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0113c0e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113c11:	89 d0                	mov    %edx,%eax
f0113c13:	01 c0                	add    %eax,%eax
f0113c15:	01 d0                	add    %edx,%eax
f0113c17:	c1 e0 02             	shl    $0x2,%eax
f0113c1a:	50                   	push   %eax
f0113c1b:	68 00 00 90 00       	push   $0x900000
f0113c20:	68 00 00 80 00       	push   $0x800000
f0113c25:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113c28:	e8 47 6f ff ff       	call   f010ab74 <copy_paste_chunk>
f0113c2d:	83 c4 10             	add    $0x10,%esp
f0113c30:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113c36:	e8 81 ad ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0113c3b:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113c3e:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113c45:	75 0b                	jne    f0113c52 <test_copy_paste_chunk+0xdc2>
f0113c47:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113c4a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113c4d:	83 f8 03             	cmp    $0x3,%eax
f0113c50:	74 2e                	je     f0113c80 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113c52:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113c55:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113c58:	83 ec 0c             	sub    $0xc,%esp
f0113c5b:	50                   	push   %eax
f0113c5c:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113c62:	68 04 9b 12 f0       	push   $0xf0129b04
f0113c67:	68 95 03 00 00       	push   $0x395
f0113c6c:	68 62 92 12 f0       	push   $0xf0129262
f0113c71:	e8 60 c8 fe ff       	call   f01004d6 <_warn>
f0113c76:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113c79:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113c80:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c84:	74 04                	je     f0113c8a <test_copy_paste_chunk+0xdfa>
f0113c86:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c8a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0113c91:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113c98:	83 ec 08             	sub    $0x8,%esp
f0113c9b:	6a 01                	push   $0x1
f0113c9d:	6a 07                	push   $0x7
f0113c9f:	6a 07                	push   $0x7
f0113ca1:	6a 07                	push   $0x7
f0113ca3:	6a 07                	push   $0x7
f0113ca5:	6a 01                	push   $0x1
f0113ca7:	68 00 30 00 00       	push   $0x3000
f0113cac:	68 00 00 90 00       	push   $0x900000
f0113cb1:	68 00 00 80 00       	push   $0x800000
f0113cb6:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113cb9:	e8 26 2e 00 00       	call   f0116ae4 <CCP>
f0113cbe:	83 c4 30             	add    $0x30,%esp
f0113cc1:	83 f8 01             	cmp    $0x1,%eax
f0113cc4:	74 28                	je     f0113cee <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113cc6:	83 ec 04             	sub    $0x4,%esp
f0113cc9:	68 a4 9b 12 f0       	push   $0xf0129ba4
f0113cce:	68 9e 03 00 00       	push   $0x39e
f0113cd3:	68 62 92 12 f0       	push   $0xf0129262
f0113cd8:	e8 f9 c7 fe ff       	call   f01004d6 <_warn>
f0113cdd:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ce0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113ce7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0113cee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113cf2:	74 04                	je     f0113cf8 <test_copy_paste_chunk+0xe68>
f0113cf4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113cf8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113cff:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113d03:	0f 84 9e 00 00 00    	je     f0113da7 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113d09:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113d10:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113d17:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113d1e:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113d25:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113d2c:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113d33:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d36:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113d39:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d3c:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113d3f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113d42:	8a 00                	mov    (%eax),%al
f0113d44:	3c 61                	cmp    $0x61,%al
f0113d46:	75 2d                	jne    f0113d75 <test_copy_paste_chunk+0xee5>
f0113d48:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113d4b:	8a 00                	mov    (%eax),%al
f0113d4d:	3c 61                	cmp    $0x61,%al
f0113d4f:	75 24                	jne    f0113d75 <test_copy_paste_chunk+0xee5>
f0113d51:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d54:	8a 00                	mov    (%eax),%al
f0113d56:	3c 79                	cmp    $0x79,%al
f0113d58:	75 1b                	jne    f0113d75 <test_copy_paste_chunk+0xee5>
f0113d5a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113d5d:	8a 00                	mov    (%eax),%al
f0113d5f:	3c 62                	cmp    $0x62,%al
f0113d61:	75 12                	jne    f0113d75 <test_copy_paste_chunk+0xee5>
f0113d63:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113d66:	8a 00                	mov    (%eax),%al
f0113d68:	3c 63                	cmp    $0x63,%al
f0113d6a:	75 09                	jne    f0113d75 <test_copy_paste_chunk+0xee5>
f0113d6c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d6f:	8a 00                	mov    (%eax),%al
f0113d71:	3c 7a                	cmp    $0x7a,%al
f0113d73:	74 21                	je     f0113d96 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113d75:	83 ec 04             	sub    $0x4,%esp
f0113d78:	68 58 9a 12 f0       	push   $0xf0129a58
f0113d7d:	68 b0 03 00 00       	push   $0x3b0
f0113d82:	68 62 92 12 f0       	push   $0xf0129262
f0113d87:	e8 4a c7 fe ff       	call   f01004d6 <_warn>
f0113d8c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113d8f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113d96:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113d9a:	74 04                	je     f0113da0 <test_copy_paste_chunk+0xf10>
f0113d9c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113da0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113da7:	e8 10 ac ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0113dac:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0113daf:	6a 00                	push   $0x0
f0113db1:	6a 02                	push   $0x2
f0113db3:	68 00 10 90 00       	push   $0x901000
f0113db8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dbb:	e8 b1 2b 00 00       	call   f0116971 <SB>
f0113dc0:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0113dc3:	6a 00                	push   $0x0
f0113dc5:	6a 02                	push   $0x2
f0113dc7:	68 00 20 90 00       	push   $0x902000
f0113dcc:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dcf:	e8 9d 2b 00 00       	call   f0116971 <SB>
f0113dd4:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0113dd7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113dda:	c1 e0 03             	shl    $0x3,%eax
f0113ddd:	50                   	push   %eax
f0113dde:	68 00 f0 bf 00       	push   $0xbff000
f0113de3:	68 00 10 90 00       	push   $0x901000
f0113de8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113deb:	e8 84 6d ff ff       	call   f010ab74 <copy_paste_chunk>
f0113df0:	83 c4 10             	add    $0x10,%esp
f0113df3:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113df9:	e8 be ab ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0113dfe:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113e01:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113e08:	75 0b                	jne    f0113e15 <test_copy_paste_chunk+0xf85>
f0113e0a:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113e0d:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113e10:	83 f8 03             	cmp    $0x3,%eax
f0113e13:	74 2e                	je     f0113e43 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113e15:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113e18:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113e1b:	83 ec 0c             	sub    $0xc,%esp
f0113e1e:	50                   	push   %eax
f0113e1f:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113e25:	68 04 9b 12 f0       	push   $0xf0129b04
f0113e2a:	68 c0 03 00 00       	push   $0x3c0
f0113e2f:	68 62 92 12 f0       	push   $0xf0129262
f0113e34:	e8 9d c6 fe ff       	call   f01004d6 <_warn>
f0113e39:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113e3c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113e43:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e47:	74 04                	je     f0113e4d <test_copy_paste_chunk+0xfbd>
f0113e49:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e4d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113e54:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113e5b:	83 ec 08             	sub    $0x8,%esp
f0113e5e:	6a 01                	push   $0x1
f0113e60:	6a 07                	push   $0x7
f0113e62:	6a 03                	push   $0x3
f0113e64:	6a 07                	push   $0x7
f0113e66:	6a 03                	push   $0x3
f0113e68:	6a 01                	push   $0x1
f0113e6a:	68 00 20 00 00       	push   $0x2000
f0113e6f:	68 00 f0 bf 00       	push   $0xbff000
f0113e74:	68 00 10 90 00       	push   $0x901000
f0113e79:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113e7c:	e8 63 2c 00 00       	call   f0116ae4 <CCP>
f0113e81:	83 c4 30             	add    $0x30,%esp
f0113e84:	83 f8 01             	cmp    $0x1,%eax
f0113e87:	74 28                	je     f0113eb1 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113e89:	83 ec 04             	sub    $0x4,%esp
f0113e8c:	68 a4 9b 12 f0       	push   $0xf0129ba4
f0113e91:	68 c9 03 00 00       	push   $0x3c9
f0113e96:	68 62 92 12 f0       	push   $0xf0129262
f0113e9b:	e8 36 c6 fe ff       	call   f01004d6 <_warn>
f0113ea0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ea3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113eaa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0113eb1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113eb5:	74 04                	je     f0113ebb <test_copy_paste_chunk+0x102b>
f0113eb7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113ebb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113ec2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113ec6:	74 72                	je     f0113f3a <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0113ec8:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0113ecf:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0113ed6:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0113edd:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0113ee4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113ee7:	8a 00                	mov    (%eax),%al
f0113ee9:	3c 62                	cmp    $0x62,%al
f0113eeb:	75 1b                	jne    f0113f08 <test_copy_paste_chunk+0x1078>
f0113eed:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113ef0:	8a 00                	mov    (%eax),%al
f0113ef2:	3c 62                	cmp    $0x62,%al
f0113ef4:	75 12                	jne    f0113f08 <test_copy_paste_chunk+0x1078>
f0113ef6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ef9:	8a 00                	mov    (%eax),%al
f0113efb:	3c 7a                	cmp    $0x7a,%al
f0113efd:	75 09                	jne    f0113f08 <test_copy_paste_chunk+0x1078>
f0113eff:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113f02:	8a 00                	mov    (%eax),%al
f0113f04:	3c 7a                	cmp    $0x7a,%al
f0113f06:	74 21                	je     f0113f29 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113f08:	83 ec 04             	sub    $0x4,%esp
f0113f0b:	68 58 9a 12 f0       	push   $0xf0129a58
f0113f10:	68 d5 03 00 00       	push   $0x3d5
f0113f15:	68 62 92 12 f0       	push   $0xf0129262
f0113f1a:	e8 b7 c5 fe ff       	call   f01004d6 <_warn>
f0113f1f:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113f22:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113f29:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f2d:	74 04                	je     f0113f33 <test_copy_paste_chunk+0x10a3>
f0113f2f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113f33:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113f3a:	83 ec 0c             	sub    $0xc,%esp
f0113f3d:	68 52 9c 12 f0       	push   $0xf0129c52
f0113f42:	e8 44 d0 fe ff       	call   f0100f8b <cprintf>
f0113f47:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113f4a:	83 ec 08             	sub    $0x8,%esp
f0113f4d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113f50:	68 64 9c 12 f0       	push   $0xf0129c64
f0113f55:	e8 31 d0 fe ff       	call   f0100f8b <cprintf>
f0113f5a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113f5d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113f61:	75 10                	jne    f0113f73 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113f63:	83 ec 0c             	sub    $0xc,%esp
f0113f66:	68 98 9c 12 f0       	push   $0xf0129c98
f0113f6b:	e8 1b d0 fe ff       	call   f0100f8b <cprintf>
f0113f70:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113f73:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0113f78:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113f7b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113f7e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113f81:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113f86:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113f89:	5b                   	pop    %ebx
f0113f8a:	5e                   	pop    %esi
f0113f8b:	5f                   	pop    %edi
f0113f8c:	5d                   	pop    %ebp
f0113f8d:	c3                   	ret    

f0113f8e <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0113f8e:	55                   	push   %ebp
f0113f8f:	89 e5                	mov    %esp,%ebp
f0113f91:	57                   	push   %edi
f0113f92:	56                   	push   %esi
f0113f93:	53                   	push   %ebx
f0113f94:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113f9a:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113fa0:	bb 64 99 12 f0       	mov    $0xf0129964,%ebx
f0113fa5:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113faa:	89 c7                	mov    %eax,%edi
f0113fac:	89 de                	mov    %ebx,%esi
f0113fae:	89 d1                	mov    %edx,%ecx
f0113fb0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113fb2:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0113fb8:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113fbd:	b0 00                	mov    $0x0,%al
f0113fbf:	89 d7                	mov    %edx,%edi
f0113fc1:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113fc3:	6a 00                	push   $0x0
f0113fc5:	6a 0a                	push   $0xa
f0113fc7:	6a 14                	push   $0x14
f0113fc9:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113fcf:	50                   	push   %eax
f0113fd0:	e8 46 70 ff ff       	call   f010b01b <env_create>
f0113fd5:	83 c4 10             	add    $0x10,%esp
f0113fd8:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113fdb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113fde:	8b 40 64             	mov    0x64(%eax),%eax
f0113fe1:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113fe4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113fe7:	8b 40 68             	mov    0x68(%eax),%eax
f0113fea:	89 45 80             	mov    %eax,-0x80(%ebp)
f0113fed:	8b 45 80             	mov    -0x80(%ebp),%eax
f0113ff0:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113ff3:	83 ec 0c             	sub    $0xc,%esp
f0113ff6:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ff9:	e8 b2 2a 00 00       	call   f0116ab0 <ClearUserSpace>
f0113ffe:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114001:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114008:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011400f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0114016:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f011401a:	83 ec 0c             	sub    $0xc,%esp
f011401d:	68 10 a5 12 f0       	push   $0xf012a510
f0114022:	e8 64 cf fe ff       	call   f0100f8b <cprintf>
f0114027:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f011402a:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0114031:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0114038:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011403b:	8a 00                	mov    (%eax),%al
f011403d:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0114043:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114046:	8a 00                	mov    (%eax),%al
f0114048:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011404e:	e8 69 a9 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114053:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0114056:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114059:	89 d0                	mov    %edx,%eax
f011405b:	01 c0                	add    %eax,%eax
f011405d:	01 d0                	add    %edx,%eax
f011405f:	01 c0                	add    %eax,%eax
f0114061:	83 ec 0c             	sub    $0xc,%esp
f0114064:	6a 02                	push   $0x2
f0114066:	50                   	push   %eax
f0114067:	68 00 40 10 f0       	push   $0xf0104000
f011406c:	68 00 00 10 f0       	push   $0xf0100000
f0114071:	ff 75 cc             	pushl  -0x34(%ebp)
f0114074:	e8 15 6b ff ff       	call   f010ab8e <share_chunk>
f0114079:	83 c4 20             	add    $0x20,%esp
f011407c:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011407f:	e8 38 a9 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114084:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114087:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f011408b:	75 08                	jne    f0114095 <test_share_chunk+0x107>
f011408d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114090:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114093:	74 28                	je     f01140bd <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0114095:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114098:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011409b:	83 ec 0c             	sub    $0xc,%esp
f011409e:	50                   	push   %eax
f011409f:	ff 75 b0             	pushl  -0x50(%ebp)
f01140a2:	68 3c a5 12 f0       	push   $0xf012a53c
f01140a7:	68 11 04 00 00       	push   $0x411
f01140ac:	68 62 92 12 f0       	push   $0xf0129262
f01140b1:	e8 20 c4 fe ff       	call   f01004d6 <_warn>
f01140b6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01140b9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01140bd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01140c1:	74 04                	je     f01140c7 <test_share_chunk+0x139>
f01140c3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01140c7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f01140cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01140ce:	c1 e0 03             	shl    $0x3,%eax
f01140d1:	83 ec 08             	sub    $0x8,%esp
f01140d4:	68 fd 00 00 00       	push   $0xfd
f01140d9:	6a 07                	push   $0x7
f01140db:	6a 03                	push   $0x3
f01140dd:	6a 07                	push   $0x7
f01140df:	6a 03                	push   $0x3
f01140e1:	6a 01                	push   $0x1
f01140e3:	50                   	push   %eax
f01140e4:	68 00 40 10 f0       	push   $0xf0104000
f01140e9:	68 00 00 10 f0       	push   $0xf0100000
f01140ee:	ff 75 cc             	pushl  -0x34(%ebp)
f01140f1:	e8 ee 29 00 00       	call   f0116ae4 <CCP>
f01140f6:	83 c4 30             	add    $0x30,%esp
f01140f9:	85 c0                	test   %eax,%eax
f01140fb:	75 1e                	jne    f011411b <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01140fd:	83 ec 04             	sub    $0x4,%esp
f0114100:	68 98 a5 12 f0       	push   $0xf012a598
f0114105:	68 19 04 00 00       	push   $0x419
f011410a:	68 62 92 12 f0       	push   $0xf0129262
f011410f:	e8 c2 c3 fe ff       	call   f01004d6 <_warn>
f0114114:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114117:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011411b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011411f:	74 04                	je     f0114125 <test_share_chunk+0x197>
f0114121:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0114125:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114128:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f011412b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011412e:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0114131:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114134:	8a 00                	mov    (%eax),%al
f0114136:	3c 41                	cmp    $0x41,%al
f0114138:	75 09                	jne    f0114143 <test_share_chunk+0x1b5>
f011413a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011413d:	8a 00                	mov    (%eax),%al
f011413f:	3c 42                	cmp    $0x42,%al
f0114141:	74 1e                	je     f0114161 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114143:	83 ec 04             	sub    $0x4,%esp
f0114146:	68 e0 a5 12 f0       	push   $0xf012a5e0
f011414b:	68 23 04 00 00       	push   $0x423
f0114150:	68 62 92 12 f0       	push   $0xf0129262
f0114155:	e8 7c c3 fe ff       	call   f01004d6 <_warn>
f011415a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011415d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114161:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114165:	74 04                	je     f011416b <test_share_chunk+0x1dd>
f0114167:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011416b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f011416f:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114175:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114178:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f011417a:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0114180:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114183:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114185:	83 ec 0c             	sub    $0xc,%esp
f0114188:	68 15 a6 12 f0       	push   $0xf012a615
f011418d:	e8 f9 cd fe ff       	call   f0100f8b <cprintf>
f0114192:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114195:	83 ec 0c             	sub    $0xc,%esp
f0114198:	68 24 a6 12 f0       	push   $0xf012a624
f011419d:	e8 e9 cd fe ff       	call   f0100f8b <cprintf>
f01141a2:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01141a5:	e8 12 a8 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01141aa:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f01141ad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01141b0:	c1 e0 05             	shl    $0x5,%eax
f01141b3:	83 ec 0c             	sub    $0xc,%esp
f01141b6:	68 02 0e 00 00       	push   $0xe02
f01141bb:	50                   	push   %eax
f01141bc:	68 00 00 00 40       	push   $0x40000000
f01141c1:	68 00 00 00 f0       	push   $0xf0000000
f01141c6:	ff 75 cc             	pushl  -0x34(%ebp)
f01141c9:	e8 c0 69 ff ff       	call   f010ab8e <share_chunk>
f01141ce:	83 c4 20             	add    $0x20,%esp
f01141d1:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01141d4:	e8 e3 a7 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01141d9:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f01141dc:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01141e0:	75 1f                	jne    f0114201 <test_share_chunk+0x273>
f01141e2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141e5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01141e8:	89 c1                	mov    %eax,%ecx
f01141ea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01141ed:	c1 e0 05             	shl    $0x5,%eax
f01141f0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01141f3:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01141fa:	99                   	cltd   
f01141fb:	f7 fb                	idiv   %ebx
f01141fd:	39 c1                	cmp    %eax,%ecx
f01141ff:	74 28                	je     f0114229 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114201:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114204:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114207:	83 ec 0c             	sub    $0xc,%esp
f011420a:	50                   	push   %eax
f011420b:	ff 75 a8             	pushl  -0x58(%ebp)
f011420e:	68 60 a6 12 f0       	push   $0xf012a660
f0114213:	68 3b 04 00 00       	push   $0x43b
f0114218:	68 62 92 12 f0       	push   $0xf0129262
f011421d:	e8 b4 c2 fe ff       	call   f01004d6 <_warn>
f0114222:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114225:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114229:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011422d:	74 04                	je     f0114233 <test_share_chunk+0x2a5>
f011422f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114233:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114237:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011423e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114241:	c1 e0 05             	shl    $0x5,%eax
f0114244:	83 ec 08             	sub    $0x8,%esp
f0114247:	6a 02                	push   $0x2
f0114249:	6a 07                	push   $0x7
f011424b:	6a 03                	push   $0x3
f011424d:	68 07 0e 00 00       	push   $0xe07
f0114252:	68 03 0e 00 00       	push   $0xe03
f0114257:	6a ff                	push   $0xffffffff
f0114259:	50                   	push   %eax
f011425a:	68 00 00 00 40       	push   $0x40000000
f011425f:	68 00 00 00 f0       	push   $0xf0000000
f0114264:	ff 75 cc             	pushl  -0x34(%ebp)
f0114267:	e8 78 28 00 00       	call   f0116ae4 <CCP>
f011426c:	83 c4 30             	add    $0x30,%esp
f011426f:	85 c0                	test   %eax,%eax
f0114271:	75 25                	jne    f0114298 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114273:	83 ec 04             	sub    $0x4,%esp
f0114276:	68 98 a5 12 f0       	push   $0xf012a598
f011427b:	68 44 04 00 00       	push   $0x444
f0114280:	68 62 92 12 f0       	push   $0xf0129262
f0114285:	e8 4c c2 fe ff       	call   f01004d6 <_warn>
f011428a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011428d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114291:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114298:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011429b:	89 d0                	mov    %edx,%eax
f011429d:	01 c0                	add    %eax,%eax
f011429f:	01 d0                	add    %edx,%eax
f01142a1:	c1 e0 02             	shl    $0x2,%eax
f01142a4:	83 ec 08             	sub    $0x8,%esp
f01142a7:	6a 02                	push   $0x2
f01142a9:	6a 07                	push   $0x7
f01142ab:	6a 03                	push   $0x3
f01142ad:	68 07 0e 00 00       	push   $0xe07
f01142b2:	68 03 0e 00 00       	push   $0xe03
f01142b7:	6a 02                	push   $0x2
f01142b9:	50                   	push   %eax
f01142ba:	68 00 00 00 40       	push   $0x40000000
f01142bf:	68 00 00 00 f0       	push   $0xf0000000
f01142c4:	ff 75 cc             	pushl  -0x34(%ebp)
f01142c7:	e8 18 28 00 00       	call   f0116ae4 <CCP>
f01142cc:	83 c4 30             	add    $0x30,%esp
f01142cf:	85 c0                	test   %eax,%eax
f01142d1:	75 1e                	jne    f01142f1 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01142d3:	83 ec 04             	sub    $0x4,%esp
f01142d6:	68 98 a5 12 f0       	push   $0xf012a598
f01142db:	68 4b 04 00 00       	push   $0x44b
f01142e0:	68 62 92 12 f0       	push   $0xf0129262
f01142e5:	e8 ec c1 fe ff       	call   f01004d6 <_warn>
f01142ea:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01142ed:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01142f1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142f5:	74 04                	je     f01142fb <test_share_chunk+0x36d>
f01142f7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142fb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f01142ff:	b8 d0 d7 b0 f0       	mov    $0xf0b0d7d0,%eax
f0114304:	05 00 00 00 10       	add    $0x10000000,%eax
f0114309:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011430c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011430f:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0114314:	83 ec 08             	sub    $0x8,%esp
f0114317:	6a 02                	push   $0x2
f0114319:	6a 07                	push   $0x7
f011431b:	6a 03                	push   $0x3
f011431d:	68 07 0e 00 00       	push   $0xe07
f0114322:	68 03 0e 00 00       	push   $0xe03
f0114327:	6a 02                	push   $0x2
f0114329:	50                   	push   %eax
f011432a:	68 00 00 0a 40       	push   $0x400a0000
f011432f:	68 00 00 0a f0       	push   $0xf00a0000
f0114334:	ff 75 cc             	pushl  -0x34(%ebp)
f0114337:	e8 a8 27 00 00       	call   f0116ae4 <CCP>
f011433c:	83 c4 30             	add    $0x30,%esp
f011433f:	85 c0                	test   %eax,%eax
f0114341:	75 1e                	jne    f0114361 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114343:	83 ec 04             	sub    $0x4,%esp
f0114346:	68 98 a5 12 f0       	push   $0xf012a598
f011434b:	68 55 04 00 00       	push   $0x455
f0114350:	68 62 92 12 f0       	push   $0xf0129262
f0114355:	e8 7c c1 fe ff       	call   f01004d6 <_warn>
f011435a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011435d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114361:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114365:	74 04                	je     f011436b <test_share_chunk+0x3dd>
f0114367:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011436b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011436f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114373:	0f 84 a4 00 00 00    	je     f011441d <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114379:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0114380:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114383:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114386:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f011438d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114390:	8a 00                	mov    (%eax),%al
f0114392:	3c 41                	cmp    $0x41,%al
f0114394:	75 09                	jne    f011439f <test_share_chunk+0x411>
f0114396:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114399:	8a 00                	mov    (%eax),%al
f011439b:	3c 41                	cmp    $0x41,%al
f011439d:	74 1e                	je     f01143bd <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011439f:	83 ec 04             	sub    $0x4,%esp
f01143a2:	68 e0 a5 12 f0       	push   $0xf012a5e0
f01143a7:	68 62 04 00 00       	push   $0x462
f01143ac:	68 62 92 12 f0       	push   $0xf0129262
f01143b1:	e8 20 c1 fe ff       	call   f01004d6 <_warn>
f01143b6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01143b9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01143bd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143c1:	74 04                	je     f01143c7 <test_share_chunk+0x439>
f01143c3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01143c7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f01143cb:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f01143d2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01143d5:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f01143d8:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f01143df:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01143e2:	8a 00                	mov    (%eax),%al
f01143e4:	3c 43                	cmp    $0x43,%al
f01143e6:	75 09                	jne    f01143f1 <test_share_chunk+0x463>
f01143e8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01143eb:	8a 00                	mov    (%eax),%al
f01143ed:	3c 43                	cmp    $0x43,%al
f01143ef:	74 1e                	je     f011440f <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01143f1:	83 ec 04             	sub    $0x4,%esp
f01143f4:	68 e0 a5 12 f0       	push   $0xf012a5e0
f01143f9:	68 6d 04 00 00       	push   $0x46d
f01143fe:	68 62 92 12 f0       	push   $0xf0129262
f0114403:	e8 ce c0 fe ff       	call   f01004d6 <_warn>
f0114408:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011440b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011440f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114413:	74 04                	je     f0114419 <test_share_chunk+0x48b>
f0114415:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114419:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f011441d:	83 ec 0c             	sub    $0xc,%esp
f0114420:	68 ef 9b 12 f0       	push   $0xf0129bef
f0114425:	e8 61 cb fe ff       	call   f0100f8b <cprintf>
f011442a:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f011442d:	83 ec 0c             	sub    $0xc,%esp
f0114430:	68 b0 a6 12 f0       	push   $0xf012a6b0
f0114435:	e8 51 cb fe ff       	call   f0100f8b <cprintf>
f011443a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011443d:	e8 7a a5 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114442:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0114445:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114448:	89 d0                	mov    %edx,%eax
f011444a:	c1 e0 03             	shl    $0x3,%eax
f011444d:	01 d0                	add    %edx,%eax
f011444f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0114456:	01 d0                	add    %edx,%eax
f0114458:	c1 e0 03             	shl    $0x3,%eax
f011445b:	83 ec 0c             	sub    $0xc,%esp
f011445e:	6a 06                	push   $0x6
f0114460:	50                   	push   %eax
f0114461:	6a 00                	push   $0x0
f0114463:	68 00 00 00 40       	push   $0x40000000
f0114468:	ff 75 cc             	pushl  -0x34(%ebp)
f011446b:	e8 1e 67 ff ff       	call   f010ab8e <share_chunk>
f0114470:	83 c4 20             	add    $0x20,%esp
f0114473:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114476:	e8 41 a5 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011447b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011447e:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114482:	75 0b                	jne    f011448f <test_share_chunk+0x501>
f0114484:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114487:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011448a:	83 f8 01             	cmp    $0x1,%eax
f011448d:	74 28                	je     f01144b7 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011448f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114492:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114495:	83 ec 0c             	sub    $0xc,%esp
f0114498:	50                   	push   %eax
f0114499:	ff 75 a0             	pushl  -0x60(%ebp)
f011449c:	68 60 a6 12 f0       	push   $0xf012a660
f01144a1:	68 83 04 00 00       	push   $0x483
f01144a6:	68 62 92 12 f0       	push   $0xf0129262
f01144ab:	e8 26 c0 fe ff       	call   f01004d6 <_warn>
f01144b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01144b3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01144b7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144bb:	74 04                	je     f01144c1 <test_share_chunk+0x533>
f01144bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144c1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01144c5:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01144cc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01144cf:	05 00 80 02 00       	add    $0x28000,%eax
f01144d4:	c1 e0 02             	shl    $0x2,%eax
f01144d7:	83 ec 08             	sub    $0x8,%esp
f01144da:	6a 02                	push   $0x2
f01144dc:	6a 07                	push   $0x7
f01144de:	6a 03                	push   $0x3
f01144e0:	6a 07                	push   $0x7
f01144e2:	6a 07                	push   $0x7
f01144e4:	6a ff                	push   $0xffffffff
f01144e6:	50                   	push   %eax
f01144e7:	6a 00                	push   $0x0
f01144e9:	68 00 00 00 40       	push   $0x40000000
f01144ee:	ff 75 cc             	pushl  -0x34(%ebp)
f01144f1:	e8 ee 25 00 00       	call   f0116ae4 <CCP>
f01144f6:	83 c4 30             	add    $0x30,%esp
f01144f9:	85 c0                	test   %eax,%eax
f01144fb:	75 25                	jne    f0114522 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01144fd:	83 ec 04             	sub    $0x4,%esp
f0114500:	68 98 a5 12 f0       	push   $0xf012a598
f0114505:	68 8c 04 00 00       	push   $0x48c
f011450a:	68 62 92 12 f0       	push   $0xf0129262
f011450f:	e8 c2 bf fe ff       	call   f01004d6 <_warn>
f0114514:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114517:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011451b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114522:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114525:	89 d0                	mov    %edx,%eax
f0114527:	01 c0                	add    %eax,%eax
f0114529:	01 d0                	add    %edx,%eax
f011452b:	c1 e0 02             	shl    $0x2,%eax
f011452e:	83 ec 08             	sub    $0x8,%esp
f0114531:	6a 02                	push   $0x2
f0114533:	6a 07                	push   $0x7
f0114535:	6a 03                	push   $0x3
f0114537:	6a 07                	push   $0x7
f0114539:	6a 07                	push   $0x7
f011453b:	6a 03                	push   $0x3
f011453d:	50                   	push   %eax
f011453e:	6a 00                	push   $0x0
f0114540:	68 00 00 00 40       	push   $0x40000000
f0114545:	ff 75 cc             	pushl  -0x34(%ebp)
f0114548:	e8 97 25 00 00       	call   f0116ae4 <CCP>
f011454d:	83 c4 30             	add    $0x30,%esp
f0114550:	85 c0                	test   %eax,%eax
f0114552:	75 1e                	jne    f0114572 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114554:	83 ec 04             	sub    $0x4,%esp
f0114557:	68 98 a5 12 f0       	push   $0xf012a598
f011455c:	68 93 04 00 00       	push   $0x493
f0114561:	68 62 92 12 f0       	push   $0xf0129262
f0114566:	e8 6b bf fe ff       	call   f01004d6 <_warn>
f011456b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011456e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114572:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114576:	74 04                	je     f011457c <test_share_chunk+0x5ee>
f0114578:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011457c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114580:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114583:	89 d0                	mov    %edx,%eax
f0114585:	01 c0                	add    %eax,%eax
f0114587:	01 d0                	add    %edx,%eax
f0114589:	c1 e0 02             	shl    $0x2,%eax
f011458c:	f7 d8                	neg    %eax
f011458e:	05 00 00 0a 00       	add    $0xa0000,%eax
f0114593:	83 ec 08             	sub    $0x8,%esp
f0114596:	6a 02                	push   $0x2
f0114598:	6a 07                	push   $0x7
f011459a:	6a 03                	push   $0x3
f011459c:	6a 07                	push   $0x7
f011459e:	6a 07                	push   $0x7
f01145a0:	6a 02                	push   $0x2
f01145a2:	50                   	push   %eax
f01145a3:	68 00 30 00 00       	push   $0x3000
f01145a8:	68 00 30 00 40       	push   $0x40003000
f01145ad:	ff 75 cc             	pushl  -0x34(%ebp)
f01145b0:	e8 2f 25 00 00       	call   f0116ae4 <CCP>
f01145b5:	83 c4 30             	add    $0x30,%esp
f01145b8:	85 c0                	test   %eax,%eax
f01145ba:	75 1e                	jne    f01145da <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01145bc:	83 ec 04             	sub    $0x4,%esp
f01145bf:	68 98 a5 12 f0       	push   $0xf012a598
f01145c4:	68 9b 04 00 00       	push   $0x49b
f01145c9:	68 62 92 12 f0       	push   $0xf0129262
f01145ce:	e8 03 bf fe ff       	call   f01004d6 <_warn>
f01145d3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145d6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145da:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145de:	74 04                	je     f01145e4 <test_share_chunk+0x656>
f01145e0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01145e4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01145e8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01145eb:	c1 e0 02             	shl    $0x2,%eax
f01145ee:	83 ec 08             	sub    $0x8,%esp
f01145f1:	6a 02                	push   $0x2
f01145f3:	6a 07                	push   $0x7
f01145f5:	6a 03                	push   $0x3
f01145f7:	6a 07                	push   $0x7
f01145f9:	6a 07                	push   $0x7
f01145fb:	6a 03                	push   $0x3
f01145fd:	50                   	push   %eax
f01145fe:	68 00 00 0a 00       	push   $0xa0000
f0114603:	68 00 00 0a 40       	push   $0x400a0000
f0114608:	ff 75 cc             	pushl  -0x34(%ebp)
f011460b:	e8 d4 24 00 00       	call   f0116ae4 <CCP>
f0114610:	83 c4 30             	add    $0x30,%esp
f0114613:	85 c0                	test   %eax,%eax
f0114615:	75 1e                	jne    f0114635 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114617:	83 ec 04             	sub    $0x4,%esp
f011461a:	68 98 a5 12 f0       	push   $0xf012a598
f011461f:	68 a3 04 00 00       	push   $0x4a3
f0114624:	68 62 92 12 f0       	push   $0xf0129262
f0114629:	e8 a8 be fe ff       	call   f01004d6 <_warn>
f011462e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114631:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114635:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114639:	74 04                	je     f011463f <test_share_chunk+0x6b1>
f011463b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011463f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114643:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114647:	0f 84 92 00 00 00    	je     f01146df <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f011464d:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114654:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f011465b:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0114662:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0114669:	8b 45 98             	mov    -0x68(%ebp),%eax
f011466c:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f011466f:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114676:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011467d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114680:	8a 00                	mov    (%eax),%al
f0114682:	3c 41                	cmp    $0x41,%al
f0114684:	75 2d                	jne    f01146b3 <test_share_chunk+0x725>
f0114686:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114689:	8a 00                	mov    (%eax),%al
f011468b:	3c 41                	cmp    $0x41,%al
f011468d:	75 24                	jne    f01146b3 <test_share_chunk+0x725>
f011468f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114692:	8a 00                	mov    (%eax),%al
f0114694:	3c 41                	cmp    $0x41,%al
f0114696:	75 1b                	jne    f01146b3 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114698:	8b 45 98             	mov    -0x68(%ebp),%eax
f011469b:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011469d:	3c 44                	cmp    $0x44,%al
f011469f:	75 12                	jne    f01146b3 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01146a1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01146a4:	8a 00                	mov    (%eax),%al
f01146a6:	3c 44                	cmp    $0x44,%al
f01146a8:	75 09                	jne    f01146b3 <test_share_chunk+0x725>
f01146aa:	8b 45 90             	mov    -0x70(%ebp),%eax
f01146ad:	8a 00                	mov    (%eax),%al
f01146af:	3c 44                	cmp    $0x44,%al
f01146b1:	74 1e                	je     f01146d1 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01146b3:	83 ec 04             	sub    $0x4,%esp
f01146b6:	68 e0 a5 12 f0       	push   $0xf012a5e0
f01146bb:	68 b5 04 00 00       	push   $0x4b5
f01146c0:	68 62 92 12 f0       	push   $0xf0129262
f01146c5:	e8 0c be fe ff       	call   f01004d6 <_warn>
f01146ca:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01146cd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01146d1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146d5:	74 04                	je     f01146db <test_share_chunk+0x74d>
f01146d7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01146db:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01146df:	83 ec 0c             	sub    $0xc,%esp
f01146e2:	68 52 9c 12 f0       	push   $0xf0129c52
f01146e7:	e8 9f c8 fe ff       	call   f0100f8b <cprintf>
f01146ec:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f01146ef:	83 ec 0c             	sub    $0xc,%esp
f01146f2:	68 ec a6 12 f0       	push   $0xf012a6ec
f01146f7:	e8 8f c8 fe ff       	call   f0100f8b <cprintf>
f01146fc:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01146ff:	e8 b8 a2 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114704:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114707:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011470a:	89 d0                	mov    %edx,%eax
f011470c:	01 c0                	add    %eax,%eax
f011470e:	01 d0                	add    %edx,%eax
f0114710:	01 c0                	add    %eax,%eax
f0114712:	01 d0                	add    %edx,%eax
f0114714:	83 ec 0c             	sub    $0xc,%esp
f0114717:	6a 04                	push   $0x4
f0114719:	50                   	push   %eax
f011471a:	68 00 fc 3f 00       	push   $0x3ffc00
f011471f:	68 00 fc 09 00       	push   $0x9fc00
f0114724:	ff 75 cc             	pushl  -0x34(%ebp)
f0114727:	e8 62 64 ff ff       	call   f010ab8e <share_chunk>
f011472c:	83 c4 20             	add    $0x20,%esp
f011472f:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114732:	e8 85 a2 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114737:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011473a:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f011473e:	75 0b                	jne    f011474b <test_share_chunk+0x7bd>
f0114740:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114743:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114746:	83 f8 01             	cmp    $0x1,%eax
f0114749:	74 28                	je     f0114773 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011474b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011474e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114751:	83 ec 0c             	sub    $0xc,%esp
f0114754:	50                   	push   %eax
f0114755:	ff 75 8c             	pushl  -0x74(%ebp)
f0114758:	68 60 a6 12 f0       	push   $0xf012a660
f011475d:	68 cb 04 00 00       	push   $0x4cb
f0114762:	68 62 92 12 f0       	push   $0xf0129262
f0114767:	e8 6a bd fe ff       	call   f01004d6 <_warn>
f011476c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011476f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114773:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114777:	74 04                	je     f011477d <test_share_chunk+0x7ef>
f0114779:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011477d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114781:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114788:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011478b:	89 d0                	mov    %edx,%eax
f011478d:	01 c0                	add    %eax,%eax
f011478f:	01 d0                	add    %edx,%eax
f0114791:	c1 e0 02             	shl    $0x2,%eax
f0114794:	83 ec 08             	sub    $0x8,%esp
f0114797:	6a 02                	push   $0x2
f0114799:	6a 07                	push   $0x7
f011479b:	6a 07                	push   $0x7
f011479d:	6a 07                	push   $0x7
f011479f:	6a 05                	push   $0x5
f01147a1:	6a ff                	push   $0xffffffff
f01147a3:	50                   	push   %eax
f01147a4:	68 00 f0 3f 00       	push   $0x3ff000
f01147a9:	68 00 f0 09 00       	push   $0x9f000
f01147ae:	ff 75 cc             	pushl  -0x34(%ebp)
f01147b1:	e8 2e 23 00 00       	call   f0116ae4 <CCP>
f01147b6:	83 c4 30             	add    $0x30,%esp
f01147b9:	85 c0                	test   %eax,%eax
f01147bb:	75 25                	jne    f01147e2 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01147bd:	83 ec 04             	sub    $0x4,%esp
f01147c0:	68 98 a5 12 f0       	push   $0xf012a598
f01147c5:	68 d4 04 00 00       	push   $0x4d4
f01147ca:	68 62 92 12 f0       	push   $0xf0129262
f01147cf:	e8 02 bd fe ff       	call   f01004d6 <_warn>
f01147d4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147d7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01147db:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01147e2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147e6:	74 04                	je     f01147ec <test_share_chunk+0x85e>
f01147e8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147ec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01147f0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01147f3:	c1 e0 02             	shl    $0x2,%eax
f01147f6:	83 ec 08             	sub    $0x8,%esp
f01147f9:	6a 02                	push   $0x2
f01147fb:	6a 07                	push   $0x7
f01147fd:	6a 07                	push   $0x7
f01147ff:	6a 07                	push   $0x7
f0114801:	6a 05                	push   $0x5
f0114803:	6a 03                	push   $0x3
f0114805:	50                   	push   %eax
f0114806:	68 00 f0 3f 00       	push   $0x3ff000
f011480b:	68 00 f0 09 00       	push   $0x9f000
f0114810:	ff 75 cc             	pushl  -0x34(%ebp)
f0114813:	e8 cc 22 00 00       	call   f0116ae4 <CCP>
f0114818:	83 c4 30             	add    $0x30,%esp
f011481b:	85 c0                	test   %eax,%eax
f011481d:	75 1e                	jne    f011483d <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011481f:	83 ec 04             	sub    $0x4,%esp
f0114822:	68 98 a5 12 f0       	push   $0xf012a598
f0114827:	68 dd 04 00 00       	push   $0x4dd
f011482c:	68 62 92 12 f0       	push   $0xf0129262
f0114831:	e8 a0 bc fe ff       	call   f01004d6 <_warn>
f0114836:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114839:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011483d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114841:	74 04                	je     f0114847 <test_share_chunk+0x8b9>
f0114843:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114847:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011484b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011484e:	c1 e0 03             	shl    $0x3,%eax
f0114851:	83 ec 08             	sub    $0x8,%esp
f0114854:	6a 02                	push   $0x2
f0114856:	6a 07                	push   $0x7
f0114858:	6a 07                	push   $0x7
f011485a:	6a 07                	push   $0x7
f011485c:	6a 05                	push   $0x5
f011485e:	6a 04                	push   $0x4
f0114860:	50                   	push   %eax
f0114861:	68 00 00 40 00       	push   $0x400000
f0114866:	68 00 00 0a 00       	push   $0xa0000
f011486b:	ff 75 cc             	pushl  -0x34(%ebp)
f011486e:	e8 71 22 00 00       	call   f0116ae4 <CCP>
f0114873:	83 c4 30             	add    $0x30,%esp
f0114876:	85 c0                	test   %eax,%eax
f0114878:	75 1e                	jne    f0114898 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011487a:	83 ec 04             	sub    $0x4,%esp
f011487d:	68 98 a5 12 f0       	push   $0xf012a598
f0114882:	68 e5 04 00 00       	push   $0x4e5
f0114887:	68 62 92 12 f0       	push   $0xf0129262
f011488c:	e8 45 bc fe ff       	call   f01004d6 <_warn>
f0114891:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114894:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114898:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011489c:	74 04                	je     f01148a2 <test_share_chunk+0x914>
f011489e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01148a2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01148a6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01148aa:	0f 84 b2 00 00 00    	je     f0114962 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01148b0:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01148b7:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01148be:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01148c5:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f01148cc:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01148d3:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01148da:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01148e1:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01148e8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01148eb:	8a 00                	mov    (%eax),%al
f01148ed:	3c 44                	cmp    $0x44,%al
f01148ef:	75 45                	jne    f0114936 <test_share_chunk+0x9a8>
f01148f1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01148f4:	8a 00                	mov    (%eax),%al
f01148f6:	3c 44                	cmp    $0x44,%al
f01148f8:	75 3c                	jne    f0114936 <test_share_chunk+0x9a8>
f01148fa:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01148fd:	8a 00                	mov    (%eax),%al
f01148ff:	3c 44                	cmp    $0x44,%al
f0114901:	75 33                	jne    f0114936 <test_share_chunk+0x9a8>
f0114903:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114906:	8a 00                	mov    (%eax),%al
f0114908:	3c 44                	cmp    $0x44,%al
f011490a:	75 2a                	jne    f0114936 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011490c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011490f:	8a 10                	mov    (%eax),%dl
f0114911:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114914:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114916:	38 c2                	cmp    %al,%dl
f0114918:	75 1c                	jne    f0114936 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011491a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011491d:	8a 10                	mov    (%eax),%dl
f011491f:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114922:	8a 00                	mov    (%eax),%al
f0114924:	38 c2                	cmp    %al,%dl
f0114926:	75 0e                	jne    f0114936 <test_share_chunk+0x9a8>
f0114928:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011492b:	8a 10                	mov    (%eax),%dl
f011492d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114930:	8a 00                	mov    (%eax),%al
f0114932:	38 c2                	cmp    %al,%dl
f0114934:	74 1e                	je     f0114954 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114936:	83 ec 04             	sub    $0x4,%esp
f0114939:	68 e0 a5 12 f0       	push   $0xf012a5e0
f011493e:	68 fa 04 00 00       	push   $0x4fa
f0114943:	68 62 92 12 f0       	push   $0xf0129262
f0114948:	e8 89 bb fe ff       	call   f01004d6 <_warn>
f011494d:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114950:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114954:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114958:	74 04                	je     f011495e <test_share_chunk+0x9d0>
f011495a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011495e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114962:	83 ec 0c             	sub    $0xc,%esp
f0114965:	68 24 a7 12 f0       	push   $0xf012a724
f011496a:	e8 1c c6 fe ff       	call   f0100f8b <cprintf>
f011496f:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114972:	83 ec 08             	sub    $0x8,%esp
f0114975:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114978:	68 34 a7 12 f0       	push   $0xf012a734
f011497d:	e8 09 c6 fe ff       	call   f0100f8b <cprintf>
f0114982:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114985:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114989:	75 10                	jne    f011499b <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f011498b:	83 ec 0c             	sub    $0xc,%esp
f011498e:	68 64 a7 12 f0       	push   $0xf012a764
f0114993:	e8 f3 c5 fe ff       	call   f0100f8b <cprintf>
f0114998:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011499b:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f01149a0:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01149a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01149a6:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01149a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01149ae:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01149b1:	5b                   	pop    %ebx
f01149b2:	5e                   	pop    %esi
f01149b3:	5f                   	pop    %edi
f01149b4:	5d                   	pop    %ebp
f01149b5:	c3                   	ret    

f01149b6 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01149b6:	55                   	push   %ebp
f01149b7:	89 e5                	mov    %esp,%ebp
f01149b9:	57                   	push   %edi
f01149ba:	56                   	push   %esi
f01149bb:	53                   	push   %ebx
f01149bc:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01149c2:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01149c8:	bb 64 99 12 f0       	mov    $0xf0129964,%ebx
f01149cd:	ba 0f 00 00 00       	mov    $0xf,%edx
f01149d2:	89 c7                	mov    %eax,%edi
f01149d4:	89 de                	mov    %ebx,%esi
f01149d6:	89 d1                	mov    %edx,%ecx
f01149d8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01149da:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01149e0:	b9 23 00 00 00       	mov    $0x23,%ecx
f01149e5:	b0 00                	mov    $0x0,%al
f01149e7:	89 d7                	mov    %edx,%edi
f01149e9:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01149eb:	6a 00                	push   $0x0
f01149ed:	6a 0a                	push   $0xa
f01149ef:	6a 14                	push   $0x14
f01149f1:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01149f7:	50                   	push   %eax
f01149f8:	e8 1e 66 ff ff       	call   f010b01b <env_create>
f01149fd:	83 c4 10             	add    $0x10,%esp
f0114a00:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114a03:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114a06:	8b 40 64             	mov    0x64(%eax),%eax
f0114a09:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114a0c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114a0f:	8b 40 68             	mov    0x68(%eax),%eax
f0114a12:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114a15:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114a18:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114a1b:	83 ec 0c             	sub    $0xc,%esp
f0114a1e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a21:	e8 8a 20 00 00       	call   f0116ab0 <ClearUserSpace>
f0114a26:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114a29:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114a30:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114a37:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114a3e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114a42:	83 ec 0c             	sub    $0xc,%esp
f0114a45:	68 a0 a7 12 f0       	push   $0xf012a7a0
f0114a4a:	e8 3c c5 fe ff       	call   f0100f8b <cprintf>
f0114a4f:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114a52:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114a59:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114a60:	eb 03                	jmp    f0114a65 <test_allocate_chunk+0xaf>
f0114a62:	ff 4d e4             	decl   -0x1c(%ebp)
f0114a65:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114a6c:	76 09                	jbe    f0114a77 <test_allocate_chunk+0xc1>
f0114a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a71:	8a 00                	mov    (%eax),%al
f0114a73:	84 c0                	test   %al,%al
f0114a75:	74 eb                	je     f0114a62 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114a77:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114a7e:	75 06                	jne    f0114a86 <test_allocate_chunk+0xd0>
f0114a80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a83:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114a86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a89:	8a 00                	mov    (%eax),%al
f0114a8b:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114a91:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114a94:	8a 00                	mov    (%eax),%al
f0114a96:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0114a9c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a9f:	8a 00                	mov    (%eax),%al
f0114aa1:	0f be c0             	movsbl %al,%eax
f0114aa4:	83 ec 08             	sub    $0x8,%esp
f0114aa7:	50                   	push   %eax
f0114aa8:	68 ca a7 12 f0       	push   $0xf012a7ca
f0114aad:	e8 d9 c4 fe ff       	call   f0100f8b <cprintf>
f0114ab2:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0114ab5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114ab8:	8a 00                	mov    (%eax),%al
f0114aba:	0f be c0             	movsbl %al,%eax
f0114abd:	83 ec 08             	sub    $0x8,%esp
f0114ac0:	50                   	push   %eax
f0114ac1:	68 d6 a7 12 f0       	push   $0xf012a7d6
f0114ac6:	e8 c0 c4 fe ff       	call   f0100f8b <cprintf>
f0114acb:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114ace:	83 ec 08             	sub    $0x8,%esp
f0114ad1:	68 00 f0 bf ef       	push   $0xefbff000
f0114ad6:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ad9:	e8 b3 1f 00 00       	call   f0116a91 <GP>
f0114ade:	83 c4 10             	add    $0x10,%esp
f0114ae1:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114ae4:	e8 d3 9e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114ae9:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114aec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114aef:	c1 e0 02             	shl    $0x2,%eax
f0114af2:	6a 02                	push   $0x2
f0114af4:	50                   	push   %eax
f0114af5:	68 00 f0 bf ef       	push   $0xefbff000
f0114afa:	ff 75 cc             	pushl  -0x34(%ebp)
f0114afd:	e8 a6 60 ff ff       	call   f010aba8 <allocate_chunk>
f0114b02:	83 c4 10             	add    $0x10,%esp
f0114b05:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114b08:	e8 af 9e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114b0d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114b10:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114b14:	75 08                	jne    f0114b1e <test_allocate_chunk+0x168>
f0114b16:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b19:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114b1c:	74 2a                	je     f0114b48 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114b1e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b21:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114b24:	83 ec 08             	sub    $0x8,%esp
f0114b27:	6a 00                	push   $0x0
f0114b29:	50                   	push   %eax
f0114b2a:	ff 75 b0             	pushl  -0x50(%ebp)
f0114b2d:	68 e4 a7 12 f0       	push   $0xf012a7e4
f0114b32:	68 3a 05 00 00       	push   $0x53a
f0114b37:	68 62 92 12 f0       	push   $0xf0129262
f0114b3c:	e8 95 b9 fe ff       	call   f01004d6 <_warn>
f0114b41:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b44:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114b48:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b4c:	74 04                	je     f0114b52 <test_allocate_chunk+0x19c>
f0114b4e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114b52:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b56:	e8 61 9e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114b5b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114b5e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b61:	01 c0                	add    %eax,%eax
f0114b63:	89 c1                	mov    %eax,%ecx
f0114b65:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114b68:	89 d0                	mov    %edx,%eax
f0114b6a:	c1 e0 02             	shl    $0x2,%eax
f0114b6d:	01 d0                	add    %edx,%eax
f0114b6f:	f7 d8                	neg    %eax
f0114b71:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114b76:	6a 02                	push   $0x2
f0114b78:	51                   	push   %ecx
f0114b79:	50                   	push   %eax
f0114b7a:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b7d:	e8 26 60 ff ff       	call   f010aba8 <allocate_chunk>
f0114b82:	83 c4 10             	add    $0x10,%esp
f0114b85:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114b88:	e8 2f 9e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114b8d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114b90:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114b94:	75 08                	jne    f0114b9e <test_allocate_chunk+0x1e8>
f0114b96:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b99:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114b9c:	74 2a                	je     f0114bc8 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114b9e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ba1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ba4:	83 ec 08             	sub    $0x8,%esp
f0114ba7:	6a 00                	push   $0x0
f0114ba9:	50                   	push   %eax
f0114baa:	ff 75 b0             	pushl  -0x50(%ebp)
f0114bad:	68 e4 a7 12 f0       	push   $0xf012a7e4
f0114bb2:	68 48 05 00 00       	push   $0x548
f0114bb7:	68 62 92 12 f0       	push   $0xf0129262
f0114bbc:	e8 15 b9 fe ff       	call   f01004d6 <_warn>
f0114bc1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114bc4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114bc8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114bcc:	74 04                	je     f0114bd2 <test_allocate_chunk+0x21c>
f0114bce:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114bd2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0114bd6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114bd9:	c1 e0 02             	shl    $0x2,%eax
f0114bdc:	83 ec 08             	sub    $0x8,%esp
f0114bdf:	6a 03                	push   $0x3
f0114be1:	6a 00                	push   $0x0
f0114be3:	6a 00                	push   $0x0
f0114be5:	68 ff 0f 00 00       	push   $0xfff
f0114bea:	ff 75 b8             	pushl  -0x48(%ebp)
f0114bed:	6a 01                	push   $0x1
f0114bef:	50                   	push   %eax
f0114bf0:	68 00 f0 bf ef       	push   $0xefbff000
f0114bf5:	6a 00                	push   $0x0
f0114bf7:	ff 75 cc             	pushl  -0x34(%ebp)
f0114bfa:	e8 e5 1e 00 00       	call   f0116ae4 <CCP>
f0114bff:	83 c4 30             	add    $0x30,%esp
f0114c02:	85 c0                	test   %eax,%eax
f0114c04:	75 1e                	jne    f0114c24 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114c06:	83 ec 04             	sub    $0x4,%esp
f0114c09:	68 4c a8 12 f0       	push   $0xf012a84c
f0114c0e:	68 50 05 00 00       	push   $0x550
f0114c13:	68 62 92 12 f0       	push   $0xf0129262
f0114c18:	e8 b9 b8 fe ff       	call   f01004d6 <_warn>
f0114c1d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c20:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114c24:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c28:	74 04                	je     f0114c2e <test_allocate_chunk+0x278>
f0114c2a:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114c2e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114c32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114c35:	8a 10                	mov    (%eax),%dl
f0114c37:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114c3d:	38 c2                	cmp    %al,%dl
f0114c3f:	75 0f                	jne    f0114c50 <test_allocate_chunk+0x29a>
f0114c41:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114c44:	8a 10                	mov    (%eax),%dl
f0114c46:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114c4c:	38 c2                	cmp    %al,%dl
f0114c4e:	74 1e                	je     f0114c6e <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114c50:	83 ec 04             	sub    $0x4,%esp
f0114c53:	68 98 a8 12 f0       	push   $0xf012a898
f0114c58:	68 58 05 00 00       	push   $0x558
f0114c5d:	68 62 92 12 f0       	push   $0xf0129262
f0114c62:	e8 6f b8 fe ff       	call   f01004d6 <_warn>
f0114c67:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c6a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114c6e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c72:	74 04                	je     f0114c78 <test_allocate_chunk+0x2c2>
f0114c74:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114c78:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114c7c:	83 ec 0c             	sub    $0xc,%esp
f0114c7f:	68 15 a6 12 f0       	push   $0xf012a615
f0114c84:	e8 02 c3 fe ff       	call   f0100f8b <cprintf>
f0114c89:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0114c8c:	83 ec 0c             	sub    $0xc,%esp
f0114c8f:	68 d0 a8 12 f0       	push   $0xf012a8d0
f0114c94:	e8 f2 c2 fe ff       	call   f0100f8b <cprintf>
f0114c99:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114c9c:	e8 1b 9d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114ca1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114ca4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ca7:	c1 e0 05             	shl    $0x5,%eax
f0114caa:	68 02 0e 00 00       	push   $0xe02
f0114caf:	50                   	push   %eax
f0114cb0:	6a 00                	push   $0x0
f0114cb2:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cb5:	e8 ee 5e ff ff       	call   f010aba8 <allocate_chunk>
f0114cba:	83 c4 10             	add    $0x10,%esp
f0114cbd:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114cc0:	e8 f7 9c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114cc5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0114cc8:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114ccc:	75 36                	jne    f0114d04 <test_allocate_chunk+0x34e>
f0114cce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cd1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114cd4:	89 c1                	mov    %eax,%ecx
f0114cd6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cd9:	c1 e0 05             	shl    $0x5,%eax
f0114cdc:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114cdf:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114ce6:	99                   	cltd   
f0114ce7:	f7 fe                	idiv   %esi
f0114ce9:	89 c3                	mov    %eax,%ebx
f0114ceb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cee:	c1 e0 05             	shl    $0x5,%eax
f0114cf1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114cf4:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114cfb:	99                   	cltd   
f0114cfc:	f7 fe                	idiv   %esi
f0114cfe:	01 d8                	add    %ebx,%eax
f0114d00:	39 c1                	cmp    %eax,%ecx
f0114d02:	74 54                	je     f0114d58 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114d04:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d07:	c1 e0 05             	shl    $0x5,%eax
f0114d0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114d0d:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114d14:	99                   	cltd   
f0114d15:	f7 ff                	idiv   %edi
f0114d17:	89 c1                	mov    %eax,%ecx
f0114d19:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d1c:	c1 e0 05             	shl    $0x5,%eax
f0114d1f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d22:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114d29:	99                   	cltd   
f0114d2a:	f7 fe                	idiv   %esi
f0114d2c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114d2f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114d32:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114d35:	83 ec 08             	sub    $0x8,%esp
f0114d38:	52                   	push   %edx
f0114d39:	50                   	push   %eax
f0114d3a:	ff 75 a8             	pushl  -0x58(%ebp)
f0114d3d:	68 10 a9 12 f0       	push   $0xf012a910
f0114d42:	68 6d 05 00 00       	push   $0x56d
f0114d47:	68 62 92 12 f0       	push   $0xf0129262
f0114d4c:	e8 85 b7 fe ff       	call   f01004d6 <_warn>
f0114d51:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d54:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114d58:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d5c:	74 04                	je     f0114d62 <test_allocate_chunk+0x3ac>
f0114d5e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114d62:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114d66:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114d6d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d70:	c1 e0 05             	shl    $0x5,%eax
f0114d73:	83 ec 08             	sub    $0x8,%esp
f0114d76:	6a 03                	push   $0x3
f0114d78:	6a 00                	push   $0x0
f0114d7a:	6a 00                	push   $0x0
f0114d7c:	68 07 0e 00 00       	push   $0xe07
f0114d81:	68 03 0e 00 00       	push   $0xe03
f0114d86:	6a 01                	push   $0x1
f0114d88:	50                   	push   %eax
f0114d89:	6a 00                	push   $0x0
f0114d8b:	6a 00                	push   $0x0
f0114d8d:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d90:	e8 4f 1d 00 00       	call   f0116ae4 <CCP>
f0114d95:	83 c4 30             	add    $0x30,%esp
f0114d98:	85 c0                	test   %eax,%eax
f0114d9a:	75 25                	jne    f0114dc1 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114d9c:	83 ec 04             	sub    $0x4,%esp
f0114d9f:	68 4c a8 12 f0       	push   $0xf012a84c
f0114da4:	68 76 05 00 00       	push   $0x576
f0114da9:	68 62 92 12 f0       	push   $0xf0129262
f0114dae:	e8 23 b7 fe ff       	call   f01004d6 <_warn>
f0114db3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114db6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114dba:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0114dc1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114dc5:	74 04                	je     f0114dcb <test_allocate_chunk+0x415>
f0114dc7:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114dcb:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114dcf:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114dd3:	74 5a                	je     f0114e2f <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0114dd5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114dd8:	01 c0                	add    %eax,%eax
f0114dda:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114ddd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114de0:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114de3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114de6:	01 c0                	add    %eax,%eax
f0114de8:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114deb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114dee:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114df1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114df4:	8a 00                	mov    (%eax),%al
f0114df6:	3c 4b                	cmp    $0x4b,%al
f0114df8:	75 09                	jne    f0114e03 <test_allocate_chunk+0x44d>
f0114dfa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114dfd:	8a 00                	mov    (%eax),%al
f0114dff:	3c 4d                	cmp    $0x4d,%al
f0114e01:	74 1e                	je     f0114e21 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114e03:	83 ec 04             	sub    $0x4,%esp
f0114e06:	68 98 a8 12 f0       	push   $0xf012a898
f0114e0b:	68 84 05 00 00       	push   $0x584
f0114e10:	68 62 92 12 f0       	push   $0xf0129262
f0114e15:	e8 bc b6 fe ff       	call   f01004d6 <_warn>
f0114e1a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114e1d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114e21:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e25:	74 04                	je     f0114e2b <test_allocate_chunk+0x475>
f0114e27:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114e2b:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114e2f:	83 ec 0c             	sub    $0xc,%esp
f0114e32:	68 ef 9b 12 f0       	push   $0xf0129bef
f0114e37:	e8 4f c1 fe ff       	call   f0100f8b <cprintf>
f0114e3c:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0114e3f:	83 ec 0c             	sub    $0xc,%esp
f0114e42:	68 70 a9 12 f0       	push   $0xf012a970
f0114e47:	e8 3f c1 fe ff       	call   f0100f8b <cprintf>
f0114e4c:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114e4f:	e8 68 9b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114e54:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114e57:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e5a:	c1 e0 06             	shl    $0x6,%eax
f0114e5d:	89 c2                	mov    %eax,%edx
f0114e5f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e62:	c1 e0 05             	shl    $0x5,%eax
f0114e65:	6a 00                	push   $0x0
f0114e67:	52                   	push   %edx
f0114e68:	50                   	push   %eax
f0114e69:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e6c:	e8 37 5d ff ff       	call   f010aba8 <allocate_chunk>
f0114e71:	83 c4 10             	add    $0x10,%esp
f0114e74:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114e77:	e8 40 9b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114e7c:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0114e7f:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114e83:	75 36                	jne    f0114ebb <test_allocate_chunk+0x505>
f0114e85:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114e88:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114e8b:	89 c1                	mov    %eax,%ecx
f0114e8d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114e90:	c1 e0 06             	shl    $0x6,%eax
f0114e93:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114e96:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114e9d:	99                   	cltd   
f0114e9e:	f7 ff                	idiv   %edi
f0114ea0:	89 c3                	mov    %eax,%ebx
f0114ea2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ea5:	c1 e0 06             	shl    $0x6,%eax
f0114ea8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114eab:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114eb2:	99                   	cltd   
f0114eb3:	f7 fe                	idiv   %esi
f0114eb5:	01 d8                	add    %ebx,%eax
f0114eb7:	39 c1                	cmp    %eax,%ecx
f0114eb9:	74 54                	je     f0114f0f <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0114ebb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ebe:	c1 e0 06             	shl    $0x6,%eax
f0114ec1:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114ec4:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114ecb:	99                   	cltd   
f0114ecc:	f7 fb                	idiv   %ebx
f0114ece:	89 c1                	mov    %eax,%ecx
f0114ed0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ed3:	c1 e0 06             	shl    $0x6,%eax
f0114ed6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ed9:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114ee0:	99                   	cltd   
f0114ee1:	f7 ff                	idiv   %edi
f0114ee3:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114ee6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ee9:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114eec:	83 ec 08             	sub    $0x8,%esp
f0114eef:	52                   	push   %edx
f0114ef0:	50                   	push   %eax
f0114ef1:	ff 75 a4             	pushl  -0x5c(%ebp)
f0114ef4:	68 10 a9 12 f0       	push   $0xf012a910
f0114ef9:	68 9a 05 00 00       	push   $0x59a
f0114efe:	68 62 92 12 f0       	push   $0xf0129262
f0114f03:	e8 ce b5 fe ff       	call   f01004d6 <_warn>
f0114f08:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f0b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114f0f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f13:	74 04                	je     f0114f19 <test_allocate_chunk+0x563>
f0114f15:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114f19:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114f1d:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114f24:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f27:	c1 e0 06             	shl    $0x6,%eax
f0114f2a:	89 c2                	mov    %eax,%edx
f0114f2c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114f2f:	c1 e0 05             	shl    $0x5,%eax
f0114f32:	83 ec 08             	sub    $0x8,%esp
f0114f35:	6a 03                	push   $0x3
f0114f37:	6a 00                	push   $0x0
f0114f39:	6a 00                	push   $0x0
f0114f3b:	68 07 0e 00 00       	push   $0xe07
f0114f40:	6a 01                	push   $0x1
f0114f42:	6a 01                	push   $0x1
f0114f44:	52                   	push   %edx
f0114f45:	50                   	push   %eax
f0114f46:	6a 00                	push   $0x0
f0114f48:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f4b:	e8 94 1b 00 00       	call   f0116ae4 <CCP>
f0114f50:	83 c4 30             	add    $0x30,%esp
f0114f53:	85 c0                	test   %eax,%eax
f0114f55:	75 25                	jne    f0114f7c <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114f57:	83 ec 04             	sub    $0x4,%esp
f0114f5a:	68 4c a8 12 f0       	push   $0xf012a84c
f0114f5f:	68 a3 05 00 00       	push   $0x5a3
f0114f64:	68 62 92 12 f0       	push   $0xf0129262
f0114f69:	e8 68 b5 fe ff       	call   f01004d6 <_warn>
f0114f6e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114f71:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114f75:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0114f7c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f80:	74 04                	je     f0114f86 <test_allocate_chunk+0x5d0>
f0114f82:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114f86:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0114f8a:	83 ec 0c             	sub    $0xc,%esp
f0114f8d:	68 52 9c 12 f0       	push   $0xf0129c52
f0114f92:	e8 f4 bf fe ff       	call   f0100f8b <cprintf>
f0114f97:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0114f9a:	83 ec 0c             	sub    $0xc,%esp
f0114f9d:	68 b0 a9 12 f0       	push   $0xf012a9b0
f0114fa2:	e8 e4 bf fe ff       	call   f0100f8b <cprintf>
f0114fa7:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114faa:	e8 0d 9a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114faf:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0114fb2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fb5:	c1 e0 06             	shl    $0x6,%eax
f0114fb8:	68 06 0e 00 00       	push   $0xe06
f0114fbd:	50                   	push   %eax
f0114fbe:	68 00 00 00 80       	push   $0x80000000
f0114fc3:	ff 75 cc             	pushl  -0x34(%ebp)
f0114fc6:	e8 dd 5b ff ff       	call   f010aba8 <allocate_chunk>
f0114fcb:	83 c4 10             	add    $0x10,%esp
f0114fce:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114fd1:	e8 e6 99 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0114fd6:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0114fd9:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0114fdd:	75 36                	jne    f0115015 <test_allocate_chunk+0x65f>
f0114fdf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114fe2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114fe5:	89 c1                	mov    %eax,%ecx
f0114fe7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fea:	c1 e0 06             	shl    $0x6,%eax
f0114fed:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ff0:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114ff7:	99                   	cltd   
f0114ff8:	f7 fb                	idiv   %ebx
f0114ffa:	89 c3                	mov    %eax,%ebx
f0114ffc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114fff:	c1 e0 06             	shl    $0x6,%eax
f0115002:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115005:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011500c:	99                   	cltd   
f011500d:	f7 fe                	idiv   %esi
f011500f:	01 d8                	add    %ebx,%eax
f0115011:	39 c1                	cmp    %eax,%ecx
f0115013:	74 54                	je     f0115069 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0115015:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115018:	c1 e0 06             	shl    $0x6,%eax
f011501b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011501e:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0115025:	99                   	cltd   
f0115026:	f7 ff                	idiv   %edi
f0115028:	89 c1                	mov    %eax,%ecx
f011502a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011502d:	c1 e0 06             	shl    $0x6,%eax
f0115030:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115033:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011503a:	99                   	cltd   
f011503b:	f7 fb                	idiv   %ebx
f011503d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115040:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115043:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115046:	83 ec 08             	sub    $0x8,%esp
f0115049:	52                   	push   %edx
f011504a:	50                   	push   %eax
f011504b:	ff 75 9c             	pushl  -0x64(%ebp)
f011504e:	68 10 a9 12 f0       	push   $0xf012a910
f0115053:	68 b9 05 00 00       	push   $0x5b9
f0115058:	68 62 92 12 f0       	push   $0xf0129262
f011505d:	e8 74 b4 fe ff       	call   f01004d6 <_warn>
f0115062:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115065:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0115069:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011506d:	74 04                	je     f0115073 <test_allocate_chunk+0x6bd>
f011506f:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115073:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115077:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011507e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115081:	c1 e0 06             	shl    $0x6,%eax
f0115084:	83 ec 08             	sub    $0x8,%esp
f0115087:	6a 03                	push   $0x3
f0115089:	6a 00                	push   $0x0
f011508b:	6a 00                	push   $0x0
f011508d:	68 07 0e 00 00       	push   $0xe07
f0115092:	68 07 0e 00 00       	push   $0xe07
f0115097:	6a 01                	push   $0x1
f0115099:	50                   	push   %eax
f011509a:	68 00 00 00 80       	push   $0x80000000
f011509f:	6a 00                	push   $0x0
f01150a1:	ff 75 cc             	pushl  -0x34(%ebp)
f01150a4:	e8 3b 1a 00 00       	call   f0116ae4 <CCP>
f01150a9:	83 c4 30             	add    $0x30,%esp
f01150ac:	85 c0                	test   %eax,%eax
f01150ae:	75 25                	jne    f01150d5 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01150b0:	83 ec 04             	sub    $0x4,%esp
f01150b3:	68 4c a8 12 f0       	push   $0xf012a84c
f01150b8:	68 c2 05 00 00       	push   $0x5c2
f01150bd:	68 62 92 12 f0       	push   $0xf0129262
f01150c2:	e8 0f b4 fe ff       	call   f01004d6 <_warn>
f01150c7:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150ca:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01150ce:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f01150d5:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150d9:	74 04                	je     f01150df <test_allocate_chunk+0x729>
f01150db:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01150df:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f01150e3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01150e7:	74 6f                	je     f0115158 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f01150e9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01150ec:	01 c0                	add    %eax,%eax
f01150ee:	05 00 00 00 80       	add    $0x80000000,%eax
f01150f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01150f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01150f9:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f01150fc:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01150ff:	89 d0                	mov    %edx,%eax
f0115101:	c1 e0 02             	shl    $0x2,%eax
f0115104:	01 d0                	add    %edx,%eax
f0115106:	01 c0                	add    %eax,%eax
f0115108:	01 d0                	add    %edx,%eax
f011510a:	01 c0                	add    %eax,%eax
f011510c:	05 00 00 00 80       	add    $0x80000000,%eax
f0115111:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0115114:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115117:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011511a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011511d:	8a 00                	mov    (%eax),%al
f011511f:	3c 4b                	cmp    $0x4b,%al
f0115121:	75 09                	jne    f011512c <test_allocate_chunk+0x776>
f0115123:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115126:	8a 00                	mov    (%eax),%al
f0115128:	3c 4d                	cmp    $0x4d,%al
f011512a:	74 1e                	je     f011514a <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011512c:	83 ec 04             	sub    $0x4,%esp
f011512f:	68 98 a8 12 f0       	push   $0xf012a898
f0115134:	68 d0 05 00 00       	push   $0x5d0
f0115139:	68 62 92 12 f0       	push   $0xf0129262
f011513e:	e8 93 b3 fe ff       	call   f01004d6 <_warn>
f0115143:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115146:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f011514a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011514e:	74 04                	je     f0115154 <test_allocate_chunk+0x79e>
f0115150:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0115154:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0115158:	83 ec 0c             	sub    $0xc,%esp
f011515b:	68 24 a7 12 f0       	push   $0xf012a724
f0115160:	e8 26 be fe ff       	call   f0100f8b <cprintf>
f0115165:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0115168:	83 ec 0c             	sub    $0xc,%esp
f011516b:	68 ec a9 12 f0       	push   $0xf012a9ec
f0115170:	e8 16 be fe ff       	call   f0100f8b <cprintf>
f0115175:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115178:	e8 3f 98 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011517d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0115180:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115183:	89 d0                	mov    %edx,%eax
f0115185:	01 c0                	add    %eax,%eax
f0115187:	01 d0                	add    %edx,%eax
f0115189:	01 c0                	add    %eax,%eax
f011518b:	01 d0                	add    %edx,%eax
f011518d:	68 04 0e 00 00       	push   $0xe04
f0115192:	50                   	push   %eax
f0115193:	68 00 fc 3f 40       	push   $0x403ffc00
f0115198:	ff 75 cc             	pushl  -0x34(%ebp)
f011519b:	e8 08 5a ff ff       	call   f010aba8 <allocate_chunk>
f01151a0:	83 c4 10             	add    $0x10,%esp
f01151a3:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01151a6:	e8 11 98 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01151ab:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f01151ae:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f01151b2:	75 0b                	jne    f01151bf <test_allocate_chunk+0x809>
f01151b4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01151b7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01151ba:	83 f8 05             	cmp    $0x5,%eax
f01151bd:	74 2a                	je     f01151e9 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f01151bf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01151c2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01151c5:	83 ec 08             	sub    $0x8,%esp
f01151c8:	6a 05                	push   $0x5
f01151ca:	50                   	push   %eax
f01151cb:	ff 75 98             	pushl  -0x68(%ebp)
f01151ce:	68 10 a9 12 f0       	push   $0xf012a910
f01151d3:	68 e7 05 00 00       	push   $0x5e7
f01151d8:	68 62 92 12 f0       	push   $0xf0129262
f01151dd:	e8 f4 b2 fe ff       	call   f01004d6 <_warn>
f01151e2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151e5:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01151e9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01151ed:	74 04                	je     f01151f3 <test_allocate_chunk+0x83d>
f01151ef:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01151f3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01151f7:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01151fe:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115201:	89 d0                	mov    %edx,%eax
f0115203:	01 c0                	add    %eax,%eax
f0115205:	01 d0                	add    %edx,%eax
f0115207:	c1 e0 02             	shl    $0x2,%eax
f011520a:	83 ec 08             	sub    $0x8,%esp
f011520d:	6a 03                	push   $0x3
f011520f:	6a 00                	push   $0x0
f0115211:	6a 00                	push   $0x0
f0115213:	68 07 0e 00 00       	push   $0xe07
f0115218:	68 05 0e 00 00       	push   $0xe05
f011521d:	6a 01                	push   $0x1
f011521f:	50                   	push   %eax
f0115220:	68 00 f0 3f 40       	push   $0x403ff000
f0115225:	6a 00                	push   $0x0
f0115227:	ff 75 cc             	pushl  -0x34(%ebp)
f011522a:	e8 b5 18 00 00       	call   f0116ae4 <CCP>
f011522f:	83 c4 30             	add    $0x30,%esp
f0115232:	85 c0                	test   %eax,%eax
f0115234:	75 25                	jne    f011525b <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115236:	83 ec 04             	sub    $0x4,%esp
f0115239:	68 4c a8 12 f0       	push   $0xf012a84c
f011523e:	68 f0 05 00 00       	push   $0x5f0
f0115243:	68 62 92 12 f0       	push   $0xf0129262
f0115248:	e8 89 b2 fe ff       	call   f01004d6 <_warn>
f011524d:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115250:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115254:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f011525b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011525f:	74 04                	je     f0115265 <test_allocate_chunk+0x8af>
f0115261:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115265:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0115269:	83 ec 0c             	sub    $0xc,%esp
f011526c:	68 23 aa 12 f0       	push   $0xf012aa23
f0115271:	e8 15 bd fe ff       	call   f0100f8b <cprintf>
f0115276:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0115279:	83 ec 08             	sub    $0x8,%esp
f011527c:	ff 75 e0             	pushl  -0x20(%ebp)
f011527f:	68 34 aa 12 f0       	push   $0xf012aa34
f0115284:	e8 02 bd fe ff       	call   f0100f8b <cprintf>
f0115289:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011528c:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0115290:	75 10                	jne    f01152a2 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0115292:	83 ec 0c             	sub    $0xc,%esp
f0115295:	68 68 aa 12 f0       	push   $0xf012aa68
f011529a:	e8 ec bc fe ff       	call   f0100f8b <cprintf>
f011529f:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01152a2:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f01152a7:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01152aa:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01152ad:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01152b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01152b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01152b8:	5b                   	pop    %ebx
f01152b9:	5e                   	pop    %esi
f01152ba:	5f                   	pop    %edi
f01152bb:	5d                   	pop    %ebp
f01152bc:	c3                   	ret    

f01152bd <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f01152bd:	55                   	push   %ebp
f01152be:	89 e5                	mov    %esp,%ebp
f01152c0:	57                   	push   %edi
f01152c1:	56                   	push   %esi
f01152c2:	53                   	push   %ebx
f01152c3:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01152c9:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01152cc:	bb 64 99 12 f0       	mov    $0xf0129964,%ebx
f01152d1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01152d6:	89 c7                	mov    %eax,%edi
f01152d8:	89 de                	mov    %ebx,%esi
f01152da:	89 d1                	mov    %edx,%ecx
f01152dc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01152de:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01152e1:	b9 23 00 00 00       	mov    $0x23,%ecx
f01152e6:	b0 00                	mov    $0x0,%al
f01152e8:	89 d7                	mov    %edx,%edi
f01152ea:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01152ec:	6a 00                	push   $0x0
f01152ee:	6a 0a                	push   $0xa
f01152f0:	6a 14                	push   $0x14
f01152f2:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01152f5:	50                   	push   %eax
f01152f6:	e8 20 5d ff ff       	call   f010b01b <env_create>
f01152fb:	83 c4 10             	add    $0x10,%esp
f01152fe:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115301:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115304:	8b 40 64             	mov    0x64(%eax),%eax
f0115307:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011530a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011530d:	8b 40 68             	mov    0x68(%eax),%eax
f0115310:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115313:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115316:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115319:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115320:	75 70 20 
f0115323:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011532a:	00 00 00 
f011532d:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115330:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115335:	b8 00 00 00 00       	mov    $0x0,%eax
f011533a:	89 d7                	mov    %edx,%edi
f011533c:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011533e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115341:	8b 40 10             	mov    0x10(%eax),%eax
f0115344:	83 ec 08             	sub    $0x8,%esp
f0115347:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f011534d:	52                   	push   %edx
f011534e:	50                   	push   %eax
f011534f:	e8 28 ae 00 00       	call   f012017c <ltostr>
f0115354:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115357:	83 ec 04             	sub    $0x4,%esp
f011535a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115360:	50                   	push   %eax
f0115361:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115367:	50                   	push   %eax
f0115368:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f011536e:	50                   	push   %eax
f011536f:	e8 e1 ae 00 00       	call   f0120255 <strcconcat>
f0115374:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115377:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011537e:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115385:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f011538c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115393:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115397:	83 ec 0c             	sub    $0xc,%esp
f011539a:	ff 75 d8             	pushl  -0x28(%ebp)
f011539d:	e8 0e 17 00 00       	call   f0116ab0 <ClearUserSpace>
f01153a2:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01153a5:	83 ec 0c             	sub    $0xc,%esp
f01153a8:	68 a8 aa 12 f0       	push   $0xf012aaa8
f01153ad:	e8 d9 bb fe ff       	call   f0100f8b <cprintf>
f01153b2:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01153b5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01153b8:	c1 e0 03             	shl    $0x3,%eax
f01153bb:	83 ec 04             	sub    $0x4,%esp
f01153be:	50                   	push   %eax
f01153bf:	6a 00                	push   $0x0
f01153c1:	ff 75 d8             	pushl  -0x28(%ebp)
f01153c4:	e8 13 58 ff ff       	call   f010abdc <calculate_required_frames>
f01153c9:	83 c4 10             	add    $0x10,%esp
f01153cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01153cf:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01153d3:	74 23                	je     f01153f8 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01153d5:	83 ec 0c             	sub    $0xc,%esp
f01153d8:	6a 03                	push   $0x3
f01153da:	ff 75 c8             	pushl  -0x38(%ebp)
f01153dd:	68 dc aa 12 f0       	push   $0xf012aadc
f01153e2:	68 29 06 00 00       	push   $0x629
f01153e7:	68 62 92 12 f0       	push   $0xf0129262
f01153ec:	e8 e5 b0 fe ff       	call   f01004d6 <_warn>
f01153f1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153f4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01153f8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153fc:	74 04                	je     f0115402 <test_calculate_required_frames+0x145>
f01153fe:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115402:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115406:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115409:	c1 e0 02             	shl    $0x2,%eax
f011540c:	83 ec 04             	sub    $0x4,%esp
f011540f:	50                   	push   %eax
f0115410:	6a 00                	push   $0x0
f0115412:	ff 75 d8             	pushl  -0x28(%ebp)
f0115415:	e8 c2 57 ff ff       	call   f010abdc <calculate_required_frames>
f011541a:	83 c4 10             	add    $0x10,%esp
f011541d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0115420:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0115427:	74 26                	je     f011544f <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0115429:	83 ec 0c             	sub    $0xc,%esp
f011542c:	68 01 04 00 00       	push   $0x401
f0115431:	ff 75 c8             	pushl  -0x38(%ebp)
f0115434:	68 dc aa 12 f0       	push   $0xf012aadc
f0115439:	68 33 06 00 00       	push   $0x633
f011543e:	68 62 92 12 f0       	push   $0xf0129262
f0115443:	e8 8e b0 fe ff       	call   f01004d6 <_warn>
f0115448:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011544b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011544f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115453:	74 04                	je     f0115459 <test_calculate_required_frames+0x19c>
f0115455:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115459:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011545d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115460:	c1 e0 0a             	shl    $0xa,%eax
f0115463:	83 ec 04             	sub    $0x4,%esp
f0115466:	50                   	push   %eax
f0115467:	6a 00                	push   $0x0
f0115469:	ff 75 d8             	pushl  -0x28(%ebp)
f011546c:	e8 6b 57 ff ff       	call   f010abdc <calculate_required_frames>
f0115471:	83 c4 10             	add    $0x10,%esp
f0115474:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115477:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011547a:	c1 e0 0a             	shl    $0xa,%eax
f011547d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115480:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115487:	99                   	cltd   
f0115488:	f7 fb                	idiv   %ebx
f011548a:	89 c1                	mov    %eax,%ecx
f011548c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011548f:	c1 e0 0a             	shl    $0xa,%eax
f0115492:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115495:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011549c:	99                   	cltd   
f011549d:	f7 fe                	idiv   %esi
f011549f:	01 c8                	add    %ecx,%eax
f01154a1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01154a4:	74 4c                	je     f01154f2 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f01154a6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01154a9:	c1 e0 0a             	shl    $0xa,%eax
f01154ac:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01154af:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01154b6:	99                   	cltd   
f01154b7:	f7 fb                	idiv   %ebx
f01154b9:	89 c1                	mov    %eax,%ecx
f01154bb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01154be:	c1 e0 0a             	shl    $0xa,%eax
f01154c1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01154c4:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01154cb:	99                   	cltd   
f01154cc:	f7 fe                	idiv   %esi
f01154ce:	01 c8                	add    %ecx,%eax
f01154d0:	83 ec 0c             	sub    $0xc,%esp
f01154d3:	50                   	push   %eax
f01154d4:	ff 75 c8             	pushl  -0x38(%ebp)
f01154d7:	68 dc aa 12 f0       	push   $0xf012aadc
f01154dc:	68 3d 06 00 00       	push   $0x63d
f01154e1:	68 62 92 12 f0       	push   $0xf0129262
f01154e6:	e8 eb af fe ff       	call   f01004d6 <_warn>
f01154eb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154ee:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01154f2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01154f6:	74 04                	je     f01154fc <test_calculate_required_frames+0x23f>
f01154f8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01154fc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0115500:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115503:	89 d0                	mov    %edx,%eax
f0115505:	01 c0                	add    %eax,%eax
f0115507:	01 d0                	add    %edx,%eax
f0115509:	01 c0                	add    %eax,%eax
f011550b:	83 ec 04             	sub    $0x4,%esp
f011550e:	50                   	push   %eax
f011550f:	68 00 10 00 00       	push   $0x1000
f0115514:	ff 75 d8             	pushl  -0x28(%ebp)
f0115517:	e8 c0 56 ff ff       	call   f010abdc <calculate_required_frames>
f011551c:	83 c4 10             	add    $0x10,%esp
f011551f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115522:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115526:	74 23                	je     f011554b <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115528:	83 ec 0c             	sub    $0xc,%esp
f011552b:	6a 03                	push   $0x3
f011552d:	ff 75 c8             	pushl  -0x38(%ebp)
f0115530:	68 dc aa 12 f0       	push   $0xf012aadc
f0115535:	68 49 06 00 00       	push   $0x649
f011553a:	68 62 92 12 f0       	push   $0xf0129262
f011553f:	e8 92 af fe ff       	call   f01004d6 <_warn>
f0115544:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115547:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011554b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011554f:	74 04                	je     f0115555 <test_calculate_required_frames+0x298>
f0115551:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115555:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115559:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011555c:	89 c2                	mov    %eax,%edx
f011555e:	01 d2                	add    %edx,%edx
f0115560:	01 d0                	add    %edx,%eax
f0115562:	83 ec 04             	sub    $0x4,%esp
f0115565:	50                   	push   %eax
f0115566:	68 00 18 00 00       	push   $0x1800
f011556b:	ff 75 d8             	pushl  -0x28(%ebp)
f011556e:	e8 69 56 ff ff       	call   f010abdc <calculate_required_frames>
f0115573:	83 c4 10             	add    $0x10,%esp
f0115576:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115579:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011557d:	74 23                	je     f01155a2 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011557f:	83 ec 0c             	sub    $0xc,%esp
f0115582:	6a 03                	push   $0x3
f0115584:	ff 75 c8             	pushl  -0x38(%ebp)
f0115587:	68 dc aa 12 f0       	push   $0xf012aadc
f011558c:	68 53 06 00 00       	push   $0x653
f0115591:	68 62 92 12 f0       	push   $0xf0129262
f0115596:	e8 3b af fe ff       	call   f01004d6 <_warn>
f011559b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011559e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01155a2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155a6:	74 04                	je     f01155ac <test_calculate_required_frames+0x2ef>
f01155a8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01155ac:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01155b0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01155b3:	89 d0                	mov    %edx,%eax
f01155b5:	c1 e0 02             	shl    $0x2,%eax
f01155b8:	01 d0                	add    %edx,%eax
f01155ba:	01 c0                	add    %eax,%eax
f01155bc:	83 ec 04             	sub    $0x4,%esp
f01155bf:	50                   	push   %eax
f01155c0:	68 00 00 40 00       	push   $0x400000
f01155c5:	ff 75 d8             	pushl  -0x28(%ebp)
f01155c8:	e8 0f 56 ff ff       	call   f010abdc <calculate_required_frames>
f01155cd:	83 c4 10             	add    $0x10,%esp
f01155d0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f01155d3:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f01155da:	74 26                	je     f0115602 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01155dc:	83 ec 0c             	sub    $0xc,%esp
f01155df:	68 03 0a 00 00       	push   $0xa03
f01155e4:	ff 75 c8             	pushl  -0x38(%ebp)
f01155e7:	68 dc aa 12 f0       	push   $0xf012aadc
f01155ec:	68 5d 06 00 00       	push   $0x65d
f01155f1:	68 62 92 12 f0       	push   $0xf0129262
f01155f6:	e8 db ae fe ff       	call   f01004d6 <_warn>
f01155fb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155fe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115602:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115606:	74 04                	je     f011560c <test_calculate_required_frames+0x34f>
f0115608:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011560c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115610:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115613:	01 c0                	add    %eax,%eax
f0115615:	83 ec 04             	sub    $0x4,%esp
f0115618:	50                   	push   %eax
f0115619:	68 00 00 70 00       	push   $0x700000
f011561e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115621:	e8 b6 55 ff ff       	call   f010abdc <calculate_required_frames>
f0115626:	83 c4 10             	add    $0x10,%esp
f0115629:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f011562c:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115633:	74 26                	je     f011565b <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0115635:	83 ec 0c             	sub    $0xc,%esp
f0115638:	68 02 02 00 00       	push   $0x202
f011563d:	ff 75 c8             	pushl  -0x38(%ebp)
f0115640:	68 dc aa 12 f0       	push   $0xf012aadc
f0115645:	68 69 06 00 00       	push   $0x669
f011564a:	68 62 92 12 f0       	push   $0xf0129262
f011564f:	e8 82 ae fe ff       	call   f01004d6 <_warn>
f0115654:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115657:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011565b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011565f:	74 04                	je     f0115665 <test_calculate_required_frames+0x3a8>
f0115661:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115665:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115669:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011566c:	83 ec 04             	sub    $0x4,%esp
f011566f:	50                   	push   %eax
f0115670:	68 ff ff 3f 00       	push   $0x3fffff
f0115675:	ff 75 d8             	pushl  -0x28(%ebp)
f0115678:	e8 5f 55 ff ff       	call   f010abdc <calculate_required_frames>
f011567d:	83 c4 10             	add    $0x10,%esp
f0115680:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0115683:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115687:	74 23                	je     f01156ac <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0115689:	83 ec 0c             	sub    $0xc,%esp
f011568c:	6a 04                	push   $0x4
f011568e:	ff 75 c8             	pushl  -0x38(%ebp)
f0115691:	68 dc aa 12 f0       	push   $0xf012aadc
f0115696:	68 73 06 00 00       	push   $0x673
f011569b:	68 62 92 12 f0       	push   $0xf0129262
f01156a0:	e8 31 ae fe ff       	call   f01004d6 <_warn>
f01156a5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156a8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01156ac:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156b0:	74 04                	je     f01156b6 <test_calculate_required_frames+0x3f9>
f01156b2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01156b6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01156ba:	83 ec 0c             	sub    $0xc,%esp
f01156bd:	68 15 a6 12 f0       	push   $0xf012a615
f01156c2:	e8 c4 b8 fe ff       	call   f0100f8b <cprintf>
f01156c7:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01156ca:	83 ec 0c             	sub    $0xc,%esp
f01156cd:	68 34 ab 12 f0       	push   $0xf012ab34
f01156d2:	e8 b4 b8 fe ff       	call   f0100f8b <cprintf>
f01156d7:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01156da:	83 ec 04             	sub    $0x4,%esp
f01156dd:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01156e3:	50                   	push   %eax
f01156e4:	68 ce 99 12 f0       	push   $0xf01299ce
f01156e9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01156ef:	50                   	push   %eax
f01156f0:	e8 60 ab 00 00       	call   f0120255 <strcconcat>
f01156f5:	83 c4 10             	add    $0x10,%esp
f01156f8:	83 ec 0c             	sub    $0xc,%esp
f01156fb:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115701:	50                   	push   %eax
f0115702:	e8 f4 c7 fe ff       	call   f0101efb <execute_command>
f0115707:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f011570a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011570d:	c1 e0 03             	shl    $0x3,%eax
f0115710:	83 ec 04             	sub    $0x4,%esp
f0115713:	50                   	push   %eax
f0115714:	6a 00                	push   $0x0
f0115716:	ff 75 d8             	pushl  -0x28(%ebp)
f0115719:	e8 be 54 ff ff       	call   f010abdc <calculate_required_frames>
f011571e:	83 c4 10             	add    $0x10,%esp
f0115721:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115724:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f011572b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011572e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115731:	74 24                	je     f0115757 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115733:	83 ec 0c             	sub    $0xc,%esp
f0115736:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115739:	ff 75 c8             	pushl  -0x38(%ebp)
f011573c:	68 dc aa 12 f0       	push   $0xf012aadc
f0115741:	68 87 06 00 00       	push   $0x687
f0115746:	68 62 92 12 f0       	push   $0xf0129262
f011574b:	e8 86 ad fe ff       	call   f01004d6 <_warn>
f0115750:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115753:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115757:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011575b:	74 04                	je     f0115761 <test_calculate_required_frames+0x4a4>
f011575d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115761:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115765:	83 ec 04             	sub    $0x4,%esp
f0115768:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011576e:	50                   	push   %eax
f011576f:	68 db 99 12 f0       	push   $0xf01299db
f0115774:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011577a:	50                   	push   %eax
f011577b:	e8 d5 aa 00 00       	call   f0120255 <strcconcat>
f0115780:	83 c4 10             	add    $0x10,%esp
f0115783:	83 ec 0c             	sub    $0xc,%esp
f0115786:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011578c:	50                   	push   %eax
f011578d:	e8 69 c7 fe ff       	call   f0101efb <execute_command>
f0115792:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115795:	83 ec 04             	sub    $0x4,%esp
f0115798:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011579e:	50                   	push   %eax
f011579f:	68 68 ab 12 f0       	push   $0xf012ab68
f01157a4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01157aa:	50                   	push   %eax
f01157ab:	e8 a5 aa 00 00       	call   f0120255 <strcconcat>
f01157b0:	83 c4 10             	add    $0x10,%esp
f01157b3:	83 ec 0c             	sub    $0xc,%esp
f01157b6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01157bc:	50                   	push   %eax
f01157bd:	e8 39 c7 fe ff       	call   f0101efb <execute_command>
f01157c2:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f01157c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01157c8:	c1 e0 03             	shl    $0x3,%eax
f01157cb:	83 ec 04             	sub    $0x4,%esp
f01157ce:	50                   	push   %eax
f01157cf:	6a 00                	push   $0x0
f01157d1:	ff 75 d8             	pushl  -0x28(%ebp)
f01157d4:	e8 03 54 ff ff       	call   f010abdc <calculate_required_frames>
f01157d9:	83 c4 10             	add    $0x10,%esp
f01157dc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01157df:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f01157e6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01157e9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01157ec:	74 24                	je     f0115812 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01157ee:	83 ec 0c             	sub    $0xc,%esp
f01157f1:	ff 75 c4             	pushl  -0x3c(%ebp)
f01157f4:	ff 75 c8             	pushl  -0x38(%ebp)
f01157f7:	68 dc aa 12 f0       	push   $0xf012aadc
f01157fc:	68 95 06 00 00       	push   $0x695
f0115801:	68 62 92 12 f0       	push   $0xf0129262
f0115806:	e8 cb ac fe ff       	call   f01004d6 <_warn>
f011580b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011580e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115812:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115816:	74 04                	je     f011581c <test_calculate_required_frames+0x55f>
f0115818:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011581c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115820:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115823:	c1 e0 0a             	shl    $0xa,%eax
f0115826:	83 ec 04             	sub    $0x4,%esp
f0115829:	50                   	push   %eax
f011582a:	6a 00                	push   $0x0
f011582c:	ff 75 d8             	pushl  -0x28(%ebp)
f011582f:	e8 a8 53 ff ff       	call   f010abdc <calculate_required_frames>
f0115834:	83 c4 10             	add    $0x10,%esp
f0115837:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f011583a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011583d:	c1 e0 0a             	shl    $0xa,%eax
f0115840:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115843:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011584a:	99                   	cltd   
f011584b:	f7 fb                	idiv   %ebx
f011584d:	89 c1                	mov    %eax,%ecx
f011584f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115852:	c1 e0 0a             	shl    $0xa,%eax
f0115855:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115858:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011585f:	99                   	cltd   
f0115860:	f7 fe                	idiv   %esi
f0115862:	01 c8                	add    %ecx,%eax
f0115864:	83 e8 05             	sub    $0x5,%eax
f0115867:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f011586a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011586d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115870:	74 24                	je     f0115896 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115872:	83 ec 0c             	sub    $0xc,%esp
f0115875:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115878:	ff 75 c8             	pushl  -0x38(%ebp)
f011587b:	68 dc aa 12 f0       	push   $0xf012aadc
f0115880:	68 a0 06 00 00       	push   $0x6a0
f0115885:	68 62 92 12 f0       	push   $0xf0129262
f011588a:	e8 47 ac fe ff       	call   f01004d6 <_warn>
f011588f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115892:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115896:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011589a:	74 04                	je     f01158a0 <test_calculate_required_frames+0x5e3>
f011589c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01158a0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01158a4:	83 ec 04             	sub    $0x4,%esp
f01158a7:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01158ad:	50                   	push   %eax
f01158ae:	68 74 ab 12 f0       	push   $0xf012ab74
f01158b3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158b9:	50                   	push   %eax
f01158ba:	e8 96 a9 00 00       	call   f0120255 <strcconcat>
f01158bf:	83 c4 10             	add    $0x10,%esp
f01158c2:	83 ec 0c             	sub    $0xc,%esp
f01158c5:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01158cb:	50                   	push   %eax
f01158cc:	e8 2a c6 fe ff       	call   f0101efb <execute_command>
f01158d1:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01158d4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01158d7:	89 c2                	mov    %eax,%edx
f01158d9:	01 d2                	add    %edx,%edx
f01158db:	01 d0                	add    %edx,%eax
f01158dd:	83 ec 04             	sub    $0x4,%esp
f01158e0:	50                   	push   %eax
f01158e1:	68 00 18 00 00       	push   $0x1800
f01158e6:	ff 75 d8             	pushl  -0x28(%ebp)
f01158e9:	e8 ee 52 ff ff       	call   f010abdc <calculate_required_frames>
f01158ee:	83 c4 10             	add    $0x10,%esp
f01158f1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01158f4:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01158fb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01158fe:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115901:	74 24                	je     f0115927 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115903:	83 ec 0c             	sub    $0xc,%esp
f0115906:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115909:	ff 75 c8             	pushl  -0x38(%ebp)
f011590c:	68 dc aa 12 f0       	push   $0xf012aadc
f0115911:	68 af 06 00 00       	push   $0x6af
f0115916:	68 62 92 12 f0       	push   $0xf0129262
f011591b:	e8 b6 ab fe ff       	call   f01004d6 <_warn>
f0115920:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115923:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115927:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011592b:	74 04                	je     f0115931 <test_calculate_required_frames+0x674>
f011592d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115931:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115935:	83 ec 04             	sub    $0x4,%esp
f0115938:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011593e:	50                   	push   %eax
f011593f:	68 34 9c 12 f0       	push   $0xf0129c34
f0115944:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011594a:	50                   	push   %eax
f011594b:	e8 05 a9 00 00       	call   f0120255 <strcconcat>
f0115950:	83 c4 10             	add    $0x10,%esp
f0115953:	83 ec 0c             	sub    $0xc,%esp
f0115956:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011595c:	50                   	push   %eax
f011595d:	e8 99 c5 fe ff       	call   f0101efb <execute_command>
f0115962:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115965:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115968:	89 d0                	mov    %edx,%eax
f011596a:	c1 e0 02             	shl    $0x2,%eax
f011596d:	01 d0                	add    %edx,%eax
f011596f:	01 c0                	add    %eax,%eax
f0115971:	83 ec 04             	sub    $0x4,%esp
f0115974:	50                   	push   %eax
f0115975:	68 00 00 40 00       	push   $0x400000
f011597a:	ff 75 d8             	pushl  -0x28(%ebp)
f011597d:	e8 5a 52 ff ff       	call   f010abdc <calculate_required_frames>
f0115982:	83 c4 10             	add    $0x10,%esp
f0115985:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115988:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f011598f:	74 26                	je     f01159b7 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115991:	83 ec 0c             	sub    $0xc,%esp
f0115994:	68 03 0a 00 00       	push   $0xa03
f0115999:	ff 75 c8             	pushl  -0x38(%ebp)
f011599c:	68 dc aa 12 f0       	push   $0xf012aadc
f01159a1:	68 bb 06 00 00       	push   $0x6bb
f01159a6:	68 62 92 12 f0       	push   $0xf0129262
f01159ab:	e8 26 ab fe ff       	call   f01004d6 <_warn>
f01159b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159b3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159b7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159bb:	74 04                	je     f01159c1 <test_calculate_required_frames+0x704>
f01159bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159c1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01159c5:	83 ec 04             	sub    $0x4,%esp
f01159c8:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01159ce:	50                   	push   %eax
f01159cf:	68 3e 9c 12 f0       	push   $0xf0129c3e
f01159d4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01159da:	50                   	push   %eax
f01159db:	e8 75 a8 00 00       	call   f0120255 <strcconcat>
f01159e0:	83 c4 10             	add    $0x10,%esp
f01159e3:	83 ec 0c             	sub    $0xc,%esp
f01159e6:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01159ec:	50                   	push   %eax
f01159ed:	e8 09 c5 fe ff       	call   f0101efb <execute_command>
f01159f2:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01159f5:	83 ec 04             	sub    $0x4,%esp
f01159f8:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01159fe:	50                   	push   %eax
f01159ff:	68 7c ab 12 f0       	push   $0xf012ab7c
f0115a04:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115a0a:	50                   	push   %eax
f0115a0b:	e8 45 a8 00 00       	call   f0120255 <strcconcat>
f0115a10:	83 c4 10             	add    $0x10,%esp
f0115a13:	83 ec 0c             	sub    $0xc,%esp
f0115a16:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115a1c:	50                   	push   %eax
f0115a1d:	e8 d9 c4 fe ff       	call   f0101efb <execute_command>
f0115a22:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115a25:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a28:	01 c0                	add    %eax,%eax
f0115a2a:	83 ec 04             	sub    $0x4,%esp
f0115a2d:	50                   	push   %eax
f0115a2e:	68 00 00 70 00       	push   $0x700000
f0115a33:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a36:	e8 a1 51 ff ff       	call   f010abdc <calculate_required_frames>
f0115a3b:	83 c4 10             	add    $0x10,%esp
f0115a3e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115a41:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115a48:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115a4b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115a4e:	74 24                	je     f0115a74 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115a50:	83 ec 0c             	sub    $0xc,%esp
f0115a53:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115a56:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a59:	68 dc aa 12 f0       	push   $0xf012aadc
f0115a5e:	68 cb 06 00 00       	push   $0x6cb
f0115a63:	68 62 92 12 f0       	push   $0xf0129262
f0115a68:	e8 69 aa fe ff       	call   f01004d6 <_warn>
f0115a6d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a70:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115a74:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a78:	74 04                	je     f0115a7e <test_calculate_required_frames+0x7c1>
f0115a7a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115a7e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115a82:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a85:	83 ec 04             	sub    $0x4,%esp
f0115a88:	50                   	push   %eax
f0115a89:	68 ff ff 3f 00       	push   $0x3fffff
f0115a8e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a91:	e8 46 51 ff ff       	call   f010abdc <calculate_required_frames>
f0115a96:	83 c4 10             	add    $0x10,%esp
f0115a99:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0115a9c:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115aa3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115aa6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115aa9:	74 24                	je     f0115acf <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115aab:	83 ec 0c             	sub    $0xc,%esp
f0115aae:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115ab1:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ab4:	68 dc aa 12 f0       	push   $0xf012aadc
f0115ab9:	68 d6 06 00 00       	push   $0x6d6
f0115abe:	68 62 92 12 f0       	push   $0xf0129262
f0115ac3:	e8 0e aa fe ff       	call   f01004d6 <_warn>
f0115ac8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115acb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115acf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ad3:	74 04                	je     f0115ad9 <test_calculate_required_frames+0x81c>
f0115ad5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115ad9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115add:	83 ec 0c             	sub    $0xc,%esp
f0115ae0:	68 ef 9b 12 f0       	push   $0xf0129bef
f0115ae5:	e8 a1 b4 fe ff       	call   f0100f8b <cprintf>
f0115aea:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115aed:	83 ec 08             	sub    $0x8,%esp
f0115af0:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115af3:	68 88 ab 12 f0       	push   $0xf012ab88
f0115af8:	e8 8e b4 fe ff       	call   f0100f8b <cprintf>
f0115afd:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115b00:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115b04:	75 10                	jne    f0115b16 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115b06:	83 ec 0c             	sub    $0xc,%esp
f0115b09:	68 c8 ab 12 f0       	push   $0xf012abc8
f0115b0e:	e8 78 b4 fe ff       	call   f0100f8b <cprintf>
f0115b13:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115b16:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f0115b1b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115b1e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115b21:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115b24:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115b29:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115b2c:	5b                   	pop    %ebx
f0115b2d:	5e                   	pop    %esi
f0115b2e:	5f                   	pop    %edi
f0115b2f:	5d                   	pop    %ebp
f0115b30:	c3                   	ret    

f0115b31 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115b31:	55                   	push   %ebp
f0115b32:	89 e5                	mov    %esp,%ebp
f0115b34:	57                   	push   %edi
f0115b35:	56                   	push   %esi
f0115b36:	53                   	push   %ebx
f0115b37:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115b3d:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115b40:	bb 64 99 12 f0       	mov    $0xf0129964,%ebx
f0115b45:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115b4a:	89 c7                	mov    %eax,%edi
f0115b4c:	89 de                	mov    %ebx,%esi
f0115b4e:	89 d1                	mov    %edx,%ecx
f0115b50:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115b52:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115b55:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115b5a:	b0 00                	mov    $0x0,%al
f0115b5c:	89 d7                	mov    %edx,%edi
f0115b5e:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115b60:	6a 00                	push   $0x0
f0115b62:	6a 0a                	push   $0xa
f0115b64:	6a 14                	push   $0x14
f0115b66:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115b69:	50                   	push   %eax
f0115b6a:	e8 ac 54 ff ff       	call   f010b01b <env_create>
f0115b6f:	83 c4 10             	add    $0x10,%esp
f0115b72:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115b75:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115b78:	8b 40 64             	mov    0x64(%eax),%eax
f0115b7b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115b7e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115b81:	8b 40 68             	mov    0x68(%eax),%eax
f0115b84:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115b87:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115b8a:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115b8d:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115b94:	75 70 20 
f0115b97:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115b9e:	00 00 00 
f0115ba1:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115ba4:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115ba9:	b8 00 00 00 00       	mov    $0x0,%eax
f0115bae:	89 d7                	mov    %edx,%edi
f0115bb0:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115bb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115bb5:	8b 40 10             	mov    0x10(%eax),%eax
f0115bb8:	83 ec 08             	sub    $0x8,%esp
f0115bbb:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115bc1:	52                   	push   %edx
f0115bc2:	50                   	push   %eax
f0115bc3:	e8 b4 a5 00 00       	call   f012017c <ltostr>
f0115bc8:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115bcb:	83 ec 04             	sub    $0x4,%esp
f0115bce:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115bd4:	50                   	push   %eax
f0115bd5:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115bdb:	50                   	push   %eax
f0115bdc:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115be2:	50                   	push   %eax
f0115be3:	e8 6d a6 00 00       	call   f0120255 <strcconcat>
f0115be8:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115beb:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115bf2:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115bf9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0115c00:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115c04:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115c0b:	00 00 00 
	uint32 num_tables = 0;
f0115c0e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115c15:	00 00 00 
	ClearUserSpace(proc_directory);
f0115c18:	83 ec 0c             	sub    $0xc,%esp
f0115c1b:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c1e:	e8 8d 0e 00 00       	call   f0116ab0 <ClearUserSpace>
f0115c23:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115c26:	83 ec 0c             	sub    $0xc,%esp
f0115c29:	68 a8 aa 12 f0       	push   $0xf012aaa8
f0115c2e:	e8 58 b3 fe ff       	call   f0100f8b <cprintf>
f0115c33:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115c36:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115c39:	c1 e0 03             	shl    $0x3,%eax
f0115c3c:	89 c2                	mov    %eax,%edx
f0115c3e:	83 ec 0c             	sub    $0xc,%esp
f0115c41:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c47:	50                   	push   %eax
f0115c48:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115c4e:	50                   	push   %eax
f0115c4f:	52                   	push   %edx
f0115c50:	6a 00                	push   $0x0
f0115c52:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c55:	e8 68 4f ff ff       	call   f010abc2 <calculate_allocated_space>
f0115c5a:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115c5d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c63:	85 c0                	test   %eax,%eax
f0115c65:	74 27                	je     f0115c8e <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115c67:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c6d:	83 ec 0c             	sub    $0xc,%esp
f0115c70:	6a 00                	push   $0x0
f0115c72:	50                   	push   %eax
f0115c73:	68 14 ac 12 f0       	push   $0xf012ac14
f0115c78:	68 0b 07 00 00       	push   $0x70b
f0115c7d:	68 62 92 12 f0       	push   $0xf0129262
f0115c82:	e8 4f a8 fe ff       	call   f01004d6 <_warn>
f0115c87:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c8a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115c8e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c94:	85 c0                	test   %eax,%eax
f0115c96:	74 27                	je     f0115cbf <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115c98:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c9e:	83 ec 0c             	sub    $0xc,%esp
f0115ca1:	6a 00                	push   $0x0
f0115ca3:	50                   	push   %eax
f0115ca4:	68 74 ac 12 f0       	push   $0xf012ac74
f0115ca9:	68 10 07 00 00       	push   $0x710
f0115cae:	68 62 92 12 f0       	push   $0xf0129262
f0115cb3:	e8 1e a8 fe ff       	call   f01004d6 <_warn>
f0115cb8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cbb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115cbf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115cc3:	74 04                	je     f0115cc9 <test_calculate_allocated_space+0x198>
f0115cc5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115cc9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0115ccd:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115cd4:	00 00 00 
		num_pages = 0;
f0115cd7:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115cde:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0115ce1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ce4:	c1 e0 02             	shl    $0x2,%eax
f0115ce7:	89 c2                	mov    %eax,%edx
f0115ce9:	83 ec 0c             	sub    $0xc,%esp
f0115cec:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115cf2:	50                   	push   %eax
f0115cf3:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115cf9:	50                   	push   %eax
f0115cfa:	52                   	push   %edx
f0115cfb:	6a 00                	push   $0x0
f0115cfd:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d00:	e8 bd 4e ff ff       	call   f010abc2 <calculate_allocated_space>
f0115d05:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115d08:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d0e:	85 c0                	test   %eax,%eax
f0115d10:	74 27                	je     f0115d39 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115d12:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d18:	83 ec 0c             	sub    $0xc,%esp
f0115d1b:	6a 00                	push   $0x0
f0115d1d:	50                   	push   %eax
f0115d1e:	68 14 ac 12 f0       	push   $0xf012ac14
f0115d23:	68 1c 07 00 00       	push   $0x71c
f0115d28:	68 62 92 12 f0       	push   $0xf0129262
f0115d2d:	e8 a4 a7 fe ff       	call   f01004d6 <_warn>
f0115d32:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d35:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115d39:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d3f:	85 c0                	test   %eax,%eax
f0115d41:	74 27                	je     f0115d6a <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115d43:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d49:	83 ec 0c             	sub    $0xc,%esp
f0115d4c:	6a 00                	push   $0x0
f0115d4e:	50                   	push   %eax
f0115d4f:	68 74 ac 12 f0       	push   $0xf012ac74
f0115d54:	68 21 07 00 00       	push   $0x721
f0115d59:	68 62 92 12 f0       	push   $0xf0129262
f0115d5e:	e8 73 a7 fe ff       	call   f01004d6 <_warn>
f0115d63:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d66:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d6a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d6e:	74 04                	je     f0115d74 <test_calculate_allocated_space+0x243>
f0115d70:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d74:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115d78:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115d7f:	00 00 00 
		num_pages = 0;
f0115d82:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115d89:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115d8c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115d8f:	c1 e0 0a             	shl    $0xa,%eax
f0115d92:	89 c2                	mov    %eax,%edx
f0115d94:	83 ec 0c             	sub    $0xc,%esp
f0115d97:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115d9d:	50                   	push   %eax
f0115d9e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115da4:	50                   	push   %eax
f0115da5:	52                   	push   %edx
f0115da6:	6a 00                	push   $0x0
f0115da8:	ff 75 d8             	pushl  -0x28(%ebp)
f0115dab:	e8 12 4e ff ff       	call   f010abc2 <calculate_allocated_space>
f0115db0:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115db3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115db9:	85 c0                	test   %eax,%eax
f0115dbb:	74 27                	je     f0115de4 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115dbd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115dc3:	83 ec 0c             	sub    $0xc,%esp
f0115dc6:	6a 00                	push   $0x0
f0115dc8:	50                   	push   %eax
f0115dc9:	68 14 ac 12 f0       	push   $0xf012ac14
f0115dce:	68 2d 07 00 00       	push   $0x72d
f0115dd3:	68 62 92 12 f0       	push   $0xf0129262
f0115dd8:	e8 f9 a6 fe ff       	call   f01004d6 <_warn>
f0115ddd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115de0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115de4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115dea:	85 c0                	test   %eax,%eax
f0115dec:	74 27                	je     f0115e15 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115dee:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115df4:	83 ec 0c             	sub    $0xc,%esp
f0115df7:	6a 00                	push   $0x0
f0115df9:	50                   	push   %eax
f0115dfa:	68 74 ac 12 f0       	push   $0xf012ac74
f0115dff:	68 32 07 00 00       	push   $0x732
f0115e04:	68 62 92 12 f0       	push   $0xf0129262
f0115e09:	e8 c8 a6 fe ff       	call   f01004d6 <_warn>
f0115e0e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e11:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e15:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e19:	74 04                	je     f0115e1f <test_calculate_allocated_space+0x2ee>
f0115e1b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e1f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115e23:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115e2a:	00 00 00 
		num_pages = 0;
f0115e2d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115e34:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115e37:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115e3a:	89 d0                	mov    %edx,%eax
f0115e3c:	01 c0                	add    %eax,%eax
f0115e3e:	01 d0                	add    %edx,%eax
f0115e40:	01 c0                	add    %eax,%eax
f0115e42:	05 00 10 00 00       	add    $0x1000,%eax
f0115e47:	89 c2                	mov    %eax,%edx
f0115e49:	83 ec 0c             	sub    $0xc,%esp
f0115e4c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115e52:	50                   	push   %eax
f0115e53:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e59:	50                   	push   %eax
f0115e5a:	52                   	push   %edx
f0115e5b:	68 00 10 00 00       	push   $0x1000
f0115e60:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e63:	e8 5a 4d ff ff       	call   f010abc2 <calculate_allocated_space>
f0115e68:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115e6b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e71:	85 c0                	test   %eax,%eax
f0115e73:	74 27                	je     f0115e9c <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115e75:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e7b:	83 ec 0c             	sub    $0xc,%esp
f0115e7e:	6a 00                	push   $0x0
f0115e80:	50                   	push   %eax
f0115e81:	68 14 ac 12 f0       	push   $0xf012ac14
f0115e86:	68 3f 07 00 00       	push   $0x73f
f0115e8b:	68 62 92 12 f0       	push   $0xf0129262
f0115e90:	e8 41 a6 fe ff       	call   f01004d6 <_warn>
f0115e95:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e98:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115e9c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ea2:	85 c0                	test   %eax,%eax
f0115ea4:	74 27                	je     f0115ecd <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115ea6:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115eac:	83 ec 0c             	sub    $0xc,%esp
f0115eaf:	6a 00                	push   $0x0
f0115eb1:	50                   	push   %eax
f0115eb2:	68 74 ac 12 f0       	push   $0xf012ac74
f0115eb7:	68 44 07 00 00       	push   $0x744
f0115ebc:	68 62 92 12 f0       	push   $0xf0129262
f0115ec1:	e8 10 a6 fe ff       	call   f01004d6 <_warn>
f0115ec6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ec9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ecd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ed1:	74 04                	je     f0115ed7 <test_calculate_allocated_space+0x3a6>
f0115ed3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ed7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0115edb:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115ee2:	00 00 00 
		num_pages = 0;
f0115ee5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115eec:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115eef:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115ef2:	89 c2                	mov    %eax,%edx
f0115ef4:	01 d2                	add    %edx,%edx
f0115ef6:	01 d0                	add    %edx,%eax
f0115ef8:	05 00 18 00 00       	add    $0x1800,%eax
f0115efd:	89 c2                	mov    %eax,%edx
f0115eff:	83 ec 0c             	sub    $0xc,%esp
f0115f02:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f08:	50                   	push   %eax
f0115f09:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f0f:	50                   	push   %eax
f0115f10:	52                   	push   %edx
f0115f11:	68 00 18 00 00       	push   $0x1800
f0115f16:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f19:	e8 a4 4c ff ff       	call   f010abc2 <calculate_allocated_space>
f0115f1e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115f21:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f27:	85 c0                	test   %eax,%eax
f0115f29:	74 27                	je     f0115f52 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115f2b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f31:	83 ec 0c             	sub    $0xc,%esp
f0115f34:	6a 00                	push   $0x0
f0115f36:	50                   	push   %eax
f0115f37:	68 14 ac 12 f0       	push   $0xf012ac14
f0115f3c:	68 50 07 00 00       	push   $0x750
f0115f41:	68 62 92 12 f0       	push   $0xf0129262
f0115f46:	e8 8b a5 fe ff       	call   f01004d6 <_warn>
f0115f4b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f4e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115f52:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f58:	85 c0                	test   %eax,%eax
f0115f5a:	74 27                	je     f0115f83 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115f5c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f62:	83 ec 0c             	sub    $0xc,%esp
f0115f65:	6a 00                	push   $0x0
f0115f67:	50                   	push   %eax
f0115f68:	68 74 ac 12 f0       	push   $0xf012ac74
f0115f6d:	68 55 07 00 00       	push   $0x755
f0115f72:	68 62 92 12 f0       	push   $0xf0129262
f0115f77:	e8 5a a5 fe ff       	call   f01004d6 <_warn>
f0115f7c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f7f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f83:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f87:	74 04                	je     f0115f8d <test_calculate_allocated_space+0x45c>
f0115f89:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f8d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0115f91:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f98:	00 00 00 
		num_pages = 0;
f0115f9b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115fa2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115fa5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115fa8:	89 d0                	mov    %edx,%eax
f0115faa:	c1 e0 02             	shl    $0x2,%eax
f0115fad:	01 d0                	add    %edx,%eax
f0115faf:	01 c0                	add    %eax,%eax
f0115fb1:	05 00 00 40 00       	add    $0x400000,%eax
f0115fb6:	89 c2                	mov    %eax,%edx
f0115fb8:	83 ec 0c             	sub    $0xc,%esp
f0115fbb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115fc1:	50                   	push   %eax
f0115fc2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115fc8:	50                   	push   %eax
f0115fc9:	52                   	push   %edx
f0115fca:	68 00 00 40 00       	push   $0x400000
f0115fcf:	ff 75 d8             	pushl  -0x28(%ebp)
f0115fd2:	e8 eb 4b ff ff       	call   f010abc2 <calculate_allocated_space>
f0115fd7:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115fda:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fe0:	85 c0                	test   %eax,%eax
f0115fe2:	74 27                	je     f011600b <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115fe4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115fea:	83 ec 0c             	sub    $0xc,%esp
f0115fed:	6a 00                	push   $0x0
f0115fef:	50                   	push   %eax
f0115ff0:	68 14 ac 12 f0       	push   $0xf012ac14
f0115ff5:	68 61 07 00 00       	push   $0x761
f0115ffa:	68 62 92 12 f0       	push   $0xf0129262
f0115fff:	e8 d2 a4 fe ff       	call   f01004d6 <_warn>
f0116004:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116007:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011600b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116011:	85 c0                	test   %eax,%eax
f0116013:	74 27                	je     f011603c <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116015:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011601b:	83 ec 0c             	sub    $0xc,%esp
f011601e:	6a 00                	push   $0x0
f0116020:	50                   	push   %eax
f0116021:	68 74 ac 12 f0       	push   $0xf012ac74
f0116026:	68 66 07 00 00       	push   $0x766
f011602b:	68 62 92 12 f0       	push   $0xf0129262
f0116030:	e8 a1 a4 fe ff       	call   f01004d6 <_warn>
f0116035:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116038:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011603c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116040:	74 04                	je     f0116046 <test_calculate_allocated_space+0x515>
f0116042:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116046:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f011604a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116051:	00 00 00 
		num_pages = 0;
f0116054:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011605b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011605e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116061:	05 00 00 38 00       	add    $0x380000,%eax
f0116066:	01 c0                	add    %eax,%eax
f0116068:	89 c2                	mov    %eax,%edx
f011606a:	83 ec 0c             	sub    $0xc,%esp
f011606d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116073:	50                   	push   %eax
f0116074:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011607a:	50                   	push   %eax
f011607b:	52                   	push   %edx
f011607c:	68 00 00 70 00       	push   $0x700000
f0116081:	ff 75 d8             	pushl  -0x28(%ebp)
f0116084:	e8 39 4b ff ff       	call   f010abc2 <calculate_allocated_space>
f0116089:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011608c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116092:	85 c0                	test   %eax,%eax
f0116094:	74 27                	je     f01160bd <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116096:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011609c:	83 ec 0c             	sub    $0xc,%esp
f011609f:	6a 00                	push   $0x0
f01160a1:	50                   	push   %eax
f01160a2:	68 14 ac 12 f0       	push   $0xf012ac14
f01160a7:	68 73 07 00 00       	push   $0x773
f01160ac:	68 62 92 12 f0       	push   $0xf0129262
f01160b1:	e8 20 a4 fe ff       	call   f01004d6 <_warn>
f01160b6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160b9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01160bd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01160c3:	85 c0                	test   %eax,%eax
f01160c5:	74 27                	je     f01160ee <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01160c7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01160cd:	83 ec 0c             	sub    $0xc,%esp
f01160d0:	6a 00                	push   $0x0
f01160d2:	50                   	push   %eax
f01160d3:	68 74 ac 12 f0       	push   $0xf012ac74
f01160d8:	68 78 07 00 00       	push   $0x778
f01160dd:	68 62 92 12 f0       	push   $0xf0129262
f01160e2:	e8 ef a3 fe ff       	call   f01004d6 <_warn>
f01160e7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160ea:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01160ee:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160f2:	74 04                	je     f01160f8 <test_calculate_allocated_space+0x5c7>
f01160f4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01160f8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f01160fc:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116103:	00 00 00 
		num_pages = 0;
f0116106:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011610d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116110:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116113:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116118:	89 c2                	mov    %eax,%edx
f011611a:	83 ec 0c             	sub    $0xc,%esp
f011611d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116123:	50                   	push   %eax
f0116124:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011612a:	50                   	push   %eax
f011612b:	52                   	push   %edx
f011612c:	68 ff ff 3f 00       	push   $0x3fffff
f0116131:	ff 75 d8             	pushl  -0x28(%ebp)
f0116134:	e8 89 4a ff ff       	call   f010abc2 <calculate_allocated_space>
f0116139:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011613c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116142:	85 c0                	test   %eax,%eax
f0116144:	74 27                	je     f011616d <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116146:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011614c:	83 ec 0c             	sub    $0xc,%esp
f011614f:	6a 00                	push   $0x0
f0116151:	50                   	push   %eax
f0116152:	68 14 ac 12 f0       	push   $0xf012ac14
f0116157:	68 84 07 00 00       	push   $0x784
f011615c:	68 62 92 12 f0       	push   $0xf0129262
f0116161:	e8 70 a3 fe ff       	call   f01004d6 <_warn>
f0116166:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116169:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011616d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116173:	85 c0                	test   %eax,%eax
f0116175:	74 27                	je     f011619e <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116177:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011617d:	83 ec 0c             	sub    $0xc,%esp
f0116180:	6a 00                	push   $0x0
f0116182:	50                   	push   %eax
f0116183:	68 74 ac 12 f0       	push   $0xf012ac74
f0116188:	68 89 07 00 00       	push   $0x789
f011618d:	68 62 92 12 f0       	push   $0xf0129262
f0116192:	e8 3f a3 fe ff       	call   f01004d6 <_warn>
f0116197:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011619a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011619e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01161a2:	74 04                	je     f01161a8 <test_calculate_allocated_space+0x677>
f01161a4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01161a8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01161ac:	83 ec 0c             	sub    $0xc,%esp
f01161af:	68 15 a6 12 f0       	push   $0xf012a615
f01161b4:	e8 d2 ad fe ff       	call   f0100f8b <cprintf>
f01161b9:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01161bc:	83 ec 0c             	sub    $0xc,%esp
f01161bf:	68 34 ab 12 f0       	push   $0xf012ab34
f01161c4:	e8 c2 ad fe ff       	call   f0100f8b <cprintf>
f01161c9:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01161cc:	83 ec 04             	sub    $0x4,%esp
f01161cf:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01161d5:	50                   	push   %eax
f01161d6:	68 ce 99 12 f0       	push   $0xf01299ce
f01161db:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01161e1:	50                   	push   %eax
f01161e2:	e8 6e a0 00 00       	call   f0120255 <strcconcat>
f01161e7:	83 c4 10             	add    $0x10,%esp
f01161ea:	83 ec 0c             	sub    $0xc,%esp
f01161ed:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f01161f3:	50                   	push   %eax
f01161f4:	e8 02 bd fe ff       	call   f0101efb <execute_command>
f01161f9:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f01161fc:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116203:	00 00 00 
		num_pages = 0;
f0116206:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011620d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0116210:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116213:	c1 e0 03             	shl    $0x3,%eax
f0116216:	89 c2                	mov    %eax,%edx
f0116218:	83 ec 0c             	sub    $0xc,%esp
f011621b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116221:	50                   	push   %eax
f0116222:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116228:	50                   	push   %eax
f0116229:	52                   	push   %edx
f011622a:	6a 00                	push   $0x0
f011622c:	ff 75 d8             	pushl  -0x28(%ebp)
f011622f:	e8 8e 49 ff ff       	call   f010abc2 <calculate_allocated_space>
f0116234:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116237:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f011623e:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116245:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011624b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011624e:	74 28                	je     f0116278 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116250:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116256:	83 ec 0c             	sub    $0xc,%esp
f0116259:	ff 75 c8             	pushl  -0x38(%ebp)
f011625c:	50                   	push   %eax
f011625d:	68 14 ac 12 f0       	push   $0xf012ac14
f0116262:	68 a0 07 00 00       	push   $0x7a0
f0116267:	68 62 92 12 f0       	push   $0xf0129262
f011626c:	e8 65 a2 fe ff       	call   f01004d6 <_warn>
f0116271:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116274:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116278:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011627e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116281:	74 28                	je     f01162ab <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116283:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116289:	83 ec 0c             	sub    $0xc,%esp
f011628c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011628f:	50                   	push   %eax
f0116290:	68 74 ac 12 f0       	push   $0xf012ac74
f0116295:	68 a5 07 00 00       	push   $0x7a5
f011629a:	68 62 92 12 f0       	push   $0xf0129262
f011629f:	e8 32 a2 fe ff       	call   f01004d6 <_warn>
f01162a4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162ab:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162af:	74 04                	je     f01162b5 <test_calculate_allocated_space+0x784>
f01162b1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162b5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01162b9:	83 ec 04             	sub    $0x4,%esp
f01162bc:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01162c2:	50                   	push   %eax
f01162c3:	68 db 99 12 f0       	push   $0xf01299db
f01162c8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01162ce:	50                   	push   %eax
f01162cf:	e8 81 9f 00 00       	call   f0120255 <strcconcat>
f01162d4:	83 c4 10             	add    $0x10,%esp
f01162d7:	83 ec 0c             	sub    $0xc,%esp
f01162da:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01162e0:	50                   	push   %eax
f01162e1:	e8 15 bc fe ff       	call   f0101efb <execute_command>
f01162e6:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01162e9:	83 ec 04             	sub    $0x4,%esp
f01162ec:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01162f2:	50                   	push   %eax
f01162f3:	68 68 ab 12 f0       	push   $0xf012ab68
f01162f8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01162fe:	50                   	push   %eax
f01162ff:	e8 51 9f 00 00       	call   f0120255 <strcconcat>
f0116304:	83 c4 10             	add    $0x10,%esp
f0116307:	83 ec 0c             	sub    $0xc,%esp
f011630a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116310:	50                   	push   %eax
f0116311:	e8 e5 bb fe ff       	call   f0101efb <execute_command>
f0116316:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0116319:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116320:	00 00 00 
		num_pages = 0;
f0116323:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011632a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f011632d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116330:	c1 e0 03             	shl    $0x3,%eax
f0116333:	89 c2                	mov    %eax,%edx
f0116335:	83 ec 0c             	sub    $0xc,%esp
f0116338:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011633e:	50                   	push   %eax
f011633f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116345:	50                   	push   %eax
f0116346:	52                   	push   %edx
f0116347:	6a 00                	push   $0x0
f0116349:	ff 75 d8             	pushl  -0x28(%ebp)
f011634c:	e8 71 48 ff ff       	call   f010abc2 <calculate_allocated_space>
f0116351:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116354:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f011635b:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116362:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116368:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011636b:	74 28                	je     f0116395 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011636d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116373:	83 ec 0c             	sub    $0xc,%esp
f0116376:	ff 75 c8             	pushl  -0x38(%ebp)
f0116379:	50                   	push   %eax
f011637a:	68 14 ac 12 f0       	push   $0xf012ac14
f011637f:	68 b6 07 00 00       	push   $0x7b6
f0116384:	68 62 92 12 f0       	push   $0xf0129262
f0116389:	e8 48 a1 fe ff       	call   f01004d6 <_warn>
f011638e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116391:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116395:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011639b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011639e:	74 28                	je     f01163c8 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01163a0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01163a6:	83 ec 0c             	sub    $0xc,%esp
f01163a9:	ff 75 c4             	pushl  -0x3c(%ebp)
f01163ac:	50                   	push   %eax
f01163ad:	68 74 ac 12 f0       	push   $0xf012ac74
f01163b2:	68 bb 07 00 00       	push   $0x7bb
f01163b7:	68 62 92 12 f0       	push   $0xf0129262
f01163bc:	e8 15 a1 fe ff       	call   f01004d6 <_warn>
f01163c1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163c4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01163c8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01163cc:	74 04                	je     f01163d2 <test_calculate_allocated_space+0x8a1>
f01163ce:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01163d2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01163d6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01163dd:	00 00 00 
		num_pages = 0;
f01163e0:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01163e7:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01163ea:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01163ed:	c1 e0 0a             	shl    $0xa,%eax
f01163f0:	89 c2                	mov    %eax,%edx
f01163f2:	83 ec 0c             	sub    $0xc,%esp
f01163f5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01163fb:	50                   	push   %eax
f01163fc:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116402:	50                   	push   %eax
f0116403:	52                   	push   %edx
f0116404:	6a 00                	push   $0x0
f0116406:	ff 75 d8             	pushl  -0x28(%ebp)
f0116409:	e8 b4 47 ff ff       	call   f010abc2 <calculate_allocated_space>
f011640e:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0116411:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0116418:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011641f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116425:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116428:	74 28                	je     f0116452 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011642a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116430:	83 ec 0c             	sub    $0xc,%esp
f0116433:	ff 75 c8             	pushl  -0x38(%ebp)
f0116436:	50                   	push   %eax
f0116437:	68 14 ac 12 f0       	push   $0xf012ac14
f011643c:	68 c9 07 00 00       	push   $0x7c9
f0116441:	68 62 92 12 f0       	push   $0xf0129262
f0116446:	e8 8b a0 fe ff       	call   f01004d6 <_warn>
f011644b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011644e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116452:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116458:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011645b:	74 28                	je     f0116485 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011645d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116463:	83 ec 0c             	sub    $0xc,%esp
f0116466:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116469:	50                   	push   %eax
f011646a:	68 74 ac 12 f0       	push   $0xf012ac74
f011646f:	68 ce 07 00 00       	push   $0x7ce
f0116474:	68 62 92 12 f0       	push   $0xf0129262
f0116479:	e8 58 a0 fe ff       	call   f01004d6 <_warn>
f011647e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116481:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116485:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116489:	74 04                	je     f011648f <test_calculate_allocated_space+0x95e>
f011648b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011648f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116493:	83 ec 04             	sub    $0x4,%esp
f0116496:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011649c:	50                   	push   %eax
f011649d:	68 74 ab 12 f0       	push   $0xf012ab74
f01164a2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01164a8:	50                   	push   %eax
f01164a9:	e8 a7 9d 00 00       	call   f0120255 <strcconcat>
f01164ae:	83 c4 10             	add    $0x10,%esp
f01164b1:	83 ec 0c             	sub    $0xc,%esp
f01164b4:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01164ba:	50                   	push   %eax
f01164bb:	e8 3b ba fe ff       	call   f0101efb <execute_command>
f01164c0:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f01164c3:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01164ca:	00 00 00 
		num_pages = 0;
f01164cd:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01164d4:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01164d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01164da:	89 c2                	mov    %eax,%edx
f01164dc:	01 d2                	add    %edx,%edx
f01164de:	01 d0                	add    %edx,%eax
f01164e0:	05 00 18 00 00       	add    $0x1800,%eax
f01164e5:	89 c2                	mov    %eax,%edx
f01164e7:	83 ec 0c             	sub    $0xc,%esp
f01164ea:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01164f0:	50                   	push   %eax
f01164f1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01164f7:	50                   	push   %eax
f01164f8:	52                   	push   %edx
f01164f9:	68 00 18 00 00       	push   $0x1800
f01164fe:	ff 75 d8             	pushl  -0x28(%ebp)
f0116501:	e8 bc 46 ff ff       	call   f010abc2 <calculate_allocated_space>
f0116506:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116509:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116510:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116517:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011651d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116520:	74 28                	je     f011654a <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116522:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116528:	83 ec 0c             	sub    $0xc,%esp
f011652b:	ff 75 c8             	pushl  -0x38(%ebp)
f011652e:	50                   	push   %eax
f011652f:	68 14 ac 12 f0       	push   $0xf012ac14
f0116534:	68 df 07 00 00       	push   $0x7df
f0116539:	68 62 92 12 f0       	push   $0xf0129262
f011653e:	e8 93 9f fe ff       	call   f01004d6 <_warn>
f0116543:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116546:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011654a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116550:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116553:	74 28                	je     f011657d <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116555:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011655b:	83 ec 0c             	sub    $0xc,%esp
f011655e:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116561:	50                   	push   %eax
f0116562:	68 74 ac 12 f0       	push   $0xf012ac74
f0116567:	68 e4 07 00 00       	push   $0x7e4
f011656c:	68 62 92 12 f0       	push   $0xf0129262
f0116571:	e8 60 9f fe ff       	call   f01004d6 <_warn>
f0116576:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116579:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011657d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116581:	74 04                	je     f0116587 <test_calculate_allocated_space+0xa56>
f0116583:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116587:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f011658b:	83 ec 04             	sub    $0x4,%esp
f011658e:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116594:	50                   	push   %eax
f0116595:	68 34 9c 12 f0       	push   $0xf0129c34
f011659a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01165a0:	50                   	push   %eax
f01165a1:	e8 af 9c 00 00       	call   f0120255 <strcconcat>
f01165a6:	83 c4 10             	add    $0x10,%esp
f01165a9:	83 ec 0c             	sub    $0xc,%esp
f01165ac:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01165b2:	50                   	push   %eax
f01165b3:	e8 43 b9 fe ff       	call   f0101efb <execute_command>
f01165b8:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f01165bb:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01165c2:	00 00 00 
		num_pages = 0;
f01165c5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01165cc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f01165cf:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01165d2:	89 d0                	mov    %edx,%eax
f01165d4:	c1 e0 02             	shl    $0x2,%eax
f01165d7:	01 d0                	add    %edx,%eax
f01165d9:	01 c0                	add    %eax,%eax
f01165db:	05 00 00 40 00       	add    $0x400000,%eax
f01165e0:	89 c2                	mov    %eax,%edx
f01165e2:	83 ec 0c             	sub    $0xc,%esp
f01165e5:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01165eb:	50                   	push   %eax
f01165ec:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01165f2:	50                   	push   %eax
f01165f3:	52                   	push   %edx
f01165f4:	68 00 00 40 00       	push   $0x400000
f01165f9:	ff 75 d8             	pushl  -0x28(%ebp)
f01165fc:	e8 c1 45 ff ff       	call   f010abc2 <calculate_allocated_space>
f0116601:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116604:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011660b:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116612:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116618:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011661b:	74 28                	je     f0116645 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011661d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116623:	83 ec 0c             	sub    $0xc,%esp
f0116626:	ff 75 c8             	pushl  -0x38(%ebp)
f0116629:	50                   	push   %eax
f011662a:	68 14 ac 12 f0       	push   $0xf012ac14
f011662f:	68 f4 07 00 00       	push   $0x7f4
f0116634:	68 62 92 12 f0       	push   $0xf0129262
f0116639:	e8 98 9e fe ff       	call   f01004d6 <_warn>
f011663e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116641:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116645:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011664b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011664e:	74 28                	je     f0116678 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116650:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116656:	83 ec 0c             	sub    $0xc,%esp
f0116659:	ff 75 c4             	pushl  -0x3c(%ebp)
f011665c:	50                   	push   %eax
f011665d:	68 74 ac 12 f0       	push   $0xf012ac74
f0116662:	68 f9 07 00 00       	push   $0x7f9
f0116667:	68 62 92 12 f0       	push   $0xf0129262
f011666c:	e8 65 9e fe ff       	call   f01004d6 <_warn>
f0116671:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116674:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116678:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011667c:	74 04                	je     f0116682 <test_calculate_allocated_space+0xb51>
f011667e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116682:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116686:	83 ec 04             	sub    $0x4,%esp
f0116689:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011668f:	50                   	push   %eax
f0116690:	68 3e 9c 12 f0       	push   $0xf0129c3e
f0116695:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011669b:	50                   	push   %eax
f011669c:	e8 b4 9b 00 00       	call   f0120255 <strcconcat>
f01166a1:	83 c4 10             	add    $0x10,%esp
f01166a4:	83 ec 0c             	sub    $0xc,%esp
f01166a7:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01166ad:	50                   	push   %eax
f01166ae:	e8 48 b8 fe ff       	call   f0101efb <execute_command>
f01166b3:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01166b6:	83 ec 04             	sub    $0x4,%esp
f01166b9:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01166bf:	50                   	push   %eax
f01166c0:	68 7c ab 12 f0       	push   $0xf012ab7c
f01166c5:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01166cb:	50                   	push   %eax
f01166cc:	e8 84 9b 00 00       	call   f0120255 <strcconcat>
f01166d1:	83 c4 10             	add    $0x10,%esp
f01166d4:	83 ec 0c             	sub    $0xc,%esp
f01166d7:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01166dd:	50                   	push   %eax
f01166de:	e8 18 b8 fe ff       	call   f0101efb <execute_command>
f01166e3:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f01166e6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01166ed:	00 00 00 
		num_pages = 0;
f01166f0:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01166f7:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01166fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01166fd:	05 00 00 38 00       	add    $0x380000,%eax
f0116702:	01 c0                	add    %eax,%eax
f0116704:	89 c2                	mov    %eax,%edx
f0116706:	83 ec 0c             	sub    $0xc,%esp
f0116709:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011670f:	50                   	push   %eax
f0116710:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116716:	50                   	push   %eax
f0116717:	52                   	push   %edx
f0116718:	68 00 00 70 00       	push   $0x700000
f011671d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116720:	e8 9d 44 ff ff       	call   f010abc2 <calculate_allocated_space>
f0116725:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116728:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f011672f:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116736:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011673c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011673f:	74 28                	je     f0116769 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116741:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116747:	83 ec 0c             	sub    $0xc,%esp
f011674a:	ff 75 c8             	pushl  -0x38(%ebp)
f011674d:	50                   	push   %eax
f011674e:	68 14 ac 12 f0       	push   $0xf012ac14
f0116753:	68 0b 08 00 00       	push   $0x80b
f0116758:	68 62 92 12 f0       	push   $0xf0129262
f011675d:	e8 74 9d fe ff       	call   f01004d6 <_warn>
f0116762:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116765:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116769:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011676f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116772:	74 28                	je     f011679c <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116774:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011677a:	83 ec 0c             	sub    $0xc,%esp
f011677d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116780:	50                   	push   %eax
f0116781:	68 74 ac 12 f0       	push   $0xf012ac74
f0116786:	68 10 08 00 00       	push   $0x810
f011678b:	68 62 92 12 f0       	push   $0xf0129262
f0116790:	e8 41 9d fe ff       	call   f01004d6 <_warn>
f0116795:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116798:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011679c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01167a0:	74 04                	je     f01167a6 <test_calculate_allocated_space+0xc75>
f01167a2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01167a6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f01167aa:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01167b1:	00 00 00 
		num_pages = 0;
f01167b4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01167bb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01167be:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01167c1:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01167c6:	89 c2                	mov    %eax,%edx
f01167c8:	83 ec 0c             	sub    $0xc,%esp
f01167cb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01167d1:	50                   	push   %eax
f01167d2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01167d8:	50                   	push   %eax
f01167d9:	52                   	push   %edx
f01167da:	68 ff ff 3f 00       	push   $0x3fffff
f01167df:	ff 75 d8             	pushl  -0x28(%ebp)
f01167e2:	e8 db 43 ff ff       	call   f010abc2 <calculate_allocated_space>
f01167e7:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01167ea:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f01167f1:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01167f8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167fe:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116801:	74 28                	je     f011682b <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116803:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116809:	83 ec 0c             	sub    $0xc,%esp
f011680c:	ff 75 c8             	pushl  -0x38(%ebp)
f011680f:	50                   	push   %eax
f0116810:	68 14 ac 12 f0       	push   $0xf012ac14
f0116815:	68 1e 08 00 00       	push   $0x81e
f011681a:	68 62 92 12 f0       	push   $0xf0129262
f011681f:	e8 b2 9c fe ff       	call   f01004d6 <_warn>
f0116824:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116827:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011682b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116831:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116834:	74 28                	je     f011685e <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116836:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011683c:	83 ec 0c             	sub    $0xc,%esp
f011683f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116842:	50                   	push   %eax
f0116843:	68 74 ac 12 f0       	push   $0xf012ac74
f0116848:	68 23 08 00 00       	push   $0x823
f011684d:	68 62 92 12 f0       	push   $0xf0129262
f0116852:	e8 7f 9c fe ff       	call   f01004d6 <_warn>
f0116857:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011685a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011685e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116862:	74 04                	je     f0116868 <test_calculate_allocated_space+0xd37>
f0116864:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116868:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011686c:	83 ec 0c             	sub    $0xc,%esp
f011686f:	68 ef 9b 12 f0       	push   $0xf0129bef
f0116874:	e8 12 a7 fe ff       	call   f0100f8b <cprintf>
f0116879:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011687c:	83 ec 08             	sub    $0x8,%esp
f011687f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116882:	68 d0 ac 12 f0       	push   $0xf012acd0
f0116887:	e8 ff a6 fe ff       	call   f0100f8b <cprintf>
f011688c:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011688f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116893:	75 10                	jne    f01168a5 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116895:	83 ec 0c             	sub    $0xc,%esp
f0116898:	68 10 ad 12 f0       	push   $0xf012ad10
f011689d:	e8 e9 a6 fe ff       	call   f0100f8b <cprintf>
f01168a2:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01168a5:	a1 e4 2d 6c f0       	mov    0xf06c2de4,%eax
f01168aa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01168ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01168b0:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01168b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01168b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01168bb:	5b                   	pop    %ebx
f01168bc:	5e                   	pop    %esi
f01168bd:	5f                   	pop    %edi
f01168be:	5d                   	pop    %ebp
f01168bf:	c3                   	ret    

f01168c0 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01168c0:	55                   	push   %ebp
f01168c1:	89 e5                	mov    %esp,%ebp
f01168c3:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01168c6:	8b 45 10             	mov    0x10(%ebp),%eax
f01168c9:	ba 01 00 00 00       	mov    $0x1,%edx
f01168ce:	88 c1                	mov    %al,%cl
f01168d0:	d3 e2                	shl    %cl,%edx
f01168d2:	89 d0                	mov    %edx,%eax
f01168d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01168d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168da:	c1 e8 16             	shr    $0x16,%eax
f01168dd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01168e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01168e7:	01 d0                	add    %edx,%eax
f01168e9:	8b 00                	mov    (%eax),%eax
f01168eb:	83 e0 01             	and    $0x1,%eax
f01168ee:	85 c0                	test   %eax,%eax
f01168f0:	75 07                	jne    f01168f9 <CB+0x39>
f01168f2:	b8 00 00 00 00       	mov    $0x0,%eax
f01168f7:	eb 76                	jmp    f011696f <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01168f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168fc:	c1 e8 16             	shr    $0x16,%eax
f01168ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116906:	8b 45 08             	mov    0x8(%ebp),%eax
f0116909:	01 d0                	add    %edx,%eax
f011690b:	8b 00                	mov    (%eax),%eax
f011690d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116912:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116915:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116918:	c1 e8 0c             	shr    $0xc,%eax
f011691b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011691e:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0116923:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116926:	72 17                	jb     f011693f <CB+0x7f>
f0116928:	ff 75 f0             	pushl  -0x10(%ebp)
f011692b:	68 5c ad 12 f0       	push   $0xf012ad5c
f0116930:	68 3e 08 00 00       	push   $0x83e
f0116935:	68 62 92 12 f0       	push   $0xf0129262
f011693a:	e8 fa 99 fe ff       	call   f0100339 <_panic>
f011693f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116942:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116947:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f011694a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011694d:	c1 e8 0c             	shr    $0xc,%eax
f0116950:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116955:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011695c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011695f:	01 d0                	add    %edx,%eax
f0116961:	8b 00                	mov    (%eax),%eax
f0116963:	23 45 f4             	and    -0xc(%ebp),%eax
f0116966:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116969:	0f 94 c0             	sete   %al
f011696c:	0f b6 c0             	movzbl %al,%eax
}
f011696f:	c9                   	leave  
f0116970:	c3                   	ret    

f0116971 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116971:	55                   	push   %ebp
f0116972:	89 e5                	mov    %esp,%ebp
f0116974:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116977:	68 8b ad 12 f0       	push   $0xf012ad8b
f011697c:	68 9a ad 12 f0       	push   $0xf012ad9a
f0116981:	68 43 08 00 00       	push   $0x843
f0116986:	68 62 92 12 f0       	push   $0xf0129262
f011698b:	e8 a9 99 fe ff       	call   f0100339 <_panic>

f0116990 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116990:	55                   	push   %ebp
f0116991:	89 e5                	mov    %esp,%ebp
f0116993:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116996:	68 8b ad 12 f0       	push   $0xf012ad8b
f011699b:	68 9a ad 12 f0       	push   $0xf012ad9a
f01169a0:	68 4d 08 00 00       	push   $0x84d
f01169a5:	68 62 92 12 f0       	push   $0xf0129262
f01169aa:	e8 8a 99 fe ff       	call   f0100339 <_panic>

f01169af <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f01169af:	55                   	push   %ebp
f01169b0:	89 e5                	mov    %esp,%ebp
f01169b2:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01169b5:	68 8b ad 12 f0       	push   $0xf012ad8b
f01169ba:	68 9a ad 12 f0       	push   $0xf012ad9a
f01169bf:	68 5c 08 00 00       	push   $0x85c
f01169c4:	68 62 92 12 f0       	push   $0xf0129262
f01169c9:	e8 6b 99 fe ff       	call   f0100339 <_panic>

f01169ce <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f01169ce:	55                   	push   %ebp
f01169cf:	89 e5                	mov    %esp,%ebp
f01169d1:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01169d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01169d7:	c1 e8 16             	shr    $0x16,%eax
f01169da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01169e1:	8b 45 08             	mov    0x8(%ebp),%eax
f01169e4:	01 d0                	add    %edx,%eax
f01169e6:	8b 00                	mov    (%eax),%eax
f01169e8:	83 e0 01             	and    $0x1,%eax
f01169eb:	85 c0                	test   %eax,%eax
f01169ed:	75 07                	jne    f01169f6 <CE+0x28>
f01169ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01169f4:	eb 7a                	jmp    f0116a70 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01169f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01169f9:	c1 e8 16             	shr    $0x16,%eax
f01169fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a03:	8b 45 08             	mov    0x8(%ebp),%eax
f0116a06:	01 d0                	add    %edx,%eax
f0116a08:	8b 00                	mov    (%eax),%eax
f0116a0a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116a0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116a12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116a15:	c1 e8 0c             	shr    $0xc,%eax
f0116a18:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116a1b:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f0116a20:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116a23:	72 17                	jb     f0116a3c <CE+0x6e>
f0116a25:	ff 75 f4             	pushl  -0xc(%ebp)
f0116a28:	68 5c ad 12 f0       	push   $0xf012ad5c
f0116a2d:	68 65 08 00 00       	push   $0x865
f0116a32:	68 62 92 12 f0       	push   $0xf0129262
f0116a37:	e8 fd 98 fe ff       	call   f0100339 <_panic>
f0116a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116a3f:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116a47:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a4a:	c1 e8 0c             	shr    $0xc,%eax
f0116a4d:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116a52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a59:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116a5c:	01 d0                	add    %edx,%eax
f0116a5e:	8b 00                	mov    (%eax),%eax
f0116a60:	85 c0                	test   %eax,%eax
f0116a62:	74 07                	je     f0116a6b <CE+0x9d>
f0116a64:	b8 00 00 00 00       	mov    $0x0,%eax
f0116a69:	eb 05                	jmp    f0116a70 <CE+0xa2>
	return 1;
f0116a6b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116a70:	c9                   	leave  
f0116a71:	c3                   	ret    

f0116a72 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116a72:	55                   	push   %ebp
f0116a73:	89 e5                	mov    %esp,%ebp
f0116a75:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116a78:	68 8b ad 12 f0       	push   $0xf012ad8b
f0116a7d:	68 9a ad 12 f0       	push   $0xf012ad9a
f0116a82:	68 6c 08 00 00       	push   $0x86c
f0116a87:	68 62 92 12 f0       	push   $0xf0129262
f0116a8c:	e8 a8 98 fe ff       	call   f0100339 <_panic>

f0116a91 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116a91:	55                   	push   %ebp
f0116a92:	89 e5                	mov    %esp,%ebp
f0116a94:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116a97:	68 8b ad 12 f0       	push   $0xf012ad8b
f0116a9c:	68 9a ad 12 f0       	push   $0xf012ad9a
f0116aa1:	68 7c 08 00 00       	push   $0x87c
f0116aa6:	68 62 92 12 f0       	push   $0xf0129262
f0116aab:	e8 89 98 fe ff       	call   f0100339 <_panic>

f0116ab0 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0116ab0:	55                   	push   %ebp
f0116ab1:	89 e5                	mov    %esp,%ebp
f0116ab3:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116ab6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116abd:	eb 18                	jmp    f0116ad7 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116abf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116ac2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0116acc:	01 d0                	add    %edx,%eax
f0116ace:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116ad4:	ff 45 fc             	incl   -0x4(%ebp)
f0116ad7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116ada:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116adf:	76 de                	jbe    f0116abf <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116ae1:	90                   	nop
f0116ae2:	c9                   	leave  
f0116ae3:	c3                   	ret    

f0116ae4 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116ae4:	55                   	push   %ebp
f0116ae5:	89 e5                	mov    %esp,%ebp
f0116ae7:	83 ec 38             	sub    $0x38,%esp
f0116aea:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116aed:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116af0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116af3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116af8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116afb:	8b 45 10             	mov    0x10(%ebp),%eax
f0116afe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116b03:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116b06:	e9 ea 01 00 00       	jmp    f0116cf5 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116b0b:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116b0f:	74 44                	je     f0116b55 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116b11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116b14:	83 ec 04             	sub    $0x4,%esp
f0116b17:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116b1a:	52                   	push   %edx
f0116b1b:	50                   	push   %eax
f0116b1c:	ff 75 08             	pushl  0x8(%ebp)
f0116b1f:	e8 45 1c ff ff       	call   f0108769 <get_frame_info>
f0116b24:	83 c4 10             	add    $0x10,%esp
f0116b27:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116b2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116b2d:	85 c0                	test   %eax,%eax
f0116b2f:	75 24                	jne    f0116b55 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116b31:	83 ec 04             	sub    $0x4,%esp
f0116b34:	68 b0 ad 12 f0       	push   $0xf012adb0
f0116b39:	68 99 08 00 00       	push   $0x899
f0116b3e:	68 62 92 12 f0       	push   $0xf0129262
f0116b43:	e8 8e 99 fe ff       	call   f01004d6 <_warn>
f0116b48:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116b4b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b50:	e9 b6 01 00 00       	jmp    f0116d0b <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116b55:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116b58:	83 ec 04             	sub    $0x4,%esp
f0116b5b:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116b5e:	52                   	push   %edx
f0116b5f:	50                   	push   %eax
f0116b60:	ff 75 08             	pushl  0x8(%ebp)
f0116b63:	e8 01 1c ff ff       	call   f0108769 <get_frame_info>
f0116b68:	83 c4 10             	add    $0x10,%esp
f0116b6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116b6e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116b71:	85 c0                	test   %eax,%eax
f0116b73:	75 24                	jne    f0116b99 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116b75:	83 ec 04             	sub    $0x4,%esp
f0116b78:	68 dc ad 12 f0       	push   $0xf012addc
f0116b7d:	68 a0 08 00 00       	push   $0x8a0
f0116b82:	68 62 92 12 f0       	push   $0xf0129262
f0116b87:	e8 4a 99 fe ff       	call   f01004d6 <_warn>
f0116b8c:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116b8f:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b94:	e9 72 01 00 00       	jmp    f0116d0b <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116b99:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116b9d:	75 70                	jne    f0116c0f <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116b9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116ba2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116ba5:	c1 ea 0c             	shr    $0xc,%edx
f0116ba8:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116bae:	c1 e2 02             	shl    $0x2,%edx
f0116bb1:	01 d0                	add    %edx,%eax
f0116bb3:	8b 00                	mov    (%eax),%eax
f0116bb5:	c1 e8 0c             	shr    $0xc,%eax
f0116bb8:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116bbb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116bbe:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116bc1:	c1 ea 0c             	shr    $0xc,%edx
f0116bc4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116bca:	c1 e2 02             	shl    $0x2,%edx
f0116bcd:	01 d0                	add    %edx,%eax
f0116bcf:	8b 00                	mov    (%eax),%eax
f0116bd1:	c1 e8 0c             	shr    $0xc,%eax
f0116bd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116bd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116bda:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116bdd:	74 30                	je     f0116c0f <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116bdf:	83 ec 04             	sub    $0x4,%esp
f0116be2:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116be5:	ff 75 e8             	pushl  -0x18(%ebp)
f0116be8:	ff 75 f0             	pushl  -0x10(%ebp)
f0116beb:	ff 75 f4             	pushl  -0xc(%ebp)
f0116bee:	68 08 ae 12 f0       	push   $0xf012ae08
f0116bf3:	68 aa 08 00 00       	push   $0x8aa
f0116bf8:	68 62 92 12 f0       	push   $0xf0129262
f0116bfd:	e8 d4 98 fe ff       	call   f01004d6 <_warn>
f0116c02:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116c05:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c0a:	e9 fc 00 00 00       	jmp    f0116d0b <CCP+0x227>
			}
		}
		if (ref != -1)
f0116c0f:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116c13:	74 52                	je     f0116c67 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116c15:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116c19:	74 0e                	je     f0116c29 <CCP+0x145>
f0116c1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c1e:	8b 40 08             	mov    0x8(%eax),%eax
f0116c21:	0f b7 c0             	movzwl %ax,%eax
f0116c24:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116c27:	74 3e                	je     f0116c67 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116c29:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116c2d:	74 0b                	je     f0116c3a <CCP+0x156>
f0116c2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c32:	8b 40 08             	mov    0x8(%eax),%eax
f0116c35:	0f b7 c0             	movzwl %ax,%eax
f0116c38:	eb 05                	jmp    f0116c3f <CCP+0x15b>
f0116c3a:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c3f:	83 ec 0c             	sub    $0xc,%esp
f0116c42:	50                   	push   %eax
f0116c43:	ff 75 f0             	pushl  -0x10(%ebp)
f0116c46:	68 64 ae 12 f0       	push   $0xf012ae64
f0116c4b:	68 b2 08 00 00       	push   $0x8b2
f0116c50:	68 62 92 12 f0       	push   $0xf0129262
f0116c55:	e8 7c 98 fe ff       	call   f01004d6 <_warn>
f0116c5a:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116c5d:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c62:	e9 a4 00 00 00       	jmp    f0116d0b <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116c67:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116c6a:	ff 75 20             	pushl  0x20(%ebp)
f0116c6d:	ff 75 1c             	pushl  0x1c(%ebp)
f0116c70:	50                   	push   %eax
f0116c71:	ff 75 08             	pushl  0x8(%ebp)
f0116c74:	e8 17 fd ff ff       	call   f0116990 <CPs>
f0116c79:	83 c4 10             	add    $0x10,%esp
f0116c7c:	85 c0                	test   %eax,%eax
f0116c7e:	7f 21                	jg     f0116ca1 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116c80:	83 ec 04             	sub    $0x4,%esp
f0116c83:	68 d4 ae 12 f0       	push   $0xf012aed4
f0116c88:	68 b8 08 00 00       	push   $0x8b8
f0116c8d:	68 62 92 12 f0       	push   $0xf0129262
f0116c92:	e8 3f 98 fe ff       	call   f01004d6 <_warn>
f0116c97:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116c9a:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c9f:	eb 6a                	jmp    f0116d0b <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116ca1:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116ca5:	74 3a                	je     f0116ce1 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116ca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116caa:	ff 75 28             	pushl  0x28(%ebp)
f0116cad:	ff 75 24             	pushl  0x24(%ebp)
f0116cb0:	50                   	push   %eax
f0116cb1:	ff 75 08             	pushl  0x8(%ebp)
f0116cb4:	e8 d7 fc ff ff       	call   f0116990 <CPs>
f0116cb9:	83 c4 10             	add    $0x10,%esp
f0116cbc:	85 c0                	test   %eax,%eax
f0116cbe:	7f 21                	jg     f0116ce1 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116cc0:	83 ec 04             	sub    $0x4,%esp
f0116cc3:	68 1c af 12 f0       	push   $0xf012af1c
f0116cc8:	68 bf 08 00 00       	push   $0x8bf
f0116ccd:	68 62 92 12 f0       	push   $0xf0129262
f0116cd2:	e8 ff 97 fe ff       	call   f01004d6 <_warn>
f0116cd7:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116cda:	b8 00 00 00 00       	mov    $0x0,%eax
f0116cdf:	eb 2a                	jmp    f0116d0b <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116ce1:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116ce5:	74 07                	je     f0116cee <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116ce7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116cee:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116cf5:	8b 55 10             	mov    0x10(%ebp),%edx
f0116cf8:	8b 45 14             	mov    0x14(%ebp),%eax
f0116cfb:	01 d0                	add    %edx,%eax
f0116cfd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116d00:	0f 87 05 fe ff ff    	ja     f0116b0b <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116d06:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116d0b:	c9                   	leave  
f0116d0c:	c3                   	ret    

f0116d0d <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116d0d:	55                   	push   %ebp
f0116d0e:	89 e5                	mov    %esp,%ebp
f0116d10:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116d13:	83 ec 04             	sub    $0x4,%esp
f0116d16:	68 5c af 12 f0       	push   $0xf012af5c
f0116d1b:	6a 0e                	push   $0xe
f0116d1d:	68 6c af 12 f0       	push   $0xf012af6c
f0116d22:	e8 12 96 fe ff       	call   f0100339 <_panic>

f0116d27 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116d27:	55                   	push   %ebp
f0116d28:	89 e5                	mov    %esp,%ebp
f0116d2a:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116d2d:	83 ec 04             	sub    $0x4,%esp
f0116d30:	68 5c af 12 f0       	push   $0xf012af5c
f0116d35:	68 d7 00 00 00       	push   $0xd7
f0116d3a:	68 6c af 12 f0       	push   $0xf012af6c
f0116d3f:	e8 f5 95 fe ff       	call   f0100339 <_panic>

f0116d44 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116d44:	55                   	push   %ebp
f0116d45:	89 e5                	mov    %esp,%ebp
f0116d47:	57                   	push   %edi
f0116d48:	53                   	push   %ebx
f0116d49:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116d4f:	83 ec 0c             	sub    $0xc,%esp
f0116d52:	68 88 af 12 f0       	push   $0xf012af88
f0116d57:	e8 2f a2 fe ff       	call   f0100f8b <cprintf>
f0116d5c:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116d5f:	83 ec 0c             	sub    $0xc,%esp
f0116d62:	68 b8 af 12 f0       	push   $0xf012afb8
f0116d67:	e8 1f a2 fe ff       	call   f0100f8b <cprintf>
f0116d6c:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0116d6f:	83 ec 0c             	sub    $0xc,%esp
f0116d72:	68 88 af 12 f0       	push   $0xf012af88
f0116d77:	e8 0f a2 fe ff       	call   f0100f8b <cprintf>
f0116d7c:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0116d7f:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0116d83:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0116d87:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0116d8d:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0116d93:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0116d9a:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0116da1:	e8 16 7c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116da6:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0116da9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0116db0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0116db7:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0116dbd:	b9 14 00 00 00       	mov    $0x14,%ecx
f0116dc2:	b8 00 00 00 00       	mov    $0x0,%eax
f0116dc7:	89 d7                	mov    %edx,%edi
f0116dc9:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0116dcb:	83 ec 0c             	sub    $0xc,%esp
f0116dce:	68 11 b0 12 f0       	push   $0xf012b011
f0116dd3:	e8 b3 a1 fe ff       	call   f0100f8b <cprintf>
f0116dd8:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116ddb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0116de2:	e8 d5 7b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116de7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116dea:	e8 b6 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116def:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0116df2:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0116df9:	83 ec 0c             	sub    $0xc,%esp
f0116dfc:	ff 75 cc             	pushl  -0x34(%ebp)
f0116dff:	e8 9b 27 ff ff       	call   f010959f <kmalloc>
f0116e04:	83 c4 10             	add    $0x10,%esp
f0116e07:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0116e0d:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116e13:	85 c0                	test   %eax,%eax
f0116e15:	74 17                	je     f0116e2e <test_kmalloc+0xea>
f0116e17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e1e:	83 ec 0c             	sub    $0xc,%esp
f0116e21:	68 30 b0 12 f0       	push   $0xf012b030
f0116e26:	e8 60 a1 fe ff       	call   f0100f8b <cprintf>
f0116e2b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116e2e:	e8 72 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e33:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116e36:	74 17                	je     f0116e4f <test_kmalloc+0x10b>
f0116e38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e3f:	83 ec 0c             	sub    $0xc,%esp
f0116e42:	68 64 b0 12 f0       	push   $0xf012b064
f0116e47:	e8 3f a1 fe ff       	call   f0100f8b <cprintf>
f0116e4c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116e4f:	e8 68 7b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116e54:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116e57:	74 17                	je     f0116e70 <test_kmalloc+0x12c>
f0116e59:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e60:	83 ec 0c             	sub    $0xc,%esp
f0116e63:	68 d0 b0 12 f0       	push   $0xf012b0d0
f0116e68:	e8 1e a1 fe ff       	call   f0100f8b <cprintf>
f0116e6d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116e70:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116e74:	74 04                	je     f0116e7a <test_kmalloc+0x136>
f0116e76:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0116e7a:	83 ec 0c             	sub    $0xc,%esp
f0116e7d:	68 14 b1 12 f0       	push   $0xf012b114
f0116e82:	e8 04 a1 fe ff       	call   f0100f8b <cprintf>
f0116e87:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116e8a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116e91:	e8 26 7b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116e96:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116e99:	e8 07 da fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116e9e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0116ea1:	83 ec 0c             	sub    $0xc,%esp
f0116ea4:	68 00 fc 1f 00       	push   $0x1ffc00
f0116ea9:	e8 f1 26 ff ff       	call   f010959f <kmalloc>
f0116eae:	83 c4 10             	add    $0x10,%esp
f0116eb1:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116eb7:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116ebd:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0116ec2:	74 17                	je     f0116edb <test_kmalloc+0x197>
f0116ec4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ecb:	83 ec 0c             	sub    $0xc,%esp
f0116ece:	68 58 b1 12 f0       	push   $0xf012b158
f0116ed3:	e8 b3 a0 fe ff       	call   f0100f8b <cprintf>
f0116ed8:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116edb:	e8 c5 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116ee0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116ee3:	74 17                	je     f0116efc <test_kmalloc+0x1b8>
f0116ee5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116eec:	83 ec 0c             	sub    $0xc,%esp
f0116eef:	68 ac b1 12 f0       	push   $0xf012b1ac
f0116ef4:	e8 92 a0 fe ff       	call   f0100f8b <cprintf>
f0116ef9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116efc:	e8 bb 7a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116f01:	89 c2                	mov    %eax,%edx
f0116f03:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116f06:	29 d0                	sub    %edx,%eax
f0116f08:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116f0d:	7f 17                	jg     f0116f26 <test_kmalloc+0x1e2>
f0116f0f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f16:	83 ec 0c             	sub    $0xc,%esp
f0116f19:	68 18 b2 12 f0       	push   $0xf012b218
f0116f1e:	e8 68 a0 fe ff       	call   f0100f8b <cprintf>
f0116f23:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116f26:	e8 91 7a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116f2b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f2e:	e8 72 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f33:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0116f36:	83 ec 0c             	sub    $0xc,%esp
f0116f39:	68 00 fc 1f 00       	push   $0x1ffc00
f0116f3e:	e8 5c 26 ff ff       	call   f010959f <kmalloc>
f0116f43:	83 c4 10             	add    $0x10,%esp
f0116f46:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116f4c:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116f52:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0116f57:	74 17                	je     f0116f70 <test_kmalloc+0x22c>
f0116f59:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f60:	83 ec 0c             	sub    $0xc,%esp
f0116f63:	68 5c b2 12 f0       	push   $0xf012b25c
f0116f68:	e8 1e a0 fe ff       	call   f0100f8b <cprintf>
f0116f6d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116f70:	e8 30 d9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116f75:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116f78:	74 17                	je     f0116f91 <test_kmalloc+0x24d>
f0116f7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f81:	83 ec 0c             	sub    $0xc,%esp
f0116f84:	68 b0 b2 12 f0       	push   $0xf012b2b0
f0116f89:	e8 fd 9f fe ff       	call   f0100f8b <cprintf>
f0116f8e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116f91:	e8 26 7a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116f96:	89 c2                	mov    %eax,%edx
f0116f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116f9b:	29 d0                	sub    %edx,%eax
f0116f9d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116fa2:	7f 17                	jg     f0116fbb <test_kmalloc+0x277>
f0116fa4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fab:	83 ec 0c             	sub    $0xc,%esp
f0116fae:	68 1c b3 12 f0       	push   $0xf012b31c
f0116fb3:	e8 d3 9f fe ff       	call   f0100f8b <cprintf>
f0116fb8:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0116fbb:	e8 fc 79 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0116fc0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116fc3:	e8 dd d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116fc8:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0116fcb:	83 ec 0c             	sub    $0xc,%esp
f0116fce:	68 ff 07 00 00       	push   $0x7ff
f0116fd3:	e8 c7 25 ff ff       	call   f010959f <kmalloc>
f0116fd8:	83 c4 10             	add    $0x10,%esp
f0116fdb:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0116fe1:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116fe7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116fec:	76 28                	jbe    f0117016 <test_kmalloc+0x2d2>
f0116fee:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0116ff4:	83 ec 0c             	sub    $0xc,%esp
f0116ff7:	6a 00                	push   $0x0
f0116ff9:	e8 6e 24 ff ff       	call   f010946c <sbrk>
f0116ffe:	83 c4 10             	add    $0x10,%esp
f0117001:	39 c3                	cmp    %eax,%ebx
f0117003:	73 11                	jae    f0117016 <test_kmalloc+0x2d2>
f0117005:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011700b:	89 c2                	mov    %eax,%edx
f011700d:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0117012:	39 c2                	cmp    %eax,%edx
f0117014:	72 17                	jb     f011702d <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0117016:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011701d:	83 ec 0c             	sub    $0xc,%esp
f0117020:	68 60 b3 12 f0       	push   $0xf012b360
f0117025:	e8 61 9f fe ff       	call   f0100f8b <cprintf>
f011702a:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011702d:	e8 73 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117032:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117035:	74 17                	je     f011704e <test_kmalloc+0x30a>
f0117037:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011703e:	83 ec 0c             	sub    $0xc,%esp
f0117041:	68 ec b3 12 f0       	push   $0xf012b3ec
f0117046:	e8 40 9f fe ff       	call   f0100f8b <cprintf>
f011704b:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011704e:	e8 52 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117053:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0117056:	83 ec 0c             	sub    $0xc,%esp
f0117059:	68 ff 07 00 00       	push   $0x7ff
f011705e:	e8 3c 25 ff ff       	call   f010959f <kmalloc>
f0117063:	83 c4 10             	add    $0x10,%esp
f0117066:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011706c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117072:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117077:	76 28                	jbe    f01170a1 <test_kmalloc+0x35d>
f0117079:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011707f:	83 ec 0c             	sub    $0xc,%esp
f0117082:	6a 00                	push   $0x0
f0117084:	e8 e3 23 ff ff       	call   f010946c <sbrk>
f0117089:	83 c4 10             	add    $0x10,%esp
f011708c:	39 c3                	cmp    %eax,%ebx
f011708e:	73 11                	jae    f01170a1 <test_kmalloc+0x35d>
f0117090:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117096:	89 c2                	mov    %eax,%edx
f0117098:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011709d:	39 c2                	cmp    %eax,%edx
f011709f:	72 17                	jb     f01170b8 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01170a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170a8:	83 ec 0c             	sub    $0xc,%esp
f01170ab:	68 58 b4 12 f0       	push   $0xf012b458
f01170b0:	e8 d6 9e fe ff       	call   f0100f8b <cprintf>
f01170b5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170b8:	e8 e8 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01170bd:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01170c0:	74 17                	je     f01170d9 <test_kmalloc+0x395>
f01170c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170c9:	83 ec 0c             	sub    $0xc,%esp
f01170cc:	68 e4 b4 12 f0       	push   $0xf012b4e4
f01170d1:	e8 b5 9e fe ff       	call   f0100f8b <cprintf>
f01170d6:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f01170d9:	e8 de 78 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01170de:	89 c2                	mov    %eax,%edx
f01170e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01170e3:	29 d0                	sub    %edx,%eax
f01170e5:	83 f8 01             	cmp    $0x1,%eax
f01170e8:	74 17                	je     f0117101 <test_kmalloc+0x3bd>
f01170ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170f1:	83 ec 0c             	sub    $0xc,%esp
f01170f4:	68 50 b5 12 f0       	push   $0xf012b550
f01170f9:	e8 8d 9e fe ff       	call   f0100f8b <cprintf>
f01170fe:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117101:	e8 b6 78 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117106:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117109:	e8 97 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011710e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0117111:	83 ec 0c             	sub    $0xc,%esp
f0117114:	68 00 1c 00 00       	push   $0x1c00
f0117119:	e8 81 24 ff ff       	call   f010959f <kmalloc>
f011711e:	83 c4 10             	add    $0x10,%esp
f0117121:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117127:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011712d:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117132:	74 17                	je     f011714b <test_kmalloc+0x407>
f0117134:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011713b:	83 ec 0c             	sub    $0xc,%esp
f011713e:	68 70 b5 12 f0       	push   $0xf012b570
f0117143:	e8 43 9e fe ff       	call   f0100f8b <cprintf>
f0117148:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011714b:	e8 55 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117150:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117153:	74 17                	je     f011716c <test_kmalloc+0x428>
f0117155:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011715c:	83 ec 0c             	sub    $0xc,%esp
f011715f:	68 c4 b5 12 f0       	push   $0xf012b5c4
f0117164:	e8 22 9e fe ff       	call   f0100f8b <cprintf>
f0117169:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011716c:	e8 4b 78 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117171:	89 c2                	mov    %eax,%edx
f0117173:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117176:	29 d0                	sub    %edx,%eax
f0117178:	83 f8 01             	cmp    $0x1,%eax
f011717b:	7f 17                	jg     f0117194 <test_kmalloc+0x450>
f011717d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117184:	83 ec 0c             	sub    $0xc,%esp
f0117187:	68 30 b6 12 f0       	push   $0xf012b630
f011718c:	e8 fa 9d fe ff       	call   f0100f8b <cprintf>
f0117191:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117194:	e8 23 78 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117199:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011719c:	e8 04 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01171a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f01171a4:	83 ec 0c             	sub    $0xc,%esp
f01171a7:	68 00 fc 2f 00       	push   $0x2ffc00
f01171ac:	e8 ee 23 ff ff       	call   f010959f <kmalloc>
f01171b1:	83 c4 10             	add    $0x10,%esp
f01171b4:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01171ba:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f01171c0:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01171c5:	74 17                	je     f01171de <test_kmalloc+0x49a>
f01171c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171ce:	83 ec 0c             	sub    $0xc,%esp
f01171d1:	68 74 b6 12 f0       	push   $0xf012b674
f01171d6:	e8 b0 9d fe ff       	call   f0100f8b <cprintf>
f01171db:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01171de:	e8 c2 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01171e3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01171e6:	74 17                	je     f01171ff <test_kmalloc+0x4bb>
f01171e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171ef:	83 ec 0c             	sub    $0xc,%esp
f01171f2:	68 c8 b6 12 f0       	push   $0xf012b6c8
f01171f7:	e8 8f 9d fe ff       	call   f0100f8b <cprintf>
f01171fc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01171ff:	e8 b8 77 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117204:	89 c2                	mov    %eax,%edx
f0117206:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117209:	29 d0                	sub    %edx,%eax
f011720b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117210:	7f 17                	jg     f0117229 <test_kmalloc+0x4e5>
f0117212:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117219:	83 ec 0c             	sub    $0xc,%esp
f011721c:	68 34 b7 12 f0       	push   $0xf012b734
f0117221:	e8 65 9d fe ff       	call   f0100f8b <cprintf>
f0117226:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117229:	e8 8e 77 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011722e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117231:	e8 6f d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117236:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0117239:	83 ec 0c             	sub    $0xc,%esp
f011723c:	68 00 fc 5f 00       	push   $0x5ffc00
f0117241:	e8 59 23 ff ff       	call   f010959f <kmalloc>
f0117246:	83 c4 10             	add    $0x10,%esp
f0117249:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011724f:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117255:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011725a:	74 17                	je     f0117273 <test_kmalloc+0x52f>
f011725c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117263:	83 ec 0c             	sub    $0xc,%esp
f0117266:	68 78 b7 12 f0       	push   $0xf012b778
f011726b:	e8 1b 9d fe ff       	call   f0100f8b <cprintf>
f0117270:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117273:	e8 2d d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117278:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011727b:	74 17                	je     f0117294 <test_kmalloc+0x550>
f011727d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117284:	83 ec 0c             	sub    $0xc,%esp
f0117287:	68 cc b7 12 f0       	push   $0xf012b7cc
f011728c:	e8 fa 9c fe ff       	call   f0100f8b <cprintf>
f0117291:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117294:	e8 23 77 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117299:	89 c2                	mov    %eax,%edx
f011729b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011729e:	29 d0                	sub    %edx,%eax
f01172a0:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f01172a5:	7f 17                	jg     f01172be <test_kmalloc+0x57a>
f01172a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172ae:	83 ec 0c             	sub    $0xc,%esp
f01172b1:	68 38 b8 12 f0       	push   $0xf012b838
f01172b6:	e8 d0 9c fe ff       	call   f0100f8b <cprintf>
f01172bb:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01172be:	e8 f9 76 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01172c3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172c6:	e8 da d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01172cb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f01172ce:	83 ec 0c             	sub    $0xc,%esp
f01172d1:	68 00 38 00 00       	push   $0x3800
f01172d6:	e8 c4 22 ff ff       	call   f010959f <kmalloc>
f01172db:	83 c4 10             	add    $0x10,%esp
f01172de:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01172e4:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01172ea:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f01172ef:	74 17                	je     f0117308 <test_kmalloc+0x5c4>
f01172f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172f8:	83 ec 0c             	sub    $0xc,%esp
f01172fb:	68 7c b8 12 f0       	push   $0xf012b87c
f0117300:	e8 86 9c fe ff       	call   f0100f8b <cprintf>
f0117305:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117308:	e8 98 d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011730d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117310:	74 17                	je     f0117329 <test_kmalloc+0x5e5>
f0117312:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117319:	83 ec 0c             	sub    $0xc,%esp
f011731c:	68 d0 b8 12 f0       	push   $0xf012b8d0
f0117321:	e8 65 9c fe ff       	call   f0100f8b <cprintf>
f0117326:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117329:	e8 8e 76 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011732e:	89 c2                	mov    %eax,%edx
f0117330:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117333:	29 d0                	sub    %edx,%eax
f0117335:	83 f8 03             	cmp    $0x3,%eax
f0117338:	7f 17                	jg     f0117351 <test_kmalloc+0x60d>
f011733a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117341:	83 ec 0c             	sub    $0xc,%esp
f0117344:	68 3c b9 12 f0       	push   $0xf012b93c
f0117349:	e8 3d 9c fe ff       	call   f0100f8b <cprintf>
f011734e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117351:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117355:	74 04                	je     f011735b <test_kmalloc+0x617>
f0117357:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f011735b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0117362:	83 ec 0c             	sub    $0xc,%esp
f0117365:	68 80 b9 12 f0       	push   $0xf012b980
f011736a:	e8 1c 9c fe ff       	call   f0100f8b <cprintf>
f011736f:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0117372:	e8 45 76 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117377:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011737a:	e8 26 d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011737f:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0117382:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0117389:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011738f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0117392:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117395:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117398:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f011739a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011739d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01173a0:	01 c2                	add    %eax,%edx
f01173a2:	8a 45 ea             	mov    -0x16(%ebp),%al
f01173a5:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f01173a7:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f01173ad:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f01173b0:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f01173b7:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01173ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01173bd:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f01173c0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01173c3:	01 c0                	add    %eax,%eax
f01173c5:	89 c2                	mov    %eax,%edx
f01173c7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01173ca:	01 c2                	add    %eax,%edx
f01173cc:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01173d0:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f01173d3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01173d9:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f01173dc:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f01173e3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01173e6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01173e9:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f01173eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01173ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01173f5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01173f8:	01 c2                	add    %eax,%edx
f01173fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01173fd:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f01173ff:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117405:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0117408:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f011740f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117412:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117415:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0117417:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011741a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011741d:	01 c2                	add    %eax,%edx
f011741f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117422:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0117424:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011742a:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f011742d:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0117434:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117437:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011743a:	88 10                	mov    %dl,(%eax)
f011743c:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011743f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117442:	66 89 42 02          	mov    %ax,0x2(%edx)
f0117446:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117449:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011744c:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f011744f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117452:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117459:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011745c:	01 c2                	add    %eax,%edx
f011745e:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117461:	88 02                	mov    %al,(%edx)
f0117463:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117466:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011746d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117470:	01 c2                	add    %eax,%edx
f0117472:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117476:	66 89 42 02          	mov    %ax,0x2(%edx)
f011747a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011747d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117484:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117487:	01 c2                	add    %eax,%edx
f0117489:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011748c:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f011748f:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0117496:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011749c:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f011749f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01174a2:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01174a5:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f01174a7:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01174aa:	89 c2                	mov    %eax,%edx
f01174ac:	c1 ea 1f             	shr    $0x1f,%edx
f01174af:	01 d0                	add    %edx,%eax
f01174b1:	d1 f8                	sar    %eax
f01174b3:	89 c2                	mov    %eax,%edx
f01174b5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01174b8:	01 c2                	add    %eax,%edx
f01174ba:	8a 45 ea             	mov    -0x16(%ebp),%al
f01174bd:	88 c1                	mov    %al,%cl
f01174bf:	c0 e9 07             	shr    $0x7,%cl
f01174c2:	01 c8                	add    %ecx,%eax
f01174c4:	d0 f8                	sar    %al
f01174c6:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f01174c8:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01174cb:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01174ce:	01 c2                	add    %eax,%edx
f01174d0:	8a 45 ea             	mov    -0x16(%ebp),%al
f01174d3:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f01174d5:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01174db:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f01174de:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f01174e5:	8b 55 98             	mov    -0x68(%ebp),%edx
f01174e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01174eb:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f01174ee:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01174f1:	01 c0                	add    %eax,%eax
f01174f3:	89 c2                	mov    %eax,%edx
f01174f5:	8b 45 98             	mov    -0x68(%ebp),%eax
f01174f8:	01 c2                	add    %eax,%edx
f01174fa:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01174fe:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0117501:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117504:	8a 00                	mov    (%eax),%al
f0117506:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117509:	75 0f                	jne    f011751a <test_kmalloc+0x7d6>
f011750b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011750e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117511:	01 d0                	add    %edx,%eax
f0117513:	8a 00                	mov    (%eax),%al
f0117515:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117518:	74 17                	je     f0117531 <test_kmalloc+0x7ed>
f011751a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117521:	83 ec 0c             	sub    $0xc,%esp
f0117524:	68 b8 b9 12 f0       	push   $0xf012b9b8
f0117529:	e8 5d 9a fe ff       	call   f0100f8b <cprintf>
f011752e:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0117531:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117534:	66 8b 00             	mov    (%eax),%ax
f0117537:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f011753b:	75 15                	jne    f0117552 <test_kmalloc+0x80e>
f011753d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117540:	01 c0                	add    %eax,%eax
f0117542:	89 c2                	mov    %eax,%edx
f0117544:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117547:	01 d0                	add    %edx,%eax
f0117549:	66 8b 00             	mov    (%eax),%ax
f011754c:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0117550:	74 17                	je     f0117569 <test_kmalloc+0x825>
f0117552:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117559:	83 ec 0c             	sub    $0xc,%esp
f011755c:	68 f0 b9 12 f0       	push   $0xf012b9f0
f0117561:	e8 25 9a fe ff       	call   f0100f8b <cprintf>
f0117566:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f0117569:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011756c:	8b 00                	mov    (%eax),%eax
f011756e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0117571:	75 16                	jne    f0117589 <test_kmalloc+0x845>
f0117573:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117576:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011757d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117580:	01 d0                	add    %edx,%eax
f0117582:	8b 00                	mov    (%eax),%eax
f0117584:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117587:	74 17                	je     f01175a0 <test_kmalloc+0x85c>
f0117589:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117590:	83 ec 0c             	sub    $0xc,%esp
f0117593:	68 2c ba 12 f0       	push   $0xf012ba2c
f0117598:	e8 ee 99 fe ff       	call   f0100f8b <cprintf>
f011759d:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f01175a0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01175a3:	8a 00                	mov    (%eax),%al
f01175a5:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01175a8:	75 0f                	jne    f01175b9 <test_kmalloc+0x875>
f01175aa:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01175ad:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01175b0:	01 d0                	add    %edx,%eax
f01175b2:	8a 00                	mov    (%eax),%al
f01175b4:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01175b7:	74 17                	je     f01175d0 <test_kmalloc+0x88c>
f01175b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175c0:	83 ec 0c             	sub    $0xc,%esp
f01175c3:	68 68 ba 12 f0       	push   $0xf012ba68
f01175c8:	e8 be 99 fe ff       	call   f0100f8b <cprintf>
f01175cd:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f01175d0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175d3:	8a 00                	mov    (%eax),%al
f01175d5:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01175d8:	75 16                	jne    f01175f0 <test_kmalloc+0x8ac>
f01175da:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01175dd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01175e4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01175e7:	01 d0                	add    %edx,%eax
f01175e9:	8a 00                	mov    (%eax),%al
f01175eb:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01175ee:	74 17                	je     f0117607 <test_kmalloc+0x8c3>
f01175f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175f7:	83 ec 0c             	sub    $0xc,%esp
f01175fa:	68 a4 ba 12 f0       	push   $0xf012baa4
f01175ff:	e8 87 99 fe ff       	call   f0100f8b <cprintf>
f0117604:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f0117607:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011760a:	66 8b 40 02          	mov    0x2(%eax),%ax
f011760e:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0117612:	75 19                	jne    f011762d <test_kmalloc+0x8e9>
f0117614:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117617:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011761e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117621:	01 d0                	add    %edx,%eax
f0117623:	66 8b 40 02          	mov    0x2(%eax),%ax
f0117627:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011762b:	74 17                	je     f0117644 <test_kmalloc+0x900>
f011762d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117634:	83 ec 0c             	sub    $0xc,%esp
f0117637:	68 e0 ba 12 f0       	push   $0xf012bae0
f011763c:	e8 4a 99 fe ff       	call   f0100f8b <cprintf>
f0117641:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f0117644:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117647:	8b 40 04             	mov    0x4(%eax),%eax
f011764a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011764d:	75 17                	jne    f0117666 <test_kmalloc+0x922>
f011764f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117652:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117659:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011765c:	01 d0                	add    %edx,%eax
f011765e:	8b 40 04             	mov    0x4(%eax),%eax
f0117661:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117664:	74 17                	je     f011767d <test_kmalloc+0x939>
f0117666:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011766d:	83 ec 0c             	sub    $0xc,%esp
f0117670:	68 1c bb 12 f0       	push   $0xf012bb1c
f0117675:	e8 11 99 fe ff       	call   f0100f8b <cprintf>
f011767a:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011767d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117680:	8a 00                	mov    (%eax),%al
f0117682:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117685:	75 34                	jne    f01176bb <test_kmalloc+0x977>
f0117687:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011768a:	89 c2                	mov    %eax,%edx
f011768c:	c1 ea 1f             	shr    $0x1f,%edx
f011768f:	01 d0                	add    %edx,%eax
f0117691:	d1 f8                	sar    %eax
f0117693:	89 c2                	mov    %eax,%edx
f0117695:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117698:	01 d0                	add    %edx,%eax
f011769a:	8a 10                	mov    (%eax),%dl
f011769c:	8a 45 ea             	mov    -0x16(%ebp),%al
f011769f:	88 c1                	mov    %al,%cl
f01176a1:	c0 e9 07             	shr    $0x7,%cl
f01176a4:	01 c8                	add    %ecx,%eax
f01176a6:	d0 f8                	sar    %al
f01176a8:	38 c2                	cmp    %al,%dl
f01176aa:	75 0f                	jne    f01176bb <test_kmalloc+0x977>
f01176ac:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01176af:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01176b2:	01 d0                	add    %edx,%eax
f01176b4:	8a 00                	mov    (%eax),%al
f01176b6:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01176b9:	74 17                	je     f01176d2 <test_kmalloc+0x98e>
f01176bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176c2:	83 ec 0c             	sub    $0xc,%esp
f01176c5:	68 58 bb 12 f0       	push   $0xf012bb58
f01176ca:	e8 bc 98 fe ff       	call   f0100f8b <cprintf>
f01176cf:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f01176d2:	8b 45 98             	mov    -0x68(%ebp),%eax
f01176d5:	66 8b 00             	mov    (%eax),%ax
f01176d8:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01176dc:	75 15                	jne    f01176f3 <test_kmalloc+0x9af>
f01176de:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01176e1:	01 c0                	add    %eax,%eax
f01176e3:	89 c2                	mov    %eax,%edx
f01176e5:	8b 45 98             	mov    -0x68(%ebp),%eax
f01176e8:	01 d0                	add    %edx,%eax
f01176ea:	66 8b 00             	mov    (%eax),%ax
f01176ed:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01176f1:	74 17                	je     f011770a <test_kmalloc+0x9c6>
f01176f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176fa:	83 ec 0c             	sub    $0xc,%esp
f01176fd:	68 90 bb 12 f0       	push   $0xf012bb90
f0117702:	e8 84 98 fe ff       	call   f0100f8b <cprintf>
f0117707:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011770a:	e8 ad 72 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011770f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117712:	74 17                	je     f011772b <test_kmalloc+0x9e7>
f0117714:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011771b:	83 ec 0c             	sub    $0xc,%esp
f011771e:	68 cc bb 12 f0       	push   $0xf012bbcc
f0117723:	e8 63 98 fe ff       	call   f0100f8b <cprintf>
f0117728:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011772b:	e8 75 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117730:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117733:	74 17                	je     f011774c <test_kmalloc+0xa08>
f0117735:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011773c:	83 ec 0c             	sub    $0xc,%esp
f011773f:	68 10 bc 12 f0       	push   $0xf012bc10
f0117744:	e8 42 98 fe ff       	call   f0100f8b <cprintf>
f0117749:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f011774c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117750:	74 04                	je     f0117756 <test_kmalloc+0xa12>
f0117752:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0117756:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f011775d:	83 ec 0c             	sub    $0xc,%esp
f0117760:	68 7c bc 12 f0       	push   $0xf012bc7c
f0117765:	e8 21 98 fe ff       	call   f0100f8b <cprintf>
f011776a:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011776d:	e8 4a 72 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117772:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117775:	e8 2b d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011777a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f011777d:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0117784:	8b 45 90             	mov    -0x70(%ebp),%eax
f0117787:	40                   	inc    %eax
f0117788:	83 ec 0c             	sub    $0xc,%esp
f011778b:	50                   	push   %eax
f011778c:	e8 0e 1e ff ff       	call   f010959f <kmalloc>
f0117791:	83 c4 10             	add    $0x10,%esp
f0117794:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f011779a:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f01177a0:	85 c0                	test   %eax,%eax
f01177a2:	74 17                	je     f01177bb <test_kmalloc+0xa77>
f01177a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177ab:	83 ec 0c             	sub    $0xc,%esp
f01177ae:	68 a0 bc 12 f0       	push   $0xf012bca0
f01177b3:	e8 d3 97 fe ff       	call   f0100f8b <cprintf>
f01177b8:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01177bb:	e8 e5 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01177c0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01177c3:	74 17                	je     f01177dc <test_kmalloc+0xa98>
f01177c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177cc:	83 ec 0c             	sub    $0xc,%esp
f01177cf:	68 d8 bc 12 f0       	push   $0xf012bcd8
f01177d4:	e8 b2 97 fe ff       	call   f0100f8b <cprintf>
f01177d9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01177dc:	e8 db 71 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01177e1:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01177e4:	74 17                	je     f01177fd <test_kmalloc+0xab9>
f01177e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177ed:	83 ec 0c             	sub    $0xc,%esp
f01177f0:	68 44 bd 12 f0       	push   $0xf012bd44
f01177f5:	e8 91 97 fe ff       	call   f0100f8b <cprintf>
f01177fa:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01177fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117801:	74 04                	je     f0117807 <test_kmalloc+0xac3>
f0117803:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117807:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f011780e:	83 ec 0c             	sub    $0xc,%esp
f0117811:	68 88 bd 12 f0       	push   $0xf012bd88
f0117816:	e8 70 97 fe ff       	call   f0100f8b <cprintf>
f011781b:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f011781e:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117824:	05 00 40 00 00       	add    $0x4000,%eax
f0117829:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011782c:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117833:	eb 6a                	jmp    f011789f <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117835:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011783a:	83 ec 04             	sub    $0x4,%esp
f011783d:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117843:	52                   	push   %edx
f0117844:	ff 75 ec             	pushl  -0x14(%ebp)
f0117847:	50                   	push   %eax
f0117848:	e8 a2 0b ff ff       	call   f01083ef <get_page_table>
f011784d:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0117850:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117856:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0117859:	c1 ea 0c             	shr    $0xc,%edx
f011785c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117862:	c1 e2 02             	shl    $0x2,%edx
f0117865:	01 d0                	add    %edx,%eax
f0117867:	8b 00                	mov    (%eax),%eax
f0117869:	25 ff 0f 00 00       	and    $0xfff,%eax
f011786e:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0117871:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117874:	83 e0 04             	and    $0x4,%eax
f0117877:	85 c0                	test   %eax,%eax
f0117879:	74 1d                	je     f0117898 <test_kmalloc+0xb54>
			{
				if (correct)
f011787b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011787f:	74 17                	je     f0117898 <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0117881:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117888:	83 ec 0c             	sub    $0xc,%esp
f011788b:	68 cc bd 12 f0       	push   $0xf012bdcc
f0117890:	e8 f6 96 fe ff       	call   f0100f8b <cprintf>
f0117895:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117898:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f011789f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01178a2:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01178a5:	72 8e                	jb     f0117835 <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f01178a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01178ab:	74 04                	je     f01178b1 <test_kmalloc+0xb6d>
f01178ad:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f01178b1:	83 ec 08             	sub    $0x8,%esp
f01178b4:	ff 75 f4             	pushl  -0xc(%ebp)
f01178b7:	68 1c be 12 f0       	push   $0xf012be1c
f01178bc:	e8 ca 96 fe ff       	call   f0100f8b <cprintf>
f01178c1:	83 c4 10             	add    $0x10,%esp

	return 1;
f01178c4:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01178c9:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01178cc:	5b                   	pop    %ebx
f01178cd:	5f                   	pop    %edi
f01178ce:	5d                   	pop    %ebp
f01178cf:	c3                   	ret    

f01178d0 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f01178d0:	55                   	push   %ebp
f01178d1:	89 e5                	mov    %esp,%ebp
f01178d3:	57                   	push   %edi
f01178d4:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01178d7:	83 ec 0c             	sub    $0xc,%esp
f01178da:	68 88 af 12 f0       	push   $0xf012af88
f01178df:	e8 a7 96 fe ff       	call   f0100f8b <cprintf>
f01178e4:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01178e7:	83 ec 0c             	sub    $0xc,%esp
f01178ea:	68 b8 af 12 f0       	push   $0xf012afb8
f01178ef:	e8 97 96 fe ff       	call   f0100f8b <cprintf>
f01178f4:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01178f7:	83 ec 0c             	sub    $0xc,%esp
f01178fa:	68 88 af 12 f0       	push   $0xf012af88
f01178ff:	e8 87 96 fe ff       	call   f0100f8b <cprintf>
f0117904:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117907:	8d 55 98             	lea    -0x68(%ebp),%edx
f011790a:	b9 14 00 00 00       	mov    $0x14,%ecx
f011790f:	b8 00 00 00 00       	mov    $0x0,%eax
f0117914:	89 d7                	mov    %edx,%edi
f0117916:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117918:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011791f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117926:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f011792d:	83 ec 0c             	sub    $0xc,%esp
f0117930:	68 48 be 12 f0       	push   $0xf012be48
f0117935:	e8 51 96 fe ff       	call   f0100f8b <cprintf>
f011793a:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011793d:	e8 7a 70 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117942:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117945:	e8 5b cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011794a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f011794d:	83 ec 0c             	sub    $0xc,%esp
f0117950:	68 00 fc 0f 00       	push   $0xffc00
f0117955:	e8 45 1c ff ff       	call   f010959f <kmalloc>
f011795a:	83 c4 10             	add    $0x10,%esp
f011795d:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0117960:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117963:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117968:	74 17                	je     f0117981 <test_kmalloc_firstfit1+0xb1>
f011796a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117971:	83 ec 0c             	sub    $0xc,%esp
f0117974:	68 88 be 12 f0       	push   $0xf012be88
f0117979:	e8 0d 96 fe ff       	call   f0100f8b <cprintf>
f011797e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117981:	e8 1f cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117986:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117989:	74 17                	je     f01179a2 <test_kmalloc_firstfit1+0xd2>
f011798b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117992:	83 ec 0c             	sub    $0xc,%esp
f0117995:	68 ac b1 12 f0       	push   $0xf012b1ac
f011799a:	e8 ec 95 fe ff       	call   f0100f8b <cprintf>
f011799f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f01179a2:	e8 15 70 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01179a7:	89 c2                	mov    %eax,%edx
f01179a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01179ac:	29 d0                	sub    %edx,%eax
f01179ae:	3d ff 00 00 00       	cmp    $0xff,%eax
f01179b3:	7f 17                	jg     f01179cc <test_kmalloc_firstfit1+0xfc>
f01179b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179bc:	83 ec 0c             	sub    $0xc,%esp
f01179bf:	68 bb be 12 f0       	push   $0xf012bebb
f01179c4:	e8 c2 95 fe ff       	call   f0100f8b <cprintf>
f01179c9:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01179cc:	e8 eb 6f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01179d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01179d4:	e8 cc ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f01179dc:	83 ec 0c             	sub    $0xc,%esp
f01179df:	68 00 fc 0f 00       	push   $0xffc00
f01179e4:	e8 b6 1b ff ff       	call   f010959f <kmalloc>
f01179e9:	83 c4 10             	add    $0x10,%esp
f01179ec:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f01179ef:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01179f2:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01179f7:	74 17                	je     f0117a10 <test_kmalloc_firstfit1+0x140>
f01179f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a00:	83 ec 0c             	sub    $0xc,%esp
f0117a03:	68 d4 be 12 f0       	push   $0xf012bed4
f0117a08:	e8 7e 95 fe ff       	call   f0100f8b <cprintf>
f0117a0d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a10:	e8 90 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a15:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a18:	74 17                	je     f0117a31 <test_kmalloc_firstfit1+0x161>
f0117a1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a21:	83 ec 0c             	sub    $0xc,%esp
f0117a24:	68 b0 b2 12 f0       	push   $0xf012b2b0
f0117a29:	e8 5d 95 fe ff       	call   f0100f8b <cprintf>
f0117a2e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117a31:	e8 86 6f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117a36:	89 c2                	mov    %eax,%edx
f0117a38:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a3b:	29 d0                	sub    %edx,%eax
f0117a3d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117a42:	7f 17                	jg     f0117a5b <test_kmalloc_firstfit1+0x18b>
f0117a44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a4b:	83 ec 0c             	sub    $0xc,%esp
f0117a4e:	68 07 bf 12 f0       	push   $0xf012bf07
f0117a53:	e8 33 95 fe ff       	call   f0100f8b <cprintf>
f0117a58:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a5b:	e8 5c 6f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117a60:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a63:	e8 3d ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a68:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0117a6b:	83 ec 0c             	sub    $0xc,%esp
f0117a6e:	68 00 fc 0f 00       	push   $0xffc00
f0117a73:	e8 27 1b ff ff       	call   f010959f <kmalloc>
f0117a78:	83 c4 10             	add    $0x10,%esp
f0117a7b:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117a7e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117a81:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117a86:	74 17                	je     f0117a9f <test_kmalloc_firstfit1+0x1cf>
f0117a88:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a8f:	83 ec 0c             	sub    $0xc,%esp
f0117a92:	68 20 bf 12 f0       	push   $0xf012bf20
f0117a97:	e8 ef 94 fe ff       	call   f0100f8b <cprintf>
f0117a9c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a9f:	e8 01 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117aa4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117aa7:	74 17                	je     f0117ac0 <test_kmalloc_firstfit1+0x1f0>
f0117aa9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ab0:	83 ec 0c             	sub    $0xc,%esp
f0117ab3:	68 ec b3 12 f0       	push   $0xf012b3ec
f0117ab8:	e8 ce 94 fe ff       	call   f0100f8b <cprintf>
f0117abd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117ac0:	e8 f7 6e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117ac5:	89 c2                	mov    %eax,%edx
f0117ac7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117aca:	29 d0                	sub    %edx,%eax
f0117acc:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117ad1:	7f 17                	jg     f0117aea <test_kmalloc_firstfit1+0x21a>
f0117ad3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ada:	83 ec 0c             	sub    $0xc,%esp
f0117add:	68 53 bf 12 f0       	push   $0xf012bf53
f0117ae2:	e8 a4 94 fe ff       	call   f0100f8b <cprintf>
f0117ae7:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117aea:	e8 cd 6e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117aef:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117af2:	e8 ae cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117af7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0117afa:	83 ec 0c             	sub    $0xc,%esp
f0117afd:	68 00 fc 0f 00       	push   $0xffc00
f0117b02:	e8 98 1a ff ff       	call   f010959f <kmalloc>
f0117b07:	83 c4 10             	add    $0x10,%esp
f0117b0a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117b0d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117b10:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117b15:	74 17                	je     f0117b2e <test_kmalloc_firstfit1+0x25e>
f0117b17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b1e:	83 ec 0c             	sub    $0xc,%esp
f0117b21:	68 6c bf 12 f0       	push   $0xf012bf6c
f0117b26:	e8 60 94 fe ff       	call   f0100f8b <cprintf>
f0117b2b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b2e:	e8 72 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b33:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b36:	74 17                	je     f0117b4f <test_kmalloc_firstfit1+0x27f>
f0117b38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b3f:	83 ec 0c             	sub    $0xc,%esp
f0117b42:	68 e4 b4 12 f0       	push   $0xf012b4e4
f0117b47:	e8 3f 94 fe ff       	call   f0100f8b <cprintf>
f0117b4c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117b4f:	e8 68 6e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117b54:	89 c2                	mov    %eax,%edx
f0117b56:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117b59:	29 d0                	sub    %edx,%eax
f0117b5b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117b60:	7f 17                	jg     f0117b79 <test_kmalloc_firstfit1+0x2a9>
f0117b62:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b69:	83 ec 0c             	sub    $0xc,%esp
f0117b6c:	68 9f bf 12 f0       	push   $0xf012bf9f
f0117b71:	e8 15 94 fe ff       	call   f0100f8b <cprintf>
f0117b76:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b79:	e8 3e 6e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117b7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b81:	e8 1f cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b86:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117b89:	83 ec 0c             	sub    $0xc,%esp
f0117b8c:	68 00 fc 1f 00       	push   $0x1ffc00
f0117b91:	e8 09 1a ff ff       	call   f010959f <kmalloc>
f0117b96:	83 c4 10             	add    $0x10,%esp
f0117b99:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0117b9c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117b9f:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117ba4:	74 17                	je     f0117bbd <test_kmalloc_firstfit1+0x2ed>
f0117ba6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bad:	83 ec 0c             	sub    $0xc,%esp
f0117bb0:	68 b8 bf 12 f0       	push   $0xf012bfb8
f0117bb5:	e8 d1 93 fe ff       	call   f0100f8b <cprintf>
f0117bba:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117bbd:	e8 e3 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bc2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117bc5:	74 17                	je     f0117bde <test_kmalloc_firstfit1+0x30e>
f0117bc7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bce:	83 ec 0c             	sub    $0xc,%esp
f0117bd1:	68 c4 b5 12 f0       	push   $0xf012b5c4
f0117bd6:	e8 b0 93 fe ff       	call   f0100f8b <cprintf>
f0117bdb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0117bde:	e8 d9 6d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117be3:	89 c2                	mov    %eax,%edx
f0117be5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117be8:	29 d0                	sub    %edx,%eax
f0117bea:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117bef:	7f 17                	jg     f0117c08 <test_kmalloc_firstfit1+0x338>
f0117bf1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bf8:	83 ec 0c             	sub    $0xc,%esp
f0117bfb:	68 eb bf 12 f0       	push   $0xf012bfeb
f0117c00:	e8 86 93 fe ff       	call   f0100f8b <cprintf>
f0117c05:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c08:	e8 af 6d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117c0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c10:	e8 90 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c15:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117c18:	83 ec 0c             	sub    $0xc,%esp
f0117c1b:	68 00 fc 1f 00       	push   $0x1ffc00
f0117c20:	e8 7a 19 ff ff       	call   f010959f <kmalloc>
f0117c25:	83 c4 10             	add    $0x10,%esp
f0117c28:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117c2b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117c2e:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117c33:	74 17                	je     f0117c4c <test_kmalloc_firstfit1+0x37c>
f0117c35:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c3c:	83 ec 0c             	sub    $0xc,%esp
f0117c3f:	68 04 c0 12 f0       	push   $0xf012c004
f0117c44:	e8 42 93 fe ff       	call   f0100f8b <cprintf>
f0117c49:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c4c:	e8 54 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c51:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c54:	74 17                	je     f0117c6d <test_kmalloc_firstfit1+0x39d>
f0117c56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c5d:	83 ec 0c             	sub    $0xc,%esp
f0117c60:	68 c8 b6 12 f0       	push   $0xf012b6c8
f0117c65:	e8 21 93 fe ff       	call   f0100f8b <cprintf>
f0117c6a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117c6d:	e8 4a 6d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117c72:	89 c2                	mov    %eax,%edx
f0117c74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c77:	29 d0                	sub    %edx,%eax
f0117c79:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117c7e:	7f 17                	jg     f0117c97 <test_kmalloc_firstfit1+0x3c7>
f0117c80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c87:	83 ec 0c             	sub    $0xc,%esp
f0117c8a:	68 37 c0 12 f0       	push   $0xf012c037
f0117c8f:	e8 f7 92 fe ff       	call   f0100f8b <cprintf>
f0117c94:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c97:	e8 20 6d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117c9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c9f:	e8 01 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ca4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117ca7:	83 ec 0c             	sub    $0xc,%esp
f0117caa:	68 00 fc 2f 00       	push   $0x2ffc00
f0117caf:	e8 eb 18 ff ff       	call   f010959f <kmalloc>
f0117cb4:	83 c4 10             	add    $0x10,%esp
f0117cb7:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0117cba:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117cbd:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0117cc2:	74 17                	je     f0117cdb <test_kmalloc_firstfit1+0x40b>
f0117cc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ccb:	83 ec 0c             	sub    $0xc,%esp
f0117cce:	68 50 c0 12 f0       	push   $0xf012c050
f0117cd3:	e8 b3 92 fe ff       	call   f0100f8b <cprintf>
f0117cd8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117cdb:	e8 c5 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ce0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ce3:	74 17                	je     f0117cfc <test_kmalloc_firstfit1+0x42c>
f0117ce5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cec:	83 ec 0c             	sub    $0xc,%esp
f0117cef:	68 cc b7 12 f0       	push   $0xf012b7cc
f0117cf4:	e8 92 92 fe ff       	call   f0100f8b <cprintf>
f0117cf9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117cfc:	e8 bb 6c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117d01:	89 c2                	mov    %eax,%edx
f0117d03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117d06:	29 d0                	sub    %edx,%eax
f0117d08:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117d0d:	7f 17                	jg     f0117d26 <test_kmalloc_firstfit1+0x456>
f0117d0f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d16:	83 ec 0c             	sub    $0xc,%esp
f0117d19:	68 83 c0 12 f0       	push   $0xf012c083
f0117d1e:	e8 68 92 fe ff       	call   f0100f8b <cprintf>
f0117d23:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d26:	e8 91 6c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117d2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d2e:	e8 72 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d33:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117d36:	83 ec 0c             	sub    $0xc,%esp
f0117d39:	68 00 fc 2f 00       	push   $0x2ffc00
f0117d3e:	e8 5c 18 ff ff       	call   f010959f <kmalloc>
f0117d43:	83 c4 10             	add    $0x10,%esp
f0117d46:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117d49:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117d4c:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0117d51:	74 17                	je     f0117d6a <test_kmalloc_firstfit1+0x49a>
f0117d53:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d5a:	83 ec 0c             	sub    $0xc,%esp
f0117d5d:	68 9c c0 12 f0       	push   $0xf012c09c
f0117d62:	e8 24 92 fe ff       	call   f0100f8b <cprintf>
f0117d67:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d6a:	e8 36 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d6f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117d72:	74 17                	je     f0117d8b <test_kmalloc_firstfit1+0x4bb>
f0117d74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d7b:	83 ec 0c             	sub    $0xc,%esp
f0117d7e:	68 d0 b8 12 f0       	push   $0xf012b8d0
f0117d83:	e8 03 92 fe ff       	call   f0100f8b <cprintf>
f0117d88:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0117d8b:	e8 2c 6c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117d90:	89 c2                	mov    %eax,%edx
f0117d92:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117d95:	29 d0                	sub    %edx,%eax
f0117d97:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117d9c:	7f 17                	jg     f0117db5 <test_kmalloc_firstfit1+0x4e5>
f0117d9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117da5:	83 ec 0c             	sub    $0xc,%esp
f0117da8:	68 cf c0 12 f0       	push   $0xf012c0cf
f0117dad:	e8 d9 91 fe ff       	call   f0100f8b <cprintf>
f0117db2:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117db5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117db9:	74 04                	je     f0117dbf <test_kmalloc_firstfit1+0x4ef>
f0117dbb:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117dbf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0117dc6:	83 ec 0c             	sub    $0xc,%esp
f0117dc9:	68 e8 c0 12 f0       	push   $0xf012c0e8
f0117dce:	e8 b8 91 fe ff       	call   f0100f8b <cprintf>
f0117dd3:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117dd6:	e8 e1 6b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117ddb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117dde:	e8 c2 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117de3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0117de6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117de9:	83 ec 0c             	sub    $0xc,%esp
f0117dec:	50                   	push   %eax
f0117ded:	e8 0d 1a ff ff       	call   f01097ff <kfree>
f0117df2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117df5:	e8 ab ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117dfa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117dfd:	74 17                	je     f0117e16 <test_kmalloc_firstfit1+0x546>
f0117dff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e06:	83 ec 0c             	sub    $0xc,%esp
f0117e09:	68 10 c1 12 f0       	push   $0xf012c110
f0117e0e:	e8 78 91 fe ff       	call   f0100f8b <cprintf>
f0117e13:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117e16:	e8 a1 6b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117e1b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117e1e:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117e23:	7f 17                	jg     f0117e3c <test_kmalloc_firstfit1+0x56c>
f0117e25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e2c:	83 ec 0c             	sub    $0xc,%esp
f0117e2f:	68 7b c1 12 f0       	push   $0xf012c17b
f0117e34:	e8 52 91 fe ff       	call   f0100f8b <cprintf>
f0117e39:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e3c:	e8 7b 6b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117e41:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e44:	e8 5c ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e49:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0117e4c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117e4f:	83 ec 0c             	sub    $0xc,%esp
f0117e52:	50                   	push   %eax
f0117e53:	e8 a7 19 ff ff       	call   f01097ff <kfree>
f0117e58:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e5b:	e8 45 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e60:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e63:	74 17                	je     f0117e7c <test_kmalloc_firstfit1+0x5ac>
f0117e65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e6c:	83 ec 0c             	sub    $0xc,%esp
f0117e6f:	68 8c c1 12 f0       	push   $0xf012c18c
f0117e74:	e8 12 91 fe ff       	call   f0100f8b <cprintf>
f0117e79:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0117e7c:	e8 3b 6b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117e81:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117e84:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117e89:	7f 17                	jg     f0117ea2 <test_kmalloc_firstfit1+0x5d2>
f0117e8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e92:	83 ec 0c             	sub    $0xc,%esp
f0117e95:	68 f8 c1 12 f0       	push   $0xf012c1f8
f0117e9a:	e8 ec 90 fe ff       	call   f0100f8b <cprintf>
f0117e9f:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117ea2:	e8 15 6b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117ea7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117eaa:	e8 f6 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117eaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0117eb2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117eb5:	83 ec 0c             	sub    $0xc,%esp
f0117eb8:	50                   	push   %eax
f0117eb9:	e8 41 19 ff ff       	call   f01097ff <kfree>
f0117ebe:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ec1:	e8 df c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ec6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ec9:	74 17                	je     f0117ee2 <test_kmalloc_firstfit1+0x612>
f0117ecb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ed2:	83 ec 0c             	sub    $0xc,%esp
f0117ed5:	68 0c c2 12 f0       	push   $0xf012c20c
f0117eda:	e8 ac 90 fe ff       	call   f0100f8b <cprintf>
f0117edf:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0117ee2:	e8 d5 6a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117ee7:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117eea:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117eef:	7f 17                	jg     f0117f08 <test_kmalloc_firstfit1+0x638>
f0117ef1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ef8:	83 ec 0c             	sub    $0xc,%esp
f0117efb:	68 78 c2 12 f0       	push   $0xf012c278
f0117f00:	e8 86 90 fe ff       	call   f0100f8b <cprintf>
f0117f05:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117f08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117f0c:	74 04                	je     f0117f12 <test_kmalloc_firstfit1+0x642>
f0117f0e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117f12:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0117f19:	83 ec 0c             	sub    $0xc,%esp
f0117f1c:	68 8c c2 12 f0       	push   $0xf012c28c
f0117f21:	e8 65 90 fe ff       	call   f0100f8b <cprintf>
f0117f26:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f29:	e8 8e 6a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117f2e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f31:	e8 6f c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f36:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0117f39:	83 ec 0c             	sub    $0xc,%esp
f0117f3c:	68 00 fc 07 00       	push   $0x7fc00
f0117f41:	e8 59 16 ff ff       	call   f010959f <kmalloc>
f0117f46:	83 c4 10             	add    $0x10,%esp
f0117f49:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0117f4c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117f4f:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117f54:	74 17                	je     f0117f6d <test_kmalloc_firstfit1+0x69d>
f0117f56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f5d:	83 ec 0c             	sub    $0xc,%esp
f0117f60:	68 b8 c2 12 f0       	push   $0xf012c2b8
f0117f65:	e8 21 90 fe ff       	call   f0100f8b <cprintf>
f0117f6a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f6d:	e8 33 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f72:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f75:	74 17                	je     f0117f8e <test_kmalloc_firstfit1+0x6be>
f0117f77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f7e:	83 ec 0c             	sub    $0xc,%esp
f0117f81:	68 ec c2 12 f0       	push   $0xf012c2ec
f0117f86:	e8 00 90 fe ff       	call   f0100f8b <cprintf>
f0117f8b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0117f8e:	e8 29 6a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117f93:	89 c2                	mov    %eax,%edx
f0117f95:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f98:	29 d0                	sub    %edx,%eax
f0117f9a:	83 f8 7f             	cmp    $0x7f,%eax
f0117f9d:	7f 17                	jg     f0117fb6 <test_kmalloc_firstfit1+0x6e6>
f0117f9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fa6:	83 ec 0c             	sub    $0xc,%esp
f0117fa9:	68 58 c3 12 f0       	push   $0xf012c358
f0117fae:	e8 d8 8f fe ff       	call   f0100f8b <cprintf>
f0117fb3:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117fb6:	e8 01 6a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0117fbb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117fbe:	e8 e2 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fc3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0117fc6:	83 ec 0c             	sub    $0xc,%esp
f0117fc9:	68 00 fc 0f 00       	push   $0xffc00
f0117fce:	e8 cc 15 ff ff       	call   f010959f <kmalloc>
f0117fd3:	83 c4 10             	add    $0x10,%esp
f0117fd6:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0117fd9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117fdc:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117fe1:	74 17                	je     f0117ffa <test_kmalloc_firstfit1+0x72a>
f0117fe3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fea:	83 ec 0c             	sub    $0xc,%esp
f0117fed:	68 70 c3 12 f0       	push   $0xf012c370
f0117ff2:	e8 94 8f fe ff       	call   f0100f8b <cprintf>
f0117ff7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ffa:	e8 a6 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fff:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118002:	74 17                	je     f011801b <test_kmalloc_firstfit1+0x74b>
f0118004:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011800b:	83 ec 0c             	sub    $0xc,%esp
f011800e:	68 a4 c3 12 f0       	push   $0xf012c3a4
f0118013:	e8 73 8f fe ff       	call   f0100f8b <cprintf>
f0118018:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f011801b:	e8 9c 69 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118020:	89 c2                	mov    %eax,%edx
f0118022:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118025:	29 d0                	sub    %edx,%eax
f0118027:	3d ff 00 00 00       	cmp    $0xff,%eax
f011802c:	7f 17                	jg     f0118045 <test_kmalloc_firstfit1+0x775>
f011802e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118035:	83 ec 0c             	sub    $0xc,%esp
f0118038:	68 10 c4 12 f0       	push   $0xf012c410
f011803d:	e8 49 8f fe ff       	call   f0100f8b <cprintf>
f0118042:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118045:	e8 72 69 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011804a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011804d:	e8 53 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118052:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0118055:	83 ec 0c             	sub    $0xc,%esp
f0118058:	68 00 fc 03 00       	push   $0x3fc00
f011805d:	e8 3d 15 ff ff       	call   f010959f <kmalloc>
f0118062:	83 c4 10             	add    $0x10,%esp
f0118065:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0118068:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011806b:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0118070:	74 17                	je     f0118089 <test_kmalloc_firstfit1+0x7b9>
f0118072:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118079:	83 ec 0c             	sub    $0xc,%esp
f011807c:	68 28 c4 12 f0       	push   $0xf012c428
f0118081:	e8 05 8f fe ff       	call   f0100f8b <cprintf>
f0118086:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118089:	e8 17 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011808e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118091:	74 17                	je     f01180aa <test_kmalloc_firstfit1+0x7da>
f0118093:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011809a:	83 ec 0c             	sub    $0xc,%esp
f011809d:	68 5c c4 12 f0       	push   $0xf012c45c
f01180a2:	e8 e4 8e fe ff       	call   f0100f8b <cprintf>
f01180a7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f01180aa:	e8 0d 69 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01180af:	89 c2                	mov    %eax,%edx
f01180b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01180b4:	29 d0                	sub    %edx,%eax
f01180b6:	83 f8 3f             	cmp    $0x3f,%eax
f01180b9:	7f 17                	jg     f01180d2 <test_kmalloc_firstfit1+0x802>
f01180bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180c2:	83 ec 0c             	sub    $0xc,%esp
f01180c5:	68 c8 c4 12 f0       	push   $0xf012c4c8
f01180ca:	e8 bc 8e fe ff       	call   f0100f8b <cprintf>
f01180cf:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01180d2:	e8 e5 68 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01180d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01180da:	e8 c6 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180df:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f01180e2:	83 ec 0c             	sub    $0xc,%esp
f01180e5:	68 00 00 20 00       	push   $0x200000
f01180ea:	e8 b0 14 ff ff       	call   f010959f <kmalloc>
f01180ef:	83 c4 10             	add    $0x10,%esp
f01180f2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f01180f5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01180f8:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01180fd:	74 17                	je     f0118116 <test_kmalloc_firstfit1+0x846>
f01180ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118106:	83 ec 0c             	sub    $0xc,%esp
f0118109:	68 e0 c4 12 f0       	push   $0xf012c4e0
f011810e:	e8 78 8e fe ff       	call   f0100f8b <cprintf>
f0118113:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0118116:	e8 a1 68 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011811b:	89 c2                	mov    %eax,%edx
f011811d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118120:	29 d0                	sub    %edx,%eax
f0118122:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118127:	7f 17                	jg     f0118140 <test_kmalloc_firstfit1+0x870>
f0118129:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118130:	83 ec 0c             	sub    $0xc,%esp
f0118133:	68 14 c5 12 f0       	push   $0xf012c514
f0118138:	e8 4e 8e fe ff       	call   f0100f8b <cprintf>
f011813d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118140:	e8 60 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118145:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118148:	74 17                	je     f0118161 <test_kmalloc_firstfit1+0x891>
f011814a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118151:	83 ec 0c             	sub    $0xc,%esp
f0118154:	68 2c c5 12 f0       	push   $0xf012c52c
f0118159:	e8 2d 8e fe ff       	call   f0100f8b <cprintf>
f011815e:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0118161:	e8 56 68 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118166:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118169:	e8 37 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011816e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0118171:	83 ec 0c             	sub    $0xc,%esp
f0118174:	68 00 fc 3f 00       	push   $0x3ffc00
f0118179:	e8 21 14 ff ff       	call   f010959f <kmalloc>
f011817e:	83 c4 10             	add    $0x10,%esp
f0118181:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0118184:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118187:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f011818c:	74 17                	je     f01181a5 <test_kmalloc_firstfit1+0x8d5>
f011818e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118195:	83 ec 0c             	sub    $0xc,%esp
f0118198:	68 98 c5 12 f0       	push   $0xf012c598
f011819d:	e8 e9 8d fe ff       	call   f0100f8b <cprintf>
f01181a2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181a5:	e8 fb c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181aa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181ad:	74 17                	je     f01181c6 <test_kmalloc_firstfit1+0x8f6>
f01181af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181b6:	83 ec 0c             	sub    $0xc,%esp
f01181b9:	68 cc c5 12 f0       	push   $0xf012c5cc
f01181be:	e8 c8 8d fe ff       	call   f0100f8b <cprintf>
f01181c3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f01181c6:	e8 f1 67 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01181cb:	89 c2                	mov    %eax,%edx
f01181cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01181d0:	29 d0                	sub    %edx,%eax
f01181d2:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f01181d7:	7f 17                	jg     f01181f0 <test_kmalloc_firstfit1+0x920>
f01181d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181e0:	83 ec 0c             	sub    $0xc,%esp
f01181e3:	68 38 c6 12 f0       	push   $0xf012c638
f01181e8:	e8 9e 8d fe ff       	call   f0100f8b <cprintf>
f01181ed:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01181f0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01181f4:	74 04                	je     f01181fa <test_kmalloc_firstfit1+0x92a>
f01181f6:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01181fa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0118201:	83 ec 0c             	sub    $0xc,%esp
f0118204:	68 50 c6 12 f0       	push   $0xf012c650
f0118209:	e8 7d 8d fe ff       	call   f0100f8b <cprintf>
f011820e:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118211:	e8 a6 67 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118216:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118219:	e8 87 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011821e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0118221:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118224:	83 ec 0c             	sub    $0xc,%esp
f0118227:	50                   	push   %eax
f0118228:	e8 d2 15 ff ff       	call   f01097ff <kfree>
f011822d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118230:	e8 70 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118235:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118238:	74 17                	je     f0118251 <test_kmalloc_firstfit1+0x981>
f011823a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118241:	83 ec 0c             	sub    $0xc,%esp
f0118244:	68 10 bc 12 f0       	push   $0xf012bc10
f0118249:	e8 3d 8d fe ff       	call   f0100f8b <cprintf>
f011824e:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0118251:	e8 66 67 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118256:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118259:	3d ff 00 00 00       	cmp    $0xff,%eax
f011825e:	7f 17                	jg     f0118277 <test_kmalloc_firstfit1+0x9a7>
f0118260:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118267:	83 ec 0c             	sub    $0xc,%esp
f011826a:	68 84 c6 12 f0       	push   $0xf012c684
f011826f:	e8 17 8d fe ff       	call   f0100f8b <cprintf>
f0118274:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0118277:	e8 40 67 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011827c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011827f:	e8 21 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118284:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0118287:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011828a:	83 ec 0c             	sub    $0xc,%esp
f011828d:	50                   	push   %eax
f011828e:	e8 6c 15 ff ff       	call   f01097ff <kfree>
f0118293:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118296:	e8 0a c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011829b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011829e:	74 17                	je     f01182b7 <test_kmalloc_firstfit1+0x9e7>
f01182a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182a7:	83 ec 0c             	sub    $0xc,%esp
f01182aa:	68 d8 bc 12 f0       	push   $0xf012bcd8
f01182af:	e8 d7 8c fe ff       	call   f0100f8b <cprintf>
f01182b4:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f01182b7:	e8 00 67 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01182bc:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01182bf:	3d ff 00 00 00       	cmp    $0xff,%eax
f01182c4:	7f 17                	jg     f01182dd <test_kmalloc_firstfit1+0xa0d>
f01182c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182cd:	83 ec 0c             	sub    $0xc,%esp
f01182d0:	68 95 c6 12 f0       	push   $0xf012c695
f01182d5:	e8 b1 8c fe ff       	call   f0100f8b <cprintf>
f01182da:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01182dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01182e1:	74 04                	je     f01182e7 <test_kmalloc_firstfit1+0xa17>
f01182e3:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01182e7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f01182ee:	83 ec 0c             	sub    $0xc,%esp
f01182f1:	68 a8 c6 12 f0       	push   $0xf012c6a8
f01182f6:	e8 90 8c fe ff       	call   f0100f8b <cprintf>
f01182fb:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f01182fe:	e8 b9 66 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118303:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118306:	e8 9a c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011830b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f011830e:	83 ec 0c             	sub    $0xc,%esp
f0118311:	68 00 00 10 00       	push   $0x100000
f0118316:	e8 84 12 ff ff       	call   f010959f <kmalloc>
f011831b:	83 c4 10             	add    $0x10,%esp
f011831e:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118321:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118324:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f0118329:	74 17                	je     f0118342 <test_kmalloc_firstfit1+0xa72>
f011832b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118332:	83 ec 0c             	sub    $0xc,%esp
f0118335:	68 e8 c6 12 f0       	push   $0xf012c6e8
f011833a:	e8 4c 8c fe ff       	call   f0100f8b <cprintf>
f011833f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118342:	e8 5e c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118347:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011834a:	74 17                	je     f0118363 <test_kmalloc_firstfit1+0xa93>
f011834c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118353:	83 ec 0c             	sub    $0xc,%esp
f0118356:	68 1c c7 12 f0       	push   $0xf012c71c
f011835b:	e8 2b 8c fe ff       	call   f0100f8b <cprintf>
f0118360:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118363:	e8 54 66 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118368:	89 c2                	mov    %eax,%edx
f011836a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011836d:	29 d0                	sub    %edx,%eax
f011836f:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118374:	7f 17                	jg     f011838d <test_kmalloc_firstfit1+0xabd>
f0118376:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011837d:	83 ec 0c             	sub    $0xc,%esp
f0118380:	68 88 c7 12 f0       	push   $0xf012c788
f0118385:	e8 01 8c fe ff       	call   f0100f8b <cprintf>
f011838a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011838d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118391:	74 04                	je     f0118397 <test_kmalloc_firstfit1+0xac7>
f0118393:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0118397:	83 ec 08             	sub    $0x8,%esp
f011839a:	ff 75 f4             	pushl  -0xc(%ebp)
f011839d:	68 a0 c7 12 f0       	push   $0xf012c7a0
f01183a2:	e8 e4 8b fe ff       	call   f0100f8b <cprintf>
f01183a7:	83 c4 10             	add    $0x10,%esp

	return 1;
f01183aa:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01183af:	8b 7d fc             	mov    -0x4(%ebp),%edi
f01183b2:	c9                   	leave  
f01183b3:	c3                   	ret    

f01183b4 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f01183b4:	55                   	push   %ebp
f01183b5:	89 e5                	mov    %esp,%ebp
f01183b7:	57                   	push   %edi
f01183b8:	53                   	push   %ebx
f01183b9:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01183bc:	83 ec 0c             	sub    $0xc,%esp
f01183bf:	68 88 af 12 f0       	push   $0xf012af88
f01183c4:	e8 c2 8b fe ff       	call   f0100f8b <cprintf>
f01183c9:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01183cc:	83 ec 0c             	sub    $0xc,%esp
f01183cf:	68 b8 af 12 f0       	push   $0xf012afb8
f01183d4:	e8 b2 8b fe ff       	call   f0100f8b <cprintf>
f01183d9:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01183dc:	83 ec 0c             	sub    $0xc,%esp
f01183df:	68 88 af 12 f0       	push   $0xf012af88
f01183e4:	e8 a2 8b fe ff       	call   f0100f8b <cprintf>
f01183e9:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01183ec:	8d 55 98             	lea    -0x68(%ebp),%edx
f01183ef:	b9 14 00 00 00       	mov    $0x14,%ecx
f01183f4:	b8 00 00 00 00       	mov    $0x0,%eax
f01183f9:	89 d7                	mov    %edx,%edi
f01183fb:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01183fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0118404:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f011840b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0118412:	83 ec 0c             	sub    $0xc,%esp
f0118415:	68 d8 c7 12 f0       	push   $0xf012c7d8
f011841a:	e8 6c 8b fe ff       	call   f0100f8b <cprintf>
f011841f:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0118422:	83 ec 0c             	sub    $0xc,%esp
f0118425:	68 01 e0 ff 07       	push   $0x7ffe001
f011842a:	e8 70 11 ff ff       	call   f010959f <kmalloc>
f011842f:	83 c4 10             	add    $0x10,%esp
f0118432:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f0118435:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118438:	85 c0                	test   %eax,%eax
f011843a:	74 17                	je     f0118453 <test_kmalloc_firstfit2+0x9f>
f011843c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118443:	83 ec 0c             	sub    $0xc,%esp
f0118446:	68 0c c8 12 f0       	push   $0xf012c80c
f011844b:	e8 3b 8b fe ff       	call   f0100f8b <cprintf>
f0118450:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118453:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118457:	74 04                	je     f011845d <test_kmalloc_firstfit2+0xa9>
f0118459:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011845d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0118464:	83 ec 0c             	sub    $0xc,%esp
f0118467:	68 54 c8 12 f0       	push   $0xf012c854
f011846c:	e8 1a 8b fe ff       	call   f0100f8b <cprintf>
f0118471:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118474:	e8 43 65 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118479:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011847c:	e8 24 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118481:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0118484:	83 ec 0c             	sub    $0xc,%esp
f0118487:	68 00 fc 1f 00       	push   $0x1ffc00
f011848c:	e8 0e 11 ff ff       	call   f010959f <kmalloc>
f0118491:	83 c4 10             	add    $0x10,%esp
f0118494:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0118497:	8b 45 98             	mov    -0x68(%ebp),%eax
f011849a:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011849f:	74 17                	je     f01184b8 <test_kmalloc_firstfit2+0x104>
f01184a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184a8:	83 ec 0c             	sub    $0xc,%esp
f01184ab:	68 d4 be 12 f0       	push   $0xf012bed4
f01184b0:	e8 d6 8a fe ff       	call   f0100f8b <cprintf>
f01184b5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184b8:	e8 e8 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184bd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184c0:	74 17                	je     f01184d9 <test_kmalloc_firstfit2+0x125>
f01184c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184c9:	83 ec 0c             	sub    $0xc,%esp
f01184cc:	68 b0 b2 12 f0       	push   $0xf012b2b0
f01184d1:	e8 b5 8a fe ff       	call   f0100f8b <cprintf>
f01184d6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f01184d9:	e8 de 64 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01184de:	89 c2                	mov    %eax,%edx
f01184e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01184e3:	29 d0                	sub    %edx,%eax
f01184e5:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01184ea:	7f 17                	jg     f0118503 <test_kmalloc_firstfit2+0x14f>
f01184ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184f3:	83 ec 0c             	sub    $0xc,%esp
f01184f6:	68 07 bf 12 f0       	push   $0xf012bf07
f01184fb:	e8 8b 8a fe ff       	call   f0100f8b <cprintf>
f0118500:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118503:	e8 b4 64 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118508:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011850b:	e8 95 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118510:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0118513:	83 ec 0c             	sub    $0xc,%esp
f0118516:	68 00 fc 1f 00       	push   $0x1ffc00
f011851b:	e8 7f 10 ff ff       	call   f010959f <kmalloc>
f0118520:	83 c4 10             	add    $0x10,%esp
f0118523:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0118526:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118529:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011852e:	74 17                	je     f0118547 <test_kmalloc_firstfit2+0x193>
f0118530:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118537:	83 ec 0c             	sub    $0xc,%esp
f011853a:	68 20 bf 12 f0       	push   $0xf012bf20
f011853f:	e8 47 8a fe ff       	call   f0100f8b <cprintf>
f0118544:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118547:	e8 59 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011854c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011854f:	74 17                	je     f0118568 <test_kmalloc_firstfit2+0x1b4>
f0118551:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118558:	83 ec 0c             	sub    $0xc,%esp
f011855b:	68 ec b3 12 f0       	push   $0xf012b3ec
f0118560:	e8 26 8a fe ff       	call   f0100f8b <cprintf>
f0118565:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0118568:	e8 4f 64 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011856d:	89 c2                	mov    %eax,%edx
f011856f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118572:	29 d0                	sub    %edx,%eax
f0118574:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118579:	7f 17                	jg     f0118592 <test_kmalloc_firstfit2+0x1de>
f011857b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118582:	83 ec 0c             	sub    $0xc,%esp
f0118585:	68 53 bf 12 f0       	push   $0xf012bf53
f011858a:	e8 fc 89 fe ff       	call   f0100f8b <cprintf>
f011858f:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118592:	e8 25 64 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118597:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011859a:	e8 06 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011859f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f01185a2:	83 ec 0c             	sub    $0xc,%esp
f01185a5:	68 00 1c 00 00       	push   $0x1c00
f01185aa:	e8 f0 0f ff ff       	call   f010959f <kmalloc>
f01185af:	83 c4 10             	add    $0x10,%esp
f01185b2:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01185b5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01185b8:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01185bd:	74 17                	je     f01185d6 <test_kmalloc_firstfit2+0x222>
f01185bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185c6:	83 ec 0c             	sub    $0xc,%esp
f01185c9:	68 6c bf 12 f0       	push   $0xf012bf6c
f01185ce:	e8 b8 89 fe ff       	call   f0100f8b <cprintf>
f01185d3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185d6:	e8 ca c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185db:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185de:	74 17                	je     f01185f7 <test_kmalloc_firstfit2+0x243>
f01185e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185e7:	83 ec 0c             	sub    $0xc,%esp
f01185ea:	68 e4 b4 12 f0       	push   $0xf012b4e4
f01185ef:	e8 97 89 fe ff       	call   f0100f8b <cprintf>
f01185f4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01185f7:	e8 c0 63 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01185fc:	89 c2                	mov    %eax,%edx
f01185fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118601:	29 d0                	sub    %edx,%eax
f0118603:	83 f8 01             	cmp    $0x1,%eax
f0118606:	7f 17                	jg     f011861f <test_kmalloc_firstfit2+0x26b>
f0118608:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011860f:	83 ec 0c             	sub    $0xc,%esp
f0118612:	68 9f bf 12 f0       	push   $0xf012bf9f
f0118617:	e8 6f 89 fe ff       	call   f0100f8b <cprintf>
f011861c:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011861f:	e8 98 63 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118624:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118627:	e8 79 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011862c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f011862f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118632:	83 ec 0c             	sub    $0xc,%esp
f0118635:	50                   	push   %eax
f0118636:	e8 c4 11 ff ff       	call   f01097ff <kfree>
f011863b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011863e:	e8 62 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118643:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118646:	74 17                	je     f011865f <test_kmalloc_firstfit2+0x2ab>
f0118648:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011864f:	83 ec 0c             	sub    $0xc,%esp
f0118652:	68 c4 b5 12 f0       	push   $0xf012b5c4
f0118657:	e8 2f 89 fe ff       	call   f0100f8b <cprintf>
f011865c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f011865f:	e8 58 63 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118664:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118667:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011866c:	7f 17                	jg     f0118685 <test_kmalloc_firstfit2+0x2d1>
f011866e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118675:	83 ec 0c             	sub    $0xc,%esp
f0118678:	68 9a c8 12 f0       	push   $0xf012c89a
f011867d:	e8 09 89 fe ff       	call   f0100f8b <cprintf>
f0118682:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118685:	e8 32 63 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011868a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011868d:	e8 13 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118692:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0118695:	83 ec 0c             	sub    $0xc,%esp
f0118698:	68 00 fc 2f 00       	push   $0x2ffc00
f011869d:	e8 fd 0e ff ff       	call   f010959f <kmalloc>
f01186a2:	83 c4 10             	add    $0x10,%esp
f01186a5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f01186a8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01186ab:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f01186b0:	74 17                	je     f01186c9 <test_kmalloc_firstfit2+0x315>
f01186b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186b9:	83 ec 0c             	sub    $0xc,%esp
f01186bc:	68 04 c0 12 f0       	push   $0xf012c004
f01186c1:	e8 c5 88 fe ff       	call   f0100f8b <cprintf>
f01186c6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01186c9:	e8 d7 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186ce:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01186d1:	74 17                	je     f01186ea <test_kmalloc_firstfit2+0x336>
f01186d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186da:	83 ec 0c             	sub    $0xc,%esp
f01186dd:	68 c8 b6 12 f0       	push   $0xf012b6c8
f01186e2:	e8 a4 88 fe ff       	call   f0100f8b <cprintf>
f01186e7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f01186ea:	e8 cd 62 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01186ef:	89 c2                	mov    %eax,%edx
f01186f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01186f4:	29 d0                	sub    %edx,%eax
f01186f6:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01186fb:	7f 17                	jg     f0118714 <test_kmalloc_firstfit2+0x360>
f01186fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118704:	83 ec 0c             	sub    $0xc,%esp
f0118707:	68 37 c0 12 f0       	push   $0xf012c037
f011870c:	e8 7a 88 fe ff       	call   f0100f8b <cprintf>
f0118711:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118714:	e8 a3 62 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118719:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011871c:	e8 84 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118721:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0118724:	83 ec 0c             	sub    $0xc,%esp
f0118727:	68 00 18 20 00       	push   $0x201800
f011872c:	e8 6e 0e ff ff       	call   f010959f <kmalloc>
f0118731:	83 c4 10             	add    $0x10,%esp
f0118734:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0118737:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011873a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011873f:	74 17                	je     f0118758 <test_kmalloc_firstfit2+0x3a4>
f0118741:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118748:	83 ec 0c             	sub    $0xc,%esp
f011874b:	68 50 c0 12 f0       	push   $0xf012c050
f0118750:	e8 36 88 fe ff       	call   f0100f8b <cprintf>
f0118755:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118758:	e8 48 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011875d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118760:	74 17                	je     f0118779 <test_kmalloc_firstfit2+0x3c5>
f0118762:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118769:	83 ec 0c             	sub    $0xc,%esp
f011876c:	68 cc b7 12 f0       	push   $0xf012b7cc
f0118771:	e8 15 88 fe ff       	call   f0100f8b <cprintf>
f0118776:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0118779:	e8 3e 62 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011877e:	89 c2                	mov    %eax,%edx
f0118780:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118783:	29 d0                	sub    %edx,%eax
f0118785:	3d 01 02 00 00       	cmp    $0x201,%eax
f011878a:	7f 17                	jg     f01187a3 <test_kmalloc_firstfit2+0x3ef>
f011878c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118793:	83 ec 0c             	sub    $0xc,%esp
f0118796:	68 83 c0 12 f0       	push   $0xf012c083
f011879b:	e8 eb 87 fe ff       	call   f0100f8b <cprintf>
f01187a0:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01187a3:	e8 14 62 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01187a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187ab:	e8 f5 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01187b3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01187b6:	83 ec 0c             	sub    $0xc,%esp
f01187b9:	50                   	push   %eax
f01187ba:	e8 40 10 ff ff       	call   f01097ff <kfree>
f01187bf:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187c2:	e8 de c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187c7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01187ca:	74 17                	je     f01187e3 <test_kmalloc_firstfit2+0x42f>
f01187cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187d3:	83 ec 0c             	sub    $0xc,%esp
f01187d6:	68 d0 b8 12 f0       	push   $0xf012b8d0
f01187db:	e8 ab 87 fe ff       	call   f0100f8b <cprintf>
f01187e0:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f01187e3:	e8 d4 61 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01187e8:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01187eb:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01187f0:	7f 17                	jg     f0118809 <test_kmalloc_firstfit2+0x455>
f01187f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187f9:	83 ec 0c             	sub    $0xc,%esp
f01187fc:	68 aa c8 12 f0       	push   $0xf012c8aa
f0118801:	e8 85 87 fe ff       	call   f0100f8b <cprintf>
f0118806:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0118809:	e8 ae 61 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011880e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118811:	e8 8f c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118816:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0118819:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011881c:	83 ec 0c             	sub    $0xc,%esp
f011881f:	50                   	push   %eax
f0118820:	e8 da 0f ff ff       	call   f01097ff <kfree>
f0118825:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f0118828:	e8 8f 61 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011882d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118830:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118835:	7f 17                	jg     f011884e <test_kmalloc_firstfit2+0x49a>
f0118837:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011883e:	83 ec 0c             	sub    $0xc,%esp
f0118841:	68 7b c1 12 f0       	push   $0xf012c17b
f0118846:	e8 40 87 fe ff       	call   f0100f8b <cprintf>
f011884b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011884e:	e8 52 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118853:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118856:	74 17                	je     f011886f <test_kmalloc_firstfit2+0x4bb>
f0118858:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011885f:	83 ec 0c             	sub    $0xc,%esp
f0118862:	68 10 c1 12 f0       	push   $0xf012c110
f0118867:	e8 1f 87 fe ff       	call   f0100f8b <cprintf>
f011886c:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011886f:	e8 48 61 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118874:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118877:	e8 29 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011887c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f011887f:	83 ec 0c             	sub    $0xc,%esp
f0118882:	68 00 fc 4f 00       	push   $0x4ffc00
f0118887:	e8 13 0d ff ff       	call   f010959f <kmalloc>
f011888c:	83 c4 10             	add    $0x10,%esp
f011888f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0118892:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118895:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f011889a:	74 17                	je     f01188b3 <test_kmalloc_firstfit2+0x4ff>
f011889c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188a3:	83 ec 0c             	sub    $0xc,%esp
f01188a6:	68 bc c8 12 f0       	push   $0xf012c8bc
f01188ab:	e8 db 86 fe ff       	call   f0100f8b <cprintf>
f01188b0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01188b3:	e8 ed bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01188b8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01188bb:	74 17                	je     f01188d4 <test_kmalloc_firstfit2+0x520>
f01188bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188c4:	83 ec 0c             	sub    $0xc,%esp
f01188c7:	68 8c c1 12 f0       	push   $0xf012c18c
f01188cc:	e8 ba 86 fe ff       	call   f0100f8b <cprintf>
f01188d1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f01188d4:	e8 e3 60 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01188d9:	89 c2                	mov    %eax,%edx
f01188db:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01188de:	29 d0                	sub    %edx,%eax
f01188e0:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f01188e5:	7f 17                	jg     f01188fe <test_kmalloc_firstfit2+0x54a>
f01188e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188ee:	83 ec 0c             	sub    $0xc,%esp
f01188f1:	68 f0 c8 12 f0       	push   $0xf012c8f0
f01188f6:	e8 90 86 fe ff       	call   f0100f8b <cprintf>
f01188fb:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01188fe:	e8 b9 60 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118903:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118906:	e8 9a bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011890b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f011890e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0118911:	83 ec 0c             	sub    $0xc,%esp
f0118914:	50                   	push   %eax
f0118915:	e8 e5 0e ff ff       	call   f01097ff <kfree>
f011891a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011891d:	e8 83 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118922:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118925:	74 17                	je     f011893e <test_kmalloc_firstfit2+0x58a>
f0118927:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011892e:	83 ec 0c             	sub    $0xc,%esp
f0118931:	68 0c c2 12 f0       	push   $0xf012c20c
f0118936:	e8 50 86 fe ff       	call   f0100f8b <cprintf>
f011893b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f011893e:	e8 79 60 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118943:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118946:	83 f8 01             	cmp    $0x1,%eax
f0118949:	7f 17                	jg     f0118962 <test_kmalloc_firstfit2+0x5ae>
f011894b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118952:	83 ec 0c             	sub    $0xc,%esp
f0118955:	68 78 c2 12 f0       	push   $0xf012c278
f011895a:	e8 2c 86 fe ff       	call   f0100f8b <cprintf>
f011895f:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118962:	e8 55 60 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118967:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011896a:	e8 36 bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011896f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0118972:	83 ec 0c             	sub    $0xc,%esp
f0118975:	68 00 04 00 00       	push   $0x400
f011897a:	e8 20 0c ff ff       	call   f010959f <kmalloc>
f011897f:	83 c4 10             	add    $0x10,%esp
f0118982:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118985:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118988:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011898d:	76 22                	jbe    f01189b1 <test_kmalloc_firstfit2+0x5fd>
f011898f:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0118992:	83 ec 0c             	sub    $0xc,%esp
f0118995:	6a 00                	push   $0x0
f0118997:	e8 d0 0a ff ff       	call   f010946c <sbrk>
f011899c:	83 c4 10             	add    $0x10,%esp
f011899f:	39 c3                	cmp    %eax,%ebx
f01189a1:	73 0e                	jae    f01189b1 <test_kmalloc_firstfit2+0x5fd>
f01189a3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01189a6:	89 c2                	mov    %eax,%edx
f01189a8:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f01189ad:	39 c2                	cmp    %eax,%edx
f01189af:	72 17                	jb     f01189c8 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01189b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189b8:	83 ec 0c             	sub    $0xc,%esp
f01189bb:	68 08 c9 12 f0       	push   $0xf012c908
f01189c0:	e8 c6 85 fe ff       	call   f0100f8b <cprintf>
f01189c5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01189c8:	e8 d8 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01189cd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01189d0:	74 17                	je     f01189e9 <test_kmalloc_firstfit2+0x635>
f01189d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189d9:	83 ec 0c             	sub    $0xc,%esp
f01189dc:	68 ec c2 12 f0       	push   $0xf012c2ec
f01189e1:	e8 a5 85 fe ff       	call   f0100f8b <cprintf>
f01189e6:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01189e9:	e8 b7 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01189ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f01189f1:	83 ec 0c             	sub    $0xc,%esp
f01189f4:	68 00 08 00 00       	push   $0x800
f01189f9:	e8 a1 0b ff ff       	call   f010959f <kmalloc>
f01189fe:	83 c4 10             	add    $0x10,%esp
f0118a01:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118a04:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118a07:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118a0c:	76 22                	jbe    f0118a30 <test_kmalloc_firstfit2+0x67c>
f0118a0e:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0118a11:	83 ec 0c             	sub    $0xc,%esp
f0118a14:	6a 00                	push   $0x0
f0118a16:	e8 51 0a ff ff       	call   f010946c <sbrk>
f0118a1b:	83 c4 10             	add    $0x10,%esp
f0118a1e:	39 c3                	cmp    %eax,%ebx
f0118a20:	73 0e                	jae    f0118a30 <test_kmalloc_firstfit2+0x67c>
f0118a22:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118a25:	89 c2                	mov    %eax,%edx
f0118a27:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0118a2c:	39 c2                	cmp    %eax,%edx
f0118a2e:	72 17                	jb     f0118a47 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118a30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a37:	83 ec 0c             	sub    $0xc,%esp
f0118a3a:	68 94 c9 12 f0       	push   $0xf012c994
f0118a3f:	e8 47 85 fe ff       	call   f0100f8b <cprintf>
f0118a44:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a47:	e8 59 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a4c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a4f:	74 17                	je     f0118a68 <test_kmalloc_firstfit2+0x6b4>
f0118a51:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a58:	83 ec 0c             	sub    $0xc,%esp
f0118a5b:	68 a4 c3 12 f0       	push   $0xf012c3a4
f0118a60:	e8 26 85 fe ff       	call   f0100f8b <cprintf>
f0118a65:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a68:	e8 38 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a6d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0118a70:	83 ec 0c             	sub    $0xc,%esp
f0118a73:	68 00 04 00 00       	push   $0x400
f0118a78:	e8 22 0b ff ff       	call   f010959f <kmalloc>
f0118a7d:	83 c4 10             	add    $0x10,%esp
f0118a80:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118a83:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a86:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118a8b:	76 22                	jbe    f0118aaf <test_kmalloc_firstfit2+0x6fb>
f0118a8d:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0118a90:	83 ec 0c             	sub    $0xc,%esp
f0118a93:	6a 00                	push   $0x0
f0118a95:	e8 d2 09 ff ff       	call   f010946c <sbrk>
f0118a9a:	83 c4 10             	add    $0x10,%esp
f0118a9d:	39 c3                	cmp    %eax,%ebx
f0118a9f:	73 0e                	jae    f0118aaf <test_kmalloc_firstfit2+0x6fb>
f0118aa1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118aa4:	89 c2                	mov    %eax,%edx
f0118aa6:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0118aab:	39 c2                	cmp    %eax,%edx
f0118aad:	72 17                	jb     f0118ac6 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118aaf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ab6:	83 ec 0c             	sub    $0xc,%esp
f0118ab9:	68 20 ca 12 f0       	push   $0xf012ca20
f0118abe:	e8 c8 84 fe ff       	call   f0100f8b <cprintf>
f0118ac3:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ac6:	e8 da bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118acb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ace:	74 17                	je     f0118ae7 <test_kmalloc_firstfit2+0x733>
f0118ad0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ad7:	83 ec 0c             	sub    $0xc,%esp
f0118ada:	68 5c c4 12 f0       	push   $0xf012c45c
f0118adf:	e8 a7 84 fe ff       	call   f0100f8b <cprintf>
f0118ae4:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0118ae7:	e8 d0 5e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118aec:	89 c2                	mov    %eax,%edx
f0118aee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118af1:	29 d0                	sub    %edx,%eax
f0118af3:	83 f8 01             	cmp    $0x1,%eax
f0118af6:	74 17                	je     f0118b0f <test_kmalloc_firstfit2+0x75b>
f0118af8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aff:	83 ec 0c             	sub    $0xc,%esp
f0118b02:	68 ac ca 12 f0       	push   $0xf012caac
f0118b07:	e8 7f 84 fe ff       	call   f0100f8b <cprintf>
f0118b0c:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f0118b0f:	e8 a8 5e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118b14:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b17:	e8 89 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f0118b1f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118b22:	83 ec 0c             	sub    $0xc,%esp
f0118b25:	50                   	push   %eax
f0118b26:	e8 d4 0c ff ff       	call   f01097ff <kfree>
f0118b2b:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b2e:	e8 72 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b33:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b36:	74 17                	je     f0118b4f <test_kmalloc_firstfit2+0x79b>
f0118b38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b3f:	83 ec 0c             	sub    $0xc,%esp
f0118b42:	68 2c c5 12 f0       	push   $0xf012c52c
f0118b47:	e8 3f 84 fe ff       	call   f0100f8b <cprintf>
f0118b4c:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118b4f:	e8 68 5e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118b54:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118b57:	74 17                	je     f0118b70 <test_kmalloc_firstfit2+0x7bc>
f0118b59:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b60:	83 ec 0c             	sub    $0xc,%esp
f0118b63:	68 d0 ca 12 f0       	push   $0xf012cad0
f0118b68:	e8 1e 84 fe ff       	call   f0100f8b <cprintf>
f0118b6d:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0118b70:	e8 47 5e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118b75:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b78:	e8 28 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b7d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0118b80:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118b83:	83 ec 0c             	sub    $0xc,%esp
f0118b86:	50                   	push   %eax
f0118b87:	e8 73 0c ff ff       	call   f01097ff <kfree>
f0118b8c:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b8f:	e8 11 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b94:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b97:	74 17                	je     f0118bb0 <test_kmalloc_firstfit2+0x7fc>
f0118b99:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ba0:	83 ec 0c             	sub    $0xc,%esp
f0118ba3:	68 cc c5 12 f0       	push   $0xf012c5cc
f0118ba8:	e8 de 83 fe ff       	call   f0100f8b <cprintf>
f0118bad:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118bb0:	e8 07 5e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118bb5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118bb8:	74 17                	je     f0118bd1 <test_kmalloc_firstfit2+0x81d>
f0118bba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bc1:	83 ec 0c             	sub    $0xc,%esp
f0118bc4:	68 30 cb 12 f0       	push   $0xf012cb30
f0118bc9:	e8 bd 83 fe ff       	call   f0100f8b <cprintf>
f0118bce:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0118bd1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118bd5:	74 04                	je     f0118bdb <test_kmalloc_firstfit2+0x827>
f0118bd7:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118bdb:	83 ec 0c             	sub    $0xc,%esp
f0118bde:	68 90 cb 12 f0       	push   $0xf012cb90
f0118be3:	e8 a3 83 fe ff       	call   f0100f8b <cprintf>
f0118be8:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118beb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118bf2:	e8 c5 5d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118bf7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118bfa:	e8 a6 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118bff:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0118c02:	83 ec 0c             	sub    $0xc,%esp
f0118c05:	68 00 08 00 00       	push   $0x800
f0118c0a:	e8 90 09 ff ff       	call   f010959f <kmalloc>
f0118c0f:	83 c4 10             	add    $0x10,%esp
f0118c12:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118c15:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118c18:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118c1b:	39 c2                	cmp    %eax,%edx
f0118c1d:	74 17                	je     f0118c36 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0118c1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c26:	83 ec 0c             	sub    $0xc,%esp
f0118c29:	68 c8 cb 12 f0       	push   $0xf012cbc8
f0118c2e:	e8 58 83 fe ff       	call   f0100f8b <cprintf>
f0118c33:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c36:	e8 6a bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c3b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c3e:	74 17                	je     f0118c57 <test_kmalloc_firstfit2+0x8a3>
f0118c40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c47:	83 ec 0c             	sub    $0xc,%esp
f0118c4a:	68 10 bc 12 f0       	push   $0xf012bc10
f0118c4f:	e8 37 83 fe ff       	call   f0100f8b <cprintf>
f0118c54:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118c57:	e8 60 5d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118c5c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118c5f:	74 17                	je     f0118c78 <test_kmalloc_firstfit2+0x8c4>
f0118c61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c68:	83 ec 0c             	sub    $0xc,%esp
f0118c6b:	68 fc cb 12 f0       	push   $0xf012cbfc
f0118c70:	e8 16 83 fe ff       	call   f0100f8b <cprintf>
f0118c75:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118c78:	e8 3f 5d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118c7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c80:	e8 20 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c85:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118c88:	83 ec 0c             	sub    $0xc,%esp
f0118c8b:	68 00 04 00 00       	push   $0x400
f0118c90:	e8 0a 09 ff ff       	call   f010959f <kmalloc>
f0118c95:	83 c4 10             	add    $0x10,%esp
f0118c98:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118c9b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118c9e:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118ca1:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118ca7:	39 d0                	cmp    %edx,%eax
f0118ca9:	74 17                	je     f0118cc2 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118cab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cb2:	83 ec 0c             	sub    $0xc,%esp
f0118cb5:	68 14 cc 12 f0       	push   $0xf012cc14
f0118cba:	e8 cc 82 fe ff       	call   f0100f8b <cprintf>
f0118cbf:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118cc2:	e8 de bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cc7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118cca:	74 17                	je     f0118ce3 <test_kmalloc_firstfit2+0x92f>
f0118ccc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cd3:	83 ec 0c             	sub    $0xc,%esp
f0118cd6:	68 d8 bc 12 f0       	push   $0xf012bcd8
f0118cdb:	e8 ab 82 fe ff       	call   f0100f8b <cprintf>
f0118ce0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0118ce3:	e8 d4 5c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118ce8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118ceb:	74 17                	je     f0118d04 <test_kmalloc_firstfit2+0x950>
f0118ced:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cf4:	83 ec 0c             	sub    $0xc,%esp
f0118cf7:	68 48 cc 12 f0       	push   $0xf012cc48
f0118cfc:	e8 8a 82 fe ff       	call   f0100f8b <cprintf>
f0118d01:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0118d04:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118d08:	74 04                	je     f0118d0e <test_kmalloc_firstfit2+0x95a>
f0118d0a:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0118d0e:	83 ec 0c             	sub    $0xc,%esp
f0118d11:	68 60 cc 12 f0       	push   $0xf012cc60
f0118d16:	e8 70 82 fe ff       	call   f0100f8b <cprintf>
f0118d1b:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0118d1e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118d25:	e8 92 5c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118d2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118d2d:	e8 73 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d32:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118d35:	83 ec 0c             	sub    $0xc,%esp
f0118d38:	68 00 04 70 00       	push   $0x700400
f0118d3d:	e8 5d 08 ff ff       	call   f010959f <kmalloc>
f0118d42:	83 c4 10             	add    $0x10,%esp
f0118d45:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118d48:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118d4b:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118d50:	74 17                	je     f0118d69 <test_kmalloc_firstfit2+0x9b5>
f0118d52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d59:	83 ec 0c             	sub    $0xc,%esp
f0118d5c:	68 e8 c6 12 f0       	push   $0xf012c6e8
f0118d61:	e8 25 82 fe ff       	call   f0100f8b <cprintf>
f0118d66:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d69:	e8 37 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d6e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d71:	74 17                	je     f0118d8a <test_kmalloc_firstfit2+0x9d6>
f0118d73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d7a:	83 ec 0c             	sub    $0xc,%esp
f0118d7d:	68 1c c7 12 f0       	push   $0xf012c71c
f0118d82:	e8 04 82 fe ff       	call   f0100f8b <cprintf>
f0118d87:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118d8a:	e8 2d 5c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118d8f:	89 c2                	mov    %eax,%edx
f0118d91:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118d94:	29 d0                	sub    %edx,%eax
f0118d96:	3d 00 07 00 00       	cmp    $0x700,%eax
f0118d9b:	7f 17                	jg     f0118db4 <test_kmalloc_firstfit2+0xa00>
f0118d9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118da4:	83 ec 0c             	sub    $0xc,%esp
f0118da7:	68 88 c7 12 f0       	push   $0xf012c788
f0118dac:	e8 da 81 fe ff       	call   f0100f8b <cprintf>
f0118db1:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118db4:	e8 03 5c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118db9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118dbc:	e8 e4 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118dc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0118dc4:	83 ec 0c             	sub    $0xc,%esp
f0118dc7:	68 00 0c 00 00       	push   $0xc00
f0118dcc:	e8 ce 07 ff ff       	call   f010959f <kmalloc>
f0118dd1:	83 c4 10             	add    $0x10,%esp
f0118dd4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0118dd7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118dda:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0118ddf:	74 17                	je     f0118df8 <test_kmalloc_firstfit2+0xa44>
f0118de1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118de8:	83 ec 0c             	sub    $0xc,%esp
f0118deb:	68 94 cc 12 f0       	push   $0xf012cc94
f0118df0:	e8 96 81 fe ff       	call   f0100f8b <cprintf>
f0118df5:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118df8:	e8 a8 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118dfd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e00:	74 17                	je     f0118e19 <test_kmalloc_firstfit2+0xa65>
f0118e02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e09:	83 ec 0c             	sub    $0xc,%esp
f0118e0c:	68 c8 cc 12 f0       	push   $0xf012ccc8
f0118e11:	e8 75 81 fe ff       	call   f0100f8b <cprintf>
f0118e16:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0118e19:	e8 9e 5b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118e1e:	89 c2                	mov    %eax,%edx
f0118e20:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118e23:	29 d0                	sub    %edx,%eax
f0118e25:	85 c0                	test   %eax,%eax
f0118e27:	7f 17                	jg     f0118e40 <test_kmalloc_firstfit2+0xa8c>
f0118e29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e30:	83 ec 0c             	sub    $0xc,%esp
f0118e33:	68 34 cd 12 f0       	push   $0xf012cd34
f0118e38:	e8 4e 81 fe ff       	call   f0100f8b <cprintf>
f0118e3d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0118e40:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118e44:	74 04                	je     f0118e4a <test_kmalloc_firstfit2+0xa96>
f0118e46:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0118e4a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0118e51:	83 ec 0c             	sub    $0xc,%esp
f0118e54:	68 4c cd 12 f0       	push   $0xf012cd4c
f0118e59:	e8 2d 81 fe ff       	call   f0100f8b <cprintf>
f0118e5e:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0118e61:	83 ec 0c             	sub    $0xc,%esp
f0118e64:	68 00 e0 1f 07       	push   $0x71fe000
f0118e69:	e8 31 07 ff ff       	call   f010959f <kmalloc>
f0118e6e:	83 c4 10             	add    $0x10,%esp
f0118e71:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0118e74:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118e77:	85 c0                	test   %eax,%eax
f0118e79:	74 17                	je     f0118e92 <test_kmalloc_firstfit2+0xade>
f0118e7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e82:	83 ec 0c             	sub    $0xc,%esp
f0118e85:	68 a0 cd 12 f0       	push   $0xf012cda0
f0118e8a:	e8 fc 80 fe ff       	call   f0100f8b <cprintf>
f0118e8f:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0118e92:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118e96:	74 04                	je     f0118e9c <test_kmalloc_firstfit2+0xae8>
f0118e98:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0118e9c:	83 ec 08             	sub    $0x8,%esp
f0118e9f:	ff 75 f4             	pushl  -0xc(%ebp)
f0118ea2:	68 08 ce 12 f0       	push   $0xf012ce08
f0118ea7:	e8 df 80 fe ff       	call   f0100f8b <cprintf>
f0118eac:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118eaf:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118eb4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0118eb7:	5b                   	pop    %ebx
f0118eb8:	5f                   	pop    %edi
f0118eb9:	5d                   	pop    %ebp
f0118eba:	c3                   	ret    

f0118ebb <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0118ebb:	55                   	push   %ebp
f0118ebc:	89 e5                	mov    %esp,%ebp
f0118ebe:	53                   	push   %ebx
f0118ebf:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118ec2:	83 ec 0c             	sub    $0xc,%esp
f0118ec5:	68 88 af 12 f0       	push   $0xf012af88
f0118eca:	e8 bc 80 fe ff       	call   f0100f8b <cprintf>
f0118ecf:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118ed2:	83 ec 0c             	sub    $0xc,%esp
f0118ed5:	68 b8 af 12 f0       	push   $0xf012afb8
f0118eda:	e8 ac 80 fe ff       	call   f0100f8b <cprintf>
f0118edf:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118ee2:	83 ec 0c             	sub    $0xc,%esp
f0118ee5:	68 88 af 12 f0       	push   $0xf012af88
f0118eea:	e8 9c 80 fe ff       	call   f0100f8b <cprintf>
f0118eef:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0118ef2:	e8 c5 5a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0118ef7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0118efa:	e8 a6 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118eff:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0118f02:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0118f09:	83 ec 0c             	sub    $0xc,%esp
f0118f0c:	68 3d ce 12 f0       	push   $0xf012ce3d
f0118f11:	e8 75 80 fe ff       	call   f0100f8b <cprintf>
f0118f16:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0118f19:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118f1e:	ba 00 00 00 00       	mov    $0x0,%edx
f0118f23:	f7 75 e4             	divl   -0x1c(%ebp)
f0118f26:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0118f29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118f30:	eb 1d                	jmp    f0118f4f <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0118f32:	83 ec 0c             	sub    $0xc,%esp
f0118f35:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118f38:	e8 62 06 ff ff       	call   f010959f <kmalloc>
f0118f3d:	83 c4 10             	add    $0x10,%esp
f0118f40:	89 c2                	mov    %eax,%edx
f0118f42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f45:	89 14 85 80 93 69 f0 	mov    %edx,-0xf966c80(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0118f4c:	ff 45 f4             	incl   -0xc(%ebp)
f0118f4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f52:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118f55:	7c db                	jl     f0118f32 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0118f57:	83 ec 0c             	sub    $0xc,%esp
f0118f5a:	68 41 ce 12 f0       	push   $0xf012ce41
f0118f5f:	e8 27 80 fe ff       	call   f0100f8b <cprintf>
f0118f64:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0118f67:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0118f6c:	ba 00 00 00 00       	mov    $0x0,%edx
f0118f71:	f7 75 e4             	divl   -0x1c(%ebp)
f0118f74:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0118f77:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118f7b:	74 1e                	je     f0118f9b <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0118f7d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0118f80:	8d 43 01             	lea    0x1(%ebx),%eax
f0118f83:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118f86:	83 ec 0c             	sub    $0xc,%esp
f0118f89:	ff 75 e0             	pushl  -0x20(%ebp)
f0118f8c:	e8 0e 06 ff ff       	call   f010959f <kmalloc>
f0118f91:	83 c4 10             	add    $0x10,%esp
f0118f94:	89 04 9d 80 93 69 f0 	mov    %eax,-0xf966c80(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0118f9b:	83 ec 04             	sub    $0x4,%esp
f0118f9e:	ff 75 f0             	pushl  -0x10(%ebp)
f0118fa1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118fa4:	68 48 ce 12 f0       	push   $0xf012ce48
f0118fa9:	e8 dd 7f fe ff       	call   f0100f8b <cprintf>
f0118fae:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118fb1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118fb8:	eb 36                	jmp    f0118ff0 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0118fba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118fbd:	8b 04 85 80 93 69 f0 	mov    -0xf966c80(,%eax,4),%eax
f0118fc4:	89 c2                	mov    %eax,%edx
f0118fc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118fc9:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118fcd:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0118fd2:	39 c2                	cmp    %eax,%edx
f0118fd4:	74 17                	je     f0118fed <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0118fd6:	83 ec 04             	sub    $0x4,%esp
f0118fd9:	68 90 ce 12 f0       	push   $0xf012ce90
f0118fde:	68 e3 02 00 00       	push   $0x2e3
f0118fe3:	68 d3 ce 12 f0       	push   $0xf012ced3
f0118fe8:	e8 4c 73 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0118fed:	ff 45 f4             	incl   -0xc(%ebp)
f0118ff0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ff3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118ff6:	7c c2                	jl     f0118fba <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118ff8:	e8 a8 b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118ffd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119000:	74 17                	je     f0119019 <test_fastfirstfit+0x15e>
f0119002:	83 ec 04             	sub    $0x4,%esp
f0119005:	68 ec ce 12 f0       	push   $0xf012ceec
f011900a:	68 e6 02 00 00       	push   $0x2e6
f011900f:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119014:	e8 20 73 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0119019:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011901c:	e8 9b 59 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119021:	29 c3                	sub    %eax,%ebx
f0119023:	89 d8                	mov    %ebx,%eax
f0119025:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f011902a:	77 17                	ja     f0119043 <test_fastfirstfit+0x188>
f011902c:	83 ec 04             	sub    $0x4,%esp
f011902f:	68 54 cf 12 f0       	push   $0xf012cf54
f0119034:	68 e7 02 00 00       	push   $0x2e7
f0119039:	68 d3 ce 12 f0       	push   $0xf012ced3
f011903e:	e8 f6 72 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0119043:	e8 5d b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119048:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f011904b:	e8 6c 59 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119050:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0119053:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0119057:	7f 17                	jg     f0119070 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0119059:	83 ec 04             	sub    $0x4,%esp
f011905c:	68 68 cf 12 f0       	push   $0xf012cf68
f0119061:	68 ee 02 00 00       	push   $0x2ee
f0119066:	68 d3 ce 12 f0       	push   $0xf012ced3
f011906b:	e8 c9 72 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0119070:	a1 80 93 69 f0       	mov    0xf0699380,%eax
f0119075:	83 ec 0c             	sub    $0xc,%esp
f0119078:	50                   	push   %eax
f0119079:	e8 81 07 ff ff       	call   f01097ff <kfree>
f011907e:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0119081:	a1 88 93 69 f0       	mov    0xf0699388,%eax
f0119086:	83 ec 0c             	sub    $0xc,%esp
f0119089:	50                   	push   %eax
f011908a:	e8 70 07 ff ff       	call   f01097ff <kfree>
f011908f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0119092:	a1 8c 93 69 f0       	mov    0xf069938c,%eax
f0119097:	83 ec 0c             	sub    $0xc,%esp
f011909a:	50                   	push   %eax
f011909b:	e8 5f 07 ff ff       	call   f01097ff <kfree>
f01190a0:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f01190a3:	a1 94 93 69 f0       	mov    0xf0699394,%eax
f01190a8:	83 ec 0c             	sub    $0xc,%esp
f01190ab:	50                   	push   %eax
f01190ac:	e8 4e 07 ff ff       	call   f01097ff <kfree>
f01190b1:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f01190b4:	a1 a8 93 69 f0       	mov    0xf06993a8,%eax
f01190b9:	83 ec 0c             	sub    $0xc,%esp
f01190bc:	50                   	push   %eax
f01190bd:	e8 3d 07 ff ff       	call   f01097ff <kfree>
f01190c2:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f01190c5:	a1 b0 93 69 f0       	mov    0xf06993b0,%eax
f01190ca:	83 ec 0c             	sub    $0xc,%esp
f01190cd:	50                   	push   %eax
f01190ce:	e8 2c 07 ff ff       	call   f01097ff <kfree>
f01190d3:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f01190d6:	a1 ac 93 69 f0       	mov    0xf06993ac,%eax
f01190db:	83 ec 0c             	sub    $0xc,%esp
f01190de:	50                   	push   %eax
f01190df:	e8 1b 07 ff ff       	call   f01097ff <kfree>
f01190e4:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f01190e7:	a1 d0 93 69 f0       	mov    0xf06993d0,%eax
f01190ec:	83 ec 0c             	sub    $0xc,%esp
f01190ef:	50                   	push   %eax
f01190f0:	e8 0a 07 ff ff       	call   f01097ff <kfree>
f01190f5:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f01190f8:	a1 e4 93 69 f0       	mov    0xf06993e4,%eax
f01190fd:	83 ec 0c             	sub    $0xc,%esp
f0119100:	50                   	push   %eax
f0119101:	e8 f9 06 ff ff       	call   f01097ff <kfree>
f0119106:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0119109:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011910c:	83 e8 02             	sub    $0x2,%eax
f011910f:	8b 04 85 80 93 69 f0 	mov    -0xf966c80(,%eax,4),%eax
f0119116:	83 ec 0c             	sub    $0xc,%esp
f0119119:	50                   	push   %eax
f011911a:	e8 e0 06 ff ff       	call   f01097ff <kfree>
f011911f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0119122:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119125:	83 e8 03             	sub    $0x3,%eax
f0119128:	8b 04 85 80 93 69 f0 	mov    -0xf966c80(,%eax,4),%eax
f011912f:	83 ec 0c             	sub    $0xc,%esp
f0119132:	50                   	push   %eax
f0119133:	e8 c7 06 ff ff       	call   f01097ff <kfree>
f0119138:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011913b:	e8 65 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119140:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119143:	74 17                	je     f011915c <test_fastfirstfit+0x2a1>
f0119145:	83 ec 04             	sub    $0x4,%esp
f0119148:	68 ec ce 12 f0       	push   $0xf012ceec
f011914d:	68 fb 02 00 00       	push   $0x2fb
f0119152:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119157:	e8 dd 71 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f011915c:	e8 5b 58 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119161:	89 c2                	mov    %eax,%edx
f0119163:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119166:	89 d1                	mov    %edx,%ecx
f0119168:	29 c1                	sub    %eax,%ecx
f011916a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011916d:	89 d0                	mov    %edx,%eax
f011916f:	c1 e0 02             	shl    $0x2,%eax
f0119172:	01 d0                	add    %edx,%eax
f0119174:	01 c0                	add    %eax,%eax
f0119176:	01 d0                	add    %edx,%eax
f0119178:	c1 e8 0c             	shr    $0xc,%eax
f011917b:	39 c1                	cmp    %eax,%ecx
f011917d:	74 17                	je     f0119196 <test_fastfirstfit+0x2db>
f011917f:	83 ec 04             	sub    $0x4,%esp
f0119182:	68 a4 cf 12 f0       	push   $0xf012cfa4
f0119187:	68 fc 02 00 00       	push   $0x2fc
f011918c:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119191:	e8 a3 71 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0119196:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119199:	01 c0                	add    %eax,%eax
f011919b:	89 c2                	mov    %eax,%edx
f011919d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01191a0:	d1 e8                	shr    %eax
f01191a2:	01 d0                	add    %edx,%eax
f01191a4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01191a7:	e8 f9 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01191af:	e8 08 58 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01191b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01191b7:	83 ec 0c             	sub    $0xc,%esp
f01191ba:	ff 75 dc             	pushl  -0x24(%ebp)
f01191bd:	e8 dd 03 ff ff       	call   f010959f <kmalloc>
f01191c2:	83 c4 10             	add    $0x10,%esp
f01191c5:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f01191c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01191cb:	89 d0                	mov    %edx,%eax
f01191cd:	c1 e0 02             	shl    $0x2,%eax
f01191d0:	01 d0                	add    %edx,%eax
f01191d2:	01 c0                	add    %eax,%eax
f01191d4:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01191da:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01191dd:	39 c2                	cmp    %eax,%edx
f01191df:	74 17                	je     f01191f8 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f01191e1:	83 ec 04             	sub    $0x4,%esp
f01191e4:	68 e4 cf 12 f0       	push   $0xf012cfe4
f01191e9:	68 07 03 00 00       	push   $0x307
f01191ee:	68 d3 ce 12 f0       	push   $0xf012ced3
f01191f3:	e8 41 71 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01191f8:	e8 a8 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191fd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119200:	74 17                	je     f0119219 <test_fastfirstfit+0x35e>
f0119202:	83 ec 04             	sub    $0x4,%esp
f0119205:	68 ec ce 12 f0       	push   $0xf012ceec
f011920a:	68 08 03 00 00       	push   $0x308
f011920f:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119214:	e8 20 71 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119219:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011921c:	e8 9b 57 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119221:	29 c3                	sub    %eax,%ebx
f0119223:	89 da                	mov    %ebx,%edx
f0119225:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119228:	c1 e8 0c             	shr    $0xc,%eax
f011922b:	39 c2                	cmp    %eax,%edx
f011922d:	73 17                	jae    f0119246 <test_fastfirstfit+0x38b>
f011922f:	83 ec 04             	sub    $0x4,%esp
f0119232:	68 54 cf 12 f0       	push   $0xf012cf54
f0119237:	68 09 03 00 00       	push   $0x309
f011923c:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119241:	e8 f3 70 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f0119246:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119249:	01 c0                	add    %eax,%eax
f011924b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011924e:	e8 52 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119253:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119256:	e8 61 57 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011925b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011925e:	83 ec 0c             	sub    $0xc,%esp
f0119261:	ff 75 dc             	pushl  -0x24(%ebp)
f0119264:	e8 36 03 ff ff       	call   f010959f <kmalloc>
f0119269:	83 c4 10             	add    $0x10,%esp
f011926c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f011926f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119272:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0119277:	01 c0                	add    %eax,%eax
f0119279:	89 c2                	mov    %eax,%edx
f011927b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011927e:	39 c2                	cmp    %eax,%edx
f0119280:	74 17                	je     f0119299 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0119282:	83 ec 04             	sub    $0x4,%esp
f0119285:	68 e4 cf 12 f0       	push   $0xf012cfe4
f011928a:	68 13 03 00 00       	push   $0x313
f011928f:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119294:	e8 a0 70 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119299:	e8 07 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011929e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01192a1:	74 17                	je     f01192ba <test_fastfirstfit+0x3ff>
f01192a3:	83 ec 04             	sub    $0x4,%esp
f01192a6:	68 ec ce 12 f0       	push   $0xf012ceec
f01192ab:	68 14 03 00 00       	push   $0x314
f01192b0:	68 d3 ce 12 f0       	push   $0xf012ced3
f01192b5:	e8 7f 70 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01192ba:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01192bd:	e8 fa 56 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01192c2:	29 c3                	sub    %eax,%ebx
f01192c4:	89 da                	mov    %ebx,%edx
f01192c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01192c9:	c1 e8 0c             	shr    $0xc,%eax
f01192cc:	39 c2                	cmp    %eax,%edx
f01192ce:	73 17                	jae    f01192e7 <test_fastfirstfit+0x42c>
f01192d0:	83 ec 04             	sub    $0x4,%esp
f01192d3:	68 54 cf 12 f0       	push   $0xf012cf54
f01192d8:	68 15 03 00 00       	push   $0x315
f01192dd:	68 d3 ce 12 f0       	push   $0xf012ced3
f01192e2:	e8 52 70 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f01192e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01192ea:	89 c2                	mov    %eax,%edx
f01192ec:	01 d2                	add    %edx,%edx
f01192ee:	01 d0                	add    %edx,%eax
f01192f0:	d1 e8                	shr    %eax
f01192f2:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01192f5:	e8 ab b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01192fd:	e8 ba 56 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119302:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119305:	83 ec 0c             	sub    $0xc,%esp
f0119308:	ff 75 dc             	pushl  -0x24(%ebp)
f011930b:	e8 8f 02 ff ff       	call   f010959f <kmalloc>
f0119310:	83 c4 10             	add    $0x10,%esp
f0119313:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f0119316:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119319:	83 e8 03             	sub    $0x3,%eax
f011931c:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119320:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119326:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119329:	39 c2                	cmp    %eax,%edx
f011932b:	74 17                	je     f0119344 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f011932d:	83 ec 04             	sub    $0x4,%esp
f0119330:	68 e4 cf 12 f0       	push   $0xf012cfe4
f0119335:	68 1f 03 00 00       	push   $0x31f
f011933a:	68 d3 ce 12 f0       	push   $0xf012ced3
f011933f:	e8 f5 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119344:	e8 5c b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119349:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011934c:	74 17                	je     f0119365 <test_fastfirstfit+0x4aa>
f011934e:	83 ec 04             	sub    $0x4,%esp
f0119351:	68 ec ce 12 f0       	push   $0xf012ceec
f0119356:	68 20 03 00 00       	push   $0x320
f011935b:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119360:	e8 d4 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119365:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119368:	e8 4f 56 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011936d:	29 c3                	sub    %eax,%ebx
f011936f:	89 da                	mov    %ebx,%edx
f0119371:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119374:	c1 e8 0c             	shr    $0xc,%eax
f0119377:	39 c2                	cmp    %eax,%edx
f0119379:	73 17                	jae    f0119392 <test_fastfirstfit+0x4d7>
f011937b:	83 ec 04             	sub    $0x4,%esp
f011937e:	68 54 cf 12 f0       	push   $0xf012cf54
f0119383:	68 21 03 00 00       	push   $0x321
f0119388:	68 d3 ce 12 f0       	push   $0xf012ced3
f011938d:	e8 a7 6f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119392:	e8 0e b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119397:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011939a:	e8 1d 56 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011939f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01193a2:	83 ec 0c             	sub    $0xc,%esp
f01193a5:	ff 75 e4             	pushl  -0x1c(%ebp)
f01193a8:	e8 f2 01 ff ff       	call   f010959f <kmalloc>
f01193ad:	83 c4 10             	add    $0x10,%esp
f01193b0:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f01193b3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01193b6:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01193bb:	74 17                	je     f01193d4 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f01193bd:	83 ec 04             	sub    $0x4,%esp
f01193c0:	68 e4 cf 12 f0       	push   $0xf012cfe4
f01193c5:	68 2a 03 00 00       	push   $0x32a
f01193ca:	68 d3 ce 12 f0       	push   $0xf012ced3
f01193cf:	e8 65 6f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01193d4:	e8 cc b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01193d9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01193dc:	74 17                	je     f01193f5 <test_fastfirstfit+0x53a>
f01193de:	83 ec 04             	sub    $0x4,%esp
f01193e1:	68 ec ce 12 f0       	push   $0xf012ceec
f01193e6:	68 2b 03 00 00       	push   $0x32b
f01193eb:	68 d3 ce 12 f0       	push   $0xf012ced3
f01193f0:	e8 44 6f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01193f5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01193f8:	e8 bf 55 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01193fd:	29 c3                	sub    %eax,%ebx
f01193ff:	89 da                	mov    %ebx,%edx
f0119401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119404:	c1 e8 0c             	shr    $0xc,%eax
f0119407:	39 c2                	cmp    %eax,%edx
f0119409:	73 17                	jae    f0119422 <test_fastfirstfit+0x567>
f011940b:	83 ec 04             	sub    $0x4,%esp
f011940e:	68 54 cf 12 f0       	push   $0xf012cf54
f0119413:	68 2c 03 00 00       	push   $0x32c
f0119418:	68 d3 ce 12 f0       	push   $0xf012ced3
f011941d:	e8 17 6f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119422:	e8 7e b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119427:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011942a:	e8 8d 55 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011942f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119432:	83 ec 0c             	sub    $0xc,%esp
f0119435:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119438:	e8 62 01 ff ff       	call   f010959f <kmalloc>
f011943d:	83 c4 10             	add    $0x10,%esp
f0119440:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0119443:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119446:	89 d0                	mov    %edx,%eax
f0119448:	c1 e0 02             	shl    $0x2,%eax
f011944b:	01 d0                	add    %edx,%eax
f011944d:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119453:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119456:	39 c2                	cmp    %eax,%edx
f0119458:	74 17                	je     f0119471 <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f011945a:	83 ec 04             	sub    $0x4,%esp
f011945d:	68 e4 cf 12 f0       	push   $0xf012cfe4
f0119462:	68 35 03 00 00       	push   $0x335
f0119467:	68 d3 ce 12 f0       	push   $0xf012ced3
f011946c:	e8 c8 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119471:	e8 2f b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119476:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119479:	74 17                	je     f0119492 <test_fastfirstfit+0x5d7>
f011947b:	83 ec 04             	sub    $0x4,%esp
f011947e:	68 ec ce 12 f0       	push   $0xf012ceec
f0119483:	68 36 03 00 00       	push   $0x336
f0119488:	68 d3 ce 12 f0       	push   $0xf012ced3
f011948d:	e8 a7 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119492:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119495:	e8 22 55 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011949a:	29 c3                	sub    %eax,%ebx
f011949c:	89 da                	mov    %ebx,%edx
f011949e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01194a1:	c1 e8 0c             	shr    $0xc,%eax
f01194a4:	39 c2                	cmp    %eax,%edx
f01194a6:	73 17                	jae    f01194bf <test_fastfirstfit+0x604>
f01194a8:	83 ec 04             	sub    $0x4,%esp
f01194ab:	68 54 cf 12 f0       	push   $0xf012cf54
f01194b0:	68 37 03 00 00       	push   $0x337
f01194b5:	68 d3 ce 12 f0       	push   $0xf012ced3
f01194ba:	e8 7a 6e fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01194bf:	e8 e1 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01194c7:	e8 f0 54 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01194cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01194cf:	83 ec 0c             	sub    $0xc,%esp
f01194d2:	ff 75 e4             	pushl  -0x1c(%ebp)
f01194d5:	e8 c5 00 ff ff       	call   f010959f <kmalloc>
f01194da:	83 c4 10             	add    $0x10,%esp
f01194dd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f01194e0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01194e3:	89 d0                	mov    %edx,%eax
f01194e5:	c1 e0 02             	shl    $0x2,%eax
f01194e8:	01 d0                	add    %edx,%eax
f01194ea:	c1 e0 02             	shl    $0x2,%eax
f01194ed:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01194f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01194f6:	39 c2                	cmp    %eax,%edx
f01194f8:	74 17                	je     f0119511 <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f01194fa:	83 ec 04             	sub    $0x4,%esp
f01194fd:	68 e4 cf 12 f0       	push   $0xf012cfe4
f0119502:	68 40 03 00 00       	push   $0x340
f0119507:	68 d3 ce 12 f0       	push   $0xf012ced3
f011950c:	e8 28 6e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119511:	e8 8f b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119516:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119519:	74 17                	je     f0119532 <test_fastfirstfit+0x677>
f011951b:	83 ec 04             	sub    $0x4,%esp
f011951e:	68 ec ce 12 f0       	push   $0xf012ceec
f0119523:	68 41 03 00 00       	push   $0x341
f0119528:	68 d3 ce 12 f0       	push   $0xf012ced3
f011952d:	e8 07 6e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119532:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119535:	e8 82 54 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011953a:	29 c3                	sub    %eax,%ebx
f011953c:	89 da                	mov    %ebx,%edx
f011953e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119541:	c1 e8 0c             	shr    $0xc,%eax
f0119544:	39 c2                	cmp    %eax,%edx
f0119546:	73 17                	jae    f011955f <test_fastfirstfit+0x6a4>
f0119548:	83 ec 04             	sub    $0x4,%esp
f011954b:	68 54 cf 12 f0       	push   $0xf012cf54
f0119550:	68 42 03 00 00       	push   $0x342
f0119555:	68 d3 ce 12 f0       	push   $0xf012ced3
f011955a:	e8 da 6d fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011955f:	e8 41 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119564:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119567:	e8 50 54 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011956c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011956f:	83 ec 0c             	sub    $0xc,%esp
f0119572:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119575:	e8 25 00 ff ff       	call   f010959f <kmalloc>
f011957a:	83 c4 10             	add    $0x10,%esp
f011957d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f0119580:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119583:	89 d0                	mov    %edx,%eax
f0119585:	c1 e0 02             	shl    $0x2,%eax
f0119588:	01 d0                	add    %edx,%eax
f011958a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119591:	01 d0                	add    %edx,%eax
f0119593:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119599:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011959c:	39 c2                	cmp    %eax,%edx
f011959e:	74 17                	je     f01195b7 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f01195a0:	83 ec 04             	sub    $0x4,%esp
f01195a3:	68 e4 cf 12 f0       	push   $0xf012cfe4
f01195a8:	68 4b 03 00 00       	push   $0x34b
f01195ad:	68 d3 ce 12 f0       	push   $0xf012ced3
f01195b2:	e8 82 6d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01195b7:	e8 e9 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01195bc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01195bf:	74 17                	je     f01195d8 <test_fastfirstfit+0x71d>
f01195c1:	83 ec 04             	sub    $0x4,%esp
f01195c4:	68 ec ce 12 f0       	push   $0xf012ceec
f01195c9:	68 4c 03 00 00       	push   $0x34c
f01195ce:	68 d3 ce 12 f0       	push   $0xf012ced3
f01195d3:	e8 61 6d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01195d8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01195db:	e8 dc 53 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01195e0:	29 c3                	sub    %eax,%ebx
f01195e2:	89 da                	mov    %ebx,%edx
f01195e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01195e7:	c1 e8 0c             	shr    $0xc,%eax
f01195ea:	39 c2                	cmp    %eax,%edx
f01195ec:	73 17                	jae    f0119605 <test_fastfirstfit+0x74a>
f01195ee:	83 ec 04             	sub    $0x4,%esp
f01195f1:	68 54 cf 12 f0       	push   $0xf012cf54
f01195f6:	68 4d 03 00 00       	push   $0x34d
f01195fb:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119600:	e8 34 6d fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0119605:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119608:	d1 e8                	shr    %eax
f011960a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011960d:	e8 93 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119612:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119615:	e8 a2 53 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011961a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011961d:	83 ec 0c             	sub    $0xc,%esp
f0119620:	ff 75 dc             	pushl  -0x24(%ebp)
f0119623:	e8 77 ff fe ff       	call   f010959f <kmalloc>
f0119628:	83 c4 10             	add    $0x10,%esp
f011962b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f011962e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119631:	89 d0                	mov    %edx,%eax
f0119633:	c1 e0 02             	shl    $0x2,%eax
f0119636:	01 d0                	add    %edx,%eax
f0119638:	01 c0                	add    %eax,%eax
f011963a:	89 c1                	mov    %eax,%ecx
f011963c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011963f:	89 d0                	mov    %edx,%eax
f0119641:	c1 e0 02             	shl    $0x2,%eax
f0119644:	01 d0                	add    %edx,%eax
f0119646:	d1 e8                	shr    %eax
f0119648:	01 c8                	add    %ecx,%eax
f011964a:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119650:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119653:	39 c2                	cmp    %eax,%edx
f0119655:	74 17                	je     f011966e <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0119657:	83 ec 04             	sub    $0x4,%esp
f011965a:	68 e4 cf 12 f0       	push   $0xf012cfe4
f011965f:	68 57 03 00 00       	push   $0x357
f0119664:	68 d3 ce 12 f0       	push   $0xf012ced3
f0119669:	e8 cb 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011966e:	e8 32 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119673:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119676:	74 17                	je     f011968f <test_fastfirstfit+0x7d4>
f0119678:	83 ec 04             	sub    $0x4,%esp
f011967b:	68 ec ce 12 f0       	push   $0xf012ceec
f0119680:	68 58 03 00 00       	push   $0x358
f0119685:	68 d3 ce 12 f0       	push   $0xf012ced3
f011968a:	e8 aa 6c fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011968f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119692:	e8 25 53 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119697:	29 c3                	sub    %eax,%ebx
f0119699:	89 da                	mov    %ebx,%edx
f011969b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011969e:	c1 e8 0c             	shr    $0xc,%eax
f01196a1:	39 c2                	cmp    %eax,%edx
f01196a3:	73 17                	jae    f01196bc <test_fastfirstfit+0x801>
f01196a5:	83 ec 04             	sub    $0x4,%esp
f01196a8:	68 54 cf 12 f0       	push   $0xf012cf54
f01196ad:	68 59 03 00 00       	push   $0x359
f01196b2:	68 d3 ce 12 f0       	push   $0xf012ced3
f01196b7:	e8 7d 6c fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f01196bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01196bf:	d1 e8                	shr    %eax
f01196c1:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01196c4:	e8 dc b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01196c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01196cc:	e8 eb 52 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01196d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01196d4:	83 ec 0c             	sub    $0xc,%esp
f01196d7:	ff 75 dc             	pushl  -0x24(%ebp)
f01196da:	e8 c0 fe fe ff       	call   f010959f <kmalloc>
f01196df:	83 c4 10             	add    $0x10,%esp
f01196e2:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f01196e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01196e8:	83 e8 03             	sub    $0x3,%eax
f01196eb:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01196ef:	89 c2                	mov    %eax,%edx
f01196f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01196f4:	89 c1                	mov    %eax,%ecx
f01196f6:	01 c9                	add    %ecx,%ecx
f01196f8:	01 c8                	add    %ecx,%eax
f01196fa:	d1 e8                	shr    %eax
f01196fc:	01 d0                	add    %edx,%eax
f01196fe:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119704:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119707:	39 c2                	cmp    %eax,%edx
f0119709:	74 17                	je     f0119722 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f011970b:	83 ec 04             	sub    $0x4,%esp
f011970e:	68 e4 cf 12 f0       	push   $0xf012cfe4
f0119713:	68 63 03 00 00       	push   $0x363
f0119718:	68 d3 ce 12 f0       	push   $0xf012ced3
f011971d:	e8 17 6c fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119722:	e8 7e b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119727:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011972a:	74 17                	je     f0119743 <test_fastfirstfit+0x888>
f011972c:	83 ec 04             	sub    $0x4,%esp
f011972f:	68 ec ce 12 f0       	push   $0xf012ceec
f0119734:	68 64 03 00 00       	push   $0x364
f0119739:	68 d3 ce 12 f0       	push   $0xf012ced3
f011973e:	e8 f6 6b fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119743:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119746:	e8 71 52 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011974b:	29 c3                	sub    %eax,%ebx
f011974d:	89 da                	mov    %ebx,%edx
f011974f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119752:	c1 e8 0c             	shr    $0xc,%eax
f0119755:	39 c2                	cmp    %eax,%edx
f0119757:	73 17                	jae    f0119770 <test_fastfirstfit+0x8b5>
f0119759:	83 ec 04             	sub    $0x4,%esp
f011975c:	68 54 cf 12 f0       	push   $0xf012cf54
f0119761:	68 65 03 00 00       	push   $0x365
f0119766:	68 d3 ce 12 f0       	push   $0xf012ced3
f011976b:	e8 c9 6b fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f0119770:	83 ec 0c             	sub    $0xc,%esp
f0119773:	68 04 d0 12 f0       	push   $0xf012d004
f0119778:	e8 0e 78 fe ff       	call   f0100f8b <cprintf>
f011977d:	83 c4 10             	add    $0x10,%esp
	return 1;
f0119780:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119785:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0119788:	c9                   	leave  
f0119789:	c3                   	ret    

f011978a <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f011978a:	55                   	push   %ebp
f011978b:	89 e5                	mov    %esp,%ebp
f011978d:	57                   	push   %edi
f011978e:	53                   	push   %ebx
f011978f:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119795:	83 ec 0c             	sub    $0xc,%esp
f0119798:	68 88 af 12 f0       	push   $0xf012af88
f011979d:	e8 e9 77 fe ff       	call   f0100f8b <cprintf>
f01197a2:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01197a5:	83 ec 0c             	sub    $0xc,%esp
f01197a8:	68 b8 af 12 f0       	push   $0xf012afb8
f01197ad:	e8 d9 77 fe ff       	call   f0100f8b <cprintf>
f01197b2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01197b5:	83 ec 0c             	sub    $0xc,%esp
f01197b8:	68 88 af 12 f0       	push   $0xf012af88
f01197bd:	e8 c9 77 fe ff       	call   f0100f8b <cprintf>
f01197c2:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f01197c5:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f01197c9:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f01197cd:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f01197d3:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f01197d9:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f01197e0:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f01197e7:	e8 d0 51 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01197ec:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f01197ef:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f01197f5:	b9 14 00 00 00       	mov    $0x14,%ecx
f01197fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01197ff:	89 d7                	mov    %edx,%edi
f0119801:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119803:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f0119809:	b9 14 00 00 00       	mov    $0x14,%ecx
f011980e:	b8 00 00 00 00       	mov    $0x0,%eax
f0119813:	89 d7                	mov    %edx,%edi
f0119815:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f0119817:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011981e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f0119825:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011982c:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119832:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119837:	b8 00 00 00 00       	mov    $0x0,%eax
f011983c:	89 d7                	mov    %edx,%edi
f011983e:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f0119840:	83 ec 0c             	sub    $0xc,%esp
f0119843:	68 48 d0 12 f0       	push   $0xf012d048
f0119848:	e8 3e 77 fe ff       	call   f0100f8b <cprintf>
f011984d:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0119850:	e8 67 51 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119855:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119858:	e8 48 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011985d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119860:	83 ec 0c             	sub    $0xc,%esp
f0119863:	68 00 fc 1f 00       	push   $0x1ffc00
f0119868:	e8 32 fd fe ff       	call   f010959f <kmalloc>
f011986d:	83 c4 10             	add    $0x10,%esp
f0119870:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119876:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011987c:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119881:	74 17                	je     f011989a <test_kfree_bestfirstfit+0x110>
f0119883:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011988a:	83 ec 0c             	sub    $0xc,%esp
f011988d:	68 80 d0 12 f0       	push   $0xf012d080
f0119892:	e8 f4 76 fe ff       	call   f0100f8b <cprintf>
f0119897:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011989a:	e8 06 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011989f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01198a2:	74 17                	je     f01198bb <test_kfree_bestfirstfit+0x131>
f01198a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198ab:	83 ec 0c             	sub    $0xc,%esp
f01198ae:	68 d4 d0 12 f0       	push   $0xf012d0d4
f01198b3:	e8 d3 76 fe ff       	call   f0100f8b <cprintf>
f01198b8:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01198bb:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01198be:	e8 f9 50 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01198c3:	29 c3                	sub    %eax,%ebx
f01198c5:	89 d8                	mov    %ebx,%eax
f01198c7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01198cc:	77 17                	ja     f01198e5 <test_kfree_bestfirstfit+0x15b>
f01198ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198d5:	83 ec 0c             	sub    $0xc,%esp
f01198d8:	68 44 d1 12 f0       	push   $0xf012d144
f01198dd:	e8 a9 76 fe ff       	call   f0100f8b <cprintf>
f01198e2:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f01198e5:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f01198ec:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f01198ef:	e8 c8 50 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f01198f4:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01198f7:	e8 a9 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01198fc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01198ff:	83 ec 0c             	sub    $0xc,%esp
f0119902:	68 00 fc 1f 00       	push   $0x1ffc00
f0119907:	e8 93 fc fe ff       	call   f010959f <kmalloc>
f011990c:	83 c4 10             	add    $0x10,%esp
f011990f:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119915:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011991b:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119920:	74 17                	je     f0119939 <test_kfree_bestfirstfit+0x1af>
f0119922:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119929:	83 ec 0c             	sub    $0xc,%esp
f011992c:	68 8c d1 12 f0       	push   $0xf012d18c
f0119931:	e8 55 76 fe ff       	call   f0100f8b <cprintf>
f0119936:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119939:	e8 67 af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011993e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119941:	74 17                	je     f011995a <test_kfree_bestfirstfit+0x1d0>
f0119943:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011994a:	83 ec 0c             	sub    $0xc,%esp
f011994d:	68 e0 d1 12 f0       	push   $0xf012d1e0
f0119952:	e8 34 76 fe ff       	call   f0100f8b <cprintf>
f0119957:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011995a:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011995d:	e8 5a 50 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119962:	29 c3                	sub    %eax,%ebx
f0119964:	89 d8                	mov    %ebx,%eax
f0119966:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011996b:	77 17                	ja     f0119984 <test_kfree_bestfirstfit+0x1fa>
f011996d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119974:	83 ec 0c             	sub    $0xc,%esp
f0119977:	68 50 d2 12 f0       	push   $0xf012d250
f011997c:	e8 0a 76 fe ff       	call   f0100f8b <cprintf>
f0119981:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119984:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011998b:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011998e:	e8 29 50 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119993:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119996:	e8 0a af fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011999b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011999e:	83 ec 0c             	sub    $0xc,%esp
f01199a1:	68 00 1c 00 00       	push   $0x1c00
f01199a6:	e8 f4 fb fe ff       	call   f010959f <kmalloc>
f01199ab:	83 c4 10             	add    $0x10,%esp
f01199ae:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01199b4:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01199ba:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01199bf:	74 17                	je     f01199d8 <test_kfree_bestfirstfit+0x24e>
f01199c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199c8:	83 ec 0c             	sub    $0xc,%esp
f01199cb:	68 98 d2 12 f0       	push   $0xf012d298
f01199d0:	e8 b6 75 fe ff       	call   f0100f8b <cprintf>
f01199d5:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01199d8:	e8 c8 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01199dd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01199e0:	74 17                	je     f01199f9 <test_kfree_bestfirstfit+0x26f>
f01199e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199e9:	83 ec 0c             	sub    $0xc,%esp
f01199ec:	68 ec d2 12 f0       	push   $0xf012d2ec
f01199f1:	e8 95 75 fe ff       	call   f0100f8b <cprintf>
f01199f6:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01199f9:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01199fc:	e8 bb 4f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119a01:	29 c3                	sub    %eax,%ebx
f0119a03:	89 d8                	mov    %ebx,%eax
f0119a05:	83 f8 01             	cmp    $0x1,%eax
f0119a08:	77 17                	ja     f0119a21 <test_kfree_bestfirstfit+0x297>
f0119a0a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a11:	83 ec 0c             	sub    $0xc,%esp
f0119a14:	68 5c d3 12 f0       	push   $0xf012d35c
f0119a19:	e8 6d 75 fe ff       	call   f0100f8b <cprintf>
f0119a1e:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f0119a21:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f0119a28:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f0119a2b:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119a31:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119a34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a3b:	eb 0e                	jmp    f0119a4b <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f0119a3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a40:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a43:	01 d0                	add    %edx,%eax
f0119a45:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f0119a48:	ff 45 f4             	incl   -0xc(%ebp)
f0119a4b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0119a51:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a54:	7f e7                	jg     f0119a3d <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119a56:	e8 61 4f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119a5b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119a5e:	e8 42 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119a63:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119a66:	83 ec 0c             	sub    $0xc,%esp
f0119a69:	68 00 fc 2f 00       	push   $0x2ffc00
f0119a6e:	e8 2c fb fe ff       	call   f010959f <kmalloc>
f0119a73:	83 c4 10             	add    $0x10,%esp
f0119a76:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119a7c:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119a82:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119a87:	74 17                	je     f0119aa0 <test_kfree_bestfirstfit+0x316>
f0119a89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a90:	83 ec 0c             	sub    $0xc,%esp
f0119a93:	68 a4 d3 12 f0       	push   $0xf012d3a4
f0119a98:	e8 ee 74 fe ff       	call   f0100f8b <cprintf>
f0119a9d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119aa0:	e8 00 ae fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119aa5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119aa8:	74 17                	je     f0119ac1 <test_kfree_bestfirstfit+0x337>
f0119aaa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ab1:	83 ec 0c             	sub    $0xc,%esp
f0119ab4:	68 f8 d3 12 f0       	push   $0xf012d3f8
f0119ab9:	e8 cd 74 fe ff       	call   f0100f8b <cprintf>
f0119abe:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119ac1:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119ac4:	e8 f3 4e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119ac9:	29 c3                	sub    %eax,%ebx
f0119acb:	89 d8                	mov    %ebx,%eax
f0119acd:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119ad2:	77 17                	ja     f0119aeb <test_kfree_bestfirstfit+0x361>
f0119ad4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119adb:	83 ec 0c             	sub    $0xc,%esp
f0119ade:	68 68 d4 12 f0       	push   $0xf012d468
f0119ae3:	e8 a3 74 fe ff       	call   f0100f8b <cprintf>
f0119ae8:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0119aeb:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f0119af2:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f0119af5:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119afb:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f0119afe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119b05:	eb 0e                	jmp    f0119b15 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f0119b07:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119b0a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119b0d:	01 d0                	add    %edx,%eax
f0119b0f:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119b12:	ff 45 f4             	incl   -0xc(%ebp)
f0119b15:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119b1b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b1e:	7f e7                	jg     f0119b07 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f0119b20:	e8 97 4e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119b25:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119b28:	e8 78 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b2d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0119b30:	83 ec 0c             	sub    $0xc,%esp
f0119b33:	68 00 fc 5f 00       	push   $0x5ffc00
f0119b38:	e8 62 fa fe ff       	call   f010959f <kmalloc>
f0119b3d:	83 c4 10             	add    $0x10,%esp
f0119b40:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119b46:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119b4c:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119b51:	74 17                	je     f0119b6a <test_kfree_bestfirstfit+0x3e0>
f0119b53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b5a:	83 ec 0c             	sub    $0xc,%esp
f0119b5d:	68 b0 d4 12 f0       	push   $0xf012d4b0
f0119b62:	e8 24 74 fe ff       	call   f0100f8b <cprintf>
f0119b67:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b6a:	e8 36 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b6f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b72:	74 17                	je     f0119b8b <test_kfree_bestfirstfit+0x401>
f0119b74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b7b:	83 ec 0c             	sub    $0xc,%esp
f0119b7e:	68 04 d5 12 f0       	push   $0xf012d504
f0119b83:	e8 03 74 fe ff       	call   f0100f8b <cprintf>
f0119b88:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119b8b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119b8e:	e8 29 4e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119b93:	29 c3                	sub    %eax,%ebx
f0119b95:	89 d8                	mov    %ebx,%eax
f0119b97:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119b9c:	77 17                	ja     f0119bb5 <test_kfree_bestfirstfit+0x42b>
f0119b9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ba5:	83 ec 0c             	sub    $0xc,%esp
f0119ba8:	68 74 d5 12 f0       	push   $0xf012d574
f0119bad:	e8 d9 73 fe ff       	call   f0100f8b <cprintf>
f0119bb2:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0119bb5:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0119bbc:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0119bbf:	e8 f8 4d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119bc4:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119bc7:	e8 d9 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119bcc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0119bcf:	83 ec 0c             	sub    $0xc,%esp
f0119bd2:	68 00 38 00 00       	push   $0x3800
f0119bd7:	e8 c3 f9 fe ff       	call   f010959f <kmalloc>
f0119bdc:	83 c4 10             	add    $0x10,%esp
f0119bdf:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119be5:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119beb:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0119bf0:	74 17                	je     f0119c09 <test_kfree_bestfirstfit+0x47f>
f0119bf2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bf9:	83 ec 0c             	sub    $0xc,%esp
f0119bfc:	68 bc d5 12 f0       	push   $0xf012d5bc
f0119c01:	e8 85 73 fe ff       	call   f0100f8b <cprintf>
f0119c06:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c09:	e8 97 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c0e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c11:	74 17                	je     f0119c2a <test_kfree_bestfirstfit+0x4a0>
f0119c13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c1a:	83 ec 0c             	sub    $0xc,%esp
f0119c1d:	68 10 d6 12 f0       	push   $0xf012d610
f0119c22:	e8 64 73 fe ff       	call   f0100f8b <cprintf>
f0119c27:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119c2a:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119c2d:	e8 8a 4d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119c32:	29 c3                	sub    %eax,%ebx
f0119c34:	89 d8                	mov    %ebx,%eax
f0119c36:	83 f8 03             	cmp    $0x3,%eax
f0119c39:	77 17                	ja     f0119c52 <test_kfree_bestfirstfit+0x4c8>
f0119c3b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c42:	83 ec 0c             	sub    $0xc,%esp
f0119c45:	68 80 d6 12 f0       	push   $0xf012d680
f0119c4a:	e8 3c 73 fe ff       	call   f0100f8b <cprintf>
f0119c4f:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119c52:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119c59:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119c5f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119c62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c69:	eb 0e                	jmp    f0119c79 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119c6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c71:	01 d0                	add    %edx,%eax
f0119c73:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119c76:	ff 45 f4             	incl   -0xc(%ebp)
f0119c79:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119c7c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c7f:	7f ea                	jg     f0119c6b <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0119c81:	e8 36 4d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119c86:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119c89:	e8 17 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c8e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0119c91:	83 ec 0c             	sub    $0xc,%esp
f0119c94:	68 00 08 00 00       	push   $0x800
f0119c99:	e8 01 f9 fe ff       	call   f010959f <kmalloc>
f0119c9e:	83 c4 10             	add    $0x10,%esp
f0119ca1:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119ca7:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119cad:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119cb2:	76 28                	jbe    f0119cdc <test_kfree_bestfirstfit+0x552>
f0119cb4:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0119cba:	83 ec 0c             	sub    $0xc,%esp
f0119cbd:	6a 00                	push   $0x0
f0119cbf:	e8 a8 f7 fe ff       	call   f010946c <sbrk>
f0119cc4:	83 c4 10             	add    $0x10,%esp
f0119cc7:	39 c3                	cmp    %eax,%ebx
f0119cc9:	73 11                	jae    f0119cdc <test_kfree_bestfirstfit+0x552>
f0119ccb:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119cd1:	89 c2                	mov    %eax,%edx
f0119cd3:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119cd8:	39 c2                	cmp    %eax,%edx
f0119cda:	72 17                	jb     f0119cf3 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119cdc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ce3:	83 ec 0c             	sub    $0xc,%esp
f0119ce6:	68 c8 d6 12 f0       	push   $0xf012d6c8
f0119ceb:	e8 9b 72 fe ff       	call   f0100f8b <cprintf>
f0119cf0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119cf3:	e8 ad ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119cf8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119cfb:	74 17                	je     f0119d14 <test_kfree_bestfirstfit+0x58a>
f0119cfd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d04:	83 ec 0c             	sub    $0xc,%esp
f0119d07:	68 54 d7 12 f0       	push   $0xf012d754
f0119d0c:	e8 7a 72 fe ff       	call   f0100f8b <cprintf>
f0119d11:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119d14:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0119d1b:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0119d1e:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119d24:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119d27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119d2e:	eb 0e                	jmp    f0119d3e <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0119d30:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119d33:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119d36:	01 d0                	add    %edx,%eax
f0119d38:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0119d3b:	ff 45 f4             	incl   -0xc(%ebp)
f0119d3e:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119d44:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119d47:	7f e7                	jg     f0119d30 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119d49:	e8 57 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d4e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119d51:	83 ec 0c             	sub    $0xc,%esp
f0119d54:	68 00 08 00 00       	push   $0x800
f0119d59:	e8 41 f8 fe ff       	call   f010959f <kmalloc>
f0119d5e:	83 c4 10             	add    $0x10,%esp
f0119d61:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119d67:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119d6d:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119d72:	76 28                	jbe    f0119d9c <test_kfree_bestfirstfit+0x612>
f0119d74:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0119d7a:	83 ec 0c             	sub    $0xc,%esp
f0119d7d:	6a 00                	push   $0x0
f0119d7f:	e8 e8 f6 fe ff       	call   f010946c <sbrk>
f0119d84:	83 c4 10             	add    $0x10,%esp
f0119d87:	39 c3                	cmp    %eax,%ebx
f0119d89:	73 11                	jae    f0119d9c <test_kfree_bestfirstfit+0x612>
f0119d8b:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119d91:	89 c2                	mov    %eax,%edx
f0119d93:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f0119d98:	39 c2                	cmp    %eax,%edx
f0119d9a:	72 17                	jb     f0119db3 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119d9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119da3:	83 ec 0c             	sub    $0xc,%esp
f0119da6:	68 c4 d7 12 f0       	push   $0xf012d7c4
f0119dab:	e8 db 71 fe ff       	call   f0100f8b <cprintf>
f0119db0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119db3:	e8 ed aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119db8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119dbb:	74 17                	je     f0119dd4 <test_kfree_bestfirstfit+0x64a>
f0119dbd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dc4:	83 ec 0c             	sub    $0xc,%esp
f0119dc7:	68 50 d8 12 f0       	push   $0xf012d850
f0119dcc:	e8 ba 71 fe ff       	call   f0100f8b <cprintf>
f0119dd1:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0119dd4:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0119ddb:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0119dde:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119de4:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0119de7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119dee:	eb 0e                	jmp    f0119dfe <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0119df0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119df3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119df6:	01 d0                	add    %edx,%eax
f0119df8:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0119dfb:	ff 45 f4             	incl   -0xc(%ebp)
f0119dfe:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0119e04:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119e07:	7f e7                	jg     f0119df0 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0119e09:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119e0c:	e8 ab 4b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119e11:	29 c3                	sub    %eax,%ebx
f0119e13:	89 d8                	mov    %ebx,%eax
f0119e15:	83 f8 01             	cmp    $0x1,%eax
f0119e18:	74 17                	je     f0119e31 <test_kfree_bestfirstfit+0x6a7>
f0119e1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e21:	83 ec 0c             	sub    $0xc,%esp
f0119e24:	68 c0 d8 12 f0       	push   $0xf012d8c0
f0119e29:	e8 5d 71 fe ff       	call   f0100f8b <cprintf>
f0119e2e:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0119e31:	83 ec 0c             	sub    $0xc,%esp
f0119e34:	68 e4 d8 12 f0       	push   $0xf012d8e4
f0119e39:	e8 4d 71 fe ff       	call   f0100f8b <cprintf>
f0119e3e:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0119e41:	e8 76 4b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119e46:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0119e49:	e8 57 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e4e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f0119e51:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119e57:	83 ec 0c             	sub    $0xc,%esp
f0119e5a:	50                   	push   %eax
f0119e5b:	e8 9f f9 fe ff       	call   f01097ff <kfree>
f0119e60:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e63:	e8 3d aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e68:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119e6b:	74 17                	je     f0119e84 <test_kfree_bestfirstfit+0x6fa>
f0119e6d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e74:	83 ec 0c             	sub    $0xc,%esp
f0119e77:	68 14 d9 12 f0       	push   $0xf012d914
f0119e7c:	e8 0a 71 fe ff       	call   f0100f8b <cprintf>
f0119e81:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119e84:	e8 33 4b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119e89:	89 c2                	mov    %eax,%edx
f0119e8b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119e8e:	29 c2                	sub    %eax,%edx
f0119e90:	89 d0                	mov    %edx,%eax
f0119e92:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119e97:	77 17                	ja     f0119eb0 <test_kfree_bestfirstfit+0x726>
f0119e99:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ea0:	83 ec 0c             	sub    $0xc,%esp
f0119ea3:	68 84 d9 12 f0       	push   $0xf012d984
f0119ea8:	e8 de 70 fe ff       	call   f0100f8b <cprintf>
f0119ead:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f0119eb0:	e8 07 4b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119eb5:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119eb8:	e8 e8 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ebd:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f0119ec0:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119ec6:	83 ec 0c             	sub    $0xc,%esp
f0119ec9:	50                   	push   %eax
f0119eca:	e8 30 f9 fe ff       	call   f01097ff <kfree>
f0119ecf:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ed2:	e8 ce a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ed7:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119eda:	74 17                	je     f0119ef3 <test_kfree_bestfirstfit+0x769>
f0119edc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ee3:	83 ec 0c             	sub    $0xc,%esp
f0119ee6:	68 c0 d9 12 f0       	push   $0xf012d9c0
f0119eeb:	e8 9b 70 fe ff       	call   f0100f8b <cprintf>
f0119ef0:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119ef3:	e8 c4 4a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119ef8:	89 c2                	mov    %eax,%edx
f0119efa:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119efd:	39 c2                	cmp    %eax,%edx
f0119eff:	74 17                	je     f0119f18 <test_kfree_bestfirstfit+0x78e>
f0119f01:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f08:	83 ec 0c             	sub    $0xc,%esp
f0119f0b:	68 30 da 12 f0       	push   $0xf012da30
f0119f10:	e8 76 70 fe ff       	call   f0100f8b <cprintf>
f0119f15:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119f18:	e8 9f 4a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119f1d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119f20:	e8 80 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f25:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0119f28:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119f2e:	83 ec 0c             	sub    $0xc,%esp
f0119f31:	50                   	push   %eax
f0119f32:	e8 c8 f8 fe ff       	call   f01097ff <kfree>
f0119f37:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f3a:	e8 66 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f3f:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119f42:	74 17                	je     f0119f5b <test_kfree_bestfirstfit+0x7d1>
f0119f44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f4b:	83 ec 0c             	sub    $0xc,%esp
f0119f4e:	68 90 da 12 f0       	push   $0xf012da90
f0119f53:	e8 33 70 fe ff       	call   f0100f8b <cprintf>
f0119f58:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119f5b:	e8 5c 4a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119f60:	89 c2                	mov    %eax,%edx
f0119f62:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119f65:	29 c2                	sub    %eax,%edx
f0119f67:	89 d0                	mov    %edx,%eax
f0119f69:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119f6e:	77 17                	ja     f0119f87 <test_kfree_bestfirstfit+0x7fd>
f0119f70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f77:	83 ec 0c             	sub    $0xc,%esp
f0119f7a:	68 00 db 12 f0       	push   $0xf012db00
f0119f7f:	e8 07 70 fe ff       	call   f0100f8b <cprintf>
f0119f84:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0119f87:	e8 30 4a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119f8c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119f8f:	e8 11 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f94:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0119f97:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0119f9d:	83 ec 0c             	sub    $0xc,%esp
f0119fa0:	50                   	push   %eax
f0119fa1:	e8 59 f8 fe ff       	call   f01097ff <kfree>
f0119fa6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119fa9:	e8 f7 a8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119fae:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119fb1:	74 17                	je     f0119fca <test_kfree_bestfirstfit+0x840>
f0119fb3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fba:	83 ec 0c             	sub    $0xc,%esp
f0119fbd:	68 3c db 12 f0       	push   $0xf012db3c
f0119fc2:	e8 c4 6f fe ff       	call   f0100f8b <cprintf>
f0119fc7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119fca:	e8 ed 49 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f0119fcf:	89 c2                	mov    %eax,%edx
f0119fd1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119fd4:	29 c2                	sub    %eax,%edx
f0119fd6:	89 d0                	mov    %edx,%eax
f0119fd8:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0119fdd:	77 17                	ja     f0119ff6 <test_kfree_bestfirstfit+0x86c>
f0119fdf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fe6:	83 ec 0c             	sub    $0xc,%esp
f0119fe9:	68 ac db 12 f0       	push   $0xf012dbac
f0119fee:	e8 98 6f fe ff       	call   f0100f8b <cprintf>
f0119ff3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119ff6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119ffa:	74 04                	je     f011a000 <test_kfree_bestfirstfit+0x876>
f0119ffc:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a000:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f011a007:	83 ec 0c             	sub    $0xc,%esp
f011a00a:	68 e8 db 12 f0       	push   $0xf012dbe8
f011a00f:	e8 77 6f fe ff       	call   f0100f8b <cprintf>
f011a014:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011a017:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a01d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011a020:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a027:	eb 1e                	jmp    f011a047 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f011a029:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a02f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a032:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a035:	01 c8                	add    %ecx,%eax
f011a037:	8a 00                	mov    (%eax),%al
f011a039:	0f be c0             	movsbl %al,%eax
f011a03c:	01 d0                	add    %edx,%eax
f011a03e:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011a044:	ff 45 f4             	incl   -0xc(%ebp)
f011a047:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a04d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a050:	7f d7                	jg     f011a029 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f011a052:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011a058:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a05e:	89 c1                	mov    %eax,%ecx
f011a060:	01 c9                	add    %ecx,%ecx
f011a062:	01 c8                	add    %ecx,%eax
f011a064:	39 c2                	cmp    %eax,%edx
f011a066:	74 17                	je     f011a07f <test_kfree_bestfirstfit+0x8f5>
f011a068:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a06f:	83 ec 0c             	sub    $0xc,%esp
f011a072:	68 30 dc 12 f0       	push   $0xf012dc30
f011a077:	e8 0f 6f fe ff       	call   f0100f8b <cprintf>
f011a07c:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011a07f:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a085:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011a088:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a08f:	eb 1e                	jmp    f011a0af <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f011a091:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011a097:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a09a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a09d:	01 c8                	add    %ecx,%eax
f011a09f:	8a 00                	mov    (%eax),%al
f011a0a1:	0f be c0             	movsbl %al,%eax
f011a0a4:	01 d0                	add    %edx,%eax
f011a0a6:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011a0ac:	ff 45 f4             	incl   -0xc(%ebp)
f011a0af:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a0b5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a0b8:	7f d7                	jg     f011a091 <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f011a0ba:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011a0c0:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f011a0c6:	c1 e2 02             	shl    $0x2,%edx
f011a0c9:	39 d0                	cmp    %edx,%eax
f011a0cb:	74 17                	je     f011a0e4 <test_kfree_bestfirstfit+0x95a>
f011a0cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0d4:	83 ec 0c             	sub    $0xc,%esp
f011a0d7:	68 68 dc 12 f0       	push   $0xf012dc68
f011a0dc:	e8 aa 6e fe ff       	call   f0100f8b <cprintf>
f011a0e1:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011a0e4:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a0ea:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011a0ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a0f4:	eb 1e                	jmp    f011a114 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f011a0f6:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011a0fc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a0ff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a102:	01 c8                	add    %ecx,%eax
f011a104:	8a 00                	mov    (%eax),%al
f011a106:	0f be c0             	movsbl %al,%eax
f011a109:	01 d0                	add    %edx,%eax
f011a10b:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011a111:	ff 45 f4             	incl   -0xc(%ebp)
f011a114:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a11a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a11d:	7f d7                	jg     f011a0f6 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011a11f:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011a125:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011a12b:	89 d0                	mov    %edx,%eax
f011a12d:	c1 e0 02             	shl    $0x2,%eax
f011a130:	01 d0                	add    %edx,%eax
f011a132:	39 c1                	cmp    %eax,%ecx
f011a134:	74 17                	je     f011a14d <test_kfree_bestfirstfit+0x9c3>
f011a136:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a13d:	83 ec 0c             	sub    $0xc,%esp
f011a140:	68 a0 dc 12 f0       	push   $0xf012dca0
f011a145:	e8 41 6e fe ff       	call   f0100f8b <cprintf>
f011a14a:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011a14d:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a153:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011a156:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a15d:	eb 1e                	jmp    f011a17d <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011a15f:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011a165:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a168:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a16b:	01 c8                	add    %ecx,%eax
f011a16d:	8a 00                	mov    (%eax),%al
f011a16f:	0f be c0             	movsbl %al,%eax
f011a172:	01 d0                	add    %edx,%eax
f011a174:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011a17a:	ff 45 f4             	incl   -0xc(%ebp)
f011a17d:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a180:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a183:	7f da                	jg     f011a15f <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011a185:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011a18b:	8b 55 80             	mov    -0x80(%ebp),%edx
f011a18e:	89 d0                	mov    %edx,%eax
f011a190:	01 c0                	add    %eax,%eax
f011a192:	01 d0                	add    %edx,%eax
f011a194:	01 c0                	add    %eax,%eax
f011a196:	01 d0                	add    %edx,%eax
f011a198:	39 c1                	cmp    %eax,%ecx
f011a19a:	74 17                	je     f011a1b3 <test_kfree_bestfirstfit+0xa29>
f011a19c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1a3:	83 ec 0c             	sub    $0xc,%esp
f011a1a6:	68 d8 dc 12 f0       	push   $0xf012dcd8
f011a1ab:	e8 db 6d fe ff       	call   f0100f8b <cprintf>
f011a1b0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011a1b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a1b7:	74 04                	je     f011a1bd <test_kfree_bestfirstfit+0xa33>
f011a1b9:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a1bd:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011a1c4:	83 ec 0c             	sub    $0xc,%esp
f011a1c7:	68 10 dd 12 f0       	push   $0xf012dd10
f011a1cc:	e8 ba 6d fe ff       	call   f0100f8b <cprintf>
f011a1d1:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011a1d4:	e8 e3 47 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a1d9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a1dc:	e8 c4 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a1e1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011a1e4:	83 ec 0c             	sub    $0xc,%esp
f011a1e7:	68 00 04 00 00       	push   $0x400
f011a1ec:	e8 ae f3 fe ff       	call   f010959f <kmalloc>
f011a1f1:	83 c4 10             	add    $0x10,%esp
f011a1f4:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011a1fa:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011a200:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a206:	39 c2                	cmp    %eax,%edx
f011a208:	74 17                	je     f011a221 <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a20a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a211:	83 ec 0c             	sub    $0xc,%esp
f011a214:	68 30 dd 12 f0       	push   $0xf012dd30
f011a219:	e8 6d 6d fe ff       	call   f0100f8b <cprintf>
f011a21e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a221:	e8 7f a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a226:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a229:	74 17                	je     f011a242 <test_kfree_bestfirstfit+0xab8>
f011a22b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a232:	83 ec 0c             	sub    $0xc,%esp
f011a235:	68 84 dd 12 f0       	push   $0xf012dd84
f011a23a:	e8 4c 6d fe ff       	call   f0100f8b <cprintf>
f011a23f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a242:	e8 75 47 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a247:	89 c2                	mov    %eax,%edx
f011a249:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a24c:	39 c2                	cmp    %eax,%edx
f011a24e:	74 17                	je     f011a267 <test_kfree_bestfirstfit+0xadd>
f011a250:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a257:	83 ec 0c             	sub    $0xc,%esp
f011a25a:	68 f4 dd 12 f0       	push   $0xf012ddf4
f011a25f:	e8 27 6d fe ff       	call   f0100f8b <cprintf>
f011a264:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011a267:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011a26e:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a274:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011a277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a27e:	eb 0e                	jmp    f011a28e <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011a280:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a283:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a286:	01 d0                	add    %edx,%eax
f011a288:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011a28b:	ff 45 f4             	incl   -0xc(%ebp)
f011a28e:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a291:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a294:	7f ea                	jg     f011a280 <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a296:	e8 21 47 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a29b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a29e:	e8 02 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a2a3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011a2a6:	83 ec 0c             	sub    $0xc,%esp
f011a2a9:	68 00 00 30 00       	push   $0x300000
f011a2ae:	e8 ec f2 fe ff       	call   f010959f <kmalloc>
f011a2b3:	83 c4 10             	add    $0x10,%esp
f011a2b6:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a2bc:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a2c2:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a2c7:	74 17                	je     f011a2e0 <test_kfree_bestfirstfit+0xb56>
f011a2c9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2d0:	83 ec 0c             	sub    $0xc,%esp
f011a2d3:	68 70 de 12 f0       	push   $0xf012de70
f011a2d8:	e8 ae 6c fe ff       	call   f0100f8b <cprintf>
f011a2dd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a2e0:	e8 c0 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a2e5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a2e8:	74 17                	je     f011a301 <test_kfree_bestfirstfit+0xb77>
f011a2ea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2f1:	83 ec 0c             	sub    $0xc,%esp
f011a2f4:	68 c4 de 12 f0       	push   $0xf012dec4
f011a2f9:	e8 8d 6c fe ff       	call   f0100f8b <cprintf>
f011a2fe:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a301:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a304:	e8 b3 46 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a309:	29 c3                	sub    %eax,%ebx
f011a30b:	89 d8                	mov    %ebx,%eax
f011a30d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a312:	77 17                	ja     f011a32b <test_kfree_bestfirstfit+0xba1>
f011a314:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a31b:	83 ec 0c             	sub    $0xc,%esp
f011a31e:	68 34 df 12 f0       	push   $0xf012df34
f011a323:	e8 63 6c fe ff       	call   f0100f8b <cprintf>
f011a328:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011a32b:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011a332:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a338:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011a33b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a342:	eb 0e                	jmp    f011a352 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011a344:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a347:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a34a:	01 d0                	add    %edx,%eax
f011a34c:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011a34f:	ff 45 f4             	incl   -0xc(%ebp)
f011a352:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a355:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a358:	7f ea                	jg     f011a344 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011a35a:	e8 5d 46 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a35f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a362:	e8 3e a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a367:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011a36a:	83 ec 0c             	sub    $0xc,%esp
f011a36d:	68 00 00 10 00       	push   $0x100000
f011a372:	e8 28 f2 fe ff       	call   f010959f <kmalloc>
f011a377:	83 c4 10             	add    $0x10,%esp
f011a37a:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a380:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a386:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011a38b:	74 17                	je     f011a3a4 <test_kfree_bestfirstfit+0xc1a>
f011a38d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a394:	83 ec 0c             	sub    $0xc,%esp
f011a397:	68 7c df 12 f0       	push   $0xf012df7c
f011a39c:	e8 ea 6b fe ff       	call   f0100f8b <cprintf>
f011a3a1:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a3a4:	e8 fc a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a3a9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a3ac:	74 17                	je     f011a3c5 <test_kfree_bestfirstfit+0xc3b>
f011a3ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3b5:	83 ec 0c             	sub    $0xc,%esp
f011a3b8:	68 d0 df 12 f0       	push   $0xf012dfd0
f011a3bd:	e8 c9 6b fe ff       	call   f0100f8b <cprintf>
f011a3c2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a3c5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a3c8:	e8 ef 45 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a3cd:	29 c3                	sub    %eax,%ebx
f011a3cf:	89 d8                	mov    %ebx,%eax
f011a3d1:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a3d6:	77 17                	ja     f011a3ef <test_kfree_bestfirstfit+0xc65>
f011a3d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3df:	83 ec 0c             	sub    $0xc,%esp
f011a3e2:	68 40 e0 12 f0       	push   $0xf012e040
f011a3e7:	e8 9f 6b fe ff       	call   f0100f8b <cprintf>
f011a3ec:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011a3ef:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011a3f6:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a3fc:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011a3ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a406:	eb 0e                	jmp    f011a416 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011a408:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a40b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a40e:	01 d0                	add    %edx,%eax
f011a410:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011a413:	ff 45 f4             	incl   -0xc(%ebp)
f011a416:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a419:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a41c:	7f ea                	jg     f011a408 <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011a41e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a422:	74 04                	je     f011a428 <test_kfree_bestfirstfit+0xc9e>
f011a424:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a428:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011a42f:	83 ec 0c             	sub    $0xc,%esp
f011a432:	68 88 e0 12 f0       	push   $0xf012e088
f011a437:	e8 4f 6b fe ff       	call   f0100f8b <cprintf>
f011a43c:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011a43f:	e8 78 45 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a444:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a447:	e8 59 a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a44c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011a44f:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a455:	83 ec 0c             	sub    $0xc,%esp
f011a458:	50                   	push   %eax
f011a459:	e8 a1 f3 fe ff       	call   f01097ff <kfree>
f011a45e:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a461:	e8 3f a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a466:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a469:	74 17                	je     f011a482 <test_kfree_bestfirstfit+0xcf8>
f011a46b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a472:	83 ec 0c             	sub    $0xc,%esp
f011a475:	68 b4 e0 12 f0       	push   $0xf012e0b4
f011a47a:	e8 0c 6b fe ff       	call   f0100f8b <cprintf>
f011a47f:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a482:	e8 35 45 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a487:	89 c2                	mov    %eax,%edx
f011a489:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a48c:	29 c2                	sub    %eax,%edx
f011a48e:	89 d0                	mov    %edx,%eax
f011a490:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a495:	77 17                	ja     f011a4ae <test_kfree_bestfirstfit+0xd24>
f011a497:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a49e:	83 ec 0c             	sub    $0xc,%esp
f011a4a1:	68 24 e1 12 f0       	push   $0xf012e124
f011a4a6:	e8 e0 6a fe ff       	call   f0100f8b <cprintf>
f011a4ab:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011a4ae:	e8 09 45 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a4b3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a4b6:	e8 ea a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4bb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011a4be:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a4c4:	83 ec 0c             	sub    $0xc,%esp
f011a4c7:	50                   	push   %eax
f011a4c8:	e8 32 f3 fe ff       	call   f01097ff <kfree>
f011a4cd:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4d0:	e8 d0 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a4d5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4d8:	74 17                	je     f011a4f1 <test_kfree_bestfirstfit+0xd67>
f011a4da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4e1:	83 ec 0c             	sub    $0xc,%esp
f011a4e4:	68 60 e1 12 f0       	push   $0xf012e160
f011a4e9:	e8 9d 6a fe ff       	call   f0100f8b <cprintf>
f011a4ee:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a4f1:	e8 c6 44 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a4f6:	89 c2                	mov    %eax,%edx
f011a4f8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a4fb:	29 c2                	sub    %eax,%edx
f011a4fd:	89 d0                	mov    %edx,%eax
f011a4ff:	83 f8 01             	cmp    $0x1,%eax
f011a502:	77 17                	ja     f011a51b <test_kfree_bestfirstfit+0xd91>
f011a504:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a50b:	83 ec 0c             	sub    $0xc,%esp
f011a50e:	68 d0 e1 12 f0       	push   $0xf012e1d0
f011a513:	e8 73 6a fe ff       	call   f0100f8b <cprintf>
f011a518:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011a51b:	e8 9c 44 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a520:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a523:	e8 7d a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a528:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011a52b:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a531:	83 ec 0c             	sub    $0xc,%esp
f011a534:	50                   	push   %eax
f011a535:	e8 c5 f2 fe ff       	call   f01097ff <kfree>
f011a53a:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a53d:	e8 63 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a542:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a545:	74 17                	je     f011a55e <test_kfree_bestfirstfit+0xdd4>
f011a547:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a54e:	83 ec 0c             	sub    $0xc,%esp
f011a551:	68 0c e2 12 f0       	push   $0xf012e20c
f011a556:	e8 30 6a fe ff       	call   f0100f8b <cprintf>
f011a55b:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a55e:	e8 59 44 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a563:	89 c2                	mov    %eax,%edx
f011a565:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a568:	29 c2                	sub    %eax,%edx
f011a56a:	89 d0                	mov    %edx,%eax
f011a56c:	83 f8 03             	cmp    $0x3,%eax
f011a56f:	77 17                	ja     f011a588 <test_kfree_bestfirstfit+0xdfe>
f011a571:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a578:	83 ec 0c             	sub    $0xc,%esp
f011a57b:	68 7c e2 12 f0       	push   $0xf012e27c
f011a580:	e8 06 6a fe ff       	call   f0100f8b <cprintf>
f011a585:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011a588:	e8 2f 44 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a58d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a590:	e8 10 a3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a595:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011a598:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a59e:	83 ec 0c             	sub    $0xc,%esp
f011a5a1:	50                   	push   %eax
f011a5a2:	e8 58 f2 fe ff       	call   f01097ff <kfree>
f011a5a7:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5aa:	e8 f6 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a5af:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a5b2:	74 17                	je     f011a5cb <test_kfree_bestfirstfit+0xe41>
f011a5b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5bb:	83 ec 0c             	sub    $0xc,%esp
f011a5be:	68 b8 e2 12 f0       	push   $0xf012e2b8
f011a5c3:	e8 c3 69 fe ff       	call   f0100f8b <cprintf>
f011a5c8:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a5cb:	e8 ec 43 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a5d0:	89 c2                	mov    %eax,%edx
f011a5d2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a5d5:	29 c2                	sub    %eax,%edx
f011a5d7:	89 d0                	mov    %edx,%eax
f011a5d9:	3d ff 00 00 00       	cmp    $0xff,%eax
f011a5de:	77 17                	ja     f011a5f7 <test_kfree_bestfirstfit+0xe6d>
f011a5e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5e7:	83 ec 0c             	sub    $0xc,%esp
f011a5ea:	68 28 e3 12 f0       	push   $0xf012e328
f011a5ef:	e8 97 69 fe ff       	call   f0100f8b <cprintf>
f011a5f4:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011a5f7:	e8 c0 43 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a5fc:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a5ff:	e8 a1 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a604:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011a607:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a60d:	83 ec 0c             	sub    $0xc,%esp
f011a610:	50                   	push   %eax
f011a611:	e8 e9 f1 fe ff       	call   f01097ff <kfree>
f011a616:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a619:	e8 87 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a61e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a621:	74 17                	je     f011a63a <test_kfree_bestfirstfit+0xeb0>
f011a623:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a62a:	83 ec 0c             	sub    $0xc,%esp
f011a62d:	68 64 e3 12 f0       	push   $0xf012e364
f011a632:	e8 54 69 fe ff       	call   f0100f8b <cprintf>
f011a637:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a63a:	e8 7d 43 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a63f:	89 c2                	mov    %eax,%edx
f011a641:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a644:	29 c2                	sub    %eax,%edx
f011a646:	89 d0                	mov    %edx,%eax
f011a648:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a64d:	77 17                	ja     f011a666 <test_kfree_bestfirstfit+0xedc>
f011a64f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a656:	83 ec 0c             	sub    $0xc,%esp
f011a659:	68 d4 e3 12 f0       	push   $0xf012e3d4
f011a65e:	e8 28 69 fe ff       	call   f0100f8b <cprintf>
f011a663:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011a666:	e8 51 43 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a66b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a66e:	e8 32 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a673:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011a676:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011a67c:	83 ec 0c             	sub    $0xc,%esp
f011a67f:	50                   	push   %eax
f011a680:	e8 7a f1 fe ff       	call   f01097ff <kfree>
f011a685:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a688:	e8 18 a2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a68d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a690:	74 17                	je     f011a6a9 <test_kfree_bestfirstfit+0xf1f>
f011a692:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a699:	83 ec 0c             	sub    $0xc,%esp
f011a69c:	68 10 e4 12 f0       	push   $0xf012e410
f011a6a1:	e8 e5 68 fe ff       	call   f0100f8b <cprintf>
f011a6a6:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a6a9:	e8 0e 43 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a6ae:	89 c2                	mov    %eax,%edx
f011a6b0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a6b3:	39 c2                	cmp    %eax,%edx
f011a6b5:	74 17                	je     f011a6ce <test_kfree_bestfirstfit+0xf44>
f011a6b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6be:	83 ec 0c             	sub    $0xc,%esp
f011a6c1:	68 80 e4 12 f0       	push   $0xf012e480
f011a6c6:	e8 c0 68 fe ff       	call   f0100f8b <cprintf>
f011a6cb:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011a6ce:	e8 e9 42 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a6d3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a6d6:	e8 ca a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a6db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011a6de:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a6e4:	83 ec 0c             	sub    $0xc,%esp
f011a6e7:	50                   	push   %eax
f011a6e8:	e8 12 f1 fe ff       	call   f01097ff <kfree>
f011a6ed:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a6f0:	e8 b0 a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a6f5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a6f8:	74 17                	je     f011a711 <test_kfree_bestfirstfit+0xf87>
f011a6fa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a701:	83 ec 0c             	sub    $0xc,%esp
f011a704:	68 bc e4 12 f0       	push   $0xf012e4bc
f011a709:	e8 7d 68 fe ff       	call   f0100f8b <cprintf>
f011a70e:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a711:	e8 a6 42 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a716:	89 c2                	mov    %eax,%edx
f011a718:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a71b:	39 c2                	cmp    %eax,%edx
f011a71d:	74 17                	je     f011a736 <test_kfree_bestfirstfit+0xfac>
f011a71f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a726:	83 ec 0c             	sub    $0xc,%esp
f011a729:	68 2c e5 12 f0       	push   $0xf012e52c
f011a72e:	e8 58 68 fe ff       	call   f0100f8b <cprintf>
f011a733:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a736:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a73a:	74 04                	je     f011a740 <test_kfree_bestfirstfit+0xfb6>
f011a73c:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a740:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a747:	83 ec 0c             	sub    $0xc,%esp
f011a74a:	68 8c e5 12 f0       	push   $0xf012e58c
f011a74f:	e8 37 68 fe ff       	call   f0100f8b <cprintf>
f011a754:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a757:	83 ec 0c             	sub    $0xc,%esp
f011a75a:	6a 03                	push   $0x3
f011a75c:	e8 84 46 ff ff       	call   f010ede5 <sys_bypassPageFault>
f011a761:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a764:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a76b:	e9 af 00 00 00       	jmp    f011a81f <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a770:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011a774:	0f 84 a1 00 00 00    	je     f011a81b <test_kfree_bestfirstfit+0x1091>
f011a77a:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011a77e:	0f 84 97 00 00 00    	je     f011a81b <test_kfree_bestfirstfit+0x1091>
f011a784:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011a788:	0f 84 8d 00 00 00    	je     f011a81b <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011a78e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a791:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011a798:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011a79b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a79e:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011a7a1:	e8 2d 46 ff ff       	call   f010edd3 <sys_rcr2>
f011a7a6:	89 c2                	mov    %eax,%edx
f011a7a8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a7ab:	39 c2                	cmp    %eax,%edx
f011a7ad:	74 1d                	je     f011a7cc <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011a7af:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a7b3:	74 17                	je     f011a7cc <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a7b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7bc:	83 ec 0c             	sub    $0xc,%esp
f011a7bf:	68 cc e5 12 f0       	push   $0xf012e5cc
f011a7c4:	e8 c2 67 fe ff       	call   f0100f8b <cprintf>
f011a7c9:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011a7cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a7cf:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a7d6:	89 c2                	mov    %eax,%edx
f011a7d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a7db:	01 d0                	add    %edx,%eax
f011a7dd:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011a7e0:	e8 ee 45 ff ff       	call   f010edd3 <sys_rcr2>
f011a7e5:	89 c2                	mov    %eax,%edx
f011a7e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a7ea:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a7f1:	89 c1                	mov    %eax,%ecx
f011a7f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a7f6:	01 c8                	add    %ecx,%eax
f011a7f8:	39 c2                	cmp    %eax,%edx
f011a7fa:	74 20                	je     f011a81c <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011a7fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a800:	74 1a                	je     f011a81c <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a802:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a809:	83 ec 0c             	sub    $0xc,%esp
f011a80c:	68 18 e6 12 f0       	push   $0xf012e618
f011a811:	e8 75 67 fe ff       	call   f0100f8b <cprintf>
f011a816:	83 c4 10             	add    $0x10,%esp
f011a819:	eb 01                	jmp    f011a81c <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a81b:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a81c:	ff 45 f4             	incl   -0xc(%ebp)
f011a81f:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a823:	0f 8e 47 ff ff ff    	jle    f011a770 <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a829:	83 ec 0c             	sub    $0xc,%esp
f011a82c:	6a 00                	push   $0x0
f011a82e:	e8 b2 45 ff ff       	call   f010ede5 <sys_bypassPageFault>
f011a833:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011a836:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a83a:	74 04                	je     f011a840 <test_kfree_bestfirstfit+0x10b6>
f011a83c:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a840:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011a847:	83 ec 0c             	sub    $0xc,%esp
f011a84a:	68 64 e6 12 f0       	push   $0xf012e664
f011a84f:	e8 37 67 fe ff       	call   f0100f8b <cprintf>
f011a854:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a857:	e8 60 41 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a85c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a85f:	e8 41 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a864:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011a867:	83 ec 0c             	sub    $0xc,%esp
f011a86a:	68 00 04 00 00       	push   $0x400
f011a86f:	e8 2b ed fe ff       	call   f010959f <kmalloc>
f011a874:	83 c4 10             	add    $0x10,%esp
f011a877:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011a87d:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011a883:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a889:	39 c2                	cmp    %eax,%edx
f011a88b:	74 17                	je     f011a8a4 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a88d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a894:	83 ec 0c             	sub    $0xc,%esp
f011a897:	68 88 e6 12 f0       	push   $0xf012e688
f011a89c:	e8 ea 66 fe ff       	call   f0100f8b <cprintf>
f011a8a1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a8a4:	e8 fc 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a8a9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a8ac:	74 17                	je     f011a8c5 <test_kfree_bestfirstfit+0x113b>
f011a8ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8b5:	83 ec 0c             	sub    $0xc,%esp
f011a8b8:	68 dc e6 12 f0       	push   $0xf012e6dc
f011a8bd:	e8 c9 66 fe ff       	call   f0100f8b <cprintf>
f011a8c2:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a8c5:	e8 f2 40 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a8ca:	89 c2                	mov    %eax,%edx
f011a8cc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a8cf:	39 c2                	cmp    %eax,%edx
f011a8d1:	74 17                	je     f011a8ea <test_kfree_bestfirstfit+0x1160>
f011a8d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8da:	83 ec 0c             	sub    $0xc,%esp
f011a8dd:	68 4c e7 12 f0       	push   $0xf012e74c
f011a8e2:	e8 a4 66 fe ff       	call   f0100f8b <cprintf>
f011a8e7:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011a8ea:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011a8f1:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a8f7:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a8fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a901:	eb 0e                	jmp    f011a911 <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011a903:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a906:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a909:	01 d0                	add    %edx,%eax
f011a90b:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a90e:	ff 45 f4             	incl   -0xc(%ebp)
f011a911:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a914:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a917:	7f ea                	jg     f011a903 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a919:	e8 9e 40 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a91e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a921:	e8 7f 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a926:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011a929:	83 ec 0c             	sub    $0xc,%esp
f011a92c:	68 00 08 00 00       	push   $0x800
f011a931:	e8 69 ec fe ff       	call   f010959f <kmalloc>
f011a936:	83 c4 10             	add    $0x10,%esp
f011a939:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011a93f:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a945:	05 08 04 00 00       	add    $0x408,%eax
f011a94a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011a94d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a953:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a956:	74 35                	je     f011a98d <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011a958:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011a95f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a965:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a96b:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011a971:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a977:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a97d:	50                   	push   %eax
f011a97e:	51                   	push   %ecx
f011a97f:	52                   	push   %edx
f011a980:	68 c8 e7 12 f0       	push   $0xf012e7c8
f011a985:	e8 01 66 fe ff       	call   f0100f8b <cprintf>
f011a98a:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a98d:	e8 13 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a992:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a995:	74 17                	je     f011a9ae <test_kfree_bestfirstfit+0x1224>
f011a997:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a99e:	83 ec 0c             	sub    $0xc,%esp
f011a9a1:	68 3c e8 12 f0       	push   $0xf012e83c
f011a9a6:	e8 e0 65 fe ff       	call   f0100f8b <cprintf>
f011a9ab:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a9ae:	e8 09 40 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011a9b3:	89 c2                	mov    %eax,%edx
f011a9b5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a9b8:	39 c2                	cmp    %eax,%edx
f011a9ba:	74 17                	je     f011a9d3 <test_kfree_bestfirstfit+0x1249>
f011a9bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9c3:	83 ec 0c             	sub    $0xc,%esp
f011a9c6:	68 ac e8 12 f0       	push   $0xf012e8ac
f011a9cb:	e8 bb 65 fe ff       	call   f0100f8b <cprintf>
f011a9d0:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011a9d3:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011a9da:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a9e0:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a9e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a9ea:	eb 0e                	jmp    f011a9fa <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011a9ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a9ef:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a9f2:	01 d0                	add    %edx,%eax
f011a9f4:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a9f7:	ff 45 f4             	incl   -0xc(%ebp)
f011a9fa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a9fd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aa00:	7f ea                	jg     f011a9ec <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011aa02:	e8 b5 3f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011aa07:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aa0a:	e8 96 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa0f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011aa12:	83 ec 0c             	sub    $0xc,%esp
f011aa15:	68 00 06 00 00       	push   $0x600
f011aa1a:	e8 80 eb fe ff       	call   f010959f <kmalloc>
f011aa1f:	83 c4 10             	add    $0x10,%esp
f011aa22:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011aa28:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011aa2e:	05 10 0c 00 00       	add    $0xc10,%eax
f011aa33:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011aa36:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011aa3c:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011aa3f:	74 17                	je     f011aa58 <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aa41:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa48:	83 ec 0c             	sub    $0xc,%esp
f011aa4b:	68 28 e9 12 f0       	push   $0xf012e928
f011aa50:	e8 36 65 fe ff       	call   f0100f8b <cprintf>
f011aa55:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa58:	e8 48 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa5d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aa60:	74 17                	je     f011aa79 <test_kfree_bestfirstfit+0x12ef>
f011aa62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa69:	83 ec 0c             	sub    $0xc,%esp
f011aa6c:	68 7c e9 12 f0       	push   $0xf012e97c
f011aa71:	e8 15 65 fe ff       	call   f0100f8b <cprintf>
f011aa76:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011aa79:	e8 3e 3f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011aa7e:	89 c2                	mov    %eax,%edx
f011aa80:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011aa83:	39 c2                	cmp    %eax,%edx
f011aa85:	74 17                	je     f011aa9e <test_kfree_bestfirstfit+0x1314>
f011aa87:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa8e:	83 ec 0c             	sub    $0xc,%esp
f011aa91:	68 ec e9 12 f0       	push   $0xf012e9ec
f011aa96:	e8 f0 64 fe ff       	call   f0100f8b <cprintf>
f011aa9b:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011aa9e:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011aaa5:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011aaab:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011aaae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aab5:	eb 0e                	jmp    f011aac5 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011aab7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aaba:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aabd:	01 d0                	add    %edx,%eax
f011aabf:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011aac2:	ff 45 f4             	incl   -0xc(%ebp)
f011aac5:	8b 45 98             	mov    -0x68(%ebp),%eax
f011aac8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aacb:	7f ea                	jg     f011aab7 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011aacd:	e8 ea 3e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011aad2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aad5:	e8 cb 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aada:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011aadd:	83 ec 0c             	sub    $0xc,%esp
f011aae0:	68 00 00 e0 01       	push   $0x1e00000
f011aae5:	e8 b5 ea fe ff       	call   f010959f <kmalloc>
f011aaea:	83 c4 10             	add    $0x10,%esp
f011aaed:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aaf3:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aaf9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011aafe:	74 17                	je     f011ab17 <test_kfree_bestfirstfit+0x138d>
f011ab00:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab07:	83 ec 0c             	sub    $0xc,%esp
f011ab0a:	68 68 ea 12 f0       	push   $0xf012ea68
f011ab0f:	e8 77 64 fe ff       	call   f0100f8b <cprintf>
f011ab14:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab17:	e8 89 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab1c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ab1f:	74 17                	je     f011ab38 <test_kfree_bestfirstfit+0x13ae>
f011ab21:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab28:	83 ec 0c             	sub    $0xc,%esp
f011ab2b:	68 bc ea 12 f0       	push   $0xf012eabc
f011ab30:	e8 56 64 fe ff       	call   f0100f8b <cprintf>
f011ab35:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ab38:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ab3b:	e8 7c 3e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011ab40:	29 c3                	sub    %eax,%ebx
f011ab42:	89 d8                	mov    %ebx,%eax
f011ab44:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011ab49:	77 17                	ja     f011ab62 <test_kfree_bestfirstfit+0x13d8>
f011ab4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab52:	83 ec 0c             	sub    $0xc,%esp
f011ab55:	68 2c eb 12 f0       	push   $0xf012eb2c
f011ab5a:	e8 2c 64 fe ff       	call   f0100f8b <cprintf>
f011ab5f:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011ab62:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011ab69:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ab6f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011ab72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab79:	eb 0e                	jmp    f011ab89 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011ab7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ab7e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab81:	01 d0                	add    %edx,%eax
f011ab83:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011ab86:	ff 45 f4             	incl   -0xc(%ebp)
f011ab89:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ab8c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab8f:	7f ea                	jg     f011ab7b <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011ab91:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ab97:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011ab9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aba1:	eb 1e                	jmp    f011abc1 <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011aba3:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011aba9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011abac:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011abaf:	01 c8                	add    %ecx,%eax
f011abb1:	8a 00                	mov    (%eax),%al
f011abb3:	0f be c0             	movsbl %al,%eax
f011abb6:	01 d0                	add    %edx,%eax
f011abb8:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011abbe:	ff 45 f4             	incl   -0xc(%ebp)
f011abc1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011abc4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abc7:	7f da                	jg     f011aba3 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011abc9:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011abcf:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011abd2:	89 d0                	mov    %edx,%eax
f011abd4:	c1 e0 02             	shl    $0x2,%eax
f011abd7:	01 d0                	add    %edx,%eax
f011abd9:	01 c0                	add    %eax,%eax
f011abdb:	39 c1                	cmp    %eax,%ecx
f011abdd:	74 17                	je     f011abf6 <test_kfree_bestfirstfit+0x146c>
f011abdf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abe6:	83 ec 0c             	sub    $0xc,%esp
f011abe9:	68 74 eb 12 f0       	push   $0xf012eb74
f011abee:	e8 98 63 fe ff       	call   f0100f8b <cprintf>
f011abf3:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011abf6:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011abfc:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011abff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac06:	eb 1e                	jmp    f011ac26 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011ac08:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011ac0e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ac11:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac14:	01 c8                	add    %ecx,%eax
f011ac16:	8a 00                	mov    (%eax),%al
f011ac18:	0f be c0             	movsbl %al,%eax
f011ac1b:	01 d0                	add    %edx,%eax
f011ac1d:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011ac23:	ff 45 f4             	incl   -0xc(%ebp)
f011ac26:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ac29:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac2c:	7f da                	jg     f011ac08 <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011ac2e:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011ac34:	8b 55 90             	mov    -0x70(%ebp),%edx
f011ac37:	89 d0                	mov    %edx,%eax
f011ac39:	c1 e0 02             	shl    $0x2,%eax
f011ac3c:	01 d0                	add    %edx,%eax
f011ac3e:	01 c0                	add    %eax,%eax
f011ac40:	01 d0                	add    %edx,%eax
f011ac42:	39 c1                	cmp    %eax,%ecx
f011ac44:	74 17                	je     f011ac5d <test_kfree_bestfirstfit+0x14d3>
f011ac46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac4d:	83 ec 0c             	sub    $0xc,%esp
f011ac50:	68 a4 eb 12 f0       	push   $0xf012eba4
f011ac55:	e8 31 63 fe ff       	call   f0100f8b <cprintf>
f011ac5a:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011ac5d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011ac63:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011ac66:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac6d:	eb 1e                	jmp    f011ac8d <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011ac6f:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011ac75:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ac78:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac7b:	01 c8                	add    %ecx,%eax
f011ac7d:	8a 00                	mov    (%eax),%al
f011ac7f:	0f be c0             	movsbl %al,%eax
f011ac82:	01 d0                	add    %edx,%eax
f011ac84:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011ac8a:	ff 45 f4             	incl   -0xc(%ebp)
f011ac8d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011ac90:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac93:	7f da                	jg     f011ac6f <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011ac95:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011ac9b:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011ac9e:	89 d0                	mov    %edx,%eax
f011aca0:	01 c0                	add    %eax,%eax
f011aca2:	01 d0                	add    %edx,%eax
f011aca4:	c1 e0 02             	shl    $0x2,%eax
f011aca7:	39 c1                	cmp    %eax,%ecx
f011aca9:	74 17                	je     f011acc2 <test_kfree_bestfirstfit+0x1538>
f011acab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acb2:	83 ec 0c             	sub    $0xc,%esp
f011acb5:	68 d4 eb 12 f0       	push   $0xf012ebd4
f011acba:	e8 cc 62 fe ff       	call   f0100f8b <cprintf>
f011acbf:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011acc2:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011acc8:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011accb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011acd2:	eb 1e                	jmp    f011acf2 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011acd4:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011acda:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011acdd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ace0:	01 c8                	add    %ecx,%eax
f011ace2:	8a 00                	mov    (%eax),%al
f011ace4:	0f be c0             	movsbl %al,%eax
f011ace7:	01 d0                	add    %edx,%eax
f011ace9:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011acef:	ff 45 f4             	incl   -0xc(%ebp)
f011acf2:	8b 45 98             	mov    -0x68(%ebp),%eax
f011acf5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011acf8:	7f da                	jg     f011acd4 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011acfa:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011ad00:	8b 55 98             	mov    -0x68(%ebp),%edx
f011ad03:	89 d0                	mov    %edx,%eax
f011ad05:	01 c0                	add    %eax,%eax
f011ad07:	01 d0                	add    %edx,%eax
f011ad09:	c1 e0 02             	shl    $0x2,%eax
f011ad0c:	01 d0                	add    %edx,%eax
f011ad0e:	39 c1                	cmp    %eax,%ecx
f011ad10:	74 17                	je     f011ad29 <test_kfree_bestfirstfit+0x159f>
f011ad12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad19:	83 ec 0c             	sub    $0xc,%esp
f011ad1c:	68 04 ec 12 f0       	push   $0xf012ec04
f011ad21:	e8 65 62 fe ff       	call   f0100f8b <cprintf>
f011ad26:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011ad29:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ad2d:	74 04                	je     f011ad33 <test_kfree_bestfirstfit+0x15a9>
f011ad2f:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011ad33:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011ad3a:	83 ec 0c             	sub    $0xc,%esp
f011ad3d:	68 31 ec 12 f0       	push   $0xf012ec31
f011ad42:	e8 44 62 fe ff       	call   f0100f8b <cprintf>
f011ad47:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011ad4a:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011ad51:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011ad58:	eb 4e                	jmp    f011ada8 <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011ad5a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011ad5d:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011ad62:	83 ec 04             	sub    $0x4,%esp
f011ad65:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011ad6b:	51                   	push   %ecx
f011ad6c:	52                   	push   %edx
f011ad6d:	50                   	push   %eax
f011ad6e:	e8 7c d6 fe ff       	call   f01083ef <get_page_table>
f011ad73:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ad76:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011ad7c:	85 c0                	test   %eax,%eax
f011ad7e:	75 1d                	jne    f011ad9d <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011ad80:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ad84:	74 17                	je     f011ad9d <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011ad86:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad8d:	83 ec 0c             	sub    $0xc,%esp
f011ad90:	68 50 ec 12 f0       	push   $0xf012ec50
f011ad95:	e8 f1 61 fe ff       	call   f0100f8b <cprintf>
f011ad9a:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011ad9d:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011ada4:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011ada8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011adac:	78 ac                	js     f011ad5a <test_kfree_bestfirstfit+0x15d0>
f011adae:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011adb2:	7f 09                	jg     f011adbd <test_kfree_bestfirstfit+0x1633>
f011adb4:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011adbb:	76 9d                	jbe    f011ad5a <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011adbd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011adc1:	74 04                	je     f011adc7 <test_kfree_bestfirstfit+0x163d>
f011adc3:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011adc7:	83 ec 08             	sub    $0x8,%esp
f011adca:	ff 75 f0             	pushl  -0x10(%ebp)
f011adcd:	68 b8 ec 12 f0       	push   $0xf012ecb8
f011add2:	e8 b4 61 fe ff       	call   f0100f8b <cprintf>
f011add7:	83 c4 10             	add    $0x10,%esp

	return 1;
f011adda:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011addf:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011ade2:	5b                   	pop    %ebx
f011ade3:	5f                   	pop    %edi
f011ade4:	5d                   	pop    %ebp
f011ade5:	c3                   	ret    

f011ade6 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011ade6:	55                   	push   %ebp
f011ade7:	89 e5                	mov    %esp,%ebp
f011ade9:	57                   	push   %edi
f011adea:	53                   	push   %ebx
f011adeb:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011adf1:	83 ec 0c             	sub    $0xc,%esp
f011adf4:	68 88 af 12 f0       	push   $0xf012af88
f011adf9:	e8 8d 61 fe ff       	call   f0100f8b <cprintf>
f011adfe:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011ae01:	83 ec 0c             	sub    $0xc,%esp
f011ae04:	68 b8 af 12 f0       	push   $0xf012afb8
f011ae09:	e8 7d 61 fe ff       	call   f0100f8b <cprintf>
f011ae0e:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011ae11:	83 ec 0c             	sub    $0xc,%esp
f011ae14:	68 88 af 12 f0       	push   $0xf012af88
f011ae19:	e8 6d 61 fe ff       	call   f0100f8b <cprintf>
f011ae1e:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011ae21:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011ae25:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011ae29:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011ae2f:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011ae35:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011ae3c:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011ae43:	e8 74 3b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011ae48:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011ae4b:	83 ec 0c             	sub    $0xc,%esp
f011ae4e:	68 dc ec 12 f0       	push   $0xf012ecdc
f011ae53:	e8 33 61 fe ff       	call   f0100f8b <cprintf>
f011ae58:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011ae5b:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011ae61:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ae66:	b8 00 00 00 00       	mov    $0x0,%eax
f011ae6b:	89 d7                	mov    %edx,%edi
f011ae6d:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011ae6f:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011ae75:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ae7a:	b8 00 00 00 00       	mov    $0x0,%eax
f011ae7f:	89 d7                	mov    %edx,%edi
f011ae81:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011ae83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011ae8a:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011ae91:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011ae97:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ae9c:	b8 00 00 00 00       	mov    $0x0,%eax
f011aea1:	89 d7                	mov    %edx,%edi
f011aea3:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011aea5:	e8 12 3b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011aeaa:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aead:	e8 f3 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aeb2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011aeb5:	83 ec 0c             	sub    $0xc,%esp
f011aeb8:	68 00 fc 1f 00       	push   $0x1ffc00
f011aebd:	e8 dd e6 fe ff       	call   f010959f <kmalloc>
f011aec2:	83 c4 10             	add    $0x10,%esp
f011aec5:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aecb:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011aed1:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011aed6:	74 17                	je     f011aeef <test_kheap_phys_addr+0x109>
f011aed8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aedf:	83 ec 0c             	sub    $0xc,%esp
f011aee2:	68 80 d0 12 f0       	push   $0xf012d080
f011aee7:	e8 9f 60 fe ff       	call   f0100f8b <cprintf>
f011aeec:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aeef:	e8 b1 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aef4:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aef7:	74 17                	je     f011af10 <test_kheap_phys_addr+0x12a>
f011aef9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af00:	83 ec 0c             	sub    $0xc,%esp
f011af03:	68 d4 d0 12 f0       	push   $0xf012d0d4
f011af08:	e8 7e 60 fe ff       	call   f0100f8b <cprintf>
f011af0d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011af10:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011af13:	e8 a4 3a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011af18:	29 c3                	sub    %eax,%ebx
f011af1a:	89 d8                	mov    %ebx,%eax
f011af1c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011af21:	77 17                	ja     f011af3a <test_kheap_phys_addr+0x154>
f011af23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af2a:	83 ec 0c             	sub    $0xc,%esp
f011af2d:	68 44 d1 12 f0       	push   $0xf012d144
f011af32:	e8 54 60 fe ff       	call   f0100f8b <cprintf>
f011af37:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011af3a:	e8 7d 3a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011af3f:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011af42:	e8 5e 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af47:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011af4a:	83 ec 0c             	sub    $0xc,%esp
f011af4d:	68 00 fc 1f 00       	push   $0x1ffc00
f011af52:	e8 48 e6 fe ff       	call   f010959f <kmalloc>
f011af57:	83 c4 10             	add    $0x10,%esp
f011af5a:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011af60:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011af66:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011af6b:	74 17                	je     f011af84 <test_kheap_phys_addr+0x19e>
f011af6d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af74:	83 ec 0c             	sub    $0xc,%esp
f011af77:	68 8c d1 12 f0       	push   $0xf012d18c
f011af7c:	e8 0a 60 fe ff       	call   f0100f8b <cprintf>
f011af81:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af84:	e8 1c 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af89:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011af8c:	74 17                	je     f011afa5 <test_kheap_phys_addr+0x1bf>
f011af8e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af95:	83 ec 0c             	sub    $0xc,%esp
f011af98:	68 e0 d1 12 f0       	push   $0xf012d1e0
f011af9d:	e8 e9 5f fe ff       	call   f0100f8b <cprintf>
f011afa2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011afa5:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011afa8:	e8 0f 3a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011afad:	29 c3                	sub    %eax,%ebx
f011afaf:	89 d8                	mov    %ebx,%eax
f011afb1:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011afb6:	77 17                	ja     f011afcf <test_kheap_phys_addr+0x1e9>
f011afb8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afbf:	83 ec 0c             	sub    $0xc,%esp
f011afc2:	68 50 d2 12 f0       	push   $0xf012d250
f011afc7:	e8 bf 5f fe ff       	call   f0100f8b <cprintf>
f011afcc:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011afcf:	e8 e8 39 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011afd4:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011afd7:	e8 c9 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011afdc:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011afdf:	83 ec 0c             	sub    $0xc,%esp
f011afe2:	68 00 04 00 00       	push   $0x400
f011afe7:	e8 b3 e5 fe ff       	call   f010959f <kmalloc>
f011afec:	83 c4 10             	add    $0x10,%esp
f011afef:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011aff5:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011affb:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b000:	76 28                	jbe    f011b02a <test_kheap_phys_addr+0x244>
f011b002:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011b008:	83 ec 0c             	sub    $0xc,%esp
f011b00b:	6a 00                	push   $0x0
f011b00d:	e8 5a e4 fe ff       	call   f010946c <sbrk>
f011b012:	83 c4 10             	add    $0x10,%esp
f011b015:	39 c3                	cmp    %eax,%ebx
f011b017:	73 11                	jae    f011b02a <test_kheap_phys_addr+0x244>
f011b019:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b01f:	89 c2                	mov    %eax,%edx
f011b021:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b026:	39 c2                	cmp    %eax,%edx
f011b028:	72 17                	jb     f011b041 <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b02a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b031:	83 ec 0c             	sub    $0xc,%esp
f011b034:	68 0c ed 12 f0       	push   $0xf012ed0c
f011b039:	e8 4d 5f fe ff       	call   f0100f8b <cprintf>
f011b03e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b041:	e8 5f 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b046:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b049:	74 17                	je     f011b062 <test_kheap_phys_addr+0x27c>
f011b04b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b052:	83 ec 0c             	sub    $0xc,%esp
f011b055:	68 ec d2 12 f0       	push   $0xf012d2ec
f011b05a:	e8 2c 5f fe ff       	call   f0100f8b <cprintf>
f011b05f:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b062:	e8 55 39 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b067:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b06a:	e8 36 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b06f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b072:	83 ec 0c             	sub    $0xc,%esp
f011b075:	68 00 08 00 00       	push   $0x800
f011b07a:	e8 20 e5 fe ff       	call   f010959f <kmalloc>
f011b07f:	83 c4 10             	add    $0x10,%esp
f011b082:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b088:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b08e:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b093:	76 28                	jbe    f011b0bd <test_kheap_phys_addr+0x2d7>
f011b095:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b09b:	83 ec 0c             	sub    $0xc,%esp
f011b09e:	6a 00                	push   $0x0
f011b0a0:	e8 c7 e3 fe ff       	call   f010946c <sbrk>
f011b0a5:	83 c4 10             	add    $0x10,%esp
f011b0a8:	39 c3                	cmp    %eax,%ebx
f011b0aa:	73 11                	jae    f011b0bd <test_kheap_phys_addr+0x2d7>
f011b0ac:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b0b2:	89 c2                	mov    %eax,%edx
f011b0b4:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b0b9:	39 c2                	cmp    %eax,%edx
f011b0bb:	72 17                	jb     f011b0d4 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b0bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0c4:	83 ec 0c             	sub    $0xc,%esp
f011b0c7:	68 98 ed 12 f0       	push   $0xf012ed98
f011b0cc:	e8 ba 5e fe ff       	call   f0100f8b <cprintf>
f011b0d1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b0d4:	e8 cc 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b0d9:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b0dc:	74 17                	je     f011b0f5 <test_kheap_phys_addr+0x30f>
f011b0de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0e5:	83 ec 0c             	sub    $0xc,%esp
f011b0e8:	68 f8 d3 12 f0       	push   $0xf012d3f8
f011b0ed:	e8 99 5e fe ff       	call   f0100f8b <cprintf>
f011b0f2:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b0f5:	e8 c2 38 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b0fa:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b0fd:	e8 a3 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b102:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b105:	83 ec 0c             	sub    $0xc,%esp
f011b108:	68 00 06 00 00       	push   $0x600
f011b10d:	e8 8d e4 fe ff       	call   f010959f <kmalloc>
f011b112:	83 c4 10             	add    $0x10,%esp
f011b115:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b11b:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b121:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b126:	76 28                	jbe    f011b150 <test_kheap_phys_addr+0x36a>
f011b128:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011b12e:	83 ec 0c             	sub    $0xc,%esp
f011b131:	6a 00                	push   $0x0
f011b133:	e8 34 e3 fe ff       	call   f010946c <sbrk>
f011b138:	83 c4 10             	add    $0x10,%esp
f011b13b:	39 c3                	cmp    %eax,%ebx
f011b13d:	73 11                	jae    f011b150 <test_kheap_phys_addr+0x36a>
f011b13f:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b145:	89 c2                	mov    %eax,%edx
f011b147:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b14c:	39 c2                	cmp    %eax,%edx
f011b14e:	72 17                	jb     f011b167 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b150:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b157:	83 ec 0c             	sub    $0xc,%esp
f011b15a:	68 24 ee 12 f0       	push   $0xf012ee24
f011b15f:	e8 27 5e fe ff       	call   f0100f8b <cprintf>
f011b164:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b167:	e8 39 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b16c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b16f:	74 17                	je     f011b188 <test_kheap_phys_addr+0x3a2>
f011b171:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b178:	83 ec 0c             	sub    $0xc,%esp
f011b17b:	68 04 d5 12 f0       	push   $0xf012d504
f011b180:	e8 06 5e fe ff       	call   f0100f8b <cprintf>
f011b185:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b188:	e8 2f 38 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b18d:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b190:	e8 10 97 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b195:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b198:	83 ec 0c             	sub    $0xc,%esp
f011b19b:	68 00 1c 00 00       	push   $0x1c00
f011b1a0:	e8 fa e3 fe ff       	call   f010959f <kmalloc>
f011b1a5:	83 c4 10             	add    $0x10,%esp
f011b1a8:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b1ae:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b1b4:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b1b9:	74 17                	je     f011b1d2 <test_kheap_phys_addr+0x3ec>
f011b1bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1c2:	83 ec 0c             	sub    $0xc,%esp
f011b1c5:	68 bc d5 12 f0       	push   $0xf012d5bc
f011b1ca:	e8 bc 5d fe ff       	call   f0100f8b <cprintf>
f011b1cf:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b1d2:	e8 ce 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b1d7:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b1da:	74 17                	je     f011b1f3 <test_kheap_phys_addr+0x40d>
f011b1dc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1e3:	83 ec 0c             	sub    $0xc,%esp
f011b1e6:	68 10 d6 12 f0       	push   $0xf012d610
f011b1eb:	e8 9b 5d fe ff       	call   f0100f8b <cprintf>
f011b1f0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b1f3:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b1f6:	e8 c1 37 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b1fb:	29 c3                	sub    %eax,%ebx
f011b1fd:	89 d8                	mov    %ebx,%eax
f011b1ff:	83 f8 01             	cmp    $0x1,%eax
f011b202:	77 17                	ja     f011b21b <test_kheap_phys_addr+0x435>
f011b204:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b20b:	83 ec 0c             	sub    $0xc,%esp
f011b20e:	68 80 d6 12 f0       	push   $0xf012d680
f011b213:	e8 73 5d fe ff       	call   f0100f8b <cprintf>
f011b218:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b21b:	e8 9c 37 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b220:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b223:	e8 7d 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b228:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b22b:	83 ec 0c             	sub    $0xc,%esp
f011b22e:	68 00 fc 2f 00       	push   $0x2ffc00
f011b233:	e8 67 e3 fe ff       	call   f010959f <kmalloc>
f011b238:	83 c4 10             	add    $0x10,%esp
f011b23b:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b241:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b247:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b24c:	74 17                	je     f011b265 <test_kheap_phys_addr+0x47f>
f011b24e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b255:	83 ec 0c             	sub    $0xc,%esp
f011b258:	68 b0 ee 12 f0       	push   $0xf012eeb0
f011b25d:	e8 29 5d fe ff       	call   f0100f8b <cprintf>
f011b262:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b265:	e8 3b 96 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b26a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b26d:	74 17                	je     f011b286 <test_kheap_phys_addr+0x4a0>
f011b26f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b276:	83 ec 0c             	sub    $0xc,%esp
f011b279:	68 54 d7 12 f0       	push   $0xf012d754
f011b27e:	e8 08 5d fe ff       	call   f0100f8b <cprintf>
f011b283:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b286:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b289:	e8 2e 37 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b28e:	29 c3                	sub    %eax,%ebx
f011b290:	89 d8                	mov    %ebx,%eax
f011b292:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b297:	77 17                	ja     f011b2b0 <test_kheap_phys_addr+0x4ca>
f011b299:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2a0:	83 ec 0c             	sub    $0xc,%esp
f011b2a3:	68 04 ef 12 f0       	push   $0xf012ef04
f011b2a8:	e8 de 5c fe ff       	call   f0100f8b <cprintf>
f011b2ad:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b2b0:	e8 07 37 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b2b5:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b2b8:	e8 e8 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b2bd:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b2c0:	83 ec 0c             	sub    $0xc,%esp
f011b2c3:	68 00 fc 5f 00       	push   $0x5ffc00
f011b2c8:	e8 d2 e2 fe ff       	call   f010959f <kmalloc>
f011b2cd:	83 c4 10             	add    $0x10,%esp
f011b2d0:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b2d6:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b2dc:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b2e1:	74 17                	je     f011b2fa <test_kheap_phys_addr+0x514>
f011b2e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2ea:	83 ec 0c             	sub    $0xc,%esp
f011b2ed:	68 4c ef 12 f0       	push   $0xf012ef4c
f011b2f2:	e8 94 5c fe ff       	call   f0100f8b <cprintf>
f011b2f7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2fa:	e8 a6 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b2ff:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b302:	74 17                	je     f011b31b <test_kheap_phys_addr+0x535>
f011b304:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b30b:	83 ec 0c             	sub    $0xc,%esp
f011b30e:	68 50 d8 12 f0       	push   $0xf012d850
f011b313:	e8 73 5c fe ff       	call   f0100f8b <cprintf>
f011b318:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b31b:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b31e:	e8 99 36 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b323:	29 c3                	sub    %eax,%ebx
f011b325:	89 d8                	mov    %ebx,%eax
f011b327:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b32c:	77 17                	ja     f011b345 <test_kheap_phys_addr+0x55f>
f011b32e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b335:	83 ec 0c             	sub    $0xc,%esp
f011b338:	68 a0 ef 12 f0       	push   $0xf012efa0
f011b33d:	e8 49 5c fe ff       	call   f0100f8b <cprintf>
f011b342:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b345:	e8 72 36 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b34a:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b34d:	e8 53 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b352:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b355:	83 ec 0c             	sub    $0xc,%esp
f011b358:	68 00 38 00 00       	push   $0x3800
f011b35d:	e8 3d e2 fe ff       	call   f010959f <kmalloc>
f011b362:	83 c4 10             	add    $0x10,%esp
f011b365:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b36b:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011b371:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b376:	74 17                	je     f011b38f <test_kheap_phys_addr+0x5a9>
f011b378:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b37f:	83 ec 0c             	sub    $0xc,%esp
f011b382:	68 e8 ef 12 f0       	push   $0xf012efe8
f011b387:	e8 ff 5b fe ff       	call   f0100f8b <cprintf>
f011b38c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b38f:	e8 11 95 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b394:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b397:	74 17                	je     f011b3b0 <test_kheap_phys_addr+0x5ca>
f011b399:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3a0:	83 ec 0c             	sub    $0xc,%esp
f011b3a3:	68 3c f0 12 f0       	push   $0xf012f03c
f011b3a8:	e8 de 5b fe ff       	call   f0100f8b <cprintf>
f011b3ad:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b3b0:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b3b3:	e8 04 36 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b3b8:	29 c3                	sub    %eax,%ebx
f011b3ba:	89 d8                	mov    %ebx,%eax
f011b3bc:	83 f8 03             	cmp    $0x3,%eax
f011b3bf:	77 17                	ja     f011b3d8 <test_kheap_phys_addr+0x5f2>
f011b3c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3c8:	83 ec 0c             	sub    $0xc,%esp
f011b3cb:	68 ac f0 12 f0       	push   $0xf012f0ac
f011b3d0:	e8 b6 5b fe ff       	call   f0100f8b <cprintf>
f011b3d5:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011b3d8:	83 ec 0c             	sub    $0xc,%esp
f011b3db:	68 f4 f0 12 f0       	push   $0xf012f0f4
f011b3e0:	e8 a6 5b fe ff       	call   f0100f8b <cprintf>
f011b3e5:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b3e8:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b3ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011b3f6:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b3fd:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011b402:	05 00 10 00 00       	add    $0x1000,%eax
f011b407:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b40a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b40d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b410:	eb 2e                	jmp    f011b440 <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b412:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b415:	8d 43 01             	lea    0x1(%ebx),%eax
f011b418:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b41b:	83 ec 0c             	sub    $0xc,%esp
f011b41e:	ff 75 e8             	pushl  -0x18(%ebp)
f011b421:	e8 bf e4 fe ff       	call   f01098e5 <kheap_physical_address>
f011b426:	83 c4 10             	add    $0x10,%esp
f011b429:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011b430:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b433:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b436:	01 d0                	add    %edx,%eax
f011b438:	05 00 10 00 00       	add    $0x1000,%eax
f011b43d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b440:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b443:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b446:	72 ca                	jb     f011b412 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b448:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b44b:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011b44e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b455:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b458:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011b45b:	e9 ce 00 00 00       	jmp    f011b52e <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b460:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b465:	83 ec 04             	sub    $0x4,%esp
f011b468:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b46e:	52                   	push   %edx
f011b46f:	ff 75 e8             	pushl  -0x18(%ebp)
f011b472:	50                   	push   %eax
f011b473:	e8 77 cf fe ff       	call   f01083ef <get_page_table>
f011b478:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b47b:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b481:	85 c0                	test   %eax,%eax
f011b483:	75 1e                	jne    f011b4a3 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b485:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b48c:	83 ec 04             	sub    $0x4,%esp
f011b48f:	68 40 f1 12 f0       	push   $0xf012f140
f011b494:	68 e7 05 00 00       	push   $0x5e7
f011b499:	68 d3 ce 12 f0       	push   $0xf012ced3
f011b49e:	e8 96 4e fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b4a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b4a6:	c1 e8 0c             	shr    $0xc,%eax
f011b4a9:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b4ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011b4b1:	eb 62                	jmp    f011b515 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011b4b3:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b4b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b4bc:	c1 e2 02             	shl    $0x2,%edx
f011b4bf:	01 d0                	add    %edx,%eax
f011b4c1:	8b 00                	mov    (%eax),%eax
f011b4c3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b4c8:	89 c2                	mov    %eax,%edx
f011b4ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b4cd:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b4d2:	01 c2                	add    %eax,%edx
f011b4d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b4d7:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b4de:	39 c2                	cmp    %eax,%edx
f011b4e0:	74 1d                	je     f011b4ff <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b4e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b4e6:	74 17                	je     f011b4ff <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011b4e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4ef:	83 ec 0c             	sub    $0xc,%esp
f011b4f2:	68 a0 f1 12 f0       	push   $0xf012f1a0
f011b4f7:	e8 8f 5a fe ff       	call   f0100f8b <cprintf>
f011b4fc:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011b4ff:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b502:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b505:	01 d0                	add    %edx,%eax
f011b507:	05 00 10 00 00       	add    $0x1000,%eax
f011b50c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b50f:	ff 45 e4             	incl   -0x1c(%ebp)
f011b512:	ff 45 f4             	incl   -0xc(%ebp)
f011b515:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b518:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011b51b:	7d 11                	jge    f011b52e <test_kheap_phys_addr+0x748>
f011b51d:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011b524:	7f 08                	jg     f011b52e <test_kheap_phys_addr+0x748>
f011b526:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b529:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b52c:	72 85                	jb     f011b4b3 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b52e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011b531:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011b534:	0f 82 26 ff ff ff    	jb     f011b460 <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011b53a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b53e:	74 04                	je     f011b544 <test_kheap_phys_addr+0x75e>
f011b540:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b544:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011b54b:	83 ec 0c             	sub    $0xc,%esp
f011b54e:	68 c4 f1 12 f0       	push   $0xf012f1c4
f011b553:	e8 33 5a fe ff       	call   f0100f8b <cprintf>
f011b558:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b55b:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011b562:	e9 b0 00 00 00       	jmp    f011b617 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011b567:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011b56a:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011b571:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011b574:	83 ec 0c             	sub    $0xc,%esp
f011b577:	ff 75 90             	pushl  -0x70(%ebp)
f011b57a:	e8 66 e3 fe ff       	call   f01098e5 <kheap_physical_address>
f011b57f:	83 c4 10             	add    $0x10,%esp
f011b582:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b585:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b58a:	83 ec 04             	sub    $0x4,%esp
f011b58d:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b593:	52                   	push   %edx
f011b594:	ff 75 90             	pushl  -0x70(%ebp)
f011b597:	50                   	push   %eax
f011b598:	e8 52 ce fe ff       	call   f01083ef <get_page_table>
f011b59d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b5a0:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b5a6:	85 c0                	test   %eax,%eax
f011b5a8:	75 1e                	jne    f011b5c8 <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b5aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5b1:	83 ec 04             	sub    $0x4,%esp
f011b5b4:	68 14 f2 12 f0       	push   $0xf012f214
f011b5b9:	68 04 06 00 00       	push   $0x604
f011b5be:	68 d3 ce 12 f0       	push   $0xf012ced3
f011b5c3:	e8 71 4d fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b5c8:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b5ce:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b5d1:	c1 ea 0c             	shr    $0xc,%edx
f011b5d4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b5da:	c1 e2 02             	shl    $0x2,%edx
f011b5dd:	01 d0                	add    %edx,%eax
f011b5df:	8b 00                	mov    (%eax),%eax
f011b5e1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b5e6:	89 c2                	mov    %eax,%edx
f011b5e8:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b5eb:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b5f0:	01 d0                	add    %edx,%eax
f011b5f2:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b5f5:	74 1d                	je     f011b614 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b5f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b5fb:	74 17                	je     f011b614 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011b5fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b604:	83 ec 0c             	sub    $0xc,%esp
f011b607:	68 74 f2 12 f0       	push   $0xf012f274
f011b60c:	e8 7a 59 fe ff       	call   f0100f8b <cprintf>
f011b611:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011b614:	ff 45 e0             	incl   -0x20(%ebp)
f011b617:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011b61b:	0f 8e 46 ff ff ff    	jle    f011b567 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011b621:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b625:	74 04                	je     f011b62b <test_kheap_phys_addr+0x845>
f011b627:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011b62b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011b632:	83 ec 0c             	sub    $0xc,%esp
f011b635:	68 98 f2 12 f0       	push   $0xf012f298
f011b63a:	e8 4c 59 fe ff       	call   f0100f8b <cprintf>
f011b63f:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b642:	e8 75 33 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b647:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b64a:	e8 56 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b64f:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b652:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b658:	83 ec 0c             	sub    $0xc,%esp
f011b65b:	50                   	push   %eax
f011b65c:	e8 9e e1 fe ff       	call   f01097ff <kfree>
f011b661:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b664:	e8 3c 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b669:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b66c:	74 17                	je     f011b685 <test_kheap_phys_addr+0x89f>
f011b66e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b675:	83 ec 0c             	sub    $0xc,%esp
f011b678:	68 84 dd 12 f0       	push   $0xf012dd84
f011b67d:	e8 09 59 fe ff       	call   f0100f8b <cprintf>
f011b682:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b685:	e8 32 33 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b68a:	89 c2                	mov    %eax,%edx
f011b68c:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b68f:	29 c2                	sub    %eax,%edx
f011b691:	89 d0                	mov    %edx,%eax
f011b693:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b698:	77 17                	ja     f011b6b1 <test_kheap_phys_addr+0x8cb>
f011b69a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6a1:	83 ec 0c             	sub    $0xc,%esp
f011b6a4:	68 c0 f2 12 f0       	push   $0xf012f2c0
f011b6a9:	e8 dd 58 fe ff       	call   f0100f8b <cprintf>
f011b6ae:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b6b1:	e8 06 33 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b6b6:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b6b9:	e8 e7 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6be:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b6c1:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b6c7:	83 ec 0c             	sub    $0xc,%esp
f011b6ca:	50                   	push   %eax
f011b6cb:	e8 2f e1 fe ff       	call   f01097ff <kfree>
f011b6d0:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b6d3:	e8 cd 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6d8:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b6db:	74 17                	je     f011b6f4 <test_kheap_phys_addr+0x90e>
f011b6dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6e4:	83 ec 0c             	sub    $0xc,%esp
f011b6e7:	68 c4 de 12 f0       	push   $0xf012dec4
f011b6ec:	e8 9a 58 fe ff       	call   f0100f8b <cprintf>
f011b6f1:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b6f4:	e8 c3 32 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b6f9:	89 c2                	mov    %eax,%edx
f011b6fb:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b6fe:	29 c2                	sub    %eax,%edx
f011b700:	89 d0                	mov    %edx,%eax
f011b702:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b707:	77 17                	ja     f011b720 <test_kheap_phys_addr+0x93a>
f011b709:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b710:	83 ec 0c             	sub    $0xc,%esp
f011b713:	68 fc f2 12 f0       	push   $0xf012f2fc
f011b718:	e8 6e 58 fe ff       	call   f0100f8b <cprintf>
f011b71d:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b720:	e8 97 32 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b725:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b728:	e8 78 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b72d:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b730:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b736:	83 ec 0c             	sub    $0xc,%esp
f011b739:	50                   	push   %eax
f011b73a:	e8 c0 e0 fe ff       	call   f01097ff <kfree>
f011b73f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b742:	e8 5e 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b747:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b74a:	74 17                	je     f011b763 <test_kheap_phys_addr+0x97d>
f011b74c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b753:	83 ec 0c             	sub    $0xc,%esp
f011b756:	68 d0 df 12 f0       	push   $0xf012dfd0
f011b75b:	e8 2b 58 fe ff       	call   f0100f8b <cprintf>
f011b760:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b763:	e8 54 32 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011b768:	89 c2                	mov    %eax,%edx
f011b76a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b76d:	29 c2                	sub    %eax,%edx
f011b76f:	89 d0                	mov    %edx,%eax
f011b771:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b776:	77 17                	ja     f011b78f <test_kheap_phys_addr+0x9a9>
f011b778:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b77f:	83 ec 0c             	sub    $0xc,%esp
f011b782:	68 38 f3 12 f0       	push   $0xf012f338
f011b787:	e8 ff 57 fe ff       	call   f0100f8b <cprintf>
f011b78c:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011b78f:	83 ec 0c             	sub    $0xc,%esp
f011b792:	68 74 f3 12 f0       	push   $0xf012f374
f011b797:	e8 ef 57 fe ff       	call   f0100f8b <cprintf>
f011b79c:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b79f:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b7a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011b7ad:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011b7b4:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011b7b7:	8b 15 d8 fd 17 f0    	mov    0xf017fdd8,%edx
f011b7bd:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b7c3:	01 d0                	add    %edx,%eax
f011b7c5:	05 00 10 00 00       	add    $0x1000,%eax
f011b7ca:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b7d0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b7d6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b7d9:	eb 25                	jmp    f011b800 <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b7db:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b7de:	8d 43 01             	lea    0x1(%ebx),%eax
f011b7e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b7e4:	83 ec 0c             	sub    $0xc,%esp
f011b7e7:	ff 75 d8             	pushl  -0x28(%ebp)
f011b7ea:	e8 f6 e0 fe ff       	call   f01098e5 <kheap_physical_address>
f011b7ef:	83 c4 10             	add    $0x10,%esp
f011b7f2:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b7f9:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b800:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b803:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b806:	72 d3                	jb     f011b7db <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b808:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b80b:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b811:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b818:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b81e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b821:	e9 f4 00 00 00       	jmp    f011b91a <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b826:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b82b:	83 ec 04             	sub    $0x4,%esp
f011b82e:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b834:	52                   	push   %edx
f011b835:	ff 75 d8             	pushl  -0x28(%ebp)
f011b838:	50                   	push   %eax
f011b839:	e8 b1 cb fe ff       	call   f01083ef <get_page_table>
f011b83e:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b841:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b847:	85 c0                	test   %eax,%eax
f011b849:	75 24                	jne    f011b86f <test_kheap_phys_addr+0xa89>
				if (correct)
f011b84b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b84f:	74 1e                	je     f011b86f <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b851:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b858:	83 ec 04             	sub    $0x4,%esp
f011b85b:	68 c4 f3 12 f0       	push   $0xf012f3c4
f011b860:	68 42 06 00 00       	push   $0x642
f011b865:	68 d3 ce 12 f0       	push   $0xf012ced3
f011b86a:	e8 ca 4a fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b86f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b872:	c1 e8 0c             	shr    $0xc,%eax
f011b875:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b87a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b87d:	eb 7b                	jmp    f011b8fa <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011b87f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011b886:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b88c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b88f:	c1 e2 02             	shl    $0x2,%edx
f011b892:	01 d0                	add    %edx,%eax
f011b894:	8b 00                	mov    (%eax),%eax
f011b896:	83 e0 01             	and    $0x1,%eax
f011b899:	85 c0                	test   %eax,%eax
f011b89b:	74 24                	je     f011b8c1 <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011b89d:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b8a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b8a6:	c1 e2 02             	shl    $0x2,%edx
f011b8a9:	01 d0                	add    %edx,%eax
f011b8ab:	8b 00                	mov    (%eax),%eax
f011b8ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b8b2:	89 c2                	mov    %eax,%edx
f011b8b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b8b7:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b8bc:	01 d0                	add    %edx,%eax
f011b8be:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011b8c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b8c4:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b8cb:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b8ce:	74 1d                	je     f011b8ed <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b8d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b8d4:	74 17                	je     f011b8ed <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011b8d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b8dd:	83 ec 0c             	sub    $0xc,%esp
f011b8e0:	68 24 f4 12 f0       	push   $0xf012f424
f011b8e5:	e8 a1 56 fe ff       	call   f0100f8b <cprintf>
f011b8ea:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011b8ed:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b8f4:	ff 45 d4             	incl   -0x2c(%ebp)
f011b8f7:	ff 45 f4             	incl   -0xc(%ebp)
f011b8fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b8fd:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011b903:	7d 15                	jge    f011b91a <test_kheap_phys_addr+0xb34>
f011b905:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b90c:	7f 0c                	jg     f011b91a <test_kheap_phys_addr+0xb34>
f011b90e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b911:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b914:	0f 82 65 ff ff ff    	jb     f011b87f <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b91a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b91d:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b920:	0f 82 00 ff ff ff    	jb     f011b826 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b926:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b92a:	74 04                	je     f011b930 <test_kheap_phys_addr+0xb4a>
f011b92c:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011b930:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011b937:	83 ec 0c             	sub    $0xc,%esp
f011b93a:	68 48 f4 12 f0       	push   $0xf012f448
f011b93f:	e8 47 56 fe ff       	call   f0100f8b <cprintf>
f011b944:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011b947:	83 ec 0c             	sub    $0xc,%esp
f011b94a:	6a 00                	push   $0x0
f011b94c:	e8 1b db fe ff       	call   f010946c <sbrk>
f011b951:	83 c4 10             	add    $0x10,%esp
f011b954:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b959:	77 17                	ja     f011b972 <test_kheap_phys_addr+0xb8c>
f011b95b:	83 ec 04             	sub    $0x4,%esp
f011b95e:	68 a0 f4 12 f0       	push   $0xf012f4a0
f011b963:	68 5d 06 00 00       	push   $0x65d
f011b968:	68 d3 ce 12 f0       	push   $0xf012ced3
f011b96d:	e8 c7 49 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b972:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011b979:	e9 af 00 00 00       	jmp    f011ba2d <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011b97e:	83 ec 0c             	sub    $0xc,%esp
f011b981:	ff 75 d0             	pushl  -0x30(%ebp)
f011b984:	e8 5c df fe ff       	call   f01098e5 <kheap_physical_address>
f011b989:	83 c4 10             	add    $0x10,%esp
f011b98c:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b992:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011b997:	83 ec 04             	sub    $0x4,%esp
f011b99a:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011b9a0:	52                   	push   %edx
f011b9a1:	ff 75 d0             	pushl  -0x30(%ebp)
f011b9a4:	50                   	push   %eax
f011b9a5:	e8 45 ca fe ff       	call   f01083ef <get_page_table>
f011b9aa:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b9ad:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b9b3:	85 c0                	test   %eax,%eax
f011b9b5:	75 24                	jne    f011b9db <test_kheap_phys_addr+0xbf5>
				if (correct)
f011b9b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b9bb:	74 1e                	je     f011b9db <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b9bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9c4:	83 ec 04             	sub    $0x4,%esp
f011b9c7:	68 bc f4 12 f0       	push   $0xf012f4bc
f011b9cc:	68 65 06 00 00       	push   $0x665
f011b9d1:	68 d3 ce 12 f0       	push   $0xf012ced3
f011b9d6:	e8 5e 49 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b9db:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b9e1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b9e4:	c1 ea 0c             	shr    $0xc,%edx
f011b9e7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b9ed:	c1 e2 02             	shl    $0x2,%edx
f011b9f0:	01 d0                	add    %edx,%eax
f011b9f2:	8b 00                	mov    (%eax),%eax
f011b9f4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b9f9:	89 c2                	mov    %eax,%edx
f011b9fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b9fe:	25 ff 0f 00 00       	and    $0xfff,%eax
f011ba03:	01 d0                	add    %edx,%eax
f011ba05:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011ba0b:	74 1d                	je     f011ba2a <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011ba0d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba11:	74 17                	je     f011ba2a <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011ba13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba1a:	83 ec 0c             	sub    $0xc,%esp
f011ba1d:	68 1c f5 12 f0       	push   $0xf012f51c
f011ba22:	e8 64 55 fe ff       	call   f0100f8b <cprintf>
f011ba27:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011ba2a:	ff 45 d0             	incl   -0x30(%ebp)
f011ba2d:	83 ec 0c             	sub    $0xc,%esp
f011ba30:	6a 00                	push   $0x0
f011ba32:	e8 35 da fe ff       	call   f010946c <sbrk>
f011ba37:	83 c4 10             	add    $0x10,%esp
f011ba3a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011ba3d:	0f 87 3b ff ff ff    	ja     f011b97e <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011ba43:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ba47:	74 04                	je     f011ba4d <test_kheap_phys_addr+0xc67>
f011ba49:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011ba4d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011ba54:	83 ec 0c             	sub    $0xc,%esp
f011ba57:	68 40 f5 12 f0       	push   $0xf012f540
f011ba5c:	e8 2a 55 fe ff       	call   f0100f8b <cprintf>
f011ba61:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011ba64:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011ba6b:	10 00 f9 
		i = 0;
f011ba6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011ba75:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011ba7b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011ba7e:	eb 0a                	jmp    f011ba8a <test_kheap_phys_addr+0xca4>
		{
			i++;
f011ba80:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011ba83:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011ba8a:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011ba91:	76 ed                	jbe    f011ba80 <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011ba93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ba96:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011ba9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011baa3:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011baa9:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011baac:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011bab3:	e9 cb 00 00 00       	jmp    f011bb83 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011bab8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011babb:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011bac0:	83 ec 04             	sub    $0x4,%esp
f011bac3:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011bac9:	51                   	push   %ecx
f011baca:	52                   	push   %edx
f011bacb:	50                   	push   %eax
f011bacc:	e8 1e c9 fe ff       	call   f01083ef <get_page_table>
f011bad1:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bad4:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011bada:	85 c0                	test   %eax,%eax
f011badc:	75 24                	jne    f011bb02 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011bade:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bae2:	74 1e                	je     f011bb02 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bae4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011baeb:	83 ec 04             	sub    $0x4,%esp
f011baee:	68 7c f5 12 f0       	push   $0xf012f57c
f011baf3:	68 87 06 00 00       	push   $0x687
f011baf8:	68 d3 ce 12 f0       	push   $0xf012ced3
f011bafd:	e8 37 48 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bb02:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011bb09:	eb 59                	jmp    f011bb64 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011bb0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bb0e:	c1 e0 0c             	shl    $0xc,%eax
f011bb11:	89 c2                	mov    %eax,%edx
f011bb13:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011bb19:	01 d0                	add    %edx,%eax
f011bb1b:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011bb21:	83 ec 0c             	sub    $0xc,%esp
f011bb24:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011bb2a:	e8 b6 dd fe ff       	call   f01098e5 <kheap_physical_address>
f011bb2f:	83 c4 10             	add    $0x10,%esp
f011bb32:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011bb38:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011bb3f:	74 1d                	je     f011bb5e <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bb41:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bb45:	74 17                	je     f011bb5e <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011bb47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb4e:	83 ec 0c             	sub    $0xc,%esp
f011bb51:	68 dc f5 12 f0       	push   $0xf012f5dc
f011bb56:	e8 30 54 fe ff       	call   f0100f8b <cprintf>
f011bb5b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011bb5e:	ff 45 c8             	incl   -0x38(%ebp)
f011bb61:	ff 45 f4             	incl   -0xc(%ebp)
f011bb64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bb67:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bb6d:	7d 09                	jge    f011bb78 <test_kheap_phys_addr+0xd92>
f011bb6f:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011bb76:	7e 93                	jle    f011bb0b <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011bb78:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011bb7f:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011bb83:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bb87:	0f 88 2b ff ff ff    	js     f011bab8 <test_kheap_phys_addr+0xcd2>
f011bb8d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011bb91:	7f 0d                	jg     f011bba0 <test_kheap_phys_addr+0xdba>
f011bb93:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011bb9a:	0f 86 18 ff ff ff    	jbe    f011bab8 <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011bba0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bba4:	74 04                	je     f011bbaa <test_kheap_phys_addr+0xdc4>
f011bba6:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011bbaa:	83 ec 08             	sub    $0x8,%esp
f011bbad:	ff 75 f0             	pushl  -0x10(%ebp)
f011bbb0:	68 00 f6 12 f0       	push   $0xf012f600
f011bbb5:	e8 d1 53 fe ff       	call   f0100f8b <cprintf>
f011bbba:	83 c4 10             	add    $0x10,%esp

	return 1;
f011bbbd:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011bbc2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011bbc5:	5b                   	pop    %ebx
f011bbc6:	5f                   	pop    %edi
f011bbc7:	5d                   	pop    %ebp
f011bbc8:	c3                   	ret    

f011bbc9 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011bbc9:	55                   	push   %ebp
f011bbca:	89 e5                	mov    %esp,%ebp
f011bbcc:	57                   	push   %edi
f011bbcd:	56                   	push   %esi
f011bbce:	53                   	push   %ebx
f011bbcf:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011bbd5:	89 e0                	mov    %esp,%eax
f011bbd7:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011bbd9:	83 ec 0c             	sub    $0xc,%esp
f011bbdc:	68 88 af 12 f0       	push   $0xf012af88
f011bbe1:	e8 a5 53 fe ff       	call   f0100f8b <cprintf>
f011bbe6:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011bbe9:	83 ec 0c             	sub    $0xc,%esp
f011bbec:	68 b8 af 12 f0       	push   $0xf012afb8
f011bbf1:	e8 95 53 fe ff       	call   f0100f8b <cprintf>
f011bbf6:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011bbf9:	83 ec 0c             	sub    $0xc,%esp
f011bbfc:	68 88 af 12 f0       	push   $0xf012af88
f011bc01:	e8 85 53 fe ff       	call   f0100f8b <cprintf>
f011bc06:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011bc09:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011bc0d:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011bc11:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011bc17:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011bc1d:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011bc24:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011bc2b:	e8 8c 2d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bc30:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011bc33:	83 ec 0c             	sub    $0xc,%esp
f011bc36:	68 dc ec 12 f0       	push   $0xf012ecdc
f011bc3b:	e8 4b 53 fe ff       	call   f0100f8b <cprintf>
f011bc40:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011bc43:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011bc49:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bc4e:	b8 00 00 00 00       	mov    $0x0,%eax
f011bc53:	89 d7                	mov    %edx,%edi
f011bc55:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011bc57:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011bc5d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bc62:	b8 00 00 00 00       	mov    $0x0,%eax
f011bc67:	89 d7                	mov    %edx,%edi
f011bc69:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011bc6b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011bc72:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011bc79:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bc7f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011bc84:	b8 00 00 00 00       	mov    $0x0,%eax
f011bc89:	89 d7                	mov    %edx,%edi
f011bc8b:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bc8d:	e8 2a 2d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bc92:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc95:	e8 0b 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc9a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011bc9d:	83 ec 0c             	sub    $0xc,%esp
f011bca0:	68 00 fc 1f 00       	push   $0x1ffc00
f011bca5:	e8 f5 d8 fe ff       	call   f010959f <kmalloc>
f011bcaa:	83 c4 10             	add    $0x10,%esp
f011bcad:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bcb3:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bcb9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011bcbe:	74 17                	je     f011bcd7 <test_kheap_virt_addr+0x10e>
f011bcc0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcc7:	83 ec 0c             	sub    $0xc,%esp
f011bcca:	68 80 d0 12 f0       	push   $0xf012d080
f011bccf:	e8 b7 52 fe ff       	call   f0100f8b <cprintf>
f011bcd4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bcd7:	e8 c9 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bcdc:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bcdf:	74 17                	je     f011bcf8 <test_kheap_virt_addr+0x12f>
f011bce1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bce8:	83 ec 0c             	sub    $0xc,%esp
f011bceb:	68 d4 d0 12 f0       	push   $0xf012d0d4
f011bcf0:	e8 96 52 fe ff       	call   f0100f8b <cprintf>
f011bcf5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bcf8:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bcfb:	e8 bc 2c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bd00:	29 c3                	sub    %eax,%ebx
f011bd02:	89 d8                	mov    %ebx,%eax
f011bd04:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bd09:	77 17                	ja     f011bd22 <test_kheap_virt_addr+0x159>
f011bd0b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd12:	83 ec 0c             	sub    $0xc,%esp
f011bd15:	68 44 d1 12 f0       	push   $0xf012d144
f011bd1a:	e8 6c 52 fe ff       	call   f0100f8b <cprintf>
f011bd1f:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bd22:	e8 95 2c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bd27:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bd2a:	e8 76 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd2f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011bd32:	83 ec 0c             	sub    $0xc,%esp
f011bd35:	68 00 fc 1f 00       	push   $0x1ffc00
f011bd3a:	e8 60 d8 fe ff       	call   f010959f <kmalloc>
f011bd3f:	83 c4 10             	add    $0x10,%esp
f011bd42:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bd48:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bd4e:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011bd53:	74 17                	je     f011bd6c <test_kheap_virt_addr+0x1a3>
f011bd55:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd5c:	83 ec 0c             	sub    $0xc,%esp
f011bd5f:	68 8c d1 12 f0       	push   $0xf012d18c
f011bd64:	e8 22 52 fe ff       	call   f0100f8b <cprintf>
f011bd69:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd6c:	e8 34 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd71:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bd74:	74 17                	je     f011bd8d <test_kheap_virt_addr+0x1c4>
f011bd76:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd7d:	83 ec 0c             	sub    $0xc,%esp
f011bd80:	68 e0 d1 12 f0       	push   $0xf012d1e0
f011bd85:	e8 01 52 fe ff       	call   f0100f8b <cprintf>
f011bd8a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bd8d:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bd90:	e8 27 2c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bd95:	29 c3                	sub    %eax,%ebx
f011bd97:	89 d8                	mov    %ebx,%eax
f011bd99:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bd9e:	77 17                	ja     f011bdb7 <test_kheap_virt_addr+0x1ee>
f011bda0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bda7:	83 ec 0c             	sub    $0xc,%esp
f011bdaa:	68 50 d2 12 f0       	push   $0xf012d250
f011bdaf:	e8 d7 51 fe ff       	call   f0100f8b <cprintf>
f011bdb4:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011bdb7:	e8 00 2c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bdbc:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bdbf:	e8 e1 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bdc4:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011bdc7:	83 ec 0c             	sub    $0xc,%esp
f011bdca:	68 00 04 00 00       	push   $0x400
f011bdcf:	e8 cb d7 fe ff       	call   f010959f <kmalloc>
f011bdd4:	83 c4 10             	add    $0x10,%esp
f011bdd7:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011bddd:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011bde3:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bde8:	76 28                	jbe    f011be12 <test_kheap_virt_addr+0x249>
f011bdea:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011bdf0:	83 ec 0c             	sub    $0xc,%esp
f011bdf3:	6a 00                	push   $0x0
f011bdf5:	e8 72 d6 fe ff       	call   f010946c <sbrk>
f011bdfa:	83 c4 10             	add    $0x10,%esp
f011bdfd:	39 c3                	cmp    %eax,%ebx
f011bdff:	73 11                	jae    f011be12 <test_kheap_virt_addr+0x249>
f011be01:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011be07:	89 c2                	mov    %eax,%edx
f011be09:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011be0e:	39 c2                	cmp    %eax,%edx
f011be10:	72 17                	jb     f011be29 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011be12:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be19:	83 ec 0c             	sub    $0xc,%esp
f011be1c:	68 0c ed 12 f0       	push   $0xf012ed0c
f011be21:	e8 65 51 fe ff       	call   f0100f8b <cprintf>
f011be26:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be29:	e8 77 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be2e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011be31:	74 17                	je     f011be4a <test_kheap_virt_addr+0x281>
f011be33:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be3a:	83 ec 0c             	sub    $0xc,%esp
f011be3d:	68 ec d2 12 f0       	push   $0xf012d2ec
f011be42:	e8 44 51 fe ff       	call   f0100f8b <cprintf>
f011be47:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011be4a:	e8 6d 2b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011be4f:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011be52:	e8 4e 8a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011be57:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011be5a:	83 ec 0c             	sub    $0xc,%esp
f011be5d:	68 00 08 00 00       	push   $0x800
f011be62:	e8 38 d7 fe ff       	call   f010959f <kmalloc>
f011be67:	83 c4 10             	add    $0x10,%esp
f011be6a:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011be70:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011be76:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011be7b:	76 28                	jbe    f011bea5 <test_kheap_virt_addr+0x2dc>
f011be7d:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011be83:	83 ec 0c             	sub    $0xc,%esp
f011be86:	6a 00                	push   $0x0
f011be88:	e8 df d5 fe ff       	call   f010946c <sbrk>
f011be8d:	83 c4 10             	add    $0x10,%esp
f011be90:	39 c3                	cmp    %eax,%ebx
f011be92:	73 11                	jae    f011bea5 <test_kheap_virt_addr+0x2dc>
f011be94:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011be9a:	89 c2                	mov    %eax,%edx
f011be9c:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bea1:	39 c2                	cmp    %eax,%edx
f011bea3:	72 17                	jb     f011bebc <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bea5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011beac:	83 ec 0c             	sub    $0xc,%esp
f011beaf:	68 98 ed 12 f0       	push   $0xf012ed98
f011beb4:	e8 d2 50 fe ff       	call   f0100f8b <cprintf>
f011beb9:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bebc:	e8 e4 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bec1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bec4:	74 17                	je     f011bedd <test_kheap_virt_addr+0x314>
f011bec6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011becd:	83 ec 0c             	sub    $0xc,%esp
f011bed0:	68 f8 d3 12 f0       	push   $0xf012d3f8
f011bed5:	e8 b1 50 fe ff       	call   f0100f8b <cprintf>
f011beda:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011bedd:	e8 da 2a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bee2:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bee5:	e8 bb 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011beea:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011beed:	83 ec 0c             	sub    $0xc,%esp
f011bef0:	68 00 06 00 00       	push   $0x600
f011bef5:	e8 a5 d6 fe ff       	call   f010959f <kmalloc>
f011befa:	83 c4 10             	add    $0x10,%esp
f011befd:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011bf03:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011bf09:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bf0e:	76 28                	jbe    f011bf38 <test_kheap_virt_addr+0x36f>
f011bf10:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011bf16:	83 ec 0c             	sub    $0xc,%esp
f011bf19:	6a 00                	push   $0x0
f011bf1b:	e8 4c d5 fe ff       	call   f010946c <sbrk>
f011bf20:	83 c4 10             	add    $0x10,%esp
f011bf23:	39 c3                	cmp    %eax,%ebx
f011bf25:	73 11                	jae    f011bf38 <test_kheap_virt_addr+0x36f>
f011bf27:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011bf2d:	89 c2                	mov    %eax,%edx
f011bf2f:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011bf34:	39 c2                	cmp    %eax,%edx
f011bf36:	72 17                	jb     f011bf4f <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bf38:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf3f:	83 ec 0c             	sub    $0xc,%esp
f011bf42:	68 24 ee 12 f0       	push   $0xf012ee24
f011bf47:	e8 3f 50 fe ff       	call   f0100f8b <cprintf>
f011bf4c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf4f:	e8 51 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf54:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bf57:	74 17                	je     f011bf70 <test_kheap_virt_addr+0x3a7>
f011bf59:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf60:	83 ec 0c             	sub    $0xc,%esp
f011bf63:	68 04 d5 12 f0       	push   $0xf012d504
f011bf68:	e8 1e 50 fe ff       	call   f0100f8b <cprintf>
f011bf6d:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011bf70:	e8 47 2a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bf75:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bf78:	e8 28 89 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bf7d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011bf80:	83 ec 0c             	sub    $0xc,%esp
f011bf83:	68 00 1c 00 00       	push   $0x1c00
f011bf88:	e8 12 d6 fe ff       	call   f010959f <kmalloc>
f011bf8d:	83 c4 10             	add    $0x10,%esp
f011bf90:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bf96:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bf9c:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011bfa1:	74 17                	je     f011bfba <test_kheap_virt_addr+0x3f1>
f011bfa3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfaa:	83 ec 0c             	sub    $0xc,%esp
f011bfad:	68 bc d5 12 f0       	push   $0xf012d5bc
f011bfb2:	e8 d4 4f fe ff       	call   f0100f8b <cprintf>
f011bfb7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bfba:	e8 e6 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bfbf:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011bfc2:	74 17                	je     f011bfdb <test_kheap_virt_addr+0x412>
f011bfc4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfcb:	83 ec 0c             	sub    $0xc,%esp
f011bfce:	68 10 d6 12 f0       	push   $0xf012d610
f011bfd3:	e8 b3 4f fe ff       	call   f0100f8b <cprintf>
f011bfd8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bfdb:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011bfde:	e8 d9 29 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011bfe3:	29 c3                	sub    %eax,%ebx
f011bfe5:	89 d8                	mov    %ebx,%eax
f011bfe7:	83 f8 01             	cmp    $0x1,%eax
f011bfea:	77 17                	ja     f011c003 <test_kheap_virt_addr+0x43a>
f011bfec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bff3:	83 ec 0c             	sub    $0xc,%esp
f011bff6:	68 80 d6 12 f0       	push   $0xf012d680
f011bffb:	e8 8b 4f fe ff       	call   f0100f8b <cprintf>
f011c000:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011c003:	e8 b4 29 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c008:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c00b:	e8 95 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c010:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011c013:	83 ec 0c             	sub    $0xc,%esp
f011c016:	68 00 fc 2f 00       	push   $0x2ffc00
f011c01b:	e8 7f d5 fe ff       	call   f010959f <kmalloc>
f011c020:	83 c4 10             	add    $0x10,%esp
f011c023:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c029:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011c02f:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011c034:	74 17                	je     f011c04d <test_kheap_virt_addr+0x484>
f011c036:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c03d:	83 ec 0c             	sub    $0xc,%esp
f011c040:	68 b0 ee 12 f0       	push   $0xf012eeb0
f011c045:	e8 41 4f fe ff       	call   f0100f8b <cprintf>
f011c04a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c04d:	e8 53 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c052:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c055:	74 17                	je     f011c06e <test_kheap_virt_addr+0x4a5>
f011c057:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c05e:	83 ec 0c             	sub    $0xc,%esp
f011c061:	68 54 d7 12 f0       	push   $0xf012d754
f011c066:	e8 20 4f fe ff       	call   f0100f8b <cprintf>
f011c06b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c06e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c071:	e8 46 29 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c076:	29 c3                	sub    %eax,%ebx
f011c078:	89 d8                	mov    %ebx,%eax
f011c07a:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011c07f:	77 17                	ja     f011c098 <test_kheap_virt_addr+0x4cf>
f011c081:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c088:	83 ec 0c             	sub    $0xc,%esp
f011c08b:	68 04 ef 12 f0       	push   $0xf012ef04
f011c090:	e8 f6 4e fe ff       	call   f0100f8b <cprintf>
f011c095:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c098:	e8 1f 29 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c09d:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c0a0:	e8 00 88 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c0a5:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011c0a8:	83 ec 0c             	sub    $0xc,%esp
f011c0ab:	68 00 fc 5f 00       	push   $0x5ffc00
f011c0b0:	e8 ea d4 fe ff       	call   f010959f <kmalloc>
f011c0b5:	83 c4 10             	add    $0x10,%esp
f011c0b8:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c0be:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c0c4:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011c0c9:	74 17                	je     f011c0e2 <test_kheap_virt_addr+0x519>
f011c0cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0d2:	83 ec 0c             	sub    $0xc,%esp
f011c0d5:	68 4c ef 12 f0       	push   $0xf012ef4c
f011c0da:	e8 ac 4e fe ff       	call   f0100f8b <cprintf>
f011c0df:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c0e2:	e8 be 87 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c0e7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c0ea:	74 17                	je     f011c103 <test_kheap_virt_addr+0x53a>
f011c0ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0f3:	83 ec 0c             	sub    $0xc,%esp
f011c0f6:	68 50 d8 12 f0       	push   $0xf012d850
f011c0fb:	e8 8b 4e fe ff       	call   f0100f8b <cprintf>
f011c100:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c103:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c106:	e8 b1 28 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c10b:	29 c3                	sub    %eax,%ebx
f011c10d:	89 d8                	mov    %ebx,%eax
f011c10f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c114:	77 17                	ja     f011c12d <test_kheap_virt_addr+0x564>
f011c116:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c11d:	83 ec 0c             	sub    $0xc,%esp
f011c120:	68 a0 ef 12 f0       	push   $0xf012efa0
f011c125:	e8 61 4e fe ff       	call   f0100f8b <cprintf>
f011c12a:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011c12d:	e8 8a 28 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c132:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c135:	e8 6b 87 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c13a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011c13d:	83 ec 0c             	sub    $0xc,%esp
f011c140:	68 00 38 00 00       	push   $0x3800
f011c145:	e8 55 d4 fe ff       	call   f010959f <kmalloc>
f011c14a:	83 c4 10             	add    $0x10,%esp
f011c14d:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c153:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c159:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011c15e:	74 17                	je     f011c177 <test_kheap_virt_addr+0x5ae>
f011c160:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c167:	83 ec 0c             	sub    $0xc,%esp
f011c16a:	68 e8 ef 12 f0       	push   $0xf012efe8
f011c16f:	e8 17 4e fe ff       	call   f0100f8b <cprintf>
f011c174:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c177:	e8 29 87 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c17c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c17f:	74 17                	je     f011c198 <test_kheap_virt_addr+0x5cf>
f011c181:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c188:	83 ec 0c             	sub    $0xc,%esp
f011c18b:	68 3c f0 12 f0       	push   $0xf012f03c
f011c190:	e8 f6 4d fe ff       	call   f0100f8b <cprintf>
f011c195:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c198:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c19b:	e8 1c 28 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c1a0:	29 c3                	sub    %eax,%ebx
f011c1a2:	89 d8                	mov    %ebx,%eax
f011c1a4:	83 f8 03             	cmp    $0x3,%eax
f011c1a7:	77 17                	ja     f011c1c0 <test_kheap_virt_addr+0x5f7>
f011c1a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c1b0:	83 ec 0c             	sub    $0xc,%esp
f011c1b3:	68 ac f0 12 f0       	push   $0xf012f0ac
f011c1b8:	e8 ce 4d fe ff       	call   f0100f8b <cprintf>
f011c1bd:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011c1c0:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011c1c7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c1ca:	c1 e8 0c             	shr    $0xc,%eax
f011c1cd:	89 c2                	mov    %eax,%edx
f011c1cf:	4a                   	dec    %edx
f011c1d0:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011c1d3:	c1 e0 02             	shl    $0x2,%eax
f011c1d6:	8d 50 03             	lea    0x3(%eax),%edx
f011c1d9:	b8 10 00 00 00       	mov    $0x10,%eax
f011c1de:	48                   	dec    %eax
f011c1df:	01 d0                	add    %edx,%eax
f011c1e1:	bf 10 00 00 00       	mov    $0x10,%edi
f011c1e6:	ba 00 00 00 00       	mov    $0x0,%edx
f011c1eb:	f7 f7                	div    %edi
f011c1ed:	6b c0 10             	imul   $0x10,%eax,%eax
f011c1f0:	29 c4                	sub    %eax,%esp
f011c1f2:	89 e0                	mov    %esp,%eax
f011c1f4:	83 c0 03             	add    $0x3,%eax
f011c1f7:	c1 e8 02             	shr    $0x2,%eax
f011c1fa:	c1 e0 02             	shl    $0x2,%eax
f011c1fd:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011c200:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011c203:	c1 e8 0c             	shr    $0xc,%eax
f011c206:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011c209:	83 ec 0c             	sub    $0xc,%esp
f011c20c:	68 34 f6 12 f0       	push   $0xf012f634
f011c211:	e8 75 4d fe ff       	call   f0100f8b <cprintf>
f011c216:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c219:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c220:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c225:	05 00 10 00 00       	add    $0x1000,%eax
f011c22a:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011c22d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c234:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c237:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c23a:	e9 2d 01 00 00       	jmp    f011c36c <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c23f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011c244:	83 ec 04             	sub    $0x4,%esp
f011c247:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c24d:	52                   	push   %edx
f011c24e:	ff 75 dc             	pushl  -0x24(%ebp)
f011c251:	50                   	push   %eax
f011c252:	e8 98 c1 fe ff       	call   f01083ef <get_page_table>
f011c257:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c25a:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c260:	85 c0                	test   %eax,%eax
f011c262:	75 1e                	jne    f011c282 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c264:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c26b:	83 ec 04             	sub    $0x4,%esp
f011c26e:	68 40 f1 12 f0       	push   $0xf012f140
f011c273:	68 26 07 00 00       	push   $0x726
f011c278:	68 d3 ce 12 f0       	push   $0xf012ced3
f011c27d:	e8 b7 40 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c282:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c285:	c1 e8 0c             	shr    $0xc,%eax
f011c288:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c28d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c290:	e9 ba 00 00 00       	jmp    f011c34f <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011c295:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c298:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011c29b:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c2a1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c2a4:	c1 e2 02             	shl    $0x2,%edx
f011c2a7:	01 d0                	add    %edx,%eax
f011c2a9:	8b 00                	mov    (%eax),%eax
f011c2ab:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c2b0:	89 c2                	mov    %eax,%edx
f011c2b2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c2b5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c2b8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c2bb:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c2be:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c2c1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c2c4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c2c7:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c2ca:	83 ec 0c             	sub    $0xc,%esp
f011c2cd:	50                   	push   %eax
f011c2ce:	e8 6f d6 fe ff       	call   f0109942 <kheap_virtual_address>
f011c2d3:	83 c4 10             	add    $0x10,%esp
f011c2d6:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011c2d9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c2dc:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c2df:	01 d0                	add    %edx,%eax
f011c2e1:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c2e4:	74 5c                	je     f011c342 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011c2e6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c2ea:	74 56                	je     f011c342 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011c2ec:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c2ef:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c2f2:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c2f5:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011c2fb:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011c2fe:	c1 e1 02             	shl    $0x2,%ecx
f011c301:	01 ca                	add    %ecx,%edx
f011c303:	8b 12                	mov    (%edx),%edx
f011c305:	89 d1                	mov    %edx,%ecx
f011c307:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011c30d:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011c310:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c313:	01 da                	add    %ebx,%edx
f011c315:	83 ec 0c             	sub    $0xc,%esp
f011c318:	50                   	push   %eax
f011c319:	51                   	push   %ecx
f011c31a:	52                   	push   %edx
f011c31b:	ff 75 8c             	pushl  -0x74(%ebp)
f011c31e:	68 80 f6 12 f0       	push   $0xf012f680
f011c323:	e8 63 4c fe ff       	call   f0100f8b <cprintf>
f011c328:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011c32b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c332:	83 ec 0c             	sub    $0xc,%esp
f011c335:	68 c4 f6 12 f0       	push   $0xf012f6c4
f011c33a:	e8 4c 4c fe ff       	call   f0100f8b <cprintf>
f011c33f:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011c342:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011c349:	ff 45 d4             	incl   -0x2c(%ebp)
f011c34c:	ff 45 d8             	incl   -0x28(%ebp)
f011c34f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c352:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011c355:	7d 15                	jge    f011c36c <test_kheap_virt_addr+0x7a3>
f011c357:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c35e:	7f 0c                	jg     f011c36c <test_kheap_virt_addr+0x7a3>
f011c360:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c363:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c366:	0f 82 29 ff ff ff    	jb     f011c295 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c36c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c36f:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011c372:	0f 82 c7 fe ff ff    	jb     f011c23f <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c378:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c37c:	74 04                	je     f011c382 <test_kheap_virt_addr+0x7b9>
f011c37e:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c382:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011c389:	83 ec 0c             	sub    $0xc,%esp
f011c38c:	68 e8 f6 12 f0       	push   $0xf012f6e8
f011c391:	e8 f5 4b fe ff       	call   f0100f8b <cprintf>
f011c396:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c399:	e8 1e 26 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c39e:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c3a1:	e8 ff 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3a6:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c3a9:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c3af:	83 ec 0c             	sub    $0xc,%esp
f011c3b2:	50                   	push   %eax
f011c3b3:	e8 47 d4 fe ff       	call   f01097ff <kfree>
f011c3b8:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c3bb:	e8 e5 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3c0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c3c3:	74 17                	je     f011c3dc <test_kheap_virt_addr+0x813>
f011c3c5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3cc:	83 ec 0c             	sub    $0xc,%esp
f011c3cf:	68 10 f7 12 f0       	push   $0xf012f710
f011c3d4:	e8 b2 4b fe ff       	call   f0100f8b <cprintf>
f011c3d9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c3dc:	e8 db 25 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c3e1:	89 c2                	mov    %eax,%edx
f011c3e3:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c3e6:	29 c2                	sub    %eax,%edx
f011c3e8:	89 d0                	mov    %edx,%eax
f011c3ea:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c3ef:	77 17                	ja     f011c408 <test_kheap_virt_addr+0x83f>
f011c3f1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c3f8:	83 ec 0c             	sub    $0xc,%esp
f011c3fb:	68 80 f7 12 f0       	push   $0xf012f780
f011c400:	e8 86 4b fe ff       	call   f0100f8b <cprintf>
f011c405:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c408:	e8 af 25 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c40d:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c410:	e8 90 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c415:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c418:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c41e:	83 ec 0c             	sub    $0xc,%esp
f011c421:	50                   	push   %eax
f011c422:	e8 d8 d3 fe ff       	call   f01097ff <kfree>
f011c427:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c42a:	e8 76 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c42f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c432:	74 17                	je     f011c44b <test_kheap_virt_addr+0x882>
f011c434:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c43b:	83 ec 0c             	sub    $0xc,%esp
f011c43e:	68 bc f7 12 f0       	push   $0xf012f7bc
f011c443:	e8 43 4b fe ff       	call   f0100f8b <cprintf>
f011c448:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c44b:	e8 6c 25 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c450:	89 c2                	mov    %eax,%edx
f011c452:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c455:	29 c2                	sub    %eax,%edx
f011c457:	89 d0                	mov    %edx,%eax
f011c459:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c45e:	77 17                	ja     f011c477 <test_kheap_virt_addr+0x8ae>
f011c460:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c467:	83 ec 0c             	sub    $0xc,%esp
f011c46a:	68 2c f8 12 f0       	push   $0xf012f82c
f011c46f:	e8 17 4b fe ff       	call   f0100f8b <cprintf>
f011c474:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c477:	e8 40 25 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c47c:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c47f:	e8 21 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c484:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c487:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011c48d:	83 ec 0c             	sub    $0xc,%esp
f011c490:	50                   	push   %eax
f011c491:	e8 69 d3 fe ff       	call   f01097ff <kfree>
f011c496:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c499:	e8 07 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c49e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c4a1:	74 17                	je     f011c4ba <test_kheap_virt_addr+0x8f1>
f011c4a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4aa:	83 ec 0c             	sub    $0xc,%esp
f011c4ad:	68 68 f8 12 f0       	push   $0xf012f868
f011c4b2:	e8 d4 4a fe ff       	call   f0100f8b <cprintf>
f011c4b7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c4ba:	e8 fd 24 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c4bf:	89 c2                	mov    %eax,%edx
f011c4c1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c4c4:	29 c2                	sub    %eax,%edx
f011c4c6:	89 d0                	mov    %edx,%eax
f011c4c8:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c4cd:	77 17                	ja     f011c4e6 <test_kheap_virt_addr+0x91d>
f011c4cf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4d6:	83 ec 0c             	sub    $0xc,%esp
f011c4d9:	68 d8 f8 12 f0       	push   $0xf012f8d8
f011c4de:	e8 a8 4a fe ff       	call   f0100f8b <cprintf>
f011c4e3:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011c4e6:	83 ec 0c             	sub    $0xc,%esp
f011c4e9:	68 14 f9 12 f0       	push   $0xf012f914
f011c4ee:	e8 98 4a fe ff       	call   f0100f8b <cprintf>
f011c4f3:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c4f6:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c4fd:	a1 d8 fd 17 f0       	mov    0xf017fdd8,%eax
f011c502:	05 00 10 00 00       	add    $0x1000,%eax
f011c507:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011c50d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011c514:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011c51b:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c51e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c524:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c527:	eb 44                	jmp    f011c56d <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c529:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c52c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c52f:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c532:	83 ec 0c             	sub    $0xc,%esp
f011c535:	50                   	push   %eax
f011c536:	e8 07 d4 fe ff       	call   f0109942 <kheap_virtual_address>
f011c53b:	83 c4 10             	add    $0x10,%esp
f011c53e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011c544:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011c54b:	74 1d                	je     f011c56a <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011c54d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c551:	74 17                	je     f011c56a <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011c553:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c55a:	83 ec 0c             	sub    $0xc,%esp
f011c55d:	68 64 f9 12 f0       	push   $0xf012f964
f011c562:	e8 24 4a fe ff       	call   f0100f8b <cprintf>
f011c567:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011c56a:	ff 45 d0             	incl   -0x30(%ebp)
f011c56d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c573:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011c579:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c57c:	39 c2                	cmp    %eax,%edx
f011c57e:	77 a9                	ja     f011c529 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c580:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c586:	05 00 04 00 00       	add    $0x400,%eax
f011c58b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c58e:	eb 64                	jmp    f011c5f4 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c590:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c593:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c596:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c599:	83 ec 0c             	sub    $0xc,%esp
f011c59c:	50                   	push   %eax
f011c59d:	e8 a0 d3 fe ff       	call   f0109942 <kheap_virtual_address>
f011c5a2:	83 c4 10             	add    $0x10,%esp
f011c5a5:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c5ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5ae:	c1 e0 0c             	shl    $0xc,%eax
f011c5b1:	89 c2                	mov    %eax,%edx
f011c5b3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c5b9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c5bc:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c5bf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c5c2:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c5c5:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c5ca:	01 c8                	add    %ecx,%eax
f011c5cc:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c5d2:	74 1d                	je     f011c5f1 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011c5d4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c5d8:	74 17                	je     f011c5f1 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011c5da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5e1:	83 ec 0c             	sub    $0xc,%esp
f011c5e4:	68 88 f9 12 f0       	push   $0xf012f988
f011c5e9:	e8 9d 49 fe ff       	call   f0100f8b <cprintf>
f011c5ee:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c5f1:	ff 45 d0             	incl   -0x30(%ebp)
f011c5f4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c5fa:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011c600:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c603:	39 c2                	cmp    %eax,%edx
f011c605:	77 89                	ja     f011c590 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c607:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c60d:	05 02 07 00 00       	add    $0x702,%eax
f011c612:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c615:	eb 44                	jmp    f011c65b <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c617:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c61a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c61d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c620:	83 ec 0c             	sub    $0xc,%esp
f011c623:	50                   	push   %eax
f011c624:	e8 19 d3 fe ff       	call   f0109942 <kheap_virtual_address>
f011c629:	83 c4 10             	add    $0x10,%esp
f011c62c:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011c632:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011c639:	74 1d                	je     f011c658 <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011c63b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c63f:	74 17                	je     f011c658 <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011c641:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c648:	83 ec 0c             	sub    $0xc,%esp
f011c64b:	68 ac f9 12 f0       	push   $0xf012f9ac
f011c650:	e8 36 49 fe ff       	call   f0100f8b <cprintf>
f011c655:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011c658:	ff 45 d0             	incl   -0x30(%ebp)
f011c65b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c661:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011c667:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c66a:	39 c2                	cmp    %eax,%edx
f011c66c:	77 a9                	ja     f011c617 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c66e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c674:	05 02 0d 00 00       	add    $0xd02,%eax
f011c679:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c67c:	eb 64                	jmp    f011c6e2 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011c67e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c681:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c684:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c687:	83 ec 0c             	sub    $0xc,%esp
f011c68a:	50                   	push   %eax
f011c68b:	e8 b2 d2 fe ff       	call   f0109942 <kheap_virtual_address>
f011c690:	83 c4 10             	add    $0x10,%esp
f011c693:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011c699:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c69c:	c1 e0 0c             	shl    $0xc,%eax
f011c69f:	89 c2                	mov    %eax,%edx
f011c6a1:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c6a7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011c6aa:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c6ad:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c6b0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011c6b3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c6b8:	01 c8                	add    %ecx,%eax
f011c6ba:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011c6c0:	74 1d                	je     f011c6df <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011c6c2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c6c6:	74 17                	je     f011c6df <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011c6c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6cf:	83 ec 0c             	sub    $0xc,%esp
f011c6d2:	68 d0 f9 12 f0       	push   $0xf012f9d0
f011c6d7:	e8 af 48 fe ff       	call   f0100f8b <cprintf>
f011c6dc:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011c6df:	ff 45 d0             	incl   -0x30(%ebp)
f011c6e2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c6e8:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011c6ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c6f1:	39 c2                	cmp    %eax,%edx
f011c6f3:	77 89                	ja     f011c67e <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011c6f5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c6f9:	74 04                	je     f011c6ff <test_kheap_virt_addr+0xb36>
f011c6fb:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011c6ff:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011c706:	83 ec 0c             	sub    $0xc,%esp
f011c709:	68 f4 f9 12 f0       	push   $0xf012f9f4
f011c70e:	e8 78 48 fe ff       	call   f0100f8b <cprintf>
f011c713:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c716:	83 ec 0c             	sub    $0xc,%esp
f011c719:	6a 00                	push   $0x0
f011c71b:	e8 4c cd fe ff       	call   f010946c <sbrk>
f011c720:	83 c4 10             	add    $0x10,%esp
f011c723:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c728:	77 17                	ja     f011c741 <test_kheap_virt_addr+0xb78>
f011c72a:	83 ec 04             	sub    $0x4,%esp
f011c72d:	68 3b fa 12 f0       	push   $0xf012fa3b
f011c732:	68 91 07 00 00       	push   $0x791
f011c737:	68 d3 ce 12 f0       	push   $0xf012ced3
f011c73c:	e8 f8 3b fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c741:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c748:	e9 d1 00 00 00       	jmp    f011c81e <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c74d:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011c752:	83 ec 04             	sub    $0x4,%esp
f011c755:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c75b:	52                   	push   %edx
f011c75c:	ff 75 cc             	pushl  -0x34(%ebp)
f011c75f:	50                   	push   %eax
f011c760:	e8 8a bc fe ff       	call   f01083ef <get_page_table>
f011c765:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c768:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c76e:	85 c0                	test   %eax,%eax
f011c770:	75 1e                	jne    f011c790 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c772:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c779:	83 ec 04             	sub    $0x4,%esp
f011c77c:	68 c4 f3 12 f0       	push   $0xf012f3c4
f011c781:	68 97 07 00 00       	push   $0x797
f011c786:	68 d3 ce 12 f0       	push   $0xf012ced3
f011c78b:	e8 a9 3b fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011c790:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c796:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c799:	c1 ea 0c             	shr    $0xc,%edx
f011c79c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c7a2:	c1 e2 02             	shl    $0x2,%edx
f011c7a5:	01 d0                	add    %edx,%eax
f011c7a7:	8b 00                	mov    (%eax),%eax
f011c7a9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c7ae:	89 c2                	mov    %eax,%edx
f011c7b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c7b3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c7b8:	01 d0                	add    %edx,%eax
f011c7ba:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011c7c0:	83 ec 0c             	sub    $0xc,%esp
f011c7c3:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c7c9:	e8 74 d1 fe ff       	call   f0109942 <kheap_virtual_address>
f011c7ce:	83 c4 10             	add    $0x10,%esp
f011c7d1:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011c7d7:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011c7dd:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c7e0:	74 39                	je     f011c81b <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011c7e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c7e6:	74 33                	je     f011c81b <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011c7e8:	ff 75 cc             	pushl  -0x34(%ebp)
f011c7eb:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011c7f1:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c7f7:	68 54 fa 12 f0       	push   $0xf012fa54
f011c7fc:	e8 8a 47 fe ff       	call   f0100f8b <cprintf>
f011c801:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c804:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c80b:	83 ec 0c             	sub    $0xc,%esp
f011c80e:	68 80 fa 12 f0       	push   $0xf012fa80
f011c813:	e8 73 47 fe ff       	call   f0100f8b <cprintf>
f011c818:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c81b:	ff 45 cc             	incl   -0x34(%ebp)
f011c81e:	83 ec 0c             	sub    $0xc,%esp
f011c821:	6a 00                	push   $0x0
f011c823:	e8 44 cc fe ff       	call   f010946c <sbrk>
f011c828:	83 c4 10             	add    $0x10,%esp
f011c82b:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c82e:	0f 87 19 ff ff ff    	ja     f011c74d <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011c834:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c838:	74 04                	je     f011c83e <test_kheap_virt_addr+0xc75>
f011c83a:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011c83e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011c845:	83 ec 0c             	sub    $0xc,%esp
f011c848:	68 a4 fa 12 f0       	push   $0xf012faa4
f011c84d:	e8 39 47 fe ff       	call   f0100f8b <cprintf>
f011c852:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c855:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011c85c:	eb 5a                	jmp    f011c8b8 <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011c85e:	83 ec 0c             	sub    $0xc,%esp
f011c861:	ff 75 c8             	pushl  -0x38(%ebp)
f011c864:	e8 d9 d0 fe ff       	call   f0109942 <kheap_virtual_address>
f011c869:	83 c4 10             	add    $0x10,%esp
f011c86c:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011c872:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011c879:	74 36                	je     f011c8b1 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011c87b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c87f:	74 30                	je     f011c8b1 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011c881:	83 ec 04             	sub    $0x4,%esp
f011c884:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011c88a:	ff 75 c8             	pushl  -0x38(%ebp)
f011c88d:	68 e3 fa 12 f0       	push   $0xf012fae3
f011c892:	e8 f4 46 fe ff       	call   f0100f8b <cprintf>
f011c897:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011c89a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8a1:	83 ec 0c             	sub    $0xc,%esp
f011c8a4:	68 00 fb 12 f0       	push   $0xf012fb00
f011c8a9:	e8 dd 46 fe ff       	call   f0100f8b <cprintf>
f011c8ae:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c8b1:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011c8b8:	b8 d0 d7 b0 00       	mov    $0xb0d7d0,%eax
f011c8bd:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011c8c0:	72 9c                	jb     f011c85e <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011c8c2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c8c6:	74 04                	je     f011c8cc <test_kheap_virt_addr+0xd03>
f011c8c8:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011c8cc:	83 ec 08             	sub    $0x8,%esp
f011c8cf:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c8d2:	68 24 fb 12 f0       	push   $0xf012fb24
f011c8d7:	e8 af 46 fe ff       	call   f0100f8b <cprintf>
f011c8dc:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c8df:	b8 01 00 00 00       	mov    $0x1,%eax
f011c8e4:	89 f4                	mov    %esi,%esp

}
f011c8e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c8e9:	5b                   	pop    %ebx
f011c8ea:	5e                   	pop    %esi
f011c8eb:	5f                   	pop    %edi
f011c8ec:	5d                   	pop    %ebp
f011c8ed:	c3                   	ret    

f011c8ee <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011c8ee:	55                   	push   %ebp
f011c8ef:	89 e5                	mov    %esp,%ebp
f011c8f1:	57                   	push   %edi
f011c8f2:	56                   	push   %esi
f011c8f3:	53                   	push   %ebx
f011c8f4:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011c8fa:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011c900:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c905:	b8 00 00 00 00       	mov    $0x0,%eax
f011c90a:	89 d7                	mov    %edx,%edi
f011c90c:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011c90e:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011c915:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c91c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011c923:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011c928:	0f b6 c0             	movzbl %al,%eax
f011c92b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c92e:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011c935:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c938:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c93b:	39 c2                	cmp    %eax,%edx
f011c93d:	73 02                	jae    f011c941 <test_ksbrk+0x53>
f011c93f:	89 c2                	mov    %eax,%edx
f011c941:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011c946:	0f b6 c0             	movzbl %al,%eax
f011c949:	c1 e0 04             	shl    $0x4,%eax
f011c94c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011c94f:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011c956:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011c959:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c95c:	39 c8                	cmp    %ecx,%eax
f011c95e:	73 02                	jae    f011c962 <test_ksbrk+0x74>
f011c960:	89 c8                	mov    %ecx,%eax
f011c962:	01 d0                	add    %edx,%eax
f011c964:	83 c0 10             	add    $0x10,%eax
f011c967:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011c96c:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011c96f:	83 ec 0c             	sub    $0xc,%esp
f011c972:	68 58 fb 12 f0       	push   $0xf012fb58
f011c977:	e8 0f 46 fe ff       	call   f0100f8b <cprintf>
f011c97c:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011c97f:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c986:	e8 31 20 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011c98b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c98e:	e8 12 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c993:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011c996:	83 ec 10             	sub    $0x10,%esp
f011c999:	89 e0                	mov    %esp,%eax
f011c99b:	89 c2                	mov    %eax,%edx
f011c99d:	bb 10 17 6c f0       	mov    $0xf06c1710,%ebx
f011c9a2:	b8 04 00 00 00       	mov    $0x4,%eax
f011c9a7:	89 d7                	mov    %edx,%edi
f011c9a9:	89 de                	mov    %ebx,%esi
f011c9ab:	89 c1                	mov    %eax,%ecx
f011c9ad:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011c9af:	e8 53 3e 00 00       	call   f0120807 <print_blocks_list>
f011c9b4:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c9b7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c9ba:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c9bd:	29 c2                	sub    %eax,%edx
f011c9bf:	89 d0                	mov    %edx,%eax
f011c9c1:	83 ec 0c             	sub    $0xc,%esp
f011c9c4:	50                   	push   %eax
f011c9c5:	e8 d5 cb fe ff       	call   f010959f <kmalloc>
f011c9ca:	83 c4 10             	add    $0x10,%esp
f011c9cd:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011c9d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c9d6:	89 c2                	mov    %eax,%edx
f011c9d8:	c1 ea 1f             	shr    $0x1f,%edx
f011c9db:	01 d0                	add    %edx,%eax
f011c9dd:	d1 f8                	sar    %eax
f011c9df:	89 c2                	mov    %eax,%edx
f011c9e1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c9e4:	01 d0                	add    %edx,%eax
f011c9e6:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c9e9:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c9ef:	6a 01                	push   $0x1
f011c9f1:	ff 75 b8             	pushl  -0x48(%ebp)
f011c9f4:	ff 75 ac             	pushl  -0x54(%ebp)
f011c9f7:	50                   	push   %eax
f011c9f8:	e8 db 43 ff ff       	call   f0110dd8 <check_block>
f011c9fd:	83 c4 10             	add    $0x10,%esp
f011ca00:	85 c0                	test   %eax,%eax
f011ca02:	75 17                	jne    f011ca1b <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011ca04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca0b:	83 ec 0c             	sub    $0xc,%esp
f011ca0e:	68 a9 fb 12 f0       	push   $0xf012fba9
f011ca13:	e8 73 45 fe ff       	call   f0100f8b <cprintf>
f011ca18:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ca1b:	e8 9c 1f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011ca20:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ca23:	74 17                	je     f011ca3c <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011ca25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca2c:	83 ec 0c             	sub    $0xc,%esp
f011ca2f:	68 c0 fb 12 f0       	push   $0xf012fbc0
f011ca34:	e8 52 45 fe ff       	call   f0100f8b <cprintf>
f011ca39:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ca3c:	e8 64 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca41:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ca44:	74 17                	je     f011ca5d <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca46:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca4d:	83 ec 0c             	sub    $0xc,%esp
f011ca50:	68 e0 fb 12 f0       	push   $0xf012fbe0
f011ca55:	e8 31 45 fe ff       	call   f0100f8b <cprintf>
f011ca5a:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011ca5d:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ca62:	0f b6 c0             	movzbl %al,%eax
f011ca65:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011ca68:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011ca6f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011ca72:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011ca75:	39 c2                	cmp    %eax,%edx
f011ca77:	73 02                	jae    f011ca7b <test_ksbrk+0x18d>
f011ca79:	89 c2                	mov    %eax,%edx
f011ca7b:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ca80:	0f b6 c0             	movzbl %al,%eax
f011ca83:	c1 e0 04             	shl    $0x4,%eax
f011ca86:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011ca89:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011ca90:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011ca93:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ca96:	39 c8                	cmp    %ecx,%eax
f011ca98:	73 02                	jae    f011ca9c <test_ksbrk+0x1ae>
f011ca9a:	89 c8                	mov    %ecx,%eax
f011ca9c:	01 d0                	add    %edx,%eax
f011ca9e:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011caa3:	29 c2                	sub    %eax,%edx
f011caa5:	89 d0                	mov    %edx,%eax
f011caa7:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011caaa:	e8 0d 1f ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011caaf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cab2:	e8 ee 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cab7:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011caba:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cabd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cac0:	29 c2                	sub    %eax,%edx
f011cac2:	89 d0                	mov    %edx,%eax
f011cac4:	83 ec 0c             	sub    $0xc,%esp
f011cac7:	50                   	push   %eax
f011cac8:	e8 d2 ca fe ff       	call   f010959f <kmalloc>
f011cacd:	83 c4 10             	add    $0x10,%esp
f011cad0:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011cad6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cad9:	89 c2                	mov    %eax,%edx
f011cadb:	c1 ea 1f             	shr    $0x1f,%edx
f011cade:	01 d0                	add    %edx,%eax
f011cae0:	d1 f8                	sar    %eax
f011cae2:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011cae8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011caeb:	01 d0                	add    %edx,%eax
f011caed:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011caf0:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011caf6:	6a 01                	push   $0x1
f011caf8:	ff 75 b8             	pushl  -0x48(%ebp)
f011cafb:	ff 75 ac             	pushl  -0x54(%ebp)
f011cafe:	50                   	push   %eax
f011caff:	e8 d4 42 ff ff       	call   f0110dd8 <check_block>
f011cb04:	83 c4 10             	add    $0x10,%esp
f011cb07:	85 c0                	test   %eax,%eax
f011cb09:	75 17                	jne    f011cb22 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011cb0b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb12:	83 ec 0c             	sub    $0xc,%esp
f011cb15:	68 4e fc 12 f0       	push   $0xf012fc4e
f011cb1a:	e8 6c 44 fe ff       	call   f0100f8b <cprintf>
f011cb1f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cb22:	e8 95 1e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011cb27:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cb2a:	74 17                	je     f011cb43 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011cb2c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb33:	83 ec 0c             	sub    $0xc,%esp
f011cb36:	68 68 fc 12 f0       	push   $0xf012fc68
f011cb3b:	e8 4b 44 fe ff       	call   f0100f8b <cprintf>
f011cb40:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cb43:	e8 5d 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cb48:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cb4b:	74 17                	je     f011cb64 <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cb4d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb54:	83 ec 0c             	sub    $0xc,%esp
f011cb57:	68 88 fc 12 f0       	push   $0xf012fc88
f011cb5c:	e8 2a 44 fe ff       	call   f0100f8b <cprintf>
f011cb61:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011cb64:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011cb6b:	e8 4c 1e ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011cb70:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cb73:	e8 2d 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cb78:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011cb7b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cb7e:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cb81:	29 c2                	sub    %eax,%edx
f011cb83:	89 d0                	mov    %edx,%eax
f011cb85:	83 ec 0c             	sub    $0xc,%esp
f011cb88:	50                   	push   %eax
f011cb89:	e8 11 ca fe ff       	call   f010959f <kmalloc>
f011cb8e:	83 c4 10             	add    $0x10,%esp
f011cb91:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cb97:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cb9a:	89 c2                	mov    %eax,%edx
f011cb9c:	c1 ea 1f             	shr    $0x1f,%edx
f011cb9f:	01 d0                	add    %edx,%eax
f011cba1:	d1 f8                	sar    %eax
f011cba3:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011cba8:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011cbab:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011cbb1:	6a 01                	push   $0x1
f011cbb3:	ff 75 b8             	pushl  -0x48(%ebp)
f011cbb6:	ff 75 ac             	pushl  -0x54(%ebp)
f011cbb9:	50                   	push   %eax
f011cbba:	e8 19 42 ff ff       	call   f0110dd8 <check_block>
f011cbbf:	83 c4 10             	add    $0x10,%esp
f011cbc2:	85 c0                	test   %eax,%eax
f011cbc4:	75 17                	jne    f011cbdd <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011cbc6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbcd:	83 ec 0c             	sub    $0xc,%esp
f011cbd0:	68 f6 fc 12 f0       	push   $0xf012fcf6
f011cbd5:	e8 b1 43 fe ff       	call   f0100f8b <cprintf>
f011cbda:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cbdd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cbe0:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011cbe3:	b8 00 10 00 00       	mov    $0x1000,%eax
f011cbe8:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011cbeb:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cbee:	6a 00                	push   $0x0
f011cbf0:	ff 75 98             	pushl  -0x68(%ebp)
f011cbf3:	ff 75 ac             	pushl  -0x54(%ebp)
f011cbf6:	ff 75 ac             	pushl  -0x54(%ebp)
f011cbf9:	e8 da 41 ff ff       	call   f0110dd8 <check_block>
f011cbfe:	83 c4 10             	add    $0x10,%esp
f011cc01:	85 c0                	test   %eax,%eax
f011cc03:	75 17                	jne    f011cc1c <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011cc05:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc0c:	83 ec 0c             	sub    $0xc,%esp
f011cc0f:	68 0d fd 12 f0       	push   $0xf012fd0d
f011cc14:	e8 72 43 fe ff       	call   f0100f8b <cprintf>
f011cc19:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011cc1c:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cc23:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cc26:	8b 00                	mov    (%eax),%eax
f011cc28:	83 f8 01             	cmp    $0x1,%eax
f011cc2b:	74 17                	je     f011cc44 <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011cc2d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc34:	83 ec 0c             	sub    $0xc,%esp
f011cc37:	68 24 fd 12 f0       	push   $0xf012fd24
f011cc3c:	e8 4a 43 fe ff       	call   f0100f8b <cprintf>
f011cc41:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cc44:	83 ec 0c             	sub    $0xc,%esp
f011cc47:	6a 00                	push   $0x0
f011cc49:	e8 1e c8 fe ff       	call   f010946c <sbrk>
f011cc4e:	83 c4 10             	add    $0x10,%esp
f011cc51:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011cc54:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011cc5b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cc5e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cc61:	74 1d                	je     f011cc80 <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011cc63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc6a:	83 ec 04             	sub    $0x4,%esp
f011cc6d:	ff 75 90             	pushl  -0x70(%ebp)
f011cc70:	ff 75 8c             	pushl  -0x74(%ebp)
f011cc73:	68 50 fd 12 f0       	push   $0xf012fd50
f011cc78:	e8 0e 43 fe ff       	call   f0100f8b <cprintf>
f011cc7d:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011cc80:	e8 37 1d ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011cc85:	89 c2                	mov    %eax,%edx
f011cc87:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011cc8a:	29 d0                	sub    %edx,%eax
f011cc8c:	83 f8 01             	cmp    $0x1,%eax
f011cc8f:	74 17                	je     f011cca8 <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011cc91:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc98:	83 ec 0c             	sub    $0xc,%esp
f011cc9b:	68 84 fd 12 f0       	push   $0xf012fd84
f011cca0:	e8 e6 42 fe ff       	call   f0100f8b <cprintf>
f011cca5:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cca8:	e8 f8 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ccad:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ccb0:	74 17                	je     f011ccc9 <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ccb2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ccb9:	83 ec 0c             	sub    $0xc,%esp
f011ccbc:	68 a4 fd 12 f0       	push   $0xf012fda4
f011ccc1:	e8 c5 42 fe ff       	call   f0100f8b <cprintf>
f011ccc6:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011ccc9:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011ccd0:	e8 e7 1c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011ccd5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ccd8:	e8 c8 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ccdd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011cce0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cce3:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cce6:	29 c2                	sub    %eax,%edx
f011cce8:	89 d0                	mov    %edx,%eax
f011ccea:	83 ec 0c             	sub    $0xc,%esp
f011cced:	50                   	push   %eax
f011ccee:	e8 ac c8 fe ff       	call   f010959f <kmalloc>
f011ccf3:	83 c4 10             	add    $0x10,%esp
f011ccf6:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011ccfc:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011cd03:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011cd09:	6a 01                	push   $0x1
f011cd0b:	ff 75 b8             	pushl  -0x48(%ebp)
f011cd0e:	ff 75 ac             	pushl  -0x54(%ebp)
f011cd11:	50                   	push   %eax
f011cd12:	e8 c1 40 ff ff       	call   f0110dd8 <check_block>
f011cd17:	83 c4 10             	add    $0x10,%esp
f011cd1a:	85 c0                	test   %eax,%eax
f011cd1c:	75 17                	jne    f011cd35 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011cd1e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd25:	83 ec 0c             	sub    $0xc,%esp
f011cd28:	68 13 fe 12 f0       	push   $0xf012fe13
f011cd2d:	e8 59 42 fe ff       	call   f0100f8b <cprintf>
f011cd32:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cd35:	e8 82 1c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011cd3a:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cd3d:	74 17                	je     f011cd56 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011cd3f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd46:	83 ec 0c             	sub    $0xc,%esp
f011cd49:	68 2c fe 12 f0       	push   $0xf012fe2c
f011cd4e:	e8 38 42 fe ff       	call   f0100f8b <cprintf>
f011cd53:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cd56:	e8 4a 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd5b:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cd5e:	74 17                	je     f011cd77 <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cd60:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd67:	83 ec 0c             	sub    $0xc,%esp
f011cd6a:	68 4c fe 12 f0       	push   $0xf012fe4c
f011cd6f:	e8 17 42 fe ff       	call   f0100f8b <cprintf>
f011cd74:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011cd77:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cd7b:	74 04                	je     f011cd81 <test_ksbrk+0x493>
		eval += 25;
f011cd7d:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011cd81:	83 ec 0c             	sub    $0xc,%esp
f011cd84:	68 bc fe 12 f0       	push   $0xf012febc
f011cd89:	e8 fd 41 fe ff       	call   f0100f8b <cprintf>
f011cd8e:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011cd91:	83 ec 0c             	sub    $0xc,%esp
f011cd94:	6a 00                	push   $0x0
f011cd96:	e8 d1 c6 fe ff       	call   f010946c <sbrk>
f011cd9b:	83 c4 10             	add    $0x10,%esp
f011cd9e:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011cda1:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011cda8:	e8 0f 1c ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011cdad:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cdb0:	e8 f0 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cdb5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011cdb8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cdbb:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cdbe:	29 c2                	sub    %eax,%edx
f011cdc0:	89 d0                	mov    %edx,%eax
f011cdc2:	83 ec 0c             	sub    $0xc,%esp
f011cdc5:	50                   	push   %eax
f011cdc6:	e8 d4 c7 fe ff       	call   f010959f <kmalloc>
f011cdcb:	83 c4 10             	add    $0x10,%esp
f011cdce:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011cdd4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cdd7:	89 c2                	mov    %eax,%edx
f011cdd9:	c1 ea 1f             	shr    $0x1f,%edx
f011cddc:	01 d0                	add    %edx,%eax
f011cdde:	d1 f8                	sar    %eax
f011cde0:	89 c2                	mov    %eax,%edx
f011cde2:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cde5:	01 d0                	add    %edx,%eax
f011cde7:	83 e8 04             	sub    $0x4,%eax
f011cdea:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011cded:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011cdf3:	6a 01                	push   $0x1
f011cdf5:	ff 75 b8             	pushl  -0x48(%ebp)
f011cdf8:	ff 75 ac             	pushl  -0x54(%ebp)
f011cdfb:	50                   	push   %eax
f011cdfc:	e8 d7 3f ff ff       	call   f0110dd8 <check_block>
f011ce01:	83 c4 10             	add    $0x10,%esp
f011ce04:	85 c0                	test   %eax,%eax
f011ce06:	75 17                	jne    f011ce1f <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011ce08:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce0f:	83 ec 0c             	sub    $0xc,%esp
f011ce12:	68 1f ff 12 f0       	push   $0xf012ff1f
f011ce17:	e8 6f 41 fe ff       	call   f0100f8b <cprintf>
f011ce1c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011ce1f:	e8 98 1b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011ce24:	89 c2                	mov    %eax,%edx
f011ce26:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011ce29:	29 d0                	sub    %edx,%eax
f011ce2b:	83 f8 01             	cmp    $0x1,%eax
f011ce2e:	74 17                	je     f011ce47 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011ce30:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce37:	83 ec 0c             	sub    $0xc,%esp
f011ce3a:	68 38 ff 12 f0       	push   $0xf012ff38
f011ce3f:	e8 47 41 fe ff       	call   f0100f8b <cprintf>
f011ce44:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ce47:	e8 59 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ce4c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ce4f:	74 17                	je     f011ce68 <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce51:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce58:	83 ec 0c             	sub    $0xc,%esp
f011ce5b:	68 58 ff 12 f0       	push   $0xf012ff58
f011ce60:	e8 26 41 fe ff       	call   f0100f8b <cprintf>
f011ce65:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011ce68:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011ce6f:	e8 48 1b ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011ce74:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ce77:	e8 29 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ce7c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011ce7f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ce82:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ce85:	29 c2                	sub    %eax,%edx
f011ce87:	89 d0                	mov    %edx,%eax
f011ce89:	83 ec 0c             	sub    $0xc,%esp
f011ce8c:	50                   	push   %eax
f011ce8d:	e8 0d c7 fe ff       	call   f010959f <kmalloc>
f011ce92:	83 c4 10             	add    $0x10,%esp
f011ce95:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011ce9b:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011cea2:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011cea8:	6a 01                	push   $0x1
f011ceaa:	ff 75 b8             	pushl  -0x48(%ebp)
f011cead:	ff 75 ac             	pushl  -0x54(%ebp)
f011ceb0:	50                   	push   %eax
f011ceb1:	e8 22 3f ff ff       	call   f0110dd8 <check_block>
f011ceb6:	83 c4 10             	add    $0x10,%esp
f011ceb9:	85 c0                	test   %eax,%eax
f011cebb:	75 17                	jne    f011ced4 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011cebd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cec4:	83 ec 0c             	sub    $0xc,%esp
f011cec7:	68 c6 ff 12 f0       	push   $0xf012ffc6
f011cecc:	e8 ba 40 fe ff       	call   f0100f8b <cprintf>
f011ced1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ced4:	e8 e3 1a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011ced9:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cedc:	74 17                	je     f011cef5 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011cede:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cee5:	83 ec 0c             	sub    $0xc,%esp
f011cee8:	68 e0 ff 12 f0       	push   $0xf012ffe0
f011ceed:	e8 99 40 fe ff       	call   f0100f8b <cprintf>
f011cef2:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cef5:	e8 ab 79 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cefa:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cefd:	74 17                	je     f011cf16 <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ceff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf06:	83 ec 0c             	sub    $0xc,%esp
f011cf09:	68 00 00 13 f0       	push   $0xf0130000
f011cf0e:	e8 78 40 fe ff       	call   f0100f8b <cprintf>
f011cf13:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011cf16:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011cf1d:	e8 9a 1a ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011cf22:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011cf25:	e8 7b 79 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cf2a:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011cf2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cf30:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011cf33:	29 c2                	sub    %eax,%edx
f011cf35:	89 d0                	mov    %edx,%eax
f011cf37:	83 ec 0c             	sub    $0xc,%esp
f011cf3a:	50                   	push   %eax
f011cf3b:	e8 5f c6 fe ff       	call   f010959f <kmalloc>
f011cf40:	83 c4 10             	add    $0x10,%esp
f011cf43:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011cf49:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011cf50:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011cf56:	6a 01                	push   $0x1
f011cf58:	ff 75 b8             	pushl  -0x48(%ebp)
f011cf5b:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf5e:	50                   	push   %eax
f011cf5f:	e8 74 3e ff ff       	call   f0110dd8 <check_block>
f011cf64:	83 c4 10             	add    $0x10,%esp
f011cf67:	85 c0                	test   %eax,%eax
f011cf69:	75 17                	jne    f011cf82 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011cf6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf72:	83 ec 0c             	sub    $0xc,%esp
f011cf75:	68 6e 00 13 f0       	push   $0xf013006e
f011cf7a:	e8 0c 40 fe ff       	call   f0100f8b <cprintf>
f011cf7f:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011cf82:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011cf85:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011cf88:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011cf8f:	6a 00                	push   $0x0
f011cf91:	ff 75 98             	pushl  -0x68(%ebp)
f011cf94:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf97:	ff 75 ac             	pushl  -0x54(%ebp)
f011cf9a:	e8 39 3e ff ff       	call   f0110dd8 <check_block>
f011cf9f:	83 c4 10             	add    $0x10,%esp
f011cfa2:	85 c0                	test   %eax,%eax
f011cfa4:	75 17                	jne    f011cfbd <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011cfa6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfad:	83 ec 0c             	sub    $0xc,%esp
f011cfb0:	68 85 00 13 f0       	push   $0xf0130085
f011cfb5:	e8 d1 3f fe ff       	call   f0100f8b <cprintf>
f011cfba:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011cfbd:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cfc0:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011cfc5:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011cfc8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cfcb:	8b 00                	mov    (%eax),%eax
f011cfcd:	83 f8 01             	cmp    $0x1,%eax
f011cfd0:	74 17                	je     f011cfe9 <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011cfd2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfd9:	83 ec 0c             	sub    $0xc,%esp
f011cfdc:	68 9c 00 13 f0       	push   $0xf013009c
f011cfe1:	e8 a5 3f fe ff       	call   f0100f8b <cprintf>
f011cfe6:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011cfe9:	83 ec 0c             	sub    $0xc,%esp
f011cfec:	6a 00                	push   $0x0
f011cfee:	e8 79 c4 fe ff       	call   f010946c <sbrk>
f011cff3:	83 c4 10             	add    $0x10,%esp
f011cff6:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011cff9:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cffc:	05 00 20 00 00       	add    $0x2000,%eax
f011d001:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011d004:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d007:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011d00a:	74 1d                	je     f011d029 <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011d00c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d013:	83 ec 04             	sub    $0x4,%esp
f011d016:	ff 75 90             	pushl  -0x70(%ebp)
f011d019:	ff 75 8c             	pushl  -0x74(%ebp)
f011d01c:	68 c8 00 13 f0       	push   $0xf01300c8
f011d021:	e8 65 3f fe ff       	call   f0100f8b <cprintf>
f011d026:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d029:	e8 8e 19 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011d02e:	89 c2                	mov    %eax,%edx
f011d030:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d033:	29 d0                	sub    %edx,%eax
f011d035:	83 f8 01             	cmp    $0x1,%eax
f011d038:	74 17                	je     f011d051 <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011d03a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d041:	83 ec 0c             	sub    $0xc,%esp
f011d044:	68 fc 00 13 f0       	push   $0xf01300fc
f011d049:	e8 3d 3f fe ff       	call   f0100f8b <cprintf>
f011d04e:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d051:	e8 4f 78 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d056:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d059:	74 17                	je     f011d072 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d05b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d062:	83 ec 0c             	sub    $0xc,%esp
f011d065:	68 1c 01 13 f0       	push   $0xf013011c
f011d06a:	e8 1c 3f fe ff       	call   f0100f8b <cprintf>
f011d06f:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011d072:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d076:	74 04                	je     f011d07c <test_ksbrk+0x78e>
		eval += 25;
f011d078:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011d07c:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011d083:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011d089:	bb 58 04 13 f0       	mov    $0xf0130458,%ebx
f011d08e:	ba 05 00 00 00       	mov    $0x5,%edx
f011d093:	89 c7                	mov    %eax,%edi
f011d095:	89 de                	mov    %ebx,%esi
f011d097:	89 d1                	mov    %edx,%ecx
f011d099:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011d09b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011d0a1:	bb 6c 04 13 f0       	mov    $0xf013046c,%ebx
f011d0a6:	ba 05 00 00 00       	mov    $0x5,%edx
f011d0ab:	89 c7                	mov    %eax,%edi
f011d0ad:	89 de                	mov    %ebx,%esi
f011d0af:	89 d1                	mov    %edx,%ecx
f011d0b1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011d0b3:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011d0b9:	bb 80 04 13 f0       	mov    $0xf0130480,%ebx
f011d0be:	ba 05 00 00 00       	mov    $0x5,%edx
f011d0c3:	89 c7                	mov    %eax,%edi
f011d0c5:	89 de                	mov    %ebx,%esi
f011d0c7:	89 d1                	mov    %edx,%ecx
f011d0c9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011d0cb:	83 ec 04             	sub    $0x4,%esp
f011d0ce:	68 00 00 00 f8       	push   $0xf8000000
f011d0d3:	68 00 10 00 00       	push   $0x1000
f011d0d8:	68 00 00 00 f6       	push   $0xf6000000
f011d0dd:	e8 73 c2 fe ff       	call   f0109355 <initialize_kheap_dynamic_allocator>
f011d0e2:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d0e5:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011d0ec:	eb 1b                	jmp    f011d109 <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011d0ee:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011d0f3:	83 ec 08             	sub    $0x8,%esp
f011d0f6:	ff 75 dc             	pushl  -0x24(%ebp)
f011d0f9:	50                   	push   %eax
f011d0fa:	e8 e0 b6 fe ff       	call   f01087df <unmap_frame>
f011d0ff:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011d102:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011d109:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011d110:	76 dc                	jbe    f011d0ee <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011d112:	83 ec 0c             	sub    $0xc,%esp
f011d115:	68 8c 01 13 f0       	push   $0xf013018c
f011d11a:	e8 6c 3e fe ff       	call   f0100f8b <cprintf>
f011d11f:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d122:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d129:	e9 21 01 00 00       	jmp    f011d24f <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d12e:	e8 89 18 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011d133:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d136:	e8 6a 77 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d13b:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d13e:	83 ec 0c             	sub    $0xc,%esp
f011d141:	6a 00                	push   $0x0
f011d143:	e8 24 c3 fe ff       	call   f010946c <sbrk>
f011d148:	83 c4 10             	add    $0x10,%esp
f011d14b:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d14e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d151:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d158:	83 ec 0c             	sub    $0xc,%esp
f011d15b:	50                   	push   %eax
f011d15c:	e8 0b c3 fe ff       	call   f010946c <sbrk>
f011d161:	83 c4 10             	add    $0x10,%esp
f011d164:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011d167:	83 ec 0c             	sub    $0xc,%esp
f011d16a:	6a 00                	push   $0x0
f011d16c:	e8 fb c2 fe ff       	call   f010946c <sbrk>
f011d171:	83 c4 10             	add    $0x10,%esp
f011d174:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d177:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d17e:	e8 22 77 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d183:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d186:	74 1a                	je     f011d1a2 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011d188:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d18f:	83 ec 08             	sub    $0x8,%esp
f011d192:	ff 75 d8             	pushl  -0x28(%ebp)
f011d195:	68 d0 01 13 f0       	push   $0xf01301d0
f011d19a:	e8 ec 3d fe ff       	call   f0100f8b <cprintf>
f011d19f:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011d1a2:	e8 15 18 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011d1a7:	89 c2                	mov    %eax,%edx
f011d1a9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d1ac:	29 d0                	sub    %edx,%eax
f011d1ae:	89 c2                	mov    %eax,%edx
f011d1b0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d1b3:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d1ba:	39 c2                	cmp    %eax,%edx
f011d1bc:	74 1a                	je     f011d1d8 <test_ksbrk+0x8ea>
			{
				correct = 0;
f011d1be:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011d1c5:	83 ec 08             	sub    $0x8,%esp
f011d1c8:	ff 75 d8             	pushl  -0x28(%ebp)
f011d1cb:	68 40 02 13 f0       	push   $0xf0130240
f011d1d0:	e8 b6 3d fe ff       	call   f0100f8b <cprintf>
f011d1d5:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d1d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d1db:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d1e2:	8b 45 80             	mov    -0x80(%ebp),%eax
f011d1e5:	39 c2                	cmp    %eax,%edx
f011d1e7:	74 25                	je     f011d20e <test_ksbrk+0x920>
			{
				correct = 0;
f011d1e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d1f0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d1f3:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d1fa:	ff 75 80             	pushl  -0x80(%ebp)
f011d1fd:	50                   	push   %eax
f011d1fe:	ff 75 d8             	pushl  -0x28(%ebp)
f011d201:	68 60 02 13 f0       	push   $0xf0130260
f011d206:	e8 80 3d fe ff       	call   f0100f8b <cprintf>
f011d20b:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d20e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d211:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d218:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d21b:	74 25                	je     f011d242 <test_ksbrk+0x954>
			{
				correct = 0;
f011d21d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d224:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d227:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d22e:	ff 75 90             	pushl  -0x70(%ebp)
f011d231:	50                   	push   %eax
f011d232:	ff 75 d8             	pushl  -0x28(%ebp)
f011d235:	68 98 02 13 f0       	push   $0xf0130298
f011d23a:	e8 4c 3d fe ff       	call   f0100f8b <cprintf>
f011d23f:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d242:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d246:	74 04                	je     f011d24c <test_ksbrk+0x95e>
				eval += 10;
f011d248:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011d24c:	ff 45 d8             	incl   -0x28(%ebp)
f011d24f:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d252:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d255:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011d258:	39 c2                	cmp    %eax,%edx
f011d25a:	0f 87 ce fe ff ff    	ja     f011d12e <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011d260:	83 ec 0c             	sub    $0xc,%esp
f011d263:	68 cc 02 13 f0       	push   $0xf01302cc
f011d268:	e8 1e 3d fe ff       	call   f0100f8b <cprintf>
f011d26d:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d270:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011d273:	48                   	dec    %eax
f011d274:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011d277:	e9 18 01 00 00       	jmp    f011d394 <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011d27c:	e8 3b 17 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011d281:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011d284:	e8 1c 76 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d289:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011d28c:	83 ec 0c             	sub    $0xc,%esp
f011d28f:	6a 00                	push   $0x0
f011d291:	e8 d6 c1 fe ff       	call   f010946c <sbrk>
f011d296:	83 c4 10             	add    $0x10,%esp
f011d299:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011d29c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d29f:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011d2a6:	83 ec 0c             	sub    $0xc,%esp
f011d2a9:	50                   	push   %eax
f011d2aa:	e8 bd c1 fe ff       	call   f010946c <sbrk>
f011d2af:	83 c4 10             	add    $0x10,%esp
f011d2b2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011d2b8:	83 ec 0c             	sub    $0xc,%esp
f011d2bb:	6a 00                	push   $0x0
f011d2bd:	e8 aa c1 fe ff       	call   f010946c <sbrk>
f011d2c2:	83 c4 10             	add    $0x10,%esp
f011d2c5:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011d2c8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d2cf:	e8 d1 75 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d2d4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d2d7:	74 1a                	je     f011d2f3 <test_ksbrk+0xa05>
			{
				correct = 0;
f011d2d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011d2e0:	83 ec 08             	sub    $0x8,%esp
f011d2e3:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d2e6:	68 1c 03 13 f0       	push   $0xf013031c
f011d2eb:	e8 9b 3c fe ff       	call   f0100f8b <cprintf>
f011d2f0:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d2f3:	e8 c4 16 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011d2f8:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d2fb:	74 1a                	je     f011d317 <test_ksbrk+0xa29>
			{
				correct = 0;
f011d2fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011d304:	83 ec 08             	sub    $0x8,%esp
f011d307:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d30a:	68 8c 03 13 f0       	push   $0xf013038c
f011d30f:	e8 77 3c fe ff       	call   f0100f8b <cprintf>
f011d314:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011d317:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d31a:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011d321:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d327:	39 c2                	cmp    %eax,%edx
f011d329:	74 28                	je     f011d353 <test_ksbrk+0xa65>
			{
				correct = 0;
f011d32b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011d332:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d335:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011d33c:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011d342:	50                   	push   %eax
f011d343:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d346:	68 ac 03 13 f0       	push   $0xf01303ac
f011d34b:	e8 3b 3c fe ff       	call   f0100f8b <cprintf>
f011d350:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011d353:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d356:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d35d:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011d360:	74 25                	je     f011d387 <test_ksbrk+0xa99>
			{
				correct = 0;
f011d362:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011d369:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d36c:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011d373:	ff 75 90             	pushl  -0x70(%ebp)
f011d376:	50                   	push   %eax
f011d377:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d37a:	68 e4 03 13 f0       	push   $0xf01303e4
f011d37f:	e8 07 3c fe ff       	call   f0100f8b <cprintf>
f011d384:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011d387:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d38b:	74 04                	je     f011d391 <test_ksbrk+0xaa3>
				eval += 10;
f011d38d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011d391:	ff 45 d4             	incl   -0x2c(%ebp)
f011d394:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d397:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011d39a:	0f 82 dc fe ff ff    	jb     f011d27c <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011d3a0:	83 ec 08             	sub    $0x8,%esp
f011d3a3:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d3a6:	68 18 04 13 f0       	push   $0xf0130418
f011d3ab:	e8 db 3b fe ff       	call   f0100f8b <cprintf>
f011d3b0:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011d3b3:	83 ec 0c             	sub    $0xc,%esp
f011d3b6:	68 42 04 13 f0       	push   $0xf0130442
f011d3bb:	e8 cb 3b fe ff       	call   f0100f8b <cprintf>
f011d3c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f011d3c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011d3c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d3cb:	5b                   	pop    %ebx
f011d3cc:	5e                   	pop    %esi
f011d3cd:	5f                   	pop    %edi
f011d3ce:	5d                   	pop    %ebp
f011d3cf:	c3                   	ret    

f011d3d0 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011d3d0:	55                   	push   %ebp
f011d3d1:	89 e5                	mov    %esp,%ebp
f011d3d3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d3d6:	83 ec 04             	sub    $0x4,%esp
f011d3d9:	68 94 04 13 f0       	push   $0xf0130494
f011d3de:	68 c2 08 00 00       	push   $0x8c2
f011d3e3:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d3e8:	e8 4c 2f fe ff       	call   f0100339 <_panic>

f011d3ed <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011d3ed:	55                   	push   %ebp
f011d3ee:	89 e5                	mov    %esp,%ebp
f011d3f0:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d3f3:	83 ec 04             	sub    $0x4,%esp
f011d3f6:	68 94 04 13 f0       	push   $0xf0130494
f011d3fb:	68 c7 08 00 00       	push   $0x8c7
f011d400:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d405:	e8 2f 2f fe ff       	call   f0100339 <_panic>

f011d40a <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011d40a:	55                   	push   %ebp
f011d40b:	89 e5                	mov    %esp,%ebp
f011d40d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d410:	83 ec 04             	sub    $0x4,%esp
f011d413:	68 94 04 13 f0       	push   $0xf0130494
f011d418:	68 cc 08 00 00       	push   $0x8cc
f011d41d:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d422:	e8 12 2f fe ff       	call   f0100339 <_panic>

f011d427 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011d427:	55                   	push   %ebp
f011d428:	89 e5                	mov    %esp,%ebp
f011d42a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d42d:	83 ec 04             	sub    $0x4,%esp
f011d430:	68 94 04 13 f0       	push   $0xf0130494
f011d435:	68 d1 08 00 00       	push   $0x8d1
f011d43a:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d43f:	e8 f5 2e fe ff       	call   f0100339 <_panic>

f011d444 <test_kfree>:
}

int test_kfree()
{
f011d444:	55                   	push   %ebp
f011d445:	89 e5                	mov    %esp,%ebp
f011d447:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d44a:	83 ec 04             	sub    $0x4,%esp
f011d44d:	68 94 04 13 f0       	push   $0xf0130494
f011d452:	68 d6 08 00 00       	push   $0x8d6
f011d457:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d45c:	e8 d8 2e fe ff       	call   f0100339 <_panic>

f011d461 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011d461:	55                   	push   %ebp
f011d462:	89 e5                	mov    %esp,%ebp
f011d464:	57                   	push   %edi
f011d465:	56                   	push   %esi
f011d466:	53                   	push   %ebx
f011d467:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011d46d:	a0 dc fd 17 f0       	mov    0xf017fddc,%al
f011d472:	84 c0                	test   %al,%al
f011d474:	74 56                	je     f011d4cc <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011d476:	c6 05 dc fd 17 f0 00 	movb   $0x0,0xf017fddc
		initFreeFrames = sys_calculate_free_frames() ;
f011d47d:	e8 3a 15 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011d482:	a3 e8 d4 b0 f0       	mov    %eax,0xf0b0d4e8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011d487:	e8 19 74 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d48c:	a3 e4 d4 b0 f0       	mov    %eax,0xf0b0d4e4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011d491:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d497:	bb f9 05 13 f0       	mov    $0xf01305f9,%ebx
f011d49c:	ba 11 00 00 00       	mov    $0x11,%edx
f011d4a1:	89 c7                	mov    %eax,%edi
f011d4a3:	89 de                	mov    %ebx,%esi
f011d4a5:	89 d1                	mov    %edx,%ecx
f011d4a7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011d4a9:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011d4af:	b9 53 00 00 00       	mov    $0x53,%ecx
f011d4b4:	b0 00                	mov    $0x0,%al
f011d4b6:	89 d7                	mov    %edx,%edi
f011d4b8:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011d4ba:	83 ec 0c             	sub    $0xc,%esp
f011d4bd:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011d4c3:	50                   	push   %eax
f011d4c4:	e8 32 4a fe ff       	call   f0101efb <execute_command>
f011d4c9:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011d4cc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011d4d3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d4da:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f011d4df:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d4e2:	eb 2b                	jmp    f011d50f <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011d4e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d4e7:	83 c0 20             	add    $0x20,%eax
f011d4ea:	83 ec 08             	sub    $0x8,%esp
f011d4ed:	68 a4 04 13 f0       	push   $0xf01304a4
f011d4f2:	50                   	push   %eax
f011d4f3:	e8 ea 28 00 00       	call   f011fde2 <strcmp>
f011d4f8:	83 c4 10             	add    $0x10,%esp
f011d4fb:	85 c0                	test   %eax,%eax
f011d4fd:	75 08                	jne    f011d507 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011d4ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d502:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011d505:	eb 2f                	jmp    f011d536 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011d507:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011d50c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011d50f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d513:	74 08                	je     f011d51d <test_three_creation_functions+0xbc>
f011d515:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d518:	8b 40 08             	mov    0x8(%eax),%eax
f011d51b:	eb 05                	jmp    f011d522 <test_three_creation_functions+0xc1>
f011d51d:	b8 00 00 00 00       	mov    $0x0,%eax
f011d522:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f011d527:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011d52c:	85 c0                	test   %eax,%eax
f011d52e:	75 b4                	jne    f011d4e4 <test_three_creation_functions+0x83>
f011d530:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d534:	75 ae                	jne    f011d4e4 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011d536:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d539:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011d53f:	85 c0                	test   %eax,%eax
f011d541:	74 17                	je     f011d55a <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011d543:	83 ec 04             	sub    $0x4,%esp
f011d546:	68 ac 04 13 f0       	push   $0xf01304ac
f011d54b:	68 f7 08 00 00       	push   $0x8f7
f011d550:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d555:	e8 df 2d fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011d55a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d55d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011d563:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011d566:	e8 51 14 ff ff       	call   f010e9bc <sys_calculate_free_frames>
f011d56b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011d56e:	e8 32 73 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011d573:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d576:	a1 e4 d4 b0 f0       	mov    0xf0b0d4e4,%eax
f011d57b:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011d57e:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d581:	74 17                	je     f011d59a <test_three_creation_functions+0x139>
f011d583:	83 ec 04             	sub    $0x4,%esp
f011d586:	68 ec ce 12 f0       	push   $0xf012ceec
f011d58b:	68 01 09 00 00       	push   $0x901
f011d590:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d595:	e8 9f 2d fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011d59a:	a1 e8 d4 b0 f0       	mov    0xf0b0d4e8,%eax
f011d59f:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011d5a2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d5a5:	83 c2 15             	add    $0x15,%edx
f011d5a8:	39 d0                	cmp    %edx,%eax
f011d5aa:	74 17                	je     f011d5c3 <test_three_creation_functions+0x162>
f011d5ac:	83 ec 04             	sub    $0x4,%esp
f011d5af:	68 fc 04 13 f0       	push   $0xf01304fc
f011d5b4:	68 03 09 00 00       	push   $0x903
f011d5b9:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d5be:	e8 76 2d fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011d5c3:	83 ec 0c             	sub    $0xc,%esp
f011d5c6:	68 00 10 00 00       	push   $0x1000
f011d5cb:	e8 cf bf fe ff       	call   f010959f <kmalloc>
f011d5d0:	83 c4 10             	add    $0x10,%esp
f011d5d3:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011d5d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d5d9:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011d5de:	74 17                	je     f011d5f7 <test_three_creation_functions+0x196>
f011d5e0:	83 ec 04             	sub    $0x4,%esp
f011d5e3:	68 3c 05 13 f0       	push   $0xf013053c
f011d5e8:	68 07 09 00 00       	push   $0x907
f011d5ed:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d5f2:	e8 42 2d fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011d5f7:	83 ec 0c             	sub    $0xc,%esp
f011d5fa:	68 ac 05 13 f0       	push   $0xf01305ac
f011d5ff:	e8 87 39 fe ff       	call   f0100f8b <cprintf>
f011d604:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d607:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011d60c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d60f:	5b                   	pop    %ebx
f011d610:	5e                   	pop    %esi
f011d611:	5f                   	pop    %edi
f011d612:	5d                   	pop    %ebp
f011d613:	c3                   	ret    

f011d614 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011d614:	55                   	push   %ebp
f011d615:	89 e5                	mov    %esp,%ebp
f011d617:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d61a:	83 ec 04             	sub    $0x4,%esp
f011d61d:	68 94 04 13 f0       	push   $0xf0130494
f011d622:	68 15 09 00 00       	push   $0x915
f011d627:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d62c:	e8 08 2d fe ff       	call   f0100339 <_panic>

f011d631 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011d631:	55                   	push   %ebp
f011d632:	89 e5                	mov    %esp,%ebp
f011d634:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d637:	83 ec 04             	sub    $0x4,%esp
f011d63a:	68 94 04 13 f0       	push   $0xf0130494
f011d63f:	68 1d 09 00 00       	push   $0x91d
f011d644:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d649:	e8 eb 2c fe ff       	call   f0100339 <_panic>

f011d64e <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011d64e:	55                   	push   %ebp
f011d64f:	89 e5                	mov    %esp,%ebp
f011d651:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d654:	83 ec 04             	sub    $0x4,%esp
f011d657:	68 94 04 13 f0       	push   $0xf0130494
f011d65c:	68 24 09 00 00       	push   $0x924
f011d661:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d666:	e8 ce 2c fe ff       	call   f0100339 <_panic>

f011d66b <test_kfreelast>:

}


int test_kfreelast()
{
f011d66b:	55                   	push   %ebp
f011d66c:	89 e5                	mov    %esp,%ebp
f011d66e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d671:	83 ec 04             	sub    $0x4,%esp
f011d674:	68 94 04 13 f0       	push   $0xf0130494
f011d679:	68 2b 09 00 00       	push   $0x92b
f011d67e:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d683:	e8 b1 2c fe ff       	call   f0100339 <_panic>

f011d688 <test_krealloc>:

}

int test_krealloc() {
f011d688:	55                   	push   %ebp
f011d689:	89 e5                	mov    %esp,%ebp
f011d68b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d68e:	83 ec 04             	sub    $0x4,%esp
f011d691:	68 94 04 13 f0       	push   $0xf0130494
f011d696:	68 30 09 00 00       	push   $0x930
f011d69b:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d6a0:	e8 94 2c fe ff       	call   f0100339 <_panic>

f011d6a5 <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011d6a5:	55                   	push   %ebp
f011d6a6:	89 e5                	mov    %esp,%ebp
f011d6a8:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d6ab:	83 ec 04             	sub    $0x4,%esp
f011d6ae:	68 94 04 13 f0       	push   $0xf0130494
f011d6b3:	68 35 09 00 00       	push   $0x935
f011d6b8:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d6bd:	e8 77 2c fe ff       	call   f0100339 <_panic>

f011d6c2 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011d6c2:	55                   	push   %ebp
f011d6c3:	89 e5                	mov    %esp,%ebp
f011d6c5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d6c8:	83 ec 04             	sub    $0x4,%esp
f011d6cb:	68 94 04 13 f0       	push   $0xf0130494
f011d6d0:	68 3b 09 00 00       	push   $0x93b
f011d6d5:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d6da:	e8 5a 2c fe ff       	call   f0100339 <_panic>

f011d6df <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011d6df:	55                   	push   %ebp
f011d6e0:	89 e5                	mov    %esp,%ebp
f011d6e2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d6e5:	83 ec 04             	sub    $0x4,%esp
f011d6e8:	68 94 04 13 f0       	push   $0xf0130494
f011d6ed:	68 40 09 00 00       	push   $0x940
f011d6f2:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d6f7:	e8 3d 2c fe ff       	call   f0100339 <_panic>

f011d6fc <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011d6fc:	55                   	push   %ebp
f011d6fd:	89 e5                	mov    %esp,%ebp
f011d6ff:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011d702:	83 ec 04             	sub    $0x4,%esp
f011d705:	68 94 04 13 f0       	push   $0xf0130494
f011d70a:	68 46 09 00 00       	push   $0x946
f011d70f:	68 d3 ce 12 f0       	push   $0xf012ced3
f011d714:	e8 20 2c fe ff       	call   f0100339 <_panic>

f011d719 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d719:	55                   	push   %ebp
f011d71a:	89 e5                	mov    %esp,%ebp
f011d71c:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d71f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d726:	e9 84 00 00 00       	jmp    f011d7af <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d72b:	83 ec 08             	sub    $0x8,%esp
f011d72e:	ff 75 f4             	pushl  -0xc(%ebp)
f011d731:	68 60 06 13 f0       	push   $0xf0130660
f011d736:	e8 50 38 fe ff       	call   f0100f8b <cprintf>
f011d73b:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d73e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d745:	eb 4c                	jmp    f011d793 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d747:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d74a:	89 d0                	mov    %edx,%eax
f011d74c:	c1 e0 02             	shl    $0x2,%eax
f011d74f:	01 d0                	add    %edx,%eax
f011d751:	c1 e0 03             	shl    $0x3,%eax
f011d754:	89 c2                	mov    %eax,%edx
f011d756:	8b 45 08             	mov    0x8(%ebp),%eax
f011d759:	01 c2                	add    %eax,%edx
f011d75b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d75e:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d761:	85 c0                	test   %eax,%eax
f011d763:	74 36                	je     f011d79b <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d765:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d768:	89 d0                	mov    %edx,%eax
f011d76a:	c1 e0 02             	shl    $0x2,%eax
f011d76d:	01 d0                	add    %edx,%eax
f011d76f:	c1 e0 03             	shl    $0x3,%eax
f011d772:	89 c2                	mov    %eax,%edx
f011d774:	8b 45 08             	mov    0x8(%ebp),%eax
f011d777:	01 c2                	add    %eax,%edx
f011d779:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d77c:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d77f:	83 ec 08             	sub    $0x8,%esp
f011d782:	50                   	push   %eax
f011d783:	68 68 06 13 f0       	push   $0xf0130668
f011d788:	e8 fe 37 fe ff       	call   f0100f8b <cprintf>
f011d78d:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d790:	ff 45 f0             	incl   -0x10(%ebp)
f011d793:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011d797:	7e ae                	jle    f011d747 <print_order+0x2e>
f011d799:	eb 01                	jmp    f011d79c <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011d79b:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011d79c:	83 ec 0c             	sub    $0xc,%esp
f011d79f:	68 6d 06 13 f0       	push   $0xf013066d
f011d7a4:	e8 e2 37 fe ff       	call   f0100f8b <cprintf>
f011d7a9:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d7ac:	ff 45 f4             	incl   -0xc(%ebp)
f011d7af:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011d7b3:	0f 8e 72 ff ff ff    	jle    f011d72b <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011d7b9:	90                   	nop
f011d7ba:	c9                   	leave  
f011d7bb:	c3                   	ret    

f011d7bc <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011d7bc:	55                   	push   %ebp
f011d7bd:	89 e5                	mov    %esp,%ebp
f011d7bf:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011d7c2:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011d7c9:	83 ec 0c             	sub    $0xc,%esp
f011d7cc:	68 e0 15 6c f0       	push   $0xf06c15e0
f011d7d1:	e8 52 25 ff ff       	call   f010fd28 <acquire_spinlock>
f011d7d6:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011d7d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011d7e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d7e7:	8b 55 0c             	mov    0xc(%ebp),%edx
f011d7ea:	8b 45 10             	mov    0x10(%ebp),%eax
f011d7ed:	01 d0                	add    %edx,%eax
f011d7ef:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d7f2:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011d7f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d7fa:	a1 64 16 6c f0       	mov    0xf06c1664,%eax
f011d7ff:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d802:	ff 75 e8             	pushl  -0x18(%ebp)
f011d805:	ff 75 0c             	pushl  0xc(%ebp)
f011d808:	ff 75 08             	pushl  0x8(%ebp)
f011d80b:	68 70 06 13 f0       	push   $0xf0130670
f011d810:	e8 76 37 fe ff       	call   f0100f8b <cprintf>
f011d815:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d818:	eb 34                	jmp    f011d84e <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d81a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d81d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d820:	7d 05                	jge    f011d827 <find_in_range+0x6b>
			{
				i++;
f011d822:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d825:	eb 1e                	jmp    f011d845 <find_in_range+0x89>
			}
			if (i >= end)
f011d827:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d82a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d82d:	7d 29                	jge    f011d858 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011d82f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d832:	8b 40 10             	mov    0x10(%eax),%eax
f011d835:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d838:	75 08                	jne    f011d842 <find_in_range+0x86>
			{
				ret = i;
f011d83a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d83d:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011d840:	eb 17                	jmp    f011d859 <find_in_range+0x9d>
			}
			i++;
f011d842:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d845:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d848:	8b 40 0c             	mov    0xc(%eax),%eax
f011d84b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d84e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d851:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d854:	7c c4                	jl     f011d81a <find_in_range+0x5e>
f011d856:	eb 01                	jmp    f011d859 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011d858:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d859:	83 ec 0c             	sub    $0xc,%esp
f011d85c:	68 e0 15 6c f0       	push   $0xf06c15e0
f011d861:	e8 49 25 ff ff       	call   f010fdaf <release_spinlock>
f011d866:	83 c4 10             	add    $0x10,%esp
	return ret;
f011d869:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011d86c:	c9                   	leave  
f011d86d:	c3                   	ret    

f011d86e <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011d86e:	55                   	push   %ebp
f011d86f:	89 e5                	mov    %esp,%ebp
f011d871:	57                   	push   %edi
f011d872:	56                   	push   %esi
f011d873:	53                   	push   %ebx
f011d874:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d877:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011d87c:	84 c0                	test   %al,%al
f011d87e:	0f 84 9b 01 00 00    	je     f011da1f <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011d884:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011d88b:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d88e:	bb e8 07 13 f0       	mov    $0xf01307e8,%ebx
f011d893:	ba 05 00 00 00       	mov    $0x5,%edx
f011d898:	89 c7                	mov    %eax,%edi
f011d89a:	89 de                	mov    %ebx,%esi
f011d89c:	89 d1                	mov    %edx,%ecx
f011d89e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d8a0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d8a7:	e9 44 01 00 00       	jmp    f011d9f0 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011d8ac:	6a 00                	push   $0x0
f011d8ae:	6a 00                	push   $0x0
f011d8b0:	68 f4 01 00 00       	push   $0x1f4
f011d8b5:	68 a1 06 13 f0       	push   $0xf01306a1
f011d8ba:	e8 5c d7 fe ff       	call   f010b01b <env_create>
f011d8bf:	83 c4 10             	add    $0x10,%esp
f011d8c2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d8c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d8c8:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d8cd:	99                   	cltd   
f011d8ce:	f7 f9                	idiv   %ecx
f011d8d0:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d8d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d8d6:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d8da:	83 ec 08             	sub    $0x8,%esp
f011d8dd:	50                   	push   %eax
f011d8de:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d8e1:	e8 a0 8d fe ff       	call   f0106686 <env_set_nice>
f011d8e6:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d8e9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d8ed:	75 14                	jne    f011d903 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011d8ef:	83 ec 04             	sub    $0x4,%esp
f011d8f2:	68 a9 06 13 f0       	push   $0xf01306a9
f011d8f7:	6a 53                	push   $0x53
f011d8f9:	68 c2 06 13 f0       	push   $0xf01306c2
f011d8fe:	e8 36 2a fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011d903:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d906:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d90c:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d911:	74 14                	je     f011d927 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011d913:	83 ec 04             	sub    $0x4,%esp
f011d916:	68 e0 06 13 f0       	push   $0xf01306e0
f011d91b:	6a 55                	push   $0x55
f011d91d:	68 c2 06 13 f0       	push   $0xf01306c2
f011d922:	e8 12 2a fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d927:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d92a:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d92e:	83 c0 0a             	add    $0xa,%eax
f011d931:	83 f8 14             	cmp    $0x14,%eax
f011d934:	0f 87 a5 00 00 00    	ja     f011d9df <test_bsd_nice_0+0x171>
f011d93a:	8b 04 85 fc 07 13 f0 	mov    -0xfecf804(,%eax,4),%eax
f011d941:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d943:	a1 7c 13 6c f0       	mov    0xf06c137c,%eax
f011d948:	8d 50 01             	lea    0x1(%eax),%edx
f011d94b:	89 15 7c 13 6c f0    	mov    %edx,0xf06c137c
f011d951:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d954:	8b 52 10             	mov    0x10(%edx),%edx
f011d957:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d95e:	eb 7f                	jmp    f011d9df <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d960:	a1 80 13 6c f0       	mov    0xf06c1380,%eax
f011d965:	8d 50 01             	lea    0x1(%eax),%edx
f011d968:	89 15 80 13 6c f0    	mov    %edx,0xf06c1380
f011d96e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d971:	8b 52 10             	mov    0x10(%edx),%edx
f011d974:	83 c0 0a             	add    $0xa,%eax
f011d977:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d97e:	eb 5f                	jmp    f011d9df <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d980:	a1 84 13 6c f0       	mov    0xf06c1384,%eax
f011d985:	8d 50 01             	lea    0x1(%eax),%edx
f011d988:	89 15 84 13 6c f0    	mov    %edx,0xf06c1384
f011d98e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d991:	8b 52 10             	mov    0x10(%edx),%edx
f011d994:	83 c0 14             	add    $0x14,%eax
f011d997:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d99e:	eb 3f                	jmp    f011d9df <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d9a0:	a1 88 13 6c f0       	mov    0xf06c1388,%eax
f011d9a5:	8d 50 01             	lea    0x1(%eax),%edx
f011d9a8:	89 15 88 13 6c f0    	mov    %edx,0xf06c1388
f011d9ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d9b1:	8b 52 10             	mov    0x10(%edx),%edx
f011d9b4:	83 c0 1e             	add    $0x1e,%eax
f011d9b7:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d9be:	eb 1f                	jmp    f011d9df <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d9c0:	a1 8c 13 6c f0       	mov    0xf06c138c,%eax
f011d9c5:	8d 50 01             	lea    0x1(%eax),%edx
f011d9c8:	89 15 8c 13 6c f0    	mov    %edx,0xf06c138c
f011d9ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d9d1:	8b 52 10             	mov    0x10(%edx),%edx
f011d9d4:	83 c0 28             	add    $0x28,%eax
f011d9d7:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011d9de:	90                   	nop
			}
			sched_new_env(env);
f011d9df:	83 ec 0c             	sub    $0xc,%esp
f011d9e2:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d9e5:	e8 32 7d fe ff       	call   f010571c <sched_new_env>
f011d9ea:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d9ed:	ff 45 e4             	incl   -0x1c(%ebp)
f011d9f0:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011d9f4:	0f 8e b2 fe ff ff    	jle    f011d8ac <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d9fa:	83 ec 0c             	sub    $0xc,%esp
f011d9fd:	68 10 07 13 f0       	push   $0xf0130710
f011da02:	e8 84 35 fe ff       	call   f0100f8b <cprintf>
f011da07:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011da0a:	83 ec 0c             	sub    $0xc,%esp
f011da0d:	68 5f 07 13 f0       	push   $0xf013075f
f011da12:	e8 e4 44 fe ff       	call   f0101efb <execute_command>
f011da17:	83 c4 10             	add    $0x10,%esp
f011da1a:	e9 c0 00 00 00       	jmp    f011dadf <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011da1f:	83 ec 0c             	sub    $0xc,%esp
f011da22:	68 66 07 13 f0       	push   $0xf0130766
f011da27:	e8 5f 35 fe ff       	call   f0100f8b <cprintf>
f011da2c:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011da2f:	e8 20 84 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011da34:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011da3b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011da42:	e9 87 00 00 00       	jmp    f011dace <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011da47:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011da4e:	eb 52                	jmp    f011daa2 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011da50:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011da53:	8b 14 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%edx
f011da5a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011da5d:	89 c8                	mov    %ecx,%eax
f011da5f:	c1 e0 02             	shl    $0x2,%eax
f011da62:	01 c8                	add    %ecx,%eax
f011da64:	01 c0                	add    %eax,%eax
f011da66:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011da69:	01 c8                	add    %ecx,%eax
f011da6b:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011da72:	83 ec 04             	sub    $0x4,%esp
f011da75:	52                   	push   %edx
f011da76:	ff 75 e0             	pushl  -0x20(%ebp)
f011da79:	50                   	push   %eax
f011da7a:	e8 3d fd ff ff       	call   f011d7bc <find_in_range>
f011da7f:	83 c4 10             	add    $0x10,%esp
f011da82:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011da85:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011da89:	75 14                	jne    f011da9f <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011da8b:	83 ec 04             	sub    $0x4,%esp
f011da8e:	68 78 07 13 f0       	push   $0xf0130778
f011da93:	6a 7b                	push   $0x7b
f011da95:	68 c2 06 13 f0       	push   $0xf01306c2
f011da9a:	e8 9a 28 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011da9f:	ff 45 d8             	incl   -0x28(%ebp)
f011daa2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011daa5:	89 d0                	mov    %edx,%eax
f011daa7:	c1 e0 02             	shl    $0x2,%eax
f011daaa:	01 d0                	add    %edx,%eax
f011daac:	01 c0                	add    %eax,%eax
f011daae:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011dab1:	01 d0                	add    %edx,%eax
f011dab3:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011daba:	85 c0                	test   %eax,%eax
f011dabc:	75 92                	jne    f011da50 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011dabe:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dac1:	8b 04 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%eax
f011dac8:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011dacb:	ff 45 dc             	incl   -0x24(%ebp)
f011dace:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011dad2:	0f 8e 6f ff ff ff    	jle    f011da47 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011dad8:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011dadf:	83 ec 0c             	sub    $0xc,%esp
f011dae2:	68 ac 07 13 f0       	push   $0xf01307ac
f011dae7:	e8 9f 34 fe ff       	call   f0100f8b <cprintf>
f011daec:	83 c4 10             	add    $0x10,%esp
}
f011daef:	90                   	nop
f011daf0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011daf3:	5b                   	pop    %ebx
f011daf4:	5e                   	pop    %esi
f011daf5:	5f                   	pop    %edi
f011daf6:	5d                   	pop    %ebp
f011daf7:	c3                   	ret    

f011daf8 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011daf8:	55                   	push   %ebp
f011daf9:	89 e5                	mov    %esp,%ebp
f011dafb:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011dafe:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011db03:	84 c0                	test   %al,%al
f011db05:	0f 84 50 01 00 00    	je     f011dc5b <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011db0b:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011db12:	6a 00                	push   $0x0
f011db14:	6a 00                	push   $0x0
f011db16:	68 f4 01 00 00       	push   $0x1f4
f011db1b:	68 a1 06 13 f0       	push   $0xf01306a1
f011db20:	e8 f6 d4 fe ff       	call   f010b01b <env_create>
f011db25:	83 c4 10             	add    $0x10,%esp
f011db28:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011db2b:	6a 00                	push   $0x0
f011db2d:	6a 00                	push   $0x0
f011db2f:	68 f4 01 00 00       	push   $0x1f4
f011db34:	68 50 08 13 f0       	push   $0xf0130850
f011db39:	e8 dd d4 fe ff       	call   f010b01b <env_create>
f011db3e:	83 c4 10             	add    $0x10,%esp
f011db41:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011db44:	6a 00                	push   $0x0
f011db46:	6a 00                	push   $0x0
f011db48:	68 f4 01 00 00       	push   $0x1f4
f011db4d:	68 5d 08 13 f0       	push   $0xf013085d
f011db52:	e8 c4 d4 fe ff       	call   f010b01b <env_create>
f011db57:	83 c4 10             	add    $0x10,%esp
f011db5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011db5d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011db61:	74 0c                	je     f011db6f <test_bsd_nice_1+0x77>
f011db63:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011db67:	74 06                	je     f011db6f <test_bsd_nice_1+0x77>
f011db69:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011db6d:	75 17                	jne    f011db86 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011db6f:	83 ec 04             	sub    $0x4,%esp
f011db72:	68 a9 06 13 f0       	push   $0xf01306a9
f011db77:	68 8e 00 00 00       	push   $0x8e
f011db7c:	68 c2 06 13 f0       	push   $0xf01306c2
f011db81:	e8 b3 27 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011db86:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011db89:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db8f:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011db94:	75 20                	jne    f011dbb6 <test_bsd_nice_1+0xbe>
f011db96:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011db99:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011db9f:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dba4:	75 10                	jne    f011dbb6 <test_bsd_nice_1+0xbe>
f011dba6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dba9:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dbaf:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011dbb4:	74 35                	je     f011dbeb <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011dbb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dbb9:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011dbbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dbc2:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011dbc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dbcb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011dbd1:	83 ec 08             	sub    $0x8,%esp
f011dbd4:	51                   	push   %ecx
f011dbd5:	52                   	push   %edx
f011dbd6:	50                   	push   %eax
f011dbd7:	68 6c 08 13 f0       	push   $0xf013086c
f011dbdc:	68 90 00 00 00       	push   $0x90
f011dbe1:	68 c2 06 13 f0       	push   $0xf01306c2
f011dbe6:	e8 4e 27 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011dbeb:	83 ec 0c             	sub    $0xc,%esp
f011dbee:	ff 75 ec             	pushl  -0x14(%ebp)
f011dbf1:	e8 26 7b fe ff       	call   f010571c <sched_new_env>
f011dbf6:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011dbf9:	83 ec 0c             	sub    $0xc,%esp
f011dbfc:	ff 75 e8             	pushl  -0x18(%ebp)
f011dbff:	e8 18 7b fe ff       	call   f010571c <sched_new_env>
f011dc04:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011dc07:	83 ec 0c             	sub    $0xc,%esp
f011dc0a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dc0d:	e8 0a 7b fe ff       	call   f010571c <sched_new_env>
f011dc12:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011dc15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dc18:	8b 40 10             	mov    0x10(%eax),%eax
f011dc1b:	a3 00 d5 b0 f0       	mov    %eax,0xf0b0d500
		prog_orders[1][0] = fibEnv->env_id;
f011dc20:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011dc23:	8b 40 10             	mov    0x10(%eax),%eax
f011dc26:	a3 28 d5 b0 f0       	mov    %eax,0xf0b0d528
		prog_orders[2][0] = fibposnEnv->env_id;
f011dc2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dc2e:	8b 40 10             	mov    0x10(%eax),%eax
f011dc31:	a3 50 d5 b0 f0       	mov    %eax,0xf0b0d550
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011dc36:	83 ec 0c             	sub    $0xc,%esp
f011dc39:	68 10 07 13 f0       	push   $0xf0130710
f011dc3e:	e8 48 33 fe ff       	call   f0100f8b <cprintf>
f011dc43:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011dc46:	83 ec 0c             	sub    $0xc,%esp
f011dc49:	68 5f 07 13 f0       	push   $0xf013075f
f011dc4e:	e8 a8 42 fe ff       	call   f0101efb <execute_command>
f011dc53:	83 c4 10             	add    $0x10,%esp
f011dc56:	e9 9e 00 00 00       	jmp    f011dcf9 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011dc5b:	83 ec 0c             	sub    $0xc,%esp
f011dc5e:	68 66 07 13 f0       	push   $0xf0130766
f011dc63:	e8 23 33 fe ff       	call   f0100f8b <cprintf>
f011dc68:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011dc6b:	e8 e4 81 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011dc70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011dc77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011dc7e:	83 ec 0c             	sub    $0xc,%esp
f011dc81:	68 e0 15 6c f0       	push   $0xf06c15e0
f011dc86:	e8 9d 20 ff ff       	call   f010fd28 <acquire_spinlock>
f011dc8b:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011dc8e:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011dc93:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011dc96:	a1 64 16 6c f0       	mov    0xf06c1664,%eax
f011dc9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dc9e:	eb 41                	jmp    f011dce1 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011dca0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dca3:	89 d0                	mov    %edx,%eax
f011dca5:	c1 e0 02             	shl    $0x2,%eax
f011dca8:	01 d0                	add    %edx,%eax
f011dcaa:	c1 e0 03             	shl    $0x3,%eax
f011dcad:	05 00 d5 b0 f0       	add    $0xf0b0d500,%eax
f011dcb2:	8b 10                	mov    (%eax),%edx
f011dcb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dcb7:	8b 40 10             	mov    0x10(%eax),%eax
f011dcba:	39 c2                	cmp    %eax,%edx
f011dcbc:	74 17                	je     f011dcd5 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011dcbe:	83 ec 04             	sub    $0x4,%esp
f011dcc1:	68 78 07 13 f0       	push   $0xf0130778
f011dcc6:	68 ab 00 00 00       	push   $0xab
f011dccb:	68 c2 06 13 f0       	push   $0xf01306c2
f011dcd0:	e8 64 26 fe ff       	call   f0100339 <_panic>
				i++;
f011dcd5:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011dcd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dcdb:	8b 40 0c             	mov    0xc(%eax),%eax
f011dcde:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011dce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dce4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011dce7:	7c b7                	jl     f011dca0 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011dce9:	83 ec 0c             	sub    $0xc,%esp
f011dcec:	68 e0 15 6c f0       	push   $0xf06c15e0
f011dcf1:	e8 b9 20 ff ff       	call   f010fdaf <release_spinlock>
f011dcf6:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011dcf9:	83 ec 0c             	sub    $0xc,%esp
f011dcfc:	68 d8 08 13 f0       	push   $0xf01308d8
f011dd01:	e8 85 32 fe ff       	call   f0100f8b <cprintf>
f011dd06:	83 c4 10             	add    $0x10,%esp
}
f011dd09:	90                   	nop
f011dd0a:	c9                   	leave  
f011dd0b:	c3                   	ret    

f011dd0c <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011dd0c:	55                   	push   %ebp
f011dd0d:	89 e5                	mov    %esp,%ebp
f011dd0f:	57                   	push   %edi
f011dd10:	56                   	push   %esi
f011dd11:	53                   	push   %ebx
f011dd12:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011dd15:	a0 dd fd 17 f0       	mov    0xf017fddd,%al
f011dd1a:	84 c0                	test   %al,%al
f011dd1c:	0f 84 ae 01 00 00    	je     f011ded0 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011dd22:	83 ec 0c             	sub    $0xc,%esp
f011dd25:	6a 01                	push   $0x1
f011dd27:	e8 fe 10 00 00       	call   f011ee2a <chksch>
f011dd2c:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011dd2f:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011dd36:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dd39:	bb 5c 09 13 f0       	mov    $0xf013095c,%ebx
f011dd3e:	ba 05 00 00 00       	mov    $0x5,%edx
f011dd43:	89 c7                	mov    %eax,%edi
f011dd45:	89 de                	mov    %ebx,%esi
f011dd47:	89 d1                	mov    %edx,%ecx
f011dd49:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011dd4b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011dd52:	e9 4a 01 00 00       	jmp    f011dea1 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011dd57:	6a 00                	push   $0x0
f011dd59:	6a 00                	push   $0x0
f011dd5b:	68 10 27 00 00       	push   $0x2710
f011dd60:	68 14 09 13 f0       	push   $0xf0130914
f011dd65:	e8 b1 d2 fe ff       	call   f010b01b <env_create>
f011dd6a:	83 c4 10             	add    $0x10,%esp
f011dd6d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011dd70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dd73:	b9 05 00 00 00       	mov    $0x5,%ecx
f011dd78:	99                   	cltd   
f011dd79:	f7 f9                	idiv   %ecx
f011dd7b:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011dd7e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dd81:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dd85:	83 ec 08             	sub    $0x8,%esp
f011dd88:	50                   	push   %eax
f011dd89:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dd8c:	e8 f5 88 fe ff       	call   f0106686 <env_set_nice>
f011dd91:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011dd94:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011dd98:	75 17                	jne    f011ddb1 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011dd9a:	83 ec 04             	sub    $0x4,%esp
f011dd9d:	68 a9 06 13 f0       	push   $0xf01306a9
f011dda2:	68 c1 00 00 00       	push   $0xc1
f011dda7:	68 c2 06 13 f0       	push   $0xf01306c2
f011ddac:	e8 88 25 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011ddb1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ddb4:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011ddba:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011ddbf:	74 17                	je     f011ddd8 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011ddc1:	83 ec 04             	sub    $0x4,%esp
f011ddc4:	68 e0 06 13 f0       	push   $0xf01306e0
f011ddc9:	68 c3 00 00 00       	push   $0xc3
f011ddce:	68 c2 06 13 f0       	push   $0xf01306c2
f011ddd3:	e8 61 25 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011ddd8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dddb:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011dddf:	83 c0 0f             	add    $0xf,%eax
f011dde2:	83 f8 1e             	cmp    $0x1e,%eax
f011dde5:	0f 87 a5 00 00 00    	ja     f011de90 <test_bsd_nice_2+0x184>
f011ddeb:	8b 04 85 70 09 13 f0 	mov    -0xfecf690(,%eax,4),%eax
f011ddf2:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011ddf4:	a1 7c 13 6c f0       	mov    0xf06c137c,%eax
f011ddf9:	8d 50 01             	lea    0x1(%eax),%edx
f011ddfc:	89 15 7c 13 6c f0    	mov    %edx,0xf06c137c
f011de02:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011de05:	8b 52 10             	mov    0x10(%edx),%edx
f011de08:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011de0f:	eb 7f                	jmp    f011de90 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011de11:	a1 80 13 6c f0       	mov    0xf06c1380,%eax
f011de16:	8d 50 01             	lea    0x1(%eax),%edx
f011de19:	89 15 80 13 6c f0    	mov    %edx,0xf06c1380
f011de1f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011de22:	8b 52 10             	mov    0x10(%edx),%edx
f011de25:	83 c0 0a             	add    $0xa,%eax
f011de28:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011de2f:	eb 5f                	jmp    f011de90 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011de31:	a1 84 13 6c f0       	mov    0xf06c1384,%eax
f011de36:	8d 50 01             	lea    0x1(%eax),%edx
f011de39:	89 15 84 13 6c f0    	mov    %edx,0xf06c1384
f011de3f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011de42:	8b 52 10             	mov    0x10(%edx),%edx
f011de45:	83 c0 14             	add    $0x14,%eax
f011de48:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011de4f:	eb 3f                	jmp    f011de90 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011de51:	a1 88 13 6c f0       	mov    0xf06c1388,%eax
f011de56:	8d 50 01             	lea    0x1(%eax),%edx
f011de59:	89 15 88 13 6c f0    	mov    %edx,0xf06c1388
f011de5f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011de62:	8b 52 10             	mov    0x10(%edx),%edx
f011de65:	83 c0 1e             	add    $0x1e,%eax
f011de68:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011de6f:	eb 1f                	jmp    f011de90 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011de71:	a1 8c 13 6c f0       	mov    0xf06c138c,%eax
f011de76:	8d 50 01             	lea    0x1(%eax),%edx
f011de79:	89 15 8c 13 6c f0    	mov    %edx,0xf06c138c
f011de7f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011de82:	8b 52 10             	mov    0x10(%edx),%edx
f011de85:	83 c0 28             	add    $0x28,%eax
f011de88:	89 14 85 00 d5 b0 f0 	mov    %edx,-0xf4f2b00(,%eax,4)
				break;
f011de8f:	90                   	nop
			}
			sched_new_env(env);
f011de90:	83 ec 0c             	sub    $0xc,%esp
f011de93:	ff 75 d4             	pushl  -0x2c(%ebp)
f011de96:	e8 81 78 fe ff       	call   f010571c <sched_new_env>
f011de9b:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011de9e:	ff 45 e4             	incl   -0x1c(%ebp)
f011dea1:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011dea5:	0f 8e ac fe ff ff    	jle    f011dd57 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011deab:	83 ec 0c             	sub    $0xc,%esp
f011deae:	68 10 07 13 f0       	push   $0xf0130710
f011deb3:	e8 d3 30 fe ff       	call   f0100f8b <cprintf>
f011deb8:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011debb:	83 ec 0c             	sub    $0xc,%esp
f011debe:	68 5f 07 13 f0       	push   $0xf013075f
f011dec3:	e8 33 40 fe ff       	call   f0101efb <execute_command>
f011dec8:	83 c4 10             	add    $0x10,%esp
f011decb:	e9 d0 00 00 00       	jmp    f011dfa0 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011ded0:	83 ec 0c             	sub    $0xc,%esp
f011ded3:	6a 00                	push   $0x0
f011ded5:	e8 50 0f 00 00       	call   f011ee2a <chksch>
f011deda:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011dedd:	83 ec 0c             	sub    $0xc,%esp
f011dee0:	68 66 07 13 f0       	push   $0xf0130766
f011dee5:	e8 a1 30 fe ff       	call   f0100f8b <cprintf>
f011deea:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011deed:	e8 62 7f fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011def2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011def9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011df00:	e9 8a 00 00 00       	jmp    f011df8f <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011df05:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011df0c:	eb 55                	jmp    f011df63 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011df0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df11:	8b 14 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%edx
f011df18:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011df1b:	89 c8                	mov    %ecx,%eax
f011df1d:	c1 e0 02             	shl    $0x2,%eax
f011df20:	01 c8                	add    %ecx,%eax
f011df22:	01 c0                	add    %eax,%eax
f011df24:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011df27:	01 c8                	add    %ecx,%eax
f011df29:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011df30:	83 ec 04             	sub    $0x4,%esp
f011df33:	52                   	push   %edx
f011df34:	ff 75 e0             	pushl  -0x20(%ebp)
f011df37:	50                   	push   %eax
f011df38:	e8 7f f8 ff ff       	call   f011d7bc <find_in_range>
f011df3d:	83 c4 10             	add    $0x10,%esp
f011df40:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011df43:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011df47:	75 17                	jne    f011df60 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011df49:	83 ec 04             	sub    $0x4,%esp
f011df4c:	68 78 07 13 f0       	push   $0xf0130778
f011df51:	68 ea 00 00 00       	push   $0xea
f011df56:	68 c2 06 13 f0       	push   $0xf01306c2
f011df5b:	e8 d9 23 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011df60:	ff 45 d8             	incl   -0x28(%ebp)
f011df63:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011df66:	89 d0                	mov    %edx,%eax
f011df68:	c1 e0 02             	shl    $0x2,%eax
f011df6b:	01 d0                	add    %edx,%eax
f011df6d:	01 c0                	add    %eax,%eax
f011df6f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011df72:	01 d0                	add    %edx,%eax
f011df74:	8b 04 85 00 d5 b0 f0 	mov    -0xf4f2b00(,%eax,4),%eax
f011df7b:	85 c0                	test   %eax,%eax
f011df7d:	75 8f                	jne    f011df0e <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011df7f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df82:	8b 04 85 7c 13 6c f0 	mov    -0xf93ec84(,%eax,4),%eax
f011df89:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011df8c:	ff 45 dc             	incl   -0x24(%ebp)
f011df8f:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011df93:	0f 8e 6c ff ff ff    	jle    f011df05 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011df99:	c6 05 dd fd 17 f0 00 	movb   $0x0,0xf017fddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011dfa0:	83 ec 0c             	sub    $0xc,%esp
f011dfa3:	68 20 09 13 f0       	push   $0xf0130920
f011dfa8:	e8 de 2f fe ff       	call   f0100f8b <cprintf>
f011dfad:	83 c4 10             	add    $0x10,%esp
}
f011dfb0:	90                   	nop
f011dfb1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dfb4:	5b                   	pop    %ebx
f011dfb5:	5e                   	pop    %esi
f011dfb6:	5f                   	pop    %edi
f011dfb7:	5d                   	pop    %ebp
f011dfb8:	c3                   	ret    

f011dfb9 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011dfb9:	55                   	push   %ebp
f011dfba:	89 e5                	mov    %esp,%ebp
f011dfbc:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011dfbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f011dfc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011dfc5:	8b 45 08             	mov    0x8(%ebp),%eax
f011dfc8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011dfcb:	89 10                	mov    %edx,(%eax)
}
f011dfcd:	8b 45 08             	mov    0x8(%ebp),%eax
f011dfd0:	c9                   	leave  
f011dfd1:	c2 04 00             	ret    $0x4

f011dfd4 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011dfd4:	55                   	push   %ebp
f011dfd5:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011dfd7:	8b 45 08             	mov    0x8(%ebp),%eax
f011dfda:	85 c0                	test   %eax,%eax
f011dfdc:	78 16                	js     f011dff4 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011dfde:	8b 45 08             	mov    0x8(%ebp),%eax
f011dfe1:	05 00 20 00 00       	add    $0x2000,%eax
f011dfe6:	85 c0                	test   %eax,%eax
f011dfe8:	79 05                	jns    f011dfef <fix_round+0x1b>
f011dfea:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011dfef:	c1 f8 0e             	sar    $0xe,%eax
f011dff2:	eb 14                	jmp    f011e008 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011dff4:	8b 45 08             	mov    0x8(%ebp),%eax
f011dff7:	2d 00 20 00 00       	sub    $0x2000,%eax
f011dffc:	85 c0                	test   %eax,%eax
f011dffe:	79 05                	jns    f011e005 <fix_round+0x31>
f011e000:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011e005:	c1 f8 0e             	sar    $0xe,%eax
}
f011e008:	5d                   	pop    %ebp
f011e009:	c3                   	ret    

f011e00a <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011e00a:	55                   	push   %ebp
f011e00b:	89 e5                	mov    %esp,%ebp
f011e00d:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011e010:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011e014:	79 16                	jns    f011e02c <fix_scale+0x22>
f011e016:	68 ec 09 13 f0       	push   $0xf01309ec
f011e01b:	68 f3 09 13 f0       	push   $0xf01309f3
f011e020:	6a 5a                	push   $0x5a
f011e022:	68 08 0a 13 f0       	push   $0xf0130a08
f011e027:	e8 0d 23 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011e02c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e02f:	0f af 45 10          	imul   0x10(%ebp),%eax
f011e033:	89 c2                	mov    %eax,%edx
f011e035:	8b 45 08             	mov    0x8(%ebp),%eax
f011e038:	83 ec 08             	sub    $0x8,%esp
f011e03b:	52                   	push   %edx
f011e03c:	50                   	push   %eax
f011e03d:	e8 77 ff ff ff       	call   f011dfb9 <__mk_fix>
f011e042:	83 c4 0c             	add    $0xc,%esp
}
f011e045:	8b 45 08             	mov    0x8(%ebp),%eax
f011e048:	c9                   	leave  
f011e049:	c2 04 00             	ret    $0x4

f011e04c <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011e04c:	55                   	push   %ebp
f011e04d:	89 e5                	mov    %esp,%ebp
f011e04f:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011e052:	83 ec 08             	sub    $0x8,%esp
f011e055:	68 1c 0a 13 f0       	push   $0xf0130a1c
f011e05a:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e05f:	e8 93 1c ff ff       	call   f010fcf7 <init_spinlock>
f011e064:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011e067:	83 ec 0c             	sub    $0xc,%esp
f011e06a:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e06f:	e8 b4 1c ff ff       	call   f010fd28 <acquire_spinlock>
f011e074:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011e077:	c7 05 c8 14 6c f0 00 	movl   $0x0,0xf06c14c8
f011e07e:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011e081:	83 ec 0c             	sub    $0xc,%esp
f011e084:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e089:	e8 21 1d ff ff       	call   f010fdaf <release_spinlock>
f011e08e:	83 c4 10             	add    $0x10,%esp
}
f011e091:	90                   	nop
f011e092:	c9                   	leave  
f011e093:	c3                   	ret    

f011e094 <inctst>:
void inctst()
{
f011e094:	55                   	push   %ebp
f011e095:	89 e5                	mov    %esp,%ebp
f011e097:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011e09a:	83 ec 0c             	sub    $0xc,%esp
f011e09d:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e0a2:	e8 81 1c ff ff       	call   f010fd28 <acquire_spinlock>
f011e0a7:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011e0aa:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
f011e0af:	40                   	inc    %eax
f011e0b0:	a3 c8 14 6c f0       	mov    %eax,0xf06c14c8
	}
	release_spinlock(&tstcntlock);
f011e0b5:	83 ec 0c             	sub    $0xc,%esp
f011e0b8:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e0bd:	e8 ed 1c ff ff       	call   f010fdaf <release_spinlock>
f011e0c2:	83 c4 10             	add    $0x10,%esp
}
f011e0c5:	90                   	nop
f011e0c6:	c9                   	leave  
f011e0c7:	c3                   	ret    

f011e0c8 <gettst>:
uint32 gettst()
{
f011e0c8:	55                   	push   %ebp
f011e0c9:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011e0cb:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
}
f011e0d0:	5d                   	pop    %ebp
f011e0d1:	c3                   	ret    

f011e0d2 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011e0d2:	55                   	push   %ebp
f011e0d3:	89 e5                	mov    %esp,%ebp
f011e0d5:	83 ec 28             	sub    $0x28,%esp
f011e0d8:	8b 45 14             	mov    0x14(%ebp),%eax
f011e0db:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011e0de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011e0e5:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011e0e9:	83 f8 65             	cmp    $0x65,%eax
f011e0ec:	74 5d                	je     f011e14b <tst+0x79>
f011e0ee:	83 f8 65             	cmp    $0x65,%eax
f011e0f1:	7f 0a                	jg     f011e0fd <tst+0x2b>
f011e0f3:	83 f8 62             	cmp    $0x62,%eax
f011e0f6:	74 73                	je     f011e16b <tst+0x99>
f011e0f8:	e9 91 00 00 00       	jmp    f011e18e <tst+0xbc>
f011e0fd:	83 f8 67             	cmp    $0x67,%eax
f011e100:	74 29                	je     f011e12b <tst+0x59>
f011e102:	83 f8 6c             	cmp    $0x6c,%eax
f011e105:	0f 85 83 00 00 00    	jne    f011e18e <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011e10b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e10e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e111:	73 09                	jae    f011e11c <tst+0x4a>
			chk = 1;
f011e113:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e11a:	eb 68                	jmp    f011e184 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011e11c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e120:	74 62                	je     f011e184 <tst+0xb2>
			chk = 1;
f011e122:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e129:	eb 59                	jmp    f011e184 <tst+0xb2>
	case 'g':
		if (n > v1)
f011e12b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e12e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e131:	76 09                	jbe    f011e13c <tst+0x6a>
			chk = 1;
f011e133:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e13a:	eb 4b                	jmp    f011e187 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011e13c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e140:	74 45                	je     f011e187 <tst+0xb5>
			chk = 1;
f011e142:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e149:	eb 3c                	jmp    f011e187 <tst+0xb5>
	case 'e':
		if (n == v1)
f011e14b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e14e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e151:	75 09                	jne    f011e15c <tst+0x8a>
			chk = 1;
f011e153:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011e15a:	eb 2e                	jmp    f011e18a <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011e15c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011e160:	74 28                	je     f011e18a <tst+0xb8>
			chk = 1;
f011e162:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e169:	eb 1f                	jmp    f011e18a <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011e16b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e16e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e171:	72 1a                	jb     f011e18d <tst+0xbb>
f011e173:	8b 45 08             	mov    0x8(%ebp),%eax
f011e176:	3b 45 10             	cmp    0x10(%ebp),%eax
f011e179:	77 12                	ja     f011e18d <tst+0xbb>
			chk = 1;
f011e17b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011e182:	eb 09                	jmp    f011e18d <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e184:	90                   	nop
f011e185:	eb 07                	jmp    f011e18e <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e187:	90                   	nop
f011e188:	eb 04                	jmp    f011e18e <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011e18a:	90                   	nop
f011e18b:	eb 01                	jmp    f011e18e <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011e18d:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011e18e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e192:	75 14                	jne    f011e1a8 <tst+0xd6>
f011e194:	83 ec 04             	sub    $0x4,%esp
f011e197:	68 28 0a 13 f0       	push   $0xf0130a28
f011e19c:	6a 48                	push   $0x48
f011e19e:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011e1a3:	e8 91 21 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011e1a8:	83 ec 0c             	sub    $0xc,%esp
f011e1ab:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e1b0:	e8 73 1b ff ff       	call   f010fd28 <acquire_spinlock>
f011e1b5:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011e1b8:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
f011e1bd:	40                   	inc    %eax
f011e1be:	a3 c8 14 6c f0       	mov    %eax,0xf06c14c8
	}
	release_spinlock(&tstcntlock);
f011e1c3:	83 ec 0c             	sub    $0xc,%esp
f011e1c6:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e1cb:	e8 df 1b ff ff       	call   f010fdaf <release_spinlock>
f011e1d0:	83 c4 10             	add    $0x10,%esp

	return;
f011e1d3:	90                   	nop
}
f011e1d4:	c9                   	leave  
f011e1d5:	c3                   	ret    

f011e1d6 <chktst>:

void chktst(uint32 n)
{
f011e1d6:	55                   	push   %ebp
f011e1d7:	89 e5                	mov    %esp,%ebp
f011e1d9:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011e1dc:	83 ec 0c             	sub    $0xc,%esp
f011e1df:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e1e4:	e8 3f 1b ff ff       	call   f010fd28 <acquire_spinlock>
f011e1e9:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011e1ec:	a1 c8 14 6c f0       	mov    0xf06c14c8,%eax
f011e1f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011e1f4:	83 ec 0c             	sub    $0xc,%esp
f011e1f7:	68 00 2e 6c f0       	push   $0xf06c2e00
f011e1fc:	e8 ae 1b ff ff       	call   f010fdaf <release_spinlock>
f011e201:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011e204:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e207:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e20a:	75 12                	jne    f011e21e <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011e20c:	83 ec 0c             	sub    $0xc,%esp
f011e20f:	68 54 0a 13 f0       	push   $0xf0130a54
f011e214:	e8 72 2d fe ff       	call   f0100f8b <cprintf>
f011e219:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011e21c:	eb 14                	jmp    f011e232 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011e21e:	83 ec 04             	sub    $0x4,%esp
f011e221:	68 80 0a 13 f0       	push   $0xf0130a80
f011e226:	6a 5e                	push   $0x5e
f011e228:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011e22d:	e8 07 21 fe ff       	call   f0100339 <_panic>
}
f011e232:	c9                   	leave  
f011e233:	c3                   	ret    

f011e234 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011e234:	55                   	push   %ebp
f011e235:	89 e5                	mov    %esp,%ebp
f011e237:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e23a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e23e:	77 07                	ja     f011e247 <nearest_pow2_ceil+0x13>
f011e240:	b8 01 00 00 00       	mov    $0x1,%eax
f011e245:	eb 20                	jmp    f011e267 <nearest_pow2_ceil+0x33>
	int power = 2;
f011e247:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e24e:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e251:	eb 08                	jmp    f011e25b <nearest_pow2_ceil+0x27>
		power <<= 1;
f011e253:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011e256:	01 c0                	add    %eax,%eax
f011e258:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011e25b:	d1 6d 08             	shrl   0x8(%ebp)
f011e25e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e262:	75 ef                	jne    f011e253 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011e264:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e267:	c9                   	leave  
f011e268:	c3                   	ret    

f011e269 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011e269:	55                   	push   %ebp
f011e26a:	89 e5                	mov    %esp,%ebp
f011e26c:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011e26f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e273:	77 07                	ja     f011e27c <log2_ceil+0x13>
f011e275:	b8 01 00 00 00       	mov    $0x1,%eax
f011e27a:	eb 1b                	jmp    f011e297 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011e27c:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011e283:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011e286:	eb 03                	jmp    f011e28b <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011e288:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011e28b:	d1 6d 08             	shrl   0x8(%ebp)
f011e28e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e292:	75 f4                	jne    f011e288 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011e294:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011e297:	c9                   	leave  
f011e298:	c3                   	ret    

f011e299 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011e299:	55                   	push   %ebp
f011e29a:	89 e5                	mov    %esp,%ebp
f011e29c:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011e29f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011e2a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e2ad:	eb 12                	jmp    f011e2c1 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011e2af:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e2b2:	89 d0                	mov    %edx,%eax
f011e2b4:	c1 e0 02             	shl    $0x2,%eax
f011e2b7:	01 d0                	add    %edx,%eax
f011e2b9:	01 c0                	add    %eax,%eax
f011e2bb:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011e2be:	ff 45 f0             	incl   -0x10(%ebp)
f011e2c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e2c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e2c7:	7c e6                	jl     f011e2af <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011e2c9:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011e2cc:	83 ec 04             	sub    $0x4,%esp
f011e2cf:	ff 75 f4             	pushl  -0xc(%ebp)
f011e2d2:	ff 75 08             	pushl  0x8(%ebp)
f011e2d5:	50                   	push   %eax
f011e2d6:	e8 2f fd ff ff       	call   f011e00a <fix_scale>
f011e2db:	83 c4 0c             	add    $0xc,%esp
f011e2de:	83 ec 0c             	sub    $0xc,%esp
f011e2e1:	ff 75 dc             	pushl  -0x24(%ebp)
f011e2e4:	e8 eb fc ff ff       	call   f011dfd4 <fix_round>
f011e2e9:	83 c4 10             	add    $0x10,%esp
f011e2ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011e2ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e2f2:	99                   	cltd   
f011e2f3:	f7 7d f4             	idivl  -0xc(%ebp)
f011e2f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011e2f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e2fc:	99                   	cltd   
f011e2fd:	f7 7d f4             	idivl  -0xc(%ebp)
f011e300:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011e303:	83 ec 08             	sub    $0x8,%esp
f011e306:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e309:	50                   	push   %eax
f011e30a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e30d:	e8 6a 1e 00 00       	call   f012017c <ltostr>
f011e312:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011e315:	83 ec 08             	sub    $0x8,%esp
f011e318:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e31b:	50                   	push   %eax
f011e31c:	ff 75 e0             	pushl  -0x20(%ebp)
f011e31f:	e8 58 1e 00 00       	call   f012017c <ltostr>
f011e324:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011e327:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011e32a:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e32f:	f7 e9                	imul   %ecx
f011e331:	c1 fa 02             	sar    $0x2,%edx
f011e334:	89 c8                	mov    %ecx,%eax
f011e336:	c1 f8 1f             	sar    $0x1f,%eax
f011e339:	29 c2                	sub    %eax,%edx
f011e33b:	89 d0                	mov    %edx,%eax
f011e33d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011e340:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011e347:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011e34e:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011e354:	eb 31                	jmp    f011e387 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011e356:	83 ec 04             	sub    $0x4,%esp
f011e359:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e35c:	50                   	push   %eax
f011e35d:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e360:	50                   	push   %eax
f011e361:	68 9c 0a 13 f0       	push   $0xf0130a9c
f011e366:	e8 ea 1e 00 00       	call   f0120255 <strcconcat>
f011e36b:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011e36e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011e371:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011e376:	f7 e9                	imul   %ecx
f011e378:	c1 fa 02             	sar    $0x2,%edx
f011e37b:	89 c8                	mov    %ecx,%eax
f011e37d:	c1 f8 1f             	sar    $0x1f,%eax
f011e380:	29 c2                	sub    %eax,%edx
f011e382:	89 d0                	mov    %edx,%eax
f011e384:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011e387:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e38a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e38d:	7c c7                	jl     f011e356 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011e38f:	83 ec 04             	sub    $0x4,%esp
f011e392:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e395:	50                   	push   %eax
f011e396:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e399:	50                   	push   %eax
f011e39a:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011e39d:	50                   	push   %eax
f011e39e:	e8 b2 1e 00 00       	call   f0120255 <strcconcat>
f011e3a3:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011e3a6:	83 ec 04             	sub    $0x4,%esp
f011e3a9:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e3ac:	50                   	push   %eax
f011e3ad:	68 9e 0a 13 f0       	push   $0xf0130a9e
f011e3b2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e3b5:	50                   	push   %eax
f011e3b6:	e8 9a 1e 00 00       	call   f0120255 <strcconcat>
f011e3bb:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011e3be:	83 ec 04             	sub    $0x4,%esp
f011e3c1:	ff 75 10             	pushl  0x10(%ebp)
f011e3c4:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011e3c7:	50                   	push   %eax
f011e3c8:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011e3cb:	50                   	push   %eax
f011e3cc:	e8 84 1e 00 00       	call   f0120255 <strcconcat>
f011e3d1:	83 c4 10             	add    $0x10,%esp

}
f011e3d4:	90                   	nop
f011e3d5:	c9                   	leave  
f011e3d6:	c3                   	ret    

f011e3d7 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011e3d7:	55                   	push   %ebp
f011e3d8:	89 e5                	mov    %esp,%ebp
f011e3da:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011e3e0:	83 ec 0c             	sub    $0xc,%esp
f011e3e3:	68 a0 0a 13 f0       	push   $0xf0130aa0
f011e3e8:	e8 e9 18 00 00       	call   f011fcd6 <strlen>
f011e3ed:	83 c4 10             	add    $0x10,%esp
f011e3f0:	83 ec 04             	sub    $0x4,%esp
f011e3f3:	50                   	push   %eax
f011e3f4:	68 a0 0a 13 f0       	push   $0xf0130aa0
f011e3f9:	ff 75 08             	pushl  0x8(%ebp)
f011e3fc:	e8 19 1a 00 00       	call   f011fe1a <strncmp>
f011e401:	83 c4 10             	add    $0x10,%esp
f011e404:	85 c0                	test   %eax,%eax
f011e406:	0f 85 8a 00 00 00    	jne    f011e496 <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e40c:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011e40f:	50                   	push   %eax
f011e410:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e416:	50                   	push   %eax
f011e417:	68 ae 0a 13 f0       	push   $0xf0130aae
f011e41c:	ff 75 08             	pushl  0x8(%ebp)
f011e41f:	e8 c7 1e 00 00       	call   f01202eb <strsplit>
f011e424:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011e427:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e42d:	83 ec 04             	sub    $0x4,%esp
f011e430:	6a 0a                	push   $0xa
f011e432:	6a 00                	push   $0x0
f011e434:	50                   	push   %eax
f011e435:	e8 fc 1b 00 00       	call   f0120036 <strtol>
f011e43a:	83 c4 10             	add    $0x10,%esp
f011e43d:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011e440:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011e447:	83 ec 04             	sub    $0x4,%esp
f011e44a:	6a 00                	push   $0x0
f011e44c:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e44f:	50                   	push   %eax
f011e450:	ff 75 e0             	pushl  -0x20(%ebp)
f011e453:	e8 91 d6 fe ff       	call   f010bae9 <envid2env>
f011e458:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011e45b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e45e:	8b 40 10             	mov    0x10(%eax),%eax
f011e461:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e464:	74 19                	je     f011e47f <sys_utilities+0xa8>
f011e466:	68 b0 0a 13 f0       	push   $0xf0130ab0
f011e46b:	68 f3 09 13 f0       	push   $0xf01309f3
f011e470:	68 a4 00 00 00       	push   $0xa4
f011e475:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011e47a:	e8 ba 1e fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011e47f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011e482:	83 ec 08             	sub    $0x8,%esp
f011e485:	ff 75 0c             	pushl  0xc(%ebp)
f011e488:	50                   	push   %eax
f011e489:	e8 f8 81 fe ff       	call   f0106686 <env_set_nice>
f011e48e:	83 c4 10             	add    $0x10,%esp
f011e491:	e9 12 04 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011e496:	83 ec 0c             	sub    $0xc,%esp
f011e499:	68 c5 0a 13 f0       	push   $0xf0130ac5
f011e49e:	e8 33 18 00 00       	call   f011fcd6 <strlen>
f011e4a3:	83 c4 10             	add    $0x10,%esp
f011e4a6:	83 ec 04             	sub    $0x4,%esp
f011e4a9:	50                   	push   %eax
f011e4aa:	68 c5 0a 13 f0       	push   $0xf0130ac5
f011e4af:	ff 75 08             	pushl  0x8(%ebp)
f011e4b2:	e8 63 19 00 00       	call   f011fe1a <strncmp>
f011e4b7:	83 c4 10             	add    $0x10,%esp
f011e4ba:	85 c0                	test   %eax,%eax
f011e4bc:	0f 85 a6 01 00 00    	jne    f011e668 <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011e4c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e4c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011e4c8:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011e4cb:	50                   	push   %eax
f011e4cc:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011e4d2:	50                   	push   %eax
f011e4d3:	68 ae 0a 13 f0       	push   $0xf0130aae
f011e4d8:	ff 75 08             	pushl  0x8(%ebp)
f011e4db:	e8 0b 1e 00 00       	call   f01202eb <strsplit>
f011e4e0:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011e4e3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011e4e9:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011e4ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011e4f3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011e4fa:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011e501:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e504:	8b 00                	mov    (%eax),%eax
f011e506:	85 c0                	test   %eax,%eax
f011e508:	79 1c                	jns    f011e526 <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011e50a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011e511:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e514:	8b 00                	mov    (%eax),%eax
f011e516:	f7 d8                	neg    %eax
f011e518:	89 c2                	mov    %eax,%edx
f011e51a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e51d:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011e51f:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011e526:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011e52d:	83 ec 0c             	sub    $0xc,%esp
f011e530:	68 e0 15 6c f0       	push   $0xf06c15e0
f011e535:	e8 ee 17 ff ff       	call   f010fd28 <acquire_spinlock>
f011e53a:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e53d:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011e542:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e545:	a1 64 16 6c f0       	mov    0xf06c1664,%eax
f011e54a:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e54d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e550:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e553:	eb 6c                	jmp    f011e5c1 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011e555:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e558:	83 c0 20             	add    $0x20,%eax
f011e55b:	83 ec 08             	sub    $0x8,%esp
f011e55e:	ff 75 d8             	pushl  -0x28(%ebp)
f011e561:	50                   	push   %eax
f011e562:	e8 7b 18 00 00       	call   f011fde2 <strcmp>
f011e567:	83 c4 10             	add    $0x10,%esp
f011e56a:	85 c0                	test   %eax,%eax
f011e56c:	75 46                	jne    f011e5b4 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011e56e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e571:	8b 00                	mov    (%eax),%eax
f011e573:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e576:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e579:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011e57b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e57f:	74 14                	je     f011e595 <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011e581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e584:	8b 40 10             	mov    0x10(%eax),%eax
f011e587:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e58a:	7d 1d                	jge    f011e5a9 <sys_utilities+0x1d2>
					{
						success = 0;
f011e58c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e593:	eb 32                	jmp    f011e5c7 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011e595:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e598:	8b 40 10             	mov    0x10(%eax),%eax
f011e59b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e59e:	7e 09                	jle    f011e5a9 <sys_utilities+0x1d2>
					{
						success = 0;
f011e5a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011e5a7:	eb 1e                	jmp    f011e5c7 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011e5a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e5ac:	8b 40 10             	mov    0x10(%eax),%eax
f011e5af:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e5b2:	eb 01                	jmp    f011e5b5 <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011e5b4:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011e5b5:	ff 4d e4             	decl   -0x1c(%ebp)
f011e5b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e5bb:	8b 40 0c             	mov    0xc(%eax),%eax
f011e5be:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e5c1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e5c5:	7f 8e                	jg     f011e555 <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e5c7:	83 ec 0c             	sub    $0xc,%esp
f011e5ca:	68 e0 15 6c f0       	push   $0xf06c15e0
f011e5cf:	e8 db 17 ff ff       	call   f010fdaf <release_spinlock>
f011e5d4:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011e5d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e5da:	8b 00                	mov    (%eax),%eax
f011e5dc:	85 c0                	test   %eax,%eax
f011e5de:	75 06                	jne    f011e5e6 <sys_utilities+0x20f>
f011e5e0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e5e4:	75 41                	jne    f011e627 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011e5e6:	83 ec 0c             	sub    $0xc,%esp
f011e5e9:	68 d8 0a 13 f0       	push   $0xf0130ad8
f011e5ee:	e8 98 29 fe ff       	call   f0100f8b <cprintf>
f011e5f3:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011e5f6:	83 ec 08             	sub    $0x8,%esp
f011e5f9:	ff 75 d8             	pushl  -0x28(%ebp)
f011e5fc:	68 08 0b 13 f0       	push   $0xf0130b08
f011e601:	e8 85 29 fe ff       	call   f0100f8b <cprintf>
f011e606:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011e609:	83 ec 0c             	sub    $0xc,%esp
f011e60c:	68 d8 0a 13 f0       	push   $0xf0130ad8
f011e611:	e8 75 29 fe ff       	call   f0100f8b <cprintf>
f011e616:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011e619:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e61c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011e622:	e9 81 02 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011e627:	83 ec 0c             	sub    $0xc,%esp
f011e62a:	68 28 0b 13 f0       	push   $0xf0130b28
f011e62f:	e8 57 29 fe ff       	call   f0100f8b <cprintf>
f011e634:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011e637:	83 ec 08             	sub    $0x8,%esp
f011e63a:	ff 75 d8             	pushl  -0x28(%ebp)
f011e63d:	68 60 0b 13 f0       	push   $0xf0130b60
f011e642:	e8 44 29 fe ff       	call   f0100f8b <cprintf>
f011e647:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011e64a:	83 ec 0c             	sub    $0xc,%esp
f011e64d:	68 28 0b 13 f0       	push   $0xf0130b28
f011e652:	e8 34 29 fe ff       	call   f0100f8b <cprintf>
f011e657:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011e65a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e65d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011e663:	e9 40 02 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011e668:	83 ec 08             	sub    $0x8,%esp
f011e66b:	68 83 0b 13 f0       	push   $0xf0130b83
f011e670:	ff 75 08             	pushl  0x8(%ebp)
f011e673:	e8 6a 17 00 00       	call   f011fde2 <strcmp>
f011e678:	83 c4 10             	add    $0x10,%esp
f011e67b:	85 c0                	test   %eax,%eax
f011e67d:	75 77                	jne    f011e6f6 <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011e67f:	a1 e0 fd 17 f0       	mov    0xf017fde0,%eax
f011e684:	85 c0                	test   %eax,%eax
f011e686:	74 34                	je     f011e6bc <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011e688:	c7 05 e0 fd 17 f0 00 	movl   $0x0,0xf017fde0
f011e68f:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011e692:	83 ec 08             	sub    $0x8,%esp
f011e695:	68 8d 0b 13 f0       	push   $0xf0130b8d
f011e69a:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e69f:	e8 44 1a ff ff       	call   f01100e8 <init_channel>
f011e6a4:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011e6a7:	83 ec 08             	sub    $0x8,%esp
f011e6aa:	68 9a 0b 13 f0       	push   $0xf0130b9a
f011e6af:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e6b4:	e8 3e 16 ff ff       	call   f010fcf7 <init_spinlock>
f011e6b9:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011e6bc:	83 ec 0c             	sub    $0xc,%esp
f011e6bf:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e6c4:	e8 5f 16 ff ff       	call   f010fd28 <acquire_spinlock>
f011e6c9:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011e6cc:	83 ec 08             	sub    $0x8,%esp
f011e6cf:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e6d4:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e6d9:	e8 37 1a ff ff       	call   f0110115 <sleep>
f011e6de:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011e6e1:	83 ec 0c             	sub    $0xc,%esp
f011e6e4:	68 60 d7 b0 f0       	push   $0xf0b0d760
f011e6e9:	e8 c1 16 ff ff       	call   f010fdaf <release_spinlock>
f011e6ee:	83 c4 10             	add    $0x10,%esp
f011e6f1:	e9 b2 01 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011e6f6:	83 ec 08             	sub    $0x8,%esp
f011e6f9:	68 ac 0b 13 f0       	push   $0xf0130bac
f011e6fe:	ff 75 08             	pushl  0x8(%ebp)
f011e701:	e8 dc 16 00 00       	call   f011fde2 <strcmp>
f011e706:	83 c4 10             	add    $0x10,%esp
f011e709:	85 c0                	test   %eax,%eax
f011e70b:	75 15                	jne    f011e722 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011e70d:	83 ec 0c             	sub    $0xc,%esp
f011e710:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e715:	e8 68 1a ff ff       	call   f0110182 <wakeup_one>
f011e71a:	83 c4 10             	add    $0x10,%esp
f011e71d:	e9 86 01 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e722:	83 ec 08             	sub    $0x8,%esp
f011e725:	68 ba 0b 13 f0       	push   $0xf0130bba
f011e72a:	ff 75 08             	pushl  0x8(%ebp)
f011e72d:	e8 b0 16 00 00       	call   f011fde2 <strcmp>
f011e732:	83 c4 10             	add    $0x10,%esp
f011e735:	85 c0                	test   %eax,%eax
f011e737:	75 15                	jne    f011e74e <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e739:	83 ec 0c             	sub    $0xc,%esp
f011e73c:	68 e0 d5 b0 f0       	push   $0xf0b0d5e0
f011e741:	e8 c0 1a ff ff       	call   f0110206 <wakeup_all>
f011e746:	83 c4 10             	add    $0x10,%esp
f011e749:	e9 5a 01 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e74e:	83 ec 08             	sub    $0x8,%esp
f011e751:	68 c8 0b 13 f0       	push   $0xf0130bc8
f011e756:	ff 75 08             	pushl  0x8(%ebp)
f011e759:	e8 84 16 00 00       	call   f011fde2 <strcmp>
f011e75e:	83 c4 10             	add    $0x10,%esp
f011e761:	85 c0                	test   %eax,%eax
f011e763:	75 17                	jne    f011e77c <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e765:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e768:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e76b:	a1 ec d5 b0 f0       	mov    0xf0b0d5ec,%eax
f011e770:	89 c2                	mov    %eax,%edx
f011e772:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e775:	89 10                	mov    %edx,(%eax)
f011e777:	e9 2c 01 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011e77c:	83 ec 08             	sub    $0x8,%esp
f011e77f:	68 dd 0b 13 f0       	push   $0xf0130bdd
f011e784:	ff 75 08             	pushl  0x8(%ebp)
f011e787:	e8 56 16 00 00       	call   f011fde2 <strcmp>
f011e78c:	83 c4 10             	add    $0x10,%esp
f011e78f:	85 c0                	test   %eax,%eax
f011e791:	75 1a                	jne    f011e7ad <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011e793:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e796:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011e799:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011e79e:	8b 40 0c             	mov    0xc(%eax),%eax
f011e7a1:	89 c2                	mov    %eax,%edx
f011e7a3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e7a6:	89 10                	mov    %edx,(%eax)
f011e7a8:	e9 fb 00 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011e7ad:	83 ec 08             	sub    $0x8,%esp
f011e7b0:	68 f3 0b 13 f0       	push   $0xf0130bf3
f011e7b5:	ff 75 08             	pushl  0x8(%ebp)
f011e7b8:	e8 25 16 00 00       	call   f011fde2 <strcmp>
f011e7bd:	83 c4 10             	add    $0x10,%esp
f011e7c0:	85 c0                	test   %eax,%eax
f011e7c2:	75 3d                	jne    f011e801 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011e7c4:	a1 e4 fd 17 f0       	mov    0xf017fde4,%eax
f011e7c9:	85 c0                	test   %eax,%eax
f011e7cb:	74 1f                	je     f011e7ec <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011e7cd:	c7 05 e4 fd 17 f0 00 	movl   $0x0,0xf017fde4
f011e7d4:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011e7d7:	83 ec 08             	sub    $0x8,%esp
f011e7da:	68 08 0c 13 f0       	push   $0xf0130c08
f011e7df:	68 40 d6 b0 f0       	push   $0xf0b0d640
f011e7e4:	e8 99 17 ff ff       	call   f010ff82 <init_sleeplock>
f011e7e9:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011e7ec:	83 ec 0c             	sub    $0xc,%esp
f011e7ef:	68 40 d6 b0 f0       	push   $0xf0b0d640
f011e7f4:	e8 4d 18 ff ff       	call   f0110046 <acquire_sleeplock>
f011e7f9:	83 c4 10             	add    $0x10,%esp
f011e7fc:	e9 a7 00 00 00       	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e801:	83 ec 08             	sub    $0x8,%esp
f011e804:	68 18 0c 13 f0       	push   $0xf0130c18
f011e809:	ff 75 08             	pushl  0x8(%ebp)
f011e80c:	e8 d1 15 00 00       	call   f011fde2 <strcmp>
f011e811:	83 c4 10             	add    $0x10,%esp
f011e814:	85 c0                	test   %eax,%eax
f011e816:	75 12                	jne    f011e82a <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e818:	83 ec 0c             	sub    $0xc,%esp
f011e81b:	68 40 d6 b0 f0       	push   $0xf0b0d640
f011e820:	e8 7b 18 ff ff       	call   f01100a0 <release_sleeplock>
f011e825:	83 c4 10             	add    $0x10,%esp
f011e828:	eb 7e                	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011e82a:	83 ec 08             	sub    $0x8,%esp
f011e82d:	68 2d 0c 13 f0       	push   $0xf0130c2d
f011e832:	ff 75 08             	pushl  0x8(%ebp)
f011e835:	e8 a8 15 00 00       	call   f011fde2 <strcmp>
f011e83a:	83 c4 10             	add    $0x10,%esp
f011e83d:	85 c0                	test   %eax,%eax
f011e83f:	75 14                	jne    f011e855 <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011e841:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e844:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011e847:	a1 c0 d6 b0 f0       	mov    0xf0b0d6c0,%eax
f011e84c:	89 c2                	mov    %eax,%edx
f011e84e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e851:	89 10                	mov    %edx,(%eax)
f011e853:	eb 53                	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011e855:	83 ec 08             	sub    $0x8,%esp
f011e858:	68 42 0c 13 f0       	push   $0xf0130c42
f011e85d:	ff 75 08             	pushl  0x8(%ebp)
f011e860:	e8 7d 15 00 00       	call   f011fde2 <strcmp>
f011e865:	83 c4 10             	add    $0x10,%esp
f011e868:	85 c0                	test   %eax,%eax
f011e86a:	75 13                	jne    f011e87f <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011e86c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e86f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011e872:	8b 15 40 d6 b0 f0    	mov    0xf0b0d640,%edx
f011e878:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e87b:	89 10                	mov    %edx,(%eax)
f011e87d:	eb 29                	jmp    f011e8a8 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011e87f:	83 ec 08             	sub    $0x8,%esp
f011e882:	68 53 0c 13 f0       	push   $0xf0130c53
f011e887:	ff 75 08             	pushl  0x8(%ebp)
f011e88a:	e8 53 15 00 00       	call   f011fde2 <strcmp>
f011e88f:	83 c4 10             	add    $0x10,%esp
f011e892:	85 c0                	test   %eax,%eax
f011e894:	75 12                	jne    f011e8a8 <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011e896:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e899:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011e89c:	a1 44 d7 b0 f0       	mov    0xf0b0d744,%eax
f011e8a1:	89 c2                	mov    %eax,%edx
f011e8a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e8a6:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011e8a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e8ac:	79 5b                	jns    f011e909 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011e8ae:	83 ec 08             	sub    $0x8,%esp
f011e8b1:	68 64 0c 13 f0       	push   $0xf0130c64
f011e8b6:	ff 75 08             	pushl  0x8(%ebp)
f011e8b9:	e8 24 15 00 00       	call   f011fde2 <strcmp>
f011e8be:	83 c4 10             	add    $0x10,%esp
f011e8c1:	85 c0                	test   %eax,%eax
f011e8c3:	75 44                	jne    f011e909 <sys_utilities+0x532>
		{
			switch (value)
f011e8c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e8c8:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011e8cb:	74 07                	je     f011e8d4 <sys_utilities+0x4fd>
f011e8cd:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011e8d0:	74 19                	je     f011e8eb <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011e8d2:	eb 35                	jmp    f011e909 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011e8d4:	83 ec 0c             	sub    $0xc,%esp
f011e8d7:	68 74 0c 13 f0       	push   $0xf0130c74
f011e8dc:	e8 aa 26 fe ff       	call   f0100f8b <cprintf>
f011e8e1:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011e8e4:	e8 a4 0d ff ff       	call   f010f68d <setPageReplacmentAlgorithmFIFO>
				break;
f011e8e9:	eb 1e                	jmp    f011e909 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011e8eb:	83 ec 0c             	sub    $0xc,%esp
f011e8ee:	68 e4 0c 13 f0       	push   $0xf0130ce4
f011e8f3:	e8 93 26 fe ff       	call   f0100f8b <cprintf>
f011e8f8:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011e8fb:	83 ec 0c             	sub    $0xc,%esp
f011e8fe:	6a 02                	push   $0x2
f011e900:	e8 45 0d ff ff       	call   f010f64a <setPageReplacmentAlgorithmLRU>
f011e905:	83 c4 10             	add    $0x10,%esp
				break;
f011e908:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011e909:	90                   	nop
f011e90a:	c9                   	leave  
f011e90b:	c3                   	ret    

f011e90c <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011e90c:	55                   	push   %ebp
f011e90d:	89 e5                	mov    %esp,%ebp
f011e90f:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011e912:	8b 45 08             	mov    0x8(%ebp),%eax
f011e915:	8b 00                	mov    (%eax),%eax
f011e917:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011e91a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e91d:	8b 00                	mov    (%eax),%eax
f011e91f:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011e922:	eb 52                	jmp    f011e976 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011e924:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e927:	8b 00                	mov    (%eax),%eax
f011e929:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011e92c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e92f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e932:	75 12                	jne    f011e946 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011e934:	83 ec 0c             	sub    $0xc,%esp
f011e937:	68 58 0d 13 f0       	push   $0xf0130d58
f011e93c:	e8 4a 26 fe ff       	call   f0100f8b <cprintf>
f011e941:	83 c4 10             	add    $0x10,%esp
			break;
f011e944:	eb 3f                	jmp    f011e985 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011e946:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e94a:	74 38                	je     f011e984 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011e94c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e94f:	8b 00                	mov    (%eax),%eax
f011e951:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011e954:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e957:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e95a:	75 12                	jne    f011e96e <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011e95c:	83 ec 0c             	sub    $0xc,%esp
f011e95f:	68 74 0d 13 f0       	push   $0xf0130d74
f011e964:	e8 22 26 fe ff       	call   f0100f8b <cprintf>
f011e969:	83 c4 10             	add    $0x10,%esp
			break;
f011e96c:	eb 17                	jmp    f011e985 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011e96e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e971:	8b 00                	mov    (%eax),%eax
f011e973:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011e976:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e97a:	74 09                	je     f011e985 <detect_loop_in_FrameInfo_list+0x79>
f011e97c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e980:	75 a2                	jne    f011e924 <detect_loop_in_FrameInfo_list+0x18>
f011e982:	eb 01                	jmp    f011e985 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011e984:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011e985:	83 ec 0c             	sub    $0xc,%esp
f011e988:	68 8b 0d 13 f0       	push   $0xf0130d8b
f011e98d:	e8 f9 25 fe ff       	call   f0100f8b <cprintf>
f011e992:	83 c4 10             	add    $0x10,%esp
}
f011e995:	90                   	nop
f011e996:	c9                   	leave  
f011e997:	c3                   	ret    

f011e998 <scarce_memory>:

void scarce_memory()
{
f011e998:	55                   	push   %ebp
f011e999:	89 e5                	mov    %esp,%ebp
f011e99b:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011e99e:	a1 b0 17 6c f0       	mov    0xf06c17b0,%eax
f011e9a3:	ba 64 00 00 00       	mov    $0x64,%edx
f011e9a8:	29 c2                	sub    %eax,%edx
f011e9aa:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f011e9af:	0f af c2             	imul   %edx,%eax
f011e9b2:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e9b7:	f7 e2                	mul    %edx
f011e9b9:	89 d0                	mov    %edx,%eax
f011e9bb:	c1 e8 05             	shr    $0x5,%eax
f011e9be:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011e9c1:	a1 b0 17 6c f0       	mov    0xf06c17b0,%eax
f011e9c6:	ba 64 00 00 00       	mov    $0x64,%edx
f011e9cb:	29 c2                	sub    %eax,%edx
f011e9cd:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f011e9d2:	89 d1                	mov    %edx,%ecx
f011e9d4:	0f af c8             	imul   %eax,%ecx
f011e9d7:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e9dc:	f7 e1                	mul    %ecx
f011e9de:	c1 ea 05             	shr    $0x5,%edx
f011e9e1:	89 d0                	mov    %edx,%eax
f011e9e3:	c1 e0 02             	shl    $0x2,%eax
f011e9e6:	01 d0                	add    %edx,%eax
f011e9e8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e9ef:	01 d0                	add    %edx,%eax
f011e9f1:	c1 e0 02             	shl    $0x2,%eax
f011e9f4:	29 c1                	sub    %eax,%ecx
f011e9f6:	89 ca                	mov    %ecx,%edx
f011e9f8:	85 d2                	test   %edx,%edx
f011e9fa:	74 03                	je     f011e9ff <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011e9fc:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011e9ff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011ea06:	83 ec 0c             	sub    $0xc,%esp
f011ea09:	68 a0 16 6c f0       	push   $0xf06c16a0
f011ea0e:	e8 15 13 ff ff       	call   f010fd28 <acquire_spinlock>
f011ea13:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011ea16:	a1 8c 16 6c f0       	mov    0xf06c168c,%eax
f011ea1b:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011ea1e:	8b 15 78 18 6c f0    	mov    0xf06c1878,%edx
f011ea24:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ea27:	29 c2                	sub    %eax,%edx
f011ea29:	89 d0                	mov    %edx,%eax
f011ea2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011ea2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ea31:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011ea34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011ea37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ea3e:	eb 12                	jmp    f011ea52 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011ea40:	83 ec 0c             	sub    $0xc,%esp
f011ea43:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011ea46:	50                   	push   %eax
f011ea47:	e8 66 97 fe ff       	call   f01081b2 <allocate_frame>
f011ea4c:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011ea4f:	ff 45 f0             	incl   -0x10(%ebp)
f011ea52:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ea55:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011ea58:	76 e6                	jbe    f011ea40 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011ea5a:	83 ec 0c             	sub    $0xc,%esp
f011ea5d:	68 a0 16 6c f0       	push   $0xf06c16a0
f011ea62:	e8 48 13 ff ff       	call   f010fdaf <release_spinlock>
f011ea67:	83 c4 10             	add    $0x10,%esp

}
f011ea6a:	90                   	nop
f011ea6b:	c9                   	leave  
f011ea6c:	c3                   	ret    

f011ea6d <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011ea6d:	55                   	push   %ebp
f011ea6e:	89 e5                	mov    %esp,%ebp
f011ea70:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011ea73:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011ea7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011ea81:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011ea88:	e8 0c d0 fe ff       	call   f010ba99 <get_cpu_proc>
f011ea8d:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011ea90:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011ea94:	75 19                	jne    f011eaaf <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011ea96:	68 a5 0d 13 f0       	push   $0xf0130da5
f011ea9b:	68 f3 09 13 f0       	push   $0xf01309f3
f011eaa0:	68 79 01 00 00       	push   $0x179
f011eaa5:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011eaaa:	e8 8a 18 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011eaaf:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011eab3:	0f 85 d6 01 00 00    	jne    f011ec8f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011eab9:	83 ec 0c             	sub    $0xc,%esp
f011eabc:	68 e0 15 6c f0       	push   $0xf06c15e0
f011eac1:	e8 62 12 ff ff       	call   f010fd28 <acquire_spinlock>
f011eac6:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011eac9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011ead0:	e9 d2 00 00 00       	jmp    f011eba7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011ead5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011eadc:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011eae1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eae4:	c1 e2 04             	shl    $0x4,%edx
f011eae7:	01 d0                	add    %edx,%eax
f011eae9:	8b 00                	mov    (%eax),%eax
f011eaeb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011eaee:	eb 7c                	jmp    f011eb6c <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011eaf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011eaf3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011eaf9:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011eafc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eaff:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eb05:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011eb08:	0f af c2             	imul   %edx,%eax
f011eb0b:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011eb10:	f7 e2                	mul    %edx
f011eb12:	89 d0                	mov    %edx,%eax
f011eb14:	c1 e8 05             	shr    $0x5,%eax
f011eb17:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011eb1a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011eb1d:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eb23:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011eb26:	89 d1                	mov    %edx,%ecx
f011eb28:	0f af c8             	imul   %eax,%ecx
f011eb2b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011eb30:	f7 e1                	mul    %ecx
f011eb32:	c1 ea 05             	shr    $0x5,%edx
f011eb35:	89 d0                	mov    %edx,%eax
f011eb37:	c1 e0 02             	shl    $0x2,%eax
f011eb3a:	01 d0                	add    %edx,%eax
f011eb3c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011eb43:	01 d0                	add    %edx,%eax
f011eb45:	c1 e0 02             	shl    $0x2,%eax
f011eb48:	29 c1                	sub    %eax,%ecx
f011eb4a:	89 ca                	mov    %ecx,%edx
f011eb4c:	85 d2                	test   %edx,%edx
f011eb4e:	74 03                	je     f011eb53 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011eb50:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011eb53:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011eb56:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011eb59:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011eb5e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eb61:	c1 e2 04             	shl    $0x4,%edx
f011eb64:	01 d0                	add    %edx,%eax
f011eb66:	8b 40 08             	mov    0x8(%eax),%eax
f011eb69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011eb6c:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011eb71:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011eb74:	c1 e2 04             	shl    $0x4,%edx
f011eb77:	01 d0                	add    %edx,%eax
f011eb79:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eb7d:	74 08                	je     f011eb87 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011eb7f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011eb82:	8b 52 08             	mov    0x8(%edx),%edx
f011eb85:	eb 05                	jmp    f011eb8c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011eb87:	ba 00 00 00 00       	mov    $0x0,%edx
f011eb8c:	89 50 08             	mov    %edx,0x8(%eax)
f011eb8f:	8b 40 08             	mov    0x8(%eax),%eax
f011eb92:	85 c0                	test   %eax,%eax
f011eb94:	0f 85 56 ff ff ff    	jne    f011eaf0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011eb9a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eb9e:	0f 85 4c ff ff ff    	jne    f011eaf0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011eba4:	ff 45 e8             	incl   -0x18(%ebp)
f011eba7:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ebac:	0f b6 c0             	movzbl %al,%eax
f011ebaf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ebb2:	0f 8f 1d ff ff ff    	jg     f011ead5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011ebb8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011ebbf:	a1 60 16 6c f0       	mov    0xf06c1660,%eax
f011ebc4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ebc7:	eb 1a                	jmp    f011ebe3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011ebc9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ebcc:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ebd2:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011ebd5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ebd8:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011ebdb:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011ebe0:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ebe3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ebe7:	74 08                	je     f011ebf1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011ebe9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ebec:	8b 40 08             	mov    0x8(%eax),%eax
f011ebef:	eb 05                	jmp    f011ebf6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011ebf1:	b8 00 00 00 00       	mov    $0x0,%eax
f011ebf6:	a3 68 16 6c f0       	mov    %eax,0xf06c1668
f011ebfb:	a1 68 16 6c f0       	mov    0xf06c1668,%eax
f011ec00:	85 c0                	test   %eax,%eax
f011ec02:	75 c5                	jne    f011ebc9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011ec04:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ec08:	75 bf                	jne    f011ebc9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011ec0a:	83 ec 0c             	sub    $0xc,%esp
f011ec0d:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ec12:	e8 98 11 ff ff       	call   f010fdaf <release_spinlock>
f011ec17:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011ec1a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011ec1e:	0f 84 d4 00 00 00    	je     f011ecf8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ec24:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec27:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ec2d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ec30:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec33:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ec39:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ec3c:	0f af c2             	imul   %edx,%eax
f011ec3f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ec44:	f7 e2                	mul    %edx
f011ec46:	89 d0                	mov    %edx,%eax
f011ec48:	c1 e8 05             	shr    $0x5,%eax
f011ec4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ec4e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec51:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ec57:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011ec5a:	89 d1                	mov    %edx,%ecx
f011ec5c:	0f af c8             	imul   %eax,%ecx
f011ec5f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011ec64:	f7 e1                	mul    %ecx
f011ec66:	c1 ea 05             	shr    $0x5,%edx
f011ec69:	89 d0                	mov    %edx,%eax
f011ec6b:	c1 e0 02             	shl    $0x2,%eax
f011ec6e:	01 d0                	add    %edx,%eax
f011ec70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ec77:	01 d0                	add    %edx,%eax
f011ec79:	c1 e0 02             	shl    $0x2,%eax
f011ec7c:	29 c1                	sub    %eax,%ecx
f011ec7e:	89 ca                	mov    %ecx,%edx
f011ec80:	85 d2                	test   %edx,%edx
f011ec82:	74 03                	je     f011ec87 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011ec84:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ec87:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ec8a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ec8d:	eb 69                	jmp    f011ecf8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011ec8f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec92:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ec98:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011ec9b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ec9e:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011eca4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011eca7:	0f af c2             	imul   %edx,%eax
f011ecaa:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011ecaf:	f7 e2                	mul    %edx
f011ecb1:	89 d0                	mov    %edx,%eax
f011ecb3:	c1 e8 05             	shr    $0x5,%eax
f011ecb6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011ecb9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ecbc:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011ecc2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ecc5:	89 d1                	mov    %edx,%ecx
f011ecc7:	0f af c8             	imul   %eax,%ecx
f011ecca:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011eccf:	f7 e1                	mul    %ecx
f011ecd1:	c1 ea 05             	shr    $0x5,%edx
f011ecd4:	89 d0                	mov    %edx,%eax
f011ecd6:	c1 e0 02             	shl    $0x2,%eax
f011ecd9:	01 d0                	add    %edx,%eax
f011ecdb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ece2:	01 d0                	add    %edx,%eax
f011ece4:	c1 e0 02             	shl    $0x2,%eax
f011ece7:	29 c1                	sub    %eax,%ecx
f011ece9:	89 ca                	mov    %ecx,%edx
f011eceb:	85 d2                	test   %edx,%edx
f011eced:	74 03                	je     f011ecf2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011ecef:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011ecf2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ecf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011ecf8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ecfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ecfe:	01 c2                	add    %eax,%edx
f011ed00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed03:	01 d0                	add    %edx,%eax
}
f011ed05:	c9                   	leave  
f011ed06:	c3                   	ret    

f011ed07 <schenv>:


void schenv()
{
f011ed07:	55                   	push   %ebp
f011ed08:	89 e5                	mov    %esp,%ebp
f011ed0a:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011ed0d:	c6 05 e0 2d 6c f0 00 	movb   $0x0,0xf06c2de0
	__ne = NULL;
f011ed14:	c7 05 cc 1a 6c f0 00 	movl   $0x0,0xf06c1acc
f011ed1b:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011ed1e:	83 ec 0c             	sub    $0xc,%esp
f011ed21:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ed26:	e8 fd 0f ff ff       	call   f010fd28 <acquire_spinlock>
f011ed2b:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ed2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ed35:	eb 3f                	jmp    f011ed76 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011ed37:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011ed3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed3f:	c1 e2 04             	shl    $0x4,%edx
f011ed42:	01 d0                	add    %edx,%eax
f011ed44:	83 ec 0c             	sub    $0xc,%esp
f011ed47:	50                   	push   %eax
f011ed48:	e8 45 62 fe ff       	call   f0104f92 <queue_size>
f011ed4d:	83 c4 10             	add    $0x10,%esp
f011ed50:	85 c0                	test   %eax,%eax
f011ed52:	74 1f                	je     f011ed73 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011ed54:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011ed59:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed5c:	c1 e2 04             	shl    $0x4,%edx
f011ed5f:	01 d0                	add    %edx,%eax
f011ed61:	8b 40 04             	mov    0x4(%eax),%eax
f011ed64:	a3 cc 1a 6c f0       	mov    %eax,0xf06c1acc
				__nl = i;
f011ed69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ed6c:	a2 e0 2d 6c f0       	mov    %al,0xf06c2de0
				break;
f011ed71:	eb 10                	jmp    f011ed83 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011ed73:	ff 45 f4             	incl   -0xc(%ebp)
f011ed76:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ed7b:	0f b6 c0             	movzbl %al,%eax
f011ed7e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ed81:	7f b4                	jg     f011ed37 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011ed83:	83 ec 0c             	sub    $0xc,%esp
f011ed86:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ed8b:	e8 1f 10 ff ff       	call   f010fdaf <release_spinlock>
f011ed90:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011ed93:	e8 01 cd fe ff       	call   f010ba99 <get_cpu_proc>
f011ed98:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011ed9b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ed9f:	0f 84 82 00 00 00    	je     f011ee27 <schenv+0x120>
	{
		if (__ne != NULL)
f011eda5:	a1 cc 1a 6c f0       	mov    0xf06c1acc,%eax
f011edaa:	85 c0                	test   %eax,%eax
f011edac:	74 49                	je     f011edf7 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011edae:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011edb3:	0f b6 c0             	movzbl %al,%eax
f011edb6:	8d 50 01             	lea    0x1(%eax),%edx
f011edb9:	a0 e0 2d 6c f0       	mov    0xf06c2de0,%al
f011edbe:	0f b6 c0             	movzbl %al,%eax
f011edc1:	39 c2                	cmp    %eax,%edx
f011edc3:	7d 62                	jge    f011ee27 <schenv+0x120>
			{
				__ne = cur_env;
f011edc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011edc8:	a3 cc 1a 6c f0       	mov    %eax,0xf06c1acc
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011edcd:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011edd2:	0f b6 c0             	movzbl %al,%eax
f011edd5:	8a 15 44 2d 6c f0    	mov    0xf06c2d44,%dl
f011eddb:	0f b6 d2             	movzbl %dl,%edx
f011edde:	4a                   	dec    %edx
f011eddf:	39 d0                	cmp    %edx,%eax
f011ede1:	7d 08                	jge    f011edeb <schenv+0xe4>
f011ede3:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ede8:	40                   	inc    %eax
f011ede9:	eb 05                	jmp    f011edf0 <schenv+0xe9>
f011edeb:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011edf0:	a2 e0 2d 6c f0       	mov    %al,0xf06c2de0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011edf5:	eb 30                	jmp    f011ee27 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011edf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011edfa:	a3 cc 1a 6c f0       	mov    %eax,0xf06c1acc
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011edff:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ee04:	0f b6 c0             	movzbl %al,%eax
f011ee07:	8a 15 44 2d 6c f0    	mov    0xf06c2d44,%dl
f011ee0d:	0f b6 d2             	movzbl %dl,%edx
f011ee10:	4a                   	dec    %edx
f011ee11:	39 d0                	cmp    %edx,%eax
f011ee13:	7d 08                	jge    f011ee1d <schenv+0x116>
f011ee15:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ee1a:	40                   	inc    %eax
f011ee1b:	eb 05                	jmp    f011ee22 <schenv+0x11b>
f011ee1d:	a0 c1 15 6c f0       	mov    0xf06c15c1,%al
f011ee22:	a2 e0 2d 6c f0       	mov    %al,0xf06c2de0
		}
	}
}
f011ee27:	90                   	nop
f011ee28:	c9                   	leave  
f011ee29:	c3                   	ret    

f011ee2a <chksch>:

void chksch(uint8 onoff)
{
f011ee2a:	55                   	push   %ebp
f011ee2b:	89 e5                	mov    %esp,%ebp
f011ee2d:	83 ec 18             	sub    $0x18,%esp
f011ee30:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee33:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011ee36:	e8 d7 78 fe ff       	call   f0106712 <isSchedMethodBSD>
f011ee3b:	85 c0                	test   %eax,%eax
f011ee3d:	74 48                	je     f011ee87 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011ee3f:	e8 7c 78 fe ff       	call   f01066c0 <get_load_average>
f011ee44:	a3 68 2d 6c f0       	mov    %eax,0xf06c2d68
f011ee49:	a1 68 2d 6c f0       	mov    0xf06c2d68,%eax
f011ee4e:	a3 7c 18 6c f0       	mov    %eax,0xf06c187c
		acquire_spinlock(&ProcessQueues.qlock);
f011ee53:	83 ec 0c             	sub    $0xc,%esp
f011ee56:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ee5b:	e8 c8 0e ff ff       	call   f010fd28 <acquire_spinlock>
f011ee60:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011ee63:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011ee68:	a3 20 17 6c f0       	mov    %eax,0xf06c1720
		}
		release_spinlock(&ProcessQueues.qlock);
f011ee6d:	83 ec 0c             	sub    $0xc,%esp
f011ee70:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ee75:	e8 35 0f ff ff       	call   f010fdaf <release_spinlock>
f011ee7a:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011ee7d:	c7 05 dc 1a 6c f0 01 	movl   $0x1,0xf06c1adc
f011ee84:	00 00 00 
	}
	__chkstatus = onoff;
f011ee87:	8a 45 f4             	mov    -0xc(%ebp),%al
f011ee8a:	a2 c8 1a 6c f0       	mov    %al,0xf06c1ac8
}
f011ee8f:	90                   	nop
f011ee90:	c9                   	leave  
f011ee91:	c3                   	ret    

f011ee92 <chk1>:
void chk1()
{
f011ee92:	55                   	push   %ebp
f011ee93:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011ee95:	90                   	nop
f011ee96:	5d                   	pop    %ebp
f011ee97:	c3                   	ret    

f011ee98 <chk2>:
void chk2(struct Env* __se)
{
f011ee98:	55                   	push   %ebp
f011ee99:	89 e5                	mov    %esp,%ebp
f011ee9b:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011ee9e:	a0 c8 1a 6c f0       	mov    0xf06c1ac8,%al
f011eea3:	84 c0                	test   %al,%al
f011eea5:	0f 84 59 03 00 00    	je     f011f204 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011eeab:	e8 62 78 fe ff       	call   f0106712 <isSchedMethodBSD>
f011eeb0:	85 c0                	test   %eax,%eax
f011eeb2:	0f 84 4d 03 00 00    	je     f011f205 <chk2+0x36d>
	{
		__nla = get_load_average();
f011eeb8:	e8 03 78 fe ff       	call   f01066c0 <get_load_average>
f011eebd:	a3 b4 17 6c f0       	mov    %eax,0xf06c17b4
		acquire_spinlock(&ProcessQueues.qlock);
f011eec2:	83 ec 0c             	sub    $0xc,%esp
f011eec5:	68 e0 15 6c f0       	push   $0xf06c15e0
f011eeca:	e8 59 0e ff ff       	call   f010fd28 <acquire_spinlock>
f011eecf:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011eed2:	a1 6c 16 6c f0       	mov    0xf06c166c,%eax
f011eed7:	a3 d0 1a 6c f0       	mov    %eax,0xf06c1ad0
		}
		release_spinlock(&ProcessQueues.qlock);
f011eedc:	83 ec 0c             	sub    $0xc,%esp
f011eedf:	68 e0 15 6c f0       	push   $0xf06c15e0
f011eee4:	e8 c6 0e ff ff       	call   f010fdaf <release_spinlock>
f011eee9:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011eeec:	a1 dc 1a 6c f0       	mov    0xf06c1adc,%eax
f011eef1:	85 c0                	test   %eax,%eax
f011eef3:	74 72                	je     f011ef67 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011eef5:	83 ec 0c             	sub    $0xc,%esp
f011eef8:	68 e0 15 6c f0       	push   $0xf06c15e0
f011eefd:	e8 26 0e ff ff       	call   f010fd28 <acquire_spinlock>
f011ef02:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011ef05:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ef09:	0f 95 c0             	setne  %al
f011ef0c:	0f b6 c0             	movzbl %al,%eax
f011ef0f:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ef14:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ef19:	0f b6 c0             	movzbl %al,%eax
f011ef1c:	48                   	dec    %eax
f011ef1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ef20:	eb 20                	jmp    f011ef42 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011ef22:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011ef27:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ef2a:	c1 e2 04             	shl    $0x4,%edx
f011ef2d:	01 d0                	add    %edx,%eax
f011ef2f:	8b 40 0c             	mov    0xc(%eax),%eax
f011ef32:	8b 15 94 1c 6c f0    	mov    0xf06c1c94,%edx
f011ef38:	01 d0                	add    %edx,%eax
f011ef3a:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ef3f:	ff 4d f4             	decl   -0xc(%ebp)
f011ef42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ef46:	79 da                	jns    f011ef22 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011ef48:	c7 05 dc 1a 6c f0 00 	movl   $0x0,0xf06c1adc
f011ef4f:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011ef52:	83 ec 0c             	sub    $0xc,%esp
f011ef55:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ef5a:	e8 50 0e ff ff       	call   f010fdaf <release_spinlock>
f011ef5f:	83 c4 10             	add    $0x10,%esp
f011ef62:	e9 91 02 00 00       	jmp    f011f1f8 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011ef67:	8b 15 20 17 6c f0    	mov    0xf06c1720,%edx
f011ef6d:	a1 d0 1a 6c f0       	mov    0xf06c1ad0,%eax
f011ef72:	39 c2                	cmp    %eax,%edx
f011ef74:	74 63                	je     f011efd9 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011ef76:	83 ec 0c             	sub    $0xc,%esp
f011ef79:	68 e0 15 6c f0       	push   $0xf06c15e0
f011ef7e:	e8 a5 0d ff ff       	call   f010fd28 <acquire_spinlock>
f011ef83:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011ef86:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ef8a:	0f 95 c0             	setne  %al
f011ef8d:	0f b6 c0             	movzbl %al,%eax
f011ef90:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011ef95:	a0 44 2d 6c f0       	mov    0xf06c2d44,%al
f011ef9a:	0f b6 c0             	movzbl %al,%eax
f011ef9d:	48                   	dec    %eax
f011ef9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011efa1:	eb 20                	jmp    f011efc3 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011efa3:	a1 70 16 6c f0       	mov    0xf06c1670,%eax
f011efa8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011efab:	c1 e2 04             	shl    $0x4,%edx
f011efae:	01 d0                	add    %edx,%eax
f011efb0:	8b 40 0c             	mov    0xc(%eax),%eax
f011efb3:	8b 15 94 1c 6c f0    	mov    0xf06c1c94,%edx
f011efb9:	01 d0                	add    %edx,%eax
f011efbb:	a3 94 1c 6c f0       	mov    %eax,0xf06c1c94
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011efc0:	ff 4d f0             	decl   -0x10(%ebp)
f011efc3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011efc7:	79 da                	jns    f011efa3 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011efc9:	83 ec 0c             	sub    $0xc,%esp
f011efcc:	68 e0 15 6c f0       	push   $0xf06c15e0
f011efd1:	e8 d9 0d ff ff       	call   f010fdaf <release_spinlock>
f011efd6:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011efd9:	e8 7b 76 fe ff       	call   f0106659 <timer_ticks>
f011efde:	6a 00                	push   $0x0
f011efe0:	68 e8 03 00 00       	push   $0x3e8
f011efe5:	52                   	push   %edx
f011efe6:	50                   	push   %eax
f011efe7:	e8 f0 31 00 00       	call   f01221dc <__moddi3>
f011efec:	83 c4 10             	add    $0x10,%esp
f011efef:	09 d0                	or     %edx,%eax
f011eff1:	85 c0                	test   %eax,%eax
f011eff3:	75 32                	jne    f011f027 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011eff5:	8b 15 7c 18 6c f0    	mov    0xf06c187c,%edx
f011effb:	a1 b4 17 6c f0       	mov    0xf06c17b4,%eax
f011f000:	39 c2                	cmp    %eax,%edx
f011f002:	75 19                	jne    f011f01d <chk2+0x185>
f011f004:	68 b5 0d 13 f0       	push   $0xf0130db5
f011f009:	68 f3 09 13 f0       	push   $0xf01309f3
f011f00e:	68 35 02 00 00       	push   $0x235
f011f013:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f018:	e8 ac 13 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011f01d:	a1 b4 17 6c f0       	mov    0xf06c17b4,%eax
f011f022:	a3 7c 18 6c f0       	mov    %eax,0xf06c187c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011f027:	e8 2d 76 fe ff       	call   f0106659 <timer_ticks>
f011f02c:	6a 00                	push   $0x0
f011f02e:	6a 64                	push   $0x64
f011f030:	52                   	push   %edx
f011f031:	50                   	push   %eax
f011f032:	e8 a5 31 00 00       	call   f01221dc <__moddi3>
f011f037:	83 c4 10             	add    $0x10,%esp
f011f03a:	09 d0                	or     %edx,%eax
f011f03c:	85 c0                	test   %eax,%eax
f011f03e:	0f 85 b4 01 00 00    	jne    f011f1f8 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011f044:	8b 0d 68 2d 6c f0    	mov    0xf06c2d68,%ecx
f011f04a:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f04f:	f7 e9                	imul   %ecx
f011f051:	c1 fa 05             	sar    $0x5,%edx
f011f054:	89 c8                	mov    %ecx,%eax
f011f056:	c1 f8 1f             	sar    $0x1f,%eax
f011f059:	29 c2                	sub    %eax,%edx
f011f05b:	89 d0                	mov    %edx,%eax
f011f05d:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011f060:	8b 0d 68 2d 6c f0    	mov    0xf06c2d68,%ecx
f011f066:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f06b:	f7 e9                	imul   %ecx
f011f06d:	c1 fa 05             	sar    $0x5,%edx
f011f070:	89 c8                	mov    %ecx,%eax
f011f072:	c1 f8 1f             	sar    $0x1f,%eax
f011f075:	29 c2                	sub    %eax,%edx
f011f077:	89 d0                	mov    %edx,%eax
f011f079:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f07c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f07f:	89 d0                	mov    %edx,%eax
f011f081:	c1 e0 02             	shl    $0x2,%eax
f011f084:	01 d0                	add    %edx,%eax
f011f086:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f08d:	01 d0                	add    %edx,%eax
f011f08f:	c1 e0 02             	shl    $0x2,%eax
f011f092:	29 c1                	sub    %eax,%ecx
f011f094:	89 c8                	mov    %ecx,%eax
f011f096:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011f099:	8b 0d b4 17 6c f0    	mov    0xf06c17b4,%ecx
f011f09f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f0a4:	f7 e9                	imul   %ecx
f011f0a6:	c1 fa 05             	sar    $0x5,%edx
f011f0a9:	89 c8                	mov    %ecx,%eax
f011f0ab:	c1 f8 1f             	sar    $0x1f,%eax
f011f0ae:	29 c2                	sub    %eax,%edx
f011f0b0:	89 d0                	mov    %edx,%eax
f011f0b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011f0b5:	8b 0d b4 17 6c f0    	mov    0xf06c17b4,%ecx
f011f0bb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f0c0:	f7 e9                	imul   %ecx
f011f0c2:	c1 fa 05             	sar    $0x5,%edx
f011f0c5:	89 c8                	mov    %ecx,%eax
f011f0c7:	c1 f8 1f             	sar    $0x1f,%eax
f011f0ca:	29 c2                	sub    %eax,%edx
f011f0cc:	89 d0                	mov    %edx,%eax
f011f0ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f0d1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f0d4:	89 d0                	mov    %edx,%eax
f011f0d6:	c1 e0 02             	shl    $0x2,%eax
f011f0d9:	01 d0                	add    %edx,%eax
f011f0db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f0e2:	01 d0                	add    %edx,%eax
f011f0e4:	c1 e0 02             	shl    $0x2,%eax
f011f0e7:	29 c1                	sub    %eax,%ecx
f011f0e9:	89 c8                	mov    %ecx,%eax
f011f0eb:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f0ee:	8b 15 d0 1a 6c f0    	mov    0xf06c1ad0,%edx
f011f0f4:	a1 20 17 6c f0       	mov    0xf06c1720,%eax
f011f0f9:	39 c2                	cmp    %eax,%edx
f011f0fb:	0f 85 ed 00 00 00    	jne    f011f1ee <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f101:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f106:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f109:	7e 5b                	jle    f011f166 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f10b:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f110:	83 ec 08             	sub    $0x8,%esp
f011f113:	ff 75 e0             	pushl  -0x20(%ebp)
f011f116:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f119:	ff 75 e8             	pushl  -0x18(%ebp)
f011f11c:	ff 75 ec             	pushl  -0x14(%ebp)
f011f11f:	50                   	push   %eax
f011f120:	68 c8 0d 13 f0       	push   $0xf0130dc8
f011f125:	e8 61 1e fe ff       	call   f0100f8b <cprintf>
f011f12a:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f12d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f130:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f133:	0f 8f b5 00 00 00    	jg     f011f1ee <chk2+0x356>
f011f139:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f13c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f13f:	75 0c                	jne    f011f14d <chk2+0x2b5>
f011f141:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f144:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f147:	0f 8d a1 00 00 00    	jge    f011f1ee <chk2+0x356>
f011f14d:	68 10 0e 13 f0       	push   $0xf0130e10
f011f152:	68 f3 09 13 f0       	push   $0xf01309f3
f011f157:	68 4a 02 00 00       	push   $0x24a
f011f15c:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f161:	e8 63 12 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011f166:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f16b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f16e:	7d 53                	jge    f011f1c3 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f170:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f175:	83 ec 08             	sub    $0x8,%esp
f011f178:	ff 75 e0             	pushl  -0x20(%ebp)
f011f17b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f17e:	ff 75 e8             	pushl  -0x18(%ebp)
f011f181:	ff 75 ec             	pushl  -0x14(%ebp)
f011f184:	50                   	push   %eax
f011f185:	68 50 0e 13 f0       	push   $0xf0130e50
f011f18a:	e8 fc 1d fe ff       	call   f0100f8b <cprintf>
f011f18f:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f192:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f195:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f198:	7c 54                	jl     f011f1ee <chk2+0x356>
f011f19a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f19d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f1a0:	75 08                	jne    f011f1aa <chk2+0x312>
f011f1a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f1a5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f1a8:	7e 44                	jle    f011f1ee <chk2+0x356>
f011f1aa:	68 98 0e 13 f0       	push   $0xf0130e98
f011f1af:	68 f3 09 13 f0       	push   $0xf01309f3
f011f1b4:	68 50 02 00 00       	push   $0x250
f011f1b9:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f1be:	e8 06 12 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011f1c3:	a1 94 1c 6c f0       	mov    0xf06c1c94,%eax
f011f1c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f1cb:	75 21                	jne    f011f1ee <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011f1cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f1d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f1d3:	74 19                	je     f011f1ee <chk2+0x356>
f011f1d5:	68 d8 0e 13 f0       	push   $0xf0130ed8
f011f1da:	68 f3 09 13 f0       	push   $0xf01309f3
f011f1df:	68 54 02 00 00       	push   $0x254
f011f1e4:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f1e9:	e8 db 11 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011f1ee:	a1 b4 17 6c f0       	mov    0xf06c17b4,%eax
f011f1f3:	a3 68 2d 6c f0       	mov    %eax,0xf06c2d68
			}
		}
		__pnexit = __nnexit;
f011f1f8:	a1 d0 1a 6c f0       	mov    0xf06c1ad0,%eax
f011f1fd:	a3 20 17 6c f0       	mov    %eax,0xf06c1720
f011f202:	eb 01                	jmp    f011f205 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011f204:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011f205:	c9                   	leave  
f011f206:	c3                   	ret    

f011f207 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011f207:	55                   	push   %ebp
f011f208:	89 e5                	mov    %esp,%ebp
f011f20a:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f20d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f214:	eb 40                	jmp    f011f256 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011f216:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f219:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f21f:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f224:	83 ec 08             	sub    $0x8,%esp
f011f227:	52                   	push   %edx
f011f228:	50                   	push   %eax
f011f229:	e8 af 01 00 00       	call   f011f3dd <check_va2pa>
f011f22e:	83 c4 10             	add    $0x10,%esp
f011f231:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f234:	74 19                	je     f011f24f <check_boot_pgdir+0x48>
f011f236:	68 ec 0e 13 f0       	push   $0xf0130eec
f011f23b:	68 f3 09 13 f0       	push   $0xf01309f3
f011f240:	68 9b 02 00 00       	push   $0x29b
f011f245:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f24a:	e8 ea 10 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011f24f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f256:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f259:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011f25f:	a1 98 1c 6c f0       	mov    0xf06c1c98,%eax
f011f264:	39 c2                	cmp    %eax,%edx
f011f266:	72 ae                	jb     f011f216 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f268:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f26f:	e9 81 00 00 00       	jmp    f011f2f5 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011f274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f277:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011f27c:	85 c0                	test   %eax,%eax
f011f27e:	74 6d                	je     f011f2ed <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011f280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f283:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011f289:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f28e:	83 ec 08             	sub    $0x8,%esp
f011f291:	52                   	push   %edx
f011f292:	50                   	push   %eax
f011f293:	e8 45 01 00 00       	call   f011f3dd <check_va2pa>
f011f298:	83 c4 10             	add    $0x10,%esp
f011f29b:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f011f2a2:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011f2a9:	77 17                	ja     f011f2c2 <check_boot_pgdir+0xbb>
f011f2ab:	ff 75 f0             	pushl  -0x10(%ebp)
f011f2ae:	68 24 0f 13 f0       	push   $0xf0130f24
f011f2b3:	68 a9 02 00 00       	push   $0x2a9
f011f2b8:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f2bd:	e8 77 10 fe ff       	call   f0100339 <_panic>
f011f2c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f2c5:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011f2cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f2ce:	01 ca                	add    %ecx,%edx
f011f2d0:	39 d0                	cmp    %edx,%eax
f011f2d2:	74 1a                	je     f011f2ee <check_boot_pgdir+0xe7>
f011f2d4:	68 58 0f 13 f0       	push   $0xf0130f58
f011f2d9:	68 f3 09 13 f0       	push   $0xf01309f3
f011f2de:	68 a9 02 00 00       	push   $0x2a9
f011f2e3:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f2e8:	e8 4c 10 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011f2ed:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011f2ee:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011f2f5:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011f2fc:	0f 86 72 ff ff ff    	jbe    f011f274 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f302:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f309:	e9 af 00 00 00       	jmp    f011f3bd <check_boot_pgdir+0x1b6>
		switch (i) {
f011f30e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f311:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f316:	74 11                	je     f011f329 <check_boot_pgdir+0x122>
f011f318:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011f31d:	72 36                	jb     f011f355 <check_boot_pgdir+0x14e>
f011f31f:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011f324:	83 f8 02             	cmp    $0x2,%eax
f011f327:	77 2c                	ja     f011f355 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011f329:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f32e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f331:	c1 e2 02             	shl    $0x2,%edx
f011f334:	01 d0                	add    %edx,%eax
f011f336:	8b 00                	mov    (%eax),%eax
f011f338:	85 c0                	test   %eax,%eax
f011f33a:	75 7a                	jne    f011f3b6 <check_boot_pgdir+0x1af>
f011f33c:	68 de 0f 13 f0       	push   $0xf0130fde
f011f341:	68 f3 09 13 f0       	push   $0xf01309f3
f011f346:	68 b4 02 00 00       	push   $0x2b4
f011f34b:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f350:	e8 e4 0f fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011f355:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011f35c:	76 2c                	jbe    f011f38a <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011f35e:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f363:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f366:	c1 e2 02             	shl    $0x2,%edx
f011f369:	01 d0                	add    %edx,%eax
f011f36b:	8b 00                	mov    (%eax),%eax
f011f36d:	85 c0                	test   %eax,%eax
f011f36f:	75 48                	jne    f011f3b9 <check_boot_pgdir+0x1b2>
f011f371:	68 de 0f 13 f0       	push   $0xf0130fde
f011f376:	68 f3 09 13 f0       	push   $0xf01309f3
f011f37b:	68 b8 02 00 00       	push   $0x2b8
f011f380:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f385:	e8 af 0f fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011f38a:	a1 a0 2c 6c f0       	mov    0xf06c2ca0,%eax
f011f38f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f392:	c1 e2 02             	shl    $0x2,%edx
f011f395:	01 d0                	add    %edx,%eax
f011f397:	8b 00                	mov    (%eax),%eax
f011f399:	85 c0                	test   %eax,%eax
f011f39b:	74 1c                	je     f011f3b9 <check_boot_pgdir+0x1b2>
f011f39d:	68 f4 0f 13 f0       	push   $0xf0130ff4
f011f3a2:	68 f3 09 13 f0       	push   $0xf01309f3
f011f3a7:	68 ba 02 00 00       	push   $0x2ba
f011f3ac:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f3b1:	e8 83 0f fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011f3b6:	90                   	nop
f011f3b7:	eb 01                	jmp    f011f3ba <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011f3b9:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011f3ba:	ff 45 f4             	incl   -0xc(%ebp)
f011f3bd:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011f3c4:	0f 86 44 ff ff ff    	jbe    f011f30e <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011f3ca:	83 ec 0c             	sub    $0xc,%esp
f011f3cd:	68 10 10 13 f0       	push   $0xf0131010
f011f3d2:	e8 b4 1b fe ff       	call   f0100f8b <cprintf>
f011f3d7:	83 c4 10             	add    $0x10,%esp
}
f011f3da:	90                   	nop
f011f3db:	c9                   	leave  
f011f3dc:	c3                   	ret    

f011f3dd <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011f3dd:	55                   	push   %ebp
f011f3de:	89 e5                	mov    %esp,%ebp
f011f3e0:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011f3e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f3e6:	c1 e8 16             	shr    $0x16,%eax
f011f3e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f3f0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f3f3:	01 d0                	add    %edx,%eax
f011f3f5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011f3f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f3fb:	8b 00                	mov    (%eax),%eax
f011f3fd:	83 e0 01             	and    $0x1,%eax
f011f400:	85 c0                	test   %eax,%eax
f011f402:	75 0a                	jne    f011f40e <check_va2pa+0x31>
		return ~0;
f011f404:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f409:	e9 87 00 00 00       	jmp    f011f495 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011f40e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f411:	8b 00                	mov    (%eax),%eax
f011f413:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011f418:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f41b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f41e:	c1 e8 0c             	shr    $0xc,%eax
f011f421:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f424:	a1 78 18 6c f0       	mov    0xf06c1878,%eax
f011f429:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011f42c:	72 17                	jb     f011f445 <check_va2pa+0x68>
f011f42e:	ff 75 f0             	pushl  -0x10(%ebp)
f011f431:	68 34 10 13 f0       	push   $0xf0131034
f011f436:	68 d0 02 00 00       	push   $0x2d0
f011f43b:	68 3b 0a 13 f0       	push   $0xf0130a3b
f011f440:	e8 f4 0e fe ff       	call   f0100339 <_panic>
f011f445:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f448:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011f44d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011f450:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f453:	c1 e8 0c             	shr    $0xc,%eax
f011f456:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f45b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f462:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f465:	01 d0                	add    %edx,%eax
f011f467:	8b 00                	mov    (%eax),%eax
f011f469:	83 e0 01             	and    $0x1,%eax
f011f46c:	85 c0                	test   %eax,%eax
f011f46e:	75 07                	jne    f011f477 <check_va2pa+0x9a>
		return ~0;
f011f470:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011f475:	eb 1e                	jmp    f011f495 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011f477:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f47a:	c1 e8 0c             	shr    $0xc,%eax
f011f47d:	25 ff 03 00 00       	and    $0x3ff,%eax
f011f482:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f489:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f48c:	01 d0                	add    %edx,%eax
f011f48e:	8b 00                	mov    (%eax),%eax
f011f490:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011f495:	c9                   	leave  
f011f496:	c3                   	ret    

f011f497 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011f497:	55                   	push   %ebp
f011f498:	89 e5                	mov    %esp,%ebp
f011f49a:	53                   	push   %ebx
f011f49b:	83 ec 14             	sub    $0x14,%esp
f011f49e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f4a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f4a4:	8b 45 14             	mov    0x14(%ebp),%eax
f011f4a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011f4aa:	8b 45 18             	mov    0x18(%ebp),%eax
f011f4ad:	ba 00 00 00 00       	mov    $0x0,%edx
f011f4b2:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f4b5:	77 55                	ja     f011f50c <printnum+0x75>
f011f4b7:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011f4ba:	72 05                	jb     f011f4c1 <printnum+0x2a>
f011f4bc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f4bf:	77 4b                	ja     f011f50c <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011f4c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011f4c4:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011f4c7:	8b 45 18             	mov    0x18(%ebp),%eax
f011f4ca:	ba 00 00 00 00       	mov    $0x0,%edx
f011f4cf:	52                   	push   %edx
f011f4d0:	50                   	push   %eax
f011f4d1:	ff 75 f4             	pushl  -0xc(%ebp)
f011f4d4:	ff 75 f0             	pushl  -0x10(%ebp)
f011f4d7:	e8 98 2e 00 00       	call   f0122374 <__udivdi3>
f011f4dc:	83 c4 10             	add    $0x10,%esp
f011f4df:	83 ec 04             	sub    $0x4,%esp
f011f4e2:	ff 75 20             	pushl  0x20(%ebp)
f011f4e5:	53                   	push   %ebx
f011f4e6:	ff 75 18             	pushl  0x18(%ebp)
f011f4e9:	52                   	push   %edx
f011f4ea:	50                   	push   %eax
f011f4eb:	ff 75 0c             	pushl  0xc(%ebp)
f011f4ee:	ff 75 08             	pushl  0x8(%ebp)
f011f4f1:	e8 a1 ff ff ff       	call   f011f497 <printnum>
f011f4f6:	83 c4 20             	add    $0x20,%esp
f011f4f9:	eb 1a                	jmp    f011f515 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011f4fb:	83 ec 08             	sub    $0x8,%esp
f011f4fe:	ff 75 0c             	pushl  0xc(%ebp)
f011f501:	ff 75 20             	pushl  0x20(%ebp)
f011f504:	8b 45 08             	mov    0x8(%ebp),%eax
f011f507:	ff d0                	call   *%eax
f011f509:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011f50c:	ff 4d 1c             	decl   0x1c(%ebp)
f011f50f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011f513:	7f e6                	jg     f011f4fb <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011f515:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011f518:	bb 00 00 00 00       	mov    $0x0,%ebx
f011f51d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f520:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f523:	53                   	push   %ebx
f011f524:	51                   	push   %ecx
f011f525:	52                   	push   %edx
f011f526:	50                   	push   %eax
f011f527:	e8 58 2f 00 00       	call   f0122484 <__umoddi3>
f011f52c:	83 c4 10             	add    $0x10,%esp
f011f52f:	05 94 12 13 f0       	add    $0xf0131294,%eax
f011f534:	8a 00                	mov    (%eax),%al
f011f536:	0f be c0             	movsbl %al,%eax
f011f539:	83 ec 08             	sub    $0x8,%esp
f011f53c:	ff 75 0c             	pushl  0xc(%ebp)
f011f53f:	50                   	push   %eax
f011f540:	8b 45 08             	mov    0x8(%ebp),%eax
f011f543:	ff d0                	call   *%eax
f011f545:	83 c4 10             	add    $0x10,%esp
}
f011f548:	90                   	nop
f011f549:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f54c:	c9                   	leave  
f011f54d:	c3                   	ret    

f011f54e <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011f54e:	55                   	push   %ebp
f011f54f:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f551:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f555:	7e 1c                	jle    f011f573 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011f557:	8b 45 08             	mov    0x8(%ebp),%eax
f011f55a:	8b 00                	mov    (%eax),%eax
f011f55c:	8d 50 08             	lea    0x8(%eax),%edx
f011f55f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f562:	89 10                	mov    %edx,(%eax)
f011f564:	8b 45 08             	mov    0x8(%ebp),%eax
f011f567:	8b 00                	mov    (%eax),%eax
f011f569:	83 e8 08             	sub    $0x8,%eax
f011f56c:	8b 50 04             	mov    0x4(%eax),%edx
f011f56f:	8b 00                	mov    (%eax),%eax
f011f571:	eb 40                	jmp    f011f5b3 <getuint+0x65>
	else if (lflag)
f011f573:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f577:	74 1e                	je     f011f597 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011f579:	8b 45 08             	mov    0x8(%ebp),%eax
f011f57c:	8b 00                	mov    (%eax),%eax
f011f57e:	8d 50 04             	lea    0x4(%eax),%edx
f011f581:	8b 45 08             	mov    0x8(%ebp),%eax
f011f584:	89 10                	mov    %edx,(%eax)
f011f586:	8b 45 08             	mov    0x8(%ebp),%eax
f011f589:	8b 00                	mov    (%eax),%eax
f011f58b:	83 e8 04             	sub    $0x4,%eax
f011f58e:	8b 00                	mov    (%eax),%eax
f011f590:	ba 00 00 00 00       	mov    $0x0,%edx
f011f595:	eb 1c                	jmp    f011f5b3 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011f597:	8b 45 08             	mov    0x8(%ebp),%eax
f011f59a:	8b 00                	mov    (%eax),%eax
f011f59c:	8d 50 04             	lea    0x4(%eax),%edx
f011f59f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5a2:	89 10                	mov    %edx,(%eax)
f011f5a4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5a7:	8b 00                	mov    (%eax),%eax
f011f5a9:	83 e8 04             	sub    $0x4,%eax
f011f5ac:	8b 00                	mov    (%eax),%eax
f011f5ae:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011f5b3:	5d                   	pop    %ebp
f011f5b4:	c3                   	ret    

f011f5b5 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011f5b5:	55                   	push   %ebp
f011f5b6:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011f5b8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011f5bc:	7e 1c                	jle    f011f5da <getint+0x25>
		return va_arg(*ap, long long);
f011f5be:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5c1:	8b 00                	mov    (%eax),%eax
f011f5c3:	8d 50 08             	lea    0x8(%eax),%edx
f011f5c6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5c9:	89 10                	mov    %edx,(%eax)
f011f5cb:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5ce:	8b 00                	mov    (%eax),%eax
f011f5d0:	83 e8 08             	sub    $0x8,%eax
f011f5d3:	8b 50 04             	mov    0x4(%eax),%edx
f011f5d6:	8b 00                	mov    (%eax),%eax
f011f5d8:	eb 38                	jmp    f011f612 <getint+0x5d>
	else if (lflag)
f011f5da:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f5de:	74 1a                	je     f011f5fa <getint+0x45>
		return va_arg(*ap, long);
f011f5e0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5e3:	8b 00                	mov    (%eax),%eax
f011f5e5:	8d 50 04             	lea    0x4(%eax),%edx
f011f5e8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5eb:	89 10                	mov    %edx,(%eax)
f011f5ed:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5f0:	8b 00                	mov    (%eax),%eax
f011f5f2:	83 e8 04             	sub    $0x4,%eax
f011f5f5:	8b 00                	mov    (%eax),%eax
f011f5f7:	99                   	cltd   
f011f5f8:	eb 18                	jmp    f011f612 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011f5fa:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5fd:	8b 00                	mov    (%eax),%eax
f011f5ff:	8d 50 04             	lea    0x4(%eax),%edx
f011f602:	8b 45 08             	mov    0x8(%ebp),%eax
f011f605:	89 10                	mov    %edx,(%eax)
f011f607:	8b 45 08             	mov    0x8(%ebp),%eax
f011f60a:	8b 00                	mov    (%eax),%eax
f011f60c:	83 e8 04             	sub    $0x4,%eax
f011f60f:	8b 00                	mov    (%eax),%eax
f011f611:	99                   	cltd   
}
f011f612:	5d                   	pop    %ebp
f011f613:	c3                   	ret    

f011f614 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011f614:	55                   	push   %ebp
f011f615:	89 e5                	mov    %esp,%ebp
f011f617:	56                   	push   %esi
f011f618:	53                   	push   %ebx
f011f619:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f61c:	eb 17                	jmp    f011f635 <vprintfmt+0x21>
			if (ch == '\0')
f011f61e:	85 db                	test   %ebx,%ebx
f011f620:	0f 84 c1 03 00 00    	je     f011f9e7 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011f626:	83 ec 08             	sub    $0x8,%esp
f011f629:	ff 75 0c             	pushl  0xc(%ebp)
f011f62c:	53                   	push   %ebx
f011f62d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f630:	ff d0                	call   *%eax
f011f632:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011f635:	8b 45 10             	mov    0x10(%ebp),%eax
f011f638:	8d 50 01             	lea    0x1(%eax),%edx
f011f63b:	89 55 10             	mov    %edx,0x10(%ebp)
f011f63e:	8a 00                	mov    (%eax),%al
f011f640:	0f b6 d8             	movzbl %al,%ebx
f011f643:	83 fb 25             	cmp    $0x25,%ebx
f011f646:	75 d6                	jne    f011f61e <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011f648:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011f64c:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011f653:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011f65a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011f661:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011f668:	8b 45 10             	mov    0x10(%ebp),%eax
f011f66b:	8d 50 01             	lea    0x1(%eax),%edx
f011f66e:	89 55 10             	mov    %edx,0x10(%ebp)
f011f671:	8a 00                	mov    (%eax),%al
f011f673:	0f b6 d8             	movzbl %al,%ebx
f011f676:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011f679:	83 f8 5b             	cmp    $0x5b,%eax
f011f67c:	0f 87 3d 03 00 00    	ja     f011f9bf <vprintfmt+0x3ab>
f011f682:	8b 04 85 b8 12 13 f0 	mov    -0xfeced48(,%eax,4),%eax
f011f689:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011f68b:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011f68f:	eb d7                	jmp    f011f668 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011f691:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011f695:	eb d1                	jmp    f011f668 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f697:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011f69e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f6a1:	89 d0                	mov    %edx,%eax
f011f6a3:	c1 e0 02             	shl    $0x2,%eax
f011f6a6:	01 d0                	add    %edx,%eax
f011f6a8:	01 c0                	add    %eax,%eax
f011f6aa:	01 d8                	add    %ebx,%eax
f011f6ac:	83 e8 30             	sub    $0x30,%eax
f011f6af:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011f6b2:	8b 45 10             	mov    0x10(%ebp),%eax
f011f6b5:	8a 00                	mov    (%eax),%al
f011f6b7:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011f6ba:	83 fb 2f             	cmp    $0x2f,%ebx
f011f6bd:	7e 3e                	jle    f011f6fd <vprintfmt+0xe9>
f011f6bf:	83 fb 39             	cmp    $0x39,%ebx
f011f6c2:	7f 39                	jg     f011f6fd <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011f6c4:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011f6c7:	eb d5                	jmp    f011f69e <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011f6c9:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6cc:	83 c0 04             	add    $0x4,%eax
f011f6cf:	89 45 14             	mov    %eax,0x14(%ebp)
f011f6d2:	8b 45 14             	mov    0x14(%ebp),%eax
f011f6d5:	83 e8 04             	sub    $0x4,%eax
f011f6d8:	8b 00                	mov    (%eax),%eax
f011f6da:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011f6dd:	eb 1f                	jmp    f011f6fe <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011f6df:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f6e3:	79 83                	jns    f011f668 <vprintfmt+0x54>
				width = 0;
f011f6e5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011f6ec:	e9 77 ff ff ff       	jmp    f011f668 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011f6f1:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011f6f8:	e9 6b ff ff ff       	jmp    f011f668 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011f6fd:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011f6fe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f702:	0f 89 60 ff ff ff    	jns    f011f668 <vprintfmt+0x54>
				width = precision, precision = -1;
f011f708:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f70b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f70e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f715:	e9 4e ff ff ff       	jmp    f011f668 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f71a:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f71d:	e9 46 ff ff ff       	jmp    f011f668 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f722:	8b 45 14             	mov    0x14(%ebp),%eax
f011f725:	83 c0 04             	add    $0x4,%eax
f011f728:	89 45 14             	mov    %eax,0x14(%ebp)
f011f72b:	8b 45 14             	mov    0x14(%ebp),%eax
f011f72e:	83 e8 04             	sub    $0x4,%eax
f011f731:	8b 00                	mov    (%eax),%eax
f011f733:	83 ec 08             	sub    $0x8,%esp
f011f736:	ff 75 0c             	pushl  0xc(%ebp)
f011f739:	50                   	push   %eax
f011f73a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f73d:	ff d0                	call   *%eax
f011f73f:	83 c4 10             	add    $0x10,%esp
			break;
f011f742:	e9 9b 02 00 00       	jmp    f011f9e2 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f747:	8b 45 14             	mov    0x14(%ebp),%eax
f011f74a:	83 c0 04             	add    $0x4,%eax
f011f74d:	89 45 14             	mov    %eax,0x14(%ebp)
f011f750:	8b 45 14             	mov    0x14(%ebp),%eax
f011f753:	83 e8 04             	sub    $0x4,%eax
f011f756:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f758:	85 db                	test   %ebx,%ebx
f011f75a:	79 02                	jns    f011f75e <vprintfmt+0x14a>
				err = -err;
f011f75c:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f75e:	83 fb 64             	cmp    $0x64,%ebx
f011f761:	7f 0b                	jg     f011f76e <vprintfmt+0x15a>
f011f763:	8b 34 9d 00 11 13 f0 	mov    -0xfecef00(,%ebx,4),%esi
f011f76a:	85 f6                	test   %esi,%esi
f011f76c:	75 19                	jne    f011f787 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f76e:	53                   	push   %ebx
f011f76f:	68 a5 12 13 f0       	push   $0xf01312a5
f011f774:	ff 75 0c             	pushl  0xc(%ebp)
f011f777:	ff 75 08             	pushl  0x8(%ebp)
f011f77a:	e8 70 02 00 00       	call   f011f9ef <printfmt>
f011f77f:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011f782:	e9 5b 02 00 00       	jmp    f011f9e2 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011f787:	56                   	push   %esi
f011f788:	68 ae 12 13 f0       	push   $0xf01312ae
f011f78d:	ff 75 0c             	pushl  0xc(%ebp)
f011f790:	ff 75 08             	pushl  0x8(%ebp)
f011f793:	e8 57 02 00 00       	call   f011f9ef <printfmt>
f011f798:	83 c4 10             	add    $0x10,%esp
			break;
f011f79b:	e9 42 02 00 00       	jmp    f011f9e2 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011f7a0:	8b 45 14             	mov    0x14(%ebp),%eax
f011f7a3:	83 c0 04             	add    $0x4,%eax
f011f7a6:	89 45 14             	mov    %eax,0x14(%ebp)
f011f7a9:	8b 45 14             	mov    0x14(%ebp),%eax
f011f7ac:	83 e8 04             	sub    $0x4,%eax
f011f7af:	8b 30                	mov    (%eax),%esi
f011f7b1:	85 f6                	test   %esi,%esi
f011f7b3:	75 05                	jne    f011f7ba <vprintfmt+0x1a6>
				p = "(null)";
f011f7b5:	be b1 12 13 f0       	mov    $0xf01312b1,%esi
			if (width > 0 && padc != '-')
f011f7ba:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f7be:	7e 6d                	jle    f011f82d <vprintfmt+0x219>
f011f7c0:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011f7c4:	74 67                	je     f011f82d <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011f7c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f7c9:	83 ec 08             	sub    $0x8,%esp
f011f7cc:	50                   	push   %eax
f011f7cd:	56                   	push   %esi
f011f7ce:	e8 26 05 00 00       	call   f011fcf9 <strnlen>
f011f7d3:	83 c4 10             	add    $0x10,%esp
f011f7d6:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011f7d9:	eb 16                	jmp    f011f7f1 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011f7db:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011f7df:	83 ec 08             	sub    $0x8,%esp
f011f7e2:	ff 75 0c             	pushl  0xc(%ebp)
f011f7e5:	50                   	push   %eax
f011f7e6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7e9:	ff d0                	call   *%eax
f011f7eb:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011f7ee:	ff 4d e4             	decl   -0x1c(%ebp)
f011f7f1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f7f5:	7f e4                	jg     f011f7db <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f7f7:	eb 34                	jmp    f011f82d <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011f7f9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f7fd:	74 1c                	je     f011f81b <vprintfmt+0x207>
f011f7ff:	83 fb 1f             	cmp    $0x1f,%ebx
f011f802:	7e 05                	jle    f011f809 <vprintfmt+0x1f5>
f011f804:	83 fb 7e             	cmp    $0x7e,%ebx
f011f807:	7e 12                	jle    f011f81b <vprintfmt+0x207>
					putch('?', putdat);
f011f809:	83 ec 08             	sub    $0x8,%esp
f011f80c:	ff 75 0c             	pushl  0xc(%ebp)
f011f80f:	6a 3f                	push   $0x3f
f011f811:	8b 45 08             	mov    0x8(%ebp),%eax
f011f814:	ff d0                	call   *%eax
f011f816:	83 c4 10             	add    $0x10,%esp
f011f819:	eb 0f                	jmp    f011f82a <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f81b:	83 ec 08             	sub    $0x8,%esp
f011f81e:	ff 75 0c             	pushl  0xc(%ebp)
f011f821:	53                   	push   %ebx
f011f822:	8b 45 08             	mov    0x8(%ebp),%eax
f011f825:	ff d0                	call   *%eax
f011f827:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f82a:	ff 4d e4             	decl   -0x1c(%ebp)
f011f82d:	89 f0                	mov    %esi,%eax
f011f82f:	8d 70 01             	lea    0x1(%eax),%esi
f011f832:	8a 00                	mov    (%eax),%al
f011f834:	0f be d8             	movsbl %al,%ebx
f011f837:	85 db                	test   %ebx,%ebx
f011f839:	74 24                	je     f011f85f <vprintfmt+0x24b>
f011f83b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f83f:	78 b8                	js     f011f7f9 <vprintfmt+0x1e5>
f011f841:	ff 4d e0             	decl   -0x20(%ebp)
f011f844:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f848:	79 af                	jns    f011f7f9 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f84a:	eb 13                	jmp    f011f85f <vprintfmt+0x24b>
				putch(' ', putdat);
f011f84c:	83 ec 08             	sub    $0x8,%esp
f011f84f:	ff 75 0c             	pushl  0xc(%ebp)
f011f852:	6a 20                	push   $0x20
f011f854:	8b 45 08             	mov    0x8(%ebp),%eax
f011f857:	ff d0                	call   *%eax
f011f859:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f85c:	ff 4d e4             	decl   -0x1c(%ebp)
f011f85f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f863:	7f e7                	jg     f011f84c <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011f865:	e9 78 01 00 00       	jmp    f011f9e2 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011f86a:	83 ec 08             	sub    $0x8,%esp
f011f86d:	ff 75 e8             	pushl  -0x18(%ebp)
f011f870:	8d 45 14             	lea    0x14(%ebp),%eax
f011f873:	50                   	push   %eax
f011f874:	e8 3c fd ff ff       	call   f011f5b5 <getint>
f011f879:	83 c4 10             	add    $0x10,%esp
f011f87c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f87f:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011f882:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f885:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f888:	85 d2                	test   %edx,%edx
f011f88a:	79 23                	jns    f011f8af <vprintfmt+0x29b>
				putch('-', putdat);
f011f88c:	83 ec 08             	sub    $0x8,%esp
f011f88f:	ff 75 0c             	pushl  0xc(%ebp)
f011f892:	6a 2d                	push   $0x2d
f011f894:	8b 45 08             	mov    0x8(%ebp),%eax
f011f897:	ff d0                	call   *%eax
f011f899:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011f89c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f89f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f8a2:	f7 d8                	neg    %eax
f011f8a4:	83 d2 00             	adc    $0x0,%edx
f011f8a7:	f7 da                	neg    %edx
f011f8a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f8ac:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011f8af:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f8b6:	e9 bc 00 00 00       	jmp    f011f977 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011f8bb:	83 ec 08             	sub    $0x8,%esp
f011f8be:	ff 75 e8             	pushl  -0x18(%ebp)
f011f8c1:	8d 45 14             	lea    0x14(%ebp),%eax
f011f8c4:	50                   	push   %eax
f011f8c5:	e8 84 fc ff ff       	call   f011f54e <getuint>
f011f8ca:	83 c4 10             	add    $0x10,%esp
f011f8cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f8d0:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011f8d3:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f8da:	e9 98 00 00 00       	jmp    f011f977 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011f8df:	83 ec 08             	sub    $0x8,%esp
f011f8e2:	ff 75 0c             	pushl  0xc(%ebp)
f011f8e5:	6a 58                	push   $0x58
f011f8e7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8ea:	ff d0                	call   *%eax
f011f8ec:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f8ef:	83 ec 08             	sub    $0x8,%esp
f011f8f2:	ff 75 0c             	pushl  0xc(%ebp)
f011f8f5:	6a 58                	push   $0x58
f011f8f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8fa:	ff d0                	call   *%eax
f011f8fc:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f8ff:	83 ec 08             	sub    $0x8,%esp
f011f902:	ff 75 0c             	pushl  0xc(%ebp)
f011f905:	6a 58                	push   $0x58
f011f907:	8b 45 08             	mov    0x8(%ebp),%eax
f011f90a:	ff d0                	call   *%eax
f011f90c:	83 c4 10             	add    $0x10,%esp
			break;
f011f90f:	e9 ce 00 00 00       	jmp    f011f9e2 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011f914:	83 ec 08             	sub    $0x8,%esp
f011f917:	ff 75 0c             	pushl  0xc(%ebp)
f011f91a:	6a 30                	push   $0x30
f011f91c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f91f:	ff d0                	call   *%eax
f011f921:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011f924:	83 ec 08             	sub    $0x8,%esp
f011f927:	ff 75 0c             	pushl  0xc(%ebp)
f011f92a:	6a 78                	push   $0x78
f011f92c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f92f:	ff d0                	call   *%eax
f011f931:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011f934:	8b 45 14             	mov    0x14(%ebp),%eax
f011f937:	83 c0 04             	add    $0x4,%eax
f011f93a:	89 45 14             	mov    %eax,0x14(%ebp)
f011f93d:	8b 45 14             	mov    0x14(%ebp),%eax
f011f940:	83 e8 04             	sub    $0x4,%eax
f011f943:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011f945:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f948:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011f94f:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011f956:	eb 1f                	jmp    f011f977 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011f958:	83 ec 08             	sub    $0x8,%esp
f011f95b:	ff 75 e8             	pushl  -0x18(%ebp)
f011f95e:	8d 45 14             	lea    0x14(%ebp),%eax
f011f961:	50                   	push   %eax
f011f962:	e8 e7 fb ff ff       	call   f011f54e <getuint>
f011f967:	83 c4 10             	add    $0x10,%esp
f011f96a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f96d:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011f970:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011f977:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011f97b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f97e:	83 ec 04             	sub    $0x4,%esp
f011f981:	52                   	push   %edx
f011f982:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f985:	50                   	push   %eax
f011f986:	ff 75 f4             	pushl  -0xc(%ebp)
f011f989:	ff 75 f0             	pushl  -0x10(%ebp)
f011f98c:	ff 75 0c             	pushl  0xc(%ebp)
f011f98f:	ff 75 08             	pushl  0x8(%ebp)
f011f992:	e8 00 fb ff ff       	call   f011f497 <printnum>
f011f997:	83 c4 20             	add    $0x20,%esp
			break;
f011f99a:	eb 46                	jmp    f011f9e2 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011f99c:	83 ec 08             	sub    $0x8,%esp
f011f99f:	ff 75 0c             	pushl  0xc(%ebp)
f011f9a2:	53                   	push   %ebx
f011f9a3:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9a6:	ff d0                	call   *%eax
f011f9a8:	83 c4 10             	add    $0x10,%esp
			break;
f011f9ab:	eb 35                	jmp    f011f9e2 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011f9ad:	c6 05 c0 15 6c f0 00 	movb   $0x0,0xf06c15c0
			break;
f011f9b4:	eb 2c                	jmp    f011f9e2 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011f9b6:	c6 05 c0 15 6c f0 01 	movb   $0x1,0xf06c15c0
			break;
f011f9bd:	eb 23                	jmp    f011f9e2 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011f9bf:	83 ec 08             	sub    $0x8,%esp
f011f9c2:	ff 75 0c             	pushl  0xc(%ebp)
f011f9c5:	6a 25                	push   $0x25
f011f9c7:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9ca:	ff d0                	call   *%eax
f011f9cc:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011f9cf:	ff 4d 10             	decl   0x10(%ebp)
f011f9d2:	eb 03                	jmp    f011f9d7 <vprintfmt+0x3c3>
f011f9d4:	ff 4d 10             	decl   0x10(%ebp)
f011f9d7:	8b 45 10             	mov    0x10(%ebp),%eax
f011f9da:	48                   	dec    %eax
f011f9db:	8a 00                	mov    (%eax),%al
f011f9dd:	3c 25                	cmp    $0x25,%al
f011f9df:	75 f3                	jne    f011f9d4 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011f9e1:	90                   	nop
		}
	}
f011f9e2:	e9 35 fc ff ff       	jmp    f011f61c <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011f9e7:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011f9e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f9eb:	5b                   	pop    %ebx
f011f9ec:	5e                   	pop    %esi
f011f9ed:	5d                   	pop    %ebp
f011f9ee:	c3                   	ret    

f011f9ef <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011f9ef:	55                   	push   %ebp
f011f9f0:	89 e5                	mov    %esp,%ebp
f011f9f2:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011f9f5:	8d 45 10             	lea    0x10(%ebp),%eax
f011f9f8:	83 c0 04             	add    $0x4,%eax
f011f9fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011f9fe:	8b 45 10             	mov    0x10(%ebp),%eax
f011fa01:	ff 75 f4             	pushl  -0xc(%ebp)
f011fa04:	50                   	push   %eax
f011fa05:	ff 75 0c             	pushl  0xc(%ebp)
f011fa08:	ff 75 08             	pushl  0x8(%ebp)
f011fa0b:	e8 04 fc ff ff       	call   f011f614 <vprintfmt>
f011fa10:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011fa13:	90                   	nop
f011fa14:	c9                   	leave  
f011fa15:	c3                   	ret    

f011fa16 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011fa16:	55                   	push   %ebp
f011fa17:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011fa19:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa1c:	8b 40 08             	mov    0x8(%eax),%eax
f011fa1f:	8d 50 01             	lea    0x1(%eax),%edx
f011fa22:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa25:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011fa28:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa2b:	8b 10                	mov    (%eax),%edx
f011fa2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa30:	8b 40 04             	mov    0x4(%eax),%eax
f011fa33:	39 c2                	cmp    %eax,%edx
f011fa35:	73 12                	jae    f011fa49 <sprintputch+0x33>
		*b->buf++ = ch;
f011fa37:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa3a:	8b 00                	mov    (%eax),%eax
f011fa3c:	8d 48 01             	lea    0x1(%eax),%ecx
f011fa3f:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fa42:	89 0a                	mov    %ecx,(%edx)
f011fa44:	8b 55 08             	mov    0x8(%ebp),%edx
f011fa47:	88 10                	mov    %dl,(%eax)
}
f011fa49:	90                   	nop
f011fa4a:	5d                   	pop    %ebp
f011fa4b:	c3                   	ret    

f011fa4c <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011fa4c:	55                   	push   %ebp
f011fa4d:	89 e5                	mov    %esp,%ebp
f011fa4f:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011fa52:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa55:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fa58:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa5b:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fa5e:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa61:	01 d0                	add    %edx,%eax
f011fa63:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fa66:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011fa6d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fa71:	74 06                	je     f011fa79 <vsnprintf+0x2d>
f011fa73:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fa77:	7f 07                	jg     f011fa80 <vsnprintf+0x34>
		return -E_INVAL;
f011fa79:	b8 03 00 00 00       	mov    $0x3,%eax
f011fa7e:	eb 20                	jmp    f011faa0 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011fa80:	ff 75 14             	pushl  0x14(%ebp)
f011fa83:	ff 75 10             	pushl  0x10(%ebp)
f011fa86:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011fa89:	50                   	push   %eax
f011fa8a:	68 16 fa 11 f0       	push   $0xf011fa16
f011fa8f:	e8 80 fb ff ff       	call   f011f614 <vprintfmt>
f011fa94:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011fa97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fa9a:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011fa9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011faa0:	c9                   	leave  
f011faa1:	c3                   	ret    

f011faa2 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011faa2:	55                   	push   %ebp
f011faa3:	89 e5                	mov    %esp,%ebp
f011faa5:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011faa8:	8d 45 10             	lea    0x10(%ebp),%eax
f011faab:	83 c0 04             	add    $0x4,%eax
f011faae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011fab1:	8b 45 10             	mov    0x10(%ebp),%eax
f011fab4:	ff 75 f4             	pushl  -0xc(%ebp)
f011fab7:	50                   	push   %eax
f011fab8:	ff 75 0c             	pushl  0xc(%ebp)
f011fabb:	ff 75 08             	pushl  0x8(%ebp)
f011fabe:	e8 89 ff ff ff       	call   f011fa4c <vsnprintf>
f011fac3:	83 c4 10             	add    $0x10,%esp
f011fac6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011fac9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011facc:	c9                   	leave  
f011facd:	c3                   	ret    

f011face <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011face:	55                   	push   %ebp
f011facf:	89 e5                	mov    %esp,%ebp
f011fad1:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011fad4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fad8:	74 13                	je     f011faed <readline+0x1f>
		cprintf("%s", prompt);
f011fada:	83 ec 08             	sub    $0x8,%esp
f011fadd:	ff 75 08             	pushl  0x8(%ebp)
f011fae0:	68 28 14 13 f0       	push   $0xf0131428
f011fae5:	e8 a1 14 fe ff       	call   f0100f8b <cprintf>
f011faea:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011faed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011faf4:	83 ec 0c             	sub    $0xc,%esp
f011faf7:	6a 00                	push   $0x0
f011faf9:	e8 9a 13 fe ff       	call   f0100e98 <iscons>
f011fafe:	83 c4 10             	add    $0x10,%esp
f011fb01:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011fb04:	e8 76 13 fe ff       	call   f0100e7f <getchar>
f011fb09:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011fb0c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fb10:	79 22                	jns    f011fb34 <readline+0x66>
			if (c != -E_EOF)
f011fb12:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fb16:	0f 84 ad 00 00 00    	je     f011fbc9 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011fb1c:	83 ec 08             	sub    $0x8,%esp
f011fb1f:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb22:	68 2b 14 13 f0       	push   $0xf013142b
f011fb27:	e8 5f 14 fe ff       	call   f0100f8b <cprintf>
f011fb2c:	83 c4 10             	add    $0x10,%esp
			break;
f011fb2f:	e9 95 00 00 00       	jmp    f011fbc9 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011fb34:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fb38:	7e 34                	jle    f011fb6e <readline+0xa0>
f011fb3a:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fb41:	7f 2b                	jg     f011fb6e <readline+0xa0>
			if (echoing)
f011fb43:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb47:	74 0e                	je     f011fb57 <readline+0x89>
				cputchar(c);
f011fb49:	83 ec 0c             	sub    $0xc,%esp
f011fb4c:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb4f:	e8 14 13 fe ff       	call   f0100e68 <cputchar>
f011fb54:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011fb57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb5a:	8d 50 01             	lea    0x1(%eax),%edx
f011fb5d:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fb60:	89 c2                	mov    %eax,%edx
f011fb62:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb65:	01 d0                	add    %edx,%eax
f011fb67:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fb6a:	88 10                	mov    %dl,(%eax)
f011fb6c:	eb 56                	jmp    f011fbc4 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011fb6e:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fb72:	75 1f                	jne    f011fb93 <readline+0xc5>
f011fb74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fb78:	7e 19                	jle    f011fb93 <readline+0xc5>
			if (echoing)
f011fb7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fb7e:	74 0e                	je     f011fb8e <readline+0xc0>
				cputchar(c);
f011fb80:	83 ec 0c             	sub    $0xc,%esp
f011fb83:	ff 75 ec             	pushl  -0x14(%ebp)
f011fb86:	e8 dd 12 fe ff       	call   f0100e68 <cputchar>
f011fb8b:	83 c4 10             	add    $0x10,%esp

			i--;
f011fb8e:	ff 4d f4             	decl   -0xc(%ebp)
f011fb91:	eb 31                	jmp    f011fbc4 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011fb93:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fb97:	74 0a                	je     f011fba3 <readline+0xd5>
f011fb99:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fb9d:	0f 85 61 ff ff ff    	jne    f011fb04 <readline+0x36>
			if (echoing)
f011fba3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fba7:	74 0e                	je     f011fbb7 <readline+0xe9>
				cputchar(c);
f011fba9:	83 ec 0c             	sub    $0xc,%esp
f011fbac:	ff 75 ec             	pushl  -0x14(%ebp)
f011fbaf:	e8 b4 12 fe ff       	call   f0100e68 <cputchar>
f011fbb4:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011fbb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbba:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fbbd:	01 d0                	add    %edx,%eax
f011fbbf:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011fbc2:	eb 06                	jmp    f011fbca <readline+0xfc>
		}
	}
f011fbc4:	e9 3b ff ff ff       	jmp    f011fb04 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011fbc9:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011fbca:	90                   	nop
f011fbcb:	c9                   	leave  
f011fbcc:	c3                   	ret    

f011fbcd <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011fbcd:	55                   	push   %ebp
f011fbce:	89 e5                	mov    %esp,%ebp
f011fbd0:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011fbd3:	e8 53 ec fe ff       	call   f010e82b <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011fbd8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fbdc:	74 13                	je     f011fbf1 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011fbde:	83 ec 08             	sub    $0x8,%esp
f011fbe1:	ff 75 08             	pushl  0x8(%ebp)
f011fbe4:	68 28 14 13 f0       	push   $0xf0131428
f011fbe9:	e8 9d 13 fe ff       	call   f0100f8b <cprintf>
f011fbee:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011fbf1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011fbf8:	83 ec 0c             	sub    $0xc,%esp
f011fbfb:	6a 00                	push   $0x0
f011fbfd:	e8 96 12 fe ff       	call   f0100e98 <iscons>
f011fc02:	83 c4 10             	add    $0x10,%esp
f011fc05:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011fc08:	e8 72 12 fe ff       	call   f0100e7f <getchar>
f011fc0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011fc10:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fc14:	79 22                	jns    f011fc38 <atomic_readline+0x6b>
				if (c != -E_EOF)
f011fc16:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011fc1a:	0f 84 ad 00 00 00    	je     f011fccd <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011fc20:	83 ec 08             	sub    $0x8,%esp
f011fc23:	ff 75 ec             	pushl  -0x14(%ebp)
f011fc26:	68 2b 14 13 f0       	push   $0xf013142b
f011fc2b:	e8 5b 13 fe ff       	call   f0100f8b <cprintf>
f011fc30:	83 c4 10             	add    $0x10,%esp
				break;
f011fc33:	e9 95 00 00 00       	jmp    f011fccd <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011fc38:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011fc3c:	7e 34                	jle    f011fc72 <atomic_readline+0xa5>
f011fc3e:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011fc45:	7f 2b                	jg     f011fc72 <atomic_readline+0xa5>
				if (echoing)
f011fc47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fc4b:	74 0e                	je     f011fc5b <atomic_readline+0x8e>
					cputchar(c);
f011fc4d:	83 ec 0c             	sub    $0xc,%esp
f011fc50:	ff 75 ec             	pushl  -0x14(%ebp)
f011fc53:	e8 10 12 fe ff       	call   f0100e68 <cputchar>
f011fc58:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011fc5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc5e:	8d 50 01             	lea    0x1(%eax),%edx
f011fc61:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011fc64:	89 c2                	mov    %eax,%edx
f011fc66:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc69:	01 d0                	add    %edx,%eax
f011fc6b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fc6e:	88 10                	mov    %dl,(%eax)
f011fc70:	eb 56                	jmp    f011fcc8 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011fc72:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011fc76:	75 1f                	jne    f011fc97 <atomic_readline+0xca>
f011fc78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fc7c:	7e 19                	jle    f011fc97 <atomic_readline+0xca>
				if (echoing)
f011fc7e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fc82:	74 0e                	je     f011fc92 <atomic_readline+0xc5>
					cputchar(c);
f011fc84:	83 ec 0c             	sub    $0xc,%esp
f011fc87:	ff 75 ec             	pushl  -0x14(%ebp)
f011fc8a:	e8 d9 11 fe ff       	call   f0100e68 <cputchar>
f011fc8f:	83 c4 10             	add    $0x10,%esp
				i--;
f011fc92:	ff 4d f4             	decl   -0xc(%ebp)
f011fc95:	eb 31                	jmp    f011fcc8 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011fc97:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011fc9b:	74 0a                	je     f011fca7 <atomic_readline+0xda>
f011fc9d:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011fca1:	0f 85 61 ff ff ff    	jne    f011fc08 <atomic_readline+0x3b>
				if (echoing)
f011fca7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011fcab:	74 0e                	je     f011fcbb <atomic_readline+0xee>
					cputchar(c);
f011fcad:	83 ec 0c             	sub    $0xc,%esp
f011fcb0:	ff 75 ec             	pushl  -0x14(%ebp)
f011fcb3:	e8 b0 11 fe ff       	call   f0100e68 <cputchar>
f011fcb8:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011fcbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fcbe:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcc1:	01 d0                	add    %edx,%eax
f011fcc3:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011fcc6:	eb 06                	jmp    f011fcce <atomic_readline+0x101>
			}
		}
f011fcc8:	e9 3b ff ff ff       	jmp    f011fc08 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011fccd:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011fcce:	e8 66 eb fe ff       	call   f010e839 <sys_unlock_cons>
}
f011fcd3:	90                   	nop
f011fcd4:	c9                   	leave  
f011fcd5:	c3                   	ret    

f011fcd6 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011fcd6:	55                   	push   %ebp
f011fcd7:	89 e5                	mov    %esp,%ebp
f011fcd9:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011fcdc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fce3:	eb 06                	jmp    f011fceb <strlen+0x15>
		n++;
f011fce5:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011fce8:	ff 45 08             	incl   0x8(%ebp)
f011fceb:	8b 45 08             	mov    0x8(%ebp),%eax
f011fcee:	8a 00                	mov    (%eax),%al
f011fcf0:	84 c0                	test   %al,%al
f011fcf2:	75 f1                	jne    f011fce5 <strlen+0xf>
		n++;
	return n;
f011fcf4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fcf7:	c9                   	leave  
f011fcf8:	c3                   	ret    

f011fcf9 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011fcf9:	55                   	push   %ebp
f011fcfa:	89 e5                	mov    %esp,%ebp
f011fcfc:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fcff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fd06:	eb 09                	jmp    f011fd11 <strnlen+0x18>
		n++;
f011fd08:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011fd0b:	ff 45 08             	incl   0x8(%ebp)
f011fd0e:	ff 4d 0c             	decl   0xc(%ebp)
f011fd11:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fd15:	74 09                	je     f011fd20 <strnlen+0x27>
f011fd17:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd1a:	8a 00                	mov    (%eax),%al
f011fd1c:	84 c0                	test   %al,%al
f011fd1e:	75 e8                	jne    f011fd08 <strnlen+0xf>
		n++;
	return n;
f011fd20:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fd23:	c9                   	leave  
f011fd24:	c3                   	ret    

f011fd25 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011fd25:	55                   	push   %ebp
f011fd26:	89 e5                	mov    %esp,%ebp
f011fd28:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011fd2b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd2e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011fd31:	90                   	nop
f011fd32:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd35:	8d 50 01             	lea    0x1(%eax),%edx
f011fd38:	89 55 08             	mov    %edx,0x8(%ebp)
f011fd3b:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fd3e:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fd41:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fd44:	8a 12                	mov    (%edx),%dl
f011fd46:	88 10                	mov    %dl,(%eax)
f011fd48:	8a 00                	mov    (%eax),%al
f011fd4a:	84 c0                	test   %al,%al
f011fd4c:	75 e4                	jne    f011fd32 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011fd4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011fd51:	c9                   	leave  
f011fd52:	c3                   	ret    

f011fd53 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011fd53:	55                   	push   %ebp
f011fd54:	89 e5                	mov    %esp,%ebp
f011fd56:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011fd59:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd5c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011fd5f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fd66:	eb 1f                	jmp    f011fd87 <strncpy+0x34>
		*dst++ = *src;
f011fd68:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd6b:	8d 50 01             	lea    0x1(%eax),%edx
f011fd6e:	89 55 08             	mov    %edx,0x8(%ebp)
f011fd71:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fd74:	8a 12                	mov    (%edx),%dl
f011fd76:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011fd78:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fd7b:	8a 00                	mov    (%eax),%al
f011fd7d:	84 c0                	test   %al,%al
f011fd7f:	74 03                	je     f011fd84 <strncpy+0x31>
			src++;
f011fd81:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011fd84:	ff 45 fc             	incl   -0x4(%ebp)
f011fd87:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fd8a:	3b 45 10             	cmp    0x10(%ebp),%eax
f011fd8d:	72 d9                	jb     f011fd68 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011fd8f:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011fd92:	c9                   	leave  
f011fd93:	c3                   	ret    

f011fd94 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011fd94:	55                   	push   %ebp
f011fd95:	89 e5                	mov    %esp,%ebp
f011fd97:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011fd9a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd9d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011fda0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fda4:	74 30                	je     f011fdd6 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011fda6:	eb 16                	jmp    f011fdbe <strlcpy+0x2a>
			*dst++ = *src++;
f011fda8:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdab:	8d 50 01             	lea    0x1(%eax),%edx
f011fdae:	89 55 08             	mov    %edx,0x8(%ebp)
f011fdb1:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fdb4:	8d 4a 01             	lea    0x1(%edx),%ecx
f011fdb7:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011fdba:	8a 12                	mov    (%edx),%dl
f011fdbc:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011fdbe:	ff 4d 10             	decl   0x10(%ebp)
f011fdc1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fdc5:	74 09                	je     f011fdd0 <strlcpy+0x3c>
f011fdc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdca:	8a 00                	mov    (%eax),%al
f011fdcc:	84 c0                	test   %al,%al
f011fdce:	75 d8                	jne    f011fda8 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011fdd0:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdd3:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011fdd6:	8b 55 08             	mov    0x8(%ebp),%edx
f011fdd9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fddc:	29 c2                	sub    %eax,%edx
f011fdde:	89 d0                	mov    %edx,%eax
}
f011fde0:	c9                   	leave  
f011fde1:	c3                   	ret    

f011fde2 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011fde2:	55                   	push   %ebp
f011fde3:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011fde5:	eb 06                	jmp    f011fded <strcmp+0xb>
		p++, q++;
f011fde7:	ff 45 08             	incl   0x8(%ebp)
f011fdea:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011fded:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdf0:	8a 00                	mov    (%eax),%al
f011fdf2:	84 c0                	test   %al,%al
f011fdf4:	74 0e                	je     f011fe04 <strcmp+0x22>
f011fdf6:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdf9:	8a 10                	mov    (%eax),%dl
f011fdfb:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fdfe:	8a 00                	mov    (%eax),%al
f011fe00:	38 c2                	cmp    %al,%dl
f011fe02:	74 e3                	je     f011fde7 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011fe04:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe07:	8a 00                	mov    (%eax),%al
f011fe09:	0f b6 d0             	movzbl %al,%edx
f011fe0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe0f:	8a 00                	mov    (%eax),%al
f011fe11:	0f b6 c0             	movzbl %al,%eax
f011fe14:	29 c2                	sub    %eax,%edx
f011fe16:	89 d0                	mov    %edx,%eax
}
f011fe18:	5d                   	pop    %ebp
f011fe19:	c3                   	ret    

f011fe1a <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011fe1a:	55                   	push   %ebp
f011fe1b:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011fe1d:	eb 09                	jmp    f011fe28 <strncmp+0xe>
		n--, p++, q++;
f011fe1f:	ff 4d 10             	decl   0x10(%ebp)
f011fe22:	ff 45 08             	incl   0x8(%ebp)
f011fe25:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011fe28:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fe2c:	74 17                	je     f011fe45 <strncmp+0x2b>
f011fe2e:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe31:	8a 00                	mov    (%eax),%al
f011fe33:	84 c0                	test   %al,%al
f011fe35:	74 0e                	je     f011fe45 <strncmp+0x2b>
f011fe37:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe3a:	8a 10                	mov    (%eax),%dl
f011fe3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe3f:	8a 00                	mov    (%eax),%al
f011fe41:	38 c2                	cmp    %al,%dl
f011fe43:	74 da                	je     f011fe1f <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011fe45:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fe49:	75 07                	jne    f011fe52 <strncmp+0x38>
		return 0;
f011fe4b:	b8 00 00 00 00       	mov    $0x0,%eax
f011fe50:	eb 14                	jmp    f011fe66 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011fe52:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe55:	8a 00                	mov    (%eax),%al
f011fe57:	0f b6 d0             	movzbl %al,%edx
f011fe5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe5d:	8a 00                	mov    (%eax),%al
f011fe5f:	0f b6 c0             	movzbl %al,%eax
f011fe62:	29 c2                	sub    %eax,%edx
f011fe64:	89 d0                	mov    %edx,%eax
}
f011fe66:	5d                   	pop    %ebp
f011fe67:	c3                   	ret    

f011fe68 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011fe68:	55                   	push   %ebp
f011fe69:	89 e5                	mov    %esp,%ebp
f011fe6b:	83 ec 04             	sub    $0x4,%esp
f011fe6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fe71:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fe74:	eb 12                	jmp    f011fe88 <strchr+0x20>
		if (*s == c)
f011fe76:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe79:	8a 00                	mov    (%eax),%al
f011fe7b:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011fe7e:	75 05                	jne    f011fe85 <strchr+0x1d>
			return (char *) s;
f011fe80:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe83:	eb 11                	jmp    f011fe96 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011fe85:	ff 45 08             	incl   0x8(%ebp)
f011fe88:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe8b:	8a 00                	mov    (%eax),%al
f011fe8d:	84 c0                	test   %al,%al
f011fe8f:	75 e5                	jne    f011fe76 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011fe91:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fe96:	c9                   	leave  
f011fe97:	c3                   	ret    

f011fe98 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011fe98:	55                   	push   %ebp
f011fe99:	89 e5                	mov    %esp,%ebp
f011fe9b:	83 ec 04             	sub    $0x4,%esp
f011fe9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fea1:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011fea4:	eb 0d                	jmp    f011feb3 <strfind+0x1b>
		if (*s == c)
f011fea6:	8b 45 08             	mov    0x8(%ebp),%eax
f011fea9:	8a 00                	mov    (%eax),%al
f011feab:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011feae:	74 0e                	je     f011febe <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011feb0:	ff 45 08             	incl   0x8(%ebp)
f011feb3:	8b 45 08             	mov    0x8(%ebp),%eax
f011feb6:	8a 00                	mov    (%eax),%al
f011feb8:	84 c0                	test   %al,%al
f011feba:	75 ea                	jne    f011fea6 <strfind+0xe>
f011febc:	eb 01                	jmp    f011febf <strfind+0x27>
		if (*s == c)
			break;
f011febe:	90                   	nop
	return (char *) s;
f011febf:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fec2:	c9                   	leave  
f011fec3:	c3                   	ret    

f011fec4 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011fec4:	55                   	push   %ebp
f011fec5:	89 e5                	mov    %esp,%ebp
f011fec7:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011feca:	8b 45 08             	mov    0x8(%ebp),%eax
f011fecd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011fed0:	8b 45 10             	mov    0x10(%ebp),%eax
f011fed3:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011fed6:	eb 0e                	jmp    f011fee6 <memset+0x22>
		*p++ = c;
f011fed8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fedb:	8d 50 01             	lea    0x1(%eax),%edx
f011fede:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011fee1:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fee4:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011fee6:	ff 4d f8             	decl   -0x8(%ebp)
f011fee9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011feed:	79 e9                	jns    f011fed8 <memset+0x14>
		*p++ = c;

	return v;
f011feef:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011fef2:	c9                   	leave  
f011fef3:	c3                   	ret    

f011fef4 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011fef4:	55                   	push   %ebp
f011fef5:	89 e5                	mov    %esp,%ebp
f011fef7:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011fefa:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fefd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ff00:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff03:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011ff06:	eb 16                	jmp    f011ff1e <memcpy+0x2a>
		*d++ = *s++;
f011ff08:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff0b:	8d 50 01             	lea    0x1(%eax),%edx
f011ff0e:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ff11:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ff14:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ff17:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ff1a:	8a 12                	mov    (%edx),%dl
f011ff1c:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011ff1e:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff21:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ff24:	89 55 10             	mov    %edx,0x10(%ebp)
f011ff27:	85 c0                	test   %eax,%eax
f011ff29:	75 dd                	jne    f011ff08 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011ff2b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ff2e:	c9                   	leave  
f011ff2f:	c3                   	ret    

f011ff30 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011ff30:	55                   	push   %ebp
f011ff31:	89 e5                	mov    %esp,%ebp
f011ff33:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ff36:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ff39:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ff3c:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff3f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011ff42:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff45:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ff48:	73 50                	jae    f011ff9a <memmove+0x6a>
f011ff4a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ff4d:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff50:	01 d0                	add    %edx,%eax
f011ff52:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ff55:	76 43                	jbe    f011ff9a <memmove+0x6a>
		s += n;
f011ff57:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff5a:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011ff5d:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff60:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011ff63:	eb 10                	jmp    f011ff75 <memmove+0x45>
			*--d = *--s;
f011ff65:	ff 4d f8             	decl   -0x8(%ebp)
f011ff68:	ff 4d fc             	decl   -0x4(%ebp)
f011ff6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ff6e:	8a 10                	mov    (%eax),%dl
f011ff70:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff73:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011ff75:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff78:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ff7b:	89 55 10             	mov    %edx,0x10(%ebp)
f011ff7e:	85 c0                	test   %eax,%eax
f011ff80:	75 e3                	jne    f011ff65 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011ff82:	eb 23                	jmp    f011ffa7 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011ff84:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ff87:	8d 50 01             	lea    0x1(%eax),%edx
f011ff8a:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ff8d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ff90:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ff93:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ff96:	8a 12                	mov    (%edx),%dl
f011ff98:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011ff9a:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff9d:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ffa0:	89 55 10             	mov    %edx,0x10(%ebp)
f011ffa3:	85 c0                	test   %eax,%eax
f011ffa5:	75 dd                	jne    f011ff84 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011ffa7:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ffaa:	c9                   	leave  
f011ffab:	c3                   	ret    

f011ffac <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011ffac:	55                   	push   %ebp
f011ffad:	89 e5                	mov    %esp,%ebp
f011ffaf:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011ffb2:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffb5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011ffb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ffbb:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011ffbe:	eb 2a                	jmp    f011ffea <memcmp+0x3e>
		if (*s1 != *s2)
f011ffc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ffc3:	8a 10                	mov    (%eax),%dl
f011ffc5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ffc8:	8a 00                	mov    (%eax),%al
f011ffca:	38 c2                	cmp    %al,%dl
f011ffcc:	74 16                	je     f011ffe4 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011ffce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ffd1:	8a 00                	mov    (%eax),%al
f011ffd3:	0f b6 d0             	movzbl %al,%edx
f011ffd6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ffd9:	8a 00                	mov    (%eax),%al
f011ffdb:	0f b6 c0             	movzbl %al,%eax
f011ffde:	29 c2                	sub    %eax,%edx
f011ffe0:	89 d0                	mov    %edx,%eax
f011ffe2:	eb 18                	jmp    f011fffc <memcmp+0x50>
		s1++, s2++;
f011ffe4:	ff 45 fc             	incl   -0x4(%ebp)
f011ffe7:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011ffea:	8b 45 10             	mov    0x10(%ebp),%eax
f011ffed:	8d 50 ff             	lea    -0x1(%eax),%edx
f011fff0:	89 55 10             	mov    %edx,0x10(%ebp)
f011fff3:	85 c0                	test   %eax,%eax
f011fff5:	75 c9                	jne    f011ffc0 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011fff7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fffc:	c9                   	leave  
f011fffd:	c3                   	ret    

f011fffe <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011fffe:	55                   	push   %ebp
f011ffff:	89 e5                	mov    %esp,%ebp
f0120001:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f0120004:	8b 55 08             	mov    0x8(%ebp),%edx
f0120007:	8b 45 10             	mov    0x10(%ebp),%eax
f012000a:	01 d0                	add    %edx,%eax
f012000c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f012000f:	eb 15                	jmp    f0120026 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f0120011:	8b 45 08             	mov    0x8(%ebp),%eax
f0120014:	8a 00                	mov    (%eax),%al
f0120016:	0f b6 d0             	movzbl %al,%edx
f0120019:	8b 45 0c             	mov    0xc(%ebp),%eax
f012001c:	0f b6 c0             	movzbl %al,%eax
f012001f:	39 c2                	cmp    %eax,%edx
f0120021:	74 0d                	je     f0120030 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f0120023:	ff 45 08             	incl   0x8(%ebp)
f0120026:	8b 45 08             	mov    0x8(%ebp),%eax
f0120029:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f012002c:	72 e3                	jb     f0120011 <memfind+0x13>
f012002e:	eb 01                	jmp    f0120031 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f0120030:	90                   	nop
	return (void *) s;
f0120031:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120034:	c9                   	leave  
f0120035:	c3                   	ret    

f0120036 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f0120036:	55                   	push   %ebp
f0120037:	89 e5                	mov    %esp,%ebp
f0120039:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f012003c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f0120043:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f012004a:	eb 03                	jmp    f012004f <strtol+0x19>
		s++;
f012004c:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f012004f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120052:	8a 00                	mov    (%eax),%al
f0120054:	3c 20                	cmp    $0x20,%al
f0120056:	74 f4                	je     f012004c <strtol+0x16>
f0120058:	8b 45 08             	mov    0x8(%ebp),%eax
f012005b:	8a 00                	mov    (%eax),%al
f012005d:	3c 09                	cmp    $0x9,%al
f012005f:	74 eb                	je     f012004c <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f0120061:	8b 45 08             	mov    0x8(%ebp),%eax
f0120064:	8a 00                	mov    (%eax),%al
f0120066:	3c 2b                	cmp    $0x2b,%al
f0120068:	75 05                	jne    f012006f <strtol+0x39>
		s++;
f012006a:	ff 45 08             	incl   0x8(%ebp)
f012006d:	eb 13                	jmp    f0120082 <strtol+0x4c>
	else if (*s == '-')
f012006f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120072:	8a 00                	mov    (%eax),%al
f0120074:	3c 2d                	cmp    $0x2d,%al
f0120076:	75 0a                	jne    f0120082 <strtol+0x4c>
		s++, neg = 1;
f0120078:	ff 45 08             	incl   0x8(%ebp)
f012007b:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f0120082:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120086:	74 06                	je     f012008e <strtol+0x58>
f0120088:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f012008c:	75 20                	jne    f01200ae <strtol+0x78>
f012008e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120091:	8a 00                	mov    (%eax),%al
f0120093:	3c 30                	cmp    $0x30,%al
f0120095:	75 17                	jne    f01200ae <strtol+0x78>
f0120097:	8b 45 08             	mov    0x8(%ebp),%eax
f012009a:	40                   	inc    %eax
f012009b:	8a 00                	mov    (%eax),%al
f012009d:	3c 78                	cmp    $0x78,%al
f012009f:	75 0d                	jne    f01200ae <strtol+0x78>
		s += 2, base = 16;
f01200a1:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f01200a5:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f01200ac:	eb 28                	jmp    f01200d6 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f01200ae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01200b2:	75 15                	jne    f01200c9 <strtol+0x93>
f01200b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01200b7:	8a 00                	mov    (%eax),%al
f01200b9:	3c 30                	cmp    $0x30,%al
f01200bb:	75 0c                	jne    f01200c9 <strtol+0x93>
		s++, base = 8;
f01200bd:	ff 45 08             	incl   0x8(%ebp)
f01200c0:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f01200c7:	eb 0d                	jmp    f01200d6 <strtol+0xa0>
	else if (base == 0)
f01200c9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01200cd:	75 07                	jne    f01200d6 <strtol+0xa0>
		base = 10;
f01200cf:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f01200d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01200d9:	8a 00                	mov    (%eax),%al
f01200db:	3c 2f                	cmp    $0x2f,%al
f01200dd:	7e 19                	jle    f01200f8 <strtol+0xc2>
f01200df:	8b 45 08             	mov    0x8(%ebp),%eax
f01200e2:	8a 00                	mov    (%eax),%al
f01200e4:	3c 39                	cmp    $0x39,%al
f01200e6:	7f 10                	jg     f01200f8 <strtol+0xc2>
			dig = *s - '0';
f01200e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01200eb:	8a 00                	mov    (%eax),%al
f01200ed:	0f be c0             	movsbl %al,%eax
f01200f0:	83 e8 30             	sub    $0x30,%eax
f01200f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01200f6:	eb 42                	jmp    f012013a <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f01200f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01200fb:	8a 00                	mov    (%eax),%al
f01200fd:	3c 60                	cmp    $0x60,%al
f01200ff:	7e 19                	jle    f012011a <strtol+0xe4>
f0120101:	8b 45 08             	mov    0x8(%ebp),%eax
f0120104:	8a 00                	mov    (%eax),%al
f0120106:	3c 7a                	cmp    $0x7a,%al
f0120108:	7f 10                	jg     f012011a <strtol+0xe4>
			dig = *s - 'a' + 10;
f012010a:	8b 45 08             	mov    0x8(%ebp),%eax
f012010d:	8a 00                	mov    (%eax),%al
f012010f:	0f be c0             	movsbl %al,%eax
f0120112:	83 e8 57             	sub    $0x57,%eax
f0120115:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120118:	eb 20                	jmp    f012013a <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f012011a:	8b 45 08             	mov    0x8(%ebp),%eax
f012011d:	8a 00                	mov    (%eax),%al
f012011f:	3c 40                	cmp    $0x40,%al
f0120121:	7e 39                	jle    f012015c <strtol+0x126>
f0120123:	8b 45 08             	mov    0x8(%ebp),%eax
f0120126:	8a 00                	mov    (%eax),%al
f0120128:	3c 5a                	cmp    $0x5a,%al
f012012a:	7f 30                	jg     f012015c <strtol+0x126>
			dig = *s - 'A' + 10;
f012012c:	8b 45 08             	mov    0x8(%ebp),%eax
f012012f:	8a 00                	mov    (%eax),%al
f0120131:	0f be c0             	movsbl %al,%eax
f0120134:	83 e8 37             	sub    $0x37,%eax
f0120137:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f012013a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012013d:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120140:	7d 19                	jge    f012015b <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f0120142:	ff 45 08             	incl   0x8(%ebp)
f0120145:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120148:	0f af 45 10          	imul   0x10(%ebp),%eax
f012014c:	89 c2                	mov    %eax,%edx
f012014e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120151:	01 d0                	add    %edx,%eax
f0120153:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f0120156:	e9 7b ff ff ff       	jmp    f01200d6 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f012015b:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f012015c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120160:	74 08                	je     f012016a <strtol+0x134>
		*endptr = (char *) s;
f0120162:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120165:	8b 55 08             	mov    0x8(%ebp),%edx
f0120168:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f012016a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f012016e:	74 07                	je     f0120177 <strtol+0x141>
f0120170:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120173:	f7 d8                	neg    %eax
f0120175:	eb 03                	jmp    f012017a <strtol+0x144>
f0120177:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f012017a:	c9                   	leave  
f012017b:	c3                   	ret    

f012017c <ltostr>:

void
ltostr(long value, char *str)
{
f012017c:	55                   	push   %ebp
f012017d:	89 e5                	mov    %esp,%ebp
f012017f:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f0120182:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f0120189:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f0120190:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120194:	79 13                	jns    f01201a9 <ltostr+0x2d>
	{
		neg = 1;
f0120196:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f012019d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201a0:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f01201a3:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f01201a6:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f01201a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01201ac:	b9 0a 00 00 00       	mov    $0xa,%ecx
f01201b1:	99                   	cltd   
f01201b2:	f7 f9                	idiv   %ecx
f01201b4:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f01201b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01201ba:	8d 50 01             	lea    0x1(%eax),%edx
f01201bd:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01201c0:	89 c2                	mov    %eax,%edx
f01201c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201c5:	01 d0                	add    %edx,%eax
f01201c7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01201ca:	83 c2 30             	add    $0x30,%edx
f01201cd:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f01201cf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01201d2:	b8 67 66 66 66       	mov    $0x66666667,%eax
f01201d7:	f7 e9                	imul   %ecx
f01201d9:	c1 fa 02             	sar    $0x2,%edx
f01201dc:	89 c8                	mov    %ecx,%eax
f01201de:	c1 f8 1f             	sar    $0x1f,%eax
f01201e1:	29 c2                	sub    %eax,%edx
f01201e3:	89 d0                	mov    %edx,%eax
f01201e5:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f01201e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01201ec:	75 bb                	jne    f01201a9 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f01201ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f01201f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01201f8:	48                   	dec    %eax
f01201f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f01201fc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0120200:	74 3d                	je     f012023f <ltostr+0xc3>
		start = 1 ;
f0120202:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f0120209:	eb 34                	jmp    f012023f <ltostr+0xc3>
	{
		char tmp = str[start] ;
f012020b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012020e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120211:	01 d0                	add    %edx,%eax
f0120213:	8a 00                	mov    (%eax),%al
f0120215:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f0120218:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012021b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012021e:	01 c2                	add    %eax,%edx
f0120220:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0120223:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120226:	01 c8                	add    %ecx,%eax
f0120228:	8a 00                	mov    (%eax),%al
f012022a:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f012022c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012022f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120232:	01 c2                	add    %eax,%edx
f0120234:	8a 45 eb             	mov    -0x15(%ebp),%al
f0120237:	88 02                	mov    %al,(%edx)
		start++ ;
f0120239:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f012023c:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f012023f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120242:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120245:	7c c4                	jl     f012020b <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f0120247:	8b 55 f8             	mov    -0x8(%ebp),%edx
f012024a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012024d:	01 d0                	add    %edx,%eax
f012024f:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0120252:	90                   	nop
f0120253:	c9                   	leave  
f0120254:	c3                   	ret    

f0120255 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f0120255:	55                   	push   %ebp
f0120256:	89 e5                	mov    %esp,%ebp
f0120258:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f012025b:	ff 75 08             	pushl  0x8(%ebp)
f012025e:	e8 73 fa ff ff       	call   f011fcd6 <strlen>
f0120263:	83 c4 04             	add    $0x4,%esp
f0120266:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f0120269:	ff 75 0c             	pushl  0xc(%ebp)
f012026c:	e8 65 fa ff ff       	call   f011fcd6 <strlen>
f0120271:	83 c4 04             	add    $0x4,%esp
f0120274:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f0120277:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f012027e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120285:	eb 17                	jmp    f012029e <strcconcat+0x49>
		final[s] = str1[s] ;
f0120287:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012028a:	8b 45 10             	mov    0x10(%ebp),%eax
f012028d:	01 c2                	add    %eax,%edx
f012028f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0120292:	8b 45 08             	mov    0x8(%ebp),%eax
f0120295:	01 c8                	add    %ecx,%eax
f0120297:	8a 00                	mov    (%eax),%al
f0120299:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f012029b:	ff 45 fc             	incl   -0x4(%ebp)
f012029e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01202a1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01202a4:	7c e1                	jl     f0120287 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f01202a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f01202ad:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f01202b4:	eb 1f                	jmp    f01202d5 <strcconcat+0x80>
		final[s++] = str2[i] ;
f01202b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01202b9:	8d 50 01             	lea    0x1(%eax),%edx
f01202bc:	89 55 fc             	mov    %edx,-0x4(%ebp)
f01202bf:	89 c2                	mov    %eax,%edx
f01202c1:	8b 45 10             	mov    0x10(%ebp),%eax
f01202c4:	01 c2                	add    %eax,%edx
f01202c6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f01202c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202cc:	01 c8                	add    %ecx,%eax
f01202ce:	8a 00                	mov    (%eax),%al
f01202d0:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f01202d2:	ff 45 f8             	incl   -0x8(%ebp)
f01202d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01202d8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01202db:	7c d9                	jl     f01202b6 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f01202dd:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01202e0:	8b 45 10             	mov    0x10(%ebp),%eax
f01202e3:	01 d0                	add    %edx,%eax
f01202e5:	c6 00 00             	movb   $0x0,(%eax)
}
f01202e8:	90                   	nop
f01202e9:	c9                   	leave  
f01202ea:	c3                   	ret    

f01202eb <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f01202eb:	55                   	push   %ebp
f01202ec:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f01202ee:	8b 45 14             	mov    0x14(%ebp),%eax
f01202f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f01202f7:	8b 45 14             	mov    0x14(%ebp),%eax
f01202fa:	8b 00                	mov    (%eax),%eax
f01202fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120303:	8b 45 10             	mov    0x10(%ebp),%eax
f0120306:	01 d0                	add    %edx,%eax
f0120308:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f012030e:	eb 0c                	jmp    f012031c <strsplit+0x31>
			*string++ = 0;
f0120310:	8b 45 08             	mov    0x8(%ebp),%eax
f0120313:	8d 50 01             	lea    0x1(%eax),%edx
f0120316:	89 55 08             	mov    %edx,0x8(%ebp)
f0120319:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f012031c:	8b 45 08             	mov    0x8(%ebp),%eax
f012031f:	8a 00                	mov    (%eax),%al
f0120321:	84 c0                	test   %al,%al
f0120323:	74 18                	je     f012033d <strsplit+0x52>
f0120325:	8b 45 08             	mov    0x8(%ebp),%eax
f0120328:	8a 00                	mov    (%eax),%al
f012032a:	0f be c0             	movsbl %al,%eax
f012032d:	50                   	push   %eax
f012032e:	ff 75 0c             	pushl  0xc(%ebp)
f0120331:	e8 32 fb ff ff       	call   f011fe68 <strchr>
f0120336:	83 c4 08             	add    $0x8,%esp
f0120339:	85 c0                	test   %eax,%eax
f012033b:	75 d3                	jne    f0120310 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f012033d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120340:	8a 00                	mov    (%eax),%al
f0120342:	84 c0                	test   %al,%al
f0120344:	74 5a                	je     f01203a0 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f0120346:	8b 45 14             	mov    0x14(%ebp),%eax
f0120349:	8b 00                	mov    (%eax),%eax
f012034b:	83 f8 0f             	cmp    $0xf,%eax
f012034e:	75 07                	jne    f0120357 <strsplit+0x6c>
		{
			return 0;
f0120350:	b8 00 00 00 00       	mov    $0x0,%eax
f0120355:	eb 66                	jmp    f01203bd <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f0120357:	8b 45 14             	mov    0x14(%ebp),%eax
f012035a:	8b 00                	mov    (%eax),%eax
f012035c:	8d 48 01             	lea    0x1(%eax),%ecx
f012035f:	8b 55 14             	mov    0x14(%ebp),%edx
f0120362:	89 0a                	mov    %ecx,(%edx)
f0120364:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f012036b:	8b 45 10             	mov    0x10(%ebp),%eax
f012036e:	01 c2                	add    %eax,%edx
f0120370:	8b 45 08             	mov    0x8(%ebp),%eax
f0120373:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120375:	eb 03                	jmp    f012037a <strsplit+0x8f>
			string++;
f0120377:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f012037a:	8b 45 08             	mov    0x8(%ebp),%eax
f012037d:	8a 00                	mov    (%eax),%al
f012037f:	84 c0                	test   %al,%al
f0120381:	74 8b                	je     f012030e <strsplit+0x23>
f0120383:	8b 45 08             	mov    0x8(%ebp),%eax
f0120386:	8a 00                	mov    (%eax),%al
f0120388:	0f be c0             	movsbl %al,%eax
f012038b:	50                   	push   %eax
f012038c:	ff 75 0c             	pushl  0xc(%ebp)
f012038f:	e8 d4 fa ff ff       	call   f011fe68 <strchr>
f0120394:	83 c4 08             	add    $0x8,%esp
f0120397:	85 c0                	test   %eax,%eax
f0120399:	74 dc                	je     f0120377 <strsplit+0x8c>
			string++;
	}
f012039b:	e9 6e ff ff ff       	jmp    f012030e <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f01203a0:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f01203a1:	8b 45 14             	mov    0x14(%ebp),%eax
f01203a4:	8b 00                	mov    (%eax),%eax
f01203a6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01203ad:	8b 45 10             	mov    0x10(%ebp),%eax
f01203b0:	01 d0                	add    %edx,%eax
f01203b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f01203b8:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01203bd:	c9                   	leave  
f01203be:	c3                   	ret    

f01203bf <str2lower>:


char* str2lower(char *dst, const char *src)
{
f01203bf:	55                   	push   %ebp
f01203c0:	89 e5                	mov    %esp,%ebp
f01203c2:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f01203c5:	83 ec 04             	sub    $0x4,%esp
f01203c8:	68 3c 14 13 f0       	push   $0xf013143c
f01203cd:	68 3f 01 00 00       	push   $0x13f
f01203d2:	68 5e 14 13 f0       	push   $0xf013145e
f01203d7:	e8 5d ff fd ff       	call   f0100339 <_panic>

f01203dc <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f01203dc:	55                   	push   %ebp
f01203dd:	89 e5                	mov    %esp,%ebp
f01203df:	83 ec 18             	sub    $0x18,%esp
f01203e2:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01203e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01203ec:	89 c2                	mov    %eax,%edx
f01203ee:	ec                   	in     (%dx),%al
f01203ef:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f01203f2:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01203f5:	0f b6 c0             	movzbl %al,%eax
f01203f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01203fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203fe:	25 c0 00 00 00       	and    $0xc0,%eax
f0120403:	83 f8 40             	cmp    $0x40,%eax
f0120406:	75 10                	jne    f0120418 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f0120408:	83 ec 0c             	sub    $0xc,%esp
f012040b:	68 e0 14 6c f0       	push   $0xf06c14e0
f0120410:	e8 6d fd fe ff       	call   f0110182 <wakeup_one>
f0120415:	83 c4 10             	add    $0x10,%esp
	}

}
f0120418:	90                   	nop
f0120419:	c9                   	leave  
f012041a:	c3                   	ret    

f012041b <ide_init>:

void ide_init()
{
f012041b:	55                   	push   %ebp
f012041c:	89 e5                	mov    %esp,%ebp
f012041e:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0120421:	83 ec 08             	sub    $0x8,%esp
f0120424:	68 dc 03 12 f0       	push   $0xf01203dc
f0120429:	6a 0e                	push   $0xe
f012042b:	e8 02 df fe ff       	call   f010e332 <irq_install_handler>
f0120430:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0120433:	83 ec 08             	sub    $0x8,%esp
f0120436:	68 6c 14 13 f0       	push   $0xf013146c
f012043b:	68 e0 14 6c f0       	push   $0xf06c14e0
f0120440:	e8 a3 fc fe ff       	call   f01100e8 <init_channel>
f0120445:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f0120448:	83 ec 08             	sub    $0x8,%esp
f012044b:	68 79 14 13 f0       	push   $0xf0131479
f0120450:	68 00 1b 6c f0       	push   $0xf06c1b00
f0120455:	e8 9d f8 fe ff       	call   f010fcf7 <init_spinlock>
f012045a:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f012045d:	90                   	nop
f012045e:	c9                   	leave  
f012045f:	c3                   	ret    

f0120460 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f0120460:	55                   	push   %ebp
f0120461:	89 e5                	mov    %esp,%ebp
f0120463:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120466:	90                   	nop
f0120467:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f012046e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120471:	89 c2                	mov    %eax,%edx
f0120473:	ec                   	in     (%dx),%al
f0120474:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120477:	8a 45 ef             	mov    -0x11(%ebp),%al
f012047a:	0f b6 c0             	movzbl %al,%eax
f012047d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120483:	25 c0 00 00 00       	and    $0xc0,%eax
f0120488:	83 f8 40             	cmp    $0x40,%eax
f012048b:	75 da                	jne    f0120467 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f012048d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120491:	74 24                	je     f01204b7 <ide_wait_ready+0x57>
f0120493:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120496:	83 e0 21             	and    $0x21,%eax
f0120499:	85 c0                	test   %eax,%eax
f012049b:	74 1a                	je     f01204b7 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f012049d:	83 ec 0c             	sub    $0xc,%esp
f01204a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01204a3:	ff 75 f4             	pushl  -0xc(%ebp)
f01204a6:	68 8c 14 13 f0       	push   $0xf013148c
f01204ab:	6a 5d                	push   $0x5d
f01204ad:	68 af 14 13 f0       	push   $0xf01314af
f01204b2:	e8 82 fe fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f01204b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01204bc:	c9                   	leave  
f01204bd:	c3                   	ret    

f01204be <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f01204be:	55                   	push   %ebp
f01204bf:	89 e5                	mov    %esp,%ebp
f01204c1:	57                   	push   %edi
f01204c2:	53                   	push   %ebx
f01204c3:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f01204c6:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f01204cd:	76 16                	jbe    f01204e5 <ide_read+0x27>
f01204cf:	68 ba 14 13 f0       	push   $0xf01314ba
f01204d4:	68 c7 14 13 f0       	push   $0xf01314c7
f01204d9:	6a 68                	push   $0x68
f01204db:	68 af 14 13 f0       	push   $0xf01314af
f01204e0:	e8 54 fe fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f01204e5:	83 ec 0c             	sub    $0xc,%esp
f01204e8:	6a 00                	push   $0x0
f01204ea:	e8 71 ff ff ff       	call   f0120460 <ide_wait_ready>
f01204ef:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f01204f2:	8b 45 10             	mov    0x10(%ebp),%eax
f01204f5:	0f b6 c0             	movzbl %al,%eax
f01204f8:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f01204ff:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120502:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0120505:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120508:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120509:	8b 45 08             	mov    0x8(%ebp),%eax
f012050c:	0f b6 c0             	movzbl %al,%eax
f012050f:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120516:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0120519:	8a 45 d3             	mov    -0x2d(%ebp),%al
f012051c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012051f:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120520:	8b 45 08             	mov    0x8(%ebp),%eax
f0120523:	c1 e8 08             	shr    $0x8,%eax
f0120526:	0f b6 c0             	movzbl %al,%eax
f0120529:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120530:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120533:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120536:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120539:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f012053a:	8b 45 08             	mov    0x8(%ebp),%eax
f012053d:	c1 e8 10             	shr    $0x10,%eax
f0120540:	0f b6 c0             	movzbl %al,%eax
f0120543:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f012054a:	88 45 d5             	mov    %al,-0x2b(%ebp)
f012054d:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120550:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120553:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120554:	a1 90 13 6c f0       	mov    0xf06c1390,%eax
f0120559:	83 e0 01             	and    $0x1,%eax
f012055c:	c1 e0 04             	shl    $0x4,%eax
f012055f:	88 c2                	mov    %al,%dl
f0120561:	8b 45 08             	mov    0x8(%ebp),%eax
f0120564:	c1 e8 18             	shr    $0x18,%eax
f0120567:	83 e0 0f             	and    $0xf,%eax
f012056a:	09 d0                	or     %edx,%eax
f012056c:	83 c8 e0             	or     $0xffffffe0,%eax
f012056f:	0f b6 c0             	movzbl %al,%eax
f0120572:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120579:	88 45 d6             	mov    %al,-0x2a(%ebp)
f012057c:	8a 45 d6             	mov    -0x2a(%ebp),%al
f012057f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120582:	ee                   	out    %al,(%dx)
f0120583:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f012058a:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f012058e:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120591:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120594:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120595:	eb 55                	jmp    f01205ec <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0120597:	83 ec 0c             	sub    $0xc,%esp
f012059a:	6a 01                	push   $0x1
f012059c:	e8 bf fe ff ff       	call   f0120460 <ide_wait_ready>
f01205a1:	83 c4 10             	add    $0x10,%esp
f01205a4:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01205a7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01205ab:	79 05                	jns    f01205b2 <ide_read+0xf4>
			return r;
f01205ad:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01205b0:	eb 45                	jmp    f01205f7 <ide_read+0x139>
f01205b2:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01205b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01205bc:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01205bf:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f01205c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01205c9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f01205cc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01205cf:	89 cb                	mov    %ecx,%ebx
f01205d1:	89 df                	mov    %ebx,%edi
f01205d3:	89 c1                	mov    %eax,%ecx
f01205d5:	fc                   	cld    
f01205d6:	f2 6d                	repnz insl (%dx),%es:(%edi)
f01205d8:	89 c8                	mov    %ecx,%eax
f01205da:	89 fb                	mov    %edi,%ebx
f01205dc:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f01205df:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01205e2:	ff 4d 10             	decl   0x10(%ebp)
f01205e5:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f01205ec:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01205f0:	75 a5                	jne    f0120597 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f01205f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01205f7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01205fa:	5b                   	pop    %ebx
f01205fb:	5f                   	pop    %edi
f01205fc:	5d                   	pop    %ebp
f01205fd:	c3                   	ret    

f01205fe <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f01205fe:	55                   	push   %ebp
f01205ff:	89 e5                	mov    %esp,%ebp
f0120601:	56                   	push   %esi
f0120602:	53                   	push   %ebx
f0120603:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f0120606:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f012060d:	76 19                	jbe    f0120628 <ide_write+0x2a>
f012060f:	68 ba 14 13 f0       	push   $0xf01314ba
f0120614:	68 c7 14 13 f0       	push   $0xf01314c7
f0120619:	68 82 00 00 00       	push   $0x82
f012061e:	68 af 14 13 f0       	push   $0xf01314af
f0120623:	e8 11 fd fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f0120628:	83 ec 0c             	sub    $0xc,%esp
f012062b:	6a 00                	push   $0x0
f012062d:	e8 2e fe ff ff       	call   f0120460 <ide_wait_ready>
f0120632:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f0120635:	8b 45 10             	mov    0x10(%ebp),%eax
f0120638:	0f b6 c0             	movzbl %al,%eax
f012063b:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120642:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120645:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0120648:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012064b:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f012064c:	8b 45 08             	mov    0x8(%ebp),%eax
f012064f:	0f b6 c0             	movzbl %al,%eax
f0120652:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120659:	88 45 d3             	mov    %al,-0x2d(%ebp)
f012065c:	8a 45 d3             	mov    -0x2d(%ebp),%al
f012065f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120662:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120663:	8b 45 08             	mov    0x8(%ebp),%eax
f0120666:	c1 e8 08             	shr    $0x8,%eax
f0120669:	0f b6 c0             	movzbl %al,%eax
f012066c:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120673:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120676:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120679:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012067c:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f012067d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120680:	c1 e8 10             	shr    $0x10,%eax
f0120683:	0f b6 c0             	movzbl %al,%eax
f0120686:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f012068d:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120690:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120693:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120696:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120697:	a1 90 13 6c f0       	mov    0xf06c1390,%eax
f012069c:	83 e0 01             	and    $0x1,%eax
f012069f:	c1 e0 04             	shl    $0x4,%eax
f01206a2:	88 c2                	mov    %al,%dl
f01206a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01206a7:	c1 e8 18             	shr    $0x18,%eax
f01206aa:	83 e0 0f             	and    $0xf,%eax
f01206ad:	09 d0                	or     %edx,%eax
f01206af:	83 c8 e0             	or     $0xffffffe0,%eax
f01206b2:	0f b6 c0             	movzbl %al,%eax
f01206b5:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f01206bc:	88 45 d6             	mov    %al,-0x2a(%ebp)
f01206bf:	8a 45 d6             	mov    -0x2a(%ebp),%al
f01206c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01206c5:	ee                   	out    %al,(%dx)
f01206c6:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f01206cd:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f01206d1:	8a 45 d7             	mov    -0x29(%ebp),%al
f01206d4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01206d7:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f01206d8:	eb 55                	jmp    f012072f <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f01206da:	83 ec 0c             	sub    $0xc,%esp
f01206dd:	6a 01                	push   $0x1
f01206df:	e8 7c fd ff ff       	call   f0120460 <ide_wait_ready>
f01206e4:	83 c4 10             	add    $0x10,%esp
f01206e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01206ea:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01206ee:	79 05                	jns    f01206f5 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f01206f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01206f3:	eb 45                	jmp    f012073a <ide_write+0x13c>
f01206f5:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f01206fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206ff:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120702:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0120709:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012070c:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f012070f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120712:	89 cb                	mov    %ecx,%ebx
f0120714:	89 de                	mov    %ebx,%esi
f0120716:	89 c1                	mov    %eax,%ecx
f0120718:	fc                   	cld    
f0120719:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f012071b:	89 c8                	mov    %ecx,%eax
f012071d:	89 f3                	mov    %esi,%ebx
f012071f:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120722:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120725:	ff 4d 10             	decl   0x10(%ebp)
f0120728:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f012072f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120733:	75 a5                	jne    f01206da <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0120735:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012073a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f012073d:	5b                   	pop    %ebx
f012073e:	5e                   	pop    %esi
f012073f:	5d                   	pop    %ebp
f0120740:	c3                   	ret    

f0120741 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120741:	55                   	push   %ebp
f0120742:	89 e5                	mov    %esp,%ebp
f0120744:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120747:	8b 45 08             	mov    0x8(%ebp),%eax
f012074a:	83 e8 04             	sub    $0x4,%eax
f012074d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120753:	8b 00                	mov    (%eax),%eax
f0120755:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0120758:	c9                   	leave  
f0120759:	c3                   	ret    

f012075a <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f012075a:	55                   	push   %ebp
f012075b:	89 e5                	mov    %esp,%ebp
f012075d:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120760:	8b 45 08             	mov    0x8(%ebp),%eax
f0120763:	83 e8 04             	sub    $0x4,%eax
f0120766:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0120769:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012076c:	8b 00                	mov    (%eax),%eax
f012076e:	83 e0 01             	and    $0x1,%eax
f0120771:	85 c0                	test   %eax,%eax
f0120773:	0f 94 c0             	sete   %al
}
f0120776:	c9                   	leave  
f0120777:	c3                   	ret    

f0120778 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0120778:	55                   	push   %ebp
f0120779:	89 e5                	mov    %esp,%ebp
f012077b:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f012077e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0120785:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120788:	83 f8 02             	cmp    $0x2,%eax
f012078b:	74 2b                	je     f01207b8 <alloc_block+0x40>
f012078d:	83 f8 02             	cmp    $0x2,%eax
f0120790:	7f 07                	jg     f0120799 <alloc_block+0x21>
f0120792:	83 f8 01             	cmp    $0x1,%eax
f0120795:	74 0e                	je     f01207a5 <alloc_block+0x2d>
f0120797:	eb 58                	jmp    f01207f1 <alloc_block+0x79>
f0120799:	83 f8 03             	cmp    $0x3,%eax
f012079c:	74 2d                	je     f01207cb <alloc_block+0x53>
f012079e:	83 f8 04             	cmp    $0x4,%eax
f01207a1:	74 3b                	je     f01207de <alloc_block+0x66>
f01207a3:	eb 4c                	jmp    f01207f1 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f01207a5:	83 ec 0c             	sub    $0xc,%esp
f01207a8:	ff 75 08             	pushl  0x8(%ebp)
f01207ab:	e8 11 03 00 00       	call   f0120ac1 <alloc_block_FF>
f01207b0:	83 c4 10             	add    $0x10,%esp
f01207b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01207b6:	eb 4a                	jmp    f0120802 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f01207b8:	83 ec 0c             	sub    $0xc,%esp
f01207bb:	ff 75 08             	pushl  0x8(%ebp)
f01207be:	e8 fa 19 00 00       	call   f01221bd <alloc_block_NF>
f01207c3:	83 c4 10             	add    $0x10,%esp
f01207c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01207c9:	eb 37                	jmp    f0120802 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f01207cb:	83 ec 0c             	sub    $0xc,%esp
f01207ce:	ff 75 08             	pushl  0x8(%ebp)
f01207d1:	e8 a7 07 00 00       	call   f0120f7d <alloc_block_BF>
f01207d6:	83 c4 10             	add    $0x10,%esp
f01207d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01207dc:	eb 24                	jmp    f0120802 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f01207de:	83 ec 0c             	sub    $0xc,%esp
f01207e1:	ff 75 08             	pushl  0x8(%ebp)
f01207e4:	e8 b7 19 00 00       	call   f01221a0 <alloc_block_WF>
f01207e9:	83 c4 10             	add    $0x10,%esp
f01207ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01207ef:	eb 11                	jmp    f0120802 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f01207f1:	83 ec 0c             	sub    $0xc,%esp
f01207f4:	68 dc 14 13 f0       	push   $0xf01314dc
f01207f9:	e8 8d 07 fe ff       	call   f0100f8b <cprintf>
f01207fe:	83 c4 10             	add    $0x10,%esp
		break;
f0120801:	90                   	nop
	}
	return va;
f0120802:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0120805:	c9                   	leave  
f0120806:	c3                   	ret    

f0120807 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0120807:	55                   	push   %ebp
f0120808:	89 e5                	mov    %esp,%ebp
f012080a:	53                   	push   %ebx
f012080b:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f012080e:	83 ec 0c             	sub    $0xc,%esp
f0120811:	68 fc 14 13 f0       	push   $0xf01314fc
f0120816:	e8 70 07 fe ff       	call   f0100f8b <cprintf>
f012081b:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f012081e:	83 ec 0c             	sub    $0xc,%esp
f0120821:	68 27 15 13 f0       	push   $0xf0131527
f0120826:	e8 60 07 fe ff       	call   f0100f8b <cprintf>
f012082b:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f012082e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120831:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120834:	eb 37                	jmp    f012086d <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120836:	83 ec 0c             	sub    $0xc,%esp
f0120839:	ff 75 f4             	pushl  -0xc(%ebp)
f012083c:	e8 19 ff ff ff       	call   f012075a <is_free_block>
f0120841:	83 c4 10             	add    $0x10,%esp
f0120844:	0f be d8             	movsbl %al,%ebx
f0120847:	83 ec 0c             	sub    $0xc,%esp
f012084a:	ff 75 f4             	pushl  -0xc(%ebp)
f012084d:	e8 ef fe ff ff       	call   f0120741 <get_block_size>
f0120852:	83 c4 10             	add    $0x10,%esp
f0120855:	83 ec 04             	sub    $0x4,%esp
f0120858:	53                   	push   %ebx
f0120859:	50                   	push   %eax
f012085a:	68 3f 15 13 f0       	push   $0xf013153f
f012085f:	e8 27 07 fe ff       	call   f0100f8b <cprintf>
f0120864:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120867:	8b 45 10             	mov    0x10(%ebp),%eax
f012086a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012086d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120871:	74 07                	je     f012087a <print_blocks_list+0x73>
f0120873:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120876:	8b 00                	mov    (%eax),%eax
f0120878:	eb 05                	jmp    f012087f <print_blocks_list+0x78>
f012087a:	b8 00 00 00 00       	mov    $0x0,%eax
f012087f:	89 45 10             	mov    %eax,0x10(%ebp)
f0120882:	8b 45 10             	mov    0x10(%ebp),%eax
f0120885:	85 c0                	test   %eax,%eax
f0120887:	75 ad                	jne    f0120836 <print_blocks_list+0x2f>
f0120889:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012088d:	75 a7                	jne    f0120836 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f012088f:	83 ec 0c             	sub    $0xc,%esp
f0120892:	68 fc 14 13 f0       	push   $0xf01314fc
f0120897:	e8 ef 06 fe ff       	call   f0100f8b <cprintf>
f012089c:	83 c4 10             	add    $0x10,%esp

}
f012089f:	90                   	nop
f01208a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01208a3:	c9                   	leave  
f01208a4:	c3                   	ret    

f01208a5 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f01208a5:	55                   	push   %ebp
f01208a6:	89 e5                	mov    %esp,%ebp
f01208a8:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f01208ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01208ae:	83 e0 01             	and    $0x1,%eax
f01208b1:	85 c0                	test   %eax,%eax
f01208b3:	74 03                	je     f01208b8 <initialize_dynamic_allocator+0x13>
f01208b5:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f01208b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01208bc:	0f 84 c7 01 00 00    	je     f0120a89 <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f01208c2:	c7 05 94 13 6c f0 01 	movl   $0x1,0xf06c1394
f01208c9:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f01208cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01208cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01208d2:	01 d0                	add    %edx,%eax
f01208d4:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f01208d9:	0f 87 ad 01 00 00    	ja     f0120a8c <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f01208df:	8b 45 08             	mov    0x8(%ebp),%eax
f01208e2:	85 c0                	test   %eax,%eax
f01208e4:	0f 89 a5 01 00 00    	jns    f0120a8f <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f01208ea:	8b 55 08             	mov    0x8(%ebp),%edx
f01208ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f01208f0:	01 d0                	add    %edx,%eax
f01208f2:	83 e8 04             	sub    $0x4,%eax
f01208f5:	a3 54 2d 6c f0       	mov    %eax,0xf06c2d54
     struct BlockElement * element = NULL;
f01208fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f0120901:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120906:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120909:	e9 87 00 00 00       	jmp    f0120995 <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f012090e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120912:	75 14                	jne    f0120928 <initialize_dynamic_allocator+0x83>
f0120914:	83 ec 04             	sub    $0x4,%esp
f0120917:	68 57 15 13 f0       	push   $0xf0131557
f012091c:	6a 79                	push   $0x79
f012091e:	68 75 15 13 f0       	push   $0xf0131575
f0120923:	e8 11 fa fd ff       	call   f0100339 <_panic>
f0120928:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012092b:	8b 00                	mov    (%eax),%eax
f012092d:	85 c0                	test   %eax,%eax
f012092f:	74 10                	je     f0120941 <initialize_dynamic_allocator+0x9c>
f0120931:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120934:	8b 00                	mov    (%eax),%eax
f0120936:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120939:	8b 52 04             	mov    0x4(%edx),%edx
f012093c:	89 50 04             	mov    %edx,0x4(%eax)
f012093f:	eb 0b                	jmp    f012094c <initialize_dynamic_allocator+0xa7>
f0120941:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120944:	8b 40 04             	mov    0x4(%eax),%eax
f0120947:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012094c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012094f:	8b 40 04             	mov    0x4(%eax),%eax
f0120952:	85 c0                	test   %eax,%eax
f0120954:	74 0f                	je     f0120965 <initialize_dynamic_allocator+0xc0>
f0120956:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120959:	8b 40 04             	mov    0x4(%eax),%eax
f012095c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012095f:	8b 12                	mov    (%edx),%edx
f0120961:	89 10                	mov    %edx,(%eax)
f0120963:	eb 0a                	jmp    f012096f <initialize_dynamic_allocator+0xca>
f0120965:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120968:	8b 00                	mov    (%eax),%eax
f012096a:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012096f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120972:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120978:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012097b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120982:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120987:	48                   	dec    %eax
f0120988:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f012098d:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0120992:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120995:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120999:	74 07                	je     f01209a2 <initialize_dynamic_allocator+0xfd>
f012099b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012099e:	8b 00                	mov    (%eax),%eax
f01209a0:	eb 05                	jmp    f01209a7 <initialize_dynamic_allocator+0x102>
f01209a2:	b8 00 00 00 00       	mov    $0x0,%eax
f01209a7:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f01209ac:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f01209b1:	85 c0                	test   %eax,%eax
f01209b3:	0f 85 55 ff ff ff    	jne    f012090e <initialize_dynamic_allocator+0x69>
f01209b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01209bd:	0f 85 4b ff ff ff    	jne    f012090e <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f01209c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01209c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f01209c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01209cc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f01209d2:	a1 54 2d 6c f0       	mov    0xf06c2d54,%eax
f01209d7:	a3 70 1b 6c f0       	mov    %eax,0xf06c1b70
    end_block->info = 1;
f01209dc:	a1 70 1b 6c f0       	mov    0xf06c1b70,%eax
f01209e1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f01209e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01209ea:	83 c0 08             	add    $0x8,%eax
f01209ed:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01209f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01209f3:	83 c0 04             	add    $0x4,%eax
f01209f6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01209f9:	83 ea 08             	sub    $0x8,%edx
f01209fc:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01209fe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120a01:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a04:	01 d0                	add    %edx,%eax
f0120a06:	83 e8 08             	sub    $0x8,%eax
f0120a09:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120a0c:	83 ea 08             	sub    $0x8,%edx
f0120a0f:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f0120a11:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0120a1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a1d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120a24:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120a28:	75 17                	jne    f0120a41 <initialize_dynamic_allocator+0x19c>
f0120a2a:	83 ec 04             	sub    $0x4,%esp
f0120a2d:	68 90 15 13 f0       	push   $0xf0131590
f0120a32:	68 90 00 00 00       	push   $0x90
f0120a37:	68 75 15 13 f0       	push   $0xf0131575
f0120a3c:	e8 f8 f8 fd ff       	call   f0100339 <_panic>
f0120a41:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0120a47:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a4a:	89 10                	mov    %edx,(%eax)
f0120a4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a4f:	8b 00                	mov    (%eax),%eax
f0120a51:	85 c0                	test   %eax,%eax
f0120a53:	74 0d                	je     f0120a62 <initialize_dynamic_allocator+0x1bd>
f0120a55:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120a5a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120a5d:	89 50 04             	mov    %edx,0x4(%eax)
f0120a60:	eb 08                	jmp    f0120a6a <initialize_dynamic_allocator+0x1c5>
f0120a62:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a65:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120a6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a6d:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120a72:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a75:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120a7c:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120a81:	40                   	inc    %eax
f0120a82:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0120a87:	eb 07                	jmp    f0120a90 <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f0120a89:	90                   	nop
f0120a8a:	eb 04                	jmp    f0120a90 <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f0120a8c:	90                   	nop
f0120a8d:	eb 01                	jmp    f0120a90 <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f0120a8f:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f0120a90:	c9                   	leave  
f0120a91:	c3                   	ret    

f0120a92 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120a92:	55                   	push   %ebp
f0120a93:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120a95:	8b 45 10             	mov    0x10(%ebp),%eax
f0120a98:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f0120a9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a9e:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120aa1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120aa4:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f0120aa6:	8b 45 08             	mov    0x8(%ebp),%eax
f0120aa9:	83 e8 04             	sub    $0x4,%eax
f0120aac:	8b 00                	mov    (%eax),%eax
f0120aae:	83 e0 fe             	and    $0xfffffffe,%eax
f0120ab1:	8d 50 f8             	lea    -0x8(%eax),%edx
f0120ab4:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ab7:	01 c2                	add    %eax,%edx
f0120ab9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120abc:	89 02                	mov    %eax,(%edx)
}
f0120abe:	90                   	nop
f0120abf:	5d                   	pop    %ebp
f0120ac0:	c3                   	ret    

f0120ac1 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f0120ac1:	55                   	push   %ebp
f0120ac2:	89 e5                	mov    %esp,%ebp
f0120ac4:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120ac7:	8b 45 08             	mov    0x8(%ebp),%eax
f0120aca:	83 e0 01             	and    $0x1,%eax
f0120acd:	85 c0                	test   %eax,%eax
f0120acf:	74 03                	je     f0120ad4 <alloc_block_FF+0x13>
f0120ad1:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120ad4:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120ad8:	77 07                	ja     f0120ae1 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120ada:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120ae1:	a1 94 13 6c f0       	mov    0xf06c1394,%eax
f0120ae6:	85 c0                	test   %eax,%eax
f0120ae8:	75 73                	jne    f0120b5d <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120aea:	8b 45 08             	mov    0x8(%ebp),%eax
f0120aed:	83 c0 10             	add    $0x10,%eax
f0120af0:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120af3:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0120afa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120afd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120b00:	01 d0                	add    %edx,%eax
f0120b02:	48                   	dec    %eax
f0120b03:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0120b06:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120b09:	ba 00 00 00 00       	mov    $0x0,%edx
f0120b0e:	f7 75 ec             	divl   -0x14(%ebp)
f0120b11:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120b14:	29 d0                	sub    %edx,%eax
f0120b16:	c1 e8 0c             	shr    $0xc,%eax
f0120b19:	83 ec 0c             	sub    $0xc,%esp
f0120b1c:	50                   	push   %eax
f0120b1d:	e8 4a 89 fe ff       	call   f010946c <sbrk>
f0120b22:	83 c4 10             	add    $0x10,%esp
f0120b25:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120b28:	83 ec 0c             	sub    $0xc,%esp
f0120b2b:	6a 00                	push   $0x0
f0120b2d:	e8 3a 89 fe ff       	call   f010946c <sbrk>
f0120b32:	83 c4 10             	add    $0x10,%esp
f0120b35:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120b38:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120b3b:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0120b3e:	83 ec 08             	sub    $0x8,%esp
f0120b41:	50                   	push   %eax
f0120b42:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120b45:	e8 5b fd ff ff       	call   f01208a5 <initialize_dynamic_allocator>
f0120b4a:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0120b4d:	83 ec 0c             	sub    $0xc,%esp
f0120b50:	68 b3 15 13 f0       	push   $0xf01315b3
f0120b55:	e8 31 04 fe ff       	call   f0100f8b <cprintf>
f0120b5a:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f0120b5d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120b61:	75 0a                	jne    f0120b6d <alloc_block_FF+0xac>
	        return NULL;
f0120b63:	b8 00 00 00 00       	mov    $0x0,%eax
f0120b68:	e9 0e 04 00 00       	jmp    f0120f7b <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f0120b6d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120b74:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120b79:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120b7c:	e9 f3 02 00 00       	jmp    f0120e74 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f0120b81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120b84:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120b87:	83 ec 0c             	sub    $0xc,%esp
f0120b8a:	ff 75 bc             	pushl  -0x44(%ebp)
f0120b8d:	e8 af fb ff ff       	call   f0120741 <get_block_size>
f0120b92:	83 c4 10             	add    $0x10,%esp
f0120b95:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120b98:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b9b:	83 c0 08             	add    $0x8,%eax
f0120b9e:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120ba1:	0f 87 c5 02 00 00    	ja     f0120e6c <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120ba7:	8b 45 08             	mov    0x8(%ebp),%eax
f0120baa:	83 c0 18             	add    $0x18,%eax
f0120bad:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0120bb0:	0f 87 19 02 00 00    	ja     f0120dcf <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f0120bb6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120bb9:	2b 45 08             	sub    0x8(%ebp),%eax
f0120bbc:	83 e8 08             	sub    $0x8,%eax
f0120bbf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f0120bc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bc5:	8d 50 08             	lea    0x8(%eax),%edx
f0120bc8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120bcb:	01 d0                	add    %edx,%eax
f0120bcd:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f0120bd0:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bd3:	83 c0 08             	add    $0x8,%eax
f0120bd6:	83 ec 04             	sub    $0x4,%esp
f0120bd9:	6a 01                	push   $0x1
f0120bdb:	50                   	push   %eax
f0120bdc:	ff 75 bc             	pushl  -0x44(%ebp)
f0120bdf:	e8 ae fe ff ff       	call   f0120a92 <set_block_data>
f0120be4:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f0120be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bea:	8b 40 04             	mov    0x4(%eax),%eax
f0120bed:	85 c0                	test   %eax,%eax
f0120bef:	75 68                	jne    f0120c59 <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120bf1:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120bf5:	75 17                	jne    f0120c0e <alloc_block_FF+0x14d>
f0120bf7:	83 ec 04             	sub    $0x4,%esp
f0120bfa:	68 90 15 13 f0       	push   $0xf0131590
f0120bff:	68 d7 00 00 00       	push   $0xd7
f0120c04:	68 75 15 13 f0       	push   $0xf0131575
f0120c09:	e8 2b f7 fd ff       	call   f0100339 <_panic>
f0120c0e:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0120c14:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c17:	89 10                	mov    %edx,(%eax)
f0120c19:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c1c:	8b 00                	mov    (%eax),%eax
f0120c1e:	85 c0                	test   %eax,%eax
f0120c20:	74 0d                	je     f0120c2f <alloc_block_FF+0x16e>
f0120c22:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0120c27:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120c2a:	89 50 04             	mov    %edx,0x4(%eax)
f0120c2d:	eb 08                	jmp    f0120c37 <alloc_block_FF+0x176>
f0120c2f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c32:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120c37:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c3a:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120c3f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c42:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120c49:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120c4e:	40                   	inc    %eax
f0120c4f:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0120c54:	e9 dc 00 00 00       	jmp    f0120d35 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120c59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c5c:	8b 00                	mov    (%eax),%eax
f0120c5e:	85 c0                	test   %eax,%eax
f0120c60:	75 65                	jne    f0120cc7 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120c62:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120c66:	75 17                	jne    f0120c7f <alloc_block_FF+0x1be>
f0120c68:	83 ec 04             	sub    $0x4,%esp
f0120c6b:	68 c4 15 13 f0       	push   $0xf01315c4
f0120c70:	68 db 00 00 00       	push   $0xdb
f0120c75:	68 75 15 13 f0       	push   $0xf0131575
f0120c7a:	e8 ba f6 fd ff       	call   f0100339 <_panic>
f0120c7f:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f0120c85:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c88:	89 50 04             	mov    %edx,0x4(%eax)
f0120c8b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120c8e:	8b 40 04             	mov    0x4(%eax),%eax
f0120c91:	85 c0                	test   %eax,%eax
f0120c93:	74 0c                	je     f0120ca1 <alloc_block_FF+0x1e0>
f0120c95:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0120c9a:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120c9d:	89 10                	mov    %edx,(%eax)
f0120c9f:	eb 08                	jmp    f0120ca9 <alloc_block_FF+0x1e8>
f0120ca1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120ca4:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120ca9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120cac:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120cb1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120cb4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120cba:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120cbf:	40                   	inc    %eax
f0120cc0:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0120cc5:	eb 6e                	jmp    f0120d35 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f0120cc7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120ccb:	74 06                	je     f0120cd3 <alloc_block_FF+0x212>
f0120ccd:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120cd1:	75 17                	jne    f0120cea <alloc_block_FF+0x229>
f0120cd3:	83 ec 04             	sub    $0x4,%esp
f0120cd6:	68 e8 15 13 f0       	push   $0xf01315e8
f0120cdb:	68 df 00 00 00       	push   $0xdf
f0120ce0:	68 75 15 13 f0       	push   $0xf0131575
f0120ce5:	e8 4f f6 fd ff       	call   f0100339 <_panic>
f0120cea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ced:	8b 10                	mov    (%eax),%edx
f0120cef:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120cf2:	89 10                	mov    %edx,(%eax)
f0120cf4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120cf7:	8b 00                	mov    (%eax),%eax
f0120cf9:	85 c0                	test   %eax,%eax
f0120cfb:	74 0b                	je     f0120d08 <alloc_block_FF+0x247>
f0120cfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d00:	8b 00                	mov    (%eax),%eax
f0120d02:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120d05:	89 50 04             	mov    %edx,0x4(%eax)
f0120d08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d0b:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120d0e:	89 10                	mov    %edx,(%eax)
f0120d10:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120d13:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d16:	89 50 04             	mov    %edx,0x4(%eax)
f0120d19:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120d1c:	8b 00                	mov    (%eax),%eax
f0120d1e:	85 c0                	test   %eax,%eax
f0120d20:	75 08                	jne    f0120d2a <alloc_block_FF+0x269>
f0120d22:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120d25:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120d2a:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120d2f:	40                   	inc    %eax
f0120d30:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120d35:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120d39:	75 17                	jne    f0120d52 <alloc_block_FF+0x291>
f0120d3b:	83 ec 04             	sub    $0x4,%esp
f0120d3e:	68 57 15 13 f0       	push   $0xf0131557
f0120d43:	68 e1 00 00 00       	push   $0xe1
f0120d48:	68 75 15 13 f0       	push   $0xf0131575
f0120d4d:	e8 e7 f5 fd ff       	call   f0100339 <_panic>
f0120d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d55:	8b 00                	mov    (%eax),%eax
f0120d57:	85 c0                	test   %eax,%eax
f0120d59:	74 10                	je     f0120d6b <alloc_block_FF+0x2aa>
f0120d5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d5e:	8b 00                	mov    (%eax),%eax
f0120d60:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d63:	8b 52 04             	mov    0x4(%edx),%edx
f0120d66:	89 50 04             	mov    %edx,0x4(%eax)
f0120d69:	eb 0b                	jmp    f0120d76 <alloc_block_FF+0x2b5>
f0120d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d6e:	8b 40 04             	mov    0x4(%eax),%eax
f0120d71:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120d76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d79:	8b 40 04             	mov    0x4(%eax),%eax
f0120d7c:	85 c0                	test   %eax,%eax
f0120d7e:	74 0f                	je     f0120d8f <alloc_block_FF+0x2ce>
f0120d80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d83:	8b 40 04             	mov    0x4(%eax),%eax
f0120d86:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120d89:	8b 12                	mov    (%edx),%edx
f0120d8b:	89 10                	mov    %edx,(%eax)
f0120d8d:	eb 0a                	jmp    f0120d99 <alloc_block_FF+0x2d8>
f0120d8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d92:	8b 00                	mov    (%eax),%eax
f0120d94:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d9c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120da2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120da5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120dac:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120db1:	48                   	dec    %eax
f0120db2:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				set_block_data(new_block_va, remaining_size, 0);
f0120db7:	83 ec 04             	sub    $0x4,%esp
f0120dba:	6a 00                	push   $0x0
f0120dbc:	ff 75 b4             	pushl  -0x4c(%ebp)
f0120dbf:	ff 75 b0             	pushl  -0x50(%ebp)
f0120dc2:	e8 cb fc ff ff       	call   f0120a92 <set_block_data>
f0120dc7:	83 c4 10             	add    $0x10,%esp
f0120dca:	e9 95 00 00 00       	jmp    f0120e64 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f0120dcf:	83 ec 04             	sub    $0x4,%esp
f0120dd2:	6a 01                	push   $0x1
f0120dd4:	ff 75 b8             	pushl  -0x48(%ebp)
f0120dd7:	ff 75 bc             	pushl  -0x44(%ebp)
f0120dda:	e8 b3 fc ff ff       	call   f0120a92 <set_block_data>
f0120ddf:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f0120de2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120de6:	75 17                	jne    f0120dff <alloc_block_FF+0x33e>
f0120de8:	83 ec 04             	sub    $0x4,%esp
f0120deb:	68 57 15 13 f0       	push   $0xf0131557
f0120df0:	68 e8 00 00 00       	push   $0xe8
f0120df5:	68 75 15 13 f0       	push   $0xf0131575
f0120dfa:	e8 3a f5 fd ff       	call   f0100339 <_panic>
f0120dff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e02:	8b 00                	mov    (%eax),%eax
f0120e04:	85 c0                	test   %eax,%eax
f0120e06:	74 10                	je     f0120e18 <alloc_block_FF+0x357>
f0120e08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e0b:	8b 00                	mov    (%eax),%eax
f0120e0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120e10:	8b 52 04             	mov    0x4(%edx),%edx
f0120e13:	89 50 04             	mov    %edx,0x4(%eax)
f0120e16:	eb 0b                	jmp    f0120e23 <alloc_block_FF+0x362>
f0120e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e1b:	8b 40 04             	mov    0x4(%eax),%eax
f0120e1e:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0120e23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e26:	8b 40 04             	mov    0x4(%eax),%eax
f0120e29:	85 c0                	test   %eax,%eax
f0120e2b:	74 0f                	je     f0120e3c <alloc_block_FF+0x37b>
f0120e2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e30:	8b 40 04             	mov    0x4(%eax),%eax
f0120e33:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120e36:	8b 12                	mov    (%edx),%edx
f0120e38:	89 10                	mov    %edx,(%eax)
f0120e3a:	eb 0a                	jmp    f0120e46 <alloc_block_FF+0x385>
f0120e3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e3f:	8b 00                	mov    (%eax),%eax
f0120e41:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0120e46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e49:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120e4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e52:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120e59:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0120e5e:	48                   	dec    %eax
f0120e5f:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
	            }
	            return va;
f0120e64:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120e67:	e9 0f 01 00 00       	jmp    f0120f7b <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120e6c:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0120e71:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120e74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120e78:	74 07                	je     f0120e81 <alloc_block_FF+0x3c0>
f0120e7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120e7d:	8b 00                	mov    (%eax),%eax
f0120e7f:	eb 05                	jmp    f0120e86 <alloc_block_FF+0x3c5>
f0120e81:	b8 00 00 00 00       	mov    $0x0,%eax
f0120e86:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0120e8b:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0120e90:	85 c0                	test   %eax,%eax
f0120e92:	0f 85 e9 fc ff ff    	jne    f0120b81 <alloc_block_FF+0xc0>
f0120e98:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120e9c:	0f 85 df fc ff ff    	jne    f0120b81 <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f0120ea2:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ea5:	83 c0 08             	add    $0x8,%eax
f0120ea8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120eab:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f0120eb2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120eb5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120eb8:	01 d0                	add    %edx,%eax
f0120eba:	48                   	dec    %eax
f0120ebb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0120ebe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120ec1:	ba 00 00 00 00       	mov    $0x0,%edx
f0120ec6:	f7 75 d8             	divl   -0x28(%ebp)
f0120ec9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120ecc:	29 d0                	sub    %edx,%eax
f0120ece:	c1 e8 0c             	shr    $0xc,%eax
f0120ed1:	83 ec 0c             	sub    $0xc,%esp
f0120ed4:	50                   	push   %eax
f0120ed5:	e8 92 85 fe ff       	call   f010946c <sbrk>
f0120eda:	83 c4 10             	add    $0x10,%esp
f0120edd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f0120ee0:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f0120ee4:	75 0a                	jne    f0120ef0 <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f0120ee6:	b8 00 00 00 00       	mov    $0x0,%eax
f0120eeb:	e9 8b 00 00 00       	jmp    f0120f7b <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120ef0:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f0120ef7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120efa:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120efd:	01 d0                	add    %edx,%eax
f0120eff:	48                   	dec    %eax
f0120f00:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0120f03:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120f06:	ba 00 00 00 00       	mov    $0x0,%edx
f0120f0b:	f7 75 cc             	divl   -0x34(%ebp)
f0120f0e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120f11:	29 d0                	sub    %edx,%eax
f0120f13:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120f16:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120f19:	01 d0                	add    %edx,%eax
f0120f1b:	a3 70 1b 6c f0       	mov    %eax,0xf06c1b70
			end_block->info = 1;
f0120f20:	a1 70 1b 6c f0       	mov    0xf06c1b70,%eax
f0120f25:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120f2b:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120f32:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120f35:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120f38:	01 d0                	add    %edx,%eax
f0120f3a:	48                   	dec    %eax
f0120f3b:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120f3e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120f41:	ba 00 00 00 00       	mov    $0x0,%edx
f0120f46:	f7 75 c4             	divl   -0x3c(%ebp)
f0120f49:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120f4c:	29 d0                	sub    %edx,%eax
f0120f4e:	83 ec 04             	sub    $0x4,%esp
f0120f51:	6a 01                	push   $0x1
f0120f53:	50                   	push   %eax
f0120f54:	ff 75 d0             	pushl  -0x30(%ebp)
f0120f57:	e8 36 fb ff ff       	call   f0120a92 <set_block_data>
f0120f5c:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f0120f5f:	83 ec 0c             	sub    $0xc,%esp
f0120f62:	ff 75 d0             	pushl  -0x30(%ebp)
f0120f65:	e8 1b 0a 00 00       	call   f0121985 <free_block>
f0120f6a:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f0120f6d:	83 ec 0c             	sub    $0xc,%esp
f0120f70:	ff 75 08             	pushl  0x8(%ebp)
f0120f73:	e8 49 fb ff ff       	call   f0120ac1 <alloc_block_FF>
f0120f78:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f0120f7b:	c9                   	leave  
f0120f7c:	c3                   	ret    

f0120f7d <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0120f7d:	55                   	push   %ebp
f0120f7e:	89 e5                	mov    %esp,%ebp
f0120f80:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120f83:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f86:	83 e0 01             	and    $0x1,%eax
f0120f89:	85 c0                	test   %eax,%eax
f0120f8b:	74 03                	je     f0120f90 <alloc_block_BF+0x13>
f0120f8d:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0120f90:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120f94:	77 07                	ja     f0120f9d <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120f96:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0120f9d:	a1 94 13 6c f0       	mov    0xf06c1394,%eax
f0120fa2:	85 c0                	test   %eax,%eax
f0120fa4:	75 73                	jne    f0121019 <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120fa6:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fa9:	83 c0 10             	add    $0x10,%eax
f0120fac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0120faf:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f0120fb6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120fb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120fbc:	01 d0                	add    %edx,%eax
f0120fbe:	48                   	dec    %eax
f0120fbf:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120fc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120fc5:	ba 00 00 00 00       	mov    $0x0,%edx
f0120fca:	f7 75 e0             	divl   -0x20(%ebp)
f0120fcd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120fd0:	29 d0                	sub    %edx,%eax
f0120fd2:	c1 e8 0c             	shr    $0xc,%eax
f0120fd5:	83 ec 0c             	sub    $0xc,%esp
f0120fd8:	50                   	push   %eax
f0120fd9:	e8 8e 84 fe ff       	call   f010946c <sbrk>
f0120fde:	83 c4 10             	add    $0x10,%esp
f0120fe1:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120fe4:	83 ec 0c             	sub    $0xc,%esp
f0120fe7:	6a 00                	push   $0x0
f0120fe9:	e8 7e 84 fe ff       	call   f010946c <sbrk>
f0120fee:	83 c4 10             	add    $0x10,%esp
f0120ff1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120ff4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120ff7:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0120ffa:	83 ec 08             	sub    $0x8,%esp
f0120ffd:	50                   	push   %eax
f0120ffe:	ff 75 d8             	pushl  -0x28(%ebp)
f0121001:	e8 9f f8 ff ff       	call   f01208a5 <initialize_dynamic_allocator>
f0121006:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f0121009:	83 ec 0c             	sub    $0xc,%esp
f012100c:	68 b3 15 13 f0       	push   $0xf01315b3
f0121011:	e8 75 ff fd ff       	call   f0100f8b <cprintf>
f0121016:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f0121019:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f0121020:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f0121027:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f012102e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f0121035:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f012103a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012103d:	e9 1d 01 00 00       	jmp    f012115f <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0121042:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121045:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f0121048:	83 ec 0c             	sub    $0xc,%esp
f012104b:	ff 75 a8             	pushl  -0x58(%ebp)
f012104e:	e8 ee f6 ff ff       	call   f0120741 <get_block_size>
f0121053:	83 c4 10             	add    $0x10,%esp
f0121056:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f0121059:	8b 45 08             	mov    0x8(%ebp),%eax
f012105c:	83 c0 08             	add    $0x8,%eax
f012105f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121062:	0f 87 ef 00 00 00    	ja     f0121157 <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0121068:	8b 45 08             	mov    0x8(%ebp),%eax
f012106b:	83 c0 18             	add    $0x18,%eax
f012106e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121071:	77 1d                	ja     f0121090 <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f0121073:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121076:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121079:	0f 86 d8 00 00 00    	jbe    f0121157 <alloc_block_BF+0x1da>
				{
					best_va = va;
f012107f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121082:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f0121085:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0121088:	89 45 ec             	mov    %eax,-0x14(%ebp)
f012108b:	e9 c7 00 00 00       	jmp    f0121157 <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f0121090:	8b 45 08             	mov    0x8(%ebp),%eax
f0121093:	83 c0 08             	add    $0x8,%eax
f0121096:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121099:	0f 85 9d 00 00 00    	jne    f012113c <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f012109f:	83 ec 04             	sub    $0x4,%esp
f01210a2:	6a 01                	push   $0x1
f01210a4:	ff 75 a4             	pushl  -0x5c(%ebp)
f01210a7:	ff 75 a8             	pushl  -0x58(%ebp)
f01210aa:	e8 e3 f9 ff ff       	call   f0120a92 <set_block_data>
f01210af:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f01210b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01210b6:	75 17                	jne    f01210cf <alloc_block_BF+0x152>
f01210b8:	83 ec 04             	sub    $0x4,%esp
f01210bb:	68 57 15 13 f0       	push   $0xf0131557
f01210c0:	68 2c 01 00 00       	push   $0x12c
f01210c5:	68 75 15 13 f0       	push   $0xf0131575
f01210ca:	e8 6a f2 fd ff       	call   f0100339 <_panic>
f01210cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210d2:	8b 00                	mov    (%eax),%eax
f01210d4:	85 c0                	test   %eax,%eax
f01210d6:	74 10                	je     f01210e8 <alloc_block_BF+0x16b>
f01210d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210db:	8b 00                	mov    (%eax),%eax
f01210dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01210e0:	8b 52 04             	mov    0x4(%edx),%edx
f01210e3:	89 50 04             	mov    %edx,0x4(%eax)
f01210e6:	eb 0b                	jmp    f01210f3 <alloc_block_BF+0x176>
f01210e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210eb:	8b 40 04             	mov    0x4(%eax),%eax
f01210ee:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01210f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210f6:	8b 40 04             	mov    0x4(%eax),%eax
f01210f9:	85 c0                	test   %eax,%eax
f01210fb:	74 0f                	je     f012110c <alloc_block_BF+0x18f>
f01210fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121100:	8b 40 04             	mov    0x4(%eax),%eax
f0121103:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121106:	8b 12                	mov    (%edx),%edx
f0121108:	89 10                	mov    %edx,(%eax)
f012110a:	eb 0a                	jmp    f0121116 <alloc_block_BF+0x199>
f012110c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012110f:	8b 00                	mov    (%eax),%eax
f0121111:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121116:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121119:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012111f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121122:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121129:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f012112e:	48                   	dec    %eax
f012112f:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
					return va;
f0121134:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0121137:	e9 24 04 00 00       	jmp    f0121560 <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f012113c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012113f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0121142:	76 13                	jbe    f0121157 <alloc_block_BF+0x1da>
					{
						internal = 1;
f0121144:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f012114b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f012114e:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0121151:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0121154:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f0121157:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f012115c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012115f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121163:	74 07                	je     f012116c <alloc_block_BF+0x1ef>
f0121165:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121168:	8b 00                	mov    (%eax),%eax
f012116a:	eb 05                	jmp    f0121171 <alloc_block_BF+0x1f4>
f012116c:	b8 00 00 00 00       	mov    $0x0,%eax
f0121171:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0121176:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f012117b:	85 c0                	test   %eax,%eax
f012117d:	0f 85 bf fe ff ff    	jne    f0121042 <alloc_block_BF+0xc5>
f0121183:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121187:	0f 85 b5 fe ff ff    	jne    f0121042 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f012118d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121191:	0f 84 26 02 00 00    	je     f01213bd <alloc_block_BF+0x440>
f0121197:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f012119b:	0f 85 1c 02 00 00    	jne    f01213bd <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f01211a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01211a4:	2b 45 08             	sub    0x8(%ebp),%eax
f01211a7:	83 e8 08             	sub    $0x8,%eax
f01211aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f01211ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01211b0:	8d 50 08             	lea    0x8(%eax),%edx
f01211b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01211b6:	01 d0                	add    %edx,%eax
f01211b8:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f01211bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01211be:	83 c0 08             	add    $0x8,%eax
f01211c1:	83 ec 04             	sub    $0x4,%esp
f01211c4:	6a 01                	push   $0x1
f01211c6:	50                   	push   %eax
f01211c7:	ff 75 f0             	pushl  -0x10(%ebp)
f01211ca:	e8 c3 f8 ff ff       	call   f0120a92 <set_block_data>
f01211cf:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f01211d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01211d5:	8b 40 04             	mov    0x4(%eax),%eax
f01211d8:	85 c0                	test   %eax,%eax
f01211da:	75 68                	jne    f0121244 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f01211dc:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01211e0:	75 17                	jne    f01211f9 <alloc_block_BF+0x27c>
f01211e2:	83 ec 04             	sub    $0x4,%esp
f01211e5:	68 90 15 13 f0       	push   $0xf0131590
f01211ea:	68 45 01 00 00       	push   $0x145
f01211ef:	68 75 15 13 f0       	push   $0xf0131575
f01211f4:	e8 40 f1 fd ff       	call   f0100339 <_panic>
f01211f9:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f01211ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121202:	89 10                	mov    %edx,(%eax)
f0121204:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121207:	8b 00                	mov    (%eax),%eax
f0121209:	85 c0                	test   %eax,%eax
f012120b:	74 0d                	je     f012121a <alloc_block_BF+0x29d>
f012120d:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121212:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121215:	89 50 04             	mov    %edx,0x4(%eax)
f0121218:	eb 08                	jmp    f0121222 <alloc_block_BF+0x2a5>
f012121a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012121d:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121222:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121225:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012122a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012122d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121234:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121239:	40                   	inc    %eax
f012123a:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f012123f:	e9 dc 00 00 00       	jmp    f0121320 <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f0121244:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121247:	8b 00                	mov    (%eax),%eax
f0121249:	85 c0                	test   %eax,%eax
f012124b:	75 65                	jne    f01212b2 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f012124d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0121251:	75 17                	jne    f012126a <alloc_block_BF+0x2ed>
f0121253:	83 ec 04             	sub    $0x4,%esp
f0121256:	68 c4 15 13 f0       	push   $0xf01315c4
f012125b:	68 4a 01 00 00       	push   $0x14a
f0121260:	68 75 15 13 f0       	push   $0xf0131575
f0121265:	e8 cf f0 fd ff       	call   f0100339 <_panic>
f012126a:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f0121270:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121273:	89 50 04             	mov    %edx,0x4(%eax)
f0121276:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121279:	8b 40 04             	mov    0x4(%eax),%eax
f012127c:	85 c0                	test   %eax,%eax
f012127e:	74 0c                	je     f012128c <alloc_block_BF+0x30f>
f0121280:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0121285:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0121288:	89 10                	mov    %edx,(%eax)
f012128a:	eb 08                	jmp    f0121294 <alloc_block_BF+0x317>
f012128c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012128f:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121294:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121297:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012129c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012129f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01212a5:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01212aa:	40                   	inc    %eax
f01212ab:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f01212b0:	eb 6e                	jmp    f0121320 <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f01212b2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01212b6:	74 06                	je     f01212be <alloc_block_BF+0x341>
f01212b8:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f01212bc:	75 17                	jne    f01212d5 <alloc_block_BF+0x358>
f01212be:	83 ec 04             	sub    $0x4,%esp
f01212c1:	68 e8 15 13 f0       	push   $0xf01315e8
f01212c6:	68 4f 01 00 00       	push   $0x14f
f01212cb:	68 75 15 13 f0       	push   $0xf0131575
f01212d0:	e8 64 f0 fd ff       	call   f0100339 <_panic>
f01212d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212d8:	8b 10                	mov    (%eax),%edx
f01212da:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01212dd:	89 10                	mov    %edx,(%eax)
f01212df:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01212e2:	8b 00                	mov    (%eax),%eax
f01212e4:	85 c0                	test   %eax,%eax
f01212e6:	74 0b                	je     f01212f3 <alloc_block_BF+0x376>
f01212e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212eb:	8b 00                	mov    (%eax),%eax
f01212ed:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01212f0:	89 50 04             	mov    %edx,0x4(%eax)
f01212f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01212f6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01212f9:	89 10                	mov    %edx,(%eax)
f01212fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01212fe:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121301:	89 50 04             	mov    %edx,0x4(%eax)
f0121304:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121307:	8b 00                	mov    (%eax),%eax
f0121309:	85 c0                	test   %eax,%eax
f012130b:	75 08                	jne    f0121315 <alloc_block_BF+0x398>
f012130d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0121310:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121315:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f012131a:	40                   	inc    %eax
f012131b:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0121320:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121324:	75 17                	jne    f012133d <alloc_block_BF+0x3c0>
f0121326:	83 ec 04             	sub    $0x4,%esp
f0121329:	68 57 15 13 f0       	push   $0xf0131557
f012132e:	68 51 01 00 00       	push   $0x151
f0121333:	68 75 15 13 f0       	push   $0xf0131575
f0121338:	e8 fc ef fd ff       	call   f0100339 <_panic>
f012133d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121340:	8b 00                	mov    (%eax),%eax
f0121342:	85 c0                	test   %eax,%eax
f0121344:	74 10                	je     f0121356 <alloc_block_BF+0x3d9>
f0121346:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121349:	8b 00                	mov    (%eax),%eax
f012134b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012134e:	8b 52 04             	mov    0x4(%edx),%edx
f0121351:	89 50 04             	mov    %edx,0x4(%eax)
f0121354:	eb 0b                	jmp    f0121361 <alloc_block_BF+0x3e4>
f0121356:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121359:	8b 40 04             	mov    0x4(%eax),%eax
f012135c:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121361:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121364:	8b 40 04             	mov    0x4(%eax),%eax
f0121367:	85 c0                	test   %eax,%eax
f0121369:	74 0f                	je     f012137a <alloc_block_BF+0x3fd>
f012136b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012136e:	8b 40 04             	mov    0x4(%eax),%eax
f0121371:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121374:	8b 12                	mov    (%edx),%edx
f0121376:	89 10                	mov    %edx,(%eax)
f0121378:	eb 0a                	jmp    f0121384 <alloc_block_BF+0x407>
f012137a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012137d:	8b 00                	mov    (%eax),%eax
f012137f:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121384:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121387:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012138d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121390:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121397:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f012139c:	48                   	dec    %eax
f012139d:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
			set_block_data(new_block_va, remaining_size, 0);
f01213a2:	83 ec 04             	sub    $0x4,%esp
f01213a5:	6a 00                	push   $0x0
f01213a7:	ff 75 d0             	pushl  -0x30(%ebp)
f01213aa:	ff 75 cc             	pushl  -0x34(%ebp)
f01213ad:	e8 e0 f6 ff ff       	call   f0120a92 <set_block_data>
f01213b2:	83 c4 10             	add    $0x10,%esp
			return best_va;
f01213b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213b8:	e9 a3 01 00 00       	jmp    f0121560 <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f01213bd:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01213c1:	0f 85 9d 00 00 00    	jne    f0121464 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f01213c7:	83 ec 04             	sub    $0x4,%esp
f01213ca:	6a 01                	push   $0x1
f01213cc:	ff 75 ec             	pushl  -0x14(%ebp)
f01213cf:	ff 75 f0             	pushl  -0x10(%ebp)
f01213d2:	e8 bb f6 ff ff       	call   f0120a92 <set_block_data>
f01213d7:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f01213da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01213de:	75 17                	jne    f01213f7 <alloc_block_BF+0x47a>
f01213e0:	83 ec 04             	sub    $0x4,%esp
f01213e3:	68 57 15 13 f0       	push   $0xf0131557
f01213e8:	68 58 01 00 00       	push   $0x158
f01213ed:	68 75 15 13 f0       	push   $0xf0131575
f01213f2:	e8 42 ef fd ff       	call   f0100339 <_panic>
f01213f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01213fa:	8b 00                	mov    (%eax),%eax
f01213fc:	85 c0                	test   %eax,%eax
f01213fe:	74 10                	je     f0121410 <alloc_block_BF+0x493>
f0121400:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121403:	8b 00                	mov    (%eax),%eax
f0121405:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121408:	8b 52 04             	mov    0x4(%edx),%edx
f012140b:	89 50 04             	mov    %edx,0x4(%eax)
f012140e:	eb 0b                	jmp    f012141b <alloc_block_BF+0x49e>
f0121410:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121413:	8b 40 04             	mov    0x4(%eax),%eax
f0121416:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012141b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012141e:	8b 40 04             	mov    0x4(%eax),%eax
f0121421:	85 c0                	test   %eax,%eax
f0121423:	74 0f                	je     f0121434 <alloc_block_BF+0x4b7>
f0121425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121428:	8b 40 04             	mov    0x4(%eax),%eax
f012142b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012142e:	8b 12                	mov    (%edx),%edx
f0121430:	89 10                	mov    %edx,(%eax)
f0121432:	eb 0a                	jmp    f012143e <alloc_block_BF+0x4c1>
f0121434:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121437:	8b 00                	mov    (%eax),%eax
f0121439:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012143e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121441:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012144a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121451:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121456:	48                   	dec    %eax
f0121457:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		return best_va;
f012145c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012145f:	e9 fc 00 00 00       	jmp    f0121560 <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f0121464:	8b 45 08             	mov    0x8(%ebp),%eax
f0121467:	83 c0 08             	add    $0x8,%eax
f012146a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f012146d:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0121474:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121477:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012147a:	01 d0                	add    %edx,%eax
f012147c:	48                   	dec    %eax
f012147d:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0121480:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121483:	ba 00 00 00 00       	mov    $0x0,%edx
f0121488:	f7 75 c4             	divl   -0x3c(%ebp)
f012148b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012148e:	29 d0                	sub    %edx,%eax
f0121490:	c1 e8 0c             	shr    $0xc,%eax
f0121493:	83 ec 0c             	sub    $0xc,%esp
f0121496:	50                   	push   %eax
f0121497:	e8 d0 7f fe ff       	call   f010946c <sbrk>
f012149c:	83 c4 10             	add    $0x10,%esp
f012149f:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f01214a2:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f01214a6:	75 0a                	jne    f01214b2 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f01214a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01214ad:	e9 ae 00 00 00       	jmp    f0121560 <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f01214b2:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f01214b9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01214bc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01214bf:	01 d0                	add    %edx,%eax
f01214c1:	48                   	dec    %eax
f01214c2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01214c5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01214c8:	ba 00 00 00 00       	mov    $0x0,%edx
f01214cd:	f7 75 b8             	divl   -0x48(%ebp)
f01214d0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01214d3:	29 d0                	sub    %edx,%eax
f01214d5:	8d 50 fc             	lea    -0x4(%eax),%edx
f01214d8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01214db:	01 d0                	add    %edx,%eax
f01214dd:	a3 70 1b 6c f0       	mov    %eax,0xf06c1b70
				end_block->info = 1;
f01214e2:	a1 70 1b 6c f0       	mov    0xf06c1b70,%eax
f01214e7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f01214ed:	83 ec 0c             	sub    $0xc,%esp
f01214f0:	68 1c 16 13 f0       	push   $0xf013161c
f01214f5:	e8 91 fa fd ff       	call   f0100f8b <cprintf>
f01214fa:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f01214fd:	83 ec 08             	sub    $0x8,%esp
f0121500:	ff 75 bc             	pushl  -0x44(%ebp)
f0121503:	68 21 16 13 f0       	push   $0xf0131621
f0121508:	e8 7e fa fd ff       	call   f0100f8b <cprintf>
f012150d:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0121510:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f0121517:	8b 55 c8             	mov    -0x38(%ebp),%edx
f012151a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012151d:	01 d0                	add    %edx,%eax
f012151f:	48                   	dec    %eax
f0121520:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0121523:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0121526:	ba 00 00 00 00       	mov    $0x0,%edx
f012152b:	f7 75 b0             	divl   -0x50(%ebp)
f012152e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0121531:	29 d0                	sub    %edx,%eax
f0121533:	83 ec 04             	sub    $0x4,%esp
f0121536:	6a 01                	push   $0x1
f0121538:	50                   	push   %eax
f0121539:	ff 75 bc             	pushl  -0x44(%ebp)
f012153c:	e8 51 f5 ff ff       	call   f0120a92 <set_block_data>
f0121541:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f0121544:	83 ec 0c             	sub    $0xc,%esp
f0121547:	ff 75 bc             	pushl  -0x44(%ebp)
f012154a:	e8 36 04 00 00       	call   f0121985 <free_block>
f012154f:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0121552:	83 ec 0c             	sub    $0xc,%esp
f0121555:	ff 75 08             	pushl  0x8(%ebp)
f0121558:	e8 20 fa ff ff       	call   f0120f7d <alloc_block_BF>
f012155d:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0121560:	c9                   	leave  
f0121561:	c3                   	ret    

f0121562 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0121562:	55                   	push   %ebp
f0121563:	89 e5                	mov    %esp,%ebp
f0121565:	53                   	push   %ebx
f0121566:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f0121569:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121570:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0121577:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012157b:	74 1e                	je     f012159b <merging+0x39>
f012157d:	ff 75 08             	pushl  0x8(%ebp)
f0121580:	e8 bc f1 ff ff       	call   f0120741 <get_block_size>
f0121585:	83 c4 04             	add    $0x4,%esp
f0121588:	89 c2                	mov    %eax,%edx
f012158a:	8b 45 08             	mov    0x8(%ebp),%eax
f012158d:	01 d0                	add    %edx,%eax
f012158f:	3b 45 10             	cmp    0x10(%ebp),%eax
f0121592:	75 07                	jne    f012159b <merging+0x39>
		prev_is_free = 1;
f0121594:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f012159b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012159f:	74 1e                	je     f01215bf <merging+0x5d>
f01215a1:	ff 75 10             	pushl  0x10(%ebp)
f01215a4:	e8 98 f1 ff ff       	call   f0120741 <get_block_size>
f01215a9:	83 c4 04             	add    $0x4,%esp
f01215ac:	89 c2                	mov    %eax,%edx
f01215ae:	8b 45 10             	mov    0x10(%ebp),%eax
f01215b1:	01 d0                	add    %edx,%eax
f01215b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01215b6:	75 07                	jne    f01215bf <merging+0x5d>
		next_is_free = 1;
f01215b8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f01215bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01215c3:	0f 84 cc 00 00 00    	je     f0121695 <merging+0x133>
f01215c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01215cd:	0f 84 c2 00 00 00    	je     f0121695 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f01215d3:	ff 75 08             	pushl  0x8(%ebp)
f01215d6:	e8 66 f1 ff ff       	call   f0120741 <get_block_size>
f01215db:	83 c4 04             	add    $0x4,%esp
f01215de:	89 c3                	mov    %eax,%ebx
f01215e0:	ff 75 10             	pushl  0x10(%ebp)
f01215e3:	e8 59 f1 ff ff       	call   f0120741 <get_block_size>
f01215e8:	83 c4 04             	add    $0x4,%esp
f01215eb:	01 c3                	add    %eax,%ebx
f01215ed:	ff 75 0c             	pushl  0xc(%ebp)
f01215f0:	e8 4c f1 ff ff       	call   f0120741 <get_block_size>
f01215f5:	83 c4 04             	add    $0x4,%esp
f01215f8:	01 d8                	add    %ebx,%eax
f01215fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01215fd:	6a 00                	push   $0x0
f01215ff:	ff 75 ec             	pushl  -0x14(%ebp)
f0121602:	ff 75 08             	pushl  0x8(%ebp)
f0121605:	e8 88 f4 ff ff       	call   f0120a92 <set_block_data>
f012160a:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f012160d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121611:	75 17                	jne    f012162a <merging+0xc8>
f0121613:	83 ec 04             	sub    $0x4,%esp
f0121616:	68 57 15 13 f0       	push   $0xf0131557
f012161b:	68 7d 01 00 00       	push   $0x17d
f0121620:	68 75 15 13 f0       	push   $0xf0131575
f0121625:	e8 0f ed fd ff       	call   f0100339 <_panic>
f012162a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012162d:	8b 00                	mov    (%eax),%eax
f012162f:	85 c0                	test   %eax,%eax
f0121631:	74 10                	je     f0121643 <merging+0xe1>
f0121633:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121636:	8b 00                	mov    (%eax),%eax
f0121638:	8b 55 0c             	mov    0xc(%ebp),%edx
f012163b:	8b 52 04             	mov    0x4(%edx),%edx
f012163e:	89 50 04             	mov    %edx,0x4(%eax)
f0121641:	eb 0b                	jmp    f012164e <merging+0xec>
f0121643:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121646:	8b 40 04             	mov    0x4(%eax),%eax
f0121649:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012164e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121651:	8b 40 04             	mov    0x4(%eax),%eax
f0121654:	85 c0                	test   %eax,%eax
f0121656:	74 0f                	je     f0121667 <merging+0x105>
f0121658:	8b 45 0c             	mov    0xc(%ebp),%eax
f012165b:	8b 40 04             	mov    0x4(%eax),%eax
f012165e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121661:	8b 12                	mov    (%edx),%edx
f0121663:	89 10                	mov    %edx,(%eax)
f0121665:	eb 0a                	jmp    f0121671 <merging+0x10f>
f0121667:	8b 45 0c             	mov    0xc(%ebp),%eax
f012166a:	8b 00                	mov    (%eax),%eax
f012166c:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121671:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121674:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012167a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012167d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121684:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121689:	48                   	dec    %eax
f012168a:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f012168f:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121690:	e9 ea 02 00 00       	jmp    f012197f <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0121695:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121699:	74 3b                	je     f01216d6 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f012169b:	83 ec 0c             	sub    $0xc,%esp
f012169e:	ff 75 08             	pushl  0x8(%ebp)
f01216a1:	e8 9b f0 ff ff       	call   f0120741 <get_block_size>
f01216a6:	83 c4 10             	add    $0x10,%esp
f01216a9:	89 c3                	mov    %eax,%ebx
f01216ab:	83 ec 0c             	sub    $0xc,%esp
f01216ae:	ff 75 10             	pushl  0x10(%ebp)
f01216b1:	e8 8b f0 ff ff       	call   f0120741 <get_block_size>
f01216b6:	83 c4 10             	add    $0x10,%esp
f01216b9:	01 d8                	add    %ebx,%eax
f01216bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f01216be:	83 ec 04             	sub    $0x4,%esp
f01216c1:	6a 00                	push   $0x0
f01216c3:	ff 75 e8             	pushl  -0x18(%ebp)
f01216c6:	ff 75 08             	pushl  0x8(%ebp)
f01216c9:	e8 c4 f3 ff ff       	call   f0120a92 <set_block_data>
f01216ce:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01216d1:	e9 a9 02 00 00       	jmp    f012197f <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f01216d6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01216da:	0f 84 2d 01 00 00    	je     f012180d <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f01216e0:	83 ec 0c             	sub    $0xc,%esp
f01216e3:	ff 75 10             	pushl  0x10(%ebp)
f01216e6:	e8 56 f0 ff ff       	call   f0120741 <get_block_size>
f01216eb:	83 c4 10             	add    $0x10,%esp
f01216ee:	89 c3                	mov    %eax,%ebx
f01216f0:	83 ec 0c             	sub    $0xc,%esp
f01216f3:	ff 75 0c             	pushl  0xc(%ebp)
f01216f6:	e8 46 f0 ff ff       	call   f0120741 <get_block_size>
f01216fb:	83 c4 10             	add    $0x10,%esp
f01216fe:	01 d8                	add    %ebx,%eax
f0121700:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f0121703:	83 ec 04             	sub    $0x4,%esp
f0121706:	6a 00                	push   $0x0
f0121708:	ff 75 e4             	pushl  -0x1c(%ebp)
f012170b:	ff 75 10             	pushl  0x10(%ebp)
f012170e:	e8 7f f3 ff ff       	call   f0120a92 <set_block_data>
f0121713:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f0121716:	8b 45 10             	mov    0x10(%ebp),%eax
f0121719:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f012171c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121720:	74 06                	je     f0121728 <merging+0x1c6>
f0121722:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121726:	75 17                	jne    f012173f <merging+0x1dd>
f0121728:	83 ec 04             	sub    $0x4,%esp
f012172b:	68 30 16 13 f0       	push   $0xf0131630
f0121730:	68 8d 01 00 00       	push   $0x18d
f0121735:	68 75 15 13 f0       	push   $0xf0131575
f012173a:	e8 fa eb fd ff       	call   f0100339 <_panic>
f012173f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121742:	8b 50 04             	mov    0x4(%eax),%edx
f0121745:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121748:	89 50 04             	mov    %edx,0x4(%eax)
f012174b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012174e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121751:	89 10                	mov    %edx,(%eax)
f0121753:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121756:	8b 40 04             	mov    0x4(%eax),%eax
f0121759:	85 c0                	test   %eax,%eax
f012175b:	74 0d                	je     f012176a <merging+0x208>
f012175d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121760:	8b 40 04             	mov    0x4(%eax),%eax
f0121763:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121766:	89 10                	mov    %edx,(%eax)
f0121768:	eb 08                	jmp    f0121772 <merging+0x210>
f012176a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012176d:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121772:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121775:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121778:	89 50 04             	mov    %edx,0x4(%eax)
f012177b:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121780:	40                   	inc    %eax
f0121781:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		LIST_REMOVE(&freeBlocksList, next_block);
f0121786:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012178a:	75 17                	jne    f01217a3 <merging+0x241>
f012178c:	83 ec 04             	sub    $0x4,%esp
f012178f:	68 57 15 13 f0       	push   $0xf0131557
f0121794:	68 8e 01 00 00       	push   $0x18e
f0121799:	68 75 15 13 f0       	push   $0xf0131575
f012179e:	e8 96 eb fd ff       	call   f0100339 <_panic>
f01217a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217a6:	8b 00                	mov    (%eax),%eax
f01217a8:	85 c0                	test   %eax,%eax
f01217aa:	74 10                	je     f01217bc <merging+0x25a>
f01217ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217af:	8b 00                	mov    (%eax),%eax
f01217b1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01217b4:	8b 52 04             	mov    0x4(%edx),%edx
f01217b7:	89 50 04             	mov    %edx,0x4(%eax)
f01217ba:	eb 0b                	jmp    f01217c7 <merging+0x265>
f01217bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217bf:	8b 40 04             	mov    0x4(%eax),%eax
f01217c2:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01217c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217ca:	8b 40 04             	mov    0x4(%eax),%eax
f01217cd:	85 c0                	test   %eax,%eax
f01217cf:	74 0f                	je     f01217e0 <merging+0x27e>
f01217d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217d4:	8b 40 04             	mov    0x4(%eax),%eax
f01217d7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01217da:	8b 12                	mov    (%edx),%edx
f01217dc:	89 10                	mov    %edx,(%eax)
f01217de:	eb 0a                	jmp    f01217ea <merging+0x288>
f01217e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217e3:	8b 00                	mov    (%eax),%eax
f01217e5:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f01217ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217ed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01217f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01217f6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01217fd:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121802:	48                   	dec    %eax
f0121803:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0121808:	e9 72 01 00 00       	jmp    f012197f <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f012180d:	8b 45 10             	mov    0x10(%ebp),%eax
f0121810:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121813:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121817:	74 79                	je     f0121892 <merging+0x330>
f0121819:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012181d:	74 73                	je     f0121892 <merging+0x330>
f012181f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121823:	74 06                	je     f012182b <merging+0x2c9>
f0121825:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121829:	75 17                	jne    f0121842 <merging+0x2e0>
f012182b:	83 ec 04             	sub    $0x4,%esp
f012182e:	68 e8 15 13 f0       	push   $0xf01315e8
f0121833:	68 94 01 00 00       	push   $0x194
f0121838:	68 75 15 13 f0       	push   $0xf0131575
f012183d:	e8 f7 ea fd ff       	call   f0100339 <_panic>
f0121842:	8b 45 08             	mov    0x8(%ebp),%eax
f0121845:	8b 10                	mov    (%eax),%edx
f0121847:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012184a:	89 10                	mov    %edx,(%eax)
f012184c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012184f:	8b 00                	mov    (%eax),%eax
f0121851:	85 c0                	test   %eax,%eax
f0121853:	74 0b                	je     f0121860 <merging+0x2fe>
f0121855:	8b 45 08             	mov    0x8(%ebp),%eax
f0121858:	8b 00                	mov    (%eax),%eax
f012185a:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012185d:	89 50 04             	mov    %edx,0x4(%eax)
f0121860:	8b 45 08             	mov    0x8(%ebp),%eax
f0121863:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121866:	89 10                	mov    %edx,(%eax)
f0121868:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012186b:	8b 55 08             	mov    0x8(%ebp),%edx
f012186e:	89 50 04             	mov    %edx,0x4(%eax)
f0121871:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121874:	8b 00                	mov    (%eax),%eax
f0121876:	85 c0                	test   %eax,%eax
f0121878:	75 08                	jne    f0121882 <merging+0x320>
f012187a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012187d:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121882:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121887:	40                   	inc    %eax
f0121888:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f012188d:	e9 ce 00 00 00       	jmp    f0121960 <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0121892:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121896:	74 65                	je     f01218fd <merging+0x39b>
f0121898:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012189c:	75 17                	jne    f01218b5 <merging+0x353>
f012189e:	83 ec 04             	sub    $0x4,%esp
f01218a1:	68 c4 15 13 f0       	push   $0xf01315c4
f01218a6:	68 95 01 00 00       	push   $0x195
f01218ab:	68 75 15 13 f0       	push   $0xf0131575
f01218b0:	e8 84 ea fd ff       	call   f0100339 <_panic>
f01218b5:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f01218bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218be:	89 50 04             	mov    %edx,0x4(%eax)
f01218c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218c4:	8b 40 04             	mov    0x4(%eax),%eax
f01218c7:	85 c0                	test   %eax,%eax
f01218c9:	74 0c                	je     f01218d7 <merging+0x375>
f01218cb:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f01218d0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01218d3:	89 10                	mov    %edx,(%eax)
f01218d5:	eb 08                	jmp    f01218df <merging+0x37d>
f01218d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218da:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f01218df:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218e2:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01218e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01218ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01218f0:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01218f5:	40                   	inc    %eax
f01218f6:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f01218fb:	eb 63                	jmp    f0121960 <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f01218fd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121901:	75 17                	jne    f012191a <merging+0x3b8>
f0121903:	83 ec 04             	sub    $0x4,%esp
f0121906:	68 90 15 13 f0       	push   $0xf0131590
f012190b:	68 98 01 00 00       	push   $0x198
f0121910:	68 75 15 13 f0       	push   $0xf0131575
f0121915:	e8 1f ea fd ff       	call   f0100339 <_panic>
f012191a:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0121920:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121923:	89 10                	mov    %edx,(%eax)
f0121925:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121928:	8b 00                	mov    (%eax),%eax
f012192a:	85 c0                	test   %eax,%eax
f012192c:	74 0d                	je     f012193b <merging+0x3d9>
f012192e:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121933:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121936:	89 50 04             	mov    %edx,0x4(%eax)
f0121939:	eb 08                	jmp    f0121943 <merging+0x3e1>
f012193b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012193e:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121943:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121946:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012194b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012194e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121955:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f012195a:	40                   	inc    %eax
f012195b:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
		}
		set_block_data(va, get_block_size(va), 0);
f0121960:	83 ec 0c             	sub    $0xc,%esp
f0121963:	ff 75 10             	pushl  0x10(%ebp)
f0121966:	e8 d6 ed ff ff       	call   f0120741 <get_block_size>
f012196b:	83 c4 10             	add    $0x10,%esp
f012196e:	83 ec 04             	sub    $0x4,%esp
f0121971:	6a 00                	push   $0x0
f0121973:	50                   	push   %eax
f0121974:	ff 75 10             	pushl  0x10(%ebp)
f0121977:	e8 16 f1 ff ff       	call   f0120a92 <set_block_data>
f012197c:	83 c4 10             	add    $0x10,%esp
	}
}
f012197f:	90                   	nop
f0121980:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121983:	c9                   	leave  
f0121984:	c3                   	ret    

f0121985 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121985:	55                   	push   %ebp
f0121986:	89 e5                	mov    %esp,%ebp
f0121988:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f012198b:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121990:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0121993:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0121998:	3b 45 08             	cmp    0x8(%ebp),%eax
f012199b:	73 1b                	jae    f01219b8 <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f012199d:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f01219a2:	83 ec 04             	sub    $0x4,%esp
f01219a5:	ff 75 08             	pushl  0x8(%ebp)
f01219a8:	6a 00                	push   $0x0
f01219aa:	50                   	push   %eax
f01219ab:	e8 b2 fb ff ff       	call   f0121562 <merging>
f01219b0:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01219b3:	e9 8b 00 00 00       	jmp    f0121a43 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01219b8:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f01219bd:	3b 45 08             	cmp    0x8(%ebp),%eax
f01219c0:	76 18                	jbe    f01219da <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f01219c2:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f01219c7:	83 ec 04             	sub    $0x4,%esp
f01219ca:	ff 75 08             	pushl  0x8(%ebp)
f01219cd:	50                   	push   %eax
f01219ce:	6a 00                	push   $0x0
f01219d0:	e8 8d fb ff ff       	call   f0121562 <merging>
f01219d5:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01219d8:	eb 69                	jmp    f0121a43 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01219da:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f01219df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01219e2:	eb 39                	jmp    f0121a1d <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f01219e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01219e7:	3b 45 08             	cmp    0x8(%ebp),%eax
f01219ea:	73 29                	jae    f0121a15 <free_block+0x90>
f01219ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01219ef:	8b 00                	mov    (%eax),%eax
f01219f1:	3b 45 08             	cmp    0x8(%ebp),%eax
f01219f4:	76 1f                	jbe    f0121a15 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f01219f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01219f9:	8b 00                	mov    (%eax),%eax
f01219fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f01219fe:	83 ec 04             	sub    $0x4,%esp
f0121a01:	ff 75 08             	pushl  0x8(%ebp)
f0121a04:	ff 75 f0             	pushl  -0x10(%ebp)
f0121a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0121a0a:	e8 53 fb ff ff       	call   f0121562 <merging>
f0121a0f:	83 c4 10             	add    $0x10,%esp
			break;
f0121a12:	90                   	nop
		}
	}
}
f0121a13:	eb 2e                	jmp    f0121a43 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121a15:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121a1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121a1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121a21:	74 07                	je     f0121a2a <free_block+0xa5>
f0121a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121a26:	8b 00                	mov    (%eax),%eax
f0121a28:	eb 05                	jmp    f0121a2f <free_block+0xaa>
f0121a2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0121a2f:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0121a34:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121a39:	85 c0                	test   %eax,%eax
f0121a3b:	75 a7                	jne    f01219e4 <free_block+0x5f>
f0121a3d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121a41:	75 a1                	jne    f01219e4 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121a43:	90                   	nop
f0121a44:	c9                   	leave  
f0121a45:	c3                   	ret    

f0121a46 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121a46:	55                   	push   %ebp
f0121a47:	89 e5                	mov    %esp,%ebp
f0121a49:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f0121a4c:	ff 75 08             	pushl  0x8(%ebp)
f0121a4f:	e8 ed ec ff ff       	call   f0120741 <get_block_size>
f0121a54:	83 c4 04             	add    $0x4,%esp
f0121a57:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f0121a5a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121a61:	eb 17                	jmp    f0121a7a <copy_data+0x34>
f0121a63:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121a66:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121a69:	01 c2                	add    %eax,%edx
f0121a6b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0121a6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a71:	01 c8                	add    %ecx,%eax
f0121a73:	8a 00                	mov    (%eax),%al
f0121a75:	88 02                	mov    %al,(%edx)
f0121a77:	ff 45 fc             	incl   -0x4(%ebp)
f0121a7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0121a7d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f0121a80:	72 e1                	jb     f0121a63 <copy_data+0x1d>
}
f0121a82:	90                   	nop
f0121a83:	c9                   	leave  
f0121a84:	c3                   	ret    

f0121a85 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121a85:	55                   	push   %ebp
f0121a86:	89 e5                	mov    %esp,%ebp
f0121a88:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f0121a8b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121a8f:	75 23                	jne    f0121ab4 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f0121a91:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121a95:	74 13                	je     f0121aaa <realloc_block_FF+0x25>
f0121a97:	83 ec 0c             	sub    $0xc,%esp
f0121a9a:	ff 75 0c             	pushl  0xc(%ebp)
f0121a9d:	e8 1f f0 ff ff       	call   f0120ac1 <alloc_block_FF>
f0121aa2:	83 c4 10             	add    $0x10,%esp
f0121aa5:	e9 f4 06 00 00       	jmp    f012219e <realloc_block_FF+0x719>
		return NULL;
f0121aaa:	b8 00 00 00 00       	mov    $0x0,%eax
f0121aaf:	e9 ea 06 00 00       	jmp    f012219e <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f0121ab4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121ab8:	75 18                	jne    f0121ad2 <realloc_block_FF+0x4d>
	{
		free_block(va);
f0121aba:	83 ec 0c             	sub    $0xc,%esp
f0121abd:	ff 75 08             	pushl  0x8(%ebp)
f0121ac0:	e8 c0 fe ff ff       	call   f0121985 <free_block>
f0121ac5:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0121ac8:	b8 00 00 00 00       	mov    $0x0,%eax
f0121acd:	e9 cc 06 00 00       	jmp    f012219e <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f0121ad2:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f0121ad6:	77 07                	ja     f0121adf <realloc_block_FF+0x5a>
f0121ad8:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f0121adf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ae2:	83 e0 01             	and    $0x1,%eax
f0121ae5:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f0121ae8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121aeb:	83 c0 08             	add    $0x8,%eax
f0121aee:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f0121af1:	83 ec 0c             	sub    $0xc,%esp
f0121af4:	ff 75 08             	pushl  0x8(%ebp)
f0121af7:	e8 45 ec ff ff       	call   f0120741 <get_block_size>
f0121afc:	83 c4 10             	add    $0x10,%esp
f0121aff:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121b02:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121b05:	83 e8 08             	sub    $0x8,%eax
f0121b08:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f0121b0b:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b0e:	83 e8 04             	sub    $0x4,%eax
f0121b11:	8b 00                	mov    (%eax),%eax
f0121b13:	83 e0 fe             	and    $0xfffffffe,%eax
f0121b16:	89 c2                	mov    %eax,%edx
f0121b18:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b1b:	01 d0                	add    %edx,%eax
f0121b1d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f0121b20:	83 ec 0c             	sub    $0xc,%esp
f0121b23:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121b26:	e8 16 ec ff ff       	call   f0120741 <get_block_size>
f0121b2b:	83 c4 10             	add    $0x10,%esp
f0121b2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f0121b31:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121b34:	83 e8 08             	sub    $0x8,%eax
f0121b37:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121b3a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121b3d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121b40:	75 08                	jne    f0121b4a <realloc_block_FF+0xc5>
	{
		 return va;
f0121b42:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b45:	e9 54 06 00 00       	jmp    f012219e <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f0121b4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121b4d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121b50:	0f 83 e5 03 00 00    	jae    f0121f3b <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121b56:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121b59:	2b 45 0c             	sub    0xc(%ebp),%eax
f0121b5c:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f0121b5f:	83 ec 0c             	sub    $0xc,%esp
f0121b62:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121b65:	e8 f0 eb ff ff       	call   f012075a <is_free_block>
f0121b6a:	83 c4 10             	add    $0x10,%esp
f0121b6d:	84 c0                	test   %al,%al
f0121b6f:	0f 84 3b 01 00 00    	je     f0121cb0 <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121b75:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121b78:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121b7b:	01 d0                	add    %edx,%eax
f0121b7d:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f0121b80:	83 ec 04             	sub    $0x4,%esp
f0121b83:	6a 01                	push   $0x1
f0121b85:	ff 75 f0             	pushl  -0x10(%ebp)
f0121b88:	ff 75 08             	pushl  0x8(%ebp)
f0121b8b:	e8 02 ef ff ff       	call   f0120a92 <set_block_data>
f0121b90:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121b93:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b96:	83 e8 04             	sub    $0x4,%eax
f0121b99:	8b 00                	mov    (%eax),%eax
f0121b9b:	83 e0 fe             	and    $0xfffffffe,%eax
f0121b9e:	89 c2                	mov    %eax,%edx
f0121ba0:	8b 45 08             	mov    0x8(%ebp),%eax
f0121ba3:	01 d0                	add    %edx,%eax
f0121ba5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121ba8:	83 ec 04             	sub    $0x4,%esp
f0121bab:	6a 00                	push   $0x0
f0121bad:	ff 75 cc             	pushl  -0x34(%ebp)
f0121bb0:	ff 75 c8             	pushl  -0x38(%ebp)
f0121bb3:	e8 da ee ff ff       	call   f0120a92 <set_block_data>
f0121bb8:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f0121bbb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121bbf:	74 06                	je     f0121bc7 <realloc_block_FF+0x142>
f0121bc1:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0121bc5:	75 17                	jne    f0121bde <realloc_block_FF+0x159>
f0121bc7:	83 ec 04             	sub    $0x4,%esp
f0121bca:	68 e8 15 13 f0       	push   $0xf01315e8
f0121bcf:	68 f6 01 00 00       	push   $0x1f6
f0121bd4:	68 75 15 13 f0       	push   $0xf0131575
f0121bd9:	e8 5b e7 fd ff       	call   f0100339 <_panic>
f0121bde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121be1:	8b 10                	mov    (%eax),%edx
f0121be3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121be6:	89 10                	mov    %edx,(%eax)
f0121be8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121beb:	8b 00                	mov    (%eax),%eax
f0121bed:	85 c0                	test   %eax,%eax
f0121bef:	74 0b                	je     f0121bfc <realloc_block_FF+0x177>
f0121bf1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bf4:	8b 00                	mov    (%eax),%eax
f0121bf6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121bf9:	89 50 04             	mov    %edx,0x4(%eax)
f0121bfc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121bff:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0121c02:	89 10                	mov    %edx,(%eax)
f0121c04:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121c07:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121c0a:	89 50 04             	mov    %edx,0x4(%eax)
f0121c0d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121c10:	8b 00                	mov    (%eax),%eax
f0121c12:	85 c0                	test   %eax,%eax
f0121c14:	75 08                	jne    f0121c1e <realloc_block_FF+0x199>
f0121c16:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121c19:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121c1e:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121c23:	40                   	inc    %eax
f0121c24:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121c29:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121c2d:	75 17                	jne    f0121c46 <realloc_block_FF+0x1c1>
f0121c2f:	83 ec 04             	sub    $0x4,%esp
f0121c32:	68 57 15 13 f0       	push   $0xf0131557
f0121c37:	68 f7 01 00 00       	push   $0x1f7
f0121c3c:	68 75 15 13 f0       	push   $0xf0131575
f0121c41:	e8 f3 e6 fd ff       	call   f0100339 <_panic>
f0121c46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c49:	8b 00                	mov    (%eax),%eax
f0121c4b:	85 c0                	test   %eax,%eax
f0121c4d:	74 10                	je     f0121c5f <realloc_block_FF+0x1da>
f0121c4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c52:	8b 00                	mov    (%eax),%eax
f0121c54:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121c57:	8b 52 04             	mov    0x4(%edx),%edx
f0121c5a:	89 50 04             	mov    %edx,0x4(%eax)
f0121c5d:	eb 0b                	jmp    f0121c6a <realloc_block_FF+0x1e5>
f0121c5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c62:	8b 40 04             	mov    0x4(%eax),%eax
f0121c65:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121c6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c6d:	8b 40 04             	mov    0x4(%eax),%eax
f0121c70:	85 c0                	test   %eax,%eax
f0121c72:	74 0f                	je     f0121c83 <realloc_block_FF+0x1fe>
f0121c74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c77:	8b 40 04             	mov    0x4(%eax),%eax
f0121c7a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121c7d:	8b 12                	mov    (%edx),%edx
f0121c7f:	89 10                	mov    %edx,(%eax)
f0121c81:	eb 0a                	jmp    f0121c8d <realloc_block_FF+0x208>
f0121c83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c86:	8b 00                	mov    (%eax),%eax
f0121c88:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121c8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121c96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121c99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121ca0:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121ca5:	48                   	dec    %eax
f0121ca6:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121cab:	e9 83 02 00 00       	jmp    f0121f33 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f0121cb0:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0121cb4:	0f 86 69 02 00 00    	jbe    f0121f23 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f0121cba:	83 ec 04             	sub    $0x4,%esp
f0121cbd:	6a 01                	push   $0x1
f0121cbf:	ff 75 f0             	pushl  -0x10(%ebp)
f0121cc2:	ff 75 08             	pushl  0x8(%ebp)
f0121cc5:	e8 c8 ed ff ff       	call   f0120a92 <set_block_data>
f0121cca:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121ccd:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cd0:	83 e8 04             	sub    $0x4,%eax
f0121cd3:	8b 00                	mov    (%eax),%eax
f0121cd5:	83 e0 fe             	and    $0xfffffffe,%eax
f0121cd8:	89 c2                	mov    %eax,%edx
f0121cda:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cdd:	01 d0                	add    %edx,%eax
f0121cdf:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f0121ce2:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121ce7:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f0121cea:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0121cee:	75 68                	jne    f0121d58 <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121cf0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121cf4:	75 17                	jne    f0121d0d <realloc_block_FF+0x288>
f0121cf6:	83 ec 04             	sub    $0x4,%esp
f0121cf9:	68 90 15 13 f0       	push   $0xf0131590
f0121cfe:	68 06 02 00 00       	push   $0x206
f0121d03:	68 75 15 13 f0       	push   $0xf0131575
f0121d08:	e8 2c e6 fd ff       	call   f0100339 <_panic>
f0121d0d:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0121d13:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d16:	89 10                	mov    %edx,(%eax)
f0121d18:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d1b:	8b 00                	mov    (%eax),%eax
f0121d1d:	85 c0                	test   %eax,%eax
f0121d1f:	74 0d                	je     f0121d2e <realloc_block_FF+0x2a9>
f0121d21:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121d26:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121d29:	89 50 04             	mov    %edx,0x4(%eax)
f0121d2c:	eb 08                	jmp    f0121d36 <realloc_block_FF+0x2b1>
f0121d2e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d31:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121d36:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d39:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121d3e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d41:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121d48:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121d4d:	40                   	inc    %eax
f0121d4e:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121d53:	e9 b0 01 00 00       	jmp    f0121f08 <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121d58:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121d5d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121d60:	76 68                	jbe    f0121dca <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121d62:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121d66:	75 17                	jne    f0121d7f <realloc_block_FF+0x2fa>
f0121d68:	83 ec 04             	sub    $0x4,%esp
f0121d6b:	68 90 15 13 f0       	push   $0xf0131590
f0121d70:	68 0b 02 00 00       	push   $0x20b
f0121d75:	68 75 15 13 f0       	push   $0xf0131575
f0121d7a:	e8 ba e5 fd ff       	call   f0100339 <_panic>
f0121d7f:	8b 15 10 17 6c f0    	mov    0xf06c1710,%edx
f0121d85:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d88:	89 10                	mov    %edx,(%eax)
f0121d8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121d8d:	8b 00                	mov    (%eax),%eax
f0121d8f:	85 c0                	test   %eax,%eax
f0121d91:	74 0d                	je     f0121da0 <realloc_block_FF+0x31b>
f0121d93:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121d98:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121d9b:	89 50 04             	mov    %edx,0x4(%eax)
f0121d9e:	eb 08                	jmp    f0121da8 <realloc_block_FF+0x323>
f0121da0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121da3:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121da8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dab:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121db0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121db3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121dba:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121dbf:	40                   	inc    %eax
f0121dc0:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121dc5:	e9 3e 01 00 00       	jmp    f0121f08 <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f0121dca:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121dcf:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121dd2:	73 68                	jae    f0121e3c <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121dd4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121dd8:	75 17                	jne    f0121df1 <realloc_block_FF+0x36c>
f0121dda:	83 ec 04             	sub    $0x4,%esp
f0121ddd:	68 c4 15 13 f0       	push   $0xf01315c4
f0121de2:	68 10 02 00 00       	push   $0x210
f0121de7:	68 75 15 13 f0       	push   $0xf0131575
f0121dec:	e8 48 e5 fd ff       	call   f0100339 <_panic>
f0121df1:	8b 15 14 17 6c f0    	mov    0xf06c1714,%edx
f0121df7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121dfa:	89 50 04             	mov    %edx,0x4(%eax)
f0121dfd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e00:	8b 40 04             	mov    0x4(%eax),%eax
f0121e03:	85 c0                	test   %eax,%eax
f0121e05:	74 0c                	je     f0121e13 <realloc_block_FF+0x38e>
f0121e07:	a1 14 17 6c f0       	mov    0xf06c1714,%eax
f0121e0c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121e0f:	89 10                	mov    %edx,(%eax)
f0121e11:	eb 08                	jmp    f0121e1b <realloc_block_FF+0x396>
f0121e13:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e16:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f0121e1b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e1e:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121e23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e26:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121e2c:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121e31:	40                   	inc    %eax
f0121e32:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
f0121e37:	e9 cc 00 00 00       	jmp    f0121f08 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f0121e3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121e43:	a1 10 17 6c f0       	mov    0xf06c1710,%eax
f0121e48:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121e4b:	e9 8a 00 00 00       	jmp    f0121eda <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f0121e50:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e53:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121e56:	73 7a                	jae    f0121ed2 <realloc_block_FF+0x44d>
f0121e58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e5b:	8b 00                	mov    (%eax),%eax
f0121e5d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121e60:	73 70                	jae    f0121ed2 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0121e62:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121e66:	74 06                	je     f0121e6e <realloc_block_FF+0x3e9>
f0121e68:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121e6c:	75 17                	jne    f0121e85 <realloc_block_FF+0x400>
f0121e6e:	83 ec 04             	sub    $0x4,%esp
f0121e71:	68 e8 15 13 f0       	push   $0xf01315e8
f0121e76:	68 1a 02 00 00       	push   $0x21a
f0121e7b:	68 75 15 13 f0       	push   $0xf0131575
f0121e80:	e8 b4 e4 fd ff       	call   f0100339 <_panic>
f0121e85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e88:	8b 10                	mov    (%eax),%edx
f0121e8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e8d:	89 10                	mov    %edx,(%eax)
f0121e8f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121e92:	8b 00                	mov    (%eax),%eax
f0121e94:	85 c0                	test   %eax,%eax
f0121e96:	74 0b                	je     f0121ea3 <realloc_block_FF+0x41e>
f0121e98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121e9b:	8b 00                	mov    (%eax),%eax
f0121e9d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121ea0:	89 50 04             	mov    %edx,0x4(%eax)
f0121ea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121ea6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121ea9:	89 10                	mov    %edx,(%eax)
f0121eab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121eae:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121eb1:	89 50 04             	mov    %edx,0x4(%eax)
f0121eb4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121eb7:	8b 00                	mov    (%eax),%eax
f0121eb9:	85 c0                	test   %eax,%eax
f0121ebb:	75 08                	jne    f0121ec5 <realloc_block_FF+0x440>
f0121ebd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121ec0:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121ec5:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0121eca:	40                   	inc    %eax
f0121ecb:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
							break;
f0121ed0:	eb 36                	jmp    f0121f08 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f0121ed2:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121ed7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121eda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121ede:	74 07                	je     f0121ee7 <realloc_block_FF+0x462>
f0121ee0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121ee3:	8b 00                	mov    (%eax),%eax
f0121ee5:	eb 05                	jmp    f0121eec <realloc_block_FF+0x467>
f0121ee7:	b8 00 00 00 00       	mov    $0x0,%eax
f0121eec:	a3 18 17 6c f0       	mov    %eax,0xf06c1718
f0121ef1:	a1 18 17 6c f0       	mov    0xf06c1718,%eax
f0121ef6:	85 c0                	test   %eax,%eax
f0121ef8:	0f 85 52 ff ff ff    	jne    f0121e50 <realloc_block_FF+0x3cb>
f0121efe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121f02:	0f 85 48 ff ff ff    	jne    f0121e50 <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f0121f08:	83 ec 04             	sub    $0x4,%esp
f0121f0b:	6a 00                	push   $0x0
f0121f0d:	ff 75 d8             	pushl  -0x28(%ebp)
f0121f10:	ff 75 d4             	pushl  -0x2c(%ebp)
f0121f13:	e8 7a eb ff ff       	call   f0120a92 <set_block_data>
f0121f18:	83 c4 10             	add    $0x10,%esp
				return va;
f0121f1b:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f1e:	e9 7b 02 00 00       	jmp    f012219e <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0121f23:	83 ec 0c             	sub    $0xc,%esp
f0121f26:	68 65 16 13 f0       	push   $0xf0131665
f0121f2b:	e8 5b f0 fd ff       	call   f0100f8b <cprintf>
f0121f30:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0121f33:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f36:	e9 63 02 00 00       	jmp    f012219e <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f0121f3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121f3e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0121f41:	0f 86 4d 02 00 00    	jbe    f0122194 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0121f47:	83 ec 0c             	sub    $0xc,%esp
f0121f4a:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121f4d:	e8 08 e8 ff ff       	call   f012075a <is_free_block>
f0121f52:	83 c4 10             	add    $0x10,%esp
f0121f55:	84 c0                	test   %al,%al
f0121f57:	0f 84 37 02 00 00    	je     f0122194 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f0121f5d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121f60:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121f63:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0121f66:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121f69:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0121f6c:	76 38                	jbe    f0121fa6 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f0121f6e:	83 ec 0c             	sub    $0xc,%esp
f0121f71:	ff 75 08             	pushl  0x8(%ebp)
f0121f74:	e8 0c fa ff ff       	call   f0121985 <free_block>
f0121f79:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f0121f7c:	83 ec 0c             	sub    $0xc,%esp
f0121f7f:	ff 75 0c             	pushl  0xc(%ebp)
f0121f82:	e8 3a eb ff ff       	call   f0120ac1 <alloc_block_FF>
f0121f87:	83 c4 10             	add    $0x10,%esp
f0121f8a:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f0121f8d:	83 ec 08             	sub    $0x8,%esp
f0121f90:	ff 75 c0             	pushl  -0x40(%ebp)
f0121f93:	ff 75 08             	pushl  0x8(%ebp)
f0121f96:	e8 ab fa ff ff       	call   f0121a46 <copy_data>
f0121f9b:	83 c4 10             	add    $0x10,%esp
				return new_va;
f0121f9e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0121fa1:	e9 f8 01 00 00       	jmp    f012219e <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0121fa6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121fa9:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f0121fac:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f0121faf:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f0121fb3:	0f 87 a0 00 00 00    	ja     f0122059 <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f0121fb9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121fbd:	75 17                	jne    f0121fd6 <realloc_block_FF+0x551>
f0121fbf:	83 ec 04             	sub    $0x4,%esp
f0121fc2:	68 57 15 13 f0       	push   $0xf0131557
f0121fc7:	68 38 02 00 00       	push   $0x238
f0121fcc:	68 75 15 13 f0       	push   $0xf0131575
f0121fd1:	e8 63 e3 fd ff       	call   f0100339 <_panic>
f0121fd6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fd9:	8b 00                	mov    (%eax),%eax
f0121fdb:	85 c0                	test   %eax,%eax
f0121fdd:	74 10                	je     f0121fef <realloc_block_FF+0x56a>
f0121fdf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121fe2:	8b 00                	mov    (%eax),%eax
f0121fe4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121fe7:	8b 52 04             	mov    0x4(%edx),%edx
f0121fea:	89 50 04             	mov    %edx,0x4(%eax)
f0121fed:	eb 0b                	jmp    f0121ffa <realloc_block_FF+0x575>
f0121fef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ff2:	8b 40 04             	mov    0x4(%eax),%eax
f0121ff5:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f0121ffa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121ffd:	8b 40 04             	mov    0x4(%eax),%eax
f0122000:	85 c0                	test   %eax,%eax
f0122002:	74 0f                	je     f0122013 <realloc_block_FF+0x58e>
f0122004:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122007:	8b 40 04             	mov    0x4(%eax),%eax
f012200a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012200d:	8b 12                	mov    (%edx),%edx
f012200f:	89 10                	mov    %edx,(%eax)
f0122011:	eb 0a                	jmp    f012201d <realloc_block_FF+0x598>
f0122013:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122016:	8b 00                	mov    (%eax),%eax
f0122018:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012201d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122020:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122026:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122029:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122030:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0122035:	48                   	dec    %eax
f0122036:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f012203b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012203e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0122041:	01 d0                	add    %edx,%eax
f0122043:	83 ec 04             	sub    $0x4,%esp
f0122046:	6a 01                	push   $0x1
f0122048:	50                   	push   %eax
f0122049:	ff 75 08             	pushl  0x8(%ebp)
f012204c:	e8 41 ea ff ff       	call   f0120a92 <set_block_data>
f0122051:	83 c4 10             	add    $0x10,%esp
f0122054:	e9 36 01 00 00       	jmp    f012218f <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0122059:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012205c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012205f:	01 d0                	add    %edx,%eax
f0122061:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0122064:	83 ec 04             	sub    $0x4,%esp
f0122067:	6a 01                	push   $0x1
f0122069:	ff 75 f0             	pushl  -0x10(%ebp)
f012206c:	ff 75 08             	pushl  0x8(%ebp)
f012206f:	e8 1e ea ff ff       	call   f0120a92 <set_block_data>
f0122074:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0122077:	8b 45 08             	mov    0x8(%ebp),%eax
f012207a:	83 e8 04             	sub    $0x4,%eax
f012207d:	8b 00                	mov    (%eax),%eax
f012207f:	83 e0 fe             	and    $0xfffffffe,%eax
f0122082:	89 c2                	mov    %eax,%edx
f0122084:	8b 45 08             	mov    0x8(%ebp),%eax
f0122087:	01 d0                	add    %edx,%eax
f0122089:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f012208c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0122090:	74 06                	je     f0122098 <realloc_block_FF+0x613>
f0122092:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0122096:	75 17                	jne    f01220af <realloc_block_FF+0x62a>
f0122098:	83 ec 04             	sub    $0x4,%esp
f012209b:	68 e8 15 13 f0       	push   $0xf01315e8
f01220a0:	68 44 02 00 00       	push   $0x244
f01220a5:	68 75 15 13 f0       	push   $0xf0131575
f01220aa:	e8 8a e2 fd ff       	call   f0100339 <_panic>
f01220af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220b2:	8b 10                	mov    (%eax),%edx
f01220b4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01220b7:	89 10                	mov    %edx,(%eax)
f01220b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01220bc:	8b 00                	mov    (%eax),%eax
f01220be:	85 c0                	test   %eax,%eax
f01220c0:	74 0b                	je     f01220cd <realloc_block_FF+0x648>
f01220c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220c5:	8b 00                	mov    (%eax),%eax
f01220c7:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01220ca:	89 50 04             	mov    %edx,0x4(%eax)
f01220cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01220d0:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01220d3:	89 10                	mov    %edx,(%eax)
f01220d5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01220d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01220db:	89 50 04             	mov    %edx,0x4(%eax)
f01220de:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01220e1:	8b 00                	mov    (%eax),%eax
f01220e3:	85 c0                	test   %eax,%eax
f01220e5:	75 08                	jne    f01220ef <realloc_block_FF+0x66a>
f01220e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01220ea:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f01220ef:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f01220f4:	40                   	inc    %eax
f01220f5:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f01220fa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01220fe:	75 17                	jne    f0122117 <realloc_block_FF+0x692>
f0122100:	83 ec 04             	sub    $0x4,%esp
f0122103:	68 57 15 13 f0       	push   $0xf0131557
f0122108:	68 45 02 00 00       	push   $0x245
f012210d:	68 75 15 13 f0       	push   $0xf0131575
f0122112:	e8 22 e2 fd ff       	call   f0100339 <_panic>
f0122117:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012211a:	8b 00                	mov    (%eax),%eax
f012211c:	85 c0                	test   %eax,%eax
f012211e:	74 10                	je     f0122130 <realloc_block_FF+0x6ab>
f0122120:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122123:	8b 00                	mov    (%eax),%eax
f0122125:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0122128:	8b 52 04             	mov    0x4(%edx),%edx
f012212b:	89 50 04             	mov    %edx,0x4(%eax)
f012212e:	eb 0b                	jmp    f012213b <realloc_block_FF+0x6b6>
f0122130:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122133:	8b 40 04             	mov    0x4(%eax),%eax
f0122136:	a3 14 17 6c f0       	mov    %eax,0xf06c1714
f012213b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012213e:	8b 40 04             	mov    0x4(%eax),%eax
f0122141:	85 c0                	test   %eax,%eax
f0122143:	74 0f                	je     f0122154 <realloc_block_FF+0x6cf>
f0122145:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122148:	8b 40 04             	mov    0x4(%eax),%eax
f012214b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012214e:	8b 12                	mov    (%edx),%edx
f0122150:	89 10                	mov    %edx,(%eax)
f0122152:	eb 0a                	jmp    f012215e <realloc_block_FF+0x6d9>
f0122154:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122157:	8b 00                	mov    (%eax),%eax
f0122159:	a3 10 17 6c f0       	mov    %eax,0xf06c1710
f012215e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0122161:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122167:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012216a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122171:	a1 1c 17 6c f0       	mov    0xf06c171c,%eax
f0122176:	48                   	dec    %eax
f0122177:	a3 1c 17 6c f0       	mov    %eax,0xf06c171c
				set_block_data(next_new_va, remaining_size, 0);
f012217c:	83 ec 04             	sub    $0x4,%esp
f012217f:	6a 00                	push   $0x0
f0122181:	ff 75 bc             	pushl  -0x44(%ebp)
f0122184:	ff 75 b8             	pushl  -0x48(%ebp)
f0122187:	e8 06 e9 ff ff       	call   f0120a92 <set_block_data>
f012218c:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f012218f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122192:	eb 0a                	jmp    f012219e <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0122194:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f012219b:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012219e:	c9                   	leave  
f012219f:	c3                   	ret    

f01221a0 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f01221a0:	55                   	push   %ebp
f01221a1:	89 e5                	mov    %esp,%ebp
f01221a3:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f01221a6:	83 ec 04             	sub    $0x4,%esp
f01221a9:	68 6c 16 13 f0       	push   $0xf013166c
f01221ae:	68 58 02 00 00       	push   $0x258
f01221b3:	68 75 15 13 f0       	push   $0xf0131575
f01221b8:	e8 7c e1 fd ff       	call   f0100339 <_panic>

f01221bd <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f01221bd:	55                   	push   %ebp
f01221be:	89 e5                	mov    %esp,%ebp
f01221c0:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f01221c3:	83 ec 04             	sub    $0x4,%esp
f01221c6:	68 94 16 13 f0       	push   $0xf0131694
f01221cb:	68 61 02 00 00       	push   $0x261
f01221d0:	68 75 15 13 f0       	push   $0xf0131575
f01221d5:	e8 5f e1 fd ff       	call   f0100339 <_panic>
f01221da:	66 90                	xchg   %ax,%ax

f01221dc <__moddi3>:
f01221dc:	55                   	push   %ebp
f01221dd:	57                   	push   %edi
f01221de:	56                   	push   %esi
f01221df:	53                   	push   %ebx
f01221e0:	83 ec 2c             	sub    $0x2c,%esp
f01221e3:	8b 74 24 40          	mov    0x40(%esp),%esi
f01221e7:	8b 7c 24 44          	mov    0x44(%esp),%edi
f01221eb:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f01221ef:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f01221f3:	89 d8                	mov    %ebx,%eax
f01221f5:	85 ff                	test   %edi,%edi
f01221f7:	0f 88 d3 00 00 00    	js     f01222d0 <__moddi3+0xf4>
f01221fd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0122204:	00 
f0122205:	85 c0                	test   %eax,%eax
f0122207:	0f 88 ab 00 00 00    	js     f01222b8 <__moddi3+0xdc>
f012220d:	89 0c 24             	mov    %ecx,(%esp)
f0122210:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0122214:	89 74 24 10          	mov    %esi,0x10(%esp)
f0122218:	89 fb                	mov    %edi,%ebx
f012221a:	8b 14 24             	mov    (%esp),%edx
f012221d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0122221:	89 d0                	mov    %edx,%eax
f0122223:	89 54 24 18          	mov    %edx,0x18(%esp)
f0122227:	89 ca                	mov    %ecx,%edx
f0122229:	8b 0c 24             	mov    (%esp),%ecx
f012222c:	89 34 24             	mov    %esi,(%esp)
f012222f:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0122233:	85 d2                	test   %edx,%edx
f0122235:	75 15                	jne    f012224c <__moddi3+0x70>
f0122237:	89 c7                	mov    %eax,%edi
f0122239:	39 d8                	cmp    %ebx,%eax
f012223b:	76 5b                	jbe    f0122298 <__moddi3+0xbc>
f012223d:	89 f0                	mov    %esi,%eax
f012223f:	89 da                	mov    %ebx,%edx
f0122241:	f7 f7                	div    %edi
f0122243:	89 d3                	mov    %edx,%ebx
f0122245:	89 d8                	mov    %ebx,%eax
f0122247:	31 d2                	xor    %edx,%edx
f0122249:	eb 09                	jmp    f0122254 <__moddi3+0x78>
f012224b:	90                   	nop
f012224c:	39 fa                	cmp    %edi,%edx
f012224e:	76 1c                	jbe    f012226c <__moddi3+0x90>
f0122250:	89 f0                	mov    %esi,%eax
f0122252:	89 fa                	mov    %edi,%edx
f0122254:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0122258:	85 c9                	test   %ecx,%ecx
f012225a:	74 07                	je     f0122263 <__moddi3+0x87>
f012225c:	f7 d8                	neg    %eax
f012225e:	83 d2 00             	adc    $0x0,%edx
f0122261:	f7 da                	neg    %edx
f0122263:	83 c4 2c             	add    $0x2c,%esp
f0122266:	5b                   	pop    %ebx
f0122267:	5e                   	pop    %esi
f0122268:	5f                   	pop    %edi
f0122269:	5d                   	pop    %ebp
f012226a:	c3                   	ret    
f012226b:	90                   	nop
f012226c:	0f bd c2             	bsr    %edx,%eax
f012226f:	83 f0 1f             	xor    $0x1f,%eax
f0122272:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0122276:	75 6c                	jne    f01222e4 <__moddi3+0x108>
f0122278:	39 fa                	cmp    %edi,%edx
f012227a:	72 05                	jb     f0122281 <__moddi3+0xa5>
f012227c:	3b 0c 24             	cmp    (%esp),%ecx
f012227f:	77 0e                	ja     f012228f <__moddi3+0xb3>
f0122281:	8b 34 24             	mov    (%esp),%esi
f0122284:	29 ce                	sub    %ecx,%esi
f0122286:	19 d3                	sbb    %edx,%ebx
f0122288:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f012228c:	89 34 24             	mov    %esi,(%esp)
f012228f:	8b 04 24             	mov    (%esp),%eax
f0122292:	8b 54 24 14          	mov    0x14(%esp),%edx
f0122296:	eb bc                	jmp    f0122254 <__moddi3+0x78>
f0122298:	85 c9                	test   %ecx,%ecx
f012229a:	75 0b                	jne    f01222a7 <__moddi3+0xcb>
f012229c:	b8 01 00 00 00       	mov    $0x1,%eax
f01222a1:	31 d2                	xor    %edx,%edx
f01222a3:	f7 f1                	div    %ecx
f01222a5:	89 c1                	mov    %eax,%ecx
f01222a7:	89 d8                	mov    %ebx,%eax
f01222a9:	31 d2                	xor    %edx,%edx
f01222ab:	f7 f1                	div    %ecx
f01222ad:	8b 04 24             	mov    (%esp),%eax
f01222b0:	f7 f1                	div    %ecx
f01222b2:	89 d3                	mov    %edx,%ebx
f01222b4:	eb 8f                	jmp    f0122245 <__moddi3+0x69>
f01222b6:	66 90                	xchg   %ax,%ax
f01222b8:	89 c8                	mov    %ecx,%eax
f01222ba:	89 da                	mov    %ebx,%edx
f01222bc:	f7 d8                	neg    %eax
f01222be:	83 d2 00             	adc    $0x0,%edx
f01222c1:	f7 da                	neg    %edx
f01222c3:	89 04 24             	mov    %eax,(%esp)
f01222c6:	89 54 24 04          	mov    %edx,0x4(%esp)
f01222ca:	e9 45 ff ff ff       	jmp    f0122214 <__moddi3+0x38>
f01222cf:	90                   	nop
f01222d0:	f7 de                	neg    %esi
f01222d2:	83 d7 00             	adc    $0x0,%edi
f01222d5:	f7 df                	neg    %edi
f01222d7:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f01222de:	ff 
f01222df:	e9 21 ff ff ff       	jmp    f0122205 <__moddi3+0x29>
f01222e4:	b8 20 00 00 00       	mov    $0x20,%eax
f01222e9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01222ed:	29 f8                	sub    %edi,%eax
f01222ef:	89 c6                	mov    %eax,%esi
f01222f1:	89 44 24 14          	mov    %eax,0x14(%esp)
f01222f5:	89 f9                	mov    %edi,%ecx
f01222f7:	d3 e2                	shl    %cl,%edx
f01222f9:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01222fd:	89 e8                	mov    %ebp,%eax
f01222ff:	89 f1                	mov    %esi,%ecx
f0122301:	d3 e8                	shr    %cl,%eax
f0122303:	09 d0                	or     %edx,%eax
f0122305:	89 04 24             	mov    %eax,(%esp)
f0122308:	89 ea                	mov    %ebp,%edx
f012230a:	89 f9                	mov    %edi,%ecx
f012230c:	d3 e2                	shl    %cl,%edx
f012230e:	89 d7                	mov    %edx,%edi
f0122310:	89 da                	mov    %ebx,%edx
f0122312:	d3 e2                	shl    %cl,%edx
f0122314:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0122318:	d3 e5                	shl    %cl,%ebp
f012231a:	8b 44 24 10          	mov    0x10(%esp),%eax
f012231e:	89 f1                	mov    %esi,%ecx
f0122320:	d3 e8                	shr    %cl,%eax
f0122322:	09 d0                	or     %edx,%eax
f0122324:	d3 eb                	shr    %cl,%ebx
f0122326:	89 da                	mov    %ebx,%edx
f0122328:	f7 34 24             	divl   (%esp)
f012232b:	89 d3                	mov    %edx,%ebx
f012232d:	f7 e7                	mul    %edi
f012232f:	89 c6                	mov    %eax,%esi
f0122331:	89 d1                	mov    %edx,%ecx
f0122333:	39 d3                	cmp    %edx,%ebx
f0122335:	72 29                	jb     f0122360 <__moddi3+0x184>
f0122337:	74 33                	je     f012236c <__moddi3+0x190>
f0122339:	89 e8                	mov    %ebp,%eax
f012233b:	29 f0                	sub    %esi,%eax
f012233d:	19 cb                	sbb    %ecx,%ebx
f012233f:	89 de                	mov    %ebx,%esi
f0122341:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0122345:	d3 e6                	shl    %cl,%esi
f0122347:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f012234b:	89 f9                	mov    %edi,%ecx
f012234d:	d3 e8                	shr    %cl,%eax
f012234f:	09 c6                	or     %eax,%esi
f0122351:	89 f0                	mov    %esi,%eax
f0122353:	89 f9                	mov    %edi,%ecx
f0122355:	d3 eb                	shr    %cl,%ebx
f0122357:	89 da                	mov    %ebx,%edx
f0122359:	e9 f6 fe ff ff       	jmp    f0122254 <__moddi3+0x78>
f012235e:	66 90                	xchg   %ax,%ax
f0122360:	29 f8                	sub    %edi,%eax
f0122362:	1b 14 24             	sbb    (%esp),%edx
f0122365:	89 d1                	mov    %edx,%ecx
f0122367:	89 c6                	mov    %eax,%esi
f0122369:	eb ce                	jmp    f0122339 <__moddi3+0x15d>
f012236b:	90                   	nop
f012236c:	39 c5                	cmp    %eax,%ebp
f012236e:	72 f0                	jb     f0122360 <__moddi3+0x184>
f0122370:	89 d9                	mov    %ebx,%ecx
f0122372:	eb c5                	jmp    f0122339 <__moddi3+0x15d>

f0122374 <__udivdi3>:
f0122374:	55                   	push   %ebp
f0122375:	57                   	push   %edi
f0122376:	56                   	push   %esi
f0122377:	53                   	push   %ebx
f0122378:	83 ec 1c             	sub    $0x1c,%esp
f012237b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f012237f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0122383:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0122387:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f012238b:	89 ca                	mov    %ecx,%edx
f012238d:	89 f8                	mov    %edi,%eax
f012238f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0122393:	85 f6                	test   %esi,%esi
f0122395:	75 2d                	jne    f01223c4 <__udivdi3+0x50>
f0122397:	39 cf                	cmp    %ecx,%edi
f0122399:	77 65                	ja     f0122400 <__udivdi3+0x8c>
f012239b:	89 fd                	mov    %edi,%ebp
f012239d:	85 ff                	test   %edi,%edi
f012239f:	75 0b                	jne    f01223ac <__udivdi3+0x38>
f01223a1:	b8 01 00 00 00       	mov    $0x1,%eax
f01223a6:	31 d2                	xor    %edx,%edx
f01223a8:	f7 f7                	div    %edi
f01223aa:	89 c5                	mov    %eax,%ebp
f01223ac:	31 d2                	xor    %edx,%edx
f01223ae:	89 c8                	mov    %ecx,%eax
f01223b0:	f7 f5                	div    %ebp
f01223b2:	89 c1                	mov    %eax,%ecx
f01223b4:	89 d8                	mov    %ebx,%eax
f01223b6:	f7 f5                	div    %ebp
f01223b8:	89 cf                	mov    %ecx,%edi
f01223ba:	89 fa                	mov    %edi,%edx
f01223bc:	83 c4 1c             	add    $0x1c,%esp
f01223bf:	5b                   	pop    %ebx
f01223c0:	5e                   	pop    %esi
f01223c1:	5f                   	pop    %edi
f01223c2:	5d                   	pop    %ebp
f01223c3:	c3                   	ret    
f01223c4:	39 ce                	cmp    %ecx,%esi
f01223c6:	77 28                	ja     f01223f0 <__udivdi3+0x7c>
f01223c8:	0f bd fe             	bsr    %esi,%edi
f01223cb:	83 f7 1f             	xor    $0x1f,%edi
f01223ce:	75 40                	jne    f0122410 <__udivdi3+0x9c>
f01223d0:	39 ce                	cmp    %ecx,%esi
f01223d2:	72 0a                	jb     f01223de <__udivdi3+0x6a>
f01223d4:	3b 44 24 08          	cmp    0x8(%esp),%eax
f01223d8:	0f 87 9e 00 00 00    	ja     f012247c <__udivdi3+0x108>
f01223de:	b8 01 00 00 00       	mov    $0x1,%eax
f01223e3:	89 fa                	mov    %edi,%edx
f01223e5:	83 c4 1c             	add    $0x1c,%esp
f01223e8:	5b                   	pop    %ebx
f01223e9:	5e                   	pop    %esi
f01223ea:	5f                   	pop    %edi
f01223eb:	5d                   	pop    %ebp
f01223ec:	c3                   	ret    
f01223ed:	8d 76 00             	lea    0x0(%esi),%esi
f01223f0:	31 ff                	xor    %edi,%edi
f01223f2:	31 c0                	xor    %eax,%eax
f01223f4:	89 fa                	mov    %edi,%edx
f01223f6:	83 c4 1c             	add    $0x1c,%esp
f01223f9:	5b                   	pop    %ebx
f01223fa:	5e                   	pop    %esi
f01223fb:	5f                   	pop    %edi
f01223fc:	5d                   	pop    %ebp
f01223fd:	c3                   	ret    
f01223fe:	66 90                	xchg   %ax,%ax
f0122400:	89 d8                	mov    %ebx,%eax
f0122402:	f7 f7                	div    %edi
f0122404:	31 ff                	xor    %edi,%edi
f0122406:	89 fa                	mov    %edi,%edx
f0122408:	83 c4 1c             	add    $0x1c,%esp
f012240b:	5b                   	pop    %ebx
f012240c:	5e                   	pop    %esi
f012240d:	5f                   	pop    %edi
f012240e:	5d                   	pop    %ebp
f012240f:	c3                   	ret    
f0122410:	bd 20 00 00 00       	mov    $0x20,%ebp
f0122415:	89 eb                	mov    %ebp,%ebx
f0122417:	29 fb                	sub    %edi,%ebx
f0122419:	89 f9                	mov    %edi,%ecx
f012241b:	d3 e6                	shl    %cl,%esi
f012241d:	89 c5                	mov    %eax,%ebp
f012241f:	88 d9                	mov    %bl,%cl
f0122421:	d3 ed                	shr    %cl,%ebp
f0122423:	89 e9                	mov    %ebp,%ecx
f0122425:	09 f1                	or     %esi,%ecx
f0122427:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f012242b:	89 f9                	mov    %edi,%ecx
f012242d:	d3 e0                	shl    %cl,%eax
f012242f:	89 c5                	mov    %eax,%ebp
f0122431:	89 d6                	mov    %edx,%esi
f0122433:	88 d9                	mov    %bl,%cl
f0122435:	d3 ee                	shr    %cl,%esi
f0122437:	89 f9                	mov    %edi,%ecx
f0122439:	d3 e2                	shl    %cl,%edx
f012243b:	8b 44 24 08          	mov    0x8(%esp),%eax
f012243f:	88 d9                	mov    %bl,%cl
f0122441:	d3 e8                	shr    %cl,%eax
f0122443:	09 c2                	or     %eax,%edx
f0122445:	89 d0                	mov    %edx,%eax
f0122447:	89 f2                	mov    %esi,%edx
f0122449:	f7 74 24 0c          	divl   0xc(%esp)
f012244d:	89 d6                	mov    %edx,%esi
f012244f:	89 c3                	mov    %eax,%ebx
f0122451:	f7 e5                	mul    %ebp
f0122453:	39 d6                	cmp    %edx,%esi
f0122455:	72 19                	jb     f0122470 <__udivdi3+0xfc>
f0122457:	74 0b                	je     f0122464 <__udivdi3+0xf0>
f0122459:	89 d8                	mov    %ebx,%eax
f012245b:	31 ff                	xor    %edi,%edi
f012245d:	e9 58 ff ff ff       	jmp    f01223ba <__udivdi3+0x46>
f0122462:	66 90                	xchg   %ax,%ax
f0122464:	8b 54 24 08          	mov    0x8(%esp),%edx
f0122468:	89 f9                	mov    %edi,%ecx
f012246a:	d3 e2                	shl    %cl,%edx
f012246c:	39 c2                	cmp    %eax,%edx
f012246e:	73 e9                	jae    f0122459 <__udivdi3+0xe5>
f0122470:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0122473:	31 ff                	xor    %edi,%edi
f0122475:	e9 40 ff ff ff       	jmp    f01223ba <__udivdi3+0x46>
f012247a:	66 90                	xchg   %ax,%ax
f012247c:	31 c0                	xor    %eax,%eax
f012247e:	e9 37 ff ff ff       	jmp    f01223ba <__udivdi3+0x46>
f0122483:	90                   	nop

f0122484 <__umoddi3>:
f0122484:	55                   	push   %ebp
f0122485:	57                   	push   %edi
f0122486:	56                   	push   %esi
f0122487:	53                   	push   %ebx
f0122488:	83 ec 1c             	sub    $0x1c,%esp
f012248b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f012248f:	8b 74 24 34          	mov    0x34(%esp),%esi
f0122493:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0122497:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f012249b:	89 44 24 0c          	mov    %eax,0xc(%esp)
f012249f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f01224a3:	89 f3                	mov    %esi,%ebx
f01224a5:	89 fa                	mov    %edi,%edx
f01224a7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f01224ab:	89 34 24             	mov    %esi,(%esp)
f01224ae:	85 c0                	test   %eax,%eax
f01224b0:	75 1a                	jne    f01224cc <__umoddi3+0x48>
f01224b2:	39 f7                	cmp    %esi,%edi
f01224b4:	0f 86 a2 00 00 00    	jbe    f012255c <__umoddi3+0xd8>
f01224ba:	89 c8                	mov    %ecx,%eax
f01224bc:	89 f2                	mov    %esi,%edx
f01224be:	f7 f7                	div    %edi
f01224c0:	89 d0                	mov    %edx,%eax
f01224c2:	31 d2                	xor    %edx,%edx
f01224c4:	83 c4 1c             	add    $0x1c,%esp
f01224c7:	5b                   	pop    %ebx
f01224c8:	5e                   	pop    %esi
f01224c9:	5f                   	pop    %edi
f01224ca:	5d                   	pop    %ebp
f01224cb:	c3                   	ret    
f01224cc:	39 f0                	cmp    %esi,%eax
f01224ce:	0f 87 ac 00 00 00    	ja     f0122580 <__umoddi3+0xfc>
f01224d4:	0f bd e8             	bsr    %eax,%ebp
f01224d7:	83 f5 1f             	xor    $0x1f,%ebp
f01224da:	0f 84 ac 00 00 00    	je     f012258c <__umoddi3+0x108>
f01224e0:	bf 20 00 00 00       	mov    $0x20,%edi
f01224e5:	29 ef                	sub    %ebp,%edi
f01224e7:	89 fe                	mov    %edi,%esi
f01224e9:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f01224ed:	89 e9                	mov    %ebp,%ecx
f01224ef:	d3 e0                	shl    %cl,%eax
f01224f1:	89 d7                	mov    %edx,%edi
f01224f3:	89 f1                	mov    %esi,%ecx
f01224f5:	d3 ef                	shr    %cl,%edi
f01224f7:	09 c7                	or     %eax,%edi
f01224f9:	89 e9                	mov    %ebp,%ecx
f01224fb:	d3 e2                	shl    %cl,%edx
f01224fd:	89 14 24             	mov    %edx,(%esp)
f0122500:	89 d8                	mov    %ebx,%eax
f0122502:	d3 e0                	shl    %cl,%eax
f0122504:	89 c2                	mov    %eax,%edx
f0122506:	8b 44 24 08          	mov    0x8(%esp),%eax
f012250a:	d3 e0                	shl    %cl,%eax
f012250c:	89 44 24 04          	mov    %eax,0x4(%esp)
f0122510:	8b 44 24 08          	mov    0x8(%esp),%eax
f0122514:	89 f1                	mov    %esi,%ecx
f0122516:	d3 e8                	shr    %cl,%eax
f0122518:	09 d0                	or     %edx,%eax
f012251a:	d3 eb                	shr    %cl,%ebx
f012251c:	89 da                	mov    %ebx,%edx
f012251e:	f7 f7                	div    %edi
f0122520:	89 d3                	mov    %edx,%ebx
f0122522:	f7 24 24             	mull   (%esp)
f0122525:	89 c6                	mov    %eax,%esi
f0122527:	89 d1                	mov    %edx,%ecx
f0122529:	39 d3                	cmp    %edx,%ebx
f012252b:	0f 82 87 00 00 00    	jb     f01225b8 <__umoddi3+0x134>
f0122531:	0f 84 91 00 00 00    	je     f01225c8 <__umoddi3+0x144>
f0122537:	8b 54 24 04          	mov    0x4(%esp),%edx
f012253b:	29 f2                	sub    %esi,%edx
f012253d:	19 cb                	sbb    %ecx,%ebx
f012253f:	89 d8                	mov    %ebx,%eax
f0122541:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0122545:	d3 e0                	shl    %cl,%eax
f0122547:	89 e9                	mov    %ebp,%ecx
f0122549:	d3 ea                	shr    %cl,%edx
f012254b:	09 d0                	or     %edx,%eax
f012254d:	89 e9                	mov    %ebp,%ecx
f012254f:	d3 eb                	shr    %cl,%ebx
f0122551:	89 da                	mov    %ebx,%edx
f0122553:	83 c4 1c             	add    $0x1c,%esp
f0122556:	5b                   	pop    %ebx
f0122557:	5e                   	pop    %esi
f0122558:	5f                   	pop    %edi
f0122559:	5d                   	pop    %ebp
f012255a:	c3                   	ret    
f012255b:	90                   	nop
f012255c:	89 fd                	mov    %edi,%ebp
f012255e:	85 ff                	test   %edi,%edi
f0122560:	75 0b                	jne    f012256d <__umoddi3+0xe9>
f0122562:	b8 01 00 00 00       	mov    $0x1,%eax
f0122567:	31 d2                	xor    %edx,%edx
f0122569:	f7 f7                	div    %edi
f012256b:	89 c5                	mov    %eax,%ebp
f012256d:	89 f0                	mov    %esi,%eax
f012256f:	31 d2                	xor    %edx,%edx
f0122571:	f7 f5                	div    %ebp
f0122573:	89 c8                	mov    %ecx,%eax
f0122575:	f7 f5                	div    %ebp
f0122577:	89 d0                	mov    %edx,%eax
f0122579:	e9 44 ff ff ff       	jmp    f01224c2 <__umoddi3+0x3e>
f012257e:	66 90                	xchg   %ax,%ax
f0122580:	89 c8                	mov    %ecx,%eax
f0122582:	89 f2                	mov    %esi,%edx
f0122584:	83 c4 1c             	add    $0x1c,%esp
f0122587:	5b                   	pop    %ebx
f0122588:	5e                   	pop    %esi
f0122589:	5f                   	pop    %edi
f012258a:	5d                   	pop    %ebp
f012258b:	c3                   	ret    
f012258c:	3b 04 24             	cmp    (%esp),%eax
f012258f:	72 06                	jb     f0122597 <__umoddi3+0x113>
f0122591:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0122595:	77 0f                	ja     f01225a6 <__umoddi3+0x122>
f0122597:	89 f2                	mov    %esi,%edx
f0122599:	29 f9                	sub    %edi,%ecx
f012259b:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f012259f:	89 14 24             	mov    %edx,(%esp)
f01225a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f01225a6:	8b 44 24 04          	mov    0x4(%esp),%eax
f01225aa:	8b 14 24             	mov    (%esp),%edx
f01225ad:	83 c4 1c             	add    $0x1c,%esp
f01225b0:	5b                   	pop    %ebx
f01225b1:	5e                   	pop    %esi
f01225b2:	5f                   	pop    %edi
f01225b3:	5d                   	pop    %ebp
f01225b4:	c3                   	ret    
f01225b5:	8d 76 00             	lea    0x0(%esi),%esi
f01225b8:	2b 04 24             	sub    (%esp),%eax
f01225bb:	19 fa                	sbb    %edi,%edx
f01225bd:	89 d1                	mov    %edx,%ecx
f01225bf:	89 c6                	mov    %eax,%esi
f01225c1:	e9 71 ff ff ff       	jmp    f0122537 <__umoddi3+0xb3>
f01225c6:	66 90                	xchg   %ax,%ax
f01225c8:	39 44 24 04          	cmp    %eax,0x4(%esp)
f01225cc:	72 ea                	jb     f01225b8 <__umoddi3+0x134>
f01225ce:	89 d9                	mov    %ebx,%ecx
f01225d0:	e9 62 ff ff ff       	jmp    f0122537 <__umoddi3+0xb3>
