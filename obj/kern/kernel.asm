
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 e0 17 00 	lgdtl  0x17e018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 e0 17 f0       	mov    $0xf017e000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 58 d8 6b f0 01 	movl   $0x1,0xf06bd858
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 a4 d7 6b f0 01 	movl   $0x1,0xf06bd7a4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba 90 84 b0 f0       	mov    $0xf0b08490,%edx
f010006a:	b8 64 45 69 f0       	mov    $0xf0694564,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 64 45 69 f0       	push   $0xf0694564
f010007e:	e8 2f f7 01 00       	call   f011f7b2 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 e0 1e 12 f0       	push   $0xf0121ee0
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 27 1f 12 f0       	push   $0xf0121f27
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 3b 1f 12 f0       	push   $0xf0121f3b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 4f 1f 12 f0       	push   $0xf0121f4f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 3c 70 00 00       	call   f0107116 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 5b 1f 12 f0       	push   $0xf0121f5b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 63 1f 12 f0       	push   $0xf0121f63
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 81 79 00 00       	call   f0107a83 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 22 75 00 00       	call   f0107629 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 c2 7c 00 00       	call   f0107dce <initialize_paging>
		sharing_init();
f010010c:	e8 33 89 00 00       	call   f0108a44 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 77 8e 00 00       	call   f0108f9f <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 4b ee 00 00       	call   f010ef7b <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 34 ef 00 00       	call   f010f078 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 0f ef 00 00       	call   f010f060 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 2f ef 00 00       	call   f010f090 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 a0 fb 01 00       	call   f011fd09 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 71 1f 12 f0       	push   $0xf0121f71
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 b6 a5 00 00       	call   f010a734 <env_init>
		ts_init();
f010017e:	e8 9a c7 00 00       	call   f010c91d <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 5b 1f 12 f0       	push   $0xf0121f5b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 84 1f 12 f0       	push   $0xf0121f84
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 5a 6c 00 00       	call   f0106e02 <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 ad 1f 12 f0       	push   $0xf0121fad
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 32 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 c3 1f 12 f0       	push   $0xf0121fc3
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 15 6e 00 00       	call   f0106ff4 <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 e0 1f 12 f0       	push   $0xf0121fe0
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 f8 6d 00 00       	call   f0106ff4 <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 ff 1f 12 f0       	push   $0xf0121fff
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 1c 20 12 f0       	push   $0xf012201c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 d4 49 00 00       	call   f0104bf8 <kclock_init>
		sched_init() ;
f0100224:	e8 04 65 00 00       	call   f010672d <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 40 20 12 f0       	push   $0xf0122040
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 e0 17 f0       	mov    $0xf017e000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 60 20 12 f0       	push   $0xf0122060
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 84 20 12 f0       	push   $0xf0122084
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 9c da 6b f0 00 	movl   $0x0,0xf06bda9c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 cc 20 12 f0       	push   $0xf01220cc
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 f8 20 12 f0       	push   $0xf01220f8
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 1d 21 12 f0       	push   $0xf012211d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 24 21 12 f0       	push   $0xf0122124
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 6c 21 12 f0       	push   $0xf012216c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 b4 21 12 f0       	push   $0xf01221b4
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 6c 21 12 f0       	push   $0xf012216c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 24 21 12 f0       	push   $0xf0122124
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 f9 21 12 f0       	push   $0xf01221f9
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 44 b0 00 00       	call   f010b388 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 80 45 69 f0       	mov    %eax,0xf0694580

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 00 22 12 f0       	push   $0xf0122200
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 25 22 12 f0       	push   $0xf0122225
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 a0 af 00 00       	call   f010b346 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 27 22 12 f0       	push   $0xf0122227
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 80 45 69 f0       	mov    %eax,0xf0694580

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 31 22 12 f0       	push   $0xf0122231
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 25 22 12 f0       	push   $0xf0122225
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 b2 6d 00 00       	call   f01071cf <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 ea 6c 00 00       	call   f010710c <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 eb 6d 00 00       	call   f0107221 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 94 60 00 00       	call   f01064d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 42 af 00 00       	call   f010b388 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 e7 ae 00 00       	call   f010b346 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 80 45 69 f0       	mov    %eax,0xf0694580

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 31 22 12 f0       	push   $0xf0122231
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 25 22 12 f0       	push   $0xf0122225
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 d0 ae 00 00       	call   f010b388 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 75 ae 00 00       	call   f010b346 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 4a 22 12 f0       	push   $0xf012224a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 25 22 12 f0       	push   $0xf0122225
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 a4 45 69 f0       	mov    0xf06945a4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 68 22 12 f0       	push   $0xf0122268
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 a4 45 69 f0       	mov    %eax,0xf06945a4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 ac d5 00 00       	call   f010dc21 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 a8 45 69 f0 b4 	movl   $0x3b4,0xf06945a8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 a8 45 69 f0 d4 	movl   $0x3d4,0xf06945a8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 ac 45 69 f0       	mov    %eax,0xf06945ac
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 ac 45 69 f0    	mov    0xf06945ac,%edx
f010087a:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		text_length = 0;
f01008a6:	c7 05 a0 45 69 f0 00 	movl   $0x0,0xf06945a0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d b0 45 69 f0 	mov    0xf06945b0,%cx
f01008b7:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d ac 45 69 f0    	mov    0xf06945ac,%ecx
f0100972:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 b0 45 69 f0 	mov    %dx,0xf06945b0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 a0 45 69 f0    	mov    0xf06945a0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 a0 45 69 f0       	mov    %eax,0xf06945a0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 ac 45 69 f0       	mov    0xf06945ac,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 ac 45 69 f0       	mov    0xf06945ac,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 f7 ed 01 00       	call   f011f7e2 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 ac 45 69 f0    	mov    0xf06945ac,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 b0 45 69 f0    	mov    %ax,0xf06945b0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 a8 45 69 f0    	mov    0xf06945a8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 a8 45 69 f0       	mov    0xf06945a8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 a8 45 69 f0    	mov    0xf06945a8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 e0 17 f0    	mov    -0xfe81fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 e0 17 f0    	mov    -0xfe81fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 e1 17 f0    	mov    -0xfe81ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 c8 47 69 f0       	mov    %eax,0xf06947c8

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 e5 17 f0 	mov    -0xfe81ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 a0 45 69 f0    	mov    0xf06945a0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 a0 45 69 f0       	mov    %eax,0xf06945a0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 b0 45 69 f0    	mov    0xf06945b0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 ac 45 69 f0    	mov    0xf06945ac,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 ac 45 69 f0       	mov    0xf06945ac,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 a0 45 69 f0       	mov    0xf06945a0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 c8 47 69 f0       	mov    0xf06947c8,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 7b 22 12 f0       	push   $0xf012227b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 0c cf 00 00       	call   f010dc21 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 c4 47 69 f0    	mov    %edx,0xf06947c4
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 c0 45 69 f0    	mov    %dl,-0xf96ba40(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 c4 47 69 f0 00 	movl   $0x0,0xf06947c4
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 c0 47 69 f0    	mov    0xf06947c0,%edx
f0100d7f:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 c0 47 69 f0    	mov    %edx,0xf06947c0
f0100d96:	8a 80 c0 45 69 f0    	mov    -0xf96ba40(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 c0 47 69 f0 00 	movl   $0x0,0xf06947c0
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 c0 47 69 f0    	mov    0xf06947c0,%edx
f0100dd0:	a1 c4 47 69 f0       	mov    0xf06947c4,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 c0 47 69 f0    	mov    %edx,0xf06947c0
f0100de7:	8a 80 c0 45 69 f0    	mov    -0xf96ba40(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 c0 47 69 f0       	mov    0xf06947c0,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 c0 47 69 f0 00 	movl   $0x0,0xf06947c0
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 a4 45 69 f0       	mov    0xf06945a4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 87 22 12 f0       	push   $0xf0122287
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 ff 3d 00 00       	call   f0104cba <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 c7 a4 00 00       	call   f010b388 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 a4 22 12 f0       	push   $0xf01222a4
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 cb 22 12 f0       	push   $0xf01222cb
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 b8 3d 00 00       	call   f0104cba <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 80 a4 00 00       	call   f010b388 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 e0 22 12 f0       	push   $0xf01222e0
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 cb 22 12 f0       	push   $0xf01222cb
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 7f df 01 00       	call   f011ef02 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 39 62 00 00       	call   f01071cf <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 6b 62 00 00       	call   f0107221 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 cc e5 01 00       	call   f011f5c4 <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 80 bb 6d f0       	push   $0xf06dbb80
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 cf e7 01 00       	call   f011f7e2 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 0a e5 01 00       	call   f011f5c4 <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 80 bb 6d f0       	push   $0xf06dbb80
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 0d e7 01 00       	call   f011f7e2 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 4a e6 01 00       	call   f011f7b2 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 0c 23 12 f0       	push   $0xf012230c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 0f 23 12 f0       	push   $0xf012230f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 60 db 6b f0       	push   $0xf06bdb60
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 ef e2 01 00       	call   f011f5c4 <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 04 e3 01 00       	call   f011f613 <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 a7 e2 01 00       	call   f011f5c4 <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 1f 23 12 f0       	push   $0xf012231f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 82 e8 01 00       	call   f011fbd9 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 24 23 12 f0       	push   $0xf0122324
f010137e:	50                   	push   %eax
f010137f:	e8 4c e3 01 00       	call   f011f6d0 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 28 23 12 f0       	push   $0xf0122328
f0101399:	50                   	push   %eax
f010139a:	e8 31 e3 01 00       	call   f011f6d0 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 2d 23 12 f0       	push   $0xf012232d
f01013b4:	50                   	push   %eax
f01013b5:	e8 16 e3 01 00       	call   f011f6d0 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 2d 23 12 f0       	push   $0xf012232d
f01013d5:	50                   	push   %eax
f01013d6:	e8 f5 e2 01 00       	call   f011f6d0 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 9d e1 01 00       	call   f011f5c4 <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 9f e1 01 00       	call   f011f613 <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 7e e1 01 00       	call   f011f613 <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 fb e0 01 00       	call   f011f5c4 <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 16 e2 01 00       	call   f011f708 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 4b e0 01 00       	call   f011f5c4 <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 16 e2 01 00       	call   f011f7b2 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 60 db 6b f0    	add    $0xf06bdb60,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 81 e0 01 00       	call   f011f641 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 c1 df 01 00       	call   f011f5c4 <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 ec 17 f0    	mov    0xf017ece0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 d9 e0 01 00       	call   f011f708 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 24 df 01 00       	call   f011f5c4 <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 c4 de 01 00       	call   f011f5c4 <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 8f e0 01 00       	call   f011f7b2 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 60 db 6b f0    	add    $0xf06bdb60,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 fa de 01 00       	call   f011f641 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 3c de 01 00       	call   f011f5c4 <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 57 df 01 00       	call   f011f708 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 a2 dd 01 00       	call   f011f5c4 <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 48 dd 01 00       	call   f011f5c4 <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 13 df 01 00       	call   f011f7b2 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 60 db 6b f0    	add    $0xf06bdb60,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 7e dd 01 00       	call   f011f641 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 ed 17 f0       	mov    0xf017edb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 60 db 6b f0       	push   $0xf06bdb60
f0101929:	e8 96 dc 01 00       	call   f011f5c4 <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 3d dc 01 00       	call   f011f5c4 <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 2a dc 01 00       	call   f011f5c4 <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 60 db 6b f0    	lea    -0xf9424a0(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 60 db 6b f0       	add    $0xf06bdb60,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 cf db 01 00       	call   f011f5c4 <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 60 6b 6d f0    	lea    -0xf9294a0(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 c4 db 01 00       	call   f011f7e2 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 60 b7 6d f0       	push   $0xf06db760
f0101c3a:	e8 a3 db 01 00       	call   f011f7e2 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 73 da 01 00       	call   f011f6d0 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 e5 17 f0       	mov    %eax,0xf017e530
f0101c6f:	a1 30 e5 17 f0       	mov    0xf017e530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 60 6b 6d f0       	add    $0xf06d6b60,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 55 db 01 00       	call   f011f7e2 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 9c da 6b f0       	mov    0xf06bda9c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 37 23 12 f0       	mov    $0xf0122337,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 37 27 12 f0       	mov    $0xf0122737,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 37 2b 12 f0       	mov    $0xf0122b37,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 9c da 6b f0 00 	movl   $0x0,0xf06bda9c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 18 da 6b f0 00 	movl   $0x0,0xf06bda18
f0101d59:	00 00 00 
f0101d5c:	c7 05 1c da 6b f0 00 	movl   $0x0,0xf06bda1c
f0101d63:	00 00 00 
f0101d66:	c7 05 24 da 6b f0 00 	movl   $0x0,0xf06bda24
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 2c da 01 00       	call   f011f7b2 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 31 23 12 f0       	push   $0xf0122331
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 36 98 00 00       	call   f010b615 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 28 53 00 00       	call   f010710c <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 40 db 6b f0       	mov    %eax,0xf06bdb40
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 40 db 6b f0       	mov    0xf06bdb40,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 40 db 6b f0    	mov    %edx,0xf06bdb40
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
f0101e98:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 40 db 6b f0       	mov    %eax,0xf06bdb40
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 40 db 6b f0       	mov    0xf06bdb40,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 40 db 6b f0    	mov    %edx,0xf06bdb40
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 60 bb 6d f0       	mov    %eax,0xf06dbb60
f0101ed4:	a1 60 bb 6d f0       	mov    0xf06dbb60,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 1f 23 12 f0       	push   $0xf012231f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 c3 dc 01 00       	call   f011fbd9 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 37 2f 12 f0       	push   $0xf0122f37
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 50 2f 12 f0       	push   $0xf0122f50
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 a1 2f 12 f0       	push   $0xf0122fa1
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 bc 2f 12 f0       	push   $0xf0122fbc
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 ec 2f 12 f0       	push   $0xf0122fec
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 a1 2f 12 f0       	push   $0xf0122fa1
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 16 30 12 f0       	push   $0xf0123016
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f010203b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 20 30 12 f0       	push   $0xf0123020
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 83 30 12 f0       	push   $0xf0123083
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 8c 30 12 f0       	push   $0xf012308c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f010218b:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 e5 17 f0       	add    $0xf017e548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
    struct Command * element = NULL;
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    LIST_FOREACH(element, &foundCommands)
f01021dd:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
    {
        LIST_REMOVE(&foundCommands,element);
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 94 30 12 f0       	push   $0xf0123094
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 a1 2f 12 f0       	push   $0xf0122fa1
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 1c da 6b f0       	mov    %eax,0xf06bda1c
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 18 da 6b f0       	mov    %eax,0xf06bda18
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 24 da 6b f0       	mov    %eax,0xf06bda24

// Youssef Mohsen , Youssef Ahmed
int process_command(int number_of_arguments, char** arguments)
{
    struct Command * element = NULL;
    LIST_FOREACH(element, &foundCommands)
f0102272:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f0102292:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 17 02 00 00       	jmp    f01024d3 <process_command+0x303>
    {
        if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 f2 d3 01 00       	call   f011f6d0 <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 f3 00 00 00    	jne    f01023dc <process_command+0x20c>
        {
            if(commands[i].num_of_args != number_of_arguments-1)
f01022e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022ec:	89 d0                	mov    %edx,%eax
f01022ee:	01 c0                	add    %eax,%eax
f01022f0:	01 d0                	add    %edx,%eax
f01022f2:	c1 e0 03             	shl    $0x3,%eax
f01022f5:	05 4c e5 17 f0       	add    $0xf017e54c,%eax
f01022fa:	8b 00                	mov    (%eax),%eax
f01022fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01022ff:	4a                   	dec    %edx
f0102300:	39 d0                	cmp    %edx,%eax
f0102302:	0f 84 cc 00 00 00    	je     f01023d4 <process_command+0x204>
            {
                if (commands[i].num_of_args == -1 && number_of_arguments-1 > 0)
f0102308:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010230b:	89 d0                	mov    %edx,%eax
f010230d:	01 c0                	add    %eax,%eax
f010230f:	01 d0                	add    %edx,%eax
f0102311:	c1 e0 03             	shl    $0x3,%eax
f0102314:	05 4c e5 17 f0       	add    $0xf017e54c,%eax
f0102319:	8b 00                	mov    (%eax),%eax
f010231b:	83 f8 ff             	cmp    $0xffffffff,%eax
f010231e:	75 10                	jne    f0102330 <process_command+0x160>
f0102320:	8b 45 08             	mov    0x8(%ebp),%eax
f0102323:	48                   	dec    %eax
f0102324:	85 c0                	test   %eax,%eax
f0102326:	7e 08                	jle    f0102330 <process_command+0x160>
                {
                    return i;
f0102328:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010232b:	e9 c5 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
                else
                {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f0102330:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102336:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102339:	89 c8                	mov    %ecx,%eax
f010233b:	01 c0                	add    %eax,%eax
f010233d:	01 c8                	add    %ecx,%eax
f010233f:	c1 e0 03             	shl    $0x3,%eax
f0102342:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102347:	89 10                	mov    %edx,(%eax)
f0102349:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234c:	89 d0                	mov    %edx,%eax
f010234e:	01 c0                	add    %eax,%eax
f0102350:	01 d0                	add    %edx,%eax
f0102352:	c1 e0 03             	shl    $0x3,%eax
f0102355:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f010235a:	8b 00                	mov    (%eax),%eax
f010235c:	85 c0                	test   %eax,%eax
f010235e:	74 1c                	je     f010237c <process_command+0x1ac>
f0102360:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102366:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102369:	89 c8                	mov    %ecx,%eax
f010236b:	01 c0                	add    %eax,%eax
f010236d:	01 c8                	add    %ecx,%eax
f010236f:	c1 e0 03             	shl    $0x3,%eax
f0102372:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0102377:	89 42 14             	mov    %eax,0x14(%edx)
f010237a:	eb 16                	jmp    f0102392 <process_command+0x1c2>
f010237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237f:	89 d0                	mov    %edx,%eax
f0102381:	01 c0                	add    %eax,%eax
f0102383:	01 d0                	add    %edx,%eax
f0102385:	c1 e0 03             	shl    $0x3,%eax
f0102388:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010238d:	a3 1c da 6b f0       	mov    %eax,0xf06bda1c
f0102392:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102395:	89 d0                	mov    %edx,%eax
f0102397:	01 c0                	add    %eax,%eax
f0102399:	01 d0                	add    %edx,%eax
f010239b:	c1 e0 03             	shl    $0x3,%eax
f010239e:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01023a3:	a3 18 da 6b f0       	mov    %eax,0xf06bda18
f01023a8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023ab:	89 d0                	mov    %edx,%eax
f01023ad:	01 c0                	add    %eax,%eax
f01023af:	01 d0                	add    %edx,%eax
f01023b1:	c1 e0 03             	shl    $0x3,%eax
f01023b4:	05 54 e5 17 f0       	add    $0xf017e554,%eax
f01023b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023bf:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f01023c4:	40                   	inc    %eax
f01023c5:	a3 24 da 6b f0       	mov    %eax,0xf06bda24
                return CMD_INV_NUM_ARGS;
f01023ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cf:	e9 21 01 00 00       	jmp    f01024f5 <process_command+0x325>
                }
            }
            else
            {
            return i;
f01023d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023d7:	e9 19 01 00 00       	jmp    f01024f5 <process_command+0x325>
            }
        }
        else
        {
            const char* ptr1 = arguments[0];
f01023dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023df:	8b 00                	mov    (%eax),%eax
f01023e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
            const char* ptr2 = commands[i].name;
f01023e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023e7:	89 d0                	mov    %edx,%eax
f01023e9:	01 c0                	add    %eax,%eax
f01023eb:	01 d0                	add    %edx,%eax
f01023ed:	c1 e0 03             	shl    $0x3,%eax
f01023f0:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01023f5:	8b 00                	mov    (%eax),%eax
f01023f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            while (*ptr1 != '\0' && *ptr2 != '\0')
f01023fa:	eb 14                	jmp    f0102410 <process_command+0x240>
            {
                if (*ptr1 == *ptr2)
f01023fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01023ff:	8a 10                	mov    (%eax),%dl
f0102401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102404:	8a 00                	mov    (%eax),%al
f0102406:	38 c2                	cmp    %al,%dl
f0102408:	75 03                	jne    f010240d <process_command+0x23d>
                {
                    ptr1++;
f010240a:	ff 45 e8             	incl   -0x18(%ebp)
                }
                ptr2++;
f010240d:	ff 45 e4             	incl   -0x1c(%ebp)
        }
        else
        {
            const char* ptr1 = arguments[0];
            const char* ptr2 = commands[i].name;
            while (*ptr1 != '\0' && *ptr2 != '\0')
f0102410:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102413:	8a 00                	mov    (%eax),%al
f0102415:	84 c0                	test   %al,%al
f0102417:	74 09                	je     f0102422 <process_command+0x252>
f0102419:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010241c:	8a 00                	mov    (%eax),%al
f010241e:	84 c0                	test   %al,%al
f0102420:	75 da                	jne    f01023fc <process_command+0x22c>
                {
                    ptr1++;
                }
                ptr2++;
            }
            if (*ptr1 == '\0')
f0102422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102425:	8a 00                	mov    (%eax),%al
f0102427:	84 c0                	test   %al,%al
f0102429:	0f 85 a1 00 00 00    	jne    f01024d0 <process_command+0x300>
            {
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
f010242f:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102435:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102438:	89 c8                	mov    %ecx,%eax
f010243a:	01 c0                	add    %eax,%eax
f010243c:	01 c8                	add    %ecx,%eax
f010243e:	c1 e0 03             	shl    $0x3,%eax
f0102441:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102446:	89 10                	mov    %edx,(%eax)
f0102448:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010244b:	89 d0                	mov    %edx,%eax
f010244d:	01 c0                	add    %eax,%eax
f010244f:	01 d0                	add    %edx,%eax
f0102451:	c1 e0 03             	shl    $0x3,%eax
f0102454:	05 50 e5 17 f0       	add    $0xf017e550,%eax
f0102459:	8b 00                	mov    (%eax),%eax
f010245b:	85 c0                	test   %eax,%eax
f010245d:	74 1c                	je     f010247b <process_command+0x2ab>
f010245f:	8b 15 18 da 6b f0    	mov    0xf06bda18,%edx
f0102465:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102468:	89 c8                	mov    %ecx,%eax
f010246a:	01 c0                	add    %eax,%eax
f010246c:	01 c8                	add    %ecx,%eax
f010246e:	c1 e0 03             	shl    $0x3,%eax
f0102471:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0102476:	89 42 14             	mov    %eax,0x14(%edx)
f0102479:	eb 16                	jmp    f0102491 <process_command+0x2c1>
f010247b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247e:	89 d0                	mov    %edx,%eax
f0102480:	01 c0                	add    %eax,%eax
f0102482:	01 d0                	add    %edx,%eax
f0102484:	c1 e0 03             	shl    $0x3,%eax
f0102487:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f010248c:	a3 1c da 6b f0       	mov    %eax,0xf06bda1c
f0102491:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102494:	89 d0                	mov    %edx,%eax
f0102496:	01 c0                	add    %eax,%eax
f0102498:	01 d0                	add    %edx,%eax
f010249a:	c1 e0 03             	shl    $0x3,%eax
f010249d:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01024a2:	a3 18 da 6b f0       	mov    %eax,0xf06bda18
f01024a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024aa:	89 d0                	mov    %edx,%eax
f01024ac:	01 c0                	add    %eax,%eax
f01024ae:	01 d0                	add    %edx,%eax
f01024b0:	c1 e0 03             	shl    $0x3,%eax
f01024b3:	05 54 e5 17 f0       	add    $0xf017e554,%eax
f01024b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024be:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f01024c3:	40                   	inc    %eax
f01024c4:	a3 24 da 6b f0       	mov    %eax,0xf06bda24
                x=1;
f01024c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    LIST_FOREACH(element, &foundCommands)
    {
        LIST_REMOVE(&foundCommands,element);
    }
    int x=0;
    for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024d0:	ff 45 ec             	incl   -0x14(%ebp)
f01024d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024d6:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01024db:	39 c2                	cmp    %eax,%edx
f01024dd:	0f 82 d9 fd ff ff    	jb     f01022bc <process_command+0xec>
                LIST_INSERT_HEAD(&foundCommands , &commands[i]);
                x=1;
            }
        }
    }
    if (x==1)
f01024e3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01024e7:	75 07                	jne    f01024f0 <process_command+0x320>
    {
        return CMD_MATCHED;
f01024e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01024ee:	eb 05                	jmp    f01024f5 <process_command+0x325>
    }
    return CMD_INVALID;
f01024f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f01024f5:	c9                   	leave  
f01024f6:	c3                   	ret    

f01024f7 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f01024f7:	55                   	push   %ebp
f01024f8:	89 e5                	mov    %esp,%ebp
f01024fa:	c7 05 58 d8 6b f0 00 	movl   $0x0,0xf06bd858
f0102501:	00 00 00 
f0102504:	90                   	nop
f0102505:	5d                   	pop    %ebp
f0102506:	c3                   	ret    

f0102507 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102507:	55                   	push   %ebp
f0102508:	89 e5                	mov    %esp,%ebp
f010250a:	c7 05 58 d8 6b f0 01 	movl   $0x1,0xf06bd858
f0102511:	00 00 00 
f0102514:	90                   	nop
f0102515:	5d                   	pop    %ebp
f0102516:	c3                   	ret    

f0102517 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102517:	55                   	push   %ebp
f0102518:	89 e5                	mov    %esp,%ebp
f010251a:	c7 05 58 d8 6b f0 02 	movl   $0x2,0xf06bd858
f0102521:	00 00 00 
f0102524:	90                   	nop
f0102525:	5d                   	pop    %ebp
f0102526:	c3                   	ret    

f0102527 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102527:	55                   	push   %ebp
f0102528:	89 e5                	mov    %esp,%ebp
f010252a:	c7 05 58 d8 6b f0 03 	movl   $0x3,0xf06bd858
f0102531:	00 00 00 
f0102534:	90                   	nop
f0102535:	5d                   	pop    %ebp
f0102536:	c3                   	ret    

f0102537 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102537:	55                   	push   %ebp
f0102538:	89 e5                	mov    %esp,%ebp
f010253a:	c7 05 58 d8 6b f0 04 	movl   $0x4,0xf06bd858
f0102541:	00 00 00 
f0102544:	90                   	nop
f0102545:	5d                   	pop    %ebp
f0102546:	c3                   	ret    

f0102547 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102547:	55                   	push   %ebp
f0102548:	89 e5                	mov    %esp,%ebp
f010254a:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010254f:	85 c0                	test   %eax,%eax
f0102551:	75 04                	jne    f0102557 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102553:	b0 01                	mov    $0x1,%al
f0102555:	eb 02                	jmp    f0102559 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102557:	b0 00                	mov    $0x0,%al
f0102559:	5d                   	pop    %ebp
f010255a:	c3                   	ret    

f010255b <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255b:	55                   	push   %ebp
f010255c:	89 e5                	mov    %esp,%ebp
f010255e:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0102563:	83 f8 01             	cmp    $0x1,%eax
f0102566:	75 04                	jne    f010256c <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102568:	b0 01                	mov    $0x1,%al
f010256a:	eb 02                	jmp    f010256e <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010256c:	b0 00                	mov    $0x0,%al
f010256e:	5d                   	pop    %ebp
f010256f:	c3                   	ret    

f0102570 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0102570:	55                   	push   %ebp
f0102571:	89 e5                	mov    %esp,%ebp
f0102573:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0102578:	83 f8 02             	cmp    $0x2,%eax
f010257b:	75 04                	jne    f0102581 <isKHeapPlacementStrategyBESTFIT+0x11>
f010257d:	b0 01                	mov    $0x1,%al
f010257f:	eb 02                	jmp    f0102583 <isKHeapPlacementStrategyBESTFIT+0x13>
f0102581:	b0 00                	mov    $0x0,%al
f0102583:	5d                   	pop    %ebp
f0102584:	c3                   	ret    

f0102585 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102585:	55                   	push   %ebp
f0102586:	89 e5                	mov    %esp,%ebp
f0102588:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010258d:	83 f8 03             	cmp    $0x3,%eax
f0102590:	75 04                	jne    f0102596 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0102592:	b0 01                	mov    $0x1,%al
f0102594:	eb 02                	jmp    f0102598 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102596:	b0 00                	mov    $0x0,%al
f0102598:	5d                   	pop    %ebp
f0102599:	c3                   	ret    

f010259a <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f010259a:	55                   	push   %ebp
f010259b:	89 e5                	mov    %esp,%ebp
f010259d:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f01025a2:	83 f8 04             	cmp    $0x4,%eax
f01025a5:	75 04                	jne    f01025ab <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025a7:	b0 01                	mov    $0x1,%al
f01025a9:	eb 02                	jmp    f01025ad <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025ab:	b0 00                	mov    $0x0,%al
f01025ad:	5d                   	pop    %ebp
f01025ae:	c3                   	ret    

f01025af <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025af:	55                   	push   %ebp
f01025b0:	89 e5                	mov    %esp,%ebp
f01025b2:	c7 05 a4 d7 6b f0 01 	movl   $0x1,0xf06bd7a4
f01025b9:	00 00 00 
f01025bc:	90                   	nop
f01025bd:	5d                   	pop    %ebp
f01025be:	c3                   	ret    

f01025bf <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025bf:	55                   	push   %ebp
f01025c0:	89 e5                	mov    %esp,%ebp
f01025c2:	c7 05 a4 d7 6b f0 02 	movl   $0x2,0xf06bd7a4
f01025c9:	00 00 00 
f01025cc:	90                   	nop
f01025cd:	5d                   	pop    %ebp
f01025ce:	c3                   	ret    

f01025cf <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025cf:	55                   	push   %ebp
f01025d0:	89 e5                	mov    %esp,%ebp
f01025d2:	c7 05 a4 d7 6b f0 03 	movl   $0x3,0xf06bd7a4
f01025d9:	00 00 00 
f01025dc:	90                   	nop
f01025dd:	5d                   	pop    %ebp
f01025de:	c3                   	ret    

f01025df <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01025df:	55                   	push   %ebp
f01025e0:	89 e5                	mov    %esp,%ebp
f01025e2:	c7 05 a4 d7 6b f0 04 	movl   $0x4,0xf06bd7a4
f01025e9:	00 00 00 
f01025ec:	90                   	nop
f01025ed:	5d                   	pop    %ebp
f01025ee:	c3                   	ret    

f01025ef <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01025ef:	55                   	push   %ebp
f01025f0:	89 e5                	mov    %esp,%ebp
f01025f2:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f01025f7:	83 f8 01             	cmp    $0x1,%eax
f01025fa:	75 04                	jne    f0102600 <isUHeapPlacementStrategyFIRSTFIT+0x11>
f01025fc:	b0 01                	mov    $0x1,%al
f01025fe:	eb 02                	jmp    f0102602 <isUHeapPlacementStrategyFIRSTFIT+0x13>
f0102600:	b0 00                	mov    $0x0,%al
f0102602:	5d                   	pop    %ebp
f0102603:	c3                   	ret    

f0102604 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102604:	55                   	push   %ebp
f0102605:	89 e5                	mov    %esp,%ebp
f0102607:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f010260c:	83 f8 02             	cmp    $0x2,%eax
f010260f:	75 04                	jne    f0102615 <isUHeapPlacementStrategyBESTFIT+0x11>
f0102611:	b0 01                	mov    $0x1,%al
f0102613:	eb 02                	jmp    f0102617 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102615:	b0 00                	mov    $0x0,%al
f0102617:	5d                   	pop    %ebp
f0102618:	c3                   	ret    

f0102619 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f0102621:	83 f8 03             	cmp    $0x3,%eax
f0102624:	75 04                	jne    f010262a <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102626:	b0 01                	mov    $0x1,%al
f0102628:	eb 02                	jmp    f010262c <isUHeapPlacementStrategyNEXTFIT+0x13>
f010262a:	b0 00                	mov    $0x0,%al
f010262c:	5d                   	pop    %ebp
f010262d:	c3                   	ret    

f010262e <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010262e:	55                   	push   %ebp
f010262f:	89 e5                	mov    %esp,%ebp
f0102631:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
f0102636:	83 f8 04             	cmp    $0x4,%eax
f0102639:	75 04                	jne    f010263f <isUHeapPlacementStrategyWORSTFIT+0x11>
f010263b:	b0 01                	mov    $0x1,%al
f010263d:	eb 02                	jmp    f0102641 <isUHeapPlacementStrategyWORSTFIT+0x13>
f010263f:	b0 00                	mov    $0x0,%al
f0102641:	5d                   	pop    %ebp
f0102642:	c3                   	ret    

f0102643 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102643:	55                   	push   %ebp
f0102644:	89 e5                	mov    %esp,%ebp
f0102646:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102649:	8b 45 08             	mov    0x8(%ebp),%eax
f010264c:	c1 e8 0c             	shr    $0xc,%eax
f010264f:	89 c2                	mov    %eax,%edx
f0102651:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0102656:	39 c2                	cmp    %eax,%edx
f0102658:	72 14                	jb     f010266e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010265a:	83 ec 04             	sub    $0x4,%esp
f010265d:	68 b4 30 12 f0       	push   $0xf01230b4
f0102662:	6a 56                	push   $0x56
f0102664:	68 dc 30 12 f0       	push   $0xf01230dc
f0102669:	e8 cb dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010266e:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0102674:	8b 45 08             	mov    0x8(%ebp),%eax
f0102677:	c1 e8 0c             	shr    $0xc,%eax
f010267a:	89 c1                	mov    %eax,%ecx
f010267c:	89 c8                	mov    %ecx,%eax
f010267e:	01 c0                	add    %eax,%eax
f0102680:	01 c8                	add    %ecx,%eax
f0102682:	c1 e0 03             	shl    $0x3,%eax
f0102685:	01 d0                	add    %edx,%eax
}
f0102687:	c9                   	leave  
f0102688:	c3                   	ret    

f0102689 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102689:	55                   	push   %ebp
f010268a:	89 e5                	mov    %esp,%ebp
f010268c:	53                   	push   %ebx
f010268d:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102697:	eb 3b                	jmp    f01026d4 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102699:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010269c:	89 d0                	mov    %edx,%eax
f010269e:	01 c0                	add    %eax,%eax
f01026a0:	01 d0                	add    %edx,%eax
f01026a2:	c1 e0 03             	shl    $0x3,%eax
f01026a5:	05 44 e5 17 f0       	add    $0xf017e544,%eax
f01026aa:	8b 10                	mov    (%eax),%edx
f01026ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026af:	89 c8                	mov    %ecx,%eax
f01026b1:	01 c0                	add    %eax,%eax
f01026b3:	01 c8                	add    %ecx,%eax
f01026b5:	c1 e0 03             	shl    $0x3,%eax
f01026b8:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f01026bd:	8b 00                	mov    (%eax),%eax
f01026bf:	83 ec 04             	sub    $0x4,%esp
f01026c2:	52                   	push   %edx
f01026c3:	50                   	push   %eax
f01026c4:	68 5f 39 12 f0       	push   $0xf012395f
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026d1:	ff 45 f4             	incl   -0xc(%ebp)
f01026d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d7:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f01026dc:	39 c2                	cmp    %eax,%edx
f01026de:	72 b9                	jb     f0102699 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01026e0:	83 ec 0c             	sub    $0xc,%esp
f01026e3:	68 68 39 12 f0       	push   $0xf0123968
f01026e8:	e8 9e e8 ff ff       	call   f0100f8b <cprintf>
f01026ed:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026f7:	eb 42                	jmp    f010273b <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f01026f9:	8b 0d e0 ec 17 f0    	mov    0xf017ece0,%ecx
f01026ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102702:	89 d0                	mov    %edx,%eax
f0102704:	01 c0                	add    %eax,%eax
f0102706:	01 d0                	add    %edx,%eax
f0102708:	c1 e0 02             	shl    $0x2,%eax
f010270b:	01 c8                	add    %ecx,%eax
f010270d:	8b 50 04             	mov    0x4(%eax),%edx
f0102710:	8b 1d e0 ec 17 f0    	mov    0xf017ece0,%ebx
f0102716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102719:	89 c8                	mov    %ecx,%eax
f010271b:	01 c0                	add    %eax,%eax
f010271d:	01 c8                	add    %ecx,%eax
f010271f:	c1 e0 02             	shl    $0x2,%eax
f0102722:	01 d8                	add    %ebx,%eax
f0102724:	8b 00                	mov    (%eax),%eax
f0102726:	83 ec 04             	sub    $0x4,%esp
f0102729:	52                   	push   %edx
f010272a:	50                   	push   %eax
f010272b:	68 7d 39 12 f0       	push   $0xf012397d
f0102730:	e8 56 e8 ff ff       	call   f0100f8b <cprintf>
f0102735:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102738:	ff 45 f4             	incl   -0xc(%ebp)
f010273b:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f0102740:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102743:	7c b4                	jl     f01026f9 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010274a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010274d:	c9                   	leave  
f010274e:	c3                   	ret    

f010274f <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010274f:	55                   	push   %ebp
f0102750:	89 e5                	mov    %esp,%ebp
f0102752:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102755:	83 ec 0c             	sub    $0xc,%esp
f0102758:	68 99 39 12 f0       	push   $0xf0123999
f010275d:	e8 29 e8 ff ff       	call   f0100f8b <cprintf>
f0102762:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102765:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f010276a:	83 ec 04             	sub    $0x4,%esp
f010276d:	50                   	push   %eax
f010276e:	68 0c 00 10 f0       	push   $0xf010000c
f0102773:	68 b4 39 12 f0       	push   $0xf01239b4
f0102778:	e8 0e e8 ff ff       	call   f0100f8b <cprintf>
f010277d:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102780:	b8 c1 1e 12 00       	mov    $0x121ec1,%eax
f0102785:	83 ec 04             	sub    $0x4,%esp
f0102788:	50                   	push   %eax
f0102789:	68 c1 1e 12 f0       	push   $0xf0121ec1
f010278e:	68 f0 39 12 f0       	push   $0xf01239f0
f0102793:	e8 f3 e7 ff ff       	call   f0100f8b <cprintf>
f0102798:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f010279b:	b8 64 45 69 00       	mov    $0x694564,%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	50                   	push   %eax
f01027a4:	68 64 45 69 f0       	push   $0xf0694564
f01027a9:	68 2c 3a 12 f0       	push   $0xf0123a2c
f01027ae:	e8 d8 e7 ff ff       	call   f0100f8b <cprintf>
f01027b3:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027b6:	b8 90 84 b0 00       	mov    $0xb08490,%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	50                   	push   %eax
f01027bf:	68 90 84 b0 f0       	push   $0xf0b08490
f01027c4:	68 74 3a 12 f0       	push   $0xf0123a74
f01027c9:	e8 bd e7 ff ff       	call   f0100f8b <cprintf>
f01027ce:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01027d1:	b8 90 84 b0 f0       	mov    $0xf0b08490,%eax
f01027d6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01027dc:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01027e1:	29 c2                	sub    %eax,%edx
f01027e3:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01027e5:	85 c0                	test   %eax,%eax
f01027e7:	79 05                	jns    f01027ee <command_kernel_info+0x9f>
f01027e9:	05 ff 03 00 00       	add    $0x3ff,%eax
f01027ee:	c1 f8 0a             	sar    $0xa,%eax
f01027f1:	83 ec 08             	sub    $0x8,%esp
f01027f4:	50                   	push   %eax
f01027f5:	68 b0 3a 12 f0       	push   $0xf0123ab0
f01027fa:	e8 8c e7 ff ff       	call   f0100f8b <cprintf>
f01027ff:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102802:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102807:	c9                   	leave  
f0102808:	c3                   	ret    

f0102809 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102809:	55                   	push   %ebp
f010280a:	89 e5                	mov    %esp,%ebp
f010280c:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102813:	75 37                	jne    f010284c <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102818:	83 c0 04             	add    $0x4,%eax
f010281b:	8b 00                	mov    (%eax),%eax
f010281d:	83 ec 04             	sub    $0x4,%esp
f0102820:	6a 10                	push   $0x10
f0102822:	6a 00                	push   $0x0
f0102824:	50                   	push   %eax
f0102825:	e8 fa d0 01 00       	call   f011f924 <strtol>
f010282a:	83 c4 10             	add    $0x10,%esp
f010282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102830:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102833:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102836:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102839:	83 c0 08             	add    $0x8,%eax
f010283c:	8b 00                	mov    (%eax),%eax
f010283e:	8a 00                	mov    (%eax),%al
f0102840:	88 c2                	mov    %al,%dl
f0102842:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102845:	88 10                	mov    %dl,(%eax)
f0102847:	e9 b9 00 00 00       	jmp    f0102905 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284c:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102850:	0f 85 9f 00 00 00    	jne    f01028f5 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102859:	83 c0 04             	add    $0x4,%eax
f010285c:	8b 00                	mov    (%eax),%eax
f010285e:	83 ec 04             	sub    $0x4,%esp
f0102861:	6a 0a                	push   $0xa
f0102863:	6a 00                	push   $0x0
f0102865:	50                   	push   %eax
f0102866:	e8 b9 d0 01 00       	call   f011f924 <strtol>
f010286b:	83 c4 10             	add    $0x10,%esp
f010286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102871:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102878:	83 ec 04             	sub    $0x4,%esp
f010287b:	6a 00                	push   $0x0
f010287d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102880:	50                   	push   %eax
f0102881:	ff 75 f4             	pushl  -0xc(%ebp)
f0102884:	e8 4f 8b 00 00       	call   f010b3d8 <envid2env>
f0102889:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288f:	83 c0 08             	add    $0x8,%eax
f0102892:	8b 00                	mov    (%eax),%eax
f0102894:	83 ec 04             	sub    $0x4,%esp
f0102897:	6a 10                	push   $0x10
f0102899:	6a 00                	push   $0x0
f010289b:	50                   	push   %eax
f010289c:	e8 83 d0 01 00       	call   f011f924 <strtol>
f01028a1:	83 c4 10             	add    $0x10,%esp
f01028a4:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028aa:	85 c0                	test   %eax,%eax
f01028ac:	75 07                	jne    f01028b5 <command_writeusermem+0xac>
f01028ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b3:	eb 55                	jmp    f010290a <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b5:	0f 20 d8             	mov    %cr3,%eax
f01028b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c4:	8b 40 68             	mov    0x68(%eax),%eax
f01028c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cd:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d9:	83 c0 0c             	add    $0xc,%eax
f01028dc:	8b 00                	mov    (%eax),%eax
f01028de:	8a 00                	mov    (%eax),%al
f01028e0:	88 c2                	mov    %al,%dl
f01028e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e5:	88 10                	mov    %dl,(%eax)
f01028e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028f0:	0f 22 d8             	mov    %eax,%cr3
f01028f3:	eb 10                	jmp    f0102905 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f5:	83 ec 0c             	sub    $0xc,%esp
f01028f8:	68 dc 3a 12 f0       	push   $0xf0123adc
f01028fd:	e8 89 e6 ff ff       	call   f0100f8b <cprintf>
f0102902:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102905:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290a:	c9                   	leave  
f010290b:	c3                   	ret    

f010290c <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290c:	55                   	push   %ebp
f010290d:	89 e5                	mov    %esp,%ebp
f010290f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102912:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102915:	83 c0 04             	add    $0x4,%eax
f0102918:	8b 00                	mov    (%eax),%eax
f010291a:	83 ec 04             	sub    $0x4,%esp
f010291d:	6a 10                	push   $0x10
f010291f:	6a 00                	push   $0x0
f0102921:	50                   	push   %eax
f0102922:	e8 fd cf 01 00       	call   f011f924 <strtol>
f0102927:	83 c4 10             	add    $0x10,%esp
f010292a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102932:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102939:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293c:	83 c0 08             	add    $0x8,%eax
f010293f:	8b 00                	mov    (%eax),%eax
f0102941:	83 ec 0c             	sub    $0xc,%esp
f0102944:	50                   	push   %eax
f0102945:	e8 7a cc 01 00       	call   f011f5c4 <strlen>
f010294a:	83 c4 10             	add    $0x10,%esp
f010294d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102950:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102957:	eb 1c                	jmp    f0102975 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102959:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295c:	83 c0 08             	add    $0x8,%eax
f010295f:	8b 10                	mov    (%eax),%edx
f0102961:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102964:	01 d0                	add    %edx,%eax
f0102966:	8a 00                	mov    (%eax),%al
f0102968:	88 c2                	mov    %al,%dl
f010296a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296d:	88 10                	mov    %dl,(%eax)
		address++;
f010296f:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102972:	ff 45 f0             	incl   -0x10(%ebp)
f0102975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102978:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297b:	7c dc                	jl     f0102959 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297d:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102982:	c9                   	leave  
f0102983:	c3                   	ret    

f0102984 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102984:	55                   	push   %ebp
f0102985:	89 e5                	mov    %esp,%ebp
f0102987:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010298a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298e:	75 42                	jne    f01029d2 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 04             	add    $0x4,%eax
f0102996:	8b 00                	mov    (%eax),%eax
f0102998:	83 ec 04             	sub    $0x4,%esp
f010299b:	6a 10                	push   $0x10
f010299d:	6a 00                	push   $0x0
f010299f:	50                   	push   %eax
f01029a0:	e8 7f cf 01 00       	call   f011f924 <strtol>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029ab:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b4:	8a 00                	mov    (%eax),%al
f01029b6:	0f b6 c0             	movzbl %al,%eax
f01029b9:	83 ec 04             	sub    $0x4,%esp
f01029bc:	50                   	push   %eax
f01029bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01029c0:	68 06 3b 12 f0       	push   $0xf0123b06
f01029c5:	e8 c1 e5 ff ff       	call   f0100f8b <cprintf>
f01029ca:	83 c4 10             	add    $0x10,%esp
f01029cd:	e9 c4 00 00 00       	jmp    f0102a96 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d6:	0f 85 aa 00 00 00    	jne    f0102a86 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029df:	83 c0 04             	add    $0x4,%eax
f01029e2:	8b 00                	mov    (%eax),%eax
f01029e4:	83 ec 04             	sub    $0x4,%esp
f01029e7:	6a 0a                	push   $0xa
f01029e9:	6a 00                	push   $0x0
f01029eb:	50                   	push   %eax
f01029ec:	e8 33 cf 01 00       	call   f011f924 <strtol>
f01029f1:	83 c4 10             	add    $0x10,%esp
f01029f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fe:	83 ec 04             	sub    $0x4,%esp
f0102a01:	6a 00                	push   $0x0
f0102a03:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a06:	50                   	push   %eax
f0102a07:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a0a:	e8 c9 89 00 00       	call   f010b3d8 <envid2env>
f0102a0f:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a15:	83 c0 08             	add    $0x8,%eax
f0102a18:	8b 00                	mov    (%eax),%eax
f0102a1a:	83 ec 04             	sub    $0x4,%esp
f0102a1d:	6a 10                	push   $0x10
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 fd ce 01 00       	call   f011f924 <strtol>
f0102a27:	83 c4 10             	add    $0x10,%esp
f0102a2a:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a30:	85 c0                	test   %eax,%eax
f0102a32:	75 07                	jne    f0102a3b <command_readusermem+0xb7>
f0102a34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a39:	eb 60                	jmp    f0102a9b <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3b:	0f 20 d8             	mov    %cr3,%eax
f0102a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a41:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a4a:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4d:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a53:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a56:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a59:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5f:	8a 00                	mov    (%eax),%al
f0102a61:	0f b6 c0             	movzbl %al,%eax
f0102a64:	83 ec 04             	sub    $0x4,%esp
f0102a67:	50                   	push   %eax
f0102a68:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6b:	68 06 3b 12 f0       	push   $0xf0123b06
f0102a70:	e8 16 e5 ff ff       	call   f0100f8b <cprintf>
f0102a75:	83 c4 10             	add    $0x10,%esp
f0102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a81:	0f 22 d8             	mov    %eax,%cr3
f0102a84:	eb 10                	jmp    f0102a96 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a86:	83 ec 0c             	sub    $0xc,%esp
f0102a89:	68 20 3b 12 f0       	push   $0xf0123b20
f0102a8e:	e8 f8 e4 ff ff       	call   f0100f8b <cprintf>
f0102a93:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a96:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9b:	c9                   	leave  
f0102a9c:	c3                   	ret    

f0102a9d <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9d:	55                   	push   %ebp
f0102a9e:	89 e5                	mov    %esp,%ebp
f0102aa0:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa6:	83 c0 04             	add    $0x4,%eax
f0102aa9:	8b 00                	mov    (%eax),%eax
f0102aab:	83 ec 04             	sub    $0x4,%esp
f0102aae:	6a 10                	push   $0x10
f0102ab0:	6a 00                	push   $0x0
f0102ab2:	50                   	push   %eax
f0102ab3:	e8 6c ce 01 00       	call   f011f924 <strtol>
f0102ab8:	83 c4 10             	add    $0x10,%esp
f0102abb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acd:	8a 00                	mov    (%eax),%al
f0102acf:	0f b6 c0             	movzbl %al,%eax
f0102ad2:	83 ec 08             	sub    $0x8,%esp
f0102ad5:	50                   	push   %eax
f0102ad6:	68 4a 3b 12 f0       	push   $0xf0123b4a
f0102adb:	e8 ab e4 ff ff       	call   f0100f8b <cprintf>
f0102ae0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae3:	83 ec 0c             	sub    $0xc,%esp
f0102ae6:	68 4d 3b 12 f0       	push   $0xf0123b4d
f0102aeb:	e8 9b e4 ff ff       	call   f0100f8b <cprintf>
f0102af0:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af8:	c9                   	leave  
f0102af9:	c3                   	ret    

f0102afa <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102afa:	55                   	push   %ebp
f0102afb:	89 e5                	mov    %esp,%ebp
f0102afd:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b00:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b03:	83 c0 04             	add    $0x4,%eax
f0102b06:	8b 00                	mov    (%eax),%eax
f0102b08:	83 ec 04             	sub    $0x4,%esp
f0102b0b:	6a 0a                	push   $0xa
f0102b0d:	6a 00                	push   $0x0
f0102b0f:	50                   	push   %eax
f0102b10:	e8 0f ce 01 00       	call   f011f924 <strtol>
f0102b15:	83 c4 10             	add    $0x10,%esp
f0102b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b22:	83 ec 04             	sub    $0x4,%esp
f0102b25:	6a 00                	push   $0x0
f0102b27:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b2a:	50                   	push   %eax
f0102b2b:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2e:	e8 a5 88 00 00       	call   f010b3d8 <envid2env>
f0102b33:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b36:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b39:	83 c0 08             	add    $0x8,%eax
f0102b3c:	8b 00                	mov    (%eax),%eax
f0102b3e:	83 ec 04             	sub    $0x4,%esp
f0102b41:	6a 10                	push   $0x10
f0102b43:	6a 00                	push   $0x0
f0102b45:	50                   	push   %eax
f0102b46:	e8 d9 cd 01 00       	call   f011f924 <strtol>
f0102b4b:	83 c4 10             	add    $0x10,%esp
f0102b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b54:	83 c0 0c             	add    $0xc,%eax
f0102b57:	8b 00                	mov    (%eax),%eax
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 0a                	push   $0xa
f0102b5e:	6a 00                	push   $0x0
f0102b60:	50                   	push   %eax
f0102b61:	e8 be cd 01 00       	call   f011f924 <strtol>
f0102b66:	83 c4 10             	add    $0x10,%esp
f0102b69:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b72:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b75:	85 c0                	test   %eax,%eax
f0102b77:	75 07                	jne    f0102b80 <command_readuserblock+0x86>
f0102b79:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7e:	eb 65                	jmp    f0102be5 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b80:	0f 20 d8             	mov    %cr3,%eax
f0102b83:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b86:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b89:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8f:	8b 40 68             	mov    0x68(%eax),%eax
f0102b92:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b98:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba2:	eb 28                	jmp    f0102bcc <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba7:	8a 00                	mov    (%eax),%al
f0102ba9:	0f b6 d0             	movzbl %al,%edx
f0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102baf:	8a 00                	mov    (%eax),%al
f0102bb1:	0f b6 c0             	movzbl %al,%eax
f0102bb4:	52                   	push   %edx
f0102bb5:	50                   	push   %eax
f0102bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb9:	68 4f 3b 12 f0       	push   $0xf0123b4f
f0102bbe:	e8 c8 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc3:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc6:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc9:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bcf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd2:	7c d0                	jl     f0102ba4 <command_readuserblock+0xaa>
f0102bd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bda:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdd:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be5:	c9                   	leave  
f0102be6:	c3                   	ret    

f0102be7 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be7:	55                   	push   %ebp
f0102be8:	89 e5                	mov    %esp,%ebp
f0102bea:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bf0:	83 c0 04             	add    $0x4,%eax
f0102bf3:	8b 00                	mov    (%eax),%eax
f0102bf5:	83 ec 04             	sub    $0x4,%esp
f0102bf8:	6a 0a                	push   $0xa
f0102bfa:	6a 00                	push   $0x0
f0102bfc:	50                   	push   %eax
f0102bfd:	e8 22 cd 01 00       	call   f011f924 <strtol>
f0102c02:	83 c4 10             	add    $0x10,%esp
f0102c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c08:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 00                	push   $0x0
f0102c14:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c17:	50                   	push   %eax
f0102c18:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1b:	e8 b8 87 00 00       	call   f010b3d8 <envid2env>
f0102c20:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	75 0a                	jne    f0102c34 <command_remove_table+0x4d>
f0102c2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2f:	e9 c7 00 00 00       	jmp    f0102cfb <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c37:	83 c0 08             	add    $0x8,%eax
f0102c3a:	8b 00                	mov    (%eax),%eax
f0102c3c:	83 ec 04             	sub    $0x4,%esp
f0102c3f:	6a 10                	push   $0x10
f0102c41:	6a 00                	push   $0x0
f0102c43:	50                   	push   %eax
f0102c44:	e8 db cc 01 00       	call   f011f924 <strtol>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c55:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c58:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5e:	c1 ea 16             	shr    $0x16,%edx
f0102c61:	c1 e2 02             	shl    $0x2,%edx
f0102c64:	01 d0                	add    %edx,%eax
f0102c66:	8b 00                	mov    (%eax),%eax
f0102c68:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c73:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c78:	77 1c                	ja     f0102c96 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c7a:	83 ec 0c             	sub    $0xc,%esp
f0102c7d:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c80:	e8 07 69 00 00       	call   f010958c <kheap_virtual_address>
f0102c85:	83 c4 10             	add    $0x10,%esp
f0102c88:	83 ec 0c             	sub    $0xc,%esp
f0102c8b:	50                   	push   %eax
f0102c8c:	e8 b8 67 00 00       	call   f0109449 <kfree>
f0102c91:	83 c4 10             	add    $0x10,%esp
f0102c94:	eb 28                	jmp    f0102cbe <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c96:	83 ec 0c             	sub    $0xc,%esp
f0102c99:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9c:	e8 a2 f9 ff ff       	call   f0102643 <to_frame_info>
f0102ca1:	83 c4 10             	add    $0x10,%esp
f0102ca4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102caa:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102cb0:	83 ec 0c             	sub    $0xc,%esp
f0102cb3:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb6:	e8 4b 56 00 00       	call   f0108306 <free_frame>
f0102cbb:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc1:	c1 e8 16             	shr    $0x16,%eax
f0102cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cca:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccd:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102cd0:	c1 e2 02             	shl    $0x2,%edx
f0102cd3:	01 c2                	add    %eax,%edx
f0102cd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd8:	8b 40 64             	mov    0x64(%eax),%eax
f0102cdb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cde:	c1 e1 02             	shl    $0x2,%ecx
f0102ce1:	01 c8                	add    %ecx,%eax
f0102ce3:	8b 00                	mov    (%eax),%eax
f0102ce5:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce8:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102cea:	0f 20 d8             	mov    %cr3,%eax
f0102ced:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cf0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf3:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfb:	c9                   	leave  
f0102cfc:	c3                   	ret    

f0102cfd <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfd:	55                   	push   %ebp
f0102cfe:	89 e5                	mov    %esp,%ebp
f0102d00:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d07:	7e 06                	jle    f0102d0f <command_allocuserpage+0x12>
f0102d09:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0d:	7e 1a                	jle    f0102d29 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0f:	83 ec 0c             	sub    $0xc,%esp
f0102d12:	68 60 3b 12 f0       	push   $0xf0123b60
f0102d17:	e8 6f e2 ff ff       	call   f0100f8b <cprintf>
f0102d1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d24:	e9 46 01 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2c:	83 c0 04             	add    $0x4,%eax
f0102d2f:	8b 00                	mov    (%eax),%eax
f0102d31:	83 ec 04             	sub    $0x4,%esp
f0102d34:	6a 0a                	push   $0xa
f0102d36:	6a 00                	push   $0x0
f0102d38:	50                   	push   %eax
f0102d39:	e8 e6 cb 01 00       	call   f011f924 <strtol>
f0102d3e:	83 c4 10             	add    $0x10,%esp
f0102d41:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d44:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4b:	83 ec 04             	sub    $0x4,%esp
f0102d4e:	6a 00                	push   $0x0
f0102d50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d53:	50                   	push   %eax
f0102d54:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d57:	e8 7c 86 00 00       	call   f010b3d8 <envid2env>
f0102d5c:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d62:	85 c0                	test   %eax,%eax
f0102d64:	75 0a                	jne    f0102d70 <command_allocuserpage+0x73>
f0102d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6b:	e9 ff 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d70:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d73:	83 c0 08             	add    $0x8,%eax
f0102d76:	8b 00                	mov    (%eax),%eax
f0102d78:	83 ec 04             	sub    $0x4,%esp
f0102d7b:	6a 10                	push   $0x10
f0102d7d:	6a 00                	push   $0x0
f0102d7f:	50                   	push   %eax
f0102d80:	e8 9f cb 01 00       	call   f011f924 <strtol>
f0102d85:	83 c4 10             	add    $0x10,%esp
f0102d88:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8b:	83 ec 0c             	sub    $0xc,%esp
f0102d8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d91:	50                   	push   %eax
f0102d92:	e8 1b 54 00 00       	call   f01081b2 <allocate_frame>
f0102d97:	83 c4 10             	add    $0x10,%esp
f0102d9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9d:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da1:	75 1a                	jne    f0102dbd <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da3:	83 ec 0c             	sub    $0xc,%esp
f0102da6:	68 8a 3b 12 f0       	push   $0xf0123b8a
f0102dab:	e8 db e1 ff ff       	call   f0100f8b <cprintf>
f0102db0:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db3:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db8:	e9 b2 00 00 00       	jmp    f0102e6f <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc1:	75 1d                	jne    f0102de0 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcc:	6a 06                	push   $0x6
f0102dce:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd1:	52                   	push   %edx
f0102dd2:	50                   	push   %eax
f0102dd3:	e8 a7 58 00 00       	call   f010867f <map_frame>
f0102dd8:	83 c4 10             	add    $0x10,%esp
f0102ddb:	e9 8a 00 00 00       	jmp    f0102e6a <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102de0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de4:	0f 85 80 00 00 00    	jne    f0102e6a <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102dea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ded:	83 c0 0c             	add    $0xc,%eax
f0102df0:	8b 00                	mov    (%eax),%eax
f0102df2:	8a 00                	mov    (%eax),%al
f0102df4:	3c 72                	cmp    $0x72,%al
f0102df6:	74 0e                	je     f0102e06 <command_allocuserpage+0x109>
f0102df8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfb:	83 c0 0c             	add    $0xc,%eax
f0102dfe:	8b 00                	mov    (%eax),%eax
f0102e00:	8a 00                	mov    (%eax),%al
f0102e02:	3c 52                	cmp    $0x52,%al
f0102e04:	75 09                	jne    f0102e0f <command_allocuserpage+0x112>
			rw = 0 ;
f0102e06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0d:	eb 3c                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	83 c0 0c             	add    $0xc,%eax
f0102e15:	8b 00                	mov    (%eax),%eax
f0102e17:	8a 00                	mov    (%eax),%al
f0102e19:	3c 77                	cmp    $0x77,%al
f0102e1b:	74 0e                	je     f0102e2b <command_allocuserpage+0x12e>
f0102e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e20:	83 c0 0c             	add    $0xc,%eax
f0102e23:	8b 00                	mov    (%eax),%eax
f0102e25:	8a 00                	mov    (%eax),%al
f0102e27:	3c 57                	cmp    $0x57,%al
f0102e29:	75 09                	jne    f0102e34 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e32:	eb 17                	jmp    f0102e4b <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e34:	83 ec 0c             	sub    $0xc,%esp
f0102e37:	68 a4 3b 12 f0       	push   $0xf0123ba4
f0102e3c:	e8 4a e1 ff ff       	call   f0100f8b <cprintf>
f0102e41:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e44:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4e:	83 c8 04             	or     $0x4,%eax
f0102e51:	89 c1                	mov    %eax,%ecx
f0102e53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e59:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5c:	51                   	push   %ecx
f0102e5d:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e60:	52                   	push   %edx
f0102e61:	50                   	push   %eax
f0102e62:	e8 18 58 00 00       	call   f010867f <map_frame>
f0102e67:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6f:	c9                   	leave  
f0102e70:	c3                   	ret    

f0102e71 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e71:	55                   	push   %ebp
f0102e72:	89 e5                	mov    %esp,%ebp
f0102e74:	56                   	push   %esi
f0102e75:	53                   	push   %ebx
f0102e76:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7c:	83 ec 0c             	sub    $0xc,%esp
f0102e7f:	50                   	push   %eax
f0102e80:	e8 dc 5a 00 00       	call   f0108961 <calculate_available_frames>
f0102e85:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e88:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e91:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e94:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e97:	01 de                	add    %ebx,%esi
f0102e99:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9c:	01 f3                	add    %esi,%ebx
f0102e9e:	83 ec 0c             	sub    $0xc,%esp
f0102ea1:	51                   	push   %ecx
f0102ea2:	52                   	push   %edx
f0102ea3:	50                   	push   %eax
f0102ea4:	53                   	push   %ebx
f0102ea5:	68 e8 3b 12 f0       	push   $0xf0123be8
f0102eaa:	e8 dc e0 ff ff       	call   f0100f8b <cprintf>
f0102eaf:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb2:	a1 70 d9 6b f0       	mov    0xf06bd970,%eax
f0102eb7:	83 ec 08             	sub    $0x8,%esp
f0102eba:	50                   	push   %eax
f0102ebb:	68 40 3c 12 f0       	push   $0xf0123c40
f0102ec0:	e8 c6 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec5:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ed0:	5b                   	pop    %ebx
f0102ed1:	5e                   	pop    %esi
f0102ed2:	5d                   	pop    %ebp
f0102ed3:	c3                   	ret    

f0102ed4 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed4:	55                   	push   %ebp
f0102ed5:	89 e5                	mov    %esp,%ebp
f0102ed7:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102eda:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eef:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ef9:	83 f8 04             	cmp    $0x4,%eax
f0102efc:	0f 84 94 00 00 00    	je     f0102f96 <CreateEnv+0xc2>
f0102f02:	83 f8 05             	cmp    $0x5,%eax
f0102f05:	74 0e                	je     f0102f15 <CreateEnv+0x41>
f0102f07:	83 f8 03             	cmp    $0x3,%eax
f0102f0a:	0f 84 ec 00 00 00    	je     f0102ffc <CreateEnv+0x128>
f0102f10:	e9 2f 01 00 00       	jmp    f0103044 <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f15:	83 ec 0c             	sub    $0xc,%esp
f0102f18:	6a 02                	push   $0x2
f0102f1a:	e8 a4 c0 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f0102f1f:	83 c4 10             	add    $0x10,%esp
f0102f22:	85 c0                	test   %eax,%eax
f0102f24:	75 1a                	jne    f0102f40 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f26:	83 ec 0c             	sub    $0xc,%esp
f0102f29:	68 7c 3c 12 f0       	push   $0xf0123c7c
f0102f2e:	e8 58 e0 ff ff       	call   f0100f8b <cprintf>
f0102f33:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f36:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f3b:	e9 ff 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f43:	83 c0 10             	add    $0x10,%eax
f0102f46:	8b 00                	mov    (%eax),%eax
f0102f48:	83 ec 04             	sub    $0x4,%esp
f0102f4b:	6a 0a                	push   $0xa
f0102f4d:	6a 00                	push   $0x0
f0102f4f:	50                   	push   %eax
f0102f50:	e8 cf c9 01 00       	call   f011f924 <strtol>
f0102f55:	83 c4 10             	add    $0x10,%esp
f0102f58:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f5e:	83 c0 0c             	add    $0xc,%eax
f0102f61:	8b 00                	mov    (%eax),%eax
f0102f63:	83 ec 04             	sub    $0x4,%esp
f0102f66:	6a 0a                	push   $0xa
f0102f68:	6a 00                	push   $0x0
f0102f6a:	50                   	push   %eax
f0102f6b:	e8 b4 c9 01 00       	call   f011f924 <strtol>
f0102f70:	83 c4 10             	add    $0x10,%esp
f0102f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f79:	83 c0 08             	add    $0x8,%eax
f0102f7c:	8b 00                	mov    (%eax),%eax
f0102f7e:	83 ec 04             	sub    $0x4,%esp
f0102f81:	6a 0a                	push   $0xa
f0102f83:	6a 00                	push   $0x0
f0102f85:	50                   	push   %eax
f0102f86:	e8 99 c9 01 00       	call   f011f924 <strtol>
f0102f8b:	83 c4 10             	add    $0x10,%esp
f0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102f91:	e9 c8 00 00 00       	jmp    f010305e <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f96:	83 ec 0c             	sub    $0xc,%esp
f0102f99:	6a 02                	push   $0x2
f0102f9b:	e8 23 c0 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f0102fa0:	83 c4 10             	add    $0x10,%esp
f0102fa3:	85 c0                	test   %eax,%eax
f0102fa5:	75 1d                	jne    f0102fc4 <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102faa:	83 c0 0c             	add    $0xc,%eax
f0102fad:	8b 00                	mov    (%eax),%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	6a 0a                	push   $0xa
f0102fb4:	6a 00                	push   $0x0
f0102fb6:	50                   	push   %eax
f0102fb7:	e8 68 c9 01 00       	call   f011f924 <strtol>
f0102fbc:	83 c4 10             	add    $0x10,%esp
f0102fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102fc2:	eb 1b                	jmp    f0102fdf <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fc7:	83 c0 0c             	add    $0xc,%eax
f0102fca:	8b 00                	mov    (%eax),%eax
f0102fcc:	83 ec 04             	sub    $0x4,%esp
f0102fcf:	6a 0a                	push   $0xa
f0102fd1:	6a 00                	push   $0x0
f0102fd3:	50                   	push   %eax
f0102fd4:	e8 4b c9 01 00       	call   f011f924 <strtol>
f0102fd9:	83 c4 10             	add    $0x10,%esp
f0102fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe2:	83 c0 08             	add    $0x8,%eax
f0102fe5:	8b 00                	mov    (%eax),%eax
f0102fe7:	83 ec 04             	sub    $0x4,%esp
f0102fea:	6a 0a                	push   $0xa
f0102fec:	6a 00                	push   $0x0
f0102fee:	50                   	push   %eax
f0102fef:	e8 30 c9 01 00       	call   f011f924 <strtol>
f0102ff4:	83 c4 10             	add    $0x10,%esp
f0102ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102ffa:	eb 62                	jmp    f010305e <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102ffc:	83 ec 0c             	sub    $0xc,%esp
f0102fff:	6a 02                	push   $0x2
f0103001:	e8 bd bf 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f0103006:	83 c4 10             	add    $0x10,%esp
f0103009:	85 c0                	test   %eax,%eax
f010300b:	74 1a                	je     f0103027 <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f010300d:	83 ec 0c             	sub    $0xc,%esp
f0103010:	68 28 3d 12 f0       	push   $0xf0123d28
f0103015:	e8 71 df ff ff       	call   f0100f8b <cprintf>
f010301a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f010301d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103022:	e9 18 01 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103027:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302a:	83 c0 08             	add    $0x8,%eax
f010302d:	8b 00                	mov    (%eax),%eax
f010302f:	83 ec 04             	sub    $0x4,%esp
f0103032:	6a 0a                	push   $0xa
f0103034:	6a 00                	push   $0x0
f0103036:	50                   	push   %eax
f0103037:	e8 e8 c8 01 00       	call   f011f924 <strtol>
f010303c:	83 c4 10             	add    $0x10,%esp
f010303f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103042:	eb 1a                	jmp    f010305e <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 b8 3d 12 f0       	push   $0xf0123db8
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 e1 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010305e:	83 ec 0c             	sub    $0xc,%esp
f0103061:	6a 02                	push   $0x2
f0103063:	e8 5b bf 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f0103068:	83 c4 10             	add    $0x10,%esp
f010306b:	85 c0                	test   %eax,%eax
f010306d:	74 23                	je     f0103092 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f010306f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103072:	48                   	dec    %eax
f0103073:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103076:	73 1a                	jae    f0103092 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103078:	83 ec 0c             	sub    $0xc,%esp
f010307b:	68 50 3e 12 f0       	push   $0xf0123e50
f0103080:	e8 06 df ff ff       	call   f0100f8b <cprintf>
f0103085:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103088:	b8 00 00 00 00       	mov    $0x0,%eax
f010308d:	e9 ad 00 00 00       	jmp    f010313f <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103092:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f0103096:	76 19                	jbe    f01030b1 <CreateEnv+0x1dd>
f0103098:	68 a8 3e 12 f0       	push   $0xf0123ea8
f010309d:	68 ed 3e 12 f0       	push   $0xf0123eed
f01030a2:	68 a4 01 00 00       	push   $0x1a4
f01030a7:	68 02 3f 12 f0       	push   $0xf0123f02
f01030ac:	e8 88 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030b1:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030b5:	76 19                	jbe    f01030d0 <CreateEnv+0x1fc>
f01030b7:	68 a8 3e 12 f0       	push   $0xf0123ea8
f01030bc:	68 ed 3e 12 f0       	push   $0xf0123eed
f01030c1:	68 c0 01 00 00       	push   $0x1c0
f01030c6:	68 02 3f 12 f0       	push   $0xf0123f02
f01030cb:	e8 69 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f01030d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030d3:	83 c0 04             	add    $0x4,%eax
f01030d6:	8b 00                	mov    (%eax),%eax
f01030d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01030db:	ff 75 f0             	pushl  -0x10(%ebp)
f01030de:	ff 75 f4             	pushl  -0xc(%ebp)
f01030e1:	50                   	push   %eax
f01030e2:	e8 23 78 00 00       	call   f010a90a <env_create>
f01030e7:	83 c4 10             	add    $0x10,%esp
f01030ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f01030ed:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f01030f1:	74 49                	je     f010313c <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f01030f3:	83 ec 08             	sub    $0x8,%esp
f01030f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01030f9:	68 16 3f 12 f0       	push   $0xf0123f16
f01030fe:	e8 88 de ff ff       	call   f0100f8b <cprintf>
f0103103:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103106:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010310a:	7c 06                	jl     f0103112 <CreateEnv+0x23e>
f010310c:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103110:	7e 19                	jle    f010312b <CreateEnv+0x257>
f0103112:	68 28 3f 12 f0       	push   $0xf0123f28
f0103117:	68 ed 3e 12 f0       	push   $0xf0123eed
f010311c:	68 c5 01 00 00       	push   $0x1c5
f0103121:	68 02 3f 12 f0       	push   $0xf0123f02
f0103126:	e8 0e d2 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010312b:	83 ec 08             	sub    $0x8,%esp
f010312e:	ff 75 ec             	pushl  -0x14(%ebp)
f0103131:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103134:	e8 4d 35 00 00       	call   f0106686 <env_set_nice>
f0103139:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f010313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010313f:	c9                   	leave  
f0103140:	c3                   	ret    

f0103141 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103141:	55                   	push   %ebp
f0103142:	89 e5                	mov    %esp,%ebp
f0103144:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103147:	83 ec 08             	sub    $0x8,%esp
f010314a:	ff 75 0c             	pushl  0xc(%ebp)
f010314d:	ff 75 08             	pushl  0x8(%ebp)
f0103150:	e8 7f fd ff ff       	call   f0102ed4 <CreateEnv>
f0103155:	83 c4 10             	add    $0x10,%esp
f0103158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f010315b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010315f:	75 07                	jne    f0103168 <command_run_program+0x27>
f0103161:	b8 00 00 00 00       	mov    $0x0,%eax
f0103166:	eb 46                	jmp    f01031ae <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103168:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010316b:	8b 40 10             	mov    0x10(%eax),%eax
f010316e:	83 ec 08             	sub    $0x8,%esp
f0103171:	50                   	push   %eax
f0103172:	68 58 3f 12 f0       	push   $0xf0123f58
f0103177:	e8 0f de ff ff       	call   f0100f8b <cprintf>
f010317c:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f010317f:	83 ec 0c             	sub    $0xc,%esp
f0103182:	ff 75 f4             	pushl  -0xc(%ebp)
f0103185:	e8 92 25 00 00       	call   f010571c <sched_new_env>
f010318a:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010318d:	c7 05 70 d9 6b f0 00 	movl   $0x0,0xf06bd970
f0103194:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103197:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010319a:	8b 40 10             	mov    0x10(%eax),%eax
f010319d:	83 ec 0c             	sub    $0xc,%esp
f01031a0:	50                   	push   %eax
f01031a1:	e8 cc 25 00 00       	call   f0105772 <sched_run_env>
f01031a6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ae:	c9                   	leave  
f01031af:	c3                   	ret    

f01031b0 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031b0:	55                   	push   %ebp
f01031b1:	89 e5                	mov    %esp,%ebp
f01031b3:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031b9:	83 c0 04             	add    $0x4,%eax
f01031bc:	8b 00                	mov    (%eax),%eax
f01031be:	83 ec 04             	sub    $0x4,%esp
f01031c1:	6a 0a                	push   $0xa
f01031c3:	6a 00                	push   $0x0
f01031c5:	50                   	push   %eax
f01031c6:	e8 59 c7 01 00       	call   f011f924 <strtol>
f01031cb:	83 c4 10             	add    $0x10,%esp
f01031ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f01031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 db 28 00 00       	call   f0105ab8 <sched_kill_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031ed:	83 ec 08             	sub    $0x8,%esp
f01031f0:	ff 75 0c             	pushl  0xc(%ebp)
f01031f3:	ff 75 08             	pushl  0x8(%ebp)
f01031f6:	e8 d9 fc ff ff       	call   f0102ed4 <CreateEnv>
f01031fb:	83 c4 10             	add    $0x10,%esp
f01031fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103201:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103205:	75 07                	jne    f010320e <commnad_load_env+0x27>
		return 0 ;
f0103207:	b8 00 00 00 00       	mov    $0x0,%eax
f010320c:	eb 2a                	jmp    f0103238 <commnad_load_env+0x51>

	sched_new_env(env) ;
f010320e:	83 ec 0c             	sub    $0xc,%esp
f0103211:	ff 75 f4             	pushl  -0xc(%ebp)
f0103214:	e8 03 25 00 00       	call   f010571c <sched_new_env>
f0103219:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010321c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321f:	8b 40 10             	mov    0x10(%eax),%eax
f0103222:	83 ec 08             	sub    $0x8,%esp
f0103225:	50                   	push   %eax
f0103226:	68 58 3f 12 f0       	push   $0xf0123f58
f010322b:	e8 5b dd ff ff       	call   f0100f8b <cprintf>
f0103230:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103233:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103238:	c9                   	leave  
f0103239:	c3                   	ret    

f010323a <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f010323a:	55                   	push   %ebp
f010323b:	89 e5                	mov    %esp,%ebp
f010323d:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103240:	c7 05 70 d9 6b f0 00 	movl   $0x0,0xf06bd970
f0103247:	00 00 00 
	sched_run_all();
f010324a:	e8 26 2e 00 00       	call   f0106075 <sched_run_all>

	return 0 ;
f010324f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103254:	c9                   	leave  
f0103255:	c3                   	ret    

f0103256 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103256:	55                   	push   %ebp
f0103257:	89 e5                	mov    %esp,%ebp
f0103259:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f010325c:	e8 f3 2b 00 00       	call   f0105e54 <sched_print_all>

	return 0 ;
f0103261:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103266:	c9                   	leave  
f0103267:	c3                   	ret    

f0103268 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103268:	55                   	push   %ebp
f0103269:	89 e5                	mov    %esp,%ebp
f010326b:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f010326e:	e8 97 2e 00 00       	call   f010610a <sched_kill_all>

	return 0 ;
f0103273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103278:	c9                   	leave  
f0103279:	c3                   	ret    

f010327a <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f010327a:	55                   	push   %ebp
f010327b:	89 e5                	mov    %esp,%ebp
f010327d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103280:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103284:	7f 1a                	jg     f01032a0 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103286:	83 ec 0c             	sub    $0xc,%esp
f0103289:	68 70 3f 12 f0       	push   $0xf0123f70
f010328e:	e8 f8 dc ff ff       	call   f0100f8b <cprintf>
f0103293:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103296:	b8 00 00 00 00       	mov    $0x0,%eax
f010329b:	e9 83 00 00 00       	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032a3:	83 c0 04             	add    $0x4,%eax
f01032a6:	8b 00                	mov    (%eax),%eax
f01032a8:	83 ec 04             	sub    $0x4,%esp
f01032ab:	6a 0a                	push   $0xa
f01032ad:	6a 00                	push   $0x0
f01032af:	50                   	push   %eax
f01032b0:	e8 6f c6 01 00       	call   f011f924 <strtol>
f01032b5:	83 c4 10             	add    $0x10,%esp
f01032b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032bb:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032bf:	75 20                	jne    f01032e1 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032c1:	83 ec 0c             	sub    $0xc,%esp
f01032c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01032c7:	e8 6c bc 00 00       	call   f010ef38 <setPageReplacmentAlgorithmLRU>
f01032cc:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f01032cf:	83 ec 0c             	sub    $0xc,%esp
f01032d2:	68 d0 3f 12 f0       	push   $0xf0123fd0
f01032d7:	e8 af dc ff ff       	call   f0100f8b <cprintf>
f01032dc:	83 c4 10             	add    $0x10,%esp
f01032df:	eb 3d                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f01032e1:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01032e5:	75 20                	jne    f0103307 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032e7:	83 ec 0c             	sub    $0xc,%esp
f01032ea:	ff 75 f4             	pushl  -0xc(%ebp)
f01032ed:	e8 46 bc 00 00       	call   f010ef38 <setPageReplacmentAlgorithmLRU>
f01032f2:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01032f5:	83 ec 0c             	sub    $0xc,%esp
f01032f8:	68 14 40 12 f0       	push   $0xf0124014
f01032fd:	e8 89 dc ff ff       	call   f0100f8b <cprintf>
f0103302:	83 c4 10             	add    $0x10,%esp
f0103305:	eb 17                	jmp    f010331e <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103307:	83 ec 0c             	sub    $0xc,%esp
f010330a:	68 54 40 12 f0       	push   $0xf0124054
f010330f:	e8 77 dc ff ff       	call   f0100f8b <cprintf>
f0103314:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103317:	b8 00 00 00 00       	mov    $0x0,%eax
f010331c:	eb 05                	jmp    f0103323 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f010331e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103323:	c9                   	leave  
f0103324:	c3                   	ret    

f0103325 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103325:	55                   	push   %ebp
f0103326:	89 e5                	mov    %esp,%ebp
f0103328:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f010332b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010332e:	83 c0 04             	add    $0x4,%eax
f0103331:	8b 00                	mov    (%eax),%eax
f0103333:	83 ec 04             	sub    $0x4,%esp
f0103336:	6a 0a                	push   $0xa
f0103338:	6a 00                	push   $0x0
f010333a:	50                   	push   %eax
f010333b:	e8 e4 c5 01 00       	call   f011f924 <strtol>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103346:	83 ec 0c             	sub    $0xc,%esp
f0103349:	ff 75 f4             	pushl  -0xc(%ebp)
f010334c:	e8 5a bc 00 00       	call   f010efab <setPageReplacmentAlgorithmNchanceCLOCK>
f0103351:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103354:	83 ec 0c             	sub    $0xc,%esp
f0103357:	68 a8 40 12 f0       	push   $0xf01240a8
f010335c:	e8 2a dc ff ff       	call   f0100f8b <cprintf>
f0103361:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103364:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103369:	c9                   	leave  
f010336a:	c3                   	ret    

f010336b <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010336b:	55                   	push   %ebp
f010336c:	89 e5                	mov    %esp,%ebp
f010336e:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103371:	e8 f5 bb 00 00       	call   f010ef6b <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103376:	83 ec 0c             	sub    $0xc,%esp
f0103379:	68 dc 40 12 f0       	push   $0xf01240dc
f010337e:	e8 08 dc ff ff       	call   f0100f8b <cprintf>
f0103383:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103386:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010338b:	c9                   	leave  
f010338c:	c3                   	ret    

f010338d <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010338d:	55                   	push   %ebp
f010338e:	89 e5                	mov    %esp,%ebp
f0103390:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103393:	e8 e3 bb 00 00       	call   f010ef7b <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0103398:	83 ec 0c             	sub    $0xc,%esp
f010339b:	68 08 41 12 f0       	push   $0xf0124108
f01033a0:	e8 e6 db ff ff       	call   f0100f8b <cprintf>
f01033a5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033ad:	c9                   	leave  
f01033ae:	c3                   	ret    

f01033af <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033af:	55                   	push   %ebp
f01033b0:	89 e5                	mov    %esp,%ebp
f01033b2:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033b5:	e8 d1 bb 00 00       	call   f010ef8b <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033ba:	83 ec 0c             	sub    $0xc,%esp
f01033bd:	68 30 41 12 f0       	push   $0xf0124130
f01033c2:	e8 c4 db ff ff       	call   f0100f8b <cprintf>
f01033c7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033cf:	c9                   	leave  
f01033d0:	c3                   	ret    

f01033d1 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01033d1:	55                   	push   %ebp
f01033d2:	89 e5                	mov    %esp,%ebp
f01033d4:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01033d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033da:	83 c0 04             	add    $0x4,%eax
f01033dd:	8b 00                	mov    (%eax),%eax
f01033df:	83 ec 04             	sub    $0x4,%esp
f01033e2:	6a 0a                	push   $0xa
f01033e4:	6a 00                	push   $0x0
f01033e6:	50                   	push   %eax
f01033e7:	e8 38 c5 01 00       	call   f011f924 <strtol>
f01033ec:	83 c4 10             	add    $0x10,%esp
f01033ef:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01033f2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01033f6:	83 ec 0c             	sub    $0xc,%esp
f01033f9:	50                   	push   %eax
f01033fa:	e8 a8 35 00 00       	call   f01069a7 <sched_init_RR>
f01033ff:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103402:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f0103407:	8a 00                	mov    (%eax),%al
f0103409:	0f b6 c0             	movzbl %al,%eax
f010340c:	83 ec 08             	sub    $0x8,%esp
f010340f:	50                   	push   %eax
f0103410:	68 64 41 12 f0       	push   $0xf0124164
f0103415:	e8 71 db ff ff       	call   f0100f8b <cprintf>
f010341a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103422:	c9                   	leave  
f0103423:	c3                   	ret    

f0103424 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103424:	55                   	push   %ebp
f0103425:	89 e5                	mov    %esp,%ebp
f0103427:	53                   	push   %ebx
f0103428:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010342b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010342e:	83 c0 04             	add    $0x4,%eax
f0103431:	8b 00                	mov    (%eax),%eax
f0103433:	83 ec 04             	sub    $0x4,%esp
f0103436:	6a 0a                	push   $0xa
f0103438:	6a 00                	push   $0x0
f010343a:	50                   	push   %eax
f010343b:	e8 e4 c4 01 00       	call   f011f924 <strtol>
f0103440:	83 c4 10             	add    $0x10,%esp
f0103443:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103446:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010344d:	eb 2e                	jmp    f010347d <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f010344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103452:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103458:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010345f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103462:	01 d0                	add    %edx,%eax
f0103464:	8b 00                	mov    (%eax),%eax
f0103466:	83 ec 04             	sub    $0x4,%esp
f0103469:	6a 0a                	push   $0xa
f010346b:	6a 00                	push   $0x0
f010346d:	50                   	push   %eax
f010346e:	e8 b1 c4 01 00       	call   f011f924 <strtol>
f0103473:	83 c4 10             	add    $0x10,%esp
f0103476:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347a:	ff 45 f4             	incl   -0xc(%ebp)
f010347d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103480:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103483:	7c ca                	jl     f010344f <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103485:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103489:	83 ec 08             	sub    $0x8,%esp
f010348c:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f010348f:	52                   	push   %edx
f0103490:	50                   	push   %eax
f0103491:	e8 bf 35 00 00       	call   f0106a55 <sched_init_MLFQ>
f0103496:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103499:	83 ec 0c             	sub    $0xc,%esp
f010349c:	68 9c 41 12 f0       	push   $0xf012419c
f01034a1:	e8 e5 da ff ff       	call   f0100f8b <cprintf>
f01034a6:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034b0:	eb 24                	jmp    f01034d6 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034b2:	8b 15 84 d6 6b f0    	mov    0xf06bd684,%edx
f01034b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034bb:	01 d0                	add    %edx,%eax
f01034bd:	8a 00                	mov    (%eax),%al
f01034bf:	0f b6 c0             	movzbl %al,%eax
f01034c2:	83 ec 08             	sub    $0x8,%esp
f01034c5:	50                   	push   %eax
f01034c6:	68 c9 41 12 f0       	push   $0xf01241c9
f01034cb:	e8 bb da ff ff       	call   f0100f8b <cprintf>
f01034d0:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034d3:	ff 45 f0             	incl   -0x10(%ebp)
f01034d6:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f01034db:	0f b6 c0             	movzbl %al,%eax
f01034de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01034e1:	7f cf                	jg     f01034b2 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01034e3:	83 ec 0c             	sub    $0xc,%esp
f01034e6:	68 4d 3b 12 f0       	push   $0xf0123b4d
f01034eb:	e8 9b da ff ff       	call   f0100f8b <cprintf>
f01034f0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01034fb:	c9                   	leave  
f01034fc:	c3                   	ret    

f01034fd <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 0a                	push   $0xa
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 0c c4 01 00       	call   f011f924 <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f010351e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103521:	83 c0 08             	add    $0x8,%eax
f0103524:	8b 00                	mov    (%eax),%eax
f0103526:	83 ec 04             	sub    $0x4,%esp
f0103529:	6a 0a                	push   $0xa
f010352b:	6a 00                	push   $0x0
f010352d:	50                   	push   %eax
f010352e:	e8 f1 c3 01 00       	call   f011f924 <strtol>
f0103533:	83 c4 10             	add    $0x10,%esp
f0103536:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103539:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010353d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103541:	83 ec 08             	sub    $0x8,%esp
f0103544:	52                   	push   %edx
f0103545:	50                   	push   %eax
f0103546:	e8 32 35 00 00       	call   f0106a7d <sched_init_BSD>
f010354b:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f010354e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103552:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103556:	83 ec 04             	sub    $0x4,%esp
f0103559:	52                   	push   %edx
f010355a:	50                   	push   %eax
f010355b:	68 d0 41 12 f0       	push   $0xf01241d0
f0103560:	e8 26 da ff ff       	call   f0100f8b <cprintf>
f0103565:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103568:	83 ec 0c             	sub    $0xc,%esp
f010356b:	68 4d 3b 12 f0       	push   $0xf0123b4d
f0103570:	e8 16 da ff ff       	call   f0100f8b <cprintf>
f0103575:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103578:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010357d:	c9                   	leave  
f010357e:	c3                   	ret    

f010357f <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f010357f:	55                   	push   %ebp
f0103580:	89 e5                	mov    %esp,%ebp
f0103582:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103585:	e8 6d 31 00 00       	call   f01066f7 <isSchedMethodMLFQ>
f010358a:	85 c0                	test   %eax,%eax
f010358c:	74 5c                	je     f01035ea <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010358e:	83 ec 0c             	sub    $0xc,%esp
f0103591:	68 0c 42 12 f0       	push   $0xf012420c
f0103596:	e8 f0 d9 ff ff       	call   f0100f8b <cprintf>
f010359b:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010359e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035a5:	eb 24                	jmp    f01035cb <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035a7:	8b 15 84 d6 6b f0    	mov    0xf06bd684,%edx
f01035ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035b0:	01 d0                	add    %edx,%eax
f01035b2:	8a 00                	mov    (%eax),%al
f01035b4:	0f b6 c0             	movzbl %al,%eax
f01035b7:	83 ec 08             	sub    $0x8,%esp
f01035ba:	50                   	push   %eax
f01035bb:	68 c9 41 12 f0       	push   $0xf01241c9
f01035c0:	e8 c6 d9 ff ff       	call   f0100f8b <cprintf>
f01035c5:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035c8:	ff 45 f4             	incl   -0xc(%ebp)
f01035cb:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f01035d0:	0f b6 c0             	movzbl %al,%eax
f01035d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01035d6:	7f cf                	jg     f01035a7 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f01035d8:	83 ec 0c             	sub    $0xc,%esp
f01035db:	68 4d 3b 12 f0       	push   $0xf0123b4d
f01035e0:	e8 a6 d9 ff ff       	call   f0100f8b <cprintf>
f01035e5:	83 c4 10             	add    $0x10,%esp
f01035e8:	eb 65                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f01035ea:	e8 ee 30 00 00       	call   f01066dd <isSchedMethodRR>
f01035ef:	85 c0                	test   %eax,%eax
f01035f1:	74 1d                	je     f0103610 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f01035f3:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f01035f8:	8a 00                	mov    (%eax),%al
f01035fa:	0f b6 c0             	movzbl %al,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	50                   	push   %eax
f0103601:	68 40 42 12 f0       	push   $0xf0124240
f0103606:	e8 80 d9 ff ff       	call   f0100f8b <cprintf>
f010360b:	83 c4 10             	add    $0x10,%esp
f010360e:	eb 3f                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103610:	e8 fd 30 00 00       	call   f0106712 <isSchedMethodBSD>
f0103615:	85 c0                	test   %eax,%eax
f0103617:	74 26                	je     f010363f <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103619:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f010361e:	8a 00                	mov    (%eax),%al
f0103620:	0f b6 d0             	movzbl %al,%edx
f0103623:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0103628:	0f b6 c0             	movzbl %al,%eax
f010362b:	83 ec 04             	sub    $0x4,%esp
f010362e:	52                   	push   %edx
f010362f:	50                   	push   %eax
f0103630:	68 d0 41 12 f0       	push   $0xf01241d0
f0103635:	e8 51 d9 ff ff       	call   f0100f8b <cprintf>
f010363a:	83 c4 10             	add    $0x10,%esp
f010363d:	eb 10                	jmp    f010364f <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f010363f:	83 ec 0c             	sub    $0xc,%esp
f0103642:	68 7c 42 12 f0       	push   $0xf012427c
f0103647:	e8 3f d9 ff ff       	call   f0100f8b <cprintf>
f010364c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010364f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103654:	c9                   	leave  
f0103655:	c3                   	ret    

f0103656 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f0103656:	55                   	push   %ebp
f0103657:	89 e5                	mov    %esp,%ebp
f0103659:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f010365c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010365f:	83 c0 04             	add    $0x4,%eax
f0103662:	8b 00                	mov    (%eax),%eax
f0103664:	83 ec 04             	sub    $0x4,%esp
f0103667:	6a 0a                	push   $0xa
f0103669:	6a 00                	push   $0x0
f010366b:	50                   	push   %eax
f010366c:	e8 b3 c2 01 00       	call   f011f924 <strtol>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010367a:	0f b6 c0             	movzbl %al,%eax
f010367d:	83 ec 0c             	sub    $0xc,%esp
f0103680:	50                   	push   %eax
f0103681:	e8 92 b0 01 00       	call   f011e718 <chksch>
f0103686:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010368d:	75 12                	jne    f01036a1 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	68 a4 42 12 f0       	push   $0xf01242a4
f0103697:	e8 ef d8 ff ff       	call   f0100f8b <cprintf>
f010369c:	83 c4 10             	add    $0x10,%esp
f010369f:	eb 16                	jmp    f01036b7 <command_sch_test+0x61>
	else if (status == 1)
f01036a1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036a5:	75 10                	jne    f01036b7 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036a7:	83 ec 0c             	sub    $0xc,%esp
f01036aa:	68 cc 42 12 f0       	push   $0xf01242cc
f01036af:	e8 d7 d8 ff ff       	call   f0100f8b <cprintf>
f01036b4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036bc:	c9                   	leave  
f01036bd:	c3                   	ret    

f01036be <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036be:	55                   	push   %ebp
f01036bf:	89 e5                	mov    %esp,%ebp
f01036c1:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036c4:	e8 10 b9 00 00       	call   f010efd9 <isPageReplacmentAlgorithmCLOCK>
f01036c9:	85 c0                	test   %eax,%eax
f01036cb:	74 15                	je     f01036e2 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f01036cd:	83 ec 0c             	sub    $0xc,%esp
f01036d0:	68 f0 42 12 f0       	push   $0xf01242f0
f01036d5:	e8 b1 d8 ff ff       	call   f0100f8b <cprintf>
f01036da:	83 c4 10             	add    $0x10,%esp
f01036dd:	e9 8c 00 00 00       	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01036e2:	83 ec 0c             	sub    $0xc,%esp
f01036e5:	6a 01                	push   $0x1
f01036e7:	e8 d7 b8 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f01036ec:	83 c4 10             	add    $0x10,%esp
f01036ef:	85 c0                	test   %eax,%eax
f01036f1:	74 12                	je     f0103705 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f01036f3:	83 ec 0c             	sub    $0xc,%esp
f01036f6:	68 18 43 12 f0       	push   $0xf0124318
f01036fb:	e8 8b d8 ff ff       	call   f0100f8b <cprintf>
f0103700:	83 c4 10             	add    $0x10,%esp
f0103703:	eb 69                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103705:	83 ec 0c             	sub    $0xc,%esp
f0103708:	6a 02                	push   $0x2
f010370a:	e8 b4 b8 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f010370f:	83 c4 10             	add    $0x10,%esp
f0103712:	85 c0                	test   %eax,%eax
f0103714:	74 12                	je     f0103728 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103716:	83 ec 0c             	sub    $0xc,%esp
f0103719:	68 58 43 12 f0       	push   $0xf0124358
f010371e:	e8 68 d8 ff ff       	call   f0100f8b <cprintf>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	eb 46                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f0103728:	e8 c7 b8 00 00       	call   f010eff4 <isPageReplacmentAlgorithmFIFO>
f010372d:	85 c0                	test   %eax,%eax
f010372f:	74 12                	je     f0103743 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103731:	83 ec 0c             	sub    $0xc,%esp
f0103734:	68 94 43 12 f0       	push   $0xf0124394
f0103739:	e8 4d d8 ff ff       	call   f0100f8b <cprintf>
f010373e:	83 c4 10             	add    $0x10,%esp
f0103741:	eb 2b                	jmp    f010376e <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f0103743:	e8 c7 b8 00 00       	call   f010f00f <isPageReplacmentAlgorithmModifiedCLOCK>
f0103748:	85 c0                	test   %eax,%eax
f010374a:	74 12                	je     f010375e <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f010374c:	83 ec 0c             	sub    $0xc,%esp
f010374f:	68 b8 43 12 f0       	push   $0xf01243b8
f0103754:	e8 32 d8 ff ff       	call   f0100f8b <cprintf>
f0103759:	83 c4 10             	add    $0x10,%esp
f010375c:	eb 10                	jmp    f010376e <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f010375e:	83 ec 0c             	sub    $0xc,%esp
f0103761:	68 e8 43 12 f0       	push   $0xf01243e8
f0103766:	e8 20 d8 ff ff       	call   f0100f8b <cprintf>
f010376b:	83 c4 10             	add    $0x10,%esp

	return 0;
f010376e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103773:	c9                   	leave  
f0103774:	c3                   	ret    

f0103775 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103775:	55                   	push   %ebp
f0103776:	89 e5                	mov    %esp,%ebp
f0103778:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010377b:	e8 2f ee ff ff       	call   f01025af <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103780:	83 ec 0c             	sub    $0xc,%esp
f0103783:	68 14 44 12 f0       	push   $0xf0124414
f0103788:	e8 fe d7 ff ff       	call   f0100f8b <cprintf>
f010378d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103790:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103795:	c9                   	leave  
f0103796:	c3                   	ret    

f0103797 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103797:	55                   	push   %ebp
f0103798:	89 e5                	mov    %esp,%ebp
f010379a:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010379d:	e8 1d ee ff ff       	call   f01025bf <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037a2:	83 ec 0c             	sub    $0xc,%esp
f01037a5:	68 44 44 12 f0       	push   $0xf0124444
f01037aa:	e8 dc d7 ff ff       	call   f0100f8b <cprintf>
f01037af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037b7:	c9                   	leave  
f01037b8:	c3                   	ret    

f01037b9 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037b9:	55                   	push   %ebp
f01037ba:	89 e5                	mov    %esp,%ebp
f01037bc:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037bf:	e8 0b ee ff ff       	call   f01025cf <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037c4:	83 ec 0c             	sub    $0xc,%esp
f01037c7:	68 74 44 12 f0       	push   $0xf0124474
f01037cc:	e8 ba d7 ff ff       	call   f0100f8b <cprintf>
f01037d1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037d9:	c9                   	leave  
f01037da:	c3                   	ret    

f01037db <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01037db:	55                   	push   %ebp
f01037dc:	89 e5                	mov    %esp,%ebp
f01037de:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01037e1:	e8 f9 ed ff ff       	call   f01025df <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01037e6:	83 ec 0c             	sub    $0xc,%esp
f01037e9:	68 a4 44 12 f0       	push   $0xf01244a4
f01037ee:	e8 98 d7 ff ff       	call   f0100f8b <cprintf>
f01037f3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037fb:	c9                   	leave  
f01037fc:	c3                   	ret    

f01037fd <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01037fd:	55                   	push   %ebp
f01037fe:	89 e5                	mov    %esp,%ebp
f0103800:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103803:	e8 e7 ed ff ff       	call   f01025ef <isUHeapPlacementStrategyFIRSTFIT>
f0103808:	84 c0                	test   %al,%al
f010380a:	74 12                	je     f010381e <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f010380c:	83 ec 0c             	sub    $0xc,%esp
f010380f:	68 d4 44 12 f0       	push   $0xf01244d4
f0103814:	e8 72 d7 ff ff       	call   f0100f8b <cprintf>
f0103819:	83 c4 10             	add    $0x10,%esp
f010381c:	eb 61                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010381e:	e8 e1 ed ff ff       	call   f0102604 <isUHeapPlacementStrategyBESTFIT>
f0103823:	84 c0                	test   %al,%al
f0103825:	74 12                	je     f0103839 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103827:	83 ec 0c             	sub    $0xc,%esp
f010382a:	68 00 45 12 f0       	push   $0xf0124500
f010382f:	e8 57 d7 ff ff       	call   f0100f8b <cprintf>
f0103834:	83 c4 10             	add    $0x10,%esp
f0103837:	eb 46                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103839:	e8 db ed ff ff       	call   f0102619 <isUHeapPlacementStrategyNEXTFIT>
f010383e:	84 c0                	test   %al,%al
f0103840:	74 12                	je     f0103854 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103842:	83 ec 0c             	sub    $0xc,%esp
f0103845:	68 2c 45 12 f0       	push   $0xf012452c
f010384a:	e8 3c d7 ff ff       	call   f0100f8b <cprintf>
f010384f:	83 c4 10             	add    $0x10,%esp
f0103852:	eb 2b                	jmp    f010387f <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103854:	e8 d5 ed ff ff       	call   f010262e <isUHeapPlacementStrategyWORSTFIT>
f0103859:	84 c0                	test   %al,%al
f010385b:	74 12                	je     f010386f <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f010385d:	83 ec 0c             	sub    $0xc,%esp
f0103860:	68 58 45 12 f0       	push   $0xf0124558
f0103865:	e8 21 d7 ff ff       	call   f0100f8b <cprintf>
f010386a:	83 c4 10             	add    $0x10,%esp
f010386d:	eb 10                	jmp    f010387f <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f010386f:	83 ec 0c             	sub    $0xc,%esp
f0103872:	68 84 45 12 f0       	push   $0xf0124584
f0103877:	e8 0f d7 ff ff       	call   f0100f8b <cprintf>
f010387c:	83 c4 10             	add    $0x10,%esp

	return 0;
f010387f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103884:	c9                   	leave  
f0103885:	c3                   	ret    

f0103886 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103886:	55                   	push   %ebp
f0103887:	89 e5                	mov    %esp,%ebp
f0103889:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f010388c:	e8 66 ec ff ff       	call   f01024f7 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 b0 45 12 f0       	push   $0xf01245b0
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038a6:	c9                   	leave  
f01038a7:	c3                   	ret    

f01038a8 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038a8:	55                   	push   %ebp
f01038a9:	89 e5                	mov    %esp,%ebp
f01038ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038ae:	e8 54 ec ff ff       	call   f0102507 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038b3:	83 ec 0c             	sub    $0xc,%esp
f01038b6:	68 b0 45 12 f0       	push   $0xf01245b0
f01038bb:	e8 cb d6 ff ff       	call   f0100f8b <cprintf>
f01038c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038c8:	c9                   	leave  
f01038c9:	c3                   	ret    

f01038ca <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01038ca:	55                   	push   %ebp
f01038cb:	89 e5                	mov    %esp,%ebp
f01038cd:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f01038d0:	e8 42 ec ff ff       	call   f0102517 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 e4 45 12 f0       	push   $0xf01245e4
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ea:	c9                   	leave  
f01038eb:	c3                   	ret    

f01038ec <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01038ec:	55                   	push   %ebp
f01038ed:	89 e5                	mov    %esp,%ebp
f01038ef:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f01038f2:	e8 30 ec ff ff       	call   f0102527 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f01038f7:	83 ec 0c             	sub    $0xc,%esp
f01038fa:	68 14 46 12 f0       	push   $0xf0124614
f01038ff:	e8 87 d6 ff ff       	call   f0100f8b <cprintf>
f0103904:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103907:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010390c:	c9                   	leave  
f010390d:	c3                   	ret    

f010390e <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010390e:	55                   	push   %ebp
f010390f:	89 e5                	mov    %esp,%ebp
f0103911:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103914:	e8 1e ec ff ff       	call   f0102537 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103919:	83 ec 0c             	sub    $0xc,%esp
f010391c:	68 44 46 12 f0       	push   $0xf0124644
f0103921:	e8 65 d6 ff ff       	call   f0100f8b <cprintf>
f0103926:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103929:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010392e:	c9                   	leave  
f010392f:	c3                   	ret    

f0103930 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103930:	55                   	push   %ebp
f0103931:	89 e5                	mov    %esp,%ebp
f0103933:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103936:	e8 0c ec ff ff       	call   f0102547 <isKHeapPlacementStrategyCONTALLOC>
f010393b:	84 c0                	test   %al,%al
f010393d:	74 12                	je     f0103951 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 78 46 12 f0       	push   $0xf0124678
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 7c                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103951:	e8 05 ec ff ff       	call   f010255b <isKHeapPlacementStrategyFIRSTFIT>
f0103956:	84 c0                	test   %al,%al
f0103958:	74 12                	je     f010396c <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010395a:	83 ec 0c             	sub    $0xc,%esp
f010395d:	68 b4 46 12 f0       	push   $0xf01246b4
f0103962:	e8 24 d6 ff ff       	call   f0100f8b <cprintf>
f0103967:	83 c4 10             	add    $0x10,%esp
f010396a:	eb 61                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f010396c:	e8 ff eb ff ff       	call   f0102570 <isKHeapPlacementStrategyBESTFIT>
f0103971:	84 c0                	test   %al,%al
f0103973:	74 12                	je     f0103987 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103975:	83 ec 0c             	sub    $0xc,%esp
f0103978:	68 e4 46 12 f0       	push   $0xf01246e4
f010397d:	e8 09 d6 ff ff       	call   f0100f8b <cprintf>
f0103982:	83 c4 10             	add    $0x10,%esp
f0103985:	eb 46                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103987:	e8 f9 eb ff ff       	call   f0102585 <isKHeapPlacementStrategyNEXTFIT>
f010398c:	84 c0                	test   %al,%al
f010398e:	74 12                	je     f01039a2 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103990:	83 ec 0c             	sub    $0xc,%esp
f0103993:	68 10 47 12 f0       	push   $0xf0124710
f0103998:	e8 ee d5 ff ff       	call   f0100f8b <cprintf>
f010399d:	83 c4 10             	add    $0x10,%esp
f01039a0:	eb 2b                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039a2:	e8 f3 eb ff ff       	call   f010259a <isKHeapPlacementStrategyWORSTFIT>
f01039a7:	84 c0                	test   %al,%al
f01039a9:	74 12                	je     f01039bd <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039ab:	83 ec 0c             	sub    $0xc,%esp
f01039ae:	68 3c 47 12 f0       	push   $0xf012473c
f01039b3:	e8 d3 d5 ff ff       	call   f0100f8b <cprintf>
f01039b8:	83 c4 10             	add    $0x10,%esp
f01039bb:	eb 10                	jmp    f01039cd <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	68 6c 47 12 f0       	push   $0xf012476c
f01039c5:	e8 c1 d5 ff ff       	call   f0100f8b <cprintf>
f01039ca:	83 c4 10             	add    $0x10,%esp

	return 0;
f01039cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039d2:	c9                   	leave  
f01039d3:	c3                   	ret    

f01039d4 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f01039d4:	55                   	push   %ebp
f01039d5:	89 e5                	mov    %esp,%ebp
f01039d7:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01039da:	e8 a7 b6 00 00       	call   f010f086 <isBufferingEnabled>
f01039df:	84 c0                	test   %al,%al
f01039e1:	75 12                	jne    f01039f5 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01039e3:	83 ec 0c             	sub    $0xc,%esp
f01039e6:	68 9c 47 12 f0       	push   $0xf012479c
f01039eb:	e8 9b d5 ff ff       	call   f0100f8b <cprintf>
f01039f0:	83 c4 10             	add    $0x10,%esp
f01039f3:	eb 1d                	jmp    f0103a12 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f01039f5:	83 ec 0c             	sub    $0xc,%esp
f01039f8:	6a 00                	push   $0x0
f01039fa:	e8 61 b6 00 00       	call   f010f060 <enableModifiedBuffer>
f01039ff:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a02:	83 ec 0c             	sub    $0xc,%esp
f0103a05:	68 d8 47 12 f0       	push   $0xf01247d8
f0103a0a:	e8 7c d5 ff ff       	call   f0100f8b <cprintf>
f0103a0f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a17:	c9                   	leave  
f0103a18:	c3                   	ret    

f0103a19 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a19:	55                   	push   %ebp
f0103a1a:	89 e5                	mov    %esp,%ebp
f0103a1c:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a1f:	e8 62 b6 00 00       	call   f010f086 <isBufferingEnabled>
f0103a24:	84 c0                	test   %al,%al
f0103a26:	75 12                	jne    f0103a3a <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a28:	83 ec 0c             	sub    $0xc,%esp
f0103a2b:	68 9c 47 12 f0       	push   $0xf012479c
f0103a30:	e8 56 d5 ff ff       	call   f0100f8b <cprintf>
f0103a35:	83 c4 10             	add    $0x10,%esp
f0103a38:	eb 1d                	jmp    f0103a57 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a3a:	83 ec 0c             	sub    $0xc,%esp
f0103a3d:	6a 01                	push   $0x1
f0103a3f:	e8 1c b6 00 00       	call   f010f060 <enableModifiedBuffer>
f0103a44:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a47:	83 ec 0c             	sub    $0xc,%esp
f0103a4a:	68 fc 47 12 f0       	push   $0xf01247fc
f0103a4f:	e8 37 d5 ff ff       	call   f0100f8b <cprintf>
f0103a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a57:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a5c:	c9                   	leave  
f0103a5d:	c3                   	ret    

f0103a5e <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a5e:	55                   	push   %ebp
f0103a5f:	89 e5                	mov    %esp,%ebp
f0103a61:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a64:	83 ec 0c             	sub    $0xc,%esp
f0103a67:	6a 00                	push   $0x0
f0103a69:	e8 0a b6 00 00       	call   f010f078 <enableBuffering>
f0103a6e:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 00                	push   $0x0
f0103a76:	e8 e5 b5 00 00       	call   f010f060 <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 1c 48 12 f0       	push   $0xf012481c
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 01                	push   $0x1
f0103aa0:	e8 d3 b5 00 00       	call   f010f078 <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 01                	push   $0x1
f0103aad:	e8 ae b5 00 00       	call   f010f060 <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ab5:	e8 e4 b5 00 00       	call   f010f09e <getModifiedBufferLength>
f0103aba:	85 c0                	test   %eax,%eax
f0103abc:	75 59                	jne    f0103b17 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103abe:	83 ec 0c             	sub    $0xc,%esp
f0103ac1:	68 38 48 12 f0       	push   $0xf0124838
f0103ac6:	e8 c0 d4 ff ff       	call   f0100f8b <cprintf>
f0103acb:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103ace:	83 ec 08             	sub    $0x8,%esp
f0103ad1:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103ad4:	50                   	push   %eax
f0103ad5:	68 68 48 12 f0       	push   $0xf0124868
f0103ada:	e8 dd b8 01 00       	call   f011f3bc <readline>
f0103adf:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103ae2:	83 ec 04             	sub    $0x4,%esp
f0103ae5:	6a 0a                	push   $0xa
f0103ae7:	6a 00                	push   $0x0
f0103ae9:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103aec:	50                   	push   %eax
f0103aed:	e8 32 be 01 00       	call   f011f924 <strtol>
f0103af2:	83 c4 10             	add    $0x10,%esp
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	50                   	push   %eax
f0103af9:	e8 92 b5 00 00       	call   f010f090 <setModifiedBufferLength>
f0103afe:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b01:	e8 98 b5 00 00       	call   f010f09e <getModifiedBufferLength>
f0103b06:	83 ec 08             	sub    $0x8,%esp
f0103b09:	50                   	push   %eax
f0103b0a:	68 94 48 12 f0       	push   $0xf0124894
f0103b0f:	e8 77 d4 ff ff       	call   f0100f8b <cprintf>
f0103b14:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b17:	83 ec 0c             	sub    $0xc,%esp
f0103b1a:	68 b9 48 12 f0       	push   $0xf01248b9
f0103b1f:	e8 67 d4 ff ff       	call   f0100f8b <cprintf>
f0103b24:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b27:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b2c:	c9                   	leave  
f0103b2d:	c3                   	ret    

f0103b2e <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b2e:	55                   	push   %ebp
f0103b2f:	89 e5                	mov    %esp,%ebp
f0103b31:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b34:	e8 4d b5 00 00       	call   f010f086 <isBufferingEnabled>
f0103b39:	84 c0                	test   %al,%al
f0103b3b:	75 12                	jne    f0103b4f <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b3d:	83 ec 0c             	sub    $0xc,%esp
f0103b40:	68 d4 48 12 f0       	push   $0xf01248d4
f0103b45:	e8 41 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4a:	83 c4 10             	add    $0x10,%esp
f0103b4d:	eb 19                	jmp    f0103b68 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b4f:	e8 1a b5 00 00       	call   f010f06e <isModifiedBufferEnabled>
f0103b54:	84 c0                	test   %al,%al
f0103b56:	75 10                	jne    f0103b68 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b58:	83 ec 0c             	sub    $0xc,%esp
f0103b5b:	68 24 49 12 f0       	push   $0xf0124924
f0103b60:	e8 26 d4 ff ff       	call   f0100f8b <cprintf>
f0103b65:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b6b:	83 c0 04             	add    $0x4,%eax
f0103b6e:	8b 00                	mov    (%eax),%eax
f0103b70:	83 ec 04             	sub    $0x4,%esp
f0103b73:	6a 0a                	push   $0xa
f0103b75:	6a 00                	push   $0x0
f0103b77:	50                   	push   %eax
f0103b78:	e8 a7 bd 01 00       	call   f011f924 <strtol>
f0103b7d:	83 c4 10             	add    $0x10,%esp
f0103b80:	83 ec 0c             	sub    $0xc,%esp
f0103b83:	50                   	push   %eax
f0103b84:	e8 07 b5 00 00       	call   f010f090 <setModifiedBufferLength>
f0103b89:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b8c:	e8 0d b5 00 00       	call   f010f09e <getModifiedBufferLength>
f0103b91:	83 ec 08             	sub    $0x8,%esp
f0103b94:	50                   	push   %eax
f0103b95:	68 94 48 12 f0       	push   $0xf0124894
f0103b9a:	e8 ec d3 ff ff       	call   f0100f8b <cprintf>
f0103b9f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ba2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba7:	c9                   	leave  
f0103ba8:	c3                   	ret    

f0103ba9 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103ba9:	55                   	push   %ebp
f0103baa:	89 e5                	mov    %esp,%ebp
f0103bac:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103baf:	e8 d2 b4 00 00       	call   f010f086 <isBufferingEnabled>
f0103bb4:	84 c0                	test   %al,%al
f0103bb6:	75 12                	jne    f0103bca <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bb8:	83 ec 0c             	sub    $0xc,%esp
f0103bbb:	68 d4 48 12 f0       	push   $0xf01248d4
f0103bc0:	e8 c6 d3 ff ff       	call   f0100f8b <cprintf>
f0103bc5:	83 c4 10             	add    $0x10,%esp
f0103bc8:	eb 19                	jmp    f0103be3 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103bca:	e8 9f b4 00 00       	call   f010f06e <isModifiedBufferEnabled>
f0103bcf:	84 c0                	test   %al,%al
f0103bd1:	75 10                	jne    f0103be3 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	68 24 49 12 f0       	push   $0xf0124924
f0103bdb:	e8 ab d3 ff ff       	call   f0100f8b <cprintf>
f0103be0:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103be3:	e8 b6 b4 00 00       	call   f010f09e <getModifiedBufferLength>
f0103be8:	83 ec 08             	sub    $0x8,%esp
f0103beb:	50                   	push   %eax
f0103bec:	68 6a 49 12 f0       	push   $0xf012496a
f0103bf1:	e8 95 d3 ff ff       	call   f0100f8b <cprintf>
f0103bf6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bfe:	c9                   	leave  
f0103bff:	c3                   	ret    

f0103c00 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c00:	55                   	push   %ebp
f0103c01:	89 e5                	mov    %esp,%ebp
f0103c03:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c06:	83 ec 08             	sub    $0x8,%esp
f0103c09:	ff 75 0c             	pushl  0xc(%ebp)
f0103c0c:	ff 75 08             	pushl  0x8(%ebp)
f0103c0f:	e8 e9 bf 00 00       	call   f010fbfd <tst_handler>
f0103c14:	83 c4 10             	add    $0x10,%esp
}
f0103c17:	c9                   	leave  
f0103c18:	c3                   	ret    

f0103c19 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c19:	55                   	push   %ebp
f0103c1a:	89 e5                	mov    %esp,%ebp
f0103c1c:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c22:	05 00 14 00 00       	add    $0x1400,%eax
f0103c27:	c1 e0 03             	shl    $0x3,%eax
f0103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c2d:	83 ec 04             	sub    $0x4,%esp
f0103c30:	6a 08                	push   $0x8
f0103c32:	ff 75 0c             	pushl  0xc(%ebp)
f0103c35:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c38:	e8 6f c1 01 00       	call   f011fdac <ide_read>
f0103c3d:	83 c4 10             	add    $0x10,%esp
f0103c40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c46:	c9                   	leave  
f0103c47:	c3                   	ret    

f0103c48 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c48:	55                   	push   %ebp
f0103c49:	89 e5                	mov    %esp,%ebp
f0103c4b:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c51:	05 00 14 00 00       	add    $0x1400,%eax
f0103c56:	c1 e0 03             	shl    $0x3,%eax
f0103c59:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c5c:	83 ec 04             	sub    $0x4,%esp
f0103c5f:	6a 08                	push   $0x8
f0103c61:	ff 75 0c             	pushl  0xc(%ebp)
f0103c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c67:	e8 80 c2 01 00       	call   f011feec <ide_write>
f0103c6c:	83 c4 10             	add    $0x10,%esp
f0103c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103c72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103c76:	74 14                	je     f0103c8c <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103c78:	83 ec 04             	sub    $0x4,%esp
f0103c7b:	68 88 49 12 f0       	push   $0xf0124988
f0103c80:	6a 2f                	push   $0x2f
f0103c82:	68 9f 49 12 f0       	push   $0xf012499f
f0103c87:	e8 ad c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c8f:	c9                   	leave  
f0103c90:	c3                   	ret    

f0103c91 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103c91:	55                   	push   %ebp
f0103c92:	89 e5                	mov    %esp,%ebp
f0103c94:	53                   	push   %ebx
f0103c95:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103c98:	c7 05 80 d9 6b f0 00 	movl   $0x0,0xf06bd980
f0103c9f:	00 00 00 
f0103ca2:	c7 05 84 d9 6b f0 00 	movl   $0x0,0xf06bd984
f0103ca9:	00 00 00 
f0103cac:	c7 05 8c d9 6b f0 00 	movl   $0x0,0xf06bd98c
f0103cb3:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cb6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cbd:	e9 e8 00 00 00       	jmp    f0103daa <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cc2:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103cc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ccb:	89 d0                	mov    %edx,%eax
f0103ccd:	01 c0                	add    %eax,%eax
f0103ccf:	01 d0                	add    %edx,%eax
f0103cd1:	c1 e0 03             	shl    $0x3,%eax
f0103cd4:	01 c8                	add    %ecx,%eax
f0103cd6:	83 ec 0c             	sub    $0xc,%esp
f0103cd9:	50                   	push   %eax
f0103cda:	e8 b8 44 00 00       	call   f0108197 <initialize_frame_info>
f0103cdf:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ce2:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103ce8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ceb:	89 d0                	mov    %edx,%eax
f0103ced:	01 c0                	add    %eax,%eax
f0103cef:	01 d0                	add    %edx,%eax
f0103cf1:	c1 e0 03             	shl    $0x3,%eax
f0103cf4:	01 c8                	add    %ecx,%eax
f0103cf6:	85 c0                	test   %eax,%eax
f0103cf8:	75 14                	jne    f0103d0e <initialize_disk_page_file+0x7d>
f0103cfa:	83 ec 04             	sub    $0x4,%esp
f0103cfd:	68 bc 49 12 f0       	push   $0xf01249bc
f0103d02:	6a 56                	push   $0x56
f0103d04:	68 9f 49 12 f0       	push   $0xf012499f
f0103d09:	e8 2b c6 ff ff       	call   f0100339 <_panic>
f0103d0e:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d17:	89 d0                	mov    %edx,%eax
f0103d19:	01 c0                	add    %eax,%eax
f0103d1b:	01 d0                	add    %edx,%eax
f0103d1d:	c1 e0 03             	shl    $0x3,%eax
f0103d20:	01 c8                	add    %ecx,%eax
f0103d22:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103d28:	89 10                	mov    %edx,(%eax)
f0103d2a:	8b 00                	mov    (%eax),%eax
f0103d2c:	85 c0                	test   %eax,%eax
f0103d2e:	74 1f                	je     f0103d4f <initialize_disk_page_file+0xbe>
f0103d30:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103d36:	8b 1d 80 d0 6b f0    	mov    0xf06bd080,%ebx
f0103d3c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103d3f:	89 c8                	mov    %ecx,%eax
f0103d41:	01 c0                	add    %eax,%eax
f0103d43:	01 c8                	add    %ecx,%eax
f0103d45:	c1 e0 03             	shl    $0x3,%eax
f0103d48:	01 d8                	add    %ebx,%eax
f0103d4a:	89 42 04             	mov    %eax,0x4(%edx)
f0103d4d:	eb 19                	jmp    f0103d68 <initialize_disk_page_file+0xd7>
f0103d4f:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d55:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d58:	89 d0                	mov    %edx,%eax
f0103d5a:	01 c0                	add    %eax,%eax
f0103d5c:	01 d0                	add    %edx,%eax
f0103d5e:	c1 e0 03             	shl    $0x3,%eax
f0103d61:	01 c8                	add    %ecx,%eax
f0103d63:	a3 84 d9 6b f0       	mov    %eax,0xf06bd984
f0103d68:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d71:	89 d0                	mov    %edx,%eax
f0103d73:	01 c0                	add    %eax,%eax
f0103d75:	01 d0                	add    %edx,%eax
f0103d77:	c1 e0 03             	shl    $0x3,%eax
f0103d7a:	01 c8                	add    %ecx,%eax
f0103d7c:	a3 80 d9 6b f0       	mov    %eax,0xf06bd980
f0103d81:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103d87:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8a:	89 d0                	mov    %edx,%eax
f0103d8c:	01 c0                	add    %eax,%eax
f0103d8e:	01 d0                	add    %edx,%eax
f0103d90:	c1 e0 03             	shl    $0x3,%eax
f0103d93:	01 c8                	add    %ecx,%eax
f0103d95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103d9c:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f0103da1:	40                   	inc    %eax
f0103da2:	a3 8c d9 6b f0       	mov    %eax,0xf06bd98c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103da7:	ff 45 f4             	incl   -0xc(%ebp)
f0103daa:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103db1:	0f 8e 0b ff ff ff    	jle    f0103cc2 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103db7:	90                   	nop
f0103db8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103dbb:	c9                   	leave  
f0103dbc:	c3                   	ret    

f0103dbd <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103dbd:	55                   	push   %ebp
f0103dbe:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103dc0:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc3:	8b 15 80 d0 6b f0    	mov    0xf06bd080,%edx
f0103dc9:	29 d0                	sub    %edx,%eax
f0103dcb:	c1 f8 03             	sar    $0x3,%eax
f0103dce:	89 c2                	mov    %eax,%edx
f0103dd0:	89 d0                	mov    %edx,%eax
f0103dd2:	c1 e0 02             	shl    $0x2,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	c1 e0 02             	shl    $0x2,%eax
f0103dda:	01 d0                	add    %edx,%eax
f0103ddc:	c1 e0 02             	shl    $0x2,%eax
f0103ddf:	01 d0                	add    %edx,%eax
f0103de1:	89 c1                	mov    %eax,%ecx
f0103de3:	c1 e1 08             	shl    $0x8,%ecx
f0103de6:	01 c8                	add    %ecx,%eax
f0103de8:	89 c1                	mov    %eax,%ecx
f0103dea:	c1 e1 10             	shl    $0x10,%ecx
f0103ded:	01 c8                	add    %ecx,%eax
f0103def:	01 c0                	add    %eax,%eax
f0103df1:	01 d0                	add    %edx,%eax
}
f0103df3:	5d                   	pop    %ebp
f0103df4:	c3                   	ret    

f0103df5 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103df5:	55                   	push   %ebp
f0103df6:	89 e5                	mov    %esp,%ebp
f0103df8:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e02:	83 ec 0c             	sub    $0xc,%esp
f0103e05:	68 90 d9 6b f0       	push   $0xf06bd990
f0103e0a:	e8 07 b8 00 00       	call   f010f616 <acquire_spinlock>
f0103e0f:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e12:	a1 80 d9 6b f0       	mov    0xf06bd980,%eax
f0103e17:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e1e:	75 0c                	jne    f0103e2c <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e20:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e27:	e9 a2 00 00 00       	jmp    f0103ece <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e30:	75 14                	jne    f0103e46 <allocate_disk_frame+0x51>
f0103e32:	83 ec 04             	sub    $0x4,%esp
f0103e35:	68 df 49 12 f0       	push   $0xf01249df
f0103e3a:	6a 7b                	push   $0x7b
f0103e3c:	68 9f 49 12 f0       	push   $0xf012499f
f0103e41:	e8 f3 c4 ff ff       	call   f0100339 <_panic>
f0103e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e49:	8b 00                	mov    (%eax),%eax
f0103e4b:	85 c0                	test   %eax,%eax
f0103e4d:	74 10                	je     f0103e5f <allocate_disk_frame+0x6a>
f0103e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e52:	8b 00                	mov    (%eax),%eax
f0103e54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e57:	8b 52 04             	mov    0x4(%edx),%edx
f0103e5a:	89 50 04             	mov    %edx,0x4(%eax)
f0103e5d:	eb 0b                	jmp    f0103e6a <allocate_disk_frame+0x75>
f0103e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e62:	8b 40 04             	mov    0x4(%eax),%eax
f0103e65:	a3 84 d9 6b f0       	mov    %eax,0xf06bd984
f0103e6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e6d:	8b 40 04             	mov    0x4(%eax),%eax
f0103e70:	85 c0                	test   %eax,%eax
f0103e72:	74 0f                	je     f0103e83 <allocate_disk_frame+0x8e>
f0103e74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e77:	8b 40 04             	mov    0x4(%eax),%eax
f0103e7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103e7d:	8b 12                	mov    (%edx),%edx
f0103e7f:	89 10                	mov    %edx,(%eax)
f0103e81:	eb 0a                	jmp    f0103e8d <allocate_disk_frame+0x98>
f0103e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e86:	8b 00                	mov    (%eax),%eax
f0103e88:	a3 80 d9 6b f0       	mov    %eax,0xf06bd980
f0103e8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103e99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103ea0:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f0103ea5:	48                   	dec    %eax
f0103ea6:	a3 8c d9 6b f0       	mov    %eax,0xf06bd98c
			initialize_frame_info(ptr_frame_info);
f0103eab:	83 ec 0c             	sub    $0xc,%esp
f0103eae:	ff 75 f0             	pushl  -0x10(%ebp)
f0103eb1:	e8 e1 42 00 00       	call   f0108197 <initialize_frame_info>
f0103eb6:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103eb9:	83 ec 0c             	sub    $0xc,%esp
f0103ebc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103ebf:	e8 f9 fe ff ff       	call   f0103dbd <to_disk_frame_number>
f0103ec4:	83 c4 10             	add    $0x10,%esp
f0103ec7:	89 c2                	mov    %eax,%edx
f0103ec9:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ecc:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103ece:	83 ec 0c             	sub    $0xc,%esp
f0103ed1:	68 90 d9 6b f0       	push   $0xf06bd990
f0103ed6:	e8 c2 b7 00 00       	call   f010f69d <release_spinlock>
f0103edb:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103ee1:	c9                   	leave  
f0103ee2:	c3                   	ret    

f0103ee3 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103ee3:	55                   	push   %ebp
f0103ee4:	89 e5                	mov    %esp,%ebp
f0103ee6:	53                   	push   %ebx
f0103ee7:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103eee:	0f 84 ea 00 00 00    	je     f0103fde <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103ef4:	83 ec 0c             	sub    $0xc,%esp
f0103ef7:	68 90 d9 6b f0       	push   $0xf06bd990
f0103efc:	e8 15 b7 00 00       	call   f010f616 <acquire_spinlock>
f0103f01:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f04:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f0a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f0d:	89 d0                	mov    %edx,%eax
f0103f0f:	01 c0                	add    %eax,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	85 c0                	test   %eax,%eax
f0103f1a:	75 17                	jne    f0103f33 <free_disk_frame+0x50>
f0103f1c:	83 ec 04             	sub    $0x4,%esp
f0103f1f:	68 bc 49 12 f0       	push   $0xf01249bc
f0103f24:	68 8e 00 00 00       	push   $0x8e
f0103f29:	68 9f 49 12 f0       	push   $0xf012499f
f0103f2e:	e8 06 c4 ff ff       	call   f0100339 <_panic>
f0103f33:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f39:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f3c:	89 d0                	mov    %edx,%eax
f0103f3e:	01 c0                	add    %eax,%eax
f0103f40:	01 d0                	add    %edx,%eax
f0103f42:	c1 e0 03             	shl    $0x3,%eax
f0103f45:	01 c8                	add    %ecx,%eax
f0103f47:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103f4d:	89 10                	mov    %edx,(%eax)
f0103f4f:	8b 00                	mov    (%eax),%eax
f0103f51:	85 c0                	test   %eax,%eax
f0103f53:	74 1f                	je     f0103f74 <free_disk_frame+0x91>
f0103f55:	8b 15 80 d9 6b f0    	mov    0xf06bd980,%edx
f0103f5b:	8b 1d 80 d0 6b f0    	mov    0xf06bd080,%ebx
f0103f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103f64:	89 c8                	mov    %ecx,%eax
f0103f66:	01 c0                	add    %eax,%eax
f0103f68:	01 c8                	add    %ecx,%eax
f0103f6a:	c1 e0 03             	shl    $0x3,%eax
f0103f6d:	01 d8                	add    %ebx,%eax
f0103f6f:	89 42 04             	mov    %eax,0x4(%edx)
f0103f72:	eb 19                	jmp    f0103f8d <free_disk_frame+0xaa>
f0103f74:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7d:	89 d0                	mov    %edx,%eax
f0103f7f:	01 c0                	add    %eax,%eax
f0103f81:	01 d0                	add    %edx,%eax
f0103f83:	c1 e0 03             	shl    $0x3,%eax
f0103f86:	01 c8                	add    %ecx,%eax
f0103f88:	a3 84 d9 6b f0       	mov    %eax,0xf06bd984
f0103f8d:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103f93:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f96:	89 d0                	mov    %edx,%eax
f0103f98:	01 c0                	add    %eax,%eax
f0103f9a:	01 d0                	add    %edx,%eax
f0103f9c:	c1 e0 03             	shl    $0x3,%eax
f0103f9f:	01 c8                	add    %ecx,%eax
f0103fa1:	a3 80 d9 6b f0       	mov    %eax,0xf06bd980
f0103fa6:	8b 0d 80 d0 6b f0    	mov    0xf06bd080,%ecx
f0103fac:	8b 55 08             	mov    0x8(%ebp),%edx
f0103faf:	89 d0                	mov    %edx,%eax
f0103fb1:	01 c0                	add    %eax,%eax
f0103fb3:	01 d0                	add    %edx,%eax
f0103fb5:	c1 e0 03             	shl    $0x3,%eax
f0103fb8:	01 c8                	add    %ecx,%eax
f0103fba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103fc1:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f0103fc6:	40                   	inc    %eax
f0103fc7:	a3 8c d9 6b f0       	mov    %eax,0xf06bd98c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103fcc:	83 ec 0c             	sub    $0xc,%esp
f0103fcf:	68 90 d9 6b f0       	push   $0xf06bd990
f0103fd4:	e8 c4 b6 00 00       	call   f010f69d <release_spinlock>
f0103fd9:	83 c4 10             	add    $0x10,%esp
f0103fdc:	eb 01                	jmp    f0103fdf <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103fde:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103fdf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fe2:	c9                   	leave  
f0103fe3:	c3                   	ret    

f0103fe4 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103fe4:	55                   	push   %ebp
f0103fe5:	89 e5                	mov    %esp,%ebp
f0103fe7:	53                   	push   %ebx
f0103fe8:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103feb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fee:	c1 e8 16             	shr    $0x16,%eax
f0103ff1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103ff8:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ffb:	01 d0                	add    %edx,%eax
f0103ffd:	8b 00                	mov    (%eax),%eax
f0103fff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104002:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104009:	77 1d                	ja     f0104028 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f010400b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010400e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104013:	83 ec 0c             	sub    $0xc,%esp
f0104016:	50                   	push   %eax
f0104017:	e8 70 55 00 00       	call   f010958c <kheap_virtual_address>
f010401c:	83 c4 10             	add    $0x10,%esp
f010401f:	89 c2                	mov    %eax,%edx
f0104021:	8b 45 14             	mov    0x14(%ebp),%eax
f0104024:	89 10                	mov    %edx,(%eax)
f0104026:	eb 44                	jmp    f010406c <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010402b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104030:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104036:	c1 e8 0c             	shr    $0xc,%eax
f0104039:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010403c:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0104041:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104044:	72 17                	jb     f010405d <get_disk_page_table+0x79>
f0104046:	ff 75 f0             	pushl  -0x10(%ebp)
f0104049:	68 00 4a 12 f0       	push   $0xf0124a00
f010404e:	68 9d 00 00 00       	push   $0x9d
f0104053:	68 9f 49 12 f0       	push   $0xf012499f
f0104058:	e8 dc c2 ff ff       	call   f0100339 <_panic>
f010405d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104060:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104065:	89 c2                	mov    %eax,%edx
f0104067:	8b 45 14             	mov    0x14(%ebp),%eax
f010406a:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010406c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104070:	0f 85 80 00 00 00    	jne    f01040f6 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104076:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010407a:	74 6a                	je     f01040e6 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010407c:	83 ec 0c             	sub    $0xc,%esp
f010407f:	68 00 10 00 00       	push   $0x1000
f0104084:	e8 60 51 00 00       	call   f01091e9 <kmalloc>
f0104089:	83 c4 10             	add    $0x10,%esp
f010408c:	89 c2                	mov    %eax,%edx
f010408e:	8b 45 14             	mov    0x14(%ebp),%eax
f0104091:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104093:	8b 45 14             	mov    0x14(%ebp),%eax
f0104096:	8b 00                	mov    (%eax),%eax
f0104098:	85 c0                	test   %eax,%eax
f010409a:	75 07                	jne    f01040a3 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010409c:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01040a1:	eb 58                	jmp    f01040fb <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01040a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040a6:	c1 e8 16             	shr    $0x16,%eax
f01040a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01040b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01040b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01040b6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040b9:	8b 00                	mov    (%eax),%eax
f01040bb:	83 ec 0c             	sub    $0xc,%esp
f01040be:	50                   	push   %eax
f01040bf:	e8 6b 54 00 00       	call   f010952f <kheap_physical_address>
f01040c4:	83 c4 10             	add    $0x10,%esp
f01040c7:	83 c8 01             	or     $0x1,%eax
f01040ca:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01040cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01040cf:	8b 00                	mov    (%eax),%eax
f01040d1:	83 ec 04             	sub    $0x4,%esp
f01040d4:	68 00 10 00 00       	push   $0x1000
f01040d9:	6a 00                	push   $0x0
f01040db:	50                   	push   %eax
f01040dc:	e8 d1 b6 01 00       	call   f011f7b2 <memset>
f01040e1:	83 c4 10             	add    $0x10,%esp
f01040e4:	eb 10                	jmp    f01040f6 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01040e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01040e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01040ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01040f4:	eb 05                	jmp    f01040fb <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01040f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01040fe:	c9                   	leave  
f01040ff:	c3                   	ret    

f0104100 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104100:	55                   	push   %ebp
f0104101:	89 e5                	mov    %esp,%ebp
f0104103:	83 ec 28             	sub    $0x28,%esp
f0104106:	8b 45 10             	mov    0x10(%ebp),%eax
f0104109:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f010410c:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104110:	74 72                	je     f0104184 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0104112:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104119:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010411c:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0104121:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104124:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104127:	ba 00 00 00 00       	mov    $0x0,%edx
f010412c:	f7 75 f4             	divl   -0xc(%ebp)
f010412f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104132:	29 d0                	sub    %edx,%eax
f0104134:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104137:	73 2f                	jae    f0104168 <pf_add_empty_env_page+0x68>
f0104139:	8b 45 08             	mov    0x8(%ebp),%eax
f010413c:	8b 50 6c             	mov    0x6c(%eax),%edx
f010413f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104144:	29 d0                	sub    %edx,%eax
f0104146:	c1 e0 0c             	shl    $0xc,%eax
f0104149:	2d 00 20 40 11       	sub    $0x11402000,%eax
f010414e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104151:	76 15                	jbe    f0104168 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f010415c:	8d 50 01             	lea    0x1(%eax),%edx
f010415f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104162:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104168:	a1 5c d8 6b f0       	mov    0xf06bd85c,%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	50                   	push   %eax
f0104171:	ff 75 0c             	pushl  0xc(%ebp)
f0104174:	ff 75 08             	pushl  0x8(%ebp)
f0104177:	e8 b5 00 00 00       	call   f0104231 <pf_add_env_page>
f010417c:	83 c4 10             	add    $0x10,%esp
f010417f:	e9 ab 00 00 00       	jmp    f010422f <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104184:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010418b:	76 19                	jbe    f01041a6 <pf_add_empty_env_page+0xa6>
f010418d:	68 30 4a 12 f0       	push   $0xf0124a30
f0104192:	68 56 4a 12 f0       	push   $0xf0124a56
f0104197:	68 dc 00 00 00       	push   $0xdc
f010419c:	68 9f 49 12 f0       	push   $0xf012499f
f01041a1:	e8 93 c1 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01041a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a9:	83 e8 80             	sub    $0xffffff80,%eax
f01041ac:	83 ec 08             	sub    $0x8,%esp
f01041af:	50                   	push   %eax
f01041b0:	ff 75 08             	pushl  0x8(%ebp)
f01041b3:	e8 c8 05 00 00       	call   f0104780 <get_disk_page_directory>
f01041b8:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01041bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01041be:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01041c4:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01041c7:	52                   	push   %edx
f01041c8:	6a 01                	push   $0x1
f01041ca:	ff 75 0c             	pushl  0xc(%ebp)
f01041cd:	50                   	push   %eax
f01041ce:	e8 11 fe ff ff       	call   f0103fe4 <get_disk_page_table>
f01041d3:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01041d9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041dc:	c1 ea 0c             	shr    $0xc,%edx
f01041df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041e5:	c1 e2 02             	shl    $0x2,%edx
f01041e8:	01 d0                	add    %edx,%eax
f01041ea:	8b 00                	mov    (%eax),%eax
f01041ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01041ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01041f2:	85 c0                	test   %eax,%eax
f01041f4:	75 34                	jne    f010422a <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01041f6:	83 ec 0c             	sub    $0xc,%esp
f01041f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01041fc:	50                   	push   %eax
f01041fd:	e8 f3 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104208:	75 07                	jne    f0104211 <pf_add_empty_env_page+0x111>
f010420a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010420f:	eb 1e                	jmp    f010422f <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104211:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104214:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104217:	c1 ea 0c             	shr    $0xc,%edx
f010421a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104220:	c1 e2 02             	shl    $0x2,%edx
f0104223:	01 c2                	add    %eax,%edx
f0104225:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104228:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f010422a:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010422f:	c9                   	leave  
f0104230:	c3                   	ret    

f0104231 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0104231:	55                   	push   %ebp
f0104232:	89 e5                	mov    %esp,%ebp
f0104234:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104237:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010423e:	76 19                	jbe    f0104259 <pf_add_env_page+0x28>
f0104240:	68 30 4a 12 f0       	push   $0xf0124a30
f0104245:	68 56 4a 12 f0       	push   $0xf0124a56
f010424a:	68 f1 00 00 00       	push   $0xf1
f010424f:	68 9f 49 12 f0       	push   $0xf012499f
f0104254:	e8 e0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104259:	8b 45 08             	mov    0x8(%ebp),%eax
f010425c:	83 e8 80             	sub    $0xffffff80,%eax
f010425f:	83 ec 08             	sub    $0x8,%esp
f0104262:	50                   	push   %eax
f0104263:	ff 75 08             	pushl  0x8(%ebp)
f0104266:	e8 15 05 00 00       	call   f0104780 <get_disk_page_directory>
f010426b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010426e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104271:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104277:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010427a:	52                   	push   %edx
f010427b:	6a 01                	push   $0x1
f010427d:	ff 75 0c             	pushl  0xc(%ebp)
f0104280:	50                   	push   %eax
f0104281:	e8 5e fd ff ff       	call   f0103fe4 <get_disk_page_table>
f0104286:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010428c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010428f:	c1 ea 0c             	shr    $0xc,%edx
f0104292:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104298:	c1 e2 02             	shl    $0x2,%edx
f010429b:	01 d0                	add    %edx,%eax
f010429d:	8b 00                	mov    (%eax),%eax
f010429f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01042a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042a5:	85 c0                	test   %eax,%eax
f01042a7:	75 34                	jne    f01042dd <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01042a9:	83 ec 0c             	sub    $0xc,%esp
f01042ac:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01042af:	50                   	push   %eax
f01042b0:	e8 40 fb ff ff       	call   f0103df5 <allocate_disk_frame>
f01042b5:	83 c4 10             	add    $0x10,%esp
f01042b8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042bb:	75 07                	jne    f01042c4 <pf_add_env_page+0x93>
f01042bd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042c2:	eb 31                	jmp    f01042f5 <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042ca:	c1 ea 0c             	shr    $0xc,%edx
f01042cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042d3:	c1 e2 02             	shl    $0x2,%edx
f01042d6:	01 c2                	add    %eax,%edx
f01042d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042db:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01042dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042e0:	83 ec 08             	sub    $0x8,%esp
f01042e3:	ff 75 10             	pushl  0x10(%ebp)
f01042e6:	50                   	push   %eax
f01042e7:	e8 5c f9 ff ff       	call   f0103c48 <write_disk_page>
f01042ec:	83 c4 10             	add    $0x10,%esp
f01042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01042f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01042f5:	c9                   	leave  
f01042f6:	c3                   	ret    

f01042f7 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01042f7:	55                   	push   %ebp
f01042f8:	89 e5                	mov    %esp,%ebp
f01042fa:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01042fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104304:	76 19                	jbe    f010431f <pf_update_env_page+0x28>
f0104306:	68 30 4a 12 f0       	push   $0xf0124a30
f010430b:	68 56 4a 12 f0       	push   $0xf0124a56
f0104310:	68 13 01 00 00       	push   $0x113
f0104315:	68 9f 49 12 f0       	push   $0xf012499f
f010431a:	e8 1a c0 ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010431f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104322:	83 e8 80             	sub    $0xffffff80,%eax
f0104325:	83 ec 08             	sub    $0x8,%esp
f0104328:	50                   	push   %eax
f0104329:	ff 75 08             	pushl  0x8(%ebp)
f010432c:	e8 4f 04 00 00       	call   f0104780 <get_disk_page_directory>
f0104331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104334:	8b 45 08             	mov    0x8(%ebp),%eax
f0104337:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010433d:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104340:	52                   	push   %edx
f0104341:	6a 00                	push   $0x0
f0104343:	ff 75 0c             	pushl  0xc(%ebp)
f0104346:	50                   	push   %eax
f0104347:	e8 98 fc ff ff       	call   f0103fe4 <get_disk_page_table>
f010434c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010434f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 29                	je     f010437f <pf_update_env_page+0x88>
f0104356:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104359:	85 c0                	test   %eax,%eax
f010435b:	0f 84 c5 00 00 00    	je     f0104426 <pf_update_env_page+0x12f>
f0104361:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 d0                	add    %edx,%eax
f0104375:	8b 00                	mov    (%eax),%eax
f0104377:	85 c0                	test   %eax,%eax
f0104379:	0f 85 a7 00 00 00    	jne    f0104426 <pf_update_env_page+0x12f>
	{

		uint32 VA = (uint32)virtual_address ;
f010437f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104382:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0104385:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104388:	85 c0                	test   %eax,%eax
f010438a:	79 09                	jns    f0104395 <pf_update_env_page+0x9e>
f010438c:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0104393:	76 30                	jbe    f01043c5 <pf_update_env_page+0xce>
f0104395:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010439c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010439f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01043a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01043a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043aa:	ba 00 00 00 00       	mov    $0x0,%edx
f01043af:	f7 75 f0             	divl   -0x10(%ebp)
f01043b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043b5:	29 d0                	sub    %edx,%eax
f01043b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01043ba:	77 53                	ja     f010440f <pf_update_env_page+0x118>
f01043bc:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f01043c3:	77 4a                	ja     f010440f <pf_update_env_page+0x118>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f01043c5:	83 ec 04             	sub    $0x4,%esp
f01043c8:	6a 00                	push   $0x0
f01043ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01043cd:	ff 75 08             	pushl  0x8(%ebp)
f01043d0:	e8 2b fd ff ff       	call   f0104100 <pf_add_empty_env_page>
f01043d5:	83 c4 10             	add    $0x10,%esp
f01043d8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01043db:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f01043df:	75 17                	jne    f01043f8 <pf_update_env_page+0x101>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01043e1:	83 ec 04             	sub    $0x4,%esp
f01043e4:	68 6c 4a 12 f0       	push   $0xf0124a6c
f01043e9:	68 43 01 00 00       	push   $0x143
f01043ee:	68 9f 49 12 f0       	push   $0xf012499f
f01043f3:	e8 41 bf ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01043f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01043fb:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0104401:	8d 50 01             	lea    0x1(%eax),%edx
f0104404:	8b 45 08             	mov    0x8(%ebp),%eax
f0104407:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
f010440d:	eb 17                	jmp    f0104426 <pf_update_env_page+0x12f>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010440f:	83 ec 04             	sub    $0x4,%esp
f0104412:	68 b8 4a 12 f0       	push   $0xf0124ab8
f0104417:	68 4c 01 00 00       	push   $0x14c
f010441c:	68 9f 49 12 f0       	push   $0xf012499f
f0104421:	e8 13 bf ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104426:	8b 45 08             	mov    0x8(%ebp),%eax
f0104429:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010442f:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0104432:	52                   	push   %edx
f0104433:	6a 00                	push   $0x0
f0104435:	ff 75 0c             	pushl  0xc(%ebp)
f0104438:	50                   	push   %eax
f0104439:	e8 a6 fb ff ff       	call   f0103fe4 <get_disk_page_table>
f010443e:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104441:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0104444:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104447:	c1 ea 0c             	shr    $0xc,%edx
f010444a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104450:	c1 e2 02             	shl    $0x2,%edx
f0104453:	01 d0                	add    %edx,%eax
f0104455:	8b 00                	mov    (%eax),%eax
f0104457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f010445a:	8b 45 08             	mov    0x8(%ebp),%eax
f010445d:	8b 40 64             	mov    0x64(%eax),%eax
f0104460:	6a 00                	push   $0x0
f0104462:	68 00 00 80 ef       	push   $0xef800000
f0104467:	ff 75 10             	pushl  0x10(%ebp)
f010446a:	50                   	push   %eax
f010446b:	e8 0f 42 00 00       	call   f010867f <map_frame>
f0104470:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f0104473:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f010447a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010447d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104482:	83 ec 08             	sub    $0x8,%esp
f0104485:	50                   	push   %eax
f0104486:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104489:	e8 ba f7 ff ff       	call   f0103c48 <write_disk_page>
f010448e:	83 c4 10             	add    $0x10,%esp
f0104491:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f0104494:	8b 45 10             	mov    0x10(%ebp),%eax
f0104497:	8b 40 08             	mov    0x8(%eax),%eax
f010449a:	40                   	inc    %eax
f010449b:	8b 55 10             	mov    0x10(%ebp),%edx
f010449e:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f01044a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a5:	8b 40 64             	mov    0x64(%eax),%eax
f01044a8:	83 ec 08             	sub    $0x8,%esp
f01044ab:	68 00 00 80 ef       	push   $0xef800000
f01044b0:	50                   	push   %eax
f01044b1:	e8 29 43 00 00       	call   f01087df <unmap_frame>
f01044b6:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01044b9:	8b 45 10             	mov    0x10(%ebp),%eax
f01044bc:	8b 40 08             	mov    0x8(%eax),%eax
f01044bf:	48                   	dec    %eax
f01044c0:	8b 55 10             	mov    0x10(%ebp),%edx
f01044c3:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01044c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01044ca:	8b 80 b0 05 00 00    	mov    0x5b0(%eax),%eax
f01044d0:	8d 50 01             	lea    0x1(%eax),%edx
f01044d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01044d6:	89 90 b0 05 00 00    	mov    %edx,0x5b0(%eax)
	//======================

	return ret;
f01044dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01044df:	c9                   	leave  
f01044e0:	c3                   	ret    

f01044e1 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01044e1:	55                   	push   %ebp
f01044e2:	89 e5                	mov    %esp,%ebp
f01044e4:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01044e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01044ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01044f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044f5:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01044f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01044fb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104501:	85 c0                	test   %eax,%eax
f0104503:	75 0a                	jne    f010450f <pf_read_env_page+0x2e>
f0104505:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010450a:	e9 93 00 00 00       	jmp    f01045a2 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f010450f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104512:	8b 45 08             	mov    0x8(%ebp),%eax
f0104515:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010451b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010451e:	51                   	push   %ecx
f010451f:	6a 00                	push   $0x0
f0104521:	52                   	push   %edx
f0104522:	50                   	push   %eax
f0104523:	e8 bc fa ff ff       	call   f0103fe4 <get_disk_page_table>
f0104528:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010452b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010452e:	85 c0                	test   %eax,%eax
f0104530:	75 07                	jne    f0104539 <pf_read_env_page+0x58>
f0104532:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104537:	eb 69                	jmp    f01045a2 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010453c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010453f:	c1 ea 0c             	shr    $0xc,%edx
f0104542:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104548:	c1 e2 02             	shl    $0x2,%edx
f010454b:	01 d0                	add    %edx,%eax
f010454d:	8b 00                	mov    (%eax),%eax
f010454f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104552:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104556:	75 07                	jne    f010455f <pf_read_env_page+0x7e>
f0104558:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010455d:	eb 43                	jmp    f01045a2 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010455f:	83 ec 08             	sub    $0x8,%esp
f0104562:	ff 75 0c             	pushl  0xc(%ebp)
f0104565:	ff 75 f0             	pushl  -0x10(%ebp)
f0104568:	e8 ac f6 ff ff       	call   f0103c19 <read_disk_page>
f010456d:	83 c4 10             	add    $0x10,%esp
f0104570:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104573:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104576:	8b 45 08             	mov    0x8(%ebp),%eax
f0104579:	8b 40 64             	mov    0x64(%eax),%eax
f010457c:	6a 40                	push   $0x40
f010457e:	6a 00                	push   $0x0
f0104580:	52                   	push   %edx
f0104581:	50                   	push   %eax
f0104582:	e8 41 50 00 00       	call   f01095c8 <pt_set_page_permissions>
f0104587:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010458a:	8b 45 08             	mov    0x8(%ebp),%eax
f010458d:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0104593:	8d 50 01             	lea    0x1(%eax),%edx
f0104596:	8b 45 08             	mov    0x8(%ebp),%eax
f0104599:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
	//======================

	return disk_read_error;
f010459f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01045a2:	c9                   	leave  
f01045a3:	c3                   	ret    

f01045a4 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01045a4:	55                   	push   %ebp
f01045a5:	89 e5                	mov    %esp,%ebp
f01045a7:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01045aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ad:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045b3:	85 c0                	test   %eax,%eax
f01045b5:	74 65                	je     f010461c <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01045b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01045ba:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01045c0:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01045c3:	52                   	push   %edx
f01045c4:	6a 00                	push   $0x0
f01045c6:	ff 75 0c             	pushl  0xc(%ebp)
f01045c9:	50                   	push   %eax
f01045ca:	e8 15 fa ff ff       	call   f0103fe4 <get_disk_page_table>
f01045cf:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01045d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d5:	85 c0                	test   %eax,%eax
f01045d7:	74 46                	je     f010461f <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045dc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045df:	c1 ea 0c             	shr    $0xc,%edx
f01045e2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045e8:	c1 e2 02             	shl    $0x2,%edx
f01045eb:	01 d0                	add    %edx,%eax
f01045ed:	8b 00                	mov    (%eax),%eax
f01045ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01045f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045f8:	c1 ea 0c             	shr    $0xc,%edx
f01045fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104601:	c1 e2 02             	shl    $0x2,%edx
f0104604:	01 d0                	add    %edx,%eax
f0104606:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010460c:	83 ec 0c             	sub    $0xc,%esp
f010460f:	ff 75 f4             	pushl  -0xc(%ebp)
f0104612:	e8 cc f8 ff ff       	call   f0103ee3 <free_disk_frame>
f0104617:	83 c4 10             	add    $0x10,%esp
f010461a:	eb 04                	jmp    f0104620 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010461c:	90                   	nop
f010461d:	eb 01                	jmp    f0104620 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010461f:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104620:	c9                   	leave  
f0104621:	c3                   	ret    

f0104622 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104622:	55                   	push   %ebp
f0104623:	89 e5                	mov    %esp,%ebp
f0104625:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010462f:	e9 c1 00 00 00       	jmp    f01046f5 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104634:	8b 45 08             	mov    0x8(%ebp),%eax
f0104637:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104640:	c1 e2 02             	shl    $0x2,%edx
f0104643:	01 d0                	add    %edx,%eax
f0104645:	8b 00                	mov    (%eax),%eax
f0104647:	83 e0 01             	and    $0x1,%eax
f010464a:	85 c0                	test   %eax,%eax
f010464c:	0f 84 9f 00 00 00    	je     f01046f1 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104652:	8b 45 08             	mov    0x8(%ebp),%eax
f0104655:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010465b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010465e:	c1 e2 02             	shl    $0x2,%edx
f0104661:	01 d0                	add    %edx,%eax
f0104663:	8b 00                	mov    (%eax),%eax
f0104665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010466a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010466d:	83 ec 0c             	sub    $0xc,%esp
f0104670:	ff 75 ec             	pushl  -0x14(%ebp)
f0104673:	e8 14 4f 00 00       	call   f010958c <kheap_virtual_address>
f0104678:	83 c4 10             	add    $0x10,%esp
f010467b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010467e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104685:	eb 3a                	jmp    f01046c1 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104687:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010468a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104691:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104694:	01 d0                	add    %edx,%eax
f0104696:	8b 00                	mov    (%eax),%eax
f0104698:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f010469b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01046a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01046a8:	01 d0                	add    %edx,%eax
f01046aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01046b0:	83 ec 0c             	sub    $0xc,%esp
f01046b3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01046b6:	e8 28 f8 ff ff       	call   f0103ee3 <free_disk_frame>
f01046bb:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01046be:	ff 45 f0             	incl   -0x10(%ebp)
f01046c1:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01046c8:	76 bd                	jbe    f0104687 <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01046ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01046cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01046d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046d6:	c1 e2 02             	shl    $0x2,%edx
f01046d9:	01 d0                	add    %edx,%eax
f01046db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01046e1:	83 ec 0c             	sub    $0xc,%esp
f01046e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01046e7:	e8 5d 4d 00 00       	call   f0109449 <kfree>
f01046ec:	83 c4 10             	add    $0x10,%esp
f01046ef:	eb 01                	jmp    f01046f2 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f01046f1:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046f2:	ff 45 f4             	incl   -0xc(%ebp)
f01046f5:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01046fc:	0f 86 32 ff ff ff    	jbe    f0104634 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010470b:	83 ec 0c             	sub    $0xc,%esp
f010470e:	50                   	push   %eax
f010470f:	e8 35 4d 00 00       	call   f0109449 <kfree>
f0104714:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104717:	8b 45 08             	mov    0x8(%ebp),%eax
f010471a:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104721:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104724:	8b 45 08             	mov    0x8(%ebp),%eax
f0104727:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010472e:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104731:	8b 45 08             	mov    0x8(%ebp),%eax
f0104734:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010473a:	85 c0                	test   %eax,%eax
f010473c:	74 3f                	je     f010477d <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f010473e:	83 ec 0c             	sub    $0xc,%esp
f0104741:	ff 75 08             	pushl  0x8(%ebp)
f0104744:	e8 14 03 00 00       	call   f0104a5d <__pf_remove_env_all_tables>
f0104749:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010474c:	8b 45 08             	mov    0x8(%ebp),%eax
f010474f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	50                   	push   %eax
f0104759:	e8 eb 4c 00 00       	call   f0109449 <kfree>
f010475e:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010476b:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f010476e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104771:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f0104778:	00 00 00 
f010477b:	eb 01                	jmp    f010477e <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010477d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010477e:	c9                   	leave  
f010477f:	c3                   	ret    

f0104780 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104780:	55                   	push   %ebp
f0104781:	89 e5                	mov    %esp,%ebp
f0104783:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104786:	8b 45 08             	mov    0x8(%ebp),%eax
f0104789:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f010478f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104792:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104794:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104797:	8b 00                	mov    (%eax),%eax
f0104799:	85 c0                	test   %eax,%eax
f010479b:	75 5b                	jne    f01047f8 <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010479d:	83 ec 0c             	sub    $0xc,%esp
f01047a0:	68 00 10 00 00       	push   $0x1000
f01047a5:	e8 3f 4a 00 00       	call   f01091e9 <kmalloc>
f01047aa:	83 c4 10             	add    $0x10,%esp
f01047ad:	89 c2                	mov    %eax,%edx
f01047af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b2:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01047b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047b7:	8b 00                	mov    (%eax),%eax
f01047b9:	85 c0                	test   %eax,%eax
f01047bb:	75 07                	jne    f01047c4 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01047bd:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01047c2:	eb 39                	jmp    f01047fd <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01047c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047c7:	8b 00                	mov    (%eax),%eax
f01047c9:	83 ec 0c             	sub    $0xc,%esp
f01047cc:	50                   	push   %eax
f01047cd:	e8 5d 4d 00 00       	call   f010952f <kheap_physical_address>
f01047d2:	83 c4 10             	add    $0x10,%esp
f01047d5:	89 c2                	mov    %eax,%edx
f01047d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01047da:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01047e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047e3:	8b 00                	mov    (%eax),%eax
f01047e5:	83 ec 04             	sub    $0x4,%esp
f01047e8:	68 00 10 00 00       	push   $0x1000
f01047ed:	6a 00                	push   $0x0
f01047ef:	50                   	push   %eax
f01047f0:	e8 bd af 01 00       	call   f011f7b2 <memset>
f01047f5:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01047f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fd:	c9                   	leave  
f01047fe:	c3                   	ret    

f01047ff <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f01047ff:	55                   	push   %ebp
f0104800:	89 e5                	mov    %esp,%ebp
f0104802:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104805:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010480c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104813:	eb 7e                	jmp    f0104893 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104815:	8b 45 08             	mov    0x8(%ebp),%eax
f0104818:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010481e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104821:	c1 e2 02             	shl    $0x2,%edx
f0104824:	01 d0                	add    %edx,%eax
f0104826:	8b 00                	mov    (%eax),%eax
f0104828:	83 e0 01             	and    $0x1,%eax
f010482b:	85 c0                	test   %eax,%eax
f010482d:	74 60                	je     f010488f <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f010482f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104832:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104838:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010483b:	c1 e2 02             	shl    $0x2,%edx
f010483e:	01 d0                	add    %edx,%eax
f0104840:	8b 00                	mov    (%eax),%eax
f0104842:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104847:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f010484a:	83 ec 0c             	sub    $0xc,%esp
f010484d:	ff 75 e8             	pushl  -0x18(%ebp)
f0104850:	e8 37 4d 00 00       	call   f010958c <kheap_virtual_address>
f0104855:	83 c4 10             	add    $0x10,%esp
f0104858:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010485b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104862:	eb 20                	jmp    f0104884 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104864:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010486e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104871:	01 d0                	add    %edx,%eax
f0104873:	8b 00                	mov    (%eax),%eax
f0104875:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104878:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010487c:	74 03                	je     f0104881 <pf_calculate_allocated_pages+0x82>
				counter ++;
f010487e:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104881:	ff 45 ec             	incl   -0x14(%ebp)
f0104884:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010488b:	76 d7                	jbe    f0104864 <pf_calculate_allocated_pages+0x65>
f010488d:	eb 01                	jmp    f0104890 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010488f:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104890:	ff 45 f4             	incl   -0xc(%ebp)
f0104893:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010489a:	0f 86 75 ff ff ff    	jbe    f0104815 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f01048a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01048a3:	c9                   	leave  
f01048a4:	c3                   	ret    

f01048a5 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f01048a5:	55                   	push   %ebp
f01048a6:	89 e5                	mov    %esp,%ebp
f01048a8:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f01048ab:	83 ec 0c             	sub    $0xc,%esp
f01048ae:	68 90 d9 6b f0       	push   $0xf06bd990
f01048b3:	e8 5e ad 00 00       	call   f010f616 <acquire_spinlock>
f01048b8:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f01048bb:	a1 8c d9 6b f0       	mov    0xf06bd98c,%eax
f01048c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	68 90 d9 6b f0       	push   $0xf06bd990
f01048cb:	e8 cd ad 00 00       	call   f010f69d <release_spinlock>
f01048d0:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f01048d6:	c9                   	leave  
f01048d7:	c3                   	ret    

f01048d8 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f01048d8:	55                   	push   %ebp
f01048d9:	89 e5                	mov    %esp,%ebp
f01048db:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f01048de:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e1:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f01048e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ea:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01048ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048ef:	8b 00                	mov    (%eax),%eax
f01048f1:	85 c0                	test   %eax,%eax
f01048f3:	75 5b                	jne    f0104950 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f01048f5:	83 ec 0c             	sub    $0xc,%esp
f01048f8:	68 00 10 00 00       	push   $0x1000
f01048fd:	e8 e7 48 00 00       	call   f01091e9 <kmalloc>
f0104902:	83 c4 10             	add    $0x10,%esp
f0104905:	89 c2                	mov    %eax,%edx
f0104907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490a:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010490c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010490f:	8b 00                	mov    (%eax),%eax
f0104911:	85 c0                	test   %eax,%eax
f0104913:	75 07                	jne    f010491c <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104915:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010491a:	eb 39                	jmp    f0104955 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010491c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010491f:	8b 00                	mov    (%eax),%eax
f0104921:	83 ec 0c             	sub    $0xc,%esp
f0104924:	50                   	push   %eax
f0104925:	e8 05 4c 00 00       	call   f010952f <kheap_physical_address>
f010492a:	83 c4 10             	add    $0x10,%esp
f010492d:	89 c2                	mov    %eax,%edx
f010492f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104932:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010493b:	8b 00                	mov    (%eax),%eax
f010493d:	83 ec 04             	sub    $0x4,%esp
f0104940:	68 00 10 00 00       	push   $0x1000
f0104945:	6a 00                	push   $0x0
f0104947:	50                   	push   %eax
f0104948:	e8 65 ae 01 00       	call   f011f7b2 <memset>
f010494d:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104950:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104955:	c9                   	leave  
f0104956:	c3                   	ret    

f0104957 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104957:	55                   	push   %ebp
f0104958:	89 e5                	mov    %esp,%ebp
f010495a:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010495d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104964:	76 19                	jbe    f010497f <__pf_write_env_table+0x28>
f0104966:	68 30 4a 12 f0       	push   $0xf0124a30
f010496b:	68 56 4a 12 f0       	push   $0xf0124a56
f0104970:	68 91 02 00 00       	push   $0x291
f0104975:	68 9f 49 12 f0       	push   $0xf012499f
f010497a:	e8 ba b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010497f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104982:	05 88 00 00 00       	add    $0x88,%eax
f0104987:	83 ec 08             	sub    $0x8,%esp
f010498a:	50                   	push   %eax
f010498b:	ff 75 08             	pushl  0x8(%ebp)
f010498e:	e8 45 ff ff ff       	call   f01048d8 <get_disk_table_directory>
f0104993:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104996:	8b 45 08             	mov    0x8(%ebp),%eax
f0104999:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010499f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049a2:	c1 ea 16             	shr    $0x16,%edx
f01049a5:	c1 e2 02             	shl    $0x2,%edx
f01049a8:	01 d0                	add    %edx,%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01049af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049b2:	85 c0                	test   %eax,%eax
f01049b4:	75 34                	jne    f01049ea <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01049b6:	83 ec 0c             	sub    $0xc,%esp
f01049b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01049bc:	50                   	push   %eax
f01049bd:	e8 33 f4 ff ff       	call   f0103df5 <allocate_disk_frame>
f01049c2:	83 c4 10             	add    $0x10,%esp
f01049c5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01049c8:	75 07                	jne    f01049d1 <__pf_write_env_table+0x7a>
f01049ca:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01049cf:	eb 31                	jmp    f0104a02 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01049d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01049d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01049da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049dd:	c1 ea 16             	shr    $0x16,%edx
f01049e0:	c1 e2 02             	shl    $0x2,%edx
f01049e3:	01 c2                	add    %eax,%edx
f01049e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049e8:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01049ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01049ed:	83 ec 08             	sub    $0x8,%esp
f01049f0:	ff 75 10             	pushl  0x10(%ebp)
f01049f3:	50                   	push   %eax
f01049f4:	e8 4f f2 ff ff       	call   f0103c48 <write_disk_page>
f01049f9:	83 c4 10             	add    $0x10,%esp
f01049fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01049ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a02:	c9                   	leave  
f0104a03:	c3                   	ret    

f0104a04 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a04:	55                   	push   %ebp
f0104a05:	89 e5                	mov    %esp,%ebp
f0104a07:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a0d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a13:	85 c0                	test   %eax,%eax
f0104a15:	75 07                	jne    f0104a1e <__pf_read_env_table+0x1a>
f0104a17:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a1c:	eb 3d                	jmp    f0104a5b <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a21:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a2a:	c1 ea 16             	shr    $0x16,%edx
f0104a2d:	c1 e2 02             	shl    $0x2,%edx
f0104a30:	01 d0                	add    %edx,%eax
f0104a32:	8b 00                	mov    (%eax),%eax
f0104a34:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a3b:	75 07                	jne    f0104a44 <__pf_read_env_table+0x40>
f0104a3d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a42:	eb 17                	jmp    f0104a5b <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a44:	83 ec 08             	sub    $0x8,%esp
f0104a47:	ff 75 10             	pushl  0x10(%ebp)
f0104a4a:	ff 75 f4             	pushl  -0xc(%ebp)
f0104a4d:	e8 c7 f1 ff ff       	call   f0103c19 <read_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a6c:	85 c0                	test   %eax,%eax
f0104a6e:	74 52                	je     f0104ac2 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a77:	eb 3e                	jmp    f0104ab7 <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a85:	c1 e2 02             	shl    $0x2,%edx
f0104a88:	01 d0                	add    %edx,%eax
f0104a8a:	8b 00                	mov    (%eax),%eax
f0104a8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a92:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104a98:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a9b:	c1 e2 02             	shl    $0x2,%edx
f0104a9e:	01 d0                	add    %edx,%eax
f0104aa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104aa6:	83 ec 0c             	sub    $0xc,%esp
f0104aa9:	ff 75 f0             	pushl  -0x10(%ebp)
f0104aac:	e8 32 f4 ff ff       	call   f0103ee3 <free_disk_frame>
f0104ab1:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ab4:	ff 45 f4             	incl   -0xc(%ebp)
f0104ab7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104abe:	76 b9                	jbe    f0104a79 <__pf_remove_env_all_tables+0x1c>
f0104ac0:	eb 01                	jmp    f0104ac3 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ac2:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104ac3:	c9                   	leave  
f0104ac4:	c3                   	ret    

f0104ac5 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104ac5:	55                   	push   %ebp
f0104ac6:	89 e5                	mov    %esp,%ebp
f0104ac8:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104acb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104acf:	75 10                	jne    f0104ae1 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ad1:	83 ec 0c             	sub    $0xc,%esp
f0104ad4:	68 34 4b 12 f0       	push   $0xf0124b34
f0104ad9:	e8 ad c4 ff ff       	call   f0100f8b <cprintf>
f0104ade:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ae4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104aea:	85 c0                	test   %eax,%eax
f0104aec:	74 43                	je     f0104b31 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104af7:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104afa:	c1 ea 16             	shr    $0x16,%edx
f0104afd:	c1 e2 02             	shl    $0x2,%edx
f0104b00:	01 d0                	add    %edx,%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b0a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104b10:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b13:	c1 ea 16             	shr    $0x16,%edx
f0104b16:	c1 e2 02             	shl    $0x2,%edx
f0104b19:	01 d0                	add    %edx,%eax
f0104b1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b21:	83 ec 0c             	sub    $0xc,%esp
f0104b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b27:	e8 b7 f3 ff ff       	call   f0103ee3 <free_disk_frame>
f0104b2c:	83 c4 10             	add    $0x10,%esp
f0104b2f:	eb 01                	jmp    f0104b32 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b31:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b32:	c9                   	leave  
f0104b33:	c3                   	ret    

f0104b34 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b34:	55                   	push   %ebp
f0104b35:	89 e5                	mov    %esp,%ebp
f0104b37:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b3a:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b41:	eb 1f                	jmp    f0104b62 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b46:	83 ec 04             	sub    $0x4,%esp
f0104b49:	6a 08                	push   $0x8
f0104b4b:	ff 75 08             	pushl  0x8(%ebp)
f0104b4e:	50                   	push   %eax
f0104b4f:	e8 98 b3 01 00       	call   f011feec <ide_write>
f0104b54:	83 c4 10             	add    $0x10,%esp
f0104b57:	85 c0                	test   %eax,%eax
f0104b59:	75 12                	jne    f0104b6d <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b5b:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104b62:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104b69:	7e d8                	jle    f0104b43 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6b:	eb 01                	jmp    f0104b6e <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104b6d:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104b6e:	90                   	nop
f0104b6f:	c9                   	leave  
f0104b70:	c3                   	ret    

f0104b71 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104b71:	55                   	push   %ebp
  pushl %eax
f0104b72:	50                   	push   %eax
  pushl %ebx
f0104b73:	53                   	push   %ebx
  pushl %ecx
f0104b74:	51                   	push   %ecx
  pushl %edx
f0104b75:	52                   	push   %edx
  pushl %esi
f0104b76:	56                   	push   %esi
  pushl %edi
f0104b77:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104b78:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104b7c:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104b80:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104b82:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104b84:	5f                   	pop    %edi
  popl %esi
f0104b85:	5e                   	pop    %esi
  popl %edx
f0104b86:	5a                   	pop    %edx
  popl %ecx
f0104b87:	59                   	pop    %ecx
  popl %ebx
f0104b88:	5b                   	pop    %ebx
  popl %eax
f0104b89:	58                   	pop    %eax
  popl %ebp
f0104b8a:	5d                   	pop    %ebp
  ret
f0104b8b:	c3                   	ret    

f0104b8c <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104b8c:	55                   	push   %ebp
f0104b8d:	89 e5                	mov    %esp,%ebp
f0104b8f:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	0f b6 c0             	movzbl %al,%eax
f0104b98:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104b9f:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104ba2:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104ba8:	ee                   	out    %al,(%dx)
f0104ba9:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bb3:	89 c2                	mov    %eax,%edx
f0104bb5:	ec                   	in     (%dx),%al
f0104bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bb9:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bbc:	0f b6 c0             	movzbl %al,%eax
}
f0104bbf:	c9                   	leave  
f0104bc0:	c3                   	ret    

f0104bc1 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104bc1:	55                   	push   %ebp
f0104bc2:	89 e5                	mov    %esp,%ebp
f0104bc4:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bc7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bca:	0f b6 c0             	movzbl %al,%eax
f0104bcd:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104bd4:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd7:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104bda:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104bdd:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104bde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104be1:	0f b6 c0             	movzbl %al,%eax
f0104be4:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104beb:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104bee:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104bf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104bf4:	ee                   	out    %al,(%dx)
}
f0104bf5:	90                   	nop
f0104bf6:	c9                   	leave  
f0104bf7:	c3                   	ret    

f0104bf8 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104bf8:	55                   	push   %ebp
f0104bf9:	89 e5                	mov    %esp,%ebp
f0104bfb:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104bfe:	c7 05 68 d9 6b f0 00 	movl   $0x0,0xf06bd968
f0104c05:	00 00 00 
f0104c08:	c7 05 6c d9 6b f0 00 	movl   $0x0,0xf06bd96c
f0104c0f:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c12:	83 ec 08             	sub    $0x8,%esp
f0104c15:	68 bf 6b 10 f0       	push   $0xf0106bbf
f0104c1a:	6a 00                	push   $0x0
f0104c1c:	e8 00 90 00 00       	call   f010dc21 <irq_install_handler>
f0104c21:	83 c4 10             	add    $0x10,%esp
}
f0104c24:	90                   	nop
f0104c25:	c9                   	leave  
f0104c26:	c3                   	ret    

f0104c27 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c27:	55                   	push   %ebp
f0104c28:	89 e5                	mov    %esp,%ebp
f0104c2a:	53                   	push   %ebx
f0104c2b:	83 ec 24             	sub    $0x24,%esp
f0104c2e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c31:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c34:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c3b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c3f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c42:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c45:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c46:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c4a:	77 48                	ja     f0104c94 <kclock_start+0x6d>
f0104c4c:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c53:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c57:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c5d:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c5e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c62:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104c67:	99                   	cltd   
f0104c68:	f7 fb                	idiv   %ebx
f0104c6a:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104c70:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104c74:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104c79:	99                   	cltd   
f0104c7a:	f7 fb                	idiv   %ebx
f0104c7c:	89 c3                	mov    %eax,%ebx
f0104c7e:	89 c8                	mov    %ecx,%eax
f0104c80:	99                   	cltd   
f0104c81:	f7 fb                	idiv   %ebx
f0104c83:	0f b7 c0             	movzwl %ax,%eax
f0104c86:	83 ec 0c             	sub    $0xc,%esp
f0104c89:	50                   	push   %eax
f0104c8a:	e8 b3 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104c8f:	83 c4 10             	add    $0x10,%esp
f0104c92:	eb 13                	jmp    f0104ca7 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104c94:	6a 35                	push   $0x35
f0104c96:	68 58 4b 12 f0       	push   $0xf0124b58
f0104c9b:	6a 41                	push   $0x41
f0104c9d:	68 b4 4b 12 f0       	push   $0xf0124bb4
f0104ca2:	e8 92 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ca7:	83 ec 0c             	sub    $0xc,%esp
f0104caa:	6a 00                	push   $0x0
f0104cac:	e8 43 23 00 00       	call   f0106ff4 <irq_clear_mask>
f0104cb1:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cb4:	90                   	nop
f0104cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cb8:	c9                   	leave  
f0104cb9:	c3                   	ret    

f0104cba <kclock_stop>:

void
kclock_stop(void)
{
f0104cba:	55                   	push   %ebp
f0104cbb:	89 e5                	mov    %esp,%ebp
f0104cbd:	83 ec 18             	sub    $0x18,%esp
f0104cc0:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104cc7:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ccb:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104cce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cd1:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104cd2:	83 ec 0c             	sub    $0xc,%esp
f0104cd5:	6a 00                	push   $0x0
f0104cd7:	e8 a3 22 00 00       	call   f0106f7f <irq_set_mask>
f0104cdc:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104cdf:	90                   	nop
f0104ce0:	c9                   	leave  
f0104ce1:	c3                   	ret    

f0104ce2 <kclock_resume>:

void
kclock_resume(void)
{
f0104ce2:	55                   	push   %ebp
f0104ce3:	89 e5                	mov    %esp,%ebp
f0104ce5:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104ce8:	e8 f5 01 00 00       	call   f0104ee2 <kclock_read_cnt0_latch>
f0104ced:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104cf1:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104cf6:	77 06                	ja     f0104cfe <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104cf8:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104cfe:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d02:	83 e0 01             	and    $0x1,%eax
f0104d05:	66 85 c0             	test   %ax,%ax
f0104d08:	74 09                	je     f0104d13 <kclock_resume+0x31>
		cnt0++;
f0104d0a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d0e:	40                   	inc    %eax
f0104d0f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d13:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d1a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d1e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d24:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d25:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d29:	83 ec 0c             	sub    $0xc,%esp
f0104d2c:	50                   	push   %eax
f0104d2d:	e8 10 01 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d32:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d35:	83 ec 0c             	sub    $0xc,%esp
f0104d38:	6a 00                	push   $0x0
f0104d3a:	e8 b5 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d3f:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d42:	90                   	nop
f0104d43:	c9                   	leave  
f0104d44:	c3                   	ret    

f0104d45 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d45:	55                   	push   %ebp
f0104d46:	89 e5                	mov    %esp,%ebp
f0104d48:	83 ec 28             	sub    $0x28,%esp
f0104d4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d4e:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d51:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d58:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d5c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d62:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104d67:	83 ec 0c             	sub    $0xc,%esp
f0104d6a:	50                   	push   %eax
f0104d6b:	e8 d2 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104d70:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d73:	83 ec 0c             	sub    $0xc,%esp
f0104d76:	6a 00                	push   $0x0
f0104d78:	e8 77 22 00 00       	call   f0106ff4 <irq_clear_mask>
f0104d7d:	83 c4 10             	add    $0x10,%esp
}
f0104d80:	90                   	nop
f0104d81:	c9                   	leave  
f0104d82:	c3                   	ret    

f0104d83 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104d83:	55                   	push   %ebp
f0104d84:	89 e5                	mov    %esp,%ebp
f0104d86:	56                   	push   %esi
f0104d87:	53                   	push   %ebx
f0104d88:	83 ec 20             	sub    $0x20,%esp
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104d91:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104d95:	0f 87 8a 00 00 00    	ja     f0104e25 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104d9b:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104d9f:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104da4:	99                   	cltd   
f0104da5:	f7 fe                	idiv   %esi
f0104da7:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dad:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104db1:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104db6:	99                   	cltd   
f0104db7:	f7 fb                	idiv   %ebx
f0104db9:	89 c6                	mov    %eax,%esi
f0104dbb:	89 c8                	mov    %ecx,%eax
f0104dbd:	99                   	cltd   
f0104dbe:	f7 fe                	idiv   %esi
f0104dc0:	89 c3                	mov    %eax,%ebx
f0104dc2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104dc6:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104dcb:	99                   	cltd   
f0104dcc:	f7 f9                	idiv   %ecx
f0104dce:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dd4:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104dd8:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ddd:	99                   	cltd   
f0104dde:	f7 fe                	idiv   %esi
f0104de0:	89 c6                	mov    %eax,%esi
f0104de2:	89 c8                	mov    %ecx,%eax
f0104de4:	99                   	cltd   
f0104de5:	f7 fe                	idiv   %esi
f0104de7:	25 01 00 00 80       	and    $0x80000001,%eax
f0104dec:	85 c0                	test   %eax,%eax
f0104dee:	79 05                	jns    f0104df5 <kclock_set_quantum+0x72>
f0104df0:	48                   	dec    %eax
f0104df1:	83 c8 fe             	or     $0xfffffffe,%eax
f0104df4:	40                   	inc    %eax
f0104df5:	01 d8                	add    %ebx,%eax
f0104df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104dfa:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e01:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e05:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e08:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e0b:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e0f:	0f b7 c0             	movzwl %ax,%eax
f0104e12:	83 ec 0c             	sub    $0xc,%esp
f0104e15:	50                   	push   %eax
f0104e16:	e8 27 00 00 00       	call   f0104e42 <kclock_write_cnt0_LSB_first>
f0104e1b:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e1e:	e8 97 fe ff ff       	call   f0104cba <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e23:	eb 16                	jmp    f0104e3b <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e25:	6a 35                	push   $0x35
f0104e27:	68 58 4b 12 f0       	push   $0xf0124b58
f0104e2c:	68 ea 00 00 00       	push   $0xea
f0104e31:	68 b4 4b 12 f0       	push   $0xf0124bb4
f0104e36:	e8 fe b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e3b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e3e:	5b                   	pop    %ebx
f0104e3f:	5e                   	pop    %esi
f0104e40:	5d                   	pop    %ebp
f0104e41:	c3                   	ret    

f0104e42 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e42:	55                   	push   %ebp
f0104e43:	89 e5                	mov    %esp,%ebp
f0104e45:	83 ec 28             	sub    $0x28,%esp
f0104e48:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e4b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e4f:	e8 7b 23 00 00       	call   f01071cf <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e57:	0f b6 c0             	movzbl %al,%eax
f0104e5a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104e61:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104e64:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e67:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e6a:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e6e:	66 c1 e8 08          	shr    $0x8,%ax
f0104e72:	0f b6 c0             	movzbl %al,%eax
f0104e75:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104e7c:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104e7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e85:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104e86:	e8 96 23 00 00       	call   f0107221 <popcli>

}
f0104e8b:	90                   	nop
f0104e8c:	c9                   	leave  
f0104e8d:	c3                   	ret    

f0104e8e <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104e8e:	55                   	push   %ebp
f0104e8f:	89 e5                	mov    %esp,%ebp
f0104e91:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104e94:	e8 36 23 00 00       	call   f01071cf <pushcli>
f0104e99:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ea3:	89 c2                	mov    %eax,%edx
f0104ea5:	ec                   	in     (%dx),%al
f0104ea6:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104ea9:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eac:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104eaf:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104eb9:	89 c2                	mov    %eax,%edx
f0104ebb:	ec                   	in     (%dx),%al
f0104ebc:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104ebf:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104ec2:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104ec5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104ec9:	c1 e0 08             	shl    $0x8,%eax
f0104ecc:	89 c2                	mov    %eax,%edx
f0104ece:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ed2:	09 d0                	or     %edx,%eax
f0104ed4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ed8:	e8 44 23 00 00       	call   f0107221 <popcli>
	return cnt0 ;
f0104edd:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104ee0:	c9                   	leave  
f0104ee1:	c3                   	ret    

f0104ee2 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104ee2:	55                   	push   %ebp
f0104ee3:	89 e5                	mov    %esp,%ebp
f0104ee5:	83 ec 30             	sub    $0x30,%esp
f0104ee8:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104ef2:	89 c2                	mov    %eax,%edx
f0104ef4:	ec                   	in     (%dx),%al
f0104ef5:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104ef8:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104efb:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104efe:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f05:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f09:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f0f:	ee                   	out    %al,(%dx)
f0104f10:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f1a:	89 c2                	mov    %eax,%edx
f0104f1c:	ec                   	in     (%dx),%al
f0104f1d:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f20:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f23:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f26:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f30:	89 c2                	mov    %eax,%edx
f0104f32:	ec                   	in     (%dx),%al
f0104f33:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f36:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f39:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f3c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f40:	c1 e0 08             	shl    $0x8,%eax
f0104f43:	89 c2                	mov    %eax,%edx
f0104f45:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f49:	09 d0                	or     %edx,%eax
f0104f4b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f4f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f53:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f5a:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f5d:	8a 45 df             	mov    -0x21(%ebp),%al
f0104f60:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104f63:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104f64:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104f67:	c9                   	leave  
f0104f68:	c3                   	ret    

f0104f69 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104f69:	55                   	push   %ebp
f0104f6a:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f70:	74 1d                	je     f0104f8f <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f85:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f88:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104f8f:	90                   	nop
f0104f90:	5d                   	pop    %ebp
f0104f91:	c3                   	ret    

f0104f92 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104f92:	55                   	push   %ebp
f0104f93:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104f95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f99:	74 08                	je     f0104fa3 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fa1:	eb 05                	jmp    f0104fa8 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fa3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fa8:	5d                   	pop    %ebp
f0104fa9:	c3                   	ret    

f0104faa <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
f0104fad:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb4:	75 16                	jne    f0104fcc <enqueue+0x22>
f0104fb6:	68 c8 4b 12 f0       	push   $0xf0124bc8
f0104fbb:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0104fc0:	6a 34                	push   $0x34
f0104fc2:	68 eb 4b 12 f0       	push   $0xf0124beb
f0104fc7:	e8 6d b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f0104fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd0:	74 66                	je     f0105038 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104fd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104fd6:	75 14                	jne    f0104fec <enqueue+0x42>
f0104fd8:	83 ec 04             	sub    $0x4,%esp
f0104fdb:	68 04 4c 12 f0       	push   $0xf0124c04
f0104fe0:	6a 37                	push   $0x37
f0104fe2:	68 eb 4b 12 f0       	push   $0xf0124beb
f0104fe7:	e8 4d b3 ff ff       	call   f0100339 <_panic>
f0104fec:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fef:	8b 10                	mov    (%eax),%edx
f0104ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ff4:	89 50 08             	mov    %edx,0x8(%eax)
f0104ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ffa:	8b 40 08             	mov    0x8(%eax),%eax
f0104ffd:	85 c0                	test   %eax,%eax
f0104fff:	74 0d                	je     f010500e <enqueue+0x64>
f0105001:	8b 45 08             	mov    0x8(%ebp),%eax
f0105004:	8b 00                	mov    (%eax),%eax
f0105006:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105009:	89 50 0c             	mov    %edx,0xc(%eax)
f010500c:	eb 09                	jmp    f0105017 <enqueue+0x6d>
f010500e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105011:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105014:	89 50 04             	mov    %edx,0x4(%eax)
f0105017:	8b 45 08             	mov    0x8(%ebp),%eax
f010501a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010501d:	89 10                	mov    %edx,(%eax)
f010501f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105022:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105029:	8b 45 08             	mov    0x8(%ebp),%eax
f010502c:	8b 40 0c             	mov    0xc(%eax),%eax
f010502f:	8d 50 01             	lea    0x1(%eax),%edx
f0105032:	8b 45 08             	mov    0x8(%ebp),%eax
f0105035:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105038:	90                   	nop
f0105039:	c9                   	leave  
f010503a:	c3                   	ret    

f010503b <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010503b:	55                   	push   %ebp
f010503c:	89 e5                	mov    %esp,%ebp
f010503e:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105041:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105045:	75 0a                	jne    f0105051 <dequeue+0x16>
f0105047:	b8 00 00 00 00       	mov    $0x0,%eax
f010504c:	e9 a0 00 00 00       	jmp    f01050f1 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105051:	8b 45 08             	mov    0x8(%ebp),%eax
f0105054:	8b 40 04             	mov    0x4(%eax),%eax
f0105057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010505a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010505e:	0f 84 8a 00 00 00    	je     f01050ee <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105064:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105068:	75 14                	jne    f010507e <dequeue+0x43>
f010506a:	83 ec 04             	sub    $0x4,%esp
f010506d:	68 27 4c 12 f0       	push   $0xf0124c27
f0105072:	6a 44                	push   $0x44
f0105074:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105079:	e8 bb b2 ff ff       	call   f0100339 <_panic>
f010507e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105081:	8b 40 08             	mov    0x8(%eax),%eax
f0105084:	85 c0                	test   %eax,%eax
f0105086:	74 11                	je     f0105099 <dequeue+0x5e>
f0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508b:	8b 40 08             	mov    0x8(%eax),%eax
f010508e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105091:	8b 52 0c             	mov    0xc(%edx),%edx
f0105094:	89 50 0c             	mov    %edx,0xc(%eax)
f0105097:	eb 0c                	jmp    f01050a5 <dequeue+0x6a>
f0105099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010509c:	8b 50 0c             	mov    0xc(%eax),%edx
f010509f:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a2:	89 50 04             	mov    %edx,0x4(%eax)
f01050a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ab:	85 c0                	test   %eax,%eax
f01050ad:	74 11                	je     f01050c0 <dequeue+0x85>
f01050af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050b2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050b8:	8b 52 08             	mov    0x8(%edx),%edx
f01050bb:	89 50 08             	mov    %edx,0x8(%eax)
f01050be:	eb 0b                	jmp    f01050cb <dequeue+0x90>
f01050c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c3:	8b 50 08             	mov    0x8(%eax),%edx
f01050c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c9:	89 10                	mov    %edx,(%eax)
f01050cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01050d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050df:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e2:	8b 40 0c             	mov    0xc(%eax),%eax
f01050e5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01050eb:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f01050ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01050f1:	c9                   	leave  
f01050f2:	c3                   	ret    

f01050f3 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f01050f3:	55                   	push   %ebp
f01050f4:	89 e5                	mov    %esp,%ebp
f01050f6:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01050f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01050fd:	75 16                	jne    f0105115 <remove_from_queue+0x22>
f01050ff:	68 c8 4b 12 f0       	push   $0xf0124bc8
f0105104:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105109:	6a 4e                	push   $0x4e
f010510b:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105110:	e8 24 b2 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105119:	0f 84 8a 00 00 00    	je     f01051a9 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f010511f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105123:	75 14                	jne    f0105139 <remove_from_queue+0x46>
f0105125:	83 ec 04             	sub    $0x4,%esp
f0105128:	68 27 4c 12 f0       	push   $0xf0124c27
f010512d:	6a 52                	push   $0x52
f010512f:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105134:	e8 00 b2 ff ff       	call   f0100339 <_panic>
f0105139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010513c:	8b 40 08             	mov    0x8(%eax),%eax
f010513f:	85 c0                	test   %eax,%eax
f0105141:	74 11                	je     f0105154 <remove_from_queue+0x61>
f0105143:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105146:	8b 40 08             	mov    0x8(%eax),%eax
f0105149:	8b 55 0c             	mov    0xc(%ebp),%edx
f010514c:	8b 52 0c             	mov    0xc(%edx),%edx
f010514f:	89 50 0c             	mov    %edx,0xc(%eax)
f0105152:	eb 0c                	jmp    f0105160 <remove_from_queue+0x6d>
f0105154:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105157:	8b 50 0c             	mov    0xc(%eax),%edx
f010515a:	8b 45 08             	mov    0x8(%ebp),%eax
f010515d:	89 50 04             	mov    %edx,0x4(%eax)
f0105160:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105163:	8b 40 0c             	mov    0xc(%eax),%eax
f0105166:	85 c0                	test   %eax,%eax
f0105168:	74 11                	je     f010517b <remove_from_queue+0x88>
f010516a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105170:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105173:	8b 52 08             	mov    0x8(%edx),%edx
f0105176:	89 50 08             	mov    %edx,0x8(%eax)
f0105179:	eb 0b                	jmp    f0105186 <remove_from_queue+0x93>
f010517b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517e:	8b 50 08             	mov    0x8(%eax),%edx
f0105181:	8b 45 08             	mov    0x8(%ebp),%eax
f0105184:	89 10                	mov    %edx,(%eax)
f0105186:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105190:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105193:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010519a:	8b 45 08             	mov    0x8(%ebp),%eax
f010519d:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a0:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01051a6:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051a9:	90                   	nop
f01051aa:	c9                   	leave  
f01051ab:	c3                   	ret    

f01051ac <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ac:	55                   	push   %ebp
f01051ad:	89 e5                	mov    %esp,%ebp
f01051af:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051b6:	75 07                	jne    f01051bf <find_env_in_queue+0x13>
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 58                	jmp    f0105217 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01051bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01051c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c9:	8b 00                	mov    (%eax),%eax
f01051cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051ce:	eb 19                	jmp    f01051e9 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01051d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051d3:	8b 40 10             	mov    0x10(%eax),%eax
f01051d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01051d9:	75 05                	jne    f01051e0 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01051db:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051de:	eb 37                	jmp    f0105217 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01051e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e3:	8b 40 08             	mov    0x8(%eax),%eax
f01051e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01051e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01051ed:	74 08                	je     f01051f7 <find_env_in_queue+0x4b>
f01051ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01051f2:	8b 40 08             	mov    0x8(%eax),%eax
f01051f5:	eb 05                	jmp    f01051fc <find_env_in_queue+0x50>
f01051f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fc:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ff:	89 42 08             	mov    %eax,0x8(%edx)
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 40 08             	mov    0x8(%eax),%eax
f0105208:	85 c0                	test   %eax,%eax
f010520a:	75 c4                	jne    f01051d0 <find_env_in_queue+0x24>
f010520c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105210:	75 be                	jne    f01051d0 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105212:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105217:	c9                   	leave  
f0105218:	c3                   	ret    

f0105219 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0105219:	55                   	push   %ebp
f010521a:	89 e5                	mov    %esp,%ebp
f010521c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f010521f:	83 ec 0c             	sub    $0xc,%esp
f0105222:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105227:	e8 ea a3 00 00       	call   f010f616 <acquire_spinlock>
f010522c:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f010522f:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105234:	85 c0                	test   %eax,%eax
f0105236:	74 11                	je     f0105249 <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105238:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010523d:	83 ec 0c             	sub    $0xc,%esp
f0105240:	50                   	push   %eax
f0105241:	e8 03 42 00 00       	call   f0109449 <kfree>
f0105246:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f0105249:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f010524e:	85 c0                	test   %eax,%eax
f0105250:	74 11                	je     f0105263 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105252:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f0105257:	83 ec 0c             	sub    $0xc,%esp
f010525a:	50                   	push   %eax
f010525b:	e8 e9 41 00 00       	call   f0109449 <kfree>
f0105260:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105263:	83 ec 0c             	sub    $0xc,%esp
f0105266:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010526b:	e8 2d a4 00 00       	call   f010f69d <release_spinlock>
f0105270:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105273:	90                   	nop
f0105274:	c9                   	leave  
f0105275:	c3                   	ret    

f0105276 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105276:	55                   	push   %ebp
f0105277:	89 e5                	mov    %esp,%ebp
f0105279:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010527c:	83 ec 0c             	sub    $0xc,%esp
f010527f:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105284:	e8 a6 a5 00 00       	call   f010f82f <holding_spinlock>
f0105289:	83 c4 10             	add    $0x10,%esp
f010528c:	85 c0                	test   %eax,%eax
f010528e:	75 17                	jne    f01052a7 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105290:	83 ec 04             	sub    $0x4,%esp
f0105293:	68 48 4c 12 f0       	push   $0xf0124c48
f0105298:	68 85 00 00 00       	push   $0x85
f010529d:	68 eb 4b 12 f0       	push   $0xf0124beb
f01052a2:	e8 92 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ab:	75 19                	jne    f01052c6 <sched_insert_ready0+0x50>
f01052ad:	68 89 4c 12 f0       	push   $0xf0124c89
f01052b2:	68 d6 4b 12 f0       	push   $0xf0124bd6
f01052b7:	68 88 00 00 00       	push   $0x88
f01052bc:	68 eb 4b 12 f0       	push   $0xf0124beb
f01052c1:	e8 73 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01052c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01052c9:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01052d0:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01052d5:	83 ec 08             	sub    $0x8,%esp
f01052d8:	ff 75 08             	pushl  0x8(%ebp)
f01052db:	50                   	push   %eax
f01052dc:	e8 c9 fc ff ff       	call   f0104faa <enqueue>
f01052e1:	83 c4 10             	add    $0x10,%esp
	}
}
f01052e4:	90                   	nop
f01052e5:	c9                   	leave  
f01052e6:	c3                   	ret    

f01052e7 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f01052e7:	55                   	push   %ebp
f01052e8:	89 e5                	mov    %esp,%ebp
f01052ea:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052ed:	83 ec 0c             	sub    $0xc,%esp
f01052f0:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01052f5:	e8 35 a5 00 00       	call   f010f82f <holding_spinlock>
f01052fa:	83 c4 10             	add    $0x10,%esp
f01052fd:	85 c0                	test   %eax,%eax
f01052ff:	75 17                	jne    f0105318 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105301:	83 ec 04             	sub    $0x4,%esp
f0105304:	68 48 4c 12 f0       	push   $0xf0124c48
f0105309:	68 97 00 00 00       	push   $0x97
f010530e:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105313:	e8 21 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010531c:	74 0b                	je     f0105329 <sched_remove_ready+0x42>
f010531e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105321:	8b 40 18             	mov    0x18(%eax),%eax
f0105324:	83 f8 01             	cmp    $0x1,%eax
f0105327:	74 19                	je     f0105342 <sched_remove_ready+0x5b>
f0105329:	68 98 4c 12 f0       	push   $0xf0124c98
f010532e:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105333:	68 9a 00 00 00       	push   $0x9a
f0105338:	68 eb 4b 12 f0       	push   $0xf0124beb
f010533d:	e8 f7 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105349:	e9 e4 00 00 00       	jmp    f0105432 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010534e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105351:	8b 40 10             	mov    0x10(%eax),%eax
f0105354:	89 c2                	mov    %eax,%edx
f0105356:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010535b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010535e:	c1 e1 04             	shl    $0x4,%ecx
f0105361:	01 c8                	add    %ecx,%eax
f0105363:	83 ec 08             	sub    $0x8,%esp
f0105366:	52                   	push   %edx
f0105367:	50                   	push   %eax
f0105368:	e8 3f fe ff ff       	call   f01051ac <find_env_in_queue>
f010536d:	83 c4 10             	add    $0x10,%esp
f0105370:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105377:	0f 84 b2 00 00 00    	je     f010542f <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010537d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105381:	75 17                	jne    f010539a <sched_remove_ready+0xb3>
f0105383:	83 ec 04             	sub    $0x4,%esp
f0105386:	68 27 4c 12 f0       	push   $0xf0124c27
f010538b:	68 a1 00 00 00       	push   $0xa1
f0105390:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105395:	e8 9f af ff ff       	call   f0100339 <_panic>
f010539a:	8b 45 08             	mov    0x8(%ebp),%eax
f010539d:	8b 40 08             	mov    0x8(%eax),%eax
f01053a0:	85 c0                	test   %eax,%eax
f01053a2:	74 11                	je     f01053b5 <sched_remove_ready+0xce>
f01053a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a7:	8b 40 08             	mov    0x8(%eax),%eax
f01053aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01053b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01053b3:	eb 16                	jmp    f01053cb <sched_remove_ready+0xe4>
f01053b5:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01053ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053bd:	c1 e2 04             	shl    $0x4,%edx
f01053c0:	01 c2                	add    %eax,%edx
f01053c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01053c8:	89 42 04             	mov    %eax,0x4(%edx)
f01053cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01053d1:	85 c0                	test   %eax,%eax
f01053d3:	74 11                	je     f01053e6 <sched_remove_ready+0xff>
f01053d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053d8:	8b 40 0c             	mov    0xc(%eax),%eax
f01053db:	8b 55 08             	mov    0x8(%ebp),%edx
f01053de:	8b 52 08             	mov    0x8(%edx),%edx
f01053e1:	89 50 08             	mov    %edx,0x8(%eax)
f01053e4:	eb 15                	jmp    f01053fb <sched_remove_ready+0x114>
f01053e6:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01053eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053ee:	c1 e2 04             	shl    $0x4,%edx
f01053f1:	01 c2                	add    %eax,%edx
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 02                	mov    %eax,(%edx)
f01053fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105405:	8b 45 08             	mov    0x8(%ebp),%eax
f0105408:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010540f:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105417:	c1 e2 04             	shl    $0x4,%edx
f010541a:	01 d0                	add    %edx,%eax
f010541c:	8b 50 0c             	mov    0xc(%eax),%edx
f010541f:	4a                   	dec    %edx
f0105420:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105423:	8b 45 08             	mov    0x8(%ebp),%eax
f0105426:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010542d:	eb 14                	jmp    f0105443 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010542f:	ff 45 f4             	incl   -0xc(%ebp)
f0105432:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105437:	0f b6 c0             	movzbl %al,%eax
f010543a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010543d:	0f 8f 0b ff ff ff    	jg     f010534e <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105443:	c9                   	leave  
f0105444:	c3                   	ret    

f0105445 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105445:	55                   	push   %ebp
f0105446:	89 e5                	mov    %esp,%ebp
f0105448:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105453:	e8 d7 a3 00 00       	call   f010f82f <holding_spinlock>
f0105458:	83 c4 10             	add    $0x10,%esp
f010545b:	85 c0                	test   %eax,%eax
f010545d:	75 17                	jne    f0105476 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010545f:	83 ec 04             	sub    $0x4,%esp
f0105462:	68 48 4c 12 f0       	push   $0xf0124c48
f0105467:	68 b0 00 00 00       	push   $0xb0
f010546c:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105471:	e8 c3 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105476:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010547a:	75 19                	jne    f0105495 <sched_insert_new+0x50>
f010547c:	68 89 4c 12 f0       	push   $0xf0124c89
f0105481:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105486:	68 b3 00 00 00       	push   $0xb3
f010548b:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105490:	e8 a4 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105495:	8b 45 08             	mov    0x8(%ebp),%eax
f0105498:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010549f:	83 ec 08             	sub    $0x8,%esp
f01054a2:	ff 75 08             	pushl  0x8(%ebp)
f01054a5:	68 30 d3 6b f0       	push   $0xf06bd330
f01054aa:	e8 fb fa ff ff       	call   f0104faa <enqueue>
f01054af:	83 c4 10             	add    $0x10,%esp
	}
}
f01054b2:	90                   	nop
f01054b3:	c9                   	leave  
f01054b4:	c3                   	ret    

f01054b5 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054b5:	55                   	push   %ebp
f01054b6:	89 e5                	mov    %esp,%ebp
f01054b8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054bb:	83 ec 0c             	sub    $0xc,%esp
f01054be:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01054c3:	e8 67 a3 00 00       	call   f010f82f <holding_spinlock>
f01054c8:	83 c4 10             	add    $0x10,%esp
f01054cb:	85 c0                	test   %eax,%eax
f01054cd:	75 17                	jne    f01054e6 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054cf:	83 ec 04             	sub    $0x4,%esp
f01054d2:	68 48 4c 12 f0       	push   $0xf0124c48
f01054d7:	68 c1 00 00 00       	push   $0xc1
f01054dc:	68 eb 4b 12 f0       	push   $0xf0124beb
f01054e1:	e8 53 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f01054e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054ea:	74 0b                	je     f01054f7 <sched_remove_new+0x42>
f01054ec:	8b 45 08             	mov    0x8(%ebp),%eax
f01054ef:	8b 40 18             	mov    0x18(%eax),%eax
f01054f2:	83 f8 04             	cmp    $0x4,%eax
f01054f5:	74 19                	je     f0105510 <sched_remove_new+0x5b>
f01054f7:	68 c4 4c 12 f0       	push   $0xf0124cc4
f01054fc:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105501:	68 c4 00 00 00       	push   $0xc4
f0105506:	68 eb 4b 12 f0       	push   $0xf0124beb
f010550b:	e8 29 ae ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105510:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105514:	75 17                	jne    f010552d <sched_remove_new+0x78>
f0105516:	83 ec 04             	sub    $0x4,%esp
f0105519:	68 27 4c 12 f0       	push   $0xf0124c27
f010551e:	68 c6 00 00 00       	push   $0xc6
f0105523:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105528:	e8 0c ae ff ff       	call   f0100339 <_panic>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 08             	mov    0x8(%eax),%eax
f0105533:	85 c0                	test   %eax,%eax
f0105535:	74 11                	je     f0105548 <sched_remove_new+0x93>
f0105537:	8b 45 08             	mov    0x8(%ebp),%eax
f010553a:	8b 40 08             	mov    0x8(%eax),%eax
f010553d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105540:	8b 52 0c             	mov    0xc(%edx),%edx
f0105543:	89 50 0c             	mov    %edx,0xc(%eax)
f0105546:	eb 0b                	jmp    f0105553 <sched_remove_new+0x9e>
f0105548:	8b 45 08             	mov    0x8(%ebp),%eax
f010554b:	8b 40 0c             	mov    0xc(%eax),%eax
f010554e:	a3 34 d3 6b f0       	mov    %eax,0xf06bd334
f0105553:	8b 45 08             	mov    0x8(%ebp),%eax
f0105556:	8b 40 0c             	mov    0xc(%eax),%eax
f0105559:	85 c0                	test   %eax,%eax
f010555b:	74 11                	je     f010556e <sched_remove_new+0xb9>
f010555d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105560:	8b 40 0c             	mov    0xc(%eax),%eax
f0105563:	8b 55 08             	mov    0x8(%ebp),%edx
f0105566:	8b 52 08             	mov    0x8(%edx),%edx
f0105569:	89 50 08             	mov    %edx,0x8(%eax)
f010556c:	eb 0b                	jmp    f0105579 <sched_remove_new+0xc4>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	a3 30 d3 6b f0       	mov    %eax,0xf06bd330
f0105579:	8b 45 08             	mov    0x8(%ebp),%eax
f010557c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105583:	8b 45 08             	mov    0x8(%ebp),%eax
f0105586:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010558d:	a1 3c d3 6b f0       	mov    0xf06bd33c,%eax
f0105592:	48                   	dec    %eax
f0105593:	a3 3c d3 6b f0       	mov    %eax,0xf06bd33c
		env->env_status = ENV_UNKNOWN;
f0105598:	8b 45 08             	mov    0x8(%ebp),%eax
f010559b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055a2:	90                   	nop
f01055a3:	c9                   	leave  
f01055a4:	c3                   	ret    

f01055a5 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055a5:	55                   	push   %ebp
f01055a6:	89 e5                	mov    %esp,%ebp
f01055a8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ab:	83 ec 0c             	sub    $0xc,%esp
f01055ae:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01055b3:	e8 77 a2 00 00       	call   f010f82f <holding_spinlock>
f01055b8:	83 c4 10             	add    $0x10,%esp
f01055bb:	85 c0                	test   %eax,%eax
f01055bd:	75 17                	jne    f01055d6 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01055bf:	83 ec 04             	sub    $0x4,%esp
f01055c2:	68 48 4c 12 f0       	push   $0xf0124c48
f01055c7:	68 d2 00 00 00       	push   $0xd2
f01055cc:	68 eb 4b 12 f0       	push   $0xf0124beb
f01055d1:	e8 63 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01055d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055da:	75 19                	jne    f01055f5 <sched_insert_exit+0x50>
f01055dc:	68 89 4c 12 f0       	push   $0xf0124c89
f01055e1:	68 d6 4b 12 f0       	push   $0xf0124bd6
f01055e6:	68 d5 00 00 00       	push   $0xd5
f01055eb:	68 eb 4b 12 f0       	push   $0xf0124beb
f01055f0:	e8 44 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f01055f5:	e8 8c 9a 00 00       	call   f010f086 <isBufferingEnabled>
f01055fa:	84 c0                	test   %al,%al
f01055fc:	74 0e                	je     f010560c <sched_insert_exit+0x67>
f01055fe:	83 ec 0c             	sub    $0xc,%esp
f0105601:	ff 75 08             	pushl  0x8(%ebp)
f0105604:	e8 01 70 00 00       	call   f010c60a <cleanup_buffers>
f0105609:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010560c:	8b 45 08             	mov    0x8(%ebp),%eax
f010560f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105616:	83 ec 08             	sub    $0x8,%esp
f0105619:	ff 75 08             	pushl  0x8(%ebp)
f010561c:	68 40 d3 6b f0       	push   $0xf06bd340
f0105621:	e8 84 f9 ff ff       	call   f0104faa <enqueue>
f0105626:	83 c4 10             	add    $0x10,%esp
	}
}
f0105629:	90                   	nop
f010562a:	c9                   	leave  
f010562b:	c3                   	ret    

f010562c <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010562c:	55                   	push   %ebp
f010562d:	89 e5                	mov    %esp,%ebp
f010562f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105632:	83 ec 0c             	sub    $0xc,%esp
f0105635:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010563a:	e8 f0 a1 00 00       	call   f010f82f <holding_spinlock>
f010563f:	83 c4 10             	add    $0x10,%esp
f0105642:	85 c0                	test   %eax,%eax
f0105644:	75 17                	jne    f010565d <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105646:	83 ec 04             	sub    $0x4,%esp
f0105649:	68 48 4c 12 f0       	push   $0xf0124c48
f010564e:	68 e3 00 00 00       	push   $0xe3
f0105653:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105658:	e8 dc ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010565d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105661:	74 0b                	je     f010566e <sched_remove_exit+0x42>
f0105663:	8b 45 08             	mov    0x8(%ebp),%eax
f0105666:	8b 40 18             	mov    0x18(%eax),%eax
f0105669:	83 f8 05             	cmp    $0x5,%eax
f010566c:	74 19                	je     f0105687 <sched_remove_exit+0x5b>
f010566e:	68 f0 4c 12 f0       	push   $0xf0124cf0
f0105673:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105678:	68 e6 00 00 00       	push   $0xe6
f010567d:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105682:	e8 b2 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105687:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010568b:	75 17                	jne    f01056a4 <sched_remove_exit+0x78>
f010568d:	83 ec 04             	sub    $0x4,%esp
f0105690:	68 27 4c 12 f0       	push   $0xf0124c27
f0105695:	68 e8 00 00 00       	push   $0xe8
f010569a:	68 eb 4b 12 f0       	push   $0xf0124beb
f010569f:	e8 95 ac ff ff       	call   f0100339 <_panic>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 08             	mov    0x8(%eax),%eax
f01056aa:	85 c0                	test   %eax,%eax
f01056ac:	74 11                	je     f01056bf <sched_remove_exit+0x93>
f01056ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b1:	8b 40 08             	mov    0x8(%eax),%eax
f01056b4:	8b 55 08             	mov    0x8(%ebp),%edx
f01056b7:	8b 52 0c             	mov    0xc(%edx),%edx
f01056ba:	89 50 0c             	mov    %edx,0xc(%eax)
f01056bd:	eb 0b                	jmp    f01056ca <sched_remove_exit+0x9e>
f01056bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c2:	8b 40 0c             	mov    0xc(%eax),%eax
f01056c5:	a3 44 d3 6b f0       	mov    %eax,0xf06bd344
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 11                	je     f01056e5 <sched_remove_exit+0xb9>
f01056d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056d7:	8b 40 0c             	mov    0xc(%eax),%eax
f01056da:	8b 55 08             	mov    0x8(%ebp),%edx
f01056dd:	8b 52 08             	mov    0x8(%edx),%edx
f01056e0:	89 50 08             	mov    %edx,0x8(%eax)
f01056e3:	eb 0b                	jmp    f01056f0 <sched_remove_exit+0xc4>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	a3 40 d3 6b f0       	mov    %eax,0xf06bd340
f01056f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105704:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f0105709:	48                   	dec    %eax
f010570a:	a3 4c d3 6b f0       	mov    %eax,0xf06bd34c
		env->env_status = ENV_UNKNOWN;
f010570f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105712:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105719:	90                   	nop
f010571a:	c9                   	leave  
f010571b:	c3                   	ret    

f010571c <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010571c:	55                   	push   %ebp
f010571d:	89 e5                	mov    %esp,%ebp
f010571f:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105722:	83 ec 0c             	sub    $0xc,%esp
f0105725:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010572a:	e8 e7 9e 00 00       	call   f010f616 <acquire_spinlock>
f010572f:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105736:	75 19                	jne    f0105751 <sched_new_env+0x35>
f0105738:	68 1b 4d 12 f0       	push   $0xf0124d1b
f010573d:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105742:	68 f6 00 00 00       	push   $0xf6
f0105747:	68 eb 4b 12 f0       	push   $0xf0124beb
f010574c:	e8 e8 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	ff 75 08             	pushl  0x8(%ebp)
f0105757:	e8 e9 fc ff ff       	call   f0105445 <sched_insert_new>
f010575c:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010575f:	83 ec 0c             	sub    $0xc,%esp
f0105762:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105767:	e8 31 9f 00 00       	call   f010f69d <release_spinlock>
f010576c:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f010576f:	90                   	nop
f0105770:	c9                   	leave  
f0105771:	c3                   	ret    

f0105772 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105772:	55                   	push   %ebp
f0105773:	89 e5                	mov    %esp,%ebp
f0105775:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105778:	83 ec 0c             	sub    $0xc,%esp
f010577b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105780:	e8 91 9e 00 00       	call   f010f616 <acquire_spinlock>
f0105785:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578f:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105794:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105797:	eb 53                	jmp    f01057ec <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105799:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579c:	8b 40 10             	mov    0x10(%eax),%eax
f010579f:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a2:	75 40                	jne    f01057e4 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057a4:	83 ec 0c             	sub    $0xc,%esp
f01057a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01057aa:	e8 06 fd ff ff       	call   f01054b5 <sched_remove_new>
f01057af:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057b2:	83 ec 0c             	sub    $0xc,%esp
f01057b5:	ff 75 f4             	pushl  -0xc(%ebp)
f01057b8:	e8 b9 fa ff ff       	call   f0105276 <sched_insert_ready0>
f01057bd:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f01057c0:	e8 47 19 00 00       	call   f010710c <mycpu>
f01057c5:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01057cb:	85 c0                	test   %eax,%eax
f01057cd:	75 46                	jne    f0105815 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057cf:	83 ec 0c             	sub    $0xc,%esp
f01057d2:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01057d7:	e8 c1 9e 00 00       	call   f010f69d <release_spinlock>
f01057dc:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f01057df:	e8 ad 0f 00 00       	call   f0106791 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057e4:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f01057e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057f0:	74 08                	je     f01057fa <sched_run_env+0x88>
f01057f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057f5:	8b 40 08             	mov    0x8(%eax),%eax
f01057f8:	eb 05                	jmp    f01057ff <sched_run_env+0x8d>
f01057fa:	b8 00 00 00 00       	mov    $0x0,%eax
f01057ff:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f0105804:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105809:	85 c0                	test   %eax,%eax
f010580b:	75 8c                	jne    f0105799 <sched_run_env+0x27>
f010580d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105811:	75 86                	jne    f0105799 <sched_run_env+0x27>
f0105813:	eb 01                	jmp    f0105816 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105815:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105816:	83 ec 0c             	sub    $0xc,%esp
f0105819:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010581e:	e8 7a 9e 00 00       	call   f010f69d <release_spinlock>
f0105823:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105826:	90                   	nop
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105837:	e8 f3 9f 00 00       	call   f010f82f <holding_spinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
f010583f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105842:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105846:	75 10                	jne    f0105858 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105848:	83 ec 0c             	sub    $0xc,%esp
f010584b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105850:	e8 c1 9d 00 00       	call   f010f616 <acquire_spinlock>
f0105855:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105858:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010585f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105866:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010586a:	75 59                	jne    f01058c5 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010586c:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105871:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105874:	eb 28                	jmp    f010589e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105876:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105879:	8b 40 10             	mov    0x10(%eax),%eax
f010587c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587f:	75 15                	jne    f0105896 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105881:	83 ec 0c             	sub    $0xc,%esp
f0105884:	ff 75 f4             	pushl  -0xc(%ebp)
f0105887:	e8 29 fc ff ff       	call   f01054b5 <sched_remove_new>
f010588c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f010588f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105896:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f010589b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	74 08                	je     f01058ac <sched_exit_env+0x83>
f01058a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a7:	8b 40 08             	mov    0x8(%eax),%eax
f01058aa:	eb 05                	jmp    f01058b1 <sched_exit_env+0x88>
f01058ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01058b1:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f01058b6:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f01058bb:	85 c0                	test   %eax,%eax
f01058bd:	75 b7                	jne    f0105876 <sched_exit_env+0x4d>
f01058bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058c3:	75 b1                	jne    f0105876 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f01058c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058c9:	0f 85 67 01 00 00    	jne    f0105a36 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01058cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058d6:	e9 47 01 00 00       	jmp    f0105a22 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01058db:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01058e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058e3:	c1 e2 04             	shl    $0x4,%edx
f01058e6:	01 d0                	add    %edx,%eax
f01058e8:	8b 00                	mov    (%eax),%eax
f01058ea:	85 c0                	test   %eax,%eax
f01058ec:	0f 84 27 01 00 00    	je     f0105a19 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f01058f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01058f9:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01058fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105901:	c1 e2 04             	shl    $0x4,%edx
f0105904:	01 d0                	add    %edx,%eax
f0105906:	8b 00                	mov    (%eax),%eax
f0105908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010590b:	e9 d1 00 00 00       	jmp    f01059e1 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105910:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105913:	8b 40 10             	mov    0x10(%eax),%eax
f0105916:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105919:	0f 85 af 00 00 00    	jne    f01059ce <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010591f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105923:	75 17                	jne    f010593c <sched_exit_env+0x113>
f0105925:	83 ec 04             	sub    $0x4,%esp
f0105928:	68 27 4c 12 f0       	push   $0xf0124c27
f010592d:	68 44 01 00 00       	push   $0x144
f0105932:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105937:	e8 fd a9 ff ff       	call   f0100339 <_panic>
f010593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010593f:	8b 40 08             	mov    0x8(%eax),%eax
f0105942:	85 c0                	test   %eax,%eax
f0105944:	74 11                	je     f0105957 <sched_exit_env+0x12e>
f0105946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105949:	8b 40 08             	mov    0x8(%eax),%eax
f010594c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010594f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105952:	89 50 0c             	mov    %edx,0xc(%eax)
f0105955:	eb 16                	jmp    f010596d <sched_exit_env+0x144>
f0105957:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010595c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010595f:	c1 e2 04             	shl    $0x4,%edx
f0105962:	01 c2                	add    %eax,%edx
f0105964:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	89 42 04             	mov    %eax,0x4(%edx)
f010596d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105970:	8b 40 0c             	mov    0xc(%eax),%eax
f0105973:	85 c0                	test   %eax,%eax
f0105975:	74 11                	je     f0105988 <sched_exit_env+0x15f>
f0105977:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597a:	8b 40 0c             	mov    0xc(%eax),%eax
f010597d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105980:	8b 52 08             	mov    0x8(%edx),%edx
f0105983:	89 50 08             	mov    %edx,0x8(%eax)
f0105986:	eb 15                	jmp    f010599d <sched_exit_env+0x174>
f0105988:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010598d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105990:	c1 e2 04             	shl    $0x4,%edx
f0105993:	01 c2                	add    %eax,%edx
f0105995:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105998:	8b 40 08             	mov    0x8(%eax),%eax
f010599b:	89 02                	mov    %eax,(%edx)
f010599d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059aa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059b1:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01059b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059b9:	c1 e2 04             	shl    $0x4,%edx
f01059bc:	01 d0                	add    %edx,%eax
f01059be:	8b 50 0c             	mov    0xc(%eax),%edx
f01059c1:	4a                   	dec    %edx
f01059c2:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f01059c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f01059cc:	eb 4b                	jmp    f0105a19 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01059ce:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01059d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d6:	c1 e2 04             	shl    $0x4,%edx
f01059d9:	01 d0                	add    %edx,%eax
f01059db:	8b 40 08             	mov    0x8(%eax),%eax
f01059de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059e1:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01059e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059e9:	c1 e2 04             	shl    $0x4,%edx
f01059ec:	01 d0                	add    %edx,%eax
f01059ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059f2:	74 08                	je     f01059fc <sched_exit_env+0x1d3>
f01059f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f7:	8b 52 08             	mov    0x8(%edx),%edx
f01059fa:	eb 05                	jmp    f0105a01 <sched_exit_env+0x1d8>
f01059fc:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a01:	89 50 08             	mov    %edx,0x8(%eax)
f0105a04:	8b 40 08             	mov    0x8(%eax),%eax
f0105a07:	85 c0                	test   %eax,%eax
f0105a09:	0f 85 01 ff ff ff    	jne    f0105910 <sched_exit_env+0xe7>
f0105a0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a13:	0f 85 f7 fe ff ff    	jne    f0105910 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a19:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a1d:	75 16                	jne    f0105a35 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a1f:	ff 45 ec             	incl   -0x14(%ebp)
f0105a22:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105a27:	0f b6 c0             	movzbl %al,%eax
f0105a2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a2d:	0f 8f a8 fe ff ff    	jg     f01058db <sched_exit_env+0xb2>
f0105a33:	eb 01                	jmp    f0105a36 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a35:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a36:	e8 4d 59 00 00       	call   f010b388 <get_cpu_proc>
f0105a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a42:	75 19                	jne    f0105a5d <sched_exit_env+0x234>
f0105a44:	68 23 4d 12 f0       	push   $0xf0124d23
f0105a49:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105a4e:	68 4e 01 00 00       	push   $0x14e
f0105a53:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105a58:	e8 dc a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a61:	75 18                	jne    f0105a7b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a66:	8b 40 10             	mov    0x10(%eax),%eax
f0105a69:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a6c:	75 0d                	jne    f0105a7b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105a74:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a7f:	74 1e                	je     f0105a9f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105a81:	83 ec 0c             	sub    $0xc,%esp
f0105a84:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a87:	e8 19 fb ff ff       	call   f01055a5 <sched_insert_exit>
f0105a8c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105a92:	8b 40 10             	mov    0x10(%eax),%eax
f0105a95:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a98:	75 05                	jne    f0105a9f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105a9a:	e8 6a 5a 00 00       	call   f010b509 <sched>
		}
	}
	if (!lock_already_held)
f0105a9f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa3:	75 10                	jne    f0105ab5 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105aa5:	83 ec 0c             	sub    $0xc,%esp
f0105aa8:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105aad:	e8 eb 9b 00 00       	call   f010f69d <release_spinlock>
f0105ab2:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105ab5:	90                   	nop
f0105ab6:	c9                   	leave  
f0105ab7:	c3                   	ret    

f0105ab8 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105ab8:	55                   	push   %ebp
f0105ab9:	89 e5                	mov    %esp,%ebp
f0105abb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105abe:	83 ec 0c             	sub    $0xc,%esp
f0105ac1:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105ac6:	e8 4b 9b 00 00       	call   f010f616 <acquire_spinlock>
f0105acb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105ace:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105adc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ae0:	75 79                	jne    f0105b5b <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ae2:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105ae7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105aea:	eb 48                	jmp    f0105b34 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aef:	8b 40 10             	mov    0x10(%eax),%eax
f0105af2:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105af5:	75 35                	jne    f0105b2c <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afa:	8d 50 20             	lea    0x20(%eax),%edx
f0105afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b00:	8b 40 10             	mov    0x10(%eax),%eax
f0105b03:	83 ec 04             	sub    $0x4,%esp
f0105b06:	52                   	push   %edx
f0105b07:	50                   	push   %eax
f0105b08:	68 34 4d 12 f0       	push   $0xf0124d34
f0105b0d:	e8 79 b4 ff ff       	call   f0100f8b <cprintf>
f0105b12:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b15:	83 ec 0c             	sub    $0xc,%esp
f0105b18:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b1b:	e8 95 f9 ff ff       	call   f01054b5 <sched_remove_new>
f0105b20:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b23:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b2a:	eb 2f                	jmp    f0105b5b <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b2c:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b38:	74 08                	je     f0105b42 <sched_kill_env+0x8a>
f0105b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3d:	8b 40 08             	mov    0x8(%eax),%eax
f0105b40:	eb 05                	jmp    f0105b47 <sched_kill_env+0x8f>
f0105b42:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b47:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f0105b4c:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	75 97                	jne    f0105aec <sched_kill_env+0x34>
f0105b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b59:	75 91                	jne    f0105aec <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b5f:	0f 85 85 01 00 00    	jne    f0105cea <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b6c:	e9 65 01 00 00       	jmp    f0105cd6 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b71:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105b76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b79:	c1 e2 04             	shl    $0x4,%edx
f0105b7c:	01 d0                	add    %edx,%eax
f0105b7e:	8b 00                	mov    (%eax),%eax
f0105b80:	85 c0                	test   %eax,%eax
f0105b82:	0f 84 45 01 00 00    	je     f0105ccd <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105b88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b8f:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b97:	c1 e2 04             	shl    $0x4,%edx
f0105b9a:	01 d0                	add    %edx,%eax
f0105b9c:	8b 00                	mov    (%eax),%eax
f0105b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ba1:	e9 ef 00 00 00       	jmp    f0105c95 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0105bac:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105baf:	0f 85 cd 00 00 00    	jne    f0105c82 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bb8:	8d 50 20             	lea    0x20(%eax),%edx
f0105bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bbe:	8b 40 10             	mov    0x10(%eax),%eax
f0105bc1:	ff 75 ec             	pushl  -0x14(%ebp)
f0105bc4:	52                   	push   %edx
f0105bc5:	50                   	push   %eax
f0105bc6:	68 5c 4d 12 f0       	push   $0xf0124d5c
f0105bcb:	e8 bb b3 ff ff       	call   f0100f8b <cprintf>
f0105bd0:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105bd3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bd7:	75 17                	jne    f0105bf0 <sched_kill_env+0x138>
f0105bd9:	83 ec 04             	sub    $0x4,%esp
f0105bdc:	68 27 4c 12 f0       	push   $0xf0124c27
f0105be1:	68 91 01 00 00       	push   $0x191
f0105be6:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105beb:	e8 49 a7 ff ff       	call   f0100339 <_panic>
f0105bf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf3:	8b 40 08             	mov    0x8(%eax),%eax
f0105bf6:	85 c0                	test   %eax,%eax
f0105bf8:	74 11                	je     f0105c0b <sched_kill_env+0x153>
f0105bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bfd:	8b 40 08             	mov    0x8(%eax),%eax
f0105c00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c03:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c06:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c09:	eb 16                	jmp    f0105c21 <sched_kill_env+0x169>
f0105c0b:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c13:	c1 e2 04             	shl    $0x4,%edx
f0105c16:	01 c2                	add    %eax,%edx
f0105c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1b:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c1e:	89 42 04             	mov    %eax,0x4(%edx)
f0105c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c24:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c27:	85 c0                	test   %eax,%eax
f0105c29:	74 11                	je     f0105c3c <sched_kill_env+0x184>
f0105c2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c2e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c34:	8b 52 08             	mov    0x8(%edx),%edx
f0105c37:	89 50 08             	mov    %edx,0x8(%eax)
f0105c3a:	eb 15                	jmp    f0105c51 <sched_kill_env+0x199>
f0105c3c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c44:	c1 e2 04             	shl    $0x4,%edx
f0105c47:	01 c2                	add    %eax,%edx
f0105c49:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c4c:	8b 40 08             	mov    0x8(%eax),%eax
f0105c4f:	89 02                	mov    %eax,(%edx)
f0105c51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c65:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c6d:	c1 e2 04             	shl    $0x4,%edx
f0105c70:	01 d0                	add    %edx,%eax
f0105c72:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c75:	4a                   	dec    %edx
f0105c76:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c79:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c80:	eb 4b                	jmp    f0105ccd <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c82:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c87:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c8a:	c1 e2 04             	shl    $0x4,%edx
f0105c8d:	01 d0                	add    %edx,%eax
f0105c8f:	8b 40 08             	mov    0x8(%eax),%eax
f0105c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c95:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105c9a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c9d:	c1 e2 04             	shl    $0x4,%edx
f0105ca0:	01 d0                	add    %edx,%eax
f0105ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca6:	74 08                	je     f0105cb0 <sched_kill_env+0x1f8>
f0105ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cab:	8b 52 08             	mov    0x8(%edx),%edx
f0105cae:	eb 05                	jmp    f0105cb5 <sched_kill_env+0x1fd>
f0105cb0:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cb5:	89 50 08             	mov    %edx,0x8(%eax)
f0105cb8:	8b 40 08             	mov    0x8(%eax),%eax
f0105cbb:	85 c0                	test   %eax,%eax
f0105cbd:	0f 85 e3 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
f0105cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105cc7:	0f 85 d9 fe ff ff    	jne    f0105ba6 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105ccd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cd1:	75 16                	jne    f0105ce9 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cd3:	ff 45 ec             	incl   -0x14(%ebp)
f0105cd6:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105cdb:	0f b6 c0             	movzbl %al,%eax
f0105cde:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105ce1:	0f 8f 8a fe ff ff    	jg     f0105b71 <sched_kill_env+0xb9>
f0105ce7:	eb 01                	jmp    f0105cea <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105ce9:	90                   	nop
		}
	}
	if (!found)
f0105cea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cee:	0f 85 80 00 00 00    	jne    f0105d74 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105cf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cfb:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f0105d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d03:	eb 48                	jmp    f0105d4d <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d05:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d08:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d0e:	75 35                	jne    f0105d45 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d13:	8d 50 20             	lea    0x20(%eax),%edx
f0105d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d19:	8b 40 10             	mov    0x10(%eax),%eax
f0105d1c:	83 ec 04             	sub    $0x4,%esp
f0105d1f:	52                   	push   %edx
f0105d20:	50                   	push   %eax
f0105d21:	68 88 4d 12 f0       	push   $0xf0124d88
f0105d26:	e8 60 b2 ff ff       	call   f0100f8b <cprintf>
f0105d2b:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d2e:	83 ec 0c             	sub    $0xc,%esp
f0105d31:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d34:	e8 f3 f8 ff ff       	call   f010562c <sched_remove_exit>
f0105d39:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d3c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d43:	eb 2f                	jmp    f0105d74 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d45:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0105d4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d51:	74 08                	je     f0105d5b <sched_kill_env+0x2a3>
f0105d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d56:	8b 40 08             	mov    0x8(%eax),%eax
f0105d59:	eb 05                	jmp    f0105d60 <sched_kill_env+0x2a8>
f0105d5b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d60:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f0105d65:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0105d6a:	85 c0                	test   %eax,%eax
f0105d6c:	75 97                	jne    f0105d05 <sched_kill_env+0x24d>
f0105d6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d72:	75 91                	jne    f0105d05 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d74:	83 ec 0c             	sub    $0xc,%esp
f0105d77:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105d7c:	e8 1c 99 00 00       	call   f010f69d <release_spinlock>
f0105d81:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105d84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d88:	74 23                	je     f0105dad <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d90:	e8 ab 55 00 00       	call   f010b340 <env_free>
f0105d95:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105d98:	83 ec 0c             	sub    $0xc,%esp
f0105d9b:	68 ae 4d 12 f0       	push   $0xf0124dae
f0105da0:	e8 e6 b1 ff ff       	call   f0100f8b <cprintf>
f0105da5:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105da8:	e9 a4 00 00 00       	jmp    f0105e51 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dad:	e8 d6 55 00 00       	call   f010b388 <get_cpu_proc>
f0105db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105db5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105db9:	75 19                	jne    f0105dd4 <sched_kill_env+0x31c>
f0105dbb:	68 23 4d 12 f0       	push   $0xf0124d23
f0105dc0:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105dc5:	68 b3 01 00 00       	push   $0x1b3
f0105dca:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105dcf:	e8 65 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105dd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105dd7:	8b 40 10             	mov    0x10(%eax),%eax
f0105dda:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ddd:	75 72                	jne    f0105e51 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105ddf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105de2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105de8:	8b 40 18             	mov    0x18(%eax),%eax
f0105deb:	83 f8 02             	cmp    $0x2,%eax
f0105dee:	74 19                	je     f0105e09 <sched_kill_env+0x351>
f0105df0:	68 b4 4d 12 f0       	push   $0xf0124db4
f0105df5:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0105dfa:	68 b8 01 00 00       	push   $0x1b8
f0105dff:	68 eb 4b 12 f0       	push   $0xf0124beb
f0105e04:	e8 30 a5 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e0c:	8d 50 20             	lea    0x20(%eax),%edx
f0105e0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e12:	8b 40 10             	mov    0x10(%eax),%eax
f0105e15:	83 ec 04             	sub    $0x4,%esp
f0105e18:	52                   	push   %edx
f0105e19:	50                   	push   %eax
f0105e1a:	68 d8 4d 12 f0       	push   $0xf0124dd8
f0105e1f:	e8 67 b1 ff ff       	call   f0100f8b <cprintf>
f0105e24:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e27:	83 ec 0c             	sub    $0xc,%esp
f0105e2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e2d:	e8 0e 55 00 00       	call   f010b340 <env_free>
f0105e32:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e35:	83 ec 0c             	sub    $0xc,%esp
f0105e38:	68 ae 4d 12 f0       	push   $0xf0124dae
f0105e3d:	e8 49 b1 ff ff       	call   f0100f8b <cprintf>
f0105e42:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e45:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e4c:	e8 b8 56 00 00       	call   f010b509 <sched>
		}
	}

}
f0105e51:	90                   	nop
f0105e52:	c9                   	leave  
f0105e53:	c3                   	ret    

f0105e54 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e54:	55                   	push   %ebp
f0105e55:	89 e5                	mov    %esp,%ebp
f0105e57:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e5a:	83 ec 0c             	sub    $0xc,%esp
f0105e5d:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0105e62:	e8 af 97 00 00       	call   f010f616 <acquire_spinlock>
f0105e67:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e6a:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105e6f:	85 c0                	test   %eax,%eax
f0105e71:	74 69                	je     f0105edc <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	68 04 4e 12 f0       	push   $0xf0124e04
f0105e7b:	e8 0b b1 ff ff       	call   f0100f8b <cprintf>
f0105e80:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e83:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0105e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e8b:	eb 26                	jmp    f0105eb3 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e90:	8d 50 20             	lea    0x20(%eax),%edx
f0105e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e96:	8b 40 10             	mov    0x10(%eax),%eax
f0105e99:	83 ec 04             	sub    $0x4,%esp
f0105e9c:	52                   	push   %edx
f0105e9d:	50                   	push   %eax
f0105e9e:	68 26 4e 12 f0       	push   $0xf0124e26
f0105ea3:	e8 e3 b0 ff ff       	call   f0100f8b <cprintf>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eab:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105eb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb7:	74 08                	je     f0105ec1 <sched_print_all+0x6d>
f0105eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebc:	8b 40 08             	mov    0x8(%eax),%eax
f0105ebf:	eb 05                	jmp    f0105ec6 <sched_print_all+0x72>
f0105ec1:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ec6:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f0105ecb:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0105ed0:	85 c0                	test   %eax,%eax
f0105ed2:	75 b9                	jne    f0105e8d <sched_print_all+0x39>
f0105ed4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ed8:	75 b3                	jne    f0105e8d <sched_print_all+0x39>
f0105eda:	eb 10                	jmp    f0105eec <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105edc:	83 ec 0c             	sub    $0xc,%esp
f0105edf:	68 30 4e 12 f0       	push   $0xf0124e30
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eec:	83 ec 0c             	sub    $0xc,%esp
f0105eef:	68 4c 4e 12 f0       	push   $0xf0124e4c
f0105ef4:	e8 92 b0 ff ff       	call   f0100f8b <cprintf>
f0105ef9:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f03:	e9 c7 00 00 00       	jmp    f0105fcf <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f08:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f10:	c1 e2 04             	shl    $0x4,%edx
f0105f13:	01 d0                	add    %edx,%eax
f0105f15:	8b 00                	mov    (%eax),%eax
f0105f17:	85 c0                	test   %eax,%eax
f0105f19:	0f 84 8a 00 00 00    	je     f0105fa9 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f1f:	83 ec 08             	sub    $0x8,%esp
f0105f22:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f25:	68 80 4e 12 f0       	push   $0xf0124e80
f0105f2a:	e8 5c b0 ff ff       	call   f0100f8b <cprintf>
f0105f2f:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f32:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f37:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f3a:	c1 e2 04             	shl    $0x4,%edx
f0105f3d:	01 d0                	add    %edx,%eax
f0105f3f:	8b 00                	mov    (%eax),%eax
f0105f41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f44:	eb 31                	jmp    f0105f77 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f49:	8d 50 20             	lea    0x20(%eax),%edx
f0105f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4f:	8b 40 10             	mov    0x10(%eax),%eax
f0105f52:	83 ec 04             	sub    $0x4,%esp
f0105f55:	52                   	push   %edx
f0105f56:	50                   	push   %eax
f0105f57:	68 26 4e 12 f0       	push   $0xf0124e26
f0105f5c:	e8 2a b0 ff ff       	call   f0100f8b <cprintf>
f0105f61:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f64:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6c:	c1 e2 04             	shl    $0x4,%edx
f0105f6f:	01 d0                	add    %edx,%eax
f0105f71:	8b 40 08             	mov    0x8(%eax),%eax
f0105f74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f77:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0105f7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7f:	c1 e2 04             	shl    $0x4,%edx
f0105f82:	01 d0                	add    %edx,%eax
f0105f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f88:	74 08                	je     f0105f92 <sched_print_all+0x13e>
f0105f8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8d:	8b 52 08             	mov    0x8(%edx),%edx
f0105f90:	eb 05                	jmp    f0105f97 <sched_print_all+0x143>
f0105f92:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f97:	89 50 08             	mov    %edx,0x8(%eax)
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	85 c0                	test   %eax,%eax
f0105f9f:	75 a5                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fa5:	75 9f                	jne    f0105f46 <sched_print_all+0xf2>
f0105fa7:	eb 13                	jmp    f0105fbc <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fa9:	83 ec 08             	sub    $0x8,%esp
f0105fac:	ff 75 f0             	pushl  -0x10(%ebp)
f0105faf:	68 a8 4e 12 f0       	push   $0xf0124ea8
f0105fb4:	e8 d2 af ff ff       	call   f0100f8b <cprintf>
f0105fb9:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105fbc:	83 ec 0c             	sub    $0xc,%esp
f0105fbf:	68 4c 4e 12 f0       	push   $0xf0124e4c
f0105fc4:	e8 c2 af ff ff       	call   f0100f8b <cprintf>
f0105fc9:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105fcc:	ff 45 f0             	incl   -0x10(%ebp)
f0105fcf:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0105fd4:	0f b6 c0             	movzbl %al,%eax
f0105fd7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105fda:	0f 8f 28 ff ff ff    	jg     f0105f08 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105fe0:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 69                	je     f0106052 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105fe9:	83 ec 0c             	sub    $0xc,%esp
f0105fec:	68 cc 4e 12 f0       	push   $0xf0124ecc
f0105ff1:	e8 95 af ff ff       	call   f0100f8b <cprintf>
f0105ff6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105ff9:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f0105ffe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106001:	eb 26                	jmp    f0106029 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106003:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106006:	8d 50 20             	lea    0x20(%eax),%edx
f0106009:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010600c:	8b 40 10             	mov    0x10(%eax),%eax
f010600f:	83 ec 04             	sub    $0x4,%esp
f0106012:	52                   	push   %edx
f0106013:	50                   	push   %eax
f0106014:	68 26 4e 12 f0       	push   $0xf0124e26
f0106019:	e8 6d af ff ff       	call   f0100f8b <cprintf>
f010601e:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106021:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0106026:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106029:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010602d:	74 08                	je     f0106037 <sched_print_all+0x1e3>
f010602f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106032:	8b 40 08             	mov    0x8(%eax),%eax
f0106035:	eb 05                	jmp    f010603c <sched_print_all+0x1e8>
f0106037:	b8 00 00 00 00       	mov    $0x0,%eax
f010603c:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f0106041:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f0106046:	85 c0                	test   %eax,%eax
f0106048:	75 b9                	jne    f0106003 <sched_print_all+0x1af>
f010604a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010604e:	75 b3                	jne    f0106003 <sched_print_all+0x1af>
f0106050:	eb 10                	jmp    f0106062 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106052:	83 ec 0c             	sub    $0xc,%esp
f0106055:	68 ee 4e 12 f0       	push   $0xf0124eee
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106062:	83 ec 0c             	sub    $0xc,%esp
f0106065:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010606a:	e8 2e 96 00 00       	call   f010f69d <release_spinlock>
f010606f:	83 c4 10             	add    $0x10,%esp
}
f0106072:	90                   	nop
f0106073:	c9                   	leave  
f0106074:	c3                   	ret    

f0106075 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106075:	55                   	push   %ebp
f0106076:	89 e5                	mov    %esp,%ebp
f0106078:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010607b:	83 ec 0c             	sub    $0xc,%esp
f010607e:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106083:	e8 8e 95 00 00       	call   f010f616 <acquire_spinlock>
f0106088:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010608b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106092:	a1 3c d3 6b f0       	mov    0xf06bd33c,%eax
f0106097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010609a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060a1:	eb 24                	jmp    f01060c7 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 30 d3 6b f0       	push   $0xf06bd330
f01060ab:	e8 8b ef ff ff       	call   f010503b <dequeue>
f01060b0:	83 c4 10             	add    $0x10,%esp
f01060b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060b6:	83 ec 0c             	sub    $0xc,%esp
f01060b9:	ff 75 f0             	pushl  -0x10(%ebp)
f01060bc:	e8 b5 f1 ff ff       	call   f0105276 <sched_insert_ready0>
f01060c1:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f01060c4:	ff 45 f4             	incl   -0xc(%ebp)
f01060c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ca:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01060cd:	7c d4                	jl     f01060a3 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060cf:	83 ec 0c             	sub    $0xc,%esp
f01060d2:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01060d7:	e8 c1 95 00 00       	call   f010f69d <release_spinlock>
f01060dc:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f01060df:	e8 28 10 00 00       	call   f010710c <mycpu>
f01060e4:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01060ea:	85 c0                	test   %eax,%eax
f01060ec:	75 05                	jne    f01060f3 <sched_run_all+0x7e>
		fos_scheduler();
f01060ee:	e8 9e 06 00 00       	call   f0106791 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f01060f3:	83 ec 04             	sub    $0x4,%esp
f01060f6:	68 0c 4f 12 f0       	push   $0xf0124f0c
f01060fb:	68 15 02 00 00       	push   $0x215
f0106100:	68 eb 4b 12 f0       	push   $0xf0124beb
f0106105:	e8 2f a2 ff ff       	call   f0100339 <_panic>

f010610a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010610a:	55                   	push   %ebp
f010610b:	89 e5                	mov    %esp,%ebp
f010610d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106118:	e8 f9 94 00 00       	call   f010f616 <acquire_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106120:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0106125:	85 c0                	test   %eax,%eax
f0106127:	0f 84 95 00 00 00    	je     f01061c2 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010612d:	83 ec 0c             	sub    $0xc,%esp
f0106130:	68 48 4f 12 f0       	push   $0xf0124f48
f0106135:	e8 51 ae ff ff       	call   f0100f8b <cprintf>
f010613a:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613d:	a1 30 d3 6b f0       	mov    0xf06bd330,%eax
f0106142:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106145:	eb 52                	jmp    f0106199 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106147:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614a:	8d 50 20             	lea    0x20(%eax),%edx
f010614d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106150:	8b 40 10             	mov    0x10(%eax),%eax
f0106153:	83 ec 04             	sub    $0x4,%esp
f0106156:	52                   	push   %edx
f0106157:	50                   	push   %eax
f0106158:	68 74 4f 12 f0       	push   $0xf0124f74
f010615d:	e8 29 ae ff ff       	call   f0100f8b <cprintf>
f0106162:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0106165:	83 ec 0c             	sub    $0xc,%esp
f0106168:	ff 75 f4             	pushl  -0xc(%ebp)
f010616b:	e8 45 f3 ff ff       	call   f01054b5 <sched_remove_new>
f0106170:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106173:	83 ec 0c             	sub    $0xc,%esp
f0106176:	ff 75 f4             	pushl  -0xc(%ebp)
f0106179:	e8 c2 51 00 00       	call   f010b340 <env_free>
f010617e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106181:	83 ec 0c             	sub    $0xc,%esp
f0106184:	68 ae 4d 12 f0       	push   $0xf0124dae
f0106189:	e8 fd ad ff ff       	call   f0100f8b <cprintf>
f010618e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106191:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f0106196:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106199:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010619d:	74 08                	je     f01061a7 <sched_kill_all+0x9d>
f010619f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a2:	8b 40 08             	mov    0x8(%eax),%eax
f01061a5:	eb 05                	jmp    f01061ac <sched_kill_all+0xa2>
f01061a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ac:	a3 38 d3 6b f0       	mov    %eax,0xf06bd338
f01061b1:	a1 38 d3 6b f0       	mov    0xf06bd338,%eax
f01061b6:	85 c0                	test   %eax,%eax
f01061b8:	75 8d                	jne    f0106147 <sched_kill_all+0x3d>
f01061ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061be:	75 87                	jne    f0106147 <sched_kill_all+0x3d>
f01061c0:	eb 10                	jmp    f01061d2 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 87 4f 12 f0       	push   $0xf0124f87
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f01061d2:	83 ec 0c             	sub    $0xc,%esp
f01061d5:	68 4c 4e 12 f0       	push   $0xf0124e4c
f01061da:	e8 ac ad ff ff       	call   f0100f8b <cprintf>
f01061df:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061e9:	e9 96 01 00 00       	jmp    f0106384 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061ee:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01061f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061f6:	c1 e2 04             	shl    $0x4,%edx
f01061f9:	01 d0                	add    %edx,%eax
f01061fb:	8b 00                	mov    (%eax),%eax
f01061fd:	85 c0                	test   %eax,%eax
f01061ff:	0f 84 59 01 00 00    	je     f010635e <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106205:	83 ec 08             	sub    $0x8,%esp
f0106208:	ff 75 f0             	pushl  -0x10(%ebp)
f010620b:	68 a4 4f 12 f0       	push   $0xf0124fa4
f0106210:	e8 76 ad ff ff       	call   f0100f8b <cprintf>
f0106215:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106218:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010621d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106220:	c1 e2 04             	shl    $0x4,%edx
f0106223:	01 d0                	add    %edx,%eax
f0106225:	8b 00                	mov    (%eax),%eax
f0106227:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010622a:	e9 f5 00 00 00       	jmp    f0106324 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106232:	8d 50 20             	lea    0x20(%eax),%edx
f0106235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106238:	8b 40 10             	mov    0x10(%eax),%eax
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	52                   	push   %edx
f010623f:	50                   	push   %eax
f0106240:	68 74 4f 12 f0       	push   $0xf0124f74
f0106245:	e8 41 ad ff ff       	call   f0100f8b <cprintf>
f010624a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010624d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106251:	75 17                	jne    f010626a <sched_kill_all+0x160>
f0106253:	83 ec 04             	sub    $0x4,%esp
f0106256:	68 27 4c 12 f0       	push   $0xf0124c27
f010625b:	68 37 02 00 00       	push   $0x237
f0106260:	68 eb 4b 12 f0       	push   $0xf0124beb
f0106265:	e8 cf a0 ff ff       	call   f0100339 <_panic>
f010626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010626d:	8b 40 08             	mov    0x8(%eax),%eax
f0106270:	85 c0                	test   %eax,%eax
f0106272:	74 11                	je     f0106285 <sched_kill_all+0x17b>
f0106274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106277:	8b 40 08             	mov    0x8(%eax),%eax
f010627a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010627d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106280:	89 50 0c             	mov    %edx,0xc(%eax)
f0106283:	eb 16                	jmp    f010629b <sched_kill_all+0x191>
f0106285:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f010628a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010628d:	c1 e2 04             	shl    $0x4,%edx
f0106290:	01 c2                	add    %eax,%edx
f0106292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106295:	8b 40 0c             	mov    0xc(%eax),%eax
f0106298:	89 42 04             	mov    %eax,0x4(%edx)
f010629b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629e:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a1:	85 c0                	test   %eax,%eax
f01062a3:	74 11                	je     f01062b6 <sched_kill_all+0x1ac>
f01062a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ae:	8b 52 08             	mov    0x8(%edx),%edx
f01062b1:	89 50 08             	mov    %edx,0x8(%eax)
f01062b4:	eb 15                	jmp    f01062cb <sched_kill_all+0x1c1>
f01062b6:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01062bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062be:	c1 e2 04             	shl    $0x4,%edx
f01062c1:	01 c2                	add    %eax,%edx
f01062c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c6:	8b 40 08             	mov    0x8(%eax),%eax
f01062c9:	89 02                	mov    %eax,(%edx)
f01062cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062df:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01062e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062e7:	c1 e2 04             	shl    $0x4,%edx
f01062ea:	01 d0                	add    %edx,%eax
f01062ec:	8b 50 0c             	mov    0xc(%eax),%edx
f01062ef:	4a                   	dec    %edx
f01062f0:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f01062f3:	83 ec 0c             	sub    $0xc,%esp
f01062f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f9:	e8 42 50 00 00       	call   f010b340 <env_free>
f01062fe:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106301:	83 ec 0c             	sub    $0xc,%esp
f0106304:	68 ae 4d 12 f0       	push   $0xf0124dae
f0106309:	e8 7d ac ff ff       	call   f0100f8b <cprintf>
f010630e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106311:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106316:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106319:	c1 e2 04             	shl    $0x4,%edx
f010631c:	01 d0                	add    %edx,%eax
f010631e:	8b 40 08             	mov    0x8(%eax),%eax
f0106321:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106324:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106329:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010632c:	c1 e2 04             	shl    $0x4,%edx
f010632f:	01 d0                	add    %edx,%eax
f0106331:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106335:	74 08                	je     f010633f <sched_kill_all+0x235>
f0106337:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010633a:	8b 52 08             	mov    0x8(%edx),%edx
f010633d:	eb 05                	jmp    f0106344 <sched_kill_all+0x23a>
f010633f:	ba 00 00 00 00       	mov    $0x0,%edx
f0106344:	89 50 08             	mov    %edx,0x8(%eax)
f0106347:	8b 40 08             	mov    0x8(%eax),%eax
f010634a:	85 c0                	test   %eax,%eax
f010634c:	0f 85 dd fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f0106352:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106356:	0f 85 d3 fe ff ff    	jne    f010622f <sched_kill_all+0x125>
f010635c:	eb 13                	jmp    f0106371 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010635e:	83 ec 08             	sub    $0x8,%esp
f0106361:	ff 75 f0             	pushl  -0x10(%ebp)
f0106364:	68 a8 4e 12 f0       	push   $0xf0124ea8
f0106369:	e8 1d ac ff ff       	call   f0100f8b <cprintf>
f010636e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106371:	83 ec 0c             	sub    $0xc,%esp
f0106374:	68 4c 4e 12 f0       	push   $0xf0124e4c
f0106379:	e8 0d ac ff ff       	call   f0100f8b <cprintf>
f010637e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106381:	ff 45 f0             	incl   -0x10(%ebp)
f0106384:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f0106389:	0f b6 c0             	movzbl %al,%eax
f010638c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010638f:	0f 8f 59 fe ff ff    	jg     f01061ee <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106395:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f010639a:	85 c0                	test   %eax,%eax
f010639c:	0f 84 95 00 00 00    	je     f0106437 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063a2:	83 ec 0c             	sub    $0xc,%esp
f01063a5:	68 d8 4f 12 f0       	push   $0xf0124fd8
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063b2:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f01063b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063ba:	eb 52                	jmp    f010640e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063bf:	8d 50 20             	lea    0x20(%eax),%edx
f01063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063c5:	8b 40 10             	mov    0x10(%eax),%eax
f01063c8:	83 ec 04             	sub    $0x4,%esp
f01063cb:	52                   	push   %edx
f01063cc:	50                   	push   %eax
f01063cd:	68 74 4f 12 f0       	push   $0xf0124f74
f01063d2:	e8 b4 ab ff ff       	call   f0100f8b <cprintf>
f01063d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01063da:	83 ec 0c             	sub    $0xc,%esp
f01063dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01063e0:	e8 47 f2 ff ff       	call   f010562c <sched_remove_exit>
f01063e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01063e8:	83 ec 0c             	sub    $0xc,%esp
f01063eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01063ee:	e8 4d 4f 00 00       	call   f010b340 <env_free>
f01063f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01063f6:	83 ec 0c             	sub    $0xc,%esp
f01063f9:	68 ae 4d 12 f0       	push   $0xf0124dae
f01063fe:	e8 88 ab ff ff       	call   f0100f8b <cprintf>
f0106403:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106406:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010640b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010640e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106412:	74 08                	je     f010641c <sched_kill_all+0x312>
f0106414:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106417:	8b 40 08             	mov    0x8(%eax),%eax
f010641a:	eb 05                	jmp    f0106421 <sched_kill_all+0x317>
f010641c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106421:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f0106426:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010642b:	85 c0                	test   %eax,%eax
f010642d:	75 8d                	jne    f01063bc <sched_kill_all+0x2b2>
f010642f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106433:	75 87                	jne    f01063bc <sched_kill_all+0x2b2>
f0106435:	eb 10                	jmp    f0106447 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 ee 4e 12 f0       	push   $0xf0124eee
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106447:	e8 3c 4f 00 00       	call   f010b388 <get_cpu_proc>
f010644c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010644f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106453:	74 6b                	je     f01064c0 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106458:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010645b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010645e:	8b 40 18             	mov    0x18(%eax),%eax
f0106461:	83 f8 02             	cmp    $0x2,%eax
f0106464:	74 19                	je     f010647f <sched_kill_all+0x375>
f0106466:	68 b4 4d 12 f0       	push   $0xf0124db4
f010646b:	68 d6 4b 12 f0       	push   $0xf0124bd6
f0106470:	68 57 02 00 00       	push   $0x257
f0106475:	68 eb 4b 12 f0       	push   $0xf0124beb
f010647a:	e8 ba 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010647f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106482:	8d 50 20             	lea    0x20(%eax),%edx
f0106485:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106488:	8b 40 10             	mov    0x10(%eax),%eax
f010648b:	83 ec 04             	sub    $0x4,%esp
f010648e:	52                   	push   %edx
f010648f:	50                   	push   %eax
f0106490:	68 d8 4d 12 f0       	push   $0xf0124dd8
f0106495:	e8 f1 aa ff ff       	call   f0100f8b <cprintf>
f010649a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010649d:	83 ec 0c             	sub    $0xc,%esp
f01064a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01064a3:	e8 98 4e 00 00       	call   f010b340 <env_free>
f01064a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ab:	83 ec 0c             	sub    $0xc,%esp
f01064ae:	68 ae 4d 12 f0       	push   $0xf0124dae
f01064b3:	e8 d3 aa ff ff       	call   f0100f8b <cprintf>
f01064b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064bb:	e8 49 50 00 00       	call   f010b509 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064c0:	83 ec 0c             	sub    $0xc,%esp
f01064c3:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01064c8:	e8 d0 91 00 00       	call   f010f69d <release_spinlock>
f01064cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01064d0:	e8 ed b8 ff ff       	call   f0101dc2 <get_into_prompt>

f01064d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01064d5:	55                   	push   %ebp
f01064d6:	89 e5                	mov    %esp,%ebp
f01064d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01064db:	83 ec 0c             	sub    $0xc,%esp
f01064de:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01064e3:	e8 2e 91 00 00       	call   f010f616 <acquire_spinlock>
f01064e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01064eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01064f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01064f9:	e9 37 01 00 00       	jmp    f0106635 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01064fe:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106503:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106506:	c1 e2 04             	shl    $0x4,%edx
f0106509:	01 d0                	add    %edx,%eax
f010650b:	8b 00                	mov    (%eax),%eax
f010650d:	85 c0                	test   %eax,%eax
f010650f:	0f 84 1d 01 00 00    	je     f0106632 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010651c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106521:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106524:	c1 e2 04             	shl    $0x4,%edx
f0106527:	01 d0                	add    %edx,%eax
f0106529:	8b 00                	mov    (%eax),%eax
f010652b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010652e:	e9 c7 00 00 00       	jmp    f01065fa <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106537:	75 17                	jne    f0106550 <sched_exit_all_ready_envs+0x7b>
f0106539:	83 ec 04             	sub    $0x4,%esp
f010653c:	68 27 4c 12 f0       	push   $0xf0124c27
f0106541:	68 79 02 00 00       	push   $0x279
f0106546:	68 eb 4b 12 f0       	push   $0xf0124beb
f010654b:	e8 e9 9d ff ff       	call   f0100339 <_panic>
f0106550:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106553:	8b 40 08             	mov    0x8(%eax),%eax
f0106556:	85 c0                	test   %eax,%eax
f0106558:	74 11                	je     f010656b <sched_exit_all_ready_envs+0x96>
f010655a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655d:	8b 40 08             	mov    0x8(%eax),%eax
f0106560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106563:	8b 52 0c             	mov    0xc(%edx),%edx
f0106566:	89 50 0c             	mov    %edx,0xc(%eax)
f0106569:	eb 16                	jmp    f0106581 <sched_exit_all_ready_envs+0xac>
f010656b:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106570:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106573:	c1 e2 04             	shl    $0x4,%edx
f0106576:	01 c2                	add    %eax,%edx
f0106578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010657b:	8b 40 0c             	mov    0xc(%eax),%eax
f010657e:	89 42 04             	mov    %eax,0x4(%edx)
f0106581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106584:	8b 40 0c             	mov    0xc(%eax),%eax
f0106587:	85 c0                	test   %eax,%eax
f0106589:	74 11                	je     f010659c <sched_exit_all_ready_envs+0xc7>
f010658b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010658e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106591:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106594:	8b 52 08             	mov    0x8(%edx),%edx
f0106597:	89 50 08             	mov    %edx,0x8(%eax)
f010659a:	eb 15                	jmp    f01065b1 <sched_exit_all_ready_envs+0xdc>
f010659c:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a4:	c1 e2 04             	shl    $0x4,%edx
f01065a7:	01 c2                	add    %eax,%edx
f01065a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ac:	8b 40 08             	mov    0x8(%eax),%eax
f01065af:	89 02                	mov    %eax,(%edx)
f01065b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065be:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065c5:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065cd:	c1 e2 04             	shl    $0x4,%edx
f01065d0:	01 d0                	add    %edx,%eax
f01065d2:	8b 50 0c             	mov    0xc(%eax),%edx
f01065d5:	4a                   	dec    %edx
f01065d6:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f01065d9:	83 ec 0c             	sub    $0xc,%esp
f01065dc:	ff 75 f4             	pushl  -0xc(%ebp)
f01065df:	e8 c1 ef ff ff       	call   f01055a5 <sched_insert_exit>
f01065e4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065e7:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065ef:	c1 e2 04             	shl    $0x4,%edx
f01065f2:	01 d0                	add    %edx,%eax
f01065f4:	8b 40 08             	mov    0x8(%eax),%eax
f01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065fa:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f01065ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106602:	c1 e2 04             	shl    $0x4,%edx
f0106605:	01 d0                	add    %edx,%eax
f0106607:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010660b:	74 08                	je     f0106615 <sched_exit_all_ready_envs+0x140>
f010660d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106610:	8b 52 08             	mov    0x8(%edx),%edx
f0106613:	eb 05                	jmp    f010661a <sched_exit_all_ready_envs+0x145>
f0106615:	ba 00 00 00 00       	mov    $0x0,%edx
f010661a:	89 50 08             	mov    %edx,0x8(%eax)
f010661d:	8b 40 08             	mov    0x8(%eax),%eax
f0106620:	85 c0                	test   %eax,%eax
f0106622:	0f 85 0b ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
f0106628:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010662c:	0f 85 01 ff ff ff    	jne    f0106533 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106632:	ff 45 f0             	incl   -0x10(%ebp)
f0106635:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f010663a:	0f b6 c0             	movzbl %al,%eax
f010663d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106640:	0f 8f b8 fe ff ff    	jg     f01064fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106646:	83 ec 0c             	sub    $0xc,%esp
f0106649:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010664e:	e8 4a 90 00 00       	call   f010f69d <release_spinlock>
f0106653:	83 c4 10             	add    $0x10,%esp
}
f0106656:	90                   	nop
f0106657:	c9                   	leave  
f0106658:	c3                   	ret    

f0106659 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106659:	55                   	push   %ebp
f010665a:	89 e5                	mov    %esp,%ebp
	return ticks;
f010665c:	a1 68 d9 6b f0       	mov    0xf06bd968,%eax
f0106661:	8b 15 6c d9 6b f0    	mov    0xf06bd96c,%edx
}
f0106667:	5d                   	pop    %ebp
f0106668:	c3                   	ret    

f0106669 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f0106669:	55                   	push   %ebp
f010666a:	89 e5                	mov    %esp,%ebp
f010666c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010666f:	83 ec 04             	sub    $0x4,%esp
f0106672:	68 04 50 12 f0       	push   $0xf0125004
f0106677:	68 8c 02 00 00       	push   $0x28c
f010667c:	68 eb 4b 12 f0       	push   $0xf0124beb
f0106681:	e8 b3 9c ff ff       	call   f0100339 <_panic>

f0106686 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106686:	55                   	push   %ebp
f0106687:	89 e5                	mov    %esp,%ebp
f0106689:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010668c:	83 ec 04             	sub    $0x4,%esp
f010668f:	68 04 50 12 f0       	push   $0xf0125004
f0106694:	68 94 02 00 00       	push   $0x294
f0106699:	68 eb 4b 12 f0       	push   $0xf0124beb
f010669e:	e8 96 9c ff ff       	call   f0100339 <_panic>

f01066a3 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066a3:	55                   	push   %ebp
f01066a4:	89 e5                	mov    %esp,%ebp
f01066a6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066a9:	83 ec 04             	sub    $0x4,%esp
f01066ac:	68 04 50 12 f0       	push   $0xf0125004
f01066b1:	68 9c 02 00 00       	push   $0x29c
f01066b6:	68 eb 4b 12 f0       	push   $0xf0124beb
f01066bb:	e8 79 9c ff ff       	call   f0100339 <_panic>

f01066c0 <get_load_average>:
}
int get_load_average()
{
f01066c0:	55                   	push   %ebp
f01066c1:	89 e5                	mov    %esp,%ebp
f01066c3:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066c6:	83 ec 04             	sub    $0x4,%esp
f01066c9:	68 04 50 12 f0       	push   $0xf0125004
f01066ce:	68 a4 02 00 00       	push   $0x2a4
f01066d3:	68 eb 4b 12 f0       	push   $0xf0124beb
f01066d8:	e8 5c 9c ff ff       	call   f0100339 <_panic>

f01066dd <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01066dd:	55                   	push   %ebp
f01066de:	89 e5                	mov    %esp,%ebp
f01066e0:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f01066e5:	85 c0                	test   %eax,%eax
f01066e7:	75 07                	jne    f01066f0 <isSchedMethodRR+0x13>
f01066e9:	b8 01 00 00 00       	mov    $0x1,%eax
f01066ee:	eb 05                	jmp    f01066f5 <isSchedMethodRR+0x18>
f01066f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01066f5:	5d                   	pop    %ebp
f01066f6:	c3                   	ret    

f01066f7 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f01066f7:	55                   	push   %ebp
f01066f8:	89 e5                	mov    %esp,%ebp
f01066fa:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f01066ff:	83 f8 01             	cmp    $0x1,%eax
f0106702:	75 07                	jne    f010670b <isSchedMethodMLFQ+0x14>
f0106704:	b8 01 00 00 00       	mov    $0x1,%eax
f0106709:	eb 05                	jmp    f0106710 <isSchedMethodMLFQ+0x19>
f010670b:	b8 00 00 00 00       	mov    $0x0,%eax
f0106710:	5d                   	pop    %ebp
f0106711:	c3                   	ret    

f0106712 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106712:	55                   	push   %ebp
f0106713:	89 e5                	mov    %esp,%ebp
f0106715:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f010671a:	83 f8 02             	cmp    $0x2,%eax
f010671d:	75 07                	jne    f0106726 <isSchedMethodBSD+0x14>
f010671f:	b8 01 00 00 00       	mov    $0x1,%eax
f0106724:	eb 05                	jmp    f010672b <isSchedMethodBSD+0x19>
f0106726:	b8 00 00 00 00       	mov    $0x0,%eax
f010672b:	5d                   	pop    %ebp
f010672c:	c3                   	ret    

f010672d <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010672d:	55                   	push   %ebp
f010672e:	89 e5                	mov    %esp,%ebp
f0106730:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106733:	c7 05 98 d4 6b f0 00 	movl   $0x0,0xf06bd498
f010673a:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010673d:	83 ec 0c             	sub    $0xc,%esp
f0106740:	6a 0a                	push   $0xa
f0106742:	e8 60 02 00 00       	call   f01069a7 <sched_init_RR>
f0106747:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010674a:	83 ec 0c             	sub    $0xc,%esp
f010674d:	68 30 d3 6b f0       	push   $0xf06bd330
f0106752:	e8 12 e8 ff ff       	call   f0104f69 <init_queue>
f0106757:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010675a:	83 ec 0c             	sub    $0xc,%esp
f010675d:	68 40 d3 6b f0       	push   $0xf06bd340
f0106762:	e8 02 e8 ff ff       	call   f0104f69 <init_queue>
f0106767:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010676a:	e8 9d 09 00 00       	call   f010710c <mycpu>
f010676f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106776:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106779:	83 ec 08             	sub    $0x8,%esp
f010677c:	68 18 50 12 f0       	push   $0xf0125018
f0106781:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106786:	e8 5a 8e 00 00       	call   f010f5e5 <init_spinlock>
f010678b:	83 c4 10             	add    $0x10,%esp
}
f010678e:	90                   	nop
f010678f:	c9                   	leave  
f0106790:	c3                   	ret    

f0106791 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106791:	55                   	push   %ebp
f0106792:	89 e5                	mov    %esp,%ebp
f0106794:	53                   	push   %ebx
f0106795:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106798:	9c                   	pushf  
f0106799:	58                   	pop    %eax
f010679a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f010679d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067a0:	25 00 02 00 00       	and    $0x200,%eax
f01067a5:	85 c0                	test   %eax,%eax
f01067a7:	74 14                	je     f01067bd <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067a9:	83 ec 04             	sub    $0x4,%esp
f01067ac:	68 2c 50 12 f0       	push   $0xf012502c
f01067b1:	6a 37                	push   $0x37
f01067b3:	68 62 50 12 f0       	push   $0xf0125062
f01067b8:	e8 7c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067bd:	e8 4a 09 00 00       	call   f010710c <mycpu>
f01067c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01067c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01067cf:	00 00 00 

	chk1();
f01067d2:	e8 a9 7f 01 00       	call   f011e780 <chk1>
	c->scheduler_status = SCH_STARTED;
f01067d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01067da:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f01067e1:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f01067e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01067eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01067f2:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01067f3:	83 ec 0c             	sub    $0xc,%esp
f01067f6:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f01067fb:	e8 16 8e 00 00       	call   f010f616 <acquire_spinlock>
f0106800:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106803:	a1 b4 d7 6b f0       	mov    0xf06bd7b4,%eax
f0106808:	8b 04 85 4c e9 17 f0 	mov    -0xfe816b4(,%eax,4),%eax
f010680f:	ff d0                	call   *%eax
f0106811:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106814:	e8 6f 4b 00 00       	call   f010b388 <get_cpu_proc>
f0106819:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010681c:	83 ec 0c             	sub    $0xc,%esp
f010681f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106822:	e8 8a 4b 00 00       	call   f010b3b1 <set_cpu_proc>
f0106827:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010682a:	83 ec 0c             	sub    $0xc,%esp
f010682d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106830:	e8 51 7f 01 00       	call   f011e786 <chk2>
f0106835:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106838:	83 ec 0c             	sub    $0xc,%esp
f010683b:	ff 75 e0             	pushl  -0x20(%ebp)
f010683e:	e8 6e 4b 00 00       	call   f010b3b1 <set_cpu_proc>
f0106843:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106846:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010684a:	0f 84 d6 00 00 00    	je     f0106926 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106850:	83 ec 0c             	sub    $0xc,%esp
f0106853:	ff 75 e8             	pushl  -0x18(%ebp)
f0106856:	e8 56 4b 00 00       	call   f010b3b1 <set_cpu_proc>
f010685b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010685e:	83 ec 0c             	sub    $0xc,%esp
f0106861:	ff 75 e8             	pushl  -0x18(%ebp)
f0106864:	e8 c3 4d 00 00       	call   f010b62c <switchuvm>
f0106869:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010686f:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106876:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106879:	8b 40 04             	mov    0x4(%eax),%eax
f010687c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010687f:	83 c2 04             	add    $0x4,%edx
f0106882:	83 ec 08             	sub    $0x8,%esp
f0106885:	50                   	push   %eax
f0106886:	52                   	push   %edx
f0106887:	e8 e5 e2 ff ff       	call   f0104b71 <context_switch>
f010688c:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010688f:	9c                   	pushf  
f0106890:	58                   	pop    %eax
f0106891:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106894:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106897:	25 00 02 00 00       	and    $0x200,%eax
f010689c:	85 c0                	test   %eax,%eax
f010689e:	74 14                	je     f01068b4 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068a0:	83 ec 04             	sub    $0x4,%esp
f01068a3:	68 74 50 12 f0       	push   $0xf0125074
f01068a8:	6a 74                	push   $0x74
f01068aa:	68 62 50 12 f0       	push   $0xf0125062
f01068af:	e8 85 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068b4:	e8 01 e4 ff ff       	call   f0104cba <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068b9:	e8 ca 4a 00 00       	call   f010b388 <get_cpu_proc>
f01068be:	89 c2                	mov    %eax,%edx
f01068c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068c3:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068c9:	39 c2                	cmp    %eax,%edx
f01068cb:	74 16                	je     f01068e3 <fos_scheduler+0x152>
f01068cd:	68 ab 50 12 f0       	push   $0xf01250ab
f01068d2:	68 c5 50 12 f0       	push   $0xf01250c5
f01068d7:	6a 7d                	push   $0x7d
f01068d9:	68 62 50 12 f0       	push   $0xf0125062
f01068de:	e8 56 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f01068e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01068e6:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01068ec:	8b 40 18             	mov    0x18(%eax),%eax
f01068ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f01068f2:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f01068f6:	75 16                	jne    f010690e <fos_scheduler+0x17d>
f01068f8:	68 da 50 12 f0       	push   $0xf01250da
f01068fd:	68 c5 50 12 f0       	push   $0xf01250c5
f0106902:	6a 7f                	push   $0x7f
f0106904:	68 62 50 12 f0       	push   $0xf0125062
f0106909:	e8 2b 9a ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010690e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106912:	74 12                	je     f0106926 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106914:	e8 fc 4c 00 00       	call   f010b615 <switchkvm>
					set_cpu_proc(NULL);
f0106919:	83 ec 0c             	sub    $0xc,%esp
f010691c:	6a 00                	push   $0x0
f010691e:	e8 8e 4a 00 00       	call   f010b3b1 <set_cpu_proc>
f0106923:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106926:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010692a:	0f 85 d3 fe ff ff    	jne    f0106803 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106930:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106937:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010693e:	eb 3e                	jmp    f010697e <fos_scheduler+0x1ed>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106940:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f0106946:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106949:	89 d0                	mov    %edx,%eax
f010694b:	c1 e0 03             	shl    $0x3,%eax
f010694e:	01 d0                	add    %edx,%eax
f0106950:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106957:	01 d8                	add    %ebx,%eax
f0106959:	01 c0                	add    %eax,%eax
f010695b:	01 d0                	add    %edx,%eax
f010695d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0106964:	01 d8                	add    %ebx,%eax
f0106966:	01 d0                	add    %edx,%eax
f0106968:	01 c8                	add    %ecx,%eax
f010696a:	8b 40 18             	mov    0x18(%eax),%eax
f010696d:	83 f8 03             	cmp    $0x3,%eax
f0106970:	75 09                	jne    f010697b <fos_scheduler+0x1ea>
			{
				is_any_blocked = 1;
f0106972:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106979:	eb 0d                	jmp    f0106988 <fos_scheduler+0x1f7>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f010697b:	ff 45 f0             	incl   -0x10(%ebp)
f010697e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106981:	3d c9 02 00 00       	cmp    $0x2c9,%eax
f0106986:	76 b8                	jbe    f0106940 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106988:	83 ec 0c             	sub    $0xc,%esp
f010698b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106990:	e8 08 8d 00 00       	call   f010f69d <release_spinlock>
f0106995:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106998:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010699c:	0f 8f 50 fe ff ff    	jg     f01067f2 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069a2:	e8 1b b4 ff ff       	call   f0101dc2 <get_into_prompt>

f01069a7 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069a7:	55                   	push   %ebp
f01069a8:	89 e5                	mov    %esp,%ebp
f01069aa:	83 ec 28             	sub    $0x28,%esp
f01069ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01069b0:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069b3:	c6 05 04 da 6b f0 01 	movb   $0x1,0xf06bda04
#if USE_KHEAP
	sched_delete_ready_queues();
f01069ba:	e8 5a e8 ff ff       	call   f0105219 <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069bf:	83 ec 0c             	sub    $0xc,%esp
f01069c2:	6a 10                	push   $0x10
f01069c4:	e8 20 28 00 00       	call   f01091e9 <kmalloc>
f01069c9:	83 c4 10             	add    $0x10,%esp
f01069cc:	a3 50 d3 6b f0       	mov    %eax,0xf06bd350
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f01069d1:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f01069d6:	0f b6 c0             	movzbl %al,%eax
f01069d9:	83 ec 0c             	sub    $0xc,%esp
f01069dc:	50                   	push   %eax
f01069dd:	e8 07 28 00 00       	call   f01091e9 <kmalloc>
f01069e2:	83 c4 10             	add    $0x10,%esp
f01069e5:	a3 84 d6 6b f0       	mov    %eax,0xf06bd684
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01069ea:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f01069ef:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01069f2:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f01069f4:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f01069f9:	8a 00                	mov    (%eax),%al
f01069fb:	0f b6 c0             	movzbl %al,%eax
f01069fe:	83 ec 0c             	sub    $0xc,%esp
f0106a01:	50                   	push   %eax
f0106a02:	e8 7c e3 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106a07:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a0a:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106a0f:	83 ec 0c             	sub    $0xc,%esp
f0106a12:	50                   	push   %eax
f0106a13:	e8 51 e5 ff ff       	call   f0104f69 <init_queue>
f0106a18:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a1b:	e8 c2 e4 ff ff       	call   f0104ee2 <kclock_read_cnt0_latch>
f0106a20:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a24:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a28:	83 ec 08             	sub    $0x8,%esp
f0106a2b:	50                   	push   %eax
f0106a2c:	68 f0 50 12 f0       	push   $0xf01250f0
f0106a31:	e8 55 a5 ff ff       	call   f0100f8b <cprintf>
f0106a36:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a39:	e8 ce 06 00 00       	call   f010710c <mycpu>
f0106a3e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a45:	00 00 00 
	scheduler_method = SCH_RR;
f0106a48:	c7 05 b4 d7 6b f0 00 	movl   $0x0,0xf06bd7b4
f0106a4f:	00 00 00 
	//=========================================
	//=========================================
}
f0106a52:	90                   	nop
f0106a53:	c9                   	leave  
f0106a54:	c3                   	ret    

f0106a55 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a55:	55                   	push   %ebp
f0106a56:	89 e5                	mov    %esp,%ebp
f0106a58:	83 ec 18             	sub    $0x18,%esp
f0106a5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a5e:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a61:	e8 b3 e7 ff ff       	call   f0105219 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a66:	83 ec 04             	sub    $0x4,%esp
f0106a69:	68 18 51 12 f0       	push   $0xf0125118
f0106a6e:	68 ce 00 00 00       	push   $0xce
f0106a73:	68 62 50 12 f0       	push   $0xf0125062
f0106a78:	e8 bc 98 ff ff       	call   f0100339 <_panic>

f0106a7d <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106a7d:	55                   	push   %ebp
f0106a7e:	89 e5                	mov    %esp,%ebp
f0106a80:	83 ec 18             	sub    $0x18,%esp
f0106a83:	8b 55 08             	mov    0x8(%ebp),%edx
f0106a86:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106a89:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106a8c:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a8f:	83 ec 04             	sub    $0x4,%esp
f0106a92:	68 18 51 12 f0       	push   $0xf0125118
f0106a97:	68 e4 00 00 00       	push   $0xe4
f0106a9c:	68 62 50 12 f0       	push   $0xf0125062
f0106aa1:	e8 93 98 ff ff       	call   f0100339 <_panic>

f0106aa6 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106aa6:	55                   	push   %ebp
f0106aa7:	89 e5                	mov    %esp,%ebp
f0106aa9:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106aac:	83 ec 0c             	sub    $0xc,%esp
f0106aaf:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106ab4:	e8 76 8d 00 00       	call   f010f82f <holding_spinlock>
f0106ab9:	83 c4 10             	add    $0x10,%esp
f0106abc:	85 c0                	test   %eax,%eax
f0106abe:	75 17                	jne    f0106ad7 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106ac0:	83 ec 04             	sub    $0x4,%esp
f0106ac3:	68 2c 51 12 f0       	push   $0xf012512c
f0106ac8:	68 fe 00 00 00       	push   $0xfe
f0106acd:	68 62 50 12 f0       	push   $0xf0125062
f0106ad2:	e8 62 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106ad7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106ade:	e8 a5 48 00 00       	call   f010b388 <get_cpu_proc>
f0106ae3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aea:	74 14                	je     f0106b00 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106aec:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106af1:	83 ec 08             	sub    $0x8,%esp
f0106af4:	ff 75 f0             	pushl  -0x10(%ebp)
f0106af7:	50                   	push   %eax
f0106af8:	e8 ad e4 ff ff       	call   f0104faa <enqueue>
f0106afd:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b00:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f0106b05:	83 ec 0c             	sub    $0xc,%esp
f0106b08:	50                   	push   %eax
f0106b09:	e8 2d e5 ff ff       	call   f010503b <dequeue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
f0106b11:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b14:	a1 84 d6 6b f0       	mov    0xf06bd684,%eax
f0106b19:	8a 00                	mov    (%eax),%al
f0106b1b:	0f b6 c0             	movzbl %al,%eax
f0106b1e:	83 ec 0c             	sub    $0xc,%esp
f0106b21:	50                   	push   %eax
f0106b22:	e8 5c e2 ff ff       	call   f0104d83 <kclock_set_quantum>
f0106b27:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b2d:	c9                   	leave  
f0106b2e:	c3                   	ret    

f0106b2f <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b2f:	55                   	push   %ebp
f0106b30:	89 e5                	mov    %esp,%ebp
f0106b32:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b35:	83 ec 0c             	sub    $0xc,%esp
f0106b38:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106b3d:	e8 ed 8c 00 00       	call   f010f82f <holding_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
f0106b45:	85 c0                	test   %eax,%eax
f0106b47:	75 17                	jne    f0106b60 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b49:	83 ec 04             	sub    $0x4,%esp
f0106b4c:	68 78 51 12 f0       	push   $0xf0125178
f0106b51:	68 1d 01 00 00       	push   $0x11d
f0106b56:	68 62 50 12 f0       	push   $0xf0125062
f0106b5b:	e8 d9 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b60:	83 ec 04             	sub    $0x4,%esp
f0106b63:	68 18 51 12 f0       	push   $0xf0125118
f0106b68:	68 23 01 00 00       	push   $0x123
f0106b6d:	68 62 50 12 f0       	push   $0xf0125062
f0106b72:	e8 c2 97 ff ff       	call   f0100339 <_panic>

f0106b77 <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106b77:	55                   	push   %ebp
f0106b78:	89 e5                	mov    %esp,%ebp
f0106b7a:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b7d:	83 ec 0c             	sub    $0xc,%esp
f0106b80:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f0106b85:	e8 a5 8c 00 00       	call   f010f82f <holding_spinlock>
f0106b8a:	83 c4 10             	add    $0x10,%esp
f0106b8d:	85 c0                	test   %eax,%eax
f0106b8f:	75 17                	jne    f0106ba8 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106b91:	83 ec 04             	sub    $0x4,%esp
f0106b94:	68 c8 51 12 f0       	push   $0xf01251c8
f0106b99:	68 2e 01 00 00       	push   $0x12e
f0106b9e:	68 62 50 12 f0       	push   $0xf0125062
f0106ba3:	e8 91 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ba8:	83 ec 04             	sub    $0x4,%esp
f0106bab:	68 18 51 12 f0       	push   $0xf0125118
f0106bb0:	68 34 01 00 00       	push   $0x134
f0106bb5:	68 62 50 12 f0       	push   $0xf0125062
f0106bba:	e8 7a 97 ff ff       	call   f0100339 <_panic>

f0106bbf <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bbf:	55                   	push   %ebp
f0106bc0:	89 e5                	mov    %esp,%ebp
f0106bc2:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bc5:	e8 48 fb ff ff       	call   f0106712 <isSchedMethodBSD>
f0106bca:	85 c0                	test   %eax,%eax
f0106bcc:	74 17                	je     f0106be5 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106bce:	83 ec 04             	sub    $0x4,%esp
f0106bd1:	68 18 51 12 f0       	push   $0xf0125118
f0106bd6:	68 43 01 00 00       	push   $0x143
f0106bdb:	68 62 50 12 f0       	push   $0xf0125062
f0106be0:	e8 54 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106be5:	a1 68 d9 6b f0       	mov    0xf06bd968,%eax
f0106bea:	8b 15 6c d9 6b f0    	mov    0xf06bd96c,%edx
f0106bf0:	83 c0 01             	add    $0x1,%eax
f0106bf3:	83 d2 00             	adc    $0x0,%edx
f0106bf6:	a3 68 d9 6b f0       	mov    %eax,0xf06bd968
f0106bfb:	89 15 6c d9 6b f0    	mov    %edx,0xf06bd96c
	struct Env* p = get_cpu_proc();
f0106c01:	e8 82 47 00 00       	call   f010b388 <get_cpu_proc>
f0106c06:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c0d:	74 30                	je     f0106c3f <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c12:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0106c18:	8d 50 01             	lea    0x1(%eax),%edx
f0106c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c1e:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c24:	83 ec 0c             	sub    $0xc,%esp
f0106c27:	6a 01                	push   $0x1
f0106c29:	e8 95 83 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f0106c2e:	83 c4 10             	add    $0x10,%esp
f0106c31:	85 c0                	test   %eax,%eax
f0106c33:	74 05                	je     f0106c3a <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c35:	e8 08 00 00 00       	call   f0106c42 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c3a:	e8 6b 48 00 00       	call   f010b4aa <yield>
	}
	/*****************************************/
}
f0106c3f:	90                   	nop
f0106c40:	c9                   	leave  
f0106c41:	c3                   	ret    

f0106c42 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c42:	55                   	push   %ebp
f0106c43:	89 e5                	mov    %esp,%ebp
f0106c45:	53                   	push   %ebx
f0106c46:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c49:	e8 3a 47 00 00       	call   f010b388 <get_cpu_proc>
f0106c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c55:	0f 84 a1 01 00 00    	je     f0106dfc <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5e:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0106c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c67:	eb 78                	jmp    f0106ce1 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6c:	8b 00                	mov    (%eax),%eax
f0106c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c74:	8b 40 64             	mov    0x64(%eax),%eax
f0106c77:	83 ec 08             	sub    $0x8,%esp
f0106c7a:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c7d:	50                   	push   %eax
f0106c7e:	e8 09 2a 00 00       	call   f010968c <pt_get_page_permissions>
f0106c83:	83 c4 10             	add    $0x10,%esp
f0106c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106c89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c8c:	8b 40 08             	mov    0x8(%eax),%eax
f0106c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106c92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106c95:	83 e0 20             	and    $0x20,%eax
f0106c98:	85 c0                	test   %eax,%eax
f0106c9a:	74 2b                	je     f0106cc7 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106c9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106c9f:	c1 e8 02             	shr    $0x2,%eax
f0106ca2:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106ca7:	89 c2                	mov    %eax,%edx
f0106ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cac:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cb2:	8b 40 64             	mov    0x64(%eax),%eax
f0106cb5:	6a 20                	push   $0x20
f0106cb7:	6a 00                	push   $0x0
f0106cb9:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cbc:	50                   	push   %eax
f0106cbd:	e8 06 29 00 00       	call   f01095c8 <pt_set_page_permissions>
f0106cc2:	83 c4 10             	add    $0x10,%esp
f0106cc5:	eb 0e                	jmp    f0106cd5 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cca:	c1 e8 02             	shr    $0x2,%eax
f0106ccd:	89 c2                	mov    %eax,%edx
f0106ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cd2:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cd8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ce1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ce5:	74 08                	je     f0106cef <update_WS_time_stamps+0xad>
f0106ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cea:	8b 40 10             	mov    0x10(%eax),%eax
f0106ced:	eb 05                	jmp    f0106cf4 <update_WS_time_stamps+0xb2>
f0106cef:	b8 00 00 00 00       	mov    $0x0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0106cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d00:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0106d06:	85 c0                	test   %eax,%eax
f0106d08:	0f 85 5b ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
f0106d0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d12:	0f 85 51 ff ff ff    	jne    f0106c69 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d1f:	e9 ce 00 00 00       	jmp    f0106df2 <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d24:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d27:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d2a:	89 d0                	mov    %edx,%eax
f0106d2c:	01 c0                	add    %eax,%eax
f0106d2e:	01 d0                	add    %edx,%eax
f0106d30:	c1 e0 03             	shl    $0x3,%eax
f0106d33:	01 c8                	add    %ecx,%eax
f0106d35:	05 b0 00 00 00       	add    $0xb0,%eax
f0106d3a:	8a 00                	mov    (%eax),%al
f0106d3c:	3c 01                	cmp    $0x1,%al
f0106d3e:	0f 84 ab 00 00 00    	je     f0106def <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d4a:	89 d0                	mov    %edx,%eax
f0106d4c:	01 c0                	add    %eax,%eax
f0106d4e:	01 d0                	add    %edx,%eax
f0106d50:	c1 e0 03             	shl    $0x3,%eax
f0106d53:	01 c8                	add    %ecx,%eax
f0106d55:	05 ac 00 00 00       	add    $0xac,%eax
f0106d5a:	8b 00                	mov    (%eax),%eax
f0106d5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d65:	89 d0                	mov    %edx,%eax
f0106d67:	01 c0                	add    %eax,%eax
f0106d69:	01 d0                	add    %edx,%eax
f0106d6b:	c1 e0 03             	shl    $0x3,%eax
f0106d6e:	01 c8                	add    %ecx,%eax
f0106d70:	05 b4 00 00 00       	add    $0xb4,%eax
f0106d75:	8b 00                	mov    (%eax),%eax
f0106d77:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d7d:	8b 40 64             	mov    0x64(%eax),%eax
f0106d80:	83 ec 08             	sub    $0x8,%esp
f0106d83:	ff 75 dc             	pushl  -0x24(%ebp)
f0106d86:	50                   	push   %eax
f0106d87:	e8 dc 29 00 00       	call   f0109768 <pd_is_table_used>
f0106d8c:	83 c4 10             	add    $0x10,%esp
f0106d8f:	85 c0                	test   %eax,%eax
f0106d91:	74 3c                	je     f0106dcf <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106d93:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106d96:	c1 e8 02             	shr    $0x2,%eax
f0106d99:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106d9e:	89 c1                	mov    %eax,%ecx
f0106da0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106da3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106da6:	89 d0                	mov    %edx,%eax
f0106da8:	01 c0                	add    %eax,%eax
f0106daa:	01 d0                	add    %edx,%eax
f0106dac:	c1 e0 03             	shl    $0x3,%eax
f0106daf:	01 d8                	add    %ebx,%eax
f0106db1:	05 b4 00 00 00       	add    $0xb4,%eax
f0106db6:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106dbb:	8b 40 64             	mov    0x64(%eax),%eax
f0106dbe:	83 ec 08             	sub    $0x8,%esp
f0106dc1:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dc4:	50                   	push   %eax
f0106dc5:	e8 c2 29 00 00       	call   f010978c <pd_set_table_unused>
f0106dca:	83 c4 10             	add    $0x10,%esp
f0106dcd:	eb 20                	jmp    f0106def <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106dcf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dd2:	c1 e8 02             	shr    $0x2,%eax
f0106dd5:	89 c1                	mov    %eax,%ecx
f0106dd7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106dda:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ddd:	89 d0                	mov    %edx,%eax
f0106ddf:	01 c0                	add    %eax,%eax
f0106de1:	01 d0                	add    %edx,%eax
f0106de3:	c1 e0 03             	shl    $0x3,%eax
f0106de6:	01 d8                	add    %ebx,%eax
f0106de8:	05 b4 00 00 00       	add    $0xb4,%eax
f0106ded:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106def:	ff 45 f0             	incl   -0x10(%ebp)
f0106df2:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106df6:	0f 8e 28 ff ff ff    	jle    f0106d24 <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106dfc:	90                   	nop
f0106dfd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e00:	c9                   	leave  
f0106e01:	c3                   	ret    

f0106e02 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e02:	55                   	push   %ebp
f0106e03:	89 e5                	mov    %esp,%ebp
f0106e05:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e08:	c7 05 cc 47 69 f0 01 	movl   $0x1,0xf06947cc
f0106e0f:	00 00 00 
f0106e12:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e19:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e1d:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e23:	ee                   	out    %al,(%dx)
f0106e24:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e2b:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e2f:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e32:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e35:	ee                   	out    %al,(%dx)
f0106e36:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e3d:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e41:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e47:	ee                   	out    %al,(%dx)
f0106e48:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e4f:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e53:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e56:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e59:	ee                   	out    %al,(%dx)
f0106e5a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e61:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e65:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106e6b:	ee                   	out    %al,(%dx)
f0106e6c:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106e73:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106e77:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106e7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106e7d:	ee                   	out    %al,(%dx)
f0106e7e:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106e85:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106e89:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106e8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106e8f:	ee                   	out    %al,(%dx)
f0106e90:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106e97:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106e9b:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106e9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ea1:	ee                   	out    %al,(%dx)
f0106ea2:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ea9:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ead:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eb3:	ee                   	out    %al,(%dx)
f0106eb4:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ebb:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ebf:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106ec2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106ec5:	ee                   	out    %al,(%dx)
f0106ec6:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106ecd:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106ed1:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106ed4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106ed7:	ee                   	out    %al,(%dx)
f0106ed8:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106edf:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106ee3:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106ee6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106ee9:	ee                   	out    %al,(%dx)
f0106eea:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106ef1:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106ef5:	8a 45 be             	mov    -0x42(%ebp),%al
f0106ef8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106efb:	ee                   	out    %al,(%dx)
f0106efc:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f03:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f07:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f0d:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f0e:	66 a1 58 e9 17 f0    	mov    0xf017e958,%ax
f0106f14:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f18:	74 15                	je     f0106f2f <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f1a:	66 a1 58 e9 17 f0    	mov    0xf017e958,%ax
f0106f20:	0f b7 c0             	movzwl %ax,%eax
f0106f23:	83 ec 0c             	sub    $0xc,%esp
f0106f26:	50                   	push   %eax
f0106f27:	e8 06 00 00 00       	call   f0106f32 <irq_setmask_8259A>
f0106f2c:	83 c4 10             	add    $0x10,%esp
}
f0106f2f:	90                   	nop
f0106f30:	c9                   	leave  
f0106f31:	c3                   	ret    

f0106f32 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f32:	55                   	push   %ebp
f0106f33:	89 e5                	mov    %esp,%ebp
f0106f35:	83 ec 14             	sub    $0x14,%esp
f0106f38:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f3b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f3f:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f0106f44:	85 c0                	test   %eax,%eax
f0106f46:	74 34                	je     f0106f7c <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f4b:	0f b6 c0             	movzbl %al,%eax
f0106f4e:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f55:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f58:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f5e:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f62:	66 c1 e8 08          	shr    $0x8,%ax
f0106f66:	0f b6 c0             	movzbl %al,%eax
f0106f69:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106f70:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106f73:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106f76:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106f79:	ee                   	out    %al,(%dx)
f0106f7a:	eb 01                	jmp    f0106f7d <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106f7c:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106f7d:	c9                   	leave  
f0106f7e:	c3                   	ret    

f0106f7f <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106f7f:	55                   	push   %ebp
f0106f80:	89 e5                	mov    %esp,%ebp
f0106f82:	53                   	push   %ebx
f0106f83:	83 ec 14             	sub    $0x14,%esp
f0106f86:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f89:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106f8c:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f0106f91:	85 c0                	test   %eax,%eax
f0106f93:	74 58                	je     f0106fed <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106f95:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106f99:	77 08                	ja     f0106fa3 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106f9b:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fa1:	eb 0a                	jmp    f0106fad <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fa3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fa9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fad:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb7:	89 c2                	mov    %eax,%edx
f0106fb9:	ec                   	in     (%dx),%al
f0106fba:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106fbd:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106fc0:	88 c2                	mov    %al,%dl
f0106fc2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106fc6:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106fcb:	88 c1                	mov    %al,%cl
f0106fcd:	d3 e3                	shl    %cl,%ebx
f0106fcf:	89 d8                	mov    %ebx,%eax
f0106fd1:	09 d0                	or     %edx,%eax
f0106fd3:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106fd6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106fda:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106fde:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106fe1:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106fe4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fea:	ee                   	out    %al,(%dx)
f0106feb:	eb 01                	jmp    f0106fee <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106fed:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106fee:	83 c4 14             	add    $0x14,%esp
f0106ff1:	5b                   	pop    %ebx
f0106ff2:	5d                   	pop    %ebp
f0106ff3:	c3                   	ret    

f0106ff4 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ff4:	55                   	push   %ebp
f0106ff5:	89 e5                	mov    %esp,%ebp
f0106ff7:	53                   	push   %ebx
f0106ff8:	83 ec 14             	sub    $0x14,%esp
f0106ffb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106ffe:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107001:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f0107006:	85 c0                	test   %eax,%eax
f0107008:	74 5a                	je     f0107064 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f010700a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010700e:	77 08                	ja     f0107018 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107010:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107016:	eb 0a                	jmp    f0107022 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107018:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010701e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107022:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107026:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107029:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010702c:	89 c2                	mov    %eax,%edx
f010702e:	ec                   	in     (%dx),%al
f010702f:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107032:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107035:	88 c2                	mov    %al,%dl
f0107037:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010703b:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107040:	88 c1                	mov    %al,%cl
f0107042:	d3 e3                	shl    %cl,%ebx
f0107044:	89 d8                	mov    %ebx,%eax
f0107046:	f7 d0                	not    %eax
f0107048:	21 d0                	and    %edx,%eax
f010704a:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010704d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107051:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107055:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107058:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010705b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010705e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107061:	ee                   	out    %al,(%dx)
f0107062:	eb 01                	jmp    f0107065 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107064:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107065:	83 c4 14             	add    $0x14,%esp
f0107068:	5b                   	pop    %ebx
f0107069:	5d                   	pop    %ebp
f010706a:	c3                   	ret    

f010706b <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f010706b:	55                   	push   %ebp
f010706c:	89 e5                	mov    %esp,%ebp
f010706e:	53                   	push   %ebx
f010706f:	83 ec 14             	sub    $0x14,%esp
f0107072:	8b 45 08             	mov    0x8(%ebp),%eax
f0107075:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107078:	a1 cc 47 69 f0       	mov    0xf06947cc,%eax
f010707d:	85 c0                	test   %eax,%eax
f010707f:	75 07                	jne    f0107088 <irq_get_mask+0x1d>
		return -1;
f0107081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107086:	eb 45                	jmp    f01070cd <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107088:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f010708c:	77 08                	ja     f0107096 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f010708e:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107094:	eb 0a                	jmp    f01070a0 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107096:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f010709c:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070aa:	89 c2                	mov    %eax,%edx
f01070ac:	ec                   	in     (%dx),%al
f01070ad:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070b0:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070b3:	88 c2                	mov    %al,%dl
f01070b5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070b9:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070be:	88 c1                	mov    %al,%cl
f01070c0:	d3 e3                	shl    %cl,%ebx
f01070c2:	89 d8                	mov    %ebx,%eax
f01070c4:	21 d0                	and    %edx,%eax
f01070c6:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01070c9:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01070cd:	83 c4 14             	add    $0x14,%esp
f01070d0:	5b                   	pop    %ebx
f01070d1:	5d                   	pop    %ebp
f01070d2:	c3                   	ret    

f01070d3 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01070d3:	55                   	push   %ebp
f01070d4:	89 e5                	mov    %esp,%ebp
f01070d6:	83 ec 14             	sub    $0x14,%esp
f01070d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01070dc:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01070df:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01070e3:	76 12                	jbe    f01070f7 <pic_sendEOI+0x24>
f01070e5:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01070ec:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01070f0:	8a 45 f7             	mov    -0x9(%ebp),%al
f01070f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01070f6:	ee                   	out    %al,(%dx)
f01070f7:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01070fe:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107102:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107105:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107108:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107109:	90                   	nop
f010710a:	c9                   	leave  
f010710b:	c3                   	ret    

f010710c <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f010710c:	55                   	push   %ebp
f010710d:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f010710f:	b8 a0 d4 6b f0       	mov    $0xf06bd4a0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107114:	5d                   	pop    %ebp
f0107115:	c3                   	ret    

f0107116 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107116:	55                   	push   %ebp
f0107117:	89 e5                	mov    %esp,%ebp
f0107119:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f010711c:	e8 eb ff ff ff       	call   f010710c <mycpu>
f0107121:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107124:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107127:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010712e:	00 00 00 
  c->ncli = 0;
f0107131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107134:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010713b:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010713e:	9c                   	pushf  
f010713f:	58                   	pop    %eax
f0107140:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107143:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107146:	25 00 02 00 00       	and    $0x200,%eax
f010714b:	85 c0                	test   %eax,%eax
f010714d:	0f 95 c0             	setne  %al
f0107150:	0f b6 d0             	movzbl %al,%edx
f0107153:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107156:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107170:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107173:	8b 45 08             	mov    0x8(%ebp),%eax
f0107176:	40                   	inc    %eax
f0107177:	c1 e0 0f             	shl    $0xf,%eax
f010717a:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010717f:	29 c2                	sub    %eax,%edx
f0107181:	89 d0                	mov    %edx,%eax
f0107183:	89 c2                	mov    %eax,%edx
f0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107188:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f010718b:	e8 18 01 00 00       	call   f01072a8 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107190:	e8 c3 58 00 00       	call   f010ca58 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107198:	83 c0 0c             	add    $0xc,%eax
f010719b:	83 ec 04             	sub    $0x4,%esp
f010719e:	6a 68                	push   $0x68
f01071a0:	6a 00                	push   $0x0
f01071a2:	50                   	push   %eax
f01071a3:	e8 0a 86 01 00       	call   f011f7b2 <memset>
f01071a8:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ae:	05 a4 00 00 00       	add    $0xa4,%eax
f01071b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071c6:	f0 87 02             	lock xchg %eax,(%edx)
f01071c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01071cc:	90                   	nop
f01071cd:	c9                   	leave  
f01071ce:	c3                   	ret    

f01071cf <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01071cf:	55                   	push   %ebp
f01071d0:	89 e5                	mov    %esp,%ebp
f01071d2:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01071d5:	9c                   	pushf  
f01071d6:	58                   	pop    %eax
f01071d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01071da:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01071dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01071e0:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01071e1:	e8 26 ff ff ff       	call   f010710c <mycpu>
f01071e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01071e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ec:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01071f2:	85 c0                	test   %eax,%eax
f01071f4:	75 13                	jne    f0107209 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01071f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01071f9:	25 00 02 00 00       	and    $0x200,%eax
f01071fe:	89 c2                	mov    %eax,%edx
f0107200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107203:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107212:	8d 50 01             	lea    0x1(%eax),%edx
f0107215:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107218:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010721e:	90                   	nop
f010721f:	c9                   	leave  
f0107220:	c3                   	ret    

f0107221 <popcli>:

void popcli(void)
{
f0107221:	55                   	push   %ebp
f0107222:	89 e5                	mov    %esp,%ebp
f0107224:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107227:	9c                   	pushf  
f0107228:	58                   	pop    %eax
f0107229:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010722c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010722f:	25 00 02 00 00       	and    $0x200,%eax
f0107234:	85 c0                	test   %eax,%eax
f0107236:	74 14                	je     f010724c <popcli+0x2b>
    panic("popcli - interruptible");
f0107238:	83 ec 04             	sub    $0x4,%esp
f010723b:	68 15 52 12 f0       	push   $0xf0125215
f0107240:	6a 5e                	push   $0x5e
f0107242:	68 2c 52 12 f0       	push   $0xf012522c
f0107247:	e8 ed 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f010724c:	e8 bb fe ff ff       	call   f010710c <mycpu>
f0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010725d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107269:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107272:	85 c0                	test   %eax,%eax
f0107274:	79 14                	jns    f010728a <popcli+0x69>
    panic("popcli");
f0107276:	83 ec 04             	sub    $0x4,%esp
f0107279:	68 3b 52 12 f0       	push   $0xf012523b
f010727e:	6a 61                	push   $0x61
f0107280:	68 2c 52 12 f0       	push   $0xf012522c
f0107285:	e8 af 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f010728a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107293:	85 c0                	test   %eax,%eax
f0107295:	75 0e                	jne    f01072a5 <popcli+0x84>
f0107297:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072a0:	85 c0                	test   %eax,%eax
f01072a2:	74 01                	je     f01072a5 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072a4:	fb                   	sti    
    sti();
}
f01072a5:	90                   	nop
f01072a6:	c9                   	leave  
f01072a7:	c3                   	ret    

f01072a8 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072a8:	55                   	push   %ebp
f01072a9:	89 e5                	mov    %esp,%ebp
f01072ab:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072ae:	e8 1c ff ff ff       	call   f01071cf <pushcli>

	c = mycpu();
f01072b3:	e8 54 fe ff ff       	call   f010710c <mycpu>
f01072b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072be:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072c5:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01072cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072cf:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01072d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d8:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01072de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e1:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01072e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072eb:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01072f1:	83 e2 f0             	and    $0xfffffff0,%edx
f01072f4:	83 ca 0a             	or     $0xa,%edx
f01072f7:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107306:	83 ca 10             	or     $0x10,%edx
f0107309:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107318:	83 e2 9f             	and    $0xffffff9f,%edx
f010731b:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107321:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107324:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010732a:	83 ca 80             	or     $0xffffff80,%edx
f010732d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107333:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107336:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010733c:	83 ca 0f             	or     $0xf,%edx
f010733f:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107345:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107348:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010734e:	83 e2 ef             	and    $0xffffffef,%edx
f0107351:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107360:	83 e2 df             	and    $0xffffffdf,%edx
f0107363:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107369:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107372:	83 ca 40             	or     $0x40,%edx
f0107375:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010737e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107384:	83 ca 80             	or     $0xffffff80,%edx
f0107387:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107390:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107397:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010739a:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073a1:	ff ff 
f01073a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a6:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073ad:	00 00 
f01073af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b2:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073bc:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073c2:	83 e2 f0             	and    $0xfffffff0,%edx
f01073c5:	83 ca 02             	or     $0x2,%edx
f01073c8:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d1:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073d7:	83 ca 10             	or     $0x10,%edx
f01073da:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073e9:	83 e2 9f             	and    $0xffffff9f,%edx
f01073ec:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01073f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fb:	83 ca 80             	or     $0xffffff80,%edx
f01073fe:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107404:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107407:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010740d:	83 ca 0f             	or     $0xf,%edx
f0107410:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107416:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107419:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010741f:	83 e2 ef             	and    $0xffffffef,%edx
f0107422:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107428:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107431:	83 e2 df             	and    $0xffffffdf,%edx
f0107434:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010743a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107443:	83 ca 40             	or     $0x40,%edx
f0107446:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010744f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107455:	83 ca 80             	or     $0xffffff80,%edx
f0107458:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010745e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107461:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107468:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010746b:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107472:	ff ff 
f0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107477:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010747e:	00 00 
f0107480:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107483:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010748a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010748d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107493:	83 e2 f0             	and    $0xfffffff0,%edx
f0107496:	83 ca 0a             	or     $0xa,%edx
f0107499:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010749f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a2:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074a8:	83 ca 10             	or     $0x10,%edx
f01074ab:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074b4:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074ba:	83 ca 60             	or     $0x60,%edx
f01074bd:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cc:	83 ca 80             	or     $0xffffff80,%edx
f01074cf:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d8:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074de:	83 ca 0f             	or     $0xf,%edx
f01074e1:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ea:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01074f0:	83 e2 ef             	and    $0xffffffef,%edx
f01074f3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107502:	83 e2 df             	and    $0xffffffdf,%edx
f0107505:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010750b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750e:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107514:	83 ca 40             	or     $0x40,%edx
f0107517:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107520:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107526:	83 ca 80             	or     $0xffffff80,%edx
f0107529:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010752f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107532:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107539:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753c:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107543:	ff ff 
f0107545:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107548:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010754f:	00 00 
f0107551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107554:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010755b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010755e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107564:	83 e2 f0             	and    $0xfffffff0,%edx
f0107567:	83 ca 02             	or     $0x2,%edx
f010756a:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107573:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107579:	83 ca 10             	or     $0x10,%edx
f010757c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107585:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010758b:	83 ca 60             	or     $0x60,%edx
f010758e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107594:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107597:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759d:	83 ca 80             	or     $0xffffff80,%edx
f01075a0:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075a9:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075af:	83 ca 0f             	or     $0xf,%edx
f01075b2:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bb:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075c1:	83 e2 ef             	and    $0xffffffef,%edx
f01075c4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cd:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075d3:	83 e2 df             	and    $0xffffffdf,%edx
f01075d6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075df:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e5:	83 ca 40             	or     $0x40,%edx
f01075e8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f7:	83 ca 80             	or     $0xffffff80,%edx
f01075fa:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107603:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010760a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760d:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107614:	00 00 00 
f0107617:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010761e:	00 00 00 

	popcli();	//enable interrupt
f0107621:	e8 fb fb ff ff       	call   f0107221 <popcli>


}
f0107626:	90                   	nop
f0107627:	c9                   	leave  
f0107628:	c3                   	ret    

f0107629 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107629:	55                   	push   %ebp
f010762a:	89 e5                	mov    %esp,%ebp
f010762c:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010762f:	83 ec 08             	sub    $0x8,%esp
f0107632:	68 00 10 00 00       	push   $0x1000
f0107637:	68 00 10 00 00       	push   $0x1000
f010763c:	e8 42 02 00 00       	call   f0107883 <boot_allocate_space>
f0107641:	83 c4 10             	add    $0x10,%esp
f0107644:	a3 7c d9 6b f0       	mov    %eax,0xf06bd97c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107649:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010764e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107651:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107658:	77 14                	ja     f010766e <initialize_kernel_VM+0x45>
f010765a:	ff 75 e0             	pushl  -0x20(%ebp)
f010765d:	68 44 52 12 f0       	push   $0xf0125244
f0107662:	6a 57                	push   $0x57
f0107664:	68 78 52 12 f0       	push   $0xf0125278
f0107669:	e8 cb 8c ff ff       	call   f0100339 <_panic>
f010766e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107671:	05 00 00 00 10       	add    $0x10000000,%eax
f0107676:	a3 a4 da 6b f0       	mov    %eax,0xf06bdaa4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010767b:	c7 45 dc 00 60 17 f0 	movl   $0xf0176000,-0x24(%ebp)
f0107682:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107689:	77 14                	ja     f010769f <initialize_kernel_VM+0x76>
f010768b:	ff 75 dc             	pushl  -0x24(%ebp)
f010768e:	68 44 52 12 f0       	push   $0xf0125244
f0107693:	6a 63                	push   $0x63
f0107695:	68 78 52 12 f0       	push   $0xf0125278
f010769a:	e8 9a 8c ff ff       	call   f0100339 <_panic>
f010769f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076a2:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076a8:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01076ad:	83 ec 0c             	sub    $0xc,%esp
f01076b0:	6a 02                	push   $0x2
f01076b2:	52                   	push   %edx
f01076b3:	68 00 80 00 00       	push   $0x8000
f01076b8:	68 00 80 bf ef       	push   $0xefbf8000
f01076bd:	50                   	push   %eax
f01076be:	e8 34 02 00 00       	call   f01078f7 <boot_map_range>
f01076c3:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01076cd:	eb 24                	jmp    f01076f3 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01076cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01076d2:	40                   	inc    %eax
f01076d3:	c1 e0 0f             	shl    $0xf,%eax
f01076d6:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01076db:	29 c2                	sub    %eax,%edx
f01076dd:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01076e2:	6a 01                	push   $0x1
f01076e4:	6a 00                	push   $0x0
f01076e6:	52                   	push   %edx
f01076e7:	50                   	push   %eax
f01076e8:	e8 db 1e 00 00       	call   f01095c8 <pt_set_page_permissions>
f01076ed:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076f0:	ff 45 f4             	incl   -0xc(%ebp)
f01076f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076f7:	7e d6                	jle    f01076cf <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01076f9:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107700:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107707:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010770e:	eb 25                	jmp    f0107735 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107710:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107713:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107716:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010771b:	83 ec 04             	sub    $0x4,%esp
f010771e:	6a 01                	push   $0x1
f0107720:	52                   	push   %edx
f0107721:	50                   	push   %eax
f0107722:	e8 44 02 00 00       	call   f010796b <boot_get_page_table>
f0107727:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010772a:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107731:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107735:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107739:	72 d5                	jb     f0107710 <initialize_kernel_VM+0xe7>
f010773b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010773f:	77 06                	ja     f0107747 <initialize_kernel_VM+0x11e>
f0107741:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107745:	76 c9                	jbe    f0107710 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107747:	8b 15 58 d5 6b f0    	mov    0xf06bd558,%edx
f010774d:	89 d0                	mov    %edx,%eax
f010774f:	01 c0                	add    %eax,%eax
f0107751:	01 d0                	add    %edx,%eax
f0107753:	c1 e0 03             	shl    $0x3,%eax
f0107756:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107759:	83 ec 08             	sub    $0x8,%esp
f010775c:	68 00 10 00 00       	push   $0x1000
f0107761:	ff 75 d8             	pushl  -0x28(%ebp)
f0107764:	e8 1a 01 00 00       	call   f0107883 <boot_allocate_space>
f0107769:	83 c4 10             	add    $0x10,%esp
f010776c:	a3 c0 d7 6b f0       	mov    %eax,0xf06bd7c0
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107771:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107778:	83 ec 08             	sub    $0x8,%esp
f010777b:	68 00 10 00 00       	push   $0x1000
f0107780:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107783:	e8 fb 00 00 00       	call   f0107883 <boot_allocate_space>
f0107788:	83 c4 10             	add    $0x10,%esp
f010778b:	a3 80 d0 6b f0       	mov    %eax,0xf06bd080
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107790:	e8 05 05 00 00       	call   f0107c9a <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107795:	83 ec 0c             	sub    $0xc,%esp
f0107798:	68 ca 02 00 00       	push   $0x2ca
f010779d:	e8 80 63 01 00       	call   f011db22 <nearest_pow2_ceil>
f01077a2:	83 c4 10             	add    $0x10,%esp
f01077a5:	83 ec 04             	sub    $0x4,%esp
f01077a8:	50                   	push   %eax
f01077a9:	68 ca 02 00 00       	push   $0x2ca
f01077ae:	68 98 52 12 f0       	push   $0xf0125298
f01077b3:	e8 d3 97 ff ff       	call   f0100f8b <cprintf>
f01077b8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077bb:	c7 45 d0 58 fe 0f 00 	movl   $0xffe58,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01077c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01077c5:	83 ec 08             	sub    $0x8,%esp
f01077c8:	68 00 10 00 00       	push   $0x1000
f01077cd:	50                   	push   %eax
f01077ce:	e8 b0 00 00 00       	call   f0107883 <boot_allocate_space>
f01077d3:	83 c4 10             	add    $0x10,%esp
f01077d6:	a3 d0 47 69 f0       	mov    %eax,0xf06947d0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01077db:	a1 d0 47 69 f0       	mov    0xf06947d0,%eax
f01077e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01077e3:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01077ea:	77 17                	ja     f0107803 <initialize_kernel_VM+0x1da>
f01077ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01077ef:	68 44 52 12 f0       	push   $0xf0125244
f01077f4:	68 b1 00 00 00       	push   $0xb1
f01077f9:	68 78 52 12 f0       	push   $0xf0125278
f01077fe:	e8 36 8b ff ff       	call   f0100339 <_panic>
f0107803:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107806:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010780c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010780f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107814:	83 ec 0c             	sub    $0xc,%esp
f0107817:	6a 04                	push   $0x4
f0107819:	51                   	push   %ecx
f010781a:	52                   	push   %edx
f010781b:	68 00 00 c0 ee       	push   $0xeec00000
f0107820:	50                   	push   %eax
f0107821:	e8 d1 00 00 00       	call   f01078f7 <boot_map_range>
f0107826:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107829:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010782e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107833:	8b 15 7c d9 6b f0    	mov    0xf06bd97c,%edx
f0107839:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010783f:	8b 12                	mov    (%edx),%edx
f0107841:	83 ca 05             	or     $0x5,%edx
f0107844:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107846:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f010784b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107851:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107856:	83 ec 0c             	sub    $0xc,%esp
f0107859:	6a 02                	push   $0x2
f010785b:	6a 00                	push   $0x0
f010785d:	52                   	push   %edx
f010785e:	68 00 00 00 f0       	push   $0xf0000000
f0107863:	50                   	push   %eax
f0107864:	e8 8e 00 00 00       	call   f01078f7 <boot_map_range>
f0107869:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010786c:	e8 84 72 01 00       	call   f011eaf5 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107871:	c7 05 90 d4 6b f0 19 	movl   $0x19,0xf06bd490
f0107878:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010787b:	e8 e6 02 00 00       	call   f0107b66 <turn_on_paging>
}
f0107880:	90                   	nop
f0107881:	c9                   	leave  
f0107882:	c3                   	ret    

f0107883 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107883:	55                   	push   %ebp
f0107884:	89 e5                	mov    %esp,%ebp
f0107886:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107889:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f010788e:	85 c0                	test   %eax,%eax
f0107890:	75 0a                	jne    f010789c <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107892:	c7 05 78 d9 6b f0 90 	movl   $0xf0b08490,0xf06bd978
f0107899:	84 b0 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010789c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010789f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078a2:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f01078a7:	89 c2                	mov    %eax,%edx
f01078a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ac:	01 d0                	add    %edx,%eax
f01078ae:	48                   	dec    %eax
f01078af:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078b5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078ba:	f7 75 f4             	divl   -0xc(%ebp)
f01078bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078c0:	29 d0                	sub    %edx,%eax
f01078c2:	a3 78 d9 6b f0       	mov    %eax,0xf06bd978

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01078c7:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f01078cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01078cf:	8b 15 78 d9 6b f0    	mov    0xf06bd978,%edx
f01078d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01078d8:	01 d0                	add    %edx,%eax
f01078da:	a3 78 d9 6b f0       	mov    %eax,0xf06bd978

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01078df:	83 ec 04             	sub    $0x4,%esp
f01078e2:	ff 75 08             	pushl  0x8(%ebp)
f01078e5:	6a 00                	push   $0x0
f01078e7:	ff 75 ec             	pushl  -0x14(%ebp)
f01078ea:	e8 c3 7e 01 00       	call   f011f7b2 <memset>
f01078ef:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01078f2:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01078f5:	c9                   	leave  
f01078f6:	c3                   	ret    

f01078f7 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01078f7:	55                   	push   %ebp
f01078f8:	89 e5                	mov    %esp,%ebp
f01078fa:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01078fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010790b:	eb 53                	jmp    f0107960 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010790d:	83 ec 04             	sub    $0x4,%esp
f0107910:	6a 01                	push   $0x1
f0107912:	ff 75 0c             	pushl  0xc(%ebp)
f0107915:	ff 75 08             	pushl  0x8(%ebp)
f0107918:	e8 4e 00 00 00       	call   f010796b <boot_get_page_table>
f010791d:	83 c4 10             	add    $0x10,%esp
f0107920:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107923:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107926:	c1 e8 0c             	shr    $0xc,%eax
f0107929:	25 ff 03 00 00       	and    $0x3ff,%eax
f010792e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107931:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107934:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010793b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010793e:	01 c2                	add    %eax,%edx
f0107940:	8b 45 18             	mov    0x18(%ebp),%eax
f0107943:	0b 45 14             	or     0x14(%ebp),%eax
f0107946:	83 c8 01             	or     $0x1,%eax
f0107949:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010794b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107952:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107959:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107963:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107966:	72 a5                	jb     f010790d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0107968:	90                   	nop
f0107969:	c9                   	leave  
f010796a:	c3                   	ret    

f010796b <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010796b:	55                   	push   %ebp
f010796c:	89 e5                	mov    %esp,%ebp
f010796e:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107974:	c1 e8 16             	shr    $0x16,%eax
f0107977:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010797a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010797d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107984:	8b 45 08             	mov    0x8(%ebp),%eax
f0107987:	01 d0                	add    %edx,%eax
f0107989:	8b 00                	mov    (%eax),%eax
f010798b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010798e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107991:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107996:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0107999:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010799c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010799f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079a2:	c1 e8 0c             	shr    $0xc,%eax
f01079a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079a8:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f01079ad:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079b0:	72 17                	jb     f01079c9 <boot_get_page_table+0x5e>
f01079b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079b5:	68 c0 52 12 f0       	push   $0xf01252c0
f01079ba:	68 33 01 00 00       	push   $0x133
f01079bf:	68 78 52 12 f0       	push   $0xf0125278
f01079c4:	e8 70 89 ff ff       	call   f0100339 <_panic>
f01079c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079cc:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01079d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01079d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01079d8:	75 72                	jne    f0107a4c <boot_get_page_table+0xe1>
	{
		if (create)
f01079da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01079de:	74 65                	je     f0107a45 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01079e0:	83 ec 08             	sub    $0x8,%esp
f01079e3:	68 00 10 00 00       	push   $0x1000
f01079e8:	68 00 10 00 00       	push   $0x1000
f01079ed:	e8 91 fe ff ff       	call   f0107883 <boot_allocate_space>
f01079f2:	83 c4 10             	add    $0x10,%esp
f01079f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01079f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01079fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01079fe:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a05:	77 17                	ja     f0107a1e <boot_get_page_table+0xb3>
f0107a07:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a0a:	68 44 52 12 f0       	push   $0xf0125244
f0107a0f:	68 39 01 00 00       	push   $0x139
f0107a14:	68 78 52 12 f0       	push   $0xf0125278
f0107a19:	e8 1b 89 ff ff       	call   f0100339 <_panic>
f0107a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a21:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a26:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a33:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a36:	01 d0                	add    %edx,%eax
f0107a38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a3b:	83 ca 03             	or     $0x3,%edx
f0107a3e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a43:	eb 0a                	jmp    f0107a4f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a45:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a4a:	eb 03                	jmp    f0107a4f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a4f:	c9                   	leave  
f0107a50:	c3                   	ret    

f0107a51 <nvram_read>:


int nvram_read(int r)
{
f0107a51:	55                   	push   %ebp
f0107a52:	89 e5                	mov    %esp,%ebp
f0107a54:	53                   	push   %ebx
f0107a55:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a5b:	83 ec 0c             	sub    $0xc,%esp
f0107a5e:	50                   	push   %eax
f0107a5f:	e8 28 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	89 c3                	mov    %eax,%ebx
f0107a69:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6c:	40                   	inc    %eax
f0107a6d:	83 ec 0c             	sub    $0xc,%esp
f0107a70:	50                   	push   %eax
f0107a71:	e8 16 d1 ff ff       	call   f0104b8c <mc146818_read>
f0107a76:	83 c4 10             	add    $0x10,%esp
f0107a79:	c1 e0 08             	shl    $0x8,%eax
f0107a7c:	09 d8                	or     %ebx,%eax
}
f0107a7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107a81:	c9                   	leave  
f0107a82:	c3                   	ret    

f0107a83 <detect_memory>:

void detect_memory()
{
f0107a83:	55                   	push   %ebp
f0107a84:	89 e5                	mov    %esp,%ebp
f0107a86:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107a89:	83 ec 0c             	sub    $0xc,%esp
f0107a8c:	6a 15                	push   $0x15
f0107a8e:	e8 be ff ff ff       	call   f0107a51 <nvram_read>
f0107a93:	83 c4 10             	add    $0x10,%esp
f0107a96:	c1 e0 0a             	shl    $0xa,%eax
f0107a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107aa7:	83 ec 0c             	sub    $0xc,%esp
f0107aaa:	6a 17                	push   $0x17
f0107aac:	e8 a0 ff ff ff       	call   f0107a51 <nvram_read>
f0107ab1:	83 c4 10             	add    $0x10,%esp
f0107ab4:	c1 e0 0a             	shl    $0xa,%eax
f0107ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107abd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ac2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107ac5:	83 ec 0c             	sub    $0xc,%esp
f0107ac8:	6a 34                	push   $0x34
f0107aca:	e8 82 ff ff ff       	call   f0107a51 <nvram_read>
f0107acf:	83 c4 10             	add    $0x10,%esp
f0107ad2:	c1 e0 10             	shl    $0x10,%eax
f0107ad5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107ad8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107adb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107ae3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107ae7:	74 18                	je     f0107b01 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107aec:	05 00 00 00 01       	add    $0x1000000,%eax
f0107af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af7:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107afc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107aff:	eb 19                	jmp    f0107b1a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b05:	74 0d                	je     f0107b14 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b0a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b12:	eb 06                	jmp    f0107b1a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b1a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b24:	c1 e8 0c             	shr    $0xc,%eax
f0107b27:	a3 58 d5 6b f0       	mov    %eax,0xf06bd558

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2f:	c1 e8 0a             	shr    $0xa,%eax
f0107b32:	83 ec 08             	sub    $0x8,%esp
f0107b35:	50                   	push   %eax
f0107b36:	68 f0 52 12 f0       	push   $0xf01252f0
f0107b3b:	e8 4b 94 ff ff       	call   f0100f8b <cprintf>
f0107b40:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b46:	c1 e8 0a             	shr    $0xa,%eax
f0107b49:	89 c2                	mov    %eax,%edx
f0107b4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b4e:	c1 e8 0a             	shr    $0xa,%eax
f0107b51:	83 ec 04             	sub    $0x4,%esp
f0107b54:	52                   	push   %edx
f0107b55:	50                   	push   %eax
f0107b56:	68 13 53 12 f0       	push   $0xf0125313
f0107b5b:	e8 2b 94 ff ff       	call   f0100f8b <cprintf>
f0107b60:	83 c4 10             	add    $0x10,%esp
}
f0107b63:	90                   	nop
f0107b64:	c9                   	leave  
f0107b65:	c3                   	ret    

f0107b66 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107b66:	55                   	push   %ebp
f0107b67:	89 e5                	mov    %esp,%ebp
f0107b69:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107b6c:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b7a:	eb 24                	jmp    f0107ba0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107b7c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107b81:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107b84:	c1 e2 02             	shl    $0x2,%edx
f0107b87:	01 c2                	add    %eax,%edx
f0107b89:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107b8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107b91:	c1 e1 02             	shl    $0x2,%ecx
f0107b94:	01 c8                	add    %ecx,%eax
f0107b96:	8b 00                	mov    (%eax),%eax
f0107b98:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107b9a:	ff 45 f4             	incl   -0xc(%ebp)
f0107b9d:	ff 45 f0             	incl   -0x10(%ebp)
f0107ba0:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f0107ba5:	c1 e8 16             	shr    $0x16,%eax
f0107ba8:	89 c2                	mov    %eax,%edx
f0107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bad:	39 c2                	cmp    %eax,%edx
f0107baf:	77 cb                	ja     f0107b7c <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bb1:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0107bb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bbc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bbf:	0f 20 c0             	mov    %cr0,%eax
f0107bc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107bc5:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107bcb:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107bd2:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107bd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107bd9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107bdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107bdf:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107be2:	e8 e8 f5 ff ff       	call   f01071cf <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107be7:	e8 20 f5 ff ff       	call   f010710c <mycpu>
f0107bec:	83 c0 74             	add    $0x74,%eax
f0107bef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107bf2:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107bfc:	48                   	dec    %eax
f0107bfd:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c04:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c08:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c0b:	c1 e8 10             	shr    $0x10,%eax
f0107c0e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c12:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c15:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c18:	e8 04 f6 ff ff       	call   f0107221 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c1d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c22:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c24:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c29:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c2b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c30:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c32:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c37:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c39:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c3e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c40:	ea 47 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c47
	asm volatile("lldt %%ax" :: "a" (0));
f0107c47:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c4c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c4f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c5d:	eb 19                	jmp    f0107c78 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c5f:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107c64:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107c67:	c1 e2 02             	shl    $0x2,%edx
f0107c6a:	01 d0                	add    %edx,%eax
f0107c6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c72:	ff 45 ec             	incl   -0x14(%ebp)
f0107c75:	ff 45 e8             	incl   -0x18(%ebp)
f0107c78:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f0107c7d:	c1 e8 16             	shr    $0x16,%eax
f0107c80:	89 c2                	mov    %eax,%edx
f0107c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107c85:	39 c2                	cmp    %eax,%edx
f0107c87:	77 d6                	ja     f0107c5f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107c89:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0107c8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107c91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107c94:	0f 22 d8             	mov    %eax,%cr3

}
f0107c97:	90                   	nop
f0107c98:	c9                   	leave  
f0107c99:	c3                   	ret    

f0107c9a <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107c9a:	55                   	push   %ebp
f0107c9b:	89 e5                	mov    %esp,%ebp
f0107c9d:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ca0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107ca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ca8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107caf:	77 17                	ja     f0107cc8 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cb4:	68 44 52 12 f0       	push   $0xf0125244
f0107cb9:	68 cf 01 00 00       	push   $0x1cf
f0107cbe:	68 78 52 12 f0       	push   $0xf0125278
f0107cc3:	e8 71 86 ff ff       	call   f0100339 <_panic>
f0107cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccb:	05 00 00 00 10       	add    $0x10000000,%eax
f0107cd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107cd3:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107cd8:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107cdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ce0:	83 ca 03             	or     $0x3,%edx
f0107ce3:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107ce5:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107cea:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107cf0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0107cf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107cf8:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107cff:	77 17                	ja     f0107d18 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d01:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d04:	68 44 52 12 f0       	push   $0xf0125244
f0107d09:	68 d4 01 00 00       	push   $0x1d4
f0107d0e:	68 78 52 12 f0       	push   $0xf0125278
f0107d13:	e8 21 86 ff ff       	call   f0100339 <_panic>
f0107d18:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d1b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d20:	83 c8 05             	or     $0x5,%eax
f0107d23:	89 02                	mov    %eax,(%edx)

}
f0107d25:	90                   	nop
f0107d26:	c9                   	leave  
f0107d27:	c3                   	ret    

f0107d28 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d28:	55                   	push   %ebp
f0107d29:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d2e:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0107d34:	29 d0                	sub    %edx,%eax
f0107d36:	c1 f8 03             	sar    $0x3,%eax
f0107d39:	89 c2                	mov    %eax,%edx
f0107d3b:	89 d0                	mov    %edx,%eax
f0107d3d:	c1 e0 02             	shl    $0x2,%eax
f0107d40:	01 d0                	add    %edx,%eax
f0107d42:	c1 e0 02             	shl    $0x2,%eax
f0107d45:	01 d0                	add    %edx,%eax
f0107d47:	c1 e0 02             	shl    $0x2,%eax
f0107d4a:	01 d0                	add    %edx,%eax
f0107d4c:	89 c1                	mov    %eax,%ecx
f0107d4e:	c1 e1 08             	shl    $0x8,%ecx
f0107d51:	01 c8                	add    %ecx,%eax
f0107d53:	89 c1                	mov    %eax,%ecx
f0107d55:	c1 e1 10             	shl    $0x10,%ecx
f0107d58:	01 c8                	add    %ecx,%eax
f0107d5a:	01 c0                	add    %eax,%eax
f0107d5c:	01 d0                	add    %edx,%eax
}
f0107d5e:	5d                   	pop    %ebp
f0107d5f:	c3                   	ret    

f0107d60 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107d60:	55                   	push   %ebp
f0107d61:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107d63:	ff 75 08             	pushl  0x8(%ebp)
f0107d66:	e8 bd ff ff ff       	call   f0107d28 <to_frame_number>
f0107d6b:	83 c4 04             	add    $0x4,%esp
f0107d6e:	c1 e0 0c             	shl    $0xc,%eax
}
f0107d71:	c9                   	leave  
f0107d72:	c3                   	ret    

f0107d73 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107d73:	55                   	push   %ebp
f0107d74:	89 e5                	mov    %esp,%ebp
f0107d76:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d7c:	c1 e8 0c             	shr    $0xc,%eax
f0107d7f:	89 c2                	mov    %eax,%edx
f0107d81:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0107d86:	39 c2                	cmp    %eax,%edx
f0107d88:	72 14                	jb     f0107d9e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107d8a:	83 ec 04             	sub    $0x4,%esp
f0107d8d:	68 30 53 12 f0       	push   $0xf0125330
f0107d92:	6a 56                	push   $0x56
f0107d94:	68 55 53 12 f0       	push   $0xf0125355
f0107d99:	e8 9b 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107d9e:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0107da4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107da7:	c1 e8 0c             	shr    $0xc,%eax
f0107daa:	89 c1                	mov    %eax,%ecx
f0107dac:	89 c8                	mov    %ecx,%eax
f0107dae:	01 c0                	add    %eax,%eax
f0107db0:	01 c8                	add    %ecx,%eax
f0107db2:	c1 e0 03             	shl    $0x3,%eax
f0107db5:	01 d0                	add    %edx,%eax
}
f0107db7:	c9                   	leave  
f0107db8:	c3                   	ret    

f0107db9 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107db9:	55                   	push   %ebp
f0107dba:	89 e5                	mov    %esp,%ebp
f0107dbc:	83 ec 10             	sub    $0x10,%esp
f0107dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107dc8:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107dcb:	90                   	nop
f0107dcc:	c9                   	leave  
f0107dcd:	c3                   	ret    

f0107dce <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107dce:	55                   	push   %ebp
f0107dcf:	89 e5                	mov    %esp,%ebp
f0107dd1:	53                   	push   %ebx
f0107dd2:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107dd5:	c7 05 60 d3 6b f0 00 	movl   $0x0,0xf06bd360
f0107ddc:	00 00 00 
f0107ddf:	c7 05 64 d3 6b f0 00 	movl   $0x0,0xf06bd364
f0107de6:	00 00 00 
f0107de9:	c7 05 6c d3 6b f0 00 	movl   $0x0,0xf06bd36c
f0107df0:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107df3:	c7 05 70 d3 6b f0 00 	movl   $0x0,0xf06bd370
f0107dfa:	00 00 00 
f0107dfd:	c7 05 74 d3 6b f0 00 	movl   $0x0,0xf06bd374
f0107e04:	00 00 00 
f0107e07:	c7 05 7c d3 6b f0 00 	movl   $0x0,0xf06bd37c
f0107e0e:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e11:	83 ec 08             	sub    $0x8,%esp
f0107e14:	68 6f 53 12 f0       	push   $0xf012536f
f0107e19:	68 80 d3 6b f0       	push   $0xf06bd380
f0107e1e:	e8 c2 77 00 00       	call   f010f5e5 <init_spinlock>
f0107e23:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e26:	a1 c0 d7 6b f0       	mov    0xf06bd7c0,%eax
f0107e2b:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e31:	a1 c0 d7 6b f0       	mov    0xf06bd7c0,%eax
f0107e36:	83 c0 18             	add    $0x18,%eax
f0107e39:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e3f:	a1 c0 d7 6b f0       	mov    0xf06bd7c0,%eax
f0107e44:	83 c0 30             	add    $0x30,%eax
f0107e47:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e4d:	c7 05 5c d8 6b f0 00 	movl   $0xf0001000,0xf06bd85c
f0107e54:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107e57:	c7 05 0c da 6b f0 00 	movl   $0xf0002000,0xf06bda0c
f0107e5e:	20 00 f0 
	i =0;
f0107e61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107e68:	eb 1f                	jmp    f0107e89 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107e6a:	8b 15 5c d8 6b f0    	mov    0xf06bd85c,%edx
f0107e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e73:	01 d0                	add    %edx,%eax
f0107e75:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107e78:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f0107e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e81:	01 d0                	add    %edx,%eax
f0107e83:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107e86:	ff 45 f4             	incl   -0xc(%ebp)
f0107e89:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107e90:	7e d8                	jle    f0107e6a <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107e92:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107e99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107e9c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107ea1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ea4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ea7:	ba 00 00 00 00       	mov    $0x0,%edx
f0107eac:	f7 75 f0             	divl   -0x10(%ebp)
f0107eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eb2:	29 d0                	sub    %edx,%eax
f0107eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107eb7:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107ebe:	e9 e8 00 00 00       	jmp    f0107fab <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107ec3:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ecc:	89 d0                	mov    %edx,%eax
f0107ece:	01 c0                	add    %eax,%eax
f0107ed0:	01 d0                	add    %edx,%eax
f0107ed2:	c1 e0 03             	shl    $0x3,%eax
f0107ed5:	01 c8                	add    %ecx,%eax
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	50                   	push   %eax
f0107edb:	e8 b7 02 00 00       	call   f0108197 <initialize_frame_info>
f0107ee0:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107ee3:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107ee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107eec:	89 d0                	mov    %edx,%eax
f0107eee:	01 c0                	add    %eax,%eax
f0107ef0:	01 d0                	add    %edx,%eax
f0107ef2:	c1 e0 03             	shl    $0x3,%eax
f0107ef5:	01 c8                	add    %ecx,%eax
f0107ef7:	85 c0                	test   %eax,%eax
f0107ef9:	75 14                	jne    f0107f0f <initialize_paging+0x141>
f0107efb:	83 ec 04             	sub    $0x4,%esp
f0107efe:	68 80 53 12 f0       	push   $0xf0125380
f0107f03:	6a 60                	push   $0x60
f0107f05:	68 a3 53 12 f0       	push   $0xf01253a3
f0107f0a:	e8 2a 84 ff ff       	call   f0100339 <_panic>
f0107f0f:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f18:	89 d0                	mov    %edx,%eax
f0107f1a:	01 c0                	add    %eax,%eax
f0107f1c:	01 d0                	add    %edx,%eax
f0107f1e:	c1 e0 03             	shl    $0x3,%eax
f0107f21:	01 c8                	add    %ecx,%eax
f0107f23:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0107f29:	89 10                	mov    %edx,(%eax)
f0107f2b:	8b 00                	mov    (%eax),%eax
f0107f2d:	85 c0                	test   %eax,%eax
f0107f2f:	74 1f                	je     f0107f50 <initialize_paging+0x182>
f0107f31:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0107f37:	8b 1d c0 d7 6b f0    	mov    0xf06bd7c0,%ebx
f0107f3d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107f40:	89 c8                	mov    %ecx,%eax
f0107f42:	01 c0                	add    %eax,%eax
f0107f44:	01 c8                	add    %ecx,%eax
f0107f46:	c1 e0 03             	shl    $0x3,%eax
f0107f49:	01 d8                	add    %ebx,%eax
f0107f4b:	89 42 04             	mov    %eax,0x4(%edx)
f0107f4e:	eb 19                	jmp    f0107f69 <initialize_paging+0x19b>
f0107f50:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f59:	89 d0                	mov    %edx,%eax
f0107f5b:	01 c0                	add    %eax,%eax
f0107f5d:	01 d0                	add    %edx,%eax
f0107f5f:	c1 e0 03             	shl    $0x3,%eax
f0107f62:	01 c8                	add    %ecx,%eax
f0107f64:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f0107f69:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f72:	89 d0                	mov    %edx,%eax
f0107f74:	01 c0                	add    %eax,%eax
f0107f76:	01 d0                	add    %edx,%eax
f0107f78:	c1 e0 03             	shl    $0x3,%eax
f0107f7b:	01 c8                	add    %ecx,%eax
f0107f7d:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f0107f82:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107f88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f8b:	89 d0                	mov    %edx,%eax
f0107f8d:	01 c0                	add    %eax,%eax
f0107f8f:	01 d0                	add    %edx,%eax
f0107f91:	c1 e0 03             	shl    $0x3,%eax
f0107f94:	01 c8                	add    %ecx,%eax
f0107f96:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107f9d:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f0107fa2:	40                   	inc    %eax
f0107fa3:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107fa8:	ff 45 f4             	incl   -0xc(%ebp)
f0107fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107fae:	85 c0                	test   %eax,%eax
f0107fb0:	79 05                	jns    f0107fb7 <initialize_paging+0x1e9>
f0107fb2:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107fb7:	c1 f8 0c             	sar    $0xc,%eax
f0107fba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107fbd:	0f 8f 00 ff ff ff    	jg     f0107ec3 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fc3:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107fca:	eb 1d                	jmp    f0107fe9 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107fcc:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0107fd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fd5:	89 d0                	mov    %edx,%eax
f0107fd7:	01 c0                	add    %eax,%eax
f0107fd9:	01 d0                	add    %edx,%eax
f0107fdb:	c1 e0 03             	shl    $0x3,%eax
f0107fde:	01 c8                	add    %ecx,%eax
f0107fe0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107fe6:	ff 45 f4             	incl   -0xc(%ebp)
f0107fe9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107ff0:	7e da                	jle    f0107fcc <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107ff2:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107ff9:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f0107ffe:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108001:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108008:	77 14                	ja     f010801e <initialize_paging+0x250>
f010800a:	ff 75 e0             	pushl  -0x20(%ebp)
f010800d:	68 c0 53 12 f0       	push   $0xf01253c0
f0108012:	6a 68                	push   $0x68
f0108014:	68 a3 53 12 f0       	push   $0xf01253a3
f0108019:	e8 1b 83 ff ff       	call   f0100339 <_panic>
f010801e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108021:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010802a:	01 d0                	add    %edx,%eax
f010802c:	48                   	dec    %eax
f010802d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108030:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108033:	ba 00 00 00 00       	mov    $0x0,%edx
f0108038:	f7 75 e4             	divl   -0x1c(%ebp)
f010803b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010803e:	29 d0                	sub    %edx,%eax
f0108040:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108043:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f010804a:	eb 1d                	jmp    f0108069 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f010804c:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108052:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108055:	89 d0                	mov    %edx,%eax
f0108057:	01 c0                	add    %eax,%eax
f0108059:	01 d0                	add    %edx,%eax
f010805b:	c1 e0 03             	shl    $0x3,%eax
f010805e:	01 c8                	add    %ecx,%eax
f0108060:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108066:	ff 45 f4             	incl   -0xc(%ebp)
f0108069:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010806c:	85 c0                	test   %eax,%eax
f010806e:	79 05                	jns    f0108075 <initialize_paging+0x2a7>
f0108070:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108075:	c1 f8 0c             	sar    $0xc,%eax
f0108078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010807b:	7f cf                	jg     f010804c <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010807d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108080:	85 c0                	test   %eax,%eax
f0108082:	79 05                	jns    f0108089 <initialize_paging+0x2bb>
f0108084:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108089:	c1 f8 0c             	sar    $0xc,%eax
f010808c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010808f:	e9 e8 00 00 00       	jmp    f010817c <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0108094:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f010809a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010809d:	89 d0                	mov    %edx,%eax
f010809f:	01 c0                	add    %eax,%eax
f01080a1:	01 d0                	add    %edx,%eax
f01080a3:	c1 e0 03             	shl    $0x3,%eax
f01080a6:	01 c8                	add    %ecx,%eax
f01080a8:	83 ec 0c             	sub    $0xc,%esp
f01080ab:	50                   	push   %eax
f01080ac:	e8 e6 00 00 00       	call   f0108197 <initialize_frame_info>
f01080b1:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01080b4:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f01080ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080bd:	89 d0                	mov    %edx,%eax
f01080bf:	01 c0                	add    %eax,%eax
f01080c1:	01 d0                	add    %edx,%eax
f01080c3:	c1 e0 03             	shl    $0x3,%eax
f01080c6:	01 c8                	add    %ecx,%eax
f01080c8:	85 c0                	test   %eax,%eax
f01080ca:	75 14                	jne    f01080e0 <initialize_paging+0x312>
f01080cc:	83 ec 04             	sub    $0x4,%esp
f01080cf:	68 80 53 12 f0       	push   $0xf0125380
f01080d4:	6a 74                	push   $0x74
f01080d6:	68 a3 53 12 f0       	push   $0xf01253a3
f01080db:	e8 59 82 ff ff       	call   f0100339 <_panic>
f01080e0:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f01080e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e9:	89 d0                	mov    %edx,%eax
f01080eb:	01 c0                	add    %eax,%eax
f01080ed:	01 d0                	add    %edx,%eax
f01080ef:	c1 e0 03             	shl    $0x3,%eax
f01080f2:	01 c8                	add    %ecx,%eax
f01080f4:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f01080fa:	89 10                	mov    %edx,(%eax)
f01080fc:	8b 00                	mov    (%eax),%eax
f01080fe:	85 c0                	test   %eax,%eax
f0108100:	74 1f                	je     f0108121 <initialize_paging+0x353>
f0108102:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0108108:	8b 1d c0 d7 6b f0    	mov    0xf06bd7c0,%ebx
f010810e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108111:	89 c8                	mov    %ecx,%eax
f0108113:	01 c0                	add    %eax,%eax
f0108115:	01 c8                	add    %ecx,%eax
f0108117:	c1 e0 03             	shl    $0x3,%eax
f010811a:	01 d8                	add    %ebx,%eax
f010811c:	89 42 04             	mov    %eax,0x4(%edx)
f010811f:	eb 19                	jmp    f010813a <initialize_paging+0x36c>
f0108121:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108127:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010812a:	89 d0                	mov    %edx,%eax
f010812c:	01 c0                	add    %eax,%eax
f010812e:	01 d0                	add    %edx,%eax
f0108130:	c1 e0 03             	shl    $0x3,%eax
f0108133:	01 c8                	add    %ecx,%eax
f0108135:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f010813a:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108140:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108143:	89 d0                	mov    %edx,%eax
f0108145:	01 c0                	add    %eax,%eax
f0108147:	01 d0                	add    %edx,%eax
f0108149:	c1 e0 03             	shl    $0x3,%eax
f010814c:	01 c8                	add    %ecx,%eax
f010814e:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f0108153:	8b 0d c0 d7 6b f0    	mov    0xf06bd7c0,%ecx
f0108159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815c:	89 d0                	mov    %edx,%eax
f010815e:	01 c0                	add    %eax,%eax
f0108160:	01 d0                	add    %edx,%eax
f0108162:	c1 e0 03             	shl    $0x3,%eax
f0108165:	01 c8                	add    %ecx,%eax
f0108167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010816e:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f0108173:	40                   	inc    %eax
f0108174:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108179:	ff 45 f4             	incl   -0xc(%ebp)
f010817c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010817f:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0108184:	39 c2                	cmp    %eax,%edx
f0108186:	0f 82 08 ff ff ff    	jb     f0108094 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010818c:	e8 00 bb ff ff       	call   f0103c91 <initialize_disk_page_file>
}
f0108191:	90                   	nop
f0108192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108195:	c9                   	leave  
f0108196:	c3                   	ret    

f0108197 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108197:	55                   	push   %ebp
f0108198:	89 e5                	mov    %esp,%ebp
f010819a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010819d:	83 ec 04             	sub    $0x4,%esp
f01081a0:	6a 18                	push   $0x18
f01081a2:	6a 00                	push   $0x0
f01081a4:	ff 75 08             	pushl  0x8(%ebp)
f01081a7:	e8 06 76 01 00       	call   f011f7b2 <memset>
f01081ac:	83 c4 10             	add    $0x10,%esp
}
f01081af:	90                   	nop
f01081b0:	c9                   	leave  
f01081b1:	c3                   	ret    

f01081b2 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01081b2:	55                   	push   %ebp
f01081b3:	89 e5                	mov    %esp,%ebp
f01081b5:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01081b8:	83 ec 0c             	sub    $0xc,%esp
f01081bb:	68 80 d3 6b f0       	push   $0xf06bd380
f01081c0:	e8 6a 76 00 00       	call   f010f82f <holding_spinlock>
f01081c5:	83 c4 10             	add    $0x10,%esp
f01081c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01081cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081cf:	75 10                	jne    f01081e1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01081d1:	83 ec 0c             	sub    $0xc,%esp
f01081d4:	68 80 d3 6b f0       	push   $0xf06bd380
f01081d9:	e8 38 74 00 00       	call   f010f616 <acquire_spinlock>
f01081de:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01081e1:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f01081e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01081ea:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01081ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01081f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01081f6:	8b 00                	mov    (%eax),%eax
f01081f8:	85 c0                	test   %eax,%eax
f01081fa:	75 17                	jne    f0108213 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01081fc:	83 ec 04             	sub    $0x4,%esp
f01081ff:	68 f4 53 12 f0       	push   $0xf01253f4
f0108204:	68 a2 00 00 00       	push   $0xa2
f0108209:	68 a3 53 12 f0       	push   $0xf01253a3
f010820e:	e8 26 81 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108213:	8b 45 08             	mov    0x8(%ebp),%eax
f0108216:	8b 00                	mov    (%eax),%eax
f0108218:	85 c0                	test   %eax,%eax
f010821a:	75 17                	jne    f0108233 <allocate_frame+0x81>
f010821c:	83 ec 04             	sub    $0x4,%esp
f010821f:	68 41 54 12 f0       	push   $0xf0125441
f0108224:	68 a8 00 00 00       	push   $0xa8
f0108229:	68 a3 53 12 f0       	push   $0xf01253a3
f010822e:	e8 06 81 ff ff       	call   f0100339 <_panic>
f0108233:	8b 45 08             	mov    0x8(%ebp),%eax
f0108236:	8b 00                	mov    (%eax),%eax
f0108238:	8b 00                	mov    (%eax),%eax
f010823a:	85 c0                	test   %eax,%eax
f010823c:	74 14                	je     f0108252 <allocate_frame+0xa0>
f010823e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108241:	8b 00                	mov    (%eax),%eax
f0108243:	8b 00                	mov    (%eax),%eax
f0108245:	8b 55 08             	mov    0x8(%ebp),%edx
f0108248:	8b 12                	mov    (%edx),%edx
f010824a:	8b 52 04             	mov    0x4(%edx),%edx
f010824d:	89 50 04             	mov    %edx,0x4(%eax)
f0108250:	eb 0d                	jmp    f010825f <allocate_frame+0xad>
f0108252:	8b 45 08             	mov    0x8(%ebp),%eax
f0108255:	8b 00                	mov    (%eax),%eax
f0108257:	8b 40 04             	mov    0x4(%eax),%eax
f010825a:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f010825f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108262:	8b 00                	mov    (%eax),%eax
f0108264:	8b 40 04             	mov    0x4(%eax),%eax
f0108267:	85 c0                	test   %eax,%eax
f0108269:	74 13                	je     f010827e <allocate_frame+0xcc>
f010826b:	8b 45 08             	mov    0x8(%ebp),%eax
f010826e:	8b 00                	mov    (%eax),%eax
f0108270:	8b 40 04             	mov    0x4(%eax),%eax
f0108273:	8b 55 08             	mov    0x8(%ebp),%edx
f0108276:	8b 12                	mov    (%edx),%edx
f0108278:	8b 12                	mov    (%edx),%edx
f010827a:	89 10                	mov    %edx,(%eax)
f010827c:	eb 0c                	jmp    f010828a <allocate_frame+0xd8>
f010827e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108281:	8b 00                	mov    (%eax),%eax
f0108283:	8b 00                	mov    (%eax),%eax
f0108285:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f010828a:	8b 45 08             	mov    0x8(%ebp),%eax
f010828d:	8b 00                	mov    (%eax),%eax
f010828f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108295:	8b 45 08             	mov    0x8(%ebp),%eax
f0108298:	8b 00                	mov    (%eax),%eax
f010829a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01082a1:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f01082a6:	48                   	dec    %eax
f01082a7:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f01082ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01082af:	8b 00                	mov    (%eax),%eax
f01082b1:	8a 40 14             	mov    0x14(%eax),%al
f01082b4:	84 c0                	test   %al,%al
f01082b6:	74 20                	je     f01082d8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01082b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082bb:	8b 00                	mov    (%eax),%eax
f01082bd:	8b 50 10             	mov    0x10(%eax),%edx
f01082c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01082c8:	8b 40 64             	mov    0x64(%eax),%eax
f01082cb:	83 ec 08             	sub    $0x8,%esp
f01082ce:	52                   	push   %edx
f01082cf:	50                   	push   %eax
f01082d0:	e8 00 14 00 00       	call   f01096d5 <pt_clear_page_table_entry>
f01082d5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01082d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01082db:	8b 00                	mov    (%eax),%eax
f01082dd:	83 ec 0c             	sub    $0xc,%esp
f01082e0:	50                   	push   %eax
f01082e1:	e8 b1 fe ff ff       	call   f0108197 <initialize_frame_info>
f01082e6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01082e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01082ed:	75 10                	jne    f01082ff <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01082ef:	83 ec 0c             	sub    $0xc,%esp
f01082f2:	68 80 d3 6b f0       	push   $0xf06bd380
f01082f7:	e8 a1 73 00 00       	call   f010f69d <release_spinlock>
f01082fc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01082ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108304:	c9                   	leave  
f0108305:	c3                   	ret    

f0108306 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108306:	55                   	push   %ebp
f0108307:	89 e5                	mov    %esp,%ebp
f0108309:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010830c:	83 ec 0c             	sub    $0xc,%esp
f010830f:	68 80 d3 6b f0       	push   $0xf06bd380
f0108314:	e8 16 75 00 00       	call   f010f82f <holding_spinlock>
f0108319:	83 c4 10             	add    $0x10,%esp
f010831c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010831f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108323:	75 10                	jne    f0108335 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108325:	83 ec 0c             	sub    $0xc,%esp
f0108328:	68 80 d3 6b f0       	push   $0xf06bd380
f010832d:	e8 e4 72 00 00       	call   f010f616 <acquire_spinlock>
f0108332:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108335:	83 ec 0c             	sub    $0xc,%esp
f0108338:	ff 75 08             	pushl  0x8(%ebp)
f010833b:	e8 57 fe ff ff       	call   f0108197 <initialize_frame_info>
f0108340:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108343:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108347:	75 17                	jne    f0108360 <free_frame+0x5a>
f0108349:	83 ec 04             	sub    $0x4,%esp
f010834c:	68 80 53 12 f0       	push   $0xf0125380
f0108351:	68 cf 00 00 00       	push   $0xcf
f0108356:	68 a3 53 12 f0       	push   $0xf01253a3
f010835b:	e8 d9 7f ff ff       	call   f0100339 <_panic>
f0108360:	8b 15 60 d3 6b f0    	mov    0xf06bd360,%edx
f0108366:	8b 45 08             	mov    0x8(%ebp),%eax
f0108369:	89 10                	mov    %edx,(%eax)
f010836b:	8b 45 08             	mov    0x8(%ebp),%eax
f010836e:	8b 00                	mov    (%eax),%eax
f0108370:	85 c0                	test   %eax,%eax
f0108372:	74 0d                	je     f0108381 <free_frame+0x7b>
f0108374:	a1 60 d3 6b f0       	mov    0xf06bd360,%eax
f0108379:	8b 55 08             	mov    0x8(%ebp),%edx
f010837c:	89 50 04             	mov    %edx,0x4(%eax)
f010837f:	eb 08                	jmp    f0108389 <free_frame+0x83>
f0108381:	8b 45 08             	mov    0x8(%ebp),%eax
f0108384:	a3 64 d3 6b f0       	mov    %eax,0xf06bd364
f0108389:	8b 45 08             	mov    0x8(%ebp),%eax
f010838c:	a3 60 d3 6b f0       	mov    %eax,0xf06bd360
f0108391:	8b 45 08             	mov    0x8(%ebp),%eax
f0108394:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010839b:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f01083a0:	40                   	inc    %eax
f01083a1:	a3 6c d3 6b f0       	mov    %eax,0xf06bd36c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01083a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083aa:	75 10                	jne    f01083bc <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083ac:	83 ec 0c             	sub    $0xc,%esp
f01083af:	68 80 d3 6b f0       	push   $0xf06bd380
f01083b4:	e8 e4 72 00 00       	call   f010f69d <release_spinlock>
f01083b9:	83 c4 10             	add    $0x10,%esp
	}
}
f01083bc:	90                   	nop
f01083bd:	c9                   	leave  
f01083be:	c3                   	ret    

f01083bf <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01083bf:	55                   	push   %ebp
f01083c0:	89 e5                	mov    %esp,%ebp
f01083c2:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01083c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01083c8:	8b 40 08             	mov    0x8(%eax),%eax
f01083cb:	48                   	dec    %eax
f01083cc:	8b 55 08             	mov    0x8(%ebp),%edx
f01083cf:	66 89 42 08          	mov    %ax,0x8(%edx)
f01083d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01083d6:	8b 40 08             	mov    0x8(%eax),%eax
f01083d9:	66 85 c0             	test   %ax,%ax
f01083dc:	75 0e                	jne    f01083ec <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01083de:	83 ec 0c             	sub    $0xc,%esp
f01083e1:	ff 75 08             	pushl  0x8(%ebp)
f01083e4:	e8 1d ff ff ff       	call   f0108306 <free_frame>
f01083e9:	83 c4 10             	add    $0x10,%esp
}
f01083ec:	90                   	nop
f01083ed:	c9                   	leave  
f01083ee:	c3                   	ret    

f01083ef <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01083ef:	55                   	push   %ebp
f01083f0:	89 e5                	mov    %esp,%ebp
f01083f2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01083f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f8:	c1 e8 16             	shr    $0x16,%eax
f01083fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108402:	8b 45 08             	mov    0x8(%ebp),%eax
f0108405:	01 d0                	add    %edx,%eax
f0108407:	8b 00                	mov    (%eax),%eax
f0108409:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010840c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840f:	83 e0 01             	and    $0x1,%eax
f0108412:	85 c0                	test   %eax,%eax
f0108414:	74 74                	je     f010848a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108416:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010841d:	77 1d                	ja     f010843c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010841f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108422:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108427:	83 ec 0c             	sub    $0xc,%esp
f010842a:	50                   	push   %eax
f010842b:	e8 5c 11 00 00       	call   f010958c <kheap_virtual_address>
f0108430:	83 c4 10             	add    $0x10,%esp
f0108433:	89 c2                	mov    %eax,%edx
f0108435:	8b 45 10             	mov    0x10(%ebp),%eax
f0108438:	89 10                	mov    %edx,(%eax)
f010843a:	eb 44                	jmp    f0108480 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010843c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010843f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108444:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108447:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010844a:	c1 e8 0c             	shr    $0xc,%eax
f010844d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108450:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0108455:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108458:	72 17                	jb     f0108471 <get_page_table+0x82>
f010845a:	ff 75 f0             	pushl  -0x10(%ebp)
f010845d:	68 60 54 12 f0       	push   $0xf0125460
f0108462:	68 fb 00 00 00       	push   $0xfb
f0108467:	68 a3 53 12 f0       	push   $0xf01253a3
f010846c:	e8 c8 7e ff ff       	call   f0100339 <_panic>
f0108471:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108474:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108479:	89 c2                	mov    %eax,%edx
f010847b:	8b 45 10             	mov    0x10(%ebp),%eax
f010847e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108480:	b8 00 00 00 00       	mov    $0x0,%eax
f0108485:	e9 b9 00 00 00       	jmp    f0108543 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010848a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010848e:	0f 84 a1 00 00 00    	je     f0108535 <get_page_table+0x146>
f0108494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108497:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010849a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010849d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01084a0:	83 ec 0c             	sub    $0xc,%esp
f01084a3:	6a 00                	push   $0x0
f01084a5:	e8 fe 6b 00 00       	call   f010f0a8 <fault_handler>
f01084aa:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084b0:	c1 e8 16             	shr    $0x16,%eax
f01084b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01084bd:	01 d0                	add    %edx,%eax
f01084bf:	8b 00                	mov    (%eax),%eax
f01084c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084c4:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084cb:	77 1d                	ja     f01084ea <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084d5:	83 ec 0c             	sub    $0xc,%esp
f01084d8:	50                   	push   %eax
f01084d9:	e8 ae 10 00 00       	call   f010958c <kheap_virtual_address>
f01084de:	83 c4 10             	add    $0x10,%esp
f01084e1:	89 c2                	mov    %eax,%edx
f01084e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01084e6:	89 10                	mov    %edx,(%eax)
f01084e8:	eb 44                	jmp    f010852e <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084ed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01084f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01084f8:	c1 e8 0c             	shr    $0xc,%eax
f01084fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01084fe:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0108503:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108506:	72 17                	jb     f010851f <get_page_table+0x130>
f0108508:	ff 75 e8             	pushl  -0x18(%ebp)
f010850b:	68 60 54 12 f0       	push   $0xf0125460
f0108510:	68 13 01 00 00       	push   $0x113
f0108515:	68 a3 53 12 f0       	push   $0xf01253a3
f010851a:	e8 1a 7e ff ff       	call   f0100339 <_panic>
f010851f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108522:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108527:	89 c2                	mov    %eax,%edx
f0108529:	8b 45 10             	mov    0x10(%ebp),%eax
f010852c:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010852e:	b8 00 00 00 00       	mov    $0x0,%eax
f0108533:	eb 0e                	jmp    f0108543 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108535:	8b 45 10             	mov    0x10(%ebp),%eax
f0108538:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010853e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108543:	c9                   	leave  
f0108544:	c3                   	ret    

f0108545 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108545:	55                   	push   %ebp
f0108546:	89 e5                	mov    %esp,%ebp
f0108548:	53                   	push   %ebx
f0108549:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010854c:	83 ec 0c             	sub    $0xc,%esp
f010854f:	68 00 10 00 00       	push   $0x1000
f0108554:	e8 90 0c 00 00       	call   f01091e9 <kmalloc>
f0108559:	83 c4 10             	add    $0x10,%esp
f010855c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010855f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108563:	75 17                	jne    f010857c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108565:	83 ec 04             	sub    $0x4,%esp
f0108568:	68 8f 54 12 f0       	push   $0xf012548f
f010856d:	68 33 01 00 00       	push   $0x133
f0108572:	68 a3 53 12 f0       	push   $0xf01253a3
f0108577:	e8 bd 7d ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010857c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010857f:	c1 e8 16             	shr    $0x16,%eax
f0108582:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108589:	8b 45 08             	mov    0x8(%ebp),%eax
f010858c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010858f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108592:	83 ec 0c             	sub    $0xc,%esp
f0108595:	50                   	push   %eax
f0108596:	e8 94 0f 00 00       	call   f010952f <kheap_physical_address>
f010859b:	83 c4 10             	add    $0x10,%esp
f010859e:	83 c8 07             	or     $0x7,%eax
f01085a1:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f01085a3:	83 ec 04             	sub    $0x4,%esp
f01085a6:	68 00 10 00 00       	push   $0x1000
f01085ab:	6a 00                	push   $0x0
f01085ad:	ff 75 f4             	pushl  -0xc(%ebp)
f01085b0:	e8 fd 71 01 00       	call   f011f7b2 <memset>
f01085b5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01085b8:	0f 20 d8             	mov    %cr3,%eax
f01085bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085c1:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f01085c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01085c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01085ca:	c9                   	leave  
f01085cb:	c3                   	ret    

f01085cc <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01085cc:	55                   	push   %ebp
f01085cd:	89 e5                	mov    %esp,%ebp
f01085cf:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01085d2:	83 ec 0c             	sub    $0xc,%esp
f01085d5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01085d8:	50                   	push   %eax
f01085d9:	e8 d4 fb ff ff       	call   f01081b2 <allocate_frame>
f01085de:	83 c4 10             	add    $0x10,%esp
f01085e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01085e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085e7:	83 ec 0c             	sub    $0xc,%esp
f01085ea:	50                   	push   %eax
f01085eb:	e8 70 f7 ff ff       	call   f0107d60 <to_physical_address>
f01085f0:	83 c4 10             	add    $0x10,%esp
f01085f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01085f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01085f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01085fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01085ff:	c1 e8 0c             	shr    $0xc,%eax
f0108602:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108605:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f010860a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010860d:	72 17                	jb     f0108626 <__static_cpt+0x5a>
f010860f:	ff 75 ec             	pushl  -0x14(%ebp)
f0108612:	68 60 54 12 f0       	push   $0xf0125460
f0108617:	68 4e 01 00 00       	push   $0x14e
f010861c:	68 a3 53 12 f0       	push   $0xf01253a3
f0108621:	e8 13 7d ff ff       	call   f0100339 <_panic>
f0108626:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108629:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010862e:	89 c2                	mov    %eax,%edx
f0108630:	8b 45 10             	mov    0x10(%ebp),%eax
f0108633:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108635:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108638:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010863e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108641:	c1 e8 16             	shr    $0x16,%eax
f0108644:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010864b:	8b 45 08             	mov    0x8(%ebp),%eax
f010864e:	01 d0                	add    %edx,%eax
f0108650:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108653:	83 ca 07             	or     $0x7,%edx
f0108656:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108658:	8b 45 10             	mov    0x10(%ebp),%eax
f010865b:	8b 00                	mov    (%eax),%eax
f010865d:	83 ec 04             	sub    $0x4,%esp
f0108660:	68 00 10 00 00       	push   $0x1000
f0108665:	6a 00                	push   $0x0
f0108667:	50                   	push   %eax
f0108668:	e8 45 71 01 00       	call   f011f7b2 <memset>
f010866d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108670:	0f 20 d8             	mov    %cr3,%eax
f0108673:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108676:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108679:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010867c:	90                   	nop
f010867d:	c9                   	leave  
f010867e:	c3                   	ret    

f010867f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010867f:	55                   	push   %ebp
f0108680:	89 e5                	mov    %esp,%ebp
f0108682:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108685:	ff 75 0c             	pushl  0xc(%ebp)
f0108688:	e8 d3 f6 ff ff       	call   f0107d60 <to_physical_address>
f010868d:	83 c4 04             	add    $0x4,%esp
f0108690:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108693:	83 ec 04             	sub    $0x4,%esp
f0108696:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108699:	50                   	push   %eax
f010869a:	ff 75 10             	pushl  0x10(%ebp)
f010869d:	ff 75 08             	pushl  0x8(%ebp)
f01086a0:	e8 4a fd ff ff       	call   f01083ef <get_page_table>
f01086a5:	83 c4 10             	add    $0x10,%esp
f01086a8:	83 f8 01             	cmp    $0x1,%eax
f01086ab:	75 1b                	jne    f01086c8 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f01086ad:	83 ec 08             	sub    $0x8,%esp
f01086b0:	ff 75 10             	pushl  0x10(%ebp)
f01086b3:	ff 75 08             	pushl  0x8(%ebp)
f01086b6:	e8 8a fe ff ff       	call   f0108545 <create_page_table>
f01086bb:	83 c4 10             	add    $0x10,%esp
f01086be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f01086c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f01086c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01086cb:	8b 55 10             	mov    0x10(%ebp),%edx
f01086ce:	c1 ea 0c             	shr    $0xc,%edx
f01086d1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01086d7:	c1 e2 02             	shl    $0x2,%edx
f01086da:	01 d0                	add    %edx,%eax
f01086dc:	8b 00                	mov    (%eax),%eax
f01086de:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01086e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086e4:	83 e0 01             	and    $0x1,%eax
f01086e7:	85 c0                	test   %eax,%eax
f01086e9:	74 25                	je     f0108710 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01086eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01086f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086f6:	75 07                	jne    f01086ff <map_frame+0x80>
			return 0;
f01086f8:	b8 00 00 00 00       	mov    $0x0,%eax
f01086fd:	eb 68                	jmp    f0108767 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01086ff:	83 ec 08             	sub    $0x8,%esp
f0108702:	ff 75 10             	pushl  0x10(%ebp)
f0108705:	ff 75 08             	pushl  0x8(%ebp)
f0108708:	e8 d2 00 00 00       	call   f01087df <unmap_frame>
f010870d:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108710:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108713:	8b 40 08             	mov    0x8(%eax),%eax
f0108716:	40                   	inc    %eax
f0108717:	8b 55 0c             	mov    0xc(%ebp),%edx
f010871a:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010871e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108721:	8b 55 10             	mov    0x10(%ebp),%edx
f0108724:	c1 ea 0c             	shr    $0xc,%edx
f0108727:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010872d:	c1 e2 02             	shl    $0x2,%edx
f0108730:	01 d0                	add    %edx,%eax
f0108732:	8b 00                	mov    (%eax),%eax
f0108734:	25 00 0e 00 00       	and    $0xe00,%eax
f0108739:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010873c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010873f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108742:	c1 ea 0c             	shr    $0xc,%edx
f0108745:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010874b:	c1 e2 02             	shl    $0x2,%edx
f010874e:	01 c2                	add    %eax,%edx
f0108750:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108753:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108756:	89 c1                	mov    %eax,%ecx
f0108758:	8b 45 14             	mov    0x14(%ebp),%eax
f010875b:	09 c8                	or     %ecx,%eax
f010875d:	83 c8 01             	or     $0x1,%eax
f0108760:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108762:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108767:	c9                   	leave  
f0108768:	c3                   	ret    

f0108769 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108769:	55                   	push   %ebp
f010876a:	89 e5                	mov    %esp,%ebp
f010876c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	ff 75 10             	pushl  0x10(%ebp)
f0108775:	ff 75 0c             	pushl  0xc(%ebp)
f0108778:	ff 75 08             	pushl  0x8(%ebp)
f010877b:	e8 6f fc ff ff       	call   f01083ef <get_page_table>
f0108780:	83 c4 10             	add    $0x10,%esp
f0108783:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108786:	8b 45 10             	mov    0x10(%ebp),%eax
f0108789:	8b 00                	mov    (%eax),%eax
f010878b:	85 c0                	test   %eax,%eax
f010878d:	74 49                	je     f01087d8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010878f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108792:	c1 e8 0c             	shr    $0xc,%eax
f0108795:	25 ff 03 00 00       	and    $0x3ff,%eax
f010879a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010879d:	8b 45 10             	mov    0x10(%ebp),%eax
f01087a0:	8b 00                	mov    (%eax),%eax
f01087a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01087a5:	c1 e2 02             	shl    $0x2,%edx
f01087a8:	01 d0                	add    %edx,%eax
f01087aa:	8b 00                	mov    (%eax),%eax
f01087ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f01087af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 16                	je     f01087d1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	83 ec 0c             	sub    $0xc,%esp
f01087c6:	50                   	push   %eax
f01087c7:	e8 a7 f5 ff ff       	call   f0107d73 <to_frame_info>
f01087cc:	83 c4 10             	add    $0x10,%esp
f01087cf:	eb 0c                	jmp    f01087dd <get_frame_info+0x74>
		}
		return 0;
f01087d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01087d6:	eb 05                	jmp    f01087dd <get_frame_info+0x74>
	}
	return 0;
f01087d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01087dd:	c9                   	leave  
f01087de:	c3                   	ret    

f01087df <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01087df:	55                   	push   %ebp
f01087e0:	89 e5                	mov    %esp,%ebp
f01087e2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01087e5:	83 ec 04             	sub    $0x4,%esp
f01087e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01087eb:	50                   	push   %eax
f01087ec:	ff 75 0c             	pushl  0xc(%ebp)
f01087ef:	ff 75 08             	pushl  0x8(%ebp)
f01087f2:	e8 72 ff ff ff       	call   f0108769 <get_frame_info>
f01087f7:	83 c4 10             	add    $0x10,%esp
f01087fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01087fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108801:	74 7d                	je     f0108880 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108806:	8a 40 14             	mov    0x14(%eax),%al
f0108809:	84 c0                	test   %al,%al
f010880b:	74 1c                	je     f0108829 <unmap_frame+0x4a>
f010880d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108814:	77 13                	ja     f0108829 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108816:	83 ec 08             	sub    $0x8,%esp
f0108819:	ff 75 0c             	pushl  0xc(%ebp)
f010881c:	68 ac 54 12 f0       	push   $0xf01254ac
f0108821:	e8 65 87 ff ff       	call   f0100f8b <cprintf>
f0108826:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108829:	83 ec 0c             	sub    $0xc,%esp
f010882c:	ff 75 f4             	pushl  -0xc(%ebp)
f010882f:	e8 8b fb ff ff       	call   f01083bf <decrement_references>
f0108834:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010883a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010883d:	c1 ea 0c             	shr    $0xc,%edx
f0108840:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108846:	c1 e2 02             	shl    $0x2,%edx
f0108849:	01 d0                	add    %edx,%eax
f010884b:	8b 00                	mov    (%eax),%eax
f010884d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108852:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108855:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108858:	8b 55 0c             	mov    0xc(%ebp),%edx
f010885b:	c1 ea 0c             	shr    $0xc,%edx
f010885e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108864:	c1 e2 02             	shl    $0x2,%edx
f0108867:	01 c2                	add    %eax,%edx
f0108869:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010886e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108871:	83 ec 08             	sub    $0x8,%esp
f0108874:	50                   	push   %eax
f0108875:	ff 75 08             	pushl  0x8(%ebp)
f0108878:	e8 3c f5 ff ff       	call   f0107db9 <tlb_invalidate>
f010887d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108880:	90                   	nop
f0108881:	c9                   	leave  
f0108882:	c3                   	ret    

f0108883 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108883:	55                   	push   %ebp
f0108884:	89 e5                	mov    %esp,%ebp
f0108886:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108889:	ff 75 0c             	pushl  0xc(%ebp)
f010888c:	e8 cf f4 ff ff       	call   f0107d60 <to_physical_address>
f0108891:	83 c4 04             	add    $0x4,%esp
f0108894:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108897:	8b 45 10             	mov    0x10(%ebp),%eax
f010889a:	c1 e8 16             	shr    $0x16,%eax
f010889d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088a7:	01 d0                	add    %edx,%eax
f01088a9:	8b 00                	mov    (%eax),%eax
f01088ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01088ae:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01088b5:	77 19                	ja     f01088d0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088bf:	83 ec 0c             	sub    $0xc,%esp
f01088c2:	50                   	push   %eax
f01088c3:	e8 c4 0c 00 00       	call   f010958c <kheap_virtual_address>
f01088c8:	83 c4 10             	add    $0x10,%esp
f01088cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01088ce:	eb 40                	jmp    f0108910 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01088d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01088db:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01088de:	c1 e8 0c             	shr    $0xc,%eax
f01088e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01088e4:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f01088e9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01088ec:	72 17                	jb     f0108905 <loadtime_map_frame+0x82>
f01088ee:	ff 75 e8             	pushl  -0x18(%ebp)
f01088f1:	68 60 54 12 f0       	push   $0xf0125460
f01088f6:	68 fa 01 00 00       	push   $0x1fa
f01088fb:	68 a3 53 12 f0       	push   $0xf01253a3
f0108900:	e8 34 7a ff ff       	call   f0100339 <_panic>
f0108905:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108908:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010890d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108914:	75 14                	jne    f010892a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0108916:	83 ec 08             	sub    $0x8,%esp
f0108919:	ff 75 10             	pushl  0x10(%ebp)
f010891c:	ff 75 08             	pushl  0x8(%ebp)
f010891f:	e8 21 fc ff ff       	call   f0108545 <create_page_table>
f0108924:	83 c4 10             	add    $0x10,%esp
f0108927:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010892a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010892d:	8b 40 08             	mov    0x8(%eax),%eax
f0108930:	40                   	inc    %eax
f0108931:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108934:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108938:	8b 45 10             	mov    0x10(%ebp),%eax
f010893b:	c1 e8 0c             	shr    $0xc,%eax
f010893e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010894a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010894d:	01 c2                	add    %eax,%edx
f010894f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108952:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108955:	83 c8 01             	or     $0x1,%eax
f0108958:	89 02                	mov    %eax,(%edx)

	return 0;
f010895a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010895f:	c9                   	leave  
f0108960:	c3                   	ret    

f0108961 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108961:	55                   	push   %ebp
f0108962:	89 e5                	mov    %esp,%ebp
f0108964:	57                   	push   %edi
f0108965:	56                   	push   %esi
f0108966:	53                   	push   %ebx
f0108967:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f010896a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108971:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108978:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f010897f:	83 ec 0c             	sub    $0xc,%esp
f0108982:	68 80 d3 6b f0       	push   $0xf06bd380
f0108987:	e8 a3 6e 00 00       	call   f010f82f <holding_spinlock>
f010898c:	83 c4 10             	add    $0x10,%esp
f010898f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108992:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108996:	75 10                	jne    f01089a8 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108998:	83 ec 0c             	sub    $0xc,%esp
f010899b:	68 80 d3 6b f0       	push   $0xf06bd380
f01089a0:	e8 71 6c 00 00       	call   f010f616 <acquire_spinlock>
f01089a5:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089a8:	a1 60 d3 6b f0       	mov    0xf06bd360,%eax
f01089ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b0:	eb 1a                	jmp    f01089cc <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01089b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089b5:	8a 40 14             	mov    0x14(%eax),%al
f01089b8:	84 c0                	test   %al,%al
f01089ba:	74 05                	je     f01089c1 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01089bc:	ff 45 dc             	incl   -0x24(%ebp)
f01089bf:	eb 03                	jmp    f01089c4 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01089c1:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01089c4:	a1 68 d3 6b f0       	mov    0xf06bd368,%eax
f01089c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089d0:	74 07                	je     f01089d9 <calculate_available_frames+0x78>
f01089d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01089d5:	8b 00                	mov    (%eax),%eax
f01089d7:	eb 05                	jmp    f01089de <calculate_available_frames+0x7d>
f01089d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01089de:	a3 68 d3 6b f0       	mov    %eax,0xf06bd368
f01089e3:	a1 68 d3 6b f0       	mov    0xf06bd368,%eax
f01089e8:	85 c0                	test   %eax,%eax
f01089ea:	75 c6                	jne    f01089b2 <calculate_available_frames+0x51>
f01089ec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01089f0:	75 c0                	jne    f01089b2 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01089f2:	a1 7c d3 6b f0       	mov    0xf06bd37c,%eax
f01089f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f01089fa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01089fe:	75 10                	jne    f0108a10 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a00:	83 ec 0c             	sub    $0xc,%esp
f0108a03:	68 80 d3 6b f0       	push   $0xf06bd380
f0108a08:	e8 90 6c 00 00       	call   f010f69d <release_spinlock>
f0108a0d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a13:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a19:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108a1c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108a1f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108a22:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a25:	89 c3                	mov    %eax,%ebx
f0108a27:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108a2a:	ba 03 00 00 00       	mov    $0x3,%edx
f0108a2f:	89 df                	mov    %ebx,%edi
f0108a31:	89 c6                	mov    %eax,%esi
f0108a33:	89 d1                	mov    %edx,%ecx
f0108a35:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108a3d:	5b                   	pop    %ebx
f0108a3e:	5e                   	pop    %esi
f0108a3f:	5f                   	pop    %edi
f0108a40:	5d                   	pop    %ebp
f0108a41:	c2 04 00             	ret    $0x4

f0108a44 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108a44:	55                   	push   %ebp
f0108a45:	89 e5                	mov    %esp,%ebp
f0108a47:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108a4a:	c7 05 20 d2 6b f0 00 	movl   $0x0,0xf06bd220
f0108a51:	00 00 00 
f0108a54:	c7 05 24 d2 6b f0 00 	movl   $0x0,0xf06bd224
f0108a5b:	00 00 00 
f0108a5e:	c7 05 2c d2 6b f0 00 	movl   $0x0,0xf06bd22c
f0108a65:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108a68:	83 ec 08             	sub    $0x8,%esp
f0108a6b:	68 dc 54 12 f0       	push   $0xf01254dc
f0108a70:	68 30 d2 6b f0       	push   $0xf06bd230
f0108a75:	e8 6b 6b 00 00       	call   f010f5e5 <init_spinlock>
f0108a7a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108a7d:	90                   	nop
f0108a7e:	c9                   	leave  
f0108a7f:	c3                   	ret    

f0108a80 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108a80:	55                   	push   %ebp
f0108a81:	89 e5                	mov    %esp,%ebp
f0108a83:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108a86:	83 ec 08             	sub    $0x8,%esp
f0108a89:	ff 75 0c             	pushl  0xc(%ebp)
f0108a8c:	ff 75 08             	pushl  0x8(%ebp)
f0108a8f:	e8 4b 01 00 00       	call   f0108bdf <get_share>
f0108a94:	83 c4 10             	add    $0x10,%esp
f0108a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9e:	75 07                	jne    f0108aa7 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108aa0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108aa5:	eb 06                	jmp    f0108aad <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108aaa:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108aad:	c9                   	leave  
f0108aae:	c3                   	ret    

f0108aaf <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108aaf:	55                   	push   %ebp
f0108ab0:	89 e5                	mov    %esp,%ebp
f0108ab2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (LIST_SIZE(&MemFrameLists.free_frame_list) < numOfFrames)
f0108ab5:	8b 15 6c d3 6b f0    	mov    0xf06bd36c,%edx
f0108abb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108abe:	39 c2                	cmp    %eax,%edx
f0108ac0:	73 07                	jae    f0108ac9 <create_frames_storage+0x1a>
	{
		return NULL;
f0108ac2:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ac7:	eb 3c                	jmp    f0108b05 <create_frames_storage+0x56>
	}
	struct FrameInfo** frames_storage = (struct FrameInfo**) kmalloc(numOfFrames * sizeof(struct FrameInfo * ));
f0108ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0108acc:	c1 e0 02             	shl    $0x2,%eax
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	50                   	push   %eax
f0108ad3:	e8 11 07 00 00       	call   f01091e9 <kmalloc>
f0108ad8:	83 c4 10             	add    $0x10,%esp
f0108adb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (frames_storage==NULL) return NULL;
f0108ade:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ae2:	75 07                	jne    f0108aeb <create_frames_storage+0x3c>
f0108ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ae9:	eb 1a                	jmp    f0108b05 <create_frames_storage+0x56>
	 // Initialize the FrameInfo struct to zero
	 memset(frames_storage, 0, numOfFrames * sizeof(struct FrameInfo *));
f0108aeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0108aee:	c1 e0 02             	shl    $0x2,%eax
f0108af1:	83 ec 04             	sub    $0x4,%esp
f0108af4:	50                   	push   %eax
f0108af5:	6a 00                	push   $0x0
f0108af7:	ff 75 f4             	pushl  -0xc(%ebp)
f0108afa:	e8 b3 6c 01 00       	call   f011f7b2 <memset>
f0108aff:	83 c4 10             	add    $0x10,%esp
	return frames_storage;
f0108b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108b05:	c9                   	leave  
f0108b06:	c3                   	ret    

f0108b07 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108b07:	55                   	push   %ebp
f0108b08:	89 e5                	mov    %esp,%ebp
f0108b0a:	83 ec 28             	sub    $0x28,%esp
f0108b0d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108b10:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	uint32 numOfFrames = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108b13:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0108b1a:	8b 55 10             	mov    0x10(%ebp),%edx
f0108b1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b20:	01 d0                	add    %edx,%eax
f0108b22:	48                   	dec    %eax
f0108b23:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b29:	ba 00 00 00 00       	mov    $0x0,%edx
f0108b2e:	f7 75 f4             	divl   -0xc(%ebp)
f0108b31:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b34:	29 d0                	sub    %edx,%eax
f0108b36:	c1 e8 0c             	shr    $0xc,%eax
f0108b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share* created_share = kmalloc(sizeof(struct Share));
f0108b3c:	83 ec 0c             	sub    $0xc,%esp
f0108b3f:	6a 60                	push   $0x60
f0108b41:	e8 a3 06 00 00       	call   f01091e9 <kmalloc>
f0108b46:	83 c4 10             	add    $0x10,%esp
f0108b49:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share==NULL) return NULL;
f0108b4c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108b50:	75 0a                	jne    f0108b5c <create_share+0x55>
f0108b52:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b57:	e9 81 00 00 00       	jmp    f0108bdd <create_share+0xd6>
	created_share->references=1;
f0108b5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b5f:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	created_share->ID=(int32)(((int)created_share << 1)>>1); //mask
f0108b66:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b69:	01 c0                	add    %eax,%eax
f0108b6b:	d1 f8                	sar    %eax
f0108b6d:	89 c2                	mov    %eax,%edx
f0108b6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b72:	89 10                	mov    %edx,(%eax)
	created_share->framesStorage = create_frames_storage(numOfFrames);
f0108b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b77:	83 ec 0c             	sub    $0xc,%esp
f0108b7a:	50                   	push   %eax
f0108b7b:	e8 2f ff ff ff       	call   f0108aaf <create_frames_storage>
f0108b80:	83 c4 10             	add    $0x10,%esp
f0108b83:	89 c2                	mov    %eax,%edx
f0108b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b88:	89 50 54             	mov    %edx,0x54(%eax)
	if(created_share->framesStorage==NULL)
f0108b8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108b8e:	8b 40 54             	mov    0x54(%eax),%eax
f0108b91:	85 c0                	test   %eax,%eax
f0108b93:	75 15                	jne    f0108baa <create_share+0xa3>
	{
			kfree((void*)created_share);
f0108b95:	83 ec 0c             	sub    $0xc,%esp
f0108b98:	ff 75 e8             	pushl  -0x18(%ebp)
f0108b9b:	e8 a9 08 00 00       	call   f0109449 <kfree>
f0108ba0:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0108ba3:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ba8:	eb 33                	jmp    f0108bdd <create_share+0xd6>
	}
	created_share->ownerID=ownerID;
f0108baa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bad:	8b 55 08             	mov    0x8(%ebp),%edx
f0108bb0:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(created_share->name, shareName);
f0108bb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bb6:	83 c0 08             	add    $0x8,%eax
f0108bb9:	83 ec 08             	sub    $0x8,%esp
f0108bbc:	ff 75 0c             	pushl  0xc(%ebp)
f0108bbf:	50                   	push   %eax
f0108bc0:	e8 4e 6a 01 00       	call   f011f613 <strcpy>
f0108bc5:	83 c4 10             	add    $0x10,%esp
	created_share->size=size;
f0108bc8:	8b 55 10             	mov    0x10(%ebp),%edx
f0108bcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bce:	89 50 48             	mov    %edx,0x48(%eax)
	created_share->isWritable=isWritable;
f0108bd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108bd4:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0108bd7:	88 50 50             	mov    %dl,0x50(%eax)
	return created_share;
f0108bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0108bdd:	c9                   	leave  
f0108bde:	c3                   	ret    

f0108bdf <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bdf:	55                   	push   %ebp
f0108be0:	89 e5                	mov    %esp,%ebp
f0108be2:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
f0108be5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&AllShares.shareslock);
f0108bec:	83 ec 0c             	sub    $0xc,%esp
f0108bef:	68 30 d2 6b f0       	push   $0xf06bd230
f0108bf4:	e8 1d 6a 00 00       	call   f010f616 <acquire_spinlock>
f0108bf9:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108bfc:	a1 20 d2 6b f0       	mov    0xf06bd220,%eax
f0108c01:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c04:	eb 41                	jmp    f0108c47 <get_share+0x68>
		if(founded->ownerID == ownerID && strcmp(founded->name, name) == 0)
f0108c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c09:	8b 40 04             	mov    0x4(%eax),%eax
f0108c0c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c0f:	75 2e                	jne    f0108c3f <get_share+0x60>
f0108c11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c14:	83 c0 08             	add    $0x8,%eax
f0108c17:	83 ec 08             	sub    $0x8,%esp
f0108c1a:	ff 75 0c             	pushl  0xc(%ebp)
f0108c1d:	50                   	push   %eax
f0108c1e:	e8 ad 6a 01 00       	call   f011f6d0 <strcmp>
f0108c23:	83 c4 10             	add    $0x10,%esp
f0108c26:	85 c0                	test   %eax,%eax
f0108c28:	75 15                	jne    f0108c3f <get_share+0x60>
		{
			release_spinlock(&AllShares.shareslock);
f0108c2a:	83 ec 0c             	sub    $0xc,%esp
f0108c2d:	68 30 d2 6b f0       	push   $0xf06bd230
f0108c32:	e8 66 6a 00 00       	call   f010f69d <release_spinlock>
f0108c37:	83 c4 10             	add    $0x10,%esp
			return founded;
f0108c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c3d:	eb 44                	jmp    f0108c83 <get_share+0xa4>
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	struct Share* founded = NULL;
	acquire_spinlock(&AllShares.shareslock);
	LIST_FOREACH(founded, &AllShares.shares_list) {
f0108c3f:	a1 28 d2 6b f0       	mov    0xf06bd228,%eax
f0108c44:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c4b:	74 08                	je     f0108c55 <get_share+0x76>
f0108c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c50:	8b 40 58             	mov    0x58(%eax),%eax
f0108c53:	eb 05                	jmp    f0108c5a <get_share+0x7b>
f0108c55:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c5a:	a3 28 d2 6b f0       	mov    %eax,0xf06bd228
f0108c5f:	a1 28 d2 6b f0       	mov    0xf06bd228,%eax
f0108c64:	85 c0                	test   %eax,%eax
f0108c66:	75 9e                	jne    f0108c06 <get_share+0x27>
f0108c68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c6c:	75 98                	jne    f0108c06 <get_share+0x27>
		{
			release_spinlock(&AllShares.shareslock);
			return founded;
		}
	}
	release_spinlock(&AllShares.shareslock);
f0108c6e:	83 ec 0c             	sub    $0xc,%esp
f0108c71:	68 30 d2 6b f0       	push   $0xf06bd230
f0108c76:	e8 22 6a 00 00       	call   f010f69d <release_spinlock>
f0108c7b:	83 c4 10             	add    $0x10,%esp
	return NULL;
f0108c7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108c83:	c9                   	leave  
f0108c84:	c3                   	ret    

f0108c85 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108c85:	55                   	push   %ebp
f0108c86:	89 e5                	mov    %esp,%ebp
f0108c88:	83 ec 48             	sub    $0x48,%esp
f0108c8b:	8b 45 14             	mov    0x14(%ebp),%eax
f0108c8e:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108c91:	e8 f2 26 00 00       	call   f010b388 <get_cpu_proc>
f0108c96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share* existed = get_share(ownerID,shareName);
f0108c99:	83 ec 08             	sub    $0x8,%esp
f0108c9c:	ff 75 0c             	pushl  0xc(%ebp)
f0108c9f:	ff 75 08             	pushl  0x8(%ebp)
f0108ca2:	e8 38 ff ff ff       	call   f0108bdf <get_share>
f0108ca7:	83 c4 10             	add    $0x10,%esp
f0108caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
f0108cad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108cb1:	74 0a                	je     f0108cbd <createSharedObject+0x38>
f0108cb3:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0108cb8:	e9 59 01 00 00       	jmp    f0108e16 <createSharedObject+0x191>
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
f0108cbd:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f0108cc1:	50                   	push   %eax
f0108cc2:	ff 75 10             	pushl  0x10(%ebp)
f0108cc5:	ff 75 0c             	pushl  0xc(%ebp)
f0108cc8:	ff 75 08             	pushl  0x8(%ebp)
f0108ccb:	e8 37 fe ff ff       	call   f0108b07 <create_share>
f0108cd0:	83 c4 10             	add    $0x10,%esp
f0108cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(created_share == NULL) return E_NO_SHARE;
f0108cd6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108cda:	75 0a                	jne    f0108ce6 <createSharedObject+0x61>
f0108cdc:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f0108ce1:	e9 30 01 00 00       	jmp    f0108e16 <createSharedObject+0x191>
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f0108ce6:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108ced:	8b 55 10             	mov    0x10(%ebp),%edx
f0108cf0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108cf3:	01 d0                	add    %edx,%eax
f0108cf5:	48                   	dec    %eax
f0108cf6:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108cf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cfc:	ba 00 00 00 00       	mov    $0x0,%edx
f0108d01:	f7 75 e4             	divl   -0x1c(%ebp)
f0108d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d07:	29 d0                	sub    %edx,%eax
f0108d09:	c1 e8 0c             	shr    $0xc,%eax
f0108d0c:	89 45 dc             	mov    %eax,-0x24(%ebp)

	for (int k = 0; k < num_pages; k++)
f0108d0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108d16:	eb 6c                	jmp    f0108d84 <createSharedObject+0xff>
	{
		struct FrameInfo *ptr_frame_info;
		int ret = allocate_frame(&ptr_frame_info);
f0108d18:	83 ec 0c             	sub    $0xc,%esp
f0108d1b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108d1e:	50                   	push   %eax
f0108d1f:	e8 8e f4 ff ff       	call   f01081b2 <allocate_frame>
f0108d24:	83 c4 10             	add    $0x10,%esp
f0108d27:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (ret == 0)
f0108d2a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0108d2e:	75 3d                	jne    f0108d6d <createSharedObject+0xe8>
		{
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
f0108d30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d33:	c1 e0 0c             	shl    $0xc,%eax
f0108d36:	89 c2                	mov    %eax,%edx
f0108d38:	8b 45 18             	mov    0x18(%ebp),%eax
f0108d3b:	01 d0                	add    %edx,%eax
f0108d3d:	89 c1                	mov    %eax,%ecx
f0108d3f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d45:	8b 40 64             	mov    0x64(%eax),%eax
f0108d48:	6a 06                	push   $0x6
f0108d4a:	51                   	push   %ecx
f0108d4b:	52                   	push   %edx
f0108d4c:	50                   	push   %eax
f0108d4d:	e8 2d f9 ff ff       	call   f010867f <map_frame>
f0108d52:	83 c4 10             	add    $0x10,%esp
			created_share->framesStorage[k] = ptr_frame_info;
f0108d55:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108d58:	8b 40 54             	mov    0x54(%eax),%eax
f0108d5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d5e:	c1 e2 02             	shl    $0x2,%edx
f0108d61:	01 c2                	add    %eax,%edx
f0108d63:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108d66:	89 02                	mov    %eax,(%edx)
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d68:	ff 45 f4             	incl   -0xc(%ebp)
f0108d6b:	eb 17                	jmp    f0108d84 <createSharedObject+0xff>
			map_frame(myenv->env_page_directory, ptr_frame_info, (uint32)(virtual_address + (k * PAGE_SIZE)),PERM_USER|PERM_WRITEABLE);
			created_share->framesStorage[k] = ptr_frame_info;
		}
		else
		{
			panic("No Memory");
f0108d6d:	83 ec 04             	sub    $0x4,%esp
f0108d70:	68 e8 54 12 f0       	push   $0xf01254e8
f0108d75:	68 a6 00 00 00       	push   $0xa6
f0108d7a:	68 f4 54 12 f0       	push   $0xf01254f4
f0108d7f:	e8 b5 75 ff ff       	call   f0100339 <_panic>
	if(existed != NULL) return E_SHARED_MEM_EXISTS;
	struct Share* created_share = create_share(ownerID,  shareName,  size,  isWritable);
	if(created_share == NULL) return E_NO_SHARE;
	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;

	for (int k = 0; k < num_pages; k++)
f0108d84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d87:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0108d8a:	72 8c                	jb     f0108d18 <createSharedObject+0x93>
		{
			panic("No Memory");
			return E_NO_SHARE;
		}
	}
	acquire_spinlock(&AllShares.shareslock);
f0108d8c:	83 ec 0c             	sub    $0xc,%esp
f0108d8f:	68 30 d2 6b f0       	push   $0xf06bd230
f0108d94:	e8 7d 68 00 00       	call   f010f616 <acquire_spinlock>
f0108d99:	83 c4 10             	add    $0x10,%esp
	LIST_INSERT_TAIL(&AllShares.shares_list,created_share);
f0108d9c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0108da0:	75 17                	jne    f0108db9 <createSharedObject+0x134>
f0108da2:	83 ec 04             	sub    $0x4,%esp
f0108da5:	68 18 55 12 f0       	push   $0xf0125518
f0108daa:	68 ab 00 00 00       	push   $0xab
f0108daf:	68 f4 54 12 f0       	push   $0xf01254f4
f0108db4:	e8 80 75 ff ff       	call   f0100339 <_panic>
f0108db9:	8b 15 24 d2 6b f0    	mov    0xf06bd224,%edx
f0108dbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dc2:	89 50 5c             	mov    %edx,0x5c(%eax)
f0108dc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108dc8:	8b 40 5c             	mov    0x5c(%eax),%eax
f0108dcb:	85 c0                	test   %eax,%eax
f0108dcd:	74 0d                	je     f0108ddc <createSharedObject+0x157>
f0108dcf:	a1 24 d2 6b f0       	mov    0xf06bd224,%eax
f0108dd4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108dd7:	89 50 58             	mov    %edx,0x58(%eax)
f0108dda:	eb 08                	jmp    f0108de4 <createSharedObject+0x15f>
f0108ddc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ddf:	a3 20 d2 6b f0       	mov    %eax,0xf06bd220
f0108de4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108de7:	a3 24 d2 6b f0       	mov    %eax,0xf06bd224
f0108dec:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108def:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0108df6:	a1 2c d2 6b f0       	mov    0xf06bd22c,%eax
f0108dfb:	40                   	inc    %eax
f0108dfc:	a3 2c d2 6b f0       	mov    %eax,0xf06bd22c
	release_spinlock(&AllShares.shareslock);
f0108e01:	83 ec 0c             	sub    $0xc,%esp
f0108e04:	68 30 d2 6b f0       	push   $0xf06bd230
f0108e09:	e8 8f 68 00 00       	call   f010f69d <release_spinlock>
f0108e0e:	83 c4 10             	add    $0x10,%esp
	return created_share->ID;
f0108e11:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e14:	8b 00                	mov    (%eax),%eax
}
f0108e16:	c9                   	leave  
f0108e17:	c3                   	ret    

f0108e18 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108e18:	55                   	push   %ebp
f0108e19:	89 e5                	mov    %esp,%ebp
f0108e1b:	53                   	push   %ebx
f0108e1c:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...

	struct Env* myenv = get_cpu_proc(); //The calling environment
f0108e1f:	e8 64 25 00 00       	call   f010b388 <get_cpu_proc>
f0108e24:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Share * shared_obj = get_share(ownerID,shareName);
f0108e27:	83 ec 08             	sub    $0x8,%esp
f0108e2a:	ff 75 0c             	pushl  0xc(%ebp)
f0108e2d:	ff 75 08             	pushl  0x8(%ebp)
f0108e30:	e8 aa fd ff ff       	call   f0108bdf <get_share>
f0108e35:	83 c4 10             	add    $0x10,%esp
f0108e38:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
f0108e3b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0108e3f:	75 0a                	jne    f0108e4b <getSharedObject+0x33>
f0108e41:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108e46:	e9 a0 00 00 00       	jmp    f0108eeb <getSharedObject+0xd3>
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
f0108e4b:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f0108e52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e55:	8b 40 48             	mov    0x48(%eax),%eax
f0108e58:	89 c2                	mov    %eax,%edx
f0108e5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e5d:	01 d0                	add    %edx,%eax
f0108e5f:	48                   	dec    %eax
f0108e60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108e63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e66:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e6b:	f7 75 e8             	divl   -0x18(%ebp)
f0108e6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e71:	29 d0                	sub    %edx,%eax
f0108e73:	85 c0                	test   %eax,%eax
f0108e75:	79 05                	jns    f0108e7c <getSharedObject+0x64>
f0108e77:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108e7c:	c1 f8 0c             	sar    $0xc,%eax
f0108e7f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	for(int i = 0 ;i< numOfFrames ;i++)
f0108e82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108e89:	eb 44                	jmp    f0108ecf <getSharedObject+0xb7>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
f0108e8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e8e:	8a 40 50             	mov    0x50(%eax),%al
f0108e91:	0f b6 c0             	movzbl %al,%eax
f0108e94:	01 c0                	add    %eax,%eax
f0108e96:	83 c8 04             	or     $0x4,%eax
f0108e99:	89 c3                	mov    %eax,%ebx
f0108e9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e9e:	c1 e0 0c             	shl    $0xc,%eax
f0108ea1:	89 c2                	mov    %eax,%edx
f0108ea3:	8b 45 10             	mov    0x10(%ebp),%eax
f0108ea6:	01 d0                	add    %edx,%eax
f0108ea8:	89 c1                	mov    %eax,%ecx
f0108eaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ead:	8b 40 54             	mov    0x54(%eax),%eax
f0108eb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108eb3:	c1 e2 02             	shl    $0x2,%edx
f0108eb6:	01 d0                	add    %edx,%eax
f0108eb8:	8b 10                	mov    (%eax),%edx
f0108eba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ebd:	8b 40 64             	mov    0x64(%eax),%eax
f0108ec0:	53                   	push   %ebx
f0108ec1:	51                   	push   %ecx
f0108ec2:	52                   	push   %edx
f0108ec3:	50                   	push   %eax
f0108ec4:	e8 b6 f7 ff ff       	call   f010867f <map_frame>
f0108ec9:	83 c4 10             	add    $0x10,%esp

	struct Env* myenv = get_cpu_proc(); //The calling environment
	struct Share * shared_obj = get_share(ownerID,shareName);
	if(shared_obj == NULL) return E_SHARED_MEM_NOT_EXISTS;
	uint32 numOfFrames = ROUNDUP(shared_obj->size ,PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0 ;i< numOfFrames ;i++)
f0108ecc:	ff 45 f4             	incl   -0xc(%ebp)
f0108ecf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108ed2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0108ed5:	72 b4                	jb     f0108e8b <getSharedObject+0x73>
	{
		map_frame(myenv->env_page_directory,shared_obj->framesStorage[i],(uint32)(virtual_address + (i * PAGE_SIZE)),PERM_USER|shared_obj->isWritable * PERM_WRITEABLE);
	}
	shared_obj->references++;
f0108ed7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eda:	8b 40 4c             	mov    0x4c(%eax),%eax
f0108edd:	8d 50 01             	lea    0x1(%eax),%edx
f0108ee0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ee3:	89 50 4c             	mov    %edx,0x4c(%eax)
	return shared_obj->ID;
f0108ee6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ee9:	8b 00                	mov    (%eax),%eax
}
f0108eeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108eee:	c9                   	leave  
f0108eef:	c3                   	ret    

f0108ef0 <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108ef0:	55                   	push   %ebp
f0108ef1:	89 e5                	mov    %esp,%ebp
f0108ef3:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f0108ef6:	83 ec 04             	sub    $0x4,%esp
f0108ef9:	68 3c 55 12 f0       	push   $0xf012553c
f0108efe:	68 d4 00 00 00       	push   $0xd4
f0108f03:	68 f4 54 12 f0       	push   $0xf01254f4
f0108f08:	e8 2c 74 ff ff       	call   f0100339 <_panic>

f0108f0d <freeSharedObject>:
}
//========================
// [B2] Free Share Object:
//========================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108f0d:	55                   	push   %ebp
f0108f0e:	89 e5                	mov    %esp,%ebp
f0108f10:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108f13:	83 ec 04             	sub    $0x4,%esp
f0108f16:	68 60 55 12 f0       	push   $0xf0125560
f0108f1b:	68 df 00 00 00       	push   $0xdf
f0108f20:	68 f4 54 12 f0       	push   $0xf01254f4
f0108f25:	e8 0f 74 ff ff       	call   f0100339 <_panic>

f0108f2a <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0108f2a:	55                   	push   %ebp
f0108f2b:	89 e5                	mov    %esp,%ebp
f0108f2d:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0108f32:	83 f8 01             	cmp    $0x1,%eax
f0108f35:	75 04                	jne    f0108f3b <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0108f37:	b0 01                	mov    $0x1,%al
f0108f39:	eb 02                	jmp    f0108f3d <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0108f3b:	b0 00                	mov    $0x0,%al
f0108f3d:	5d                   	pop    %ebp
f0108f3e:	c3                   	ret    

f0108f3f <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0108f3f:	55                   	push   %ebp
f0108f40:	89 e5                	mov    %esp,%ebp
f0108f42:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f0108f47:	83 f8 02             	cmp    $0x2,%eax
f0108f4a:	75 04                	jne    f0108f50 <isKHeapPlacementStrategyBESTFIT+0x11>
f0108f4c:	b0 01                	mov    $0x1,%al
f0108f4e:	eb 02                	jmp    f0108f52 <isKHeapPlacementStrategyBESTFIT+0x13>
f0108f50:	b0 00                	mov    $0x0,%al
f0108f52:	5d                   	pop    %ebp
f0108f53:	c3                   	ret    

f0108f54 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108f54:	55                   	push   %ebp
f0108f55:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108f57:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f5a:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f0108f60:	29 d0                	sub    %edx,%eax
f0108f62:	c1 f8 03             	sar    $0x3,%eax
f0108f65:	89 c2                	mov    %eax,%edx
f0108f67:	89 d0                	mov    %edx,%eax
f0108f69:	c1 e0 02             	shl    $0x2,%eax
f0108f6c:	01 d0                	add    %edx,%eax
f0108f6e:	c1 e0 02             	shl    $0x2,%eax
f0108f71:	01 d0                	add    %edx,%eax
f0108f73:	c1 e0 02             	shl    $0x2,%eax
f0108f76:	01 d0                	add    %edx,%eax
f0108f78:	89 c1                	mov    %eax,%ecx
f0108f7a:	c1 e1 08             	shl    $0x8,%ecx
f0108f7d:	01 c8                	add    %ecx,%eax
f0108f7f:	89 c1                	mov    %eax,%ecx
f0108f81:	c1 e1 10             	shl    $0x10,%ecx
f0108f84:	01 c8                	add    %ecx,%eax
f0108f86:	01 c0                	add    %eax,%eax
f0108f88:	01 d0                	add    %edx,%eax
}
f0108f8a:	5d                   	pop    %ebp
f0108f8b:	c3                   	ret    

f0108f8c <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108f8c:	55                   	push   %ebp
f0108f8d:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108f8f:	ff 75 08             	pushl  0x8(%ebp)
f0108f92:	e8 bd ff ff ff       	call   f0108f54 <to_frame_number>
f0108f97:	83 c4 04             	add    $0x4,%esp
f0108f9a:	c1 e0 0c             	shl    $0xc,%eax
}
f0108f9d:	c9                   	leave  
f0108f9e:	c3                   	ret    

f0108f9f <initialize_kheap_dynamic_allocator>:
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC

uint32 no_pages_alloc[NUM_OF_KHEAP_PAGES];
uint32 to_virtual[1048576];
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108f9f:	55                   	push   %ebp
f0108fa0:	89 e5                	mov    %esp,%ebp
f0108fa2:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
	start = daStart;
f0108fa5:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fa8:	a3 08 da 6b f0       	mov    %eax,0xf06bda08
	hard_limit = daLimit;
f0108fad:	8b 45 10             	mov    0x10(%ebp),%eax
f0108fb0:	a3 54 d8 6b f0       	mov    %eax,0xf06bd854
	brk = daStart + initSizeToAllocate;
f0108fb5:	8b 55 08             	mov    0x8(%ebp),%edx
f0108fb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108fbb:	01 d0                	add    %edx,%eax
f0108fbd:	a3 00 da 6b f0       	mov    %eax,0xf06bda00

	if(brk > daLimit) panic("exceeds Limit");
f0108fc2:	a1 00 da 6b f0       	mov    0xf06bda00,%eax
f0108fc7:	3b 45 10             	cmp    0x10(%ebp),%eax
f0108fca:	76 14                	jbe    f0108fe0 <initialize_kheap_dynamic_allocator+0x41>
f0108fcc:	83 ec 04             	sub    $0x4,%esp
f0108fcf:	68 88 55 12 f0       	push   $0xf0125588
f0108fd4:	6a 1a                	push   $0x1a
f0108fd6:	68 96 55 12 f0       	push   $0xf0125596
f0108fdb:	e8 59 73 ff ff       	call   f0100339 <_panic>

	 struct FrameInfo * start_block_area = (struct FrameInfo*) KERNEL_HEAP_START;
f0108fe0:	c7 45 f0 00 00 00 f6 	movl   $0xf6000000,-0x10(%ebp)
	 struct FrameInfo * end_block_area = (struct FrameInfo*) daLimit;
f0108fe7:	8b 45 10             	mov    0x10(%ebp),%eax
f0108fea:	89 45 ec             	mov    %eax,-0x14(%ebp)

	 uint32 page_area_size = initSizeToAllocate;
f0108fed:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108ff0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;
f0108ff3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ff6:	c1 e8 0c             	shr    $0xc,%eax
f0108ff9:	89 45 e4             	mov    %eax,-0x1c(%ebp)


	 for(int i=0;i<no_pages;i++)
f0108ffc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109003:	e9 8a 00 00 00       	jmp    f0109092 <initialize_kheap_dynamic_allocator+0xf3>
	 {
		 struct FrameInfo * ptr_frame;
		int ret = allocate_frame(&ptr_frame);
f0109008:	83 ec 0c             	sub    $0xc,%esp
f010900b:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010900e:	50                   	push   %eax
f010900f:	e8 9e f1 ff ff       	call   f01081b2 <allocate_frame>
f0109014:	83 c4 10             	add    $0x10,%esp
f0109017:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(ret != E_NO_MEM)
f010901a:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010901e:	74 5e                	je     f010907e <initialize_kheap_dynamic_allocator+0xdf>
		{
			map_frame(ptr_page_directory,ptr_frame,(uint32)start_block_area+i*PAGE_SIZE,PERM_WRITEABLE);
f0109020:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109023:	c1 e0 0c             	shl    $0xc,%eax
f0109026:	89 c2                	mov    %eax,%edx
f0109028:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010902b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010902e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0109031:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0109036:	6a 02                	push   $0x2
f0109038:	51                   	push   %ecx
f0109039:	52                   	push   %edx
f010903a:	50                   	push   %eax
f010903b:	e8 3f f6 ff ff       	call   f010867f <map_frame>
f0109040:	83 c4 10             	add    $0x10,%esp
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
f0109043:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109046:	c1 e0 0c             	shl    $0xc,%eax
f0109049:	89 c2                	mov    %eax,%edx
f010904b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010904e:	01 d0                	add    %edx,%eax
f0109050:	83 ec 0c             	sub    $0xc,%esp
f0109053:	50                   	push   %eax
f0109054:	e8 d6 04 00 00       	call   f010952f <kheap_physical_address>
f0109059:	83 c4 10             	add    $0x10,%esp
f010905c:	89 45 dc             	mov    %eax,-0x24(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
f010905f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109062:	c1 e8 0c             	shr    $0xc,%eax
f0109065:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109068:	c1 e2 0c             	shl    $0xc,%edx
f010906b:	89 d1                	mov    %edx,%ecx
f010906d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109070:	01 ca                	add    %ecx,%edx
f0109072:	89 14 85 a0 3f 70 f0 	mov    %edx,-0xf8fc060(,%eax,4)

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109079:	ff 45 f4             	incl   -0xc(%ebp)
f010907c:	eb 14                	jmp    f0109092 <initialize_kheap_dynamic_allocator+0xf3>
			uint32 pa = kheap_physical_address((uint32)start_block_area+i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = (uint32)start_block_area+i*PAGE_SIZE;
		}
		else
		{
			panic("No Memory");
f010907e:	83 ec 04             	sub    $0x4,%esp
f0109081:	68 a7 55 12 f0       	push   $0xf01255a7
f0109086:	6a 2f                	push   $0x2f
f0109088:	68 96 55 12 f0       	push   $0xf0125596
f010908d:	e8 a7 72 ff ff       	call   f0100339 <_panic>

	 uint32 page_area_size = initSizeToAllocate;
	 uint32 no_pages = page_area_size / (uint32)PAGE_SIZE;


	 for(int i=0;i<no_pages;i++)
f0109092:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109095:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109098:	0f 82 6a ff ff ff    	jb     f0109008 <initialize_kheap_dynamic_allocator+0x69>
		{
			panic("No Memory");
		}

	 }
	initialize_dynamic_allocator(daStart,initSizeToAllocate);
f010909e:	83 ec 08             	sub    $0x8,%esp
f01090a1:	ff 75 0c             	pushl  0xc(%ebp)
f01090a4:	ff 75 08             	pushl  0x8(%ebp)
f01090a7:	e8 e7 70 01 00       	call   f0120193 <initialize_dynamic_allocator>
f01090ac:	83 c4 10             	add    $0x10,%esp

	return 0;
f01090af:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01090b4:	c9                   	leave  
f01090b5:	c3                   	ret    

f01090b6 <sbrk>:

void* sbrk(int numOfPages)
{
f01090b6:	55                   	push   %ebp
f01090b7:	89 e5                	mov    %esp,%ebp
f01090b9:	83 ec 28             	sub    $0x28,%esp
	//====================================================

	//TODO: [PROJECT'24.MS2 - #02] [1] KERNEL HEAP - sbrk
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	if(numOfPages > 0)
f01090bc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01090c0:	0f 8e d6 00 00 00    	jle    f010919c <sbrk+0xe6>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f01090c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01090c9:	c1 e0 0c             	shl    $0xc,%eax
f01090cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk=brk;
f01090cf:	a1 00 da 6b f0       	mov    0xf06bda00,%eax
f01090d4:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if(brk+size > hard_limit) return (void *)-1;
f01090d7:	8b 15 00 da 6b f0    	mov    0xf06bda00,%edx
f01090dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01090e0:	01 c2                	add    %eax,%edx
f01090e2:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f01090e7:	39 c2                	cmp    %eax,%edx
f01090e9:	76 0a                	jbe    f01090f5 <sbrk+0x3f>
f01090eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01090f0:	e9 b9 00 00 00       	jmp    f01091ae <sbrk+0xf8>

		for(int i=0;i<numOfPages;i++)
f01090f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01090fc:	eb 7d                	jmp    f010917b <sbrk+0xc5>
		{
			struct FrameInfo * ptr_frame;
			int ret = allocate_frame(&ptr_frame);
f01090fe:	83 ec 0c             	sub    $0xc,%esp
f0109101:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0109104:	50                   	push   %eax
f0109105:	e8 a8 f0 ff ff       	call   f01081b2 <allocate_frame>
f010910a:	83 c4 10             	add    $0x10,%esp
f010910d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(ret != E_NO_MEM)
f0109110:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0109114:	74 5e                	je     f0109174 <sbrk+0xbe>
			{
				map_frame(ptr_page_directory,ptr_frame,prev_brk+i*PAGE_SIZE,PERM_WRITEABLE);
f0109116:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109119:	c1 e0 0c             	shl    $0xc,%eax
f010911c:	89 c2                	mov    %eax,%edx
f010911e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109121:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109124:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109127:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010912c:	6a 02                	push   $0x2
f010912e:	51                   	push   %ecx
f010912f:	52                   	push   %edx
f0109130:	50                   	push   %eax
f0109131:	e8 49 f5 ff ff       	call   f010867f <map_frame>
f0109136:	83 c4 10             	add    $0x10,%esp
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
f0109139:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010913c:	c1 e0 0c             	shl    $0xc,%eax
f010913f:	89 c2                	mov    %eax,%edx
f0109141:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109144:	01 d0                	add    %edx,%eax
f0109146:	83 ec 0c             	sub    $0xc,%esp
f0109149:	50                   	push   %eax
f010914a:	e8 e0 03 00 00       	call   f010952f <kheap_physical_address>
f010914f:	83 c4 10             	add    $0x10,%esp
f0109152:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
f0109155:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109158:	c1 e8 0c             	shr    $0xc,%eax
f010915b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010915e:	c1 e2 0c             	shl    $0xc,%edx
f0109161:	89 d1                	mov    %edx,%ecx
f0109163:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109166:	01 ca                	add    %ecx,%edx
f0109168:	89 14 85 a0 3f 70 f0 	mov    %edx,-0xf8fc060(,%eax,4)
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f010916f:	ff 45 f4             	incl   -0xc(%ebp)
f0109172:	eb 07                	jmp    f010917b <sbrk+0xc5>
				uint32 pa = kheap_physical_address(prev_brk+i*PAGE_SIZE);
				to_virtual[pa / PAGE_SIZE] = prev_brk+i*PAGE_SIZE;
			}
			else
			{
				return (void *)-1;
f0109174:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109179:	eb 33                	jmp    f01091ae <sbrk+0xf8>
		uint32 size = numOfPages * PAGE_SIZE;
		uint32 prev_brk=brk;

		if(brk+size > hard_limit) return (void *)-1;

		for(int i=0;i<numOfPages;i++)
f010917b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010917e:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109181:	0f 8c 77 ff ff ff    	jl     f01090fe <sbrk+0x48>
			else
			{
				return (void *)-1;
			}
		}
		brk += size;
f0109187:	8b 15 00 da 6b f0    	mov    0xf06bda00,%edx
f010918d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109190:	01 d0                	add    %edx,%eax
f0109192:	a3 00 da 6b f0       	mov    %eax,0xf06bda00
		return (void *)prev_brk;
f0109197:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010919a:	eb 12                	jmp    f01091ae <sbrk+0xf8>

	}
	else if(numOfPages == 0)
f010919c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01091a0:	75 07                	jne    f01091a9 <sbrk+0xf3>
	{
		return (void *) brk;
f01091a2:	a1 00 da 6b f0       	mov    0xf06bda00,%eax
f01091a7:	eb 05                	jmp    f01091ae <sbrk+0xf8>
	}

	return (void *)-1;
f01091a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
f01091ae:	c9                   	leave  
f01091af:	c3                   	ret    

f01091b0 <isPageAllocated>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator
bool isPageAllocated(uint32 *ptr_page_directory, const uint32 virtual_address)
{
f01091b0:	55                   	push   %ebp
f01091b1:	89 e5                	mov    %esp,%ebp
f01091b3:	83 ec 18             	sub    $0x18,%esp
	uint32* ptr_pageTable = NULL;
f01091b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_pageTable);
f01091bd:	83 ec 04             	sub    $0x4,%esp
f01091c0:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01091c3:	50                   	push   %eax
f01091c4:	ff 75 0c             	pushl  0xc(%ebp)
f01091c7:	ff 75 08             	pushl  0x8(%ebp)
f01091ca:	e8 9a f5 ff ff       	call   f0108769 <get_frame_info>
f01091cf:	83 c4 10             	add    $0x10,%esp
f01091d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_frame_info == NULL) return 0;
f01091d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01091d9:	75 07                	jne    f01091e2 <isPageAllocated+0x32>
f01091db:	b8 00 00 00 00       	mov    $0x0,%eax
f01091e0:	eb 05                	jmp    f01091e7 <isPageAllocated+0x37>
	return 1;
f01091e2:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01091e7:	c9                   	leave  
f01091e8:	c3                   	ret    

f01091e9 <kmalloc>:

void *kmalloc(unsigned int size)
{
f01091e9:	55                   	push   %ebp
f01091ea:	89 e5                	mov    %esp,%ebp
f01091ec:	83 ec 48             	sub    $0x48,%esp
	// TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	//  Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	uint32 num_pages = ROUNDUP(size ,PAGE_SIZE) / PAGE_SIZE;
f01091ef:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01091f6:	8b 55 08             	mov    0x8(%ebp),%edx
f01091f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01091fc:	01 d0                	add    %edx,%eax
f01091fe:	48                   	dec    %eax
f01091ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109202:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109205:	ba 00 00 00 00       	mov    $0x0,%edx
f010920a:	f7 75 d8             	divl   -0x28(%ebp)
f010920d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109210:	29 d0                	sub    %edx,%eax
f0109212:	c1 e8 0c             	shr    $0xc,%eax
f0109215:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 max_no_of_pages = ROUNDUP((uint32)KERNEL_HEAP_MAX - hard_limit + (uint32)PAGE_SIZE ,PAGE_SIZE) / PAGE_SIZE;
f0109218:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f010921f:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f0109224:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109227:	29 c2                	sub    %eax,%edx
f0109229:	89 d0                	mov    %edx,%eax
f010922b:	48                   	dec    %eax
f010922c:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010922f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109232:	ba 00 00 00 00       	mov    $0x0,%edx
f0109237:	f7 75 cc             	divl   -0x34(%ebp)
f010923a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010923d:	29 d0                	sub    %edx,%eax
f010923f:	c1 e8 0c             	shr    $0xc,%eax
f0109242:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	void *ptr = NULL;
f0109245:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE)
f010924c:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109253:	77 42                	ja     f0109297 <kmalloc+0xae>
	{
		if (isKHeapPlacementStrategyFIRSTFIT())
f0109255:	e8 d0 fc ff ff       	call   f0108f2a <isKHeapPlacementStrategyFIRSTFIT>
f010925a:	84 c0                	test   %al,%al
f010925c:	74 16                	je     f0109274 <kmalloc+0x8b>
			ptr = alloc_block_FF(size);
f010925e:	83 ec 0c             	sub    $0xc,%esp
f0109261:	ff 75 08             	pushl  0x8(%ebp)
f0109264:	e8 46 71 01 00       	call   f01203af <alloc_block_FF>
f0109269:	83 c4 10             	add    $0x10,%esp
f010926c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010926f:	e9 d0 01 00 00       	jmp    f0109444 <kmalloc+0x25b>
		else if (isKHeapPlacementStrategyBESTFIT())
f0109274:	e8 c6 fc ff ff       	call   f0108f3f <isKHeapPlacementStrategyBESTFIT>
f0109279:	84 c0                	test   %al,%al
f010927b:	0f 84 c3 01 00 00    	je     f0109444 <kmalloc+0x25b>
			ptr = alloc_block_BF(size);
f0109281:	83 ec 0c             	sub    $0xc,%esp
f0109284:	ff 75 08             	pushl  0x8(%ebp)
f0109287:	e8 df 75 01 00       	call   f012086b <alloc_block_BF>
f010928c:	83 c4 10             	add    $0x10,%esp
f010928f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109292:	e9 ad 01 00 00       	jmp    f0109444 <kmalloc+0x25b>
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
f0109297:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010929a:	48                   	dec    %eax
f010929b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f010929e:	0f 86 99 01 00 00    	jbe    f010943d <kmalloc+0x254>
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
f01092a4:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f01092a9:	05 00 10 00 00       	add    $0x1000,%eax
f01092ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		bool ok = 0;
f01092b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		while (i < (uint32)KERNEL_HEAP_MAX)
f01092b8:	e9 86 00 00 00       	jmp    f0109343 <kmalloc+0x15a>
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
f01092bd:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01092c2:	83 ec 08             	sub    $0x8,%esp
f01092c5:	ff 75 f0             	pushl  -0x10(%ebp)
f01092c8:	50                   	push   %eax
f01092c9:	e8 e2 fe ff ff       	call   f01091b0 <isPageAllocated>
f01092ce:	83 c4 10             	add    $0x10,%esp
f01092d1:	85 c0                	test   %eax,%eax
f01092d3:	75 61                	jne    f0109336 <kmalloc+0x14d>
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
f01092d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092d8:	05 00 10 00 00       	add    $0x1000,%eax
f01092dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
				uint32 cnt = 0;
f01092e0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				while(cnt < num_pages - 1)
f01092e7:	eb 3d                	jmp    f0109326 <kmalloc+0x13d>
				{
					if(j >= (uint32)KERNEL_HEAP_MAX) return NULL;
f01092e9:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f01092f0:	76 0a                	jbe    f01092fc <kmalloc+0x113>
f01092f2:	b8 00 00 00 00       	mov    $0x0,%eax
f01092f7:	e9 4b 01 00 00       	jmp    f0109447 <kmalloc+0x25e>
					if (isPageAllocated(ptr_page_directory, j))
f01092fc:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0109301:	83 ec 08             	sub    $0x8,%esp
f0109304:	ff 75 e8             	pushl  -0x18(%ebp)
f0109307:	50                   	push   %eax
f0109308:	e8 a3 fe ff ff       	call   f01091b0 <isPageAllocated>
f010930d:	83 c4 10             	add    $0x10,%esp
f0109310:	85 c0                	test   %eax,%eax
f0109312:	74 08                	je     f010931c <kmalloc+0x133>
					{

						i = j;
f0109314:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109317:	89 45 f0             	mov    %eax,-0x10(%ebp)
						goto sayed;
f010931a:	eb 1a                	jmp    f0109336 <kmalloc+0x14d>
					}

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++
f010931c:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)

					cnt++;
f0109323:	ff 45 e4             	incl   -0x1c(%ebp)
		{
			if (!isPageAllocated(ptr_page_directory, i)) // page not allocated?
			{
				uint32 j = i + (uint32)PAGE_SIZE; // <-- changed, was j = i + 1
				uint32 cnt = 0;
				while(cnt < num_pages - 1)
f0109326:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109329:	48                   	dec    %eax
f010932a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010932d:	77 ba                	ja     f01092e9 <kmalloc+0x100>

					j += (uint32)PAGE_SIZE; // <-- changed, was j ++

					cnt++;
				}
				ok = 1;
f010932f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
			}
			sayed:
			if(ok)
f0109336:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010933a:	75 16                	jne    f0109352 <kmalloc+0x169>
			{
				break;
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
f010933c:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
	}
	else if(num_pages < max_no_of_pages - 1) // the else statement in kern/mem/kheap.c/kmalloc is wrong, rewrite it to be correct.
	{
		uint32 i = hard_limit + PAGE_SIZE; // start: hardlimit + 4  ______ end: KERNEL_HEAP_MAX
		bool ok = 0;
		while (i < (uint32)KERNEL_HEAP_MAX)
f0109343:	81 7d f0 ff ef ff ff 	cmpl   $0xffffefff,-0x10(%ebp)
f010934a:	0f 86 6d ff ff ff    	jbe    f01092bd <kmalloc+0xd4>
f0109350:	eb 01                	jmp    f0109353 <kmalloc+0x16a>
				ok = 1;
			}
			sayed:
			if(ok)
			{
				break;
f0109352:	90                   	nop
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
f0109353:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109357:	75 0a                	jne    f0109363 <kmalloc+0x17a>
f0109359:	b8 00 00 00 00       	mov    $0x0,%eax
f010935e:	e9 e4 00 00 00       	jmp    f0109447 <kmalloc+0x25e>
		for (int k = 0; k < num_pages; k++)
f0109363:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f010936a:	eb 57                	jmp    f01093c3 <kmalloc+0x1da>
		{
			struct FrameInfo *ptr_frame_info;
			int ret = allocate_frame(&ptr_frame_info);
f010936c:	83 ec 0c             	sub    $0xc,%esp
f010936f:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0109372:	50                   	push   %eax
f0109373:	e8 3a ee ff ff       	call   f01081b2 <allocate_frame>
f0109378:	83 c4 10             	add    $0x10,%esp
f010937b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			//map_frame(ptr_page_directory, ptr_frame_info, i + k * 1024, PERM_USER|PERM_WRITEABLE); REPLACED BY
			if (ret != E_NO_MEM)
f010937e:	83 7d c0 fc          	cmpl   $0xfffffffc,-0x40(%ebp)
f0109382:	74 28                	je     f01093ac <kmalloc+0x1c3>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
f0109384:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109387:	c1 e0 0c             	shl    $0xc,%eax
f010938a:	89 c2                	mov    %eax,%edx
f010938c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010938f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f0109392:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0109395:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010939a:	6a 02                	push   $0x2
f010939c:	51                   	push   %ecx
f010939d:	52                   	push   %edx
f010939e:	50                   	push   %eax
f010939f:	e8 db f2 ff ff       	call   f010867f <map_frame>
f01093a4:	83 c4 10             	add    $0x10,%esp
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01093a7:	ff 45 e0             	incl   -0x20(%ebp)
f01093aa:	eb 17                	jmp    f01093c3 <kmalloc+0x1da>
			{
				map_frame(ptr_page_directory, ptr_frame_info, i + k * PAGE_SIZE,PERM_WRITEABLE); // a3raf el page mnen
			}
			else
			{
				panic("No Memory");
f01093ac:	83 ec 04             	sub    $0x4,%esp
f01093af:	68 a7 55 12 f0       	push   $0xf01255a7
f01093b4:	68 b6 00 00 00       	push   $0xb6
f01093b9:	68 96 55 12 f0       	push   $0xf0125596
f01093be:	e8 76 6f ff ff       	call   f0100339 <_panic>
			}
			i += (uint32)PAGE_SIZE; // <-- changed, was i++
		}

		if(!ok) return NULL;
		for (int k = 0; k < num_pages; k++)
f01093c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01093c6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01093c9:	72 a1                	jb     f010936c <kmalloc+0x183>
			else
			{
				panic("No Memory");
			}
		}
		ptr = (void*)i;
f01093cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093ce:	89 45 f4             	mov    %eax,-0xc(%ebp)

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;
f01093d1:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f01093d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01093d9:	29 c2                	sub    %eax,%edx
f01093db:	89 d0                	mov    %edx,%eax
f01093dd:	2d 00 10 00 00       	sub    $0x1000,%eax
f01093e2:	c1 e8 0c             	shr    $0xc,%eax
f01093e5:	89 c2                	mov    %eax,%edx
f01093e7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01093ea:	89 04 95 a0 bf 6d f0 	mov    %eax,-0xf924060(,%edx,4)

		for(int i = 0; i < num_pages; i++){
f01093f1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01093f8:	eb 39                	jmp    f0109433 <kmalloc+0x24a>
			uint32 pa = kheap_physical_address((uint32)ptr + i * PAGE_SIZE);
f01093fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01093fd:	c1 e0 0c             	shl    $0xc,%eax
f0109400:	89 c2                	mov    %eax,%edx
f0109402:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109405:	01 d0                	add    %edx,%eax
f0109407:	83 ec 0c             	sub    $0xc,%esp
f010940a:	50                   	push   %eax
f010940b:	e8 1f 01 00 00       	call   f010952f <kheap_physical_address>
f0109410:	83 c4 10             	add    $0x10,%esp
f0109413:	89 45 bc             	mov    %eax,-0x44(%ebp)
			to_virtual[pa / PAGE_SIZE] = (uint32)ptr + i * PAGE_SIZE;
f0109416:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0109419:	c1 e8 0c             	shr    $0xc,%eax
f010941c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010941f:	c1 e2 0c             	shl    $0xc,%edx
f0109422:	89 d1                	mov    %edx,%ecx
f0109424:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109427:	01 ca                	add    %ecx,%edx
f0109429:	89 14 85 a0 3f 70 f0 	mov    %edx,-0xf8fc060(,%eax,4)
		}
		ptr = (void*)i;

		no_pages_alloc[KHEAP_PAGE_INDEX(i)] = num_pages;

		for(int i = 0; i < num_pages; i++){
f0109430:	ff 45 dc             	incl   -0x24(%ebp)
f0109433:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109436:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109439:	72 bf                	jb     f01093fa <kmalloc+0x211>
f010943b:	eb 07                	jmp    f0109444 <kmalloc+0x25b>
		}
	}
	else
	{

		return NULL;
f010943d:	b8 00 00 00 00       	mov    $0x0,%eax
f0109442:	eb 03                	jmp    f0109447 <kmalloc+0x25e>
	}
	return ptr;
f0109444:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109447:	c9                   	leave  
f0109448:	c3                   	ret    

f0109449 <kfree>:

void kfree(void *va)
{
f0109449:	55                   	push   %ebp
f010944a:	89 e5                	mov    %esp,%ebp
f010944c:	83 ec 18             	sub    $0x18,%esp
    //  Write your code here, remove the panic and write your code
//    panic("kfree() is not implemented yet...!!");

    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
f010944f:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f0109454:	05 00 10 00 00       	add    $0x1000,%eax
f0109459:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((uint32)va < hard_limit){
f010945c:	8b 55 08             	mov    0x8(%ebp),%edx
f010945f:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f0109464:	39 c2                	cmp    %eax,%edx
f0109466:	73 13                	jae    f010947b <kfree+0x32>
        free_block(va);
f0109468:	83 ec 0c             	sub    $0xc,%esp
f010946b:	ff 75 08             	pushl  0x8(%ebp)
f010946e:	e8 00 7e 01 00       	call   f0121273 <free_block>
f0109473:	83 c4 10             	add    $0x10,%esp
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
    }
}
f0109476:	e9 b1 00 00 00       	jmp    f010952c <kfree+0xe3>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f010947b:	8b 45 08             	mov    0x8(%ebp),%eax
f010947e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109481:	0f 82 8e 00 00 00    	jb     f0109515 <kfree+0xcc>
f0109487:	8b 45 08             	mov    0x8(%ebp),%eax
f010948a:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f010948f:	0f 87 80 00 00 00    	ja     f0109515 <kfree+0xcc>
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
f0109495:	8b 55 08             	mov    0x8(%ebp),%edx
f0109498:	a1 54 d8 6b f0       	mov    0xf06bd854,%eax
f010949d:	29 c2                	sub    %eax,%edx
f010949f:	89 d0                	mov    %edx,%eax
f01094a1:	2d 00 10 00 00       	sub    $0x1000,%eax
f01094a6:	c1 e8 0c             	shr    $0xc,%eax
f01094a9:	8b 04 85 a0 bf 6d f0 	mov    -0xf924060(,%eax,4),%eax
f01094b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f01094b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01094ba:	eb 4f                	jmp    f010950b <kfree+0xc2>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
f01094bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094bf:	c1 e0 0c             	shl    $0xc,%eax
f01094c2:	89 c2                	mov    %eax,%edx
f01094c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01094c7:	01 d0                	add    %edx,%eax
f01094c9:	83 ec 0c             	sub    $0xc,%esp
f01094cc:	50                   	push   %eax
f01094cd:	e8 5d 00 00 00       	call   f010952f <kheap_physical_address>
f01094d2:	83 c4 10             	add    $0x10,%esp
f01094d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			to_virtual[pa / PAGE_SIZE] = 0;
f01094d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01094db:	c1 e8 0c             	shr    $0xc,%eax
f01094de:	c7 04 85 a0 3f 70 f0 	movl   $0x0,-0xf8fc060(,%eax,4)
f01094e5:	00 00 00 00 
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
f01094e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094ec:	c1 e0 0c             	shl    $0xc,%eax
f01094ef:	89 c2                	mov    %eax,%edx
f01094f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01094f4:	01 c2                	add    %eax,%edx
f01094f6:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01094fb:	83 ec 08             	sub    $0x8,%esp
f01094fe:	52                   	push   %edx
f01094ff:	50                   	push   %eax
f0109500:	e8 da f2 ff ff       	call   f01087df <unmap_frame>
f0109505:	83 c4 10             	add    $0x10,%esp
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
    	uint32 no_of_pages = no_pages_alloc[KHEAP_PAGE_INDEX((uint32)va)];
		for(int i = 0; i < no_of_pages; i++){
f0109508:	ff 45 f4             	incl   -0xc(%ebp)
f010950b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010950e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109511:	72 a9                	jb     f01094bc <kfree+0x73>
    // you need to get the size of the given allocation using its address
    // refer to the project presentation and documentation for details
    uint32 pageA_start = hard_limit + PAGE_SIZE;
    if((uint32)va < hard_limit){
        free_block(va);
    } else if((uint32)va >= pageA_start && (uint32)va < KERNEL_HEAP_MAX){
f0109513:	eb 17                	jmp    f010952c <kfree+0xe3>
			uint32 pa = kheap_physical_address((uint32)va + i*PAGE_SIZE);
			to_virtual[pa / PAGE_SIZE] = 0;
			unmap_frame(ptr_page_directory, (uint32)va + i*PAGE_SIZE);
		}
    } else{
        panic("kfree: The virtual Address is invalid");
f0109515:	83 ec 04             	sub    $0x4,%esp
f0109518:	68 b4 55 12 f0       	push   $0xf01255b4
f010951d:	68 dd 00 00 00       	push   $0xdd
f0109522:	68 96 55 12 f0       	push   $0xf0125596
f0109527:	e8 0d 6e ff ff       	call   f0100339 <_panic>
    }
}
f010952c:	90                   	nop
f010952d:	c9                   	leave  
f010952e:	c3                   	ret    

f010952f <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int va)
{
f010952f:	55                   	push   %ebp
f0109530:	89 e5                	mov    %esp,%ebp
f0109532:	83 ec 18             	sub    $0x18,%esp
	// return the physical address corresponding to given virtual_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	uint32* ptr_page_table = NULL;
f0109535:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, va, &ptr_page_table);
f010953c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0109541:	83 ec 04             	sub    $0x4,%esp
f0109544:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0109547:	52                   	push   %edx
f0109548:	ff 75 08             	pushl  0x8(%ebp)
f010954b:	50                   	push   %eax
f010954c:	e8 18 f2 ff ff       	call   f0108769 <get_frame_info>
f0109551:	83 c4 10             	add    $0x10,%esp
f0109554:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_frame_info == NULL){
f0109557:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010955b:	75 07                	jne    f0109564 <kheap_physical_address+0x35>
		return 0;
f010955d:	b8 00 00 00 00       	mov    $0x0,%eax
f0109562:	eb 26                	jmp    f010958a <kheap_physical_address+0x5b>
	}

	uint32 offset = PGOFF(va);
f0109564:	8b 45 08             	mov    0x8(%ebp),%eax
f0109567:	25 ff 0f 00 00       	and    $0xfff,%eax
f010956c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pa = to_physical_address(ptr_frame_info) + offset;
f010956f:	83 ec 0c             	sub    $0xc,%esp
f0109572:	ff 75 f4             	pushl  -0xc(%ebp)
f0109575:	e8 12 fa ff ff       	call   f0108f8c <to_physical_address>
f010957a:	83 c4 10             	add    $0x10,%esp
f010957d:	89 c2                	mov    %eax,%edx
f010957f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109582:	01 d0                	add    %edx,%eax
f0109584:	89 45 ec             	mov    %eax,-0x14(%ebp)


	return pa;
f0109587:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010958a:	c9                   	leave  
f010958b:	c3                   	ret    

f010958c <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f010958c:	55                   	push   %ebp
f010958d:	89 e5                	mov    %esp,%ebp
f010958f:	83 ec 10             	sub    $0x10,%esp
	// return the virtual address corresponding to given physical_address
	// refer to the project presentation and documentation for details

	// EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	////////////get it in block Allocator//////////////////
	uint32 offset = PGOFF(physical_address);
f0109592:	8b 45 08             	mov    0x8(%ebp),%eax
f0109595:	25 ff 0f 00 00       	and    $0xfff,%eax
f010959a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32 va = to_virtual[physical_address / PAGE_SIZE];
f010959d:	8b 45 08             	mov    0x8(%ebp),%eax
f01095a0:	c1 e8 0c             	shr    $0xc,%eax
f01095a3:	8b 04 85 a0 3f 70 f0 	mov    -0xf8fc060(,%eax,4),%eax
f01095aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(va) va += offset;
f01095ad:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01095b1:	74 06                	je     f01095b9 <kheap_virtual_address+0x2d>
f01095b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01095b6:	01 45 fc             	add    %eax,-0x4(%ebp)
	return va;
f01095b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01095bc:	c9                   	leave  
f01095bd:	c3                   	ret    

f01095be <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f01095be:	55                   	push   %ebp
f01095bf:	89 e5                	mov    %esp,%ebp
	// TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	//  Write your code here, remove the panic and write your code
	return NULL;
f01095c1:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f01095c6:	5d                   	pop    %ebp
f01095c7:	c3                   	ret    

f01095c8 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f01095c8:	55                   	push   %ebp
f01095c9:	89 e5                	mov    %esp,%ebp
f01095cb:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01095ce:	83 ec 04             	sub    $0x4,%esp
f01095d1:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01095d4:	50                   	push   %eax
f01095d5:	ff 75 0c             	pushl  0xc(%ebp)
f01095d8:	ff 75 08             	pushl  0x8(%ebp)
f01095db:	e8 0f ee ff ff       	call   f01083ef <get_page_table>
f01095e0:	83 c4 10             	add    $0x10,%esp
f01095e3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f01095e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095e9:	85 c0                	test   %eax,%eax
f01095eb:	74 64                	je     f0109651 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f01095ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095f0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01095f3:	c1 ea 0c             	shr    $0xc,%edx
f01095f6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01095fc:	c1 e2 02             	shl    $0x2,%edx
f01095ff:	01 c2                	add    %eax,%edx
f0109601:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109604:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109607:	c1 e9 0c             	shr    $0xc,%ecx
f010960a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109610:	c1 e1 02             	shl    $0x2,%ecx
f0109613:	01 c8                	add    %ecx,%eax
f0109615:	8b 00                	mov    (%eax),%eax
f0109617:	0b 45 10             	or     0x10(%ebp),%eax
f010961a:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f010961c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010961f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109622:	c1 ea 0c             	shr    $0xc,%edx
f0109625:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010962b:	c1 e2 02             	shl    $0x2,%edx
f010962e:	01 d0                	add    %edx,%eax
f0109630:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109633:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109636:	c1 e9 0c             	shr    $0xc,%ecx
f0109639:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010963f:	c1 e1 02             	shl    $0x2,%ecx
f0109642:	01 ca                	add    %ecx,%edx
f0109644:	8b 12                	mov    (%edx),%edx
f0109646:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109649:	f7 d1                	not    %ecx
f010964b:	21 ca                	and    %ecx,%edx
f010964d:	89 10                	mov    %edx,(%eax)
f010964f:	eb 27                	jmp    f0109678 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109651:	83 ec 08             	sub    $0x8,%esp
f0109654:	ff 75 0c             	pushl  0xc(%ebp)
f0109657:	68 dc 55 12 f0       	push   $0xf01255dc
f010965c:	e8 2a 79 ff ff       	call   f0100f8b <cprintf>
f0109661:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109664:	83 ec 04             	sub    $0x4,%esp
f0109667:	68 04 56 12 f0       	push   $0xf0125604
f010966c:	6a 1c                	push   $0x1c
f010966e:	68 78 56 12 f0       	push   $0xf0125678
f0109673:	e8 c1 6c ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109678:	8b 45 0c             	mov    0xc(%ebp),%eax
f010967b:	83 ec 08             	sub    $0x8,%esp
f010967e:	50                   	push   %eax
f010967f:	6a 00                	push   $0x0
f0109681:	e8 33 e7 ff ff       	call   f0107db9 <tlb_invalidate>
f0109686:	83 c4 10             	add    $0x10,%esp
}
f0109689:	90                   	nop
f010968a:	c9                   	leave  
f010968b:	c3                   	ret    

f010968c <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f010968c:	55                   	push   %ebp
f010968d:	89 e5                	mov    %esp,%ebp
f010968f:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109692:	83 ec 04             	sub    $0x4,%esp
f0109695:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109698:	50                   	push   %eax
f0109699:	ff 75 0c             	pushl  0xc(%ebp)
f010969c:	ff 75 08             	pushl  0x8(%ebp)
f010969f:	e8 4b ed ff ff       	call   f01083ef <get_page_table>
f01096a4:	83 c4 10             	add    $0x10,%esp
f01096a7:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f01096aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096ad:	85 c0                	test   %eax,%eax
f01096af:	74 1d                	je     f01096ce <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f01096b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096b4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01096b7:	c1 ea 0c             	shr    $0xc,%edx
f01096ba:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01096c0:	c1 e2 02             	shl    $0x2,%edx
f01096c3:	01 d0                	add    %edx,%eax
f01096c5:	8b 00                	mov    (%eax),%eax
f01096c7:	25 ff 0f 00 00       	and    $0xfff,%eax
f01096cc:	eb 05                	jmp    f01096d3 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f01096ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f01096d3:	c9                   	leave  
f01096d4:	c3                   	ret    

f01096d5 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f01096d5:	55                   	push   %ebp
f01096d6:	89 e5                	mov    %esp,%ebp
f01096d8:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01096db:	83 ec 04             	sub    $0x4,%esp
f01096de:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01096e1:	50                   	push   %eax
f01096e2:	ff 75 0c             	pushl  0xc(%ebp)
f01096e5:	ff 75 08             	pushl  0x8(%ebp)
f01096e8:	e8 02 ed ff ff       	call   f01083ef <get_page_table>
f01096ed:	83 c4 10             	add    $0x10,%esp
f01096f0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f01096f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096f6:	85 c0                	test   %eax,%eax
f01096f8:	74 46                	je     f0109740 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f01096fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096fd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109700:	c1 ea 0c             	shr    $0xc,%edx
f0109703:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109709:	c1 e2 02             	shl    $0x2,%edx
f010970c:	01 d0                	add    %edx,%eax
f010970e:	8b 00                	mov    (%eax),%eax
f0109710:	83 ec 04             	sub    $0x4,%esp
f0109713:	50                   	push   %eax
f0109714:	ff 75 0c             	pushl  0xc(%ebp)
f0109717:	68 94 56 12 f0       	push   $0xf0125694
f010971c:	e8 6a 78 ff ff       	call   f0100f8b <cprintf>
f0109721:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0109724:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109727:	8b 55 0c             	mov    0xc(%ebp),%edx
f010972a:	c1 ea 0c             	shr    $0xc,%edx
f010972d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109733:	c1 e2 02             	shl    $0x2,%edx
f0109736:	01 d0                	add    %edx,%eax
f0109738:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010973e:	eb 14                	jmp    f0109754 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109740:	83 ec 04             	sub    $0x4,%esp
f0109743:	68 bc 56 12 f0       	push   $0xf01256bc
f0109748:	6a 47                	push   $0x47
f010974a:	68 78 56 12 f0       	push   $0xf0125678
f010974f:	e8 e5 6b ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109754:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109757:	83 ec 08             	sub    $0x8,%esp
f010975a:	50                   	push   %eax
f010975b:	6a 00                	push   $0x0
f010975d:	e8 57 e6 ff ff       	call   f0107db9 <tlb_invalidate>
f0109762:	83 c4 10             	add    $0x10,%esp
}
f0109765:	90                   	nop
f0109766:	c9                   	leave  
f0109767:	c3                   	ret    

f0109768 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f0109768:	55                   	push   %ebp
f0109769:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f010976b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010976e:	c1 e8 16             	shr    $0x16,%eax
f0109771:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109778:	8b 45 08             	mov    0x8(%ebp),%eax
f010977b:	01 d0                	add    %edx,%eax
f010977d:	8b 00                	mov    (%eax),%eax
f010977f:	83 e0 20             	and    $0x20,%eax
f0109782:	85 c0                	test   %eax,%eax
f0109784:	0f 95 c0             	setne  %al
f0109787:	0f b6 c0             	movzbl %al,%eax
}
f010978a:	5d                   	pop    %ebp
f010978b:	c3                   	ret    

f010978c <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f010978c:	55                   	push   %ebp
f010978d:	89 e5                	mov    %esp,%ebp
f010978f:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0109792:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109795:	c1 e8 16             	shr    $0x16,%eax
f0109798:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010979f:	8b 45 08             	mov    0x8(%ebp),%eax
f01097a2:	01 d0                	add    %edx,%eax
f01097a4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01097a7:	c1 ea 16             	shr    $0x16,%edx
f01097aa:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f01097b1:	8b 55 08             	mov    0x8(%ebp),%edx
f01097b4:	01 ca                	add    %ecx,%edx
f01097b6:	8b 12                	mov    (%edx),%edx
f01097b8:	83 e2 df             	and    $0xffffffdf,%edx
f01097bb:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01097bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097c0:	83 ec 08             	sub    $0x8,%esp
f01097c3:	50                   	push   %eax
f01097c4:	6a 00                	push   $0x0
f01097c6:	e8 ee e5 ff ff       	call   f0107db9 <tlb_invalidate>
f01097cb:	83 c4 10             	add    $0x10,%esp
}
f01097ce:	90                   	nop
f01097cf:	c9                   	leave  
f01097d0:	c3                   	ret    

f01097d1 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f01097d1:	55                   	push   %ebp
f01097d2:	89 e5                	mov    %esp,%ebp
f01097d4:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f01097d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097da:	c1 e8 16             	shr    $0x16,%eax
f01097dd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01097e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01097e7:	01 d0                	add    %edx,%eax
f01097e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01097ef:	0f 20 d8             	mov    %cr3,%eax
f01097f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01097f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01097f8:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01097fb:	90                   	nop
f01097fc:	c9                   	leave  
f01097fd:	c3                   	ret    

f01097fe <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f01097fe:	55                   	push   %ebp
f01097ff:	89 e5                	mov    %esp,%ebp
f0109801:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	void* retK = kmalloc(sizeof(struct WorkingSetElement));
f0109804:	83 ec 0c             	sub    $0xc,%esp
f0109807:	6a 18                	push   $0x18
f0109809:	e8 db f9 ff ff       	call   f01091e9 <kmalloc>
f010980e:	83 c4 10             	add    $0x10,%esp
f0109811:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (retK==NULL) panic("env_page_ws_list_create_element failed no mem");
f0109814:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109818:	75 14                	jne    f010982e <env_page_ws_list_create_element+0x30>
f010981a:	83 ec 04             	sub    $0x4,%esp
f010981d:	68 34 57 12 f0       	push   $0xf0125734
f0109822:	6a 19                	push   $0x19
f0109824:	68 64 57 12 f0       	push   $0xf0125764
f0109829:	e8 0b 6b ff ff       	call   f0100339 <_panic>
	struct WorkingSetElement* element =(struct WorkingSetElement*)retK;
f010982e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109831:	89 45 f0             	mov    %eax,-0x10(%ebp)
	element->virtual_address=ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109834:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109837:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010983a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010983d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109842:	89 c2                	mov    %eax,%edx
f0109844:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109847:	89 10                	mov    %edx,(%eax)
	element->empty=0;
f0109849:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010984c:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	element->time_stamp=0;
f0109850:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109853:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	element->sweeps_counter=0;
f010985a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010985d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return element;
f0109864:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
f0109867:	c9                   	leave  
f0109868:	c3                   	ret    

f0109869 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109869:	55                   	push   %ebp
f010986a:	89 e5                	mov    %esp,%ebp
f010986c:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010986f:	83 ec 0c             	sub    $0xc,%esp
f0109872:	6a 02                	push   $0x2
f0109874:	e8 4a 57 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f0109879:	83 c4 10             	add    $0x10,%esp
f010987c:	85 c0                	test   %eax,%eax
f010987e:	0f 84 e5 03 00 00    	je     f0109c69 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109884:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010988b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109892:	8b 45 08             	mov    0x8(%ebp),%eax
f0109895:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010989b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010989e:	e9 3b 02 00 00       	jmp    f0109ade <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f01098a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098a6:	8b 00                	mov    (%eax),%eax
f01098a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01098ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01098ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01098b3:	89 c2                	mov    %eax,%edx
f01098b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01098b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01098bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01098be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01098c3:	39 c2                	cmp    %eax,%edx
f01098c5:	0f 85 07 02 00 00    	jne    f0109ad2 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f01098cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01098ce:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01098d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f01098d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098da:	8b 10                	mov    (%eax),%edx
f01098dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01098df:	8b 40 64             	mov    0x64(%eax),%eax
f01098e2:	83 ec 08             	sub    $0x8,%esp
f01098e5:	52                   	push   %edx
f01098e6:	50                   	push   %eax
f01098e7:	e8 f3 ee ff ff       	call   f01087df <unmap_frame>
f01098ec:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f01098ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01098f3:	75 14                	jne    f0109909 <env_page_ws_invalidate+0xa0>
f01098f5:	83 ec 04             	sub    $0x4,%esp
f01098f8:	68 83 57 12 f0       	push   $0xf0125783
f01098fd:	6a 2f                	push   $0x2f
f01098ff:	68 64 57 12 f0       	push   $0xf0125764
f0109904:	e8 30 6a ff ff       	call   f0100339 <_panic>
f0109909:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010990c:	8b 40 10             	mov    0x10(%eax),%eax
f010990f:	85 c0                	test   %eax,%eax
f0109911:	74 11                	je     f0109924 <env_page_ws_invalidate+0xbb>
f0109913:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109916:	8b 40 10             	mov    0x10(%eax),%eax
f0109919:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010991c:	8b 52 14             	mov    0x14(%edx),%edx
f010991f:	89 50 14             	mov    %edx,0x14(%eax)
f0109922:	eb 0f                	jmp    f0109933 <env_page_ws_invalidate+0xca>
f0109924:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109927:	8b 50 14             	mov    0x14(%eax),%edx
f010992a:	8b 45 08             	mov    0x8(%ebp),%eax
f010992d:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109933:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109936:	8b 40 14             	mov    0x14(%eax),%eax
f0109939:	85 c0                	test   %eax,%eax
f010993b:	74 11                	je     f010994e <env_page_ws_invalidate+0xe5>
f010993d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109940:	8b 40 14             	mov    0x14(%eax),%eax
f0109943:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109946:	8b 52 10             	mov    0x10(%edx),%edx
f0109949:	89 50 10             	mov    %edx,0x10(%eax)
f010994c:	eb 0f                	jmp    f010995d <env_page_ws_invalidate+0xf4>
f010994e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109951:	8b 50 10             	mov    0x10(%eax),%edx
f0109954:	8b 45 08             	mov    0x8(%ebp),%eax
f0109957:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010995d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109960:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109967:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010996a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109971:	8b 45 08             	mov    0x8(%ebp),%eax
f0109974:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010997a:	8d 50 ff             	lea    -0x1(%eax),%edx
f010997d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109980:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f0109986:	83 ec 0c             	sub    $0xc,%esp
f0109989:	ff 75 f0             	pushl  -0x10(%ebp)
f010998c:	e8 b8 fa ff ff       	call   f0109449 <kfree>
f0109991:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f0109994:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109998:	0f 84 2b 01 00 00    	je     f0109ac9 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010999e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01099a2:	75 14                	jne    f01099b8 <env_page_ws_invalidate+0x14f>
f01099a4:	83 ec 04             	sub    $0x4,%esp
f01099a7:	68 83 57 12 f0       	push   $0xf0125783
f01099ac:	6a 35                	push   $0x35
f01099ae:	68 64 57 12 f0       	push   $0xf0125764
f01099b3:	e8 81 69 ff ff       	call   f0100339 <_panic>
f01099b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099bb:	8b 40 10             	mov    0x10(%eax),%eax
f01099be:	85 c0                	test   %eax,%eax
f01099c0:	74 11                	je     f01099d3 <env_page_ws_invalidate+0x16a>
f01099c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099c5:	8b 40 10             	mov    0x10(%eax),%eax
f01099c8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01099cb:	8b 52 14             	mov    0x14(%edx),%edx
f01099ce:	89 50 14             	mov    %edx,0x14(%eax)
f01099d1:	eb 0f                	jmp    f01099e2 <env_page_ws_invalidate+0x179>
f01099d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099d6:	8b 50 14             	mov    0x14(%eax),%edx
f01099d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01099dc:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f01099e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099e5:	8b 40 14             	mov    0x14(%eax),%eax
f01099e8:	85 c0                	test   %eax,%eax
f01099ea:	74 11                	je     f01099fd <env_page_ws_invalidate+0x194>
f01099ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01099ef:	8b 40 14             	mov    0x14(%eax),%eax
f01099f2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01099f5:	8b 52 10             	mov    0x10(%edx),%edx
f01099f8:	89 50 10             	mov    %edx,0x10(%eax)
f01099fb:	eb 0f                	jmp    f0109a0c <env_page_ws_invalidate+0x1a3>
f01099fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a00:	8b 50 10             	mov    0x10(%eax),%edx
f0109a03:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a06:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f0109a0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a0f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109a16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a19:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109a20:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a23:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0109a29:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109a2c:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a2f:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f0109a35:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109a39:	75 14                	jne    f0109a4f <env_page_ws_invalidate+0x1e6>
f0109a3b:	83 ec 04             	sub    $0x4,%esp
f0109a3e:	68 a4 57 12 f0       	push   $0xf01257a4
f0109a43:	6a 36                	push   $0x36
f0109a45:	68 64 57 12 f0       	push   $0xf0125764
f0109a4a:	e8 ea 68 ff ff       	call   f0100339 <_panic>
f0109a4f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a52:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f0109a58:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a5b:	89 50 14             	mov    %edx,0x14(%eax)
f0109a5e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a61:	8b 40 14             	mov    0x14(%eax),%eax
f0109a64:	85 c0                	test   %eax,%eax
f0109a66:	74 11                	je     f0109a79 <env_page_ws_invalidate+0x210>
f0109a68:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a6b:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0109a71:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109a74:	89 50 10             	mov    %edx,0x10(%eax)
f0109a77:	eb 0c                	jmp    f0109a85 <env_page_ws_invalidate+0x21c>
f0109a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a7c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109a7f:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f0109a85:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a88:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109a8b:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f0109a91:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109a94:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109a9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a9e:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109aa4:	8d 50 01             	lea    0x1(%eax),%edx
f0109aa7:	8b 45 08             	mov    0x8(%ebp),%eax
f0109aaa:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f0109ab0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109ab3:	8b 10                	mov    (%eax),%edx
f0109ab5:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ab8:	8b 40 64             	mov    0x64(%eax),%eax
f0109abb:	6a 00                	push   $0x0
f0109abd:	6a 01                	push   $0x1
f0109abf:	52                   	push   %edx
f0109ac0:	50                   	push   %eax
f0109ac1:	e8 02 fb ff ff       	call   f01095c8 <pt_set_page_permissions>
f0109ac6:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f0109ac9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0109ad0:	eb 43                	jmp    f0109b15 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109ad2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ad5:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109adb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109ade:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109ae2:	74 08                	je     f0109aec <env_page_ws_invalidate+0x283>
f0109ae4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ae7:	8b 40 10             	mov    0x10(%eax),%eax
f0109aea:	eb 05                	jmp    f0109af1 <env_page_ws_invalidate+0x288>
f0109aec:	b8 00 00 00 00       	mov    $0x0,%eax
f0109af1:	8b 55 08             	mov    0x8(%ebp),%edx
f0109af4:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0109afa:	8b 45 08             	mov    0x8(%ebp),%eax
f0109afd:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109b03:	85 c0                	test   %eax,%eax
f0109b05:	0f 85 98 fd ff ff    	jne    f01098a3 <env_page_ws_invalidate+0x3a>
f0109b0b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109b0f:	0f 85 8e fd ff ff    	jne    f01098a3 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f0109b15:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109b19:	0f 85 a4 02 00 00    	jne    f0109dc3 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f0109b1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109b26:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b29:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109b2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109b32:	e9 f6 00 00 00       	jmp    f0109c2d <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109b37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b3a:	8b 00                	mov    (%eax),%eax
f0109b3c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0109b3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109b42:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b47:	89 c2                	mov    %eax,%edx
f0109b49:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109b4c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0109b4f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109b52:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b57:	39 c2                	cmp    %eax,%edx
f0109b59:	0f 85 c2 00 00 00    	jne    f0109c21 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109b5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b62:	8b 10                	mov    (%eax),%edx
f0109b64:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b67:	8b 40 64             	mov    0x64(%eax),%eax
f0109b6a:	83 ec 08             	sub    $0x8,%esp
f0109b6d:	52                   	push   %edx
f0109b6e:	50                   	push   %eax
f0109b6f:	e8 6b ec ff ff       	call   f01087df <unmap_frame>
f0109b74:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f0109b77:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109b7b:	75 14                	jne    f0109b91 <env_page_ws_invalidate+0x328>
f0109b7d:	83 ec 04             	sub    $0x4,%esp
f0109b80:	68 83 57 12 f0       	push   $0xf0125783
f0109b85:	6a 46                	push   $0x46
f0109b87:	68 64 57 12 f0       	push   $0xf0125764
f0109b8c:	e8 a8 67 ff ff       	call   f0100339 <_panic>
f0109b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b94:	8b 40 10             	mov    0x10(%eax),%eax
f0109b97:	85 c0                	test   %eax,%eax
f0109b99:	74 11                	je     f0109bac <env_page_ws_invalidate+0x343>
f0109b9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b9e:	8b 40 10             	mov    0x10(%eax),%eax
f0109ba1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109ba4:	8b 52 14             	mov    0x14(%edx),%edx
f0109ba7:	89 50 14             	mov    %edx,0x14(%eax)
f0109baa:	eb 0f                	jmp    f0109bbb <env_page_ws_invalidate+0x352>
f0109bac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109baf:	8b 50 14             	mov    0x14(%eax),%edx
f0109bb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bb5:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f0109bbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bbe:	8b 40 14             	mov    0x14(%eax),%eax
f0109bc1:	85 c0                	test   %eax,%eax
f0109bc3:	74 11                	je     f0109bd6 <env_page_ws_invalidate+0x36d>
f0109bc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bc8:	8b 40 14             	mov    0x14(%eax),%eax
f0109bcb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109bce:	8b 52 10             	mov    0x10(%edx),%edx
f0109bd1:	89 50 10             	mov    %edx,0x10(%eax)
f0109bd4:	eb 0f                	jmp    f0109be5 <env_page_ws_invalidate+0x37c>
f0109bd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bd9:	8b 50 10             	mov    0x10(%eax),%edx
f0109bdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bdf:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f0109be5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109be8:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109bef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109bf2:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109bf9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bfc:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0109c02:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109c05:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c08:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

					kfree(ptr_WS_element);
f0109c0e:	83 ec 0c             	sub    $0xc,%esp
f0109c11:	ff 75 f0             	pushl  -0x10(%ebp)
f0109c14:	e8 30 f8 ff ff       	call   f0109449 <kfree>
f0109c19:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f0109c1c:	e9 a2 01 00 00       	jmp    f0109dc3 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109c21:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c24:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109c2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109c2d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109c31:	74 08                	je     f0109c3b <env_page_ws_invalidate+0x3d2>
f0109c33:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c36:	8b 40 10             	mov    0x10(%eax),%eax
f0109c39:	eb 05                	jmp    f0109c40 <env_page_ws_invalidate+0x3d7>
f0109c3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0109c40:	8b 55 08             	mov    0x8(%ebp),%edx
f0109c43:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0109c49:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c4c:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109c52:	85 c0                	test   %eax,%eax
f0109c54:	0f 85 dd fe ff ff    	jne    f0109b37 <env_page_ws_invalidate+0x2ce>
f0109c5a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109c5e:	0f 85 d3 fe ff ff    	jne    f0109b37 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f0109c64:	e9 5a 01 00 00       	jmp    f0109dc3 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109c69:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c6c:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0109c72:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109c75:	e9 10 01 00 00       	jmp    f0109d8a <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109c7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109c7d:	8b 00                	mov    (%eax),%eax
f0109c7f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109c82:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109c85:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109c8a:	89 c2                	mov    %eax,%edx
f0109c8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109c8f:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109c92:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109c95:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109c9a:	39 c2                	cmp    %eax,%edx
f0109c9c:	0f 85 dc 00 00 00    	jne    f0109d7e <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f0109ca2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109ca5:	8b 10                	mov    (%eax),%edx
f0109ca7:	8b 45 08             	mov    0x8(%ebp),%eax
f0109caa:	8b 40 64             	mov    0x64(%eax),%eax
f0109cad:	83 ec 08             	sub    $0x8,%esp
f0109cb0:	52                   	push   %edx
f0109cb1:	50                   	push   %eax
f0109cb2:	e8 28 eb ff ff       	call   f01087df <unmap_frame>
f0109cb7:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f0109cba:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cbd:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0109cc3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109cc6:	75 0f                	jne    f0109cd7 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f0109cc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109ccb:	8b 50 10             	mov    0x10(%eax),%edx
f0109cce:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cd1:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f0109cd7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109cdb:	75 14                	jne    f0109cf1 <env_page_ws_invalidate+0x488>
f0109cdd:	83 ec 04             	sub    $0x4,%esp
f0109ce0:	68 83 57 12 f0       	push   $0xf0125783
f0109ce5:	6a 5c                	push   $0x5c
f0109ce7:	68 64 57 12 f0       	push   $0xf0125764
f0109cec:	e8 48 66 ff ff       	call   f0100339 <_panic>
f0109cf1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109cf4:	8b 40 10             	mov    0x10(%eax),%eax
f0109cf7:	85 c0                	test   %eax,%eax
f0109cf9:	74 11                	je     f0109d0c <env_page_ws_invalidate+0x4a3>
f0109cfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109cfe:	8b 40 10             	mov    0x10(%eax),%eax
f0109d01:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109d04:	8b 52 14             	mov    0x14(%edx),%edx
f0109d07:	89 50 14             	mov    %edx,0x14(%eax)
f0109d0a:	eb 0f                	jmp    f0109d1b <env_page_ws_invalidate+0x4b2>
f0109d0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d0f:	8b 50 14             	mov    0x14(%eax),%edx
f0109d12:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d15:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f0109d1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d1e:	8b 40 14             	mov    0x14(%eax),%eax
f0109d21:	85 c0                	test   %eax,%eax
f0109d23:	74 11                	je     f0109d36 <env_page_ws_invalidate+0x4cd>
f0109d25:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d28:	8b 40 14             	mov    0x14(%eax),%eax
f0109d2b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109d2e:	8b 52 10             	mov    0x10(%edx),%edx
f0109d31:	89 50 10             	mov    %edx,0x10(%eax)
f0109d34:	eb 0f                	jmp    f0109d45 <env_page_ws_invalidate+0x4dc>
f0109d36:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d39:	8b 50 10             	mov    0x10(%eax),%edx
f0109d3c:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d3f:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0109d45:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d48:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109d4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d52:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109d59:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d5c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0109d62:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109d65:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d68:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f0109d6e:	83 ec 0c             	sub    $0xc,%esp
f0109d71:	ff 75 ec             	pushl  -0x14(%ebp)
f0109d74:	e8 d0 f6 ff ff       	call   f0109449 <kfree>
f0109d79:	83 c4 10             	add    $0x10,%esp

				break;
f0109d7c:	eb 45                	jmp    f0109dc3 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109d7e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109d81:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109d87:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109d8a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109d8e:	74 08                	je     f0109d98 <env_page_ws_invalidate+0x52f>
f0109d90:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d93:	8b 40 10             	mov    0x10(%eax),%eax
f0109d96:	eb 05                	jmp    f0109d9d <env_page_ws_invalidate+0x534>
f0109d98:	b8 00 00 00 00       	mov    $0x0,%eax
f0109d9d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109da0:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0109da6:	8b 45 08             	mov    0x8(%ebp),%eax
f0109da9:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109daf:	85 c0                	test   %eax,%eax
f0109db1:	0f 85 c3 fe ff ff    	jne    f0109c7a <env_page_ws_invalidate+0x411>
f0109db7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109dbb:	0f 85 b9 fe ff ff    	jne    f0109c7a <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f0109dc1:	eb 00                	jmp    f0109dc3 <env_page_ws_invalidate+0x55a>
f0109dc3:	90                   	nop
f0109dc4:	c9                   	leave  
f0109dc5:	c3                   	ret    

f0109dc6 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f0109dc6:	55                   	push   %ebp
f0109dc7:	89 e5                	mov    %esp,%ebp
f0109dc9:	53                   	push   %ebx
f0109dca:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109dcd:	83 ec 0c             	sub    $0xc,%esp
f0109dd0:	6a 02                	push   $0x2
f0109dd2:	e8 ec 51 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f0109dd7:	83 c4 10             	add    $0x10,%esp
f0109dda:	85 c0                	test   %eax,%eax
f0109ddc:	0f 84 fe 00 00 00    	je     f0109ee0 <env_page_ws_print+0x11a>
	{
		int i = 0;
f0109de2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0109de9:	83 ec 0c             	sub    $0xc,%esp
f0109dec:	68 c7 57 12 f0       	push   $0xf01257c7
f0109df1:	e8 95 71 ff ff       	call   f0100f8b <cprintf>
f0109df6:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109df9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109dfc:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109e02:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109e05:	eb 2c                	jmp    f0109e33 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109e07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e0a:	8b 10                	mov    (%eax),%edx
f0109e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109e0f:	8d 48 01             	lea    0x1(%eax),%ecx
f0109e12:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109e15:	83 ec 04             	sub    $0x4,%esp
f0109e18:	52                   	push   %edx
f0109e19:	50                   	push   %eax
f0109e1a:	68 e1 57 12 f0       	push   $0xf01257e1
f0109e1f:	e8 67 71 ff ff       	call   f0100f8b <cprintf>
f0109e24:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109e27:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e2a:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109e30:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109e33:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109e37:	74 08                	je     f0109e41 <env_page_ws_print+0x7b>
f0109e39:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e3c:	8b 40 10             	mov    0x10(%eax),%eax
f0109e3f:	eb 05                	jmp    f0109e46 <env_page_ws_print+0x80>
f0109e41:	b8 00 00 00 00       	mov    $0x0,%eax
f0109e46:	8b 55 08             	mov    0x8(%ebp),%edx
f0109e49:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0109e4f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e52:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109e58:	85 c0                	test   %eax,%eax
f0109e5a:	75 ab                	jne    f0109e07 <env_page_ws_print+0x41>
f0109e5c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109e60:	75 a5                	jne    f0109e07 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f0109e62:	83 ec 0c             	sub    $0xc,%esp
f0109e65:	68 e9 57 12 f0       	push   $0xf01257e9
f0109e6a:	e8 1c 71 ff ff       	call   f0100f8b <cprintf>
f0109e6f:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109e72:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e75:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0109e7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109e7e:	eb 2c                	jmp    f0109eac <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109e80:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e83:	8b 10                	mov    (%eax),%edx
f0109e85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109e88:	8d 48 01             	lea    0x1(%eax),%ecx
f0109e8b:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109e8e:	83 ec 04             	sub    $0x4,%esp
f0109e91:	52                   	push   %edx
f0109e92:	50                   	push   %eax
f0109e93:	68 e1 57 12 f0       	push   $0xf01257e1
f0109e98:	e8 ee 70 ff ff       	call   f0100f8b <cprintf>
f0109e9d:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109ea0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ea3:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109ea9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109eac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109eb0:	74 08                	je     f0109eba <env_page_ws_print+0xf4>
f0109eb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109eb5:	8b 40 10             	mov    0x10(%eax),%eax
f0109eb8:	eb 05                	jmp    f0109ebf <env_page_ws_print+0xf9>
f0109eba:	b8 00 00 00 00       	mov    $0x0,%eax
f0109ebf:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ec2:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0109ec8:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ecb:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109ed1:	85 c0                	test   %eax,%eax
f0109ed3:	75 ab                	jne    f0109e80 <env_page_ws_print+0xba>
f0109ed5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109ed9:	75 a5                	jne    f0109e80 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109edb:	e9 5a 01 00 00       	jmp    f010a03a <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f0109ee0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f0109ee7:	83 ec 0c             	sub    $0xc,%esp
f0109eea:	68 04 58 12 f0       	push   $0xf0125804
f0109eef:	e8 97 70 ff ff       	call   f0100f8b <cprintf>
f0109ef4:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f0109ef7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109efe:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f01:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0109f07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109f0a:	e9 d1 00 00 00       	jmp    f0109fe0 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f0109f0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f12:	8b 00                	mov    (%eax),%eax
f0109f14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f0109f17:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f1a:	8b 40 08             	mov    0x8(%eax),%eax
f0109f1d:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f0109f20:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f23:	8b 40 64             	mov    0x64(%eax),%eax
f0109f26:	83 ec 08             	sub    $0x8,%esp
f0109f29:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109f2c:	50                   	push   %eax
f0109f2d:	e8 5a f7 ff ff       	call   f010968c <pt_get_page_permissions>
f0109f32:	83 c4 10             	add    $0x10,%esp
f0109f35:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f0109f38:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f3b:	83 e0 40             	and    $0x40,%eax
f0109f3e:	85 c0                	test   %eax,%eax
f0109f40:	0f 95 c0             	setne  %al
f0109f43:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f0109f46:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f49:	83 e0 20             	and    $0x20,%eax
f0109f4c:	85 c0                	test   %eax,%eax
f0109f4e:	0f 95 c0             	setne  %al
f0109f51:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f0109f54:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109f57:	25 00 02 00 00       	and    $0x200,%eax
f0109f5c:	85 c0                	test   %eax,%eax
f0109f5e:	0f 95 c0             	setne  %al
f0109f61:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f0109f64:	83 ec 04             	sub    $0x4,%esp
f0109f67:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109f6a:	ff 75 ec             	pushl  -0x14(%ebp)
f0109f6d:	68 0e 58 12 f0       	push   $0xf012580e
f0109f72:	e8 14 70 ff ff       	call   f0100f8b <cprintf>
f0109f77:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f0109f7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109f7d:	8b 58 0c             	mov    0xc(%eax),%ebx
f0109f80:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f0109f84:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f0109f88:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f0109f8c:	83 ec 08             	sub    $0x8,%esp
f0109f8f:	53                   	push   %ebx
f0109f90:	ff 75 e0             	pushl  -0x20(%ebp)
f0109f93:	51                   	push   %ecx
f0109f94:	52                   	push   %edx
f0109f95:	50                   	push   %eax
f0109f96:	68 18 58 12 f0       	push   $0xf0125818
f0109f9b:	e8 eb 6f ff ff       	call   f0100f8b <cprintf>
f0109fa0:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f0109fa3:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fa6:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0109fac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109faf:	75 10                	jne    f0109fc1 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f0109fb1:	83 ec 0c             	sub    $0xc,%esp
f0109fb4:	68 5f 58 12 f0       	push   $0xf012585f
f0109fb9:	e8 cd 6f ff ff       	call   f0100f8b <cprintf>
f0109fbe:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109fc1:	83 ec 0c             	sub    $0xc,%esp
f0109fc4:	68 64 58 12 f0       	push   $0xf0125864
f0109fc9:	e8 bd 6f ff ff       	call   f0100f8b <cprintf>
f0109fce:	83 c4 10             	add    $0x10,%esp
			i++;
f0109fd1:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109fd4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fd7:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0109fdd:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109fe0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109fe4:	74 08                	je     f0109fee <env_page_ws_print+0x228>
f0109fe6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109fe9:	8b 40 10             	mov    0x10(%eax),%eax
f0109fec:	eb 05                	jmp    f0109ff3 <env_page_ws_print+0x22d>
f0109fee:	b8 00 00 00 00       	mov    $0x0,%eax
f0109ff3:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ff6:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0109ffc:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fff:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a005:	85 c0                	test   %eax,%eax
f010a007:	0f 85 02 ff ff ff    	jne    f0109f0f <env_page_ws_print+0x149>
f010a00d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a011:	0f 85 f8 fe ff ff    	jne    f0109f0f <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a017:	eb 13                	jmp    f010a02c <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a019:	83 ec 0c             	sub    $0xc,%esp
f010a01c:	68 66 58 12 f0       	push   $0xf0125866
f010a021:	e8 65 6f ff ff       	call   f0100f8b <cprintf>
f010a026:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a029:	ff 45 ec             	incl   -0x14(%ebp)
f010a02c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a02f:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a035:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a038:	77 df                	ja     f010a019 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a03a:	90                   	nop
f010a03b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a03e:	c9                   	leave  
f010a03f:	c3                   	ret    

f010a040 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a040:	55                   	push   %ebp
f010a041:	89 e5                	mov    %esp,%ebp
f010a043:	53                   	push   %ebx
f010a044:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a047:	83 ec 0c             	sub    $0xc,%esp
f010a04a:	68 78 58 12 f0       	push   $0xf0125878
f010a04f:	e8 37 6f ff ff       	call   f0100f8b <cprintf>
f010a054:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a057:	83 ec 0c             	sub    $0xc,%esp
f010a05a:	68 ad 58 12 f0       	push   $0xf01258ad
f010a05f:	e8 27 6f ff ff       	call   f0100f8b <cprintf>
f010a064:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a067:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a06e:	e9 16 01 00 00       	jmp    f010a189 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a073:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a076:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a079:	89 d0                	mov    %edx,%eax
f010a07b:	01 c0                	add    %eax,%eax
f010a07d:	01 d0                	add    %edx,%eax
f010a07f:	c1 e0 03             	shl    $0x3,%eax
f010a082:	01 c8                	add    %ecx,%eax
f010a084:	05 b0 00 00 00       	add    $0xb0,%eax
f010a089:	8a 00                	mov    (%eax),%al
f010a08b:	84 c0                	test   %al,%al
f010a08d:	74 43                	je     f010a0d2 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a08f:	83 ec 0c             	sub    $0xc,%esp
f010a092:	68 b8 58 12 f0       	push   $0xf01258b8
f010a097:	e8 ef 6e ff ff       	call   f0100f8b <cprintf>
f010a09c:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a09f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0a2:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a0a8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a0ab:	75 10                	jne    f010a0bd <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a0ad:	83 ec 0c             	sub    $0xc,%esp
f010a0b0:	68 c7 58 12 f0       	push   $0xf01258c7
f010a0b5:	e8 d1 6e ff ff       	call   f0100f8b <cprintf>
f010a0ba:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a0bd:	83 ec 0c             	sub    $0xc,%esp
f010a0c0:	68 64 58 12 f0       	push   $0xf0125864
f010a0c5:	e8 c1 6e ff ff       	call   f0100f8b <cprintf>
f010a0ca:	83 c4 10             	add    $0x10,%esp
			continue;
f010a0cd:	e9 b4 00 00 00       	jmp    f010a186 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a0d2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a0d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0d8:	89 d0                	mov    %edx,%eax
f010a0da:	01 c0                	add    %eax,%eax
f010a0dc:	01 d0                	add    %edx,%eax
f010a0de:	c1 e0 03             	shl    $0x3,%eax
f010a0e1:	01 c8                	add    %ecx,%eax
f010a0e3:	05 ac 00 00 00       	add    $0xac,%eax
f010a0e8:	8b 00                	mov    (%eax),%eax
f010a0ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a0ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a0f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0f3:	89 d0                	mov    %edx,%eax
f010a0f5:	01 c0                	add    %eax,%eax
f010a0f7:	01 d0                	add    %edx,%eax
f010a0f9:	c1 e0 03             	shl    $0x3,%eax
f010a0fc:	01 c8                	add    %ecx,%eax
f010a0fe:	05 ac 00 00 00       	add    $0xac,%eax
f010a103:	8b 00                	mov    (%eax),%eax
f010a105:	83 ec 04             	sub    $0x4,%esp
f010a108:	50                   	push   %eax
f010a109:	ff 75 f4             	pushl  -0xc(%ebp)
f010a10c:	68 cd 58 12 f0       	push   $0xf01258cd
f010a111:	e8 75 6e ff ff       	call   f0100f8b <cprintf>
f010a116:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a119:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a11c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a11f:	89 d0                	mov    %edx,%eax
f010a121:	01 c0                	add    %eax,%eax
f010a123:	01 d0                	add    %edx,%eax
f010a125:	c1 e0 03             	shl    $0x3,%eax
f010a128:	01 c8                	add    %ecx,%eax
f010a12a:	05 b4 00 00 00       	add    $0xb4,%eax
f010a12f:	8b 18                	mov    (%eax),%ebx
f010a131:	8b 45 08             	mov    0x8(%ebp),%eax
f010a134:	8b 40 64             	mov    0x64(%eax),%eax
f010a137:	83 ec 08             	sub    $0x8,%esp
f010a13a:	ff 75 f0             	pushl  -0x10(%ebp)
f010a13d:	50                   	push   %eax
f010a13e:	e8 25 f6 ff ff       	call   f0109768 <pd_is_table_used>
f010a143:	83 c4 10             	add    $0x10,%esp
f010a146:	83 ec 04             	sub    $0x4,%esp
f010a149:	53                   	push   %ebx
f010a14a:	50                   	push   %eax
f010a14b:	68 e4 58 12 f0       	push   $0xf01258e4
f010a150:	e8 36 6e ff ff       	call   f0100f8b <cprintf>
f010a155:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a158:	8b 45 08             	mov    0x8(%ebp),%eax
f010a15b:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010a161:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a164:	75 10                	jne    f010a176 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a166:	83 ec 0c             	sub    $0xc,%esp
f010a169:	68 5f 58 12 f0       	push   $0xf012585f
f010a16e:	e8 18 6e ff ff       	call   f0100f8b <cprintf>
f010a173:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a176:	83 ec 0c             	sub    $0xc,%esp
f010a179:	68 64 58 12 f0       	push   $0xf0125864
f010a17e:	e8 08 6e ff ff       	call   f0100f8b <cprintf>
f010a183:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a186:	ff 45 f4             	incl   -0xc(%ebp)
f010a189:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a18d:	0f 86 e0 fe ff ff    	jbe    f010a073 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a193:	90                   	nop
f010a194:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a197:	c9                   	leave  
f010a198:	c3                   	ret    

f010a199 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a199:	55                   	push   %ebp
f010a19a:	89 e5                	mov    %esp,%ebp
f010a19c:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a19f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a1a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a1ad:	eb 22                	jmp    f010a1d1 <env_table_ws_get_size+0x38>
f010a1af:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a1b2:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a1b5:	89 d0                	mov    %edx,%eax
f010a1b7:	01 c0                	add    %eax,%eax
f010a1b9:	01 d0                	add    %edx,%eax
f010a1bb:	c1 e0 03             	shl    $0x3,%eax
f010a1be:	01 c8                	add    %ecx,%eax
f010a1c0:	05 b0 00 00 00       	add    $0xb0,%eax
f010a1c5:	8a 00                	mov    (%eax),%al
f010a1c7:	84 c0                	test   %al,%al
f010a1c9:	75 03                	jne    f010a1ce <env_table_ws_get_size+0x35>
f010a1cb:	ff 45 f8             	incl   -0x8(%ebp)
f010a1ce:	ff 45 fc             	incl   -0x4(%ebp)
f010a1d1:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a1d5:	7e d8                	jle    f010a1af <env_table_ws_get_size+0x16>
	return counter;
f010a1d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a1da:	c9                   	leave  
f010a1db:	c3                   	ret    

f010a1dc <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a1dc:	55                   	push   %ebp
f010a1dd:	89 e5                	mov    %esp,%ebp
f010a1df:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a1e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a1e9:	eb 4e                	jmp    f010a239 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a1eb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a1ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a1f1:	89 d0                	mov    %edx,%eax
f010a1f3:	01 c0                	add    %eax,%eax
f010a1f5:	01 d0                	add    %edx,%eax
f010a1f7:	c1 e0 03             	shl    $0x3,%eax
f010a1fa:	01 c8                	add    %ecx,%eax
f010a1fc:	05 ac 00 00 00       	add    $0xac,%eax
f010a201:	8b 00                	mov    (%eax),%eax
f010a203:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a206:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a209:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a20e:	89 c2                	mov    %eax,%edx
f010a210:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a213:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a216:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a219:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a21e:	39 c2                	cmp    %eax,%edx
f010a220:	75 14                	jne    f010a236 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a225:	83 ec 08             	sub    $0x8,%esp
f010a228:	50                   	push   %eax
f010a229:	ff 75 08             	pushl  0x8(%ebp)
f010a22c:	e8 bc 00 00 00       	call   f010a2ed <env_table_ws_clear_entry>
f010a231:	83 c4 10             	add    $0x10,%esp
			break;
f010a234:	eb 09                	jmp    f010a23f <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a236:	ff 45 f4             	incl   -0xc(%ebp)
f010a239:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a23d:	7e ac                	jle    f010a1eb <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a23f:	90                   	nop
f010a240:	c9                   	leave  
f010a241:	c3                   	ret    

f010a242 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a242:	55                   	push   %ebp
f010a243:	89 e5                	mov    %esp,%ebp
f010a245:	53                   	push   %ebx
f010a246:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a249:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a24d:	76 19                	jbe    f010a268 <env_table_ws_set_entry+0x26>
f010a24f:	68 08 59 12 f0       	push   $0xf0125908
f010a254:	68 39 59 12 f0       	push   $0xf0125939
f010a259:	68 3f 01 00 00       	push   $0x13f
f010a25e:	68 64 57 12 f0       	push   $0xf0125764
f010a263:	e8 d1 60 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a268:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a26f:	76 19                	jbe    f010a28a <env_table_ws_set_entry+0x48>
f010a271:	68 50 59 12 f0       	push   $0xf0125950
f010a276:	68 39 59 12 f0       	push   $0xf0125939
f010a27b:	68 40 01 00 00       	push   $0x140
f010a280:	68 64 57 12 f0       	push   $0xf0125764
f010a285:	e8 af 60 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a28a:	8b 45 10             	mov    0x10(%ebp),%eax
f010a28d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a290:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a293:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a298:	89 c1                	mov    %eax,%ecx
f010a29a:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a29d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2a0:	89 d0                	mov    %edx,%eax
f010a2a2:	01 c0                	add    %eax,%eax
f010a2a4:	01 d0                	add    %edx,%eax
f010a2a6:	c1 e0 03             	shl    $0x3,%eax
f010a2a9:	01 d8                	add    %ebx,%eax
f010a2ab:	05 ac 00 00 00       	add    $0xac,%eax
f010a2b0:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a2b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a2b5:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2b8:	89 d0                	mov    %edx,%eax
f010a2ba:	01 c0                	add    %eax,%eax
f010a2bc:	01 d0                	add    %edx,%eax
f010a2be:	c1 e0 03             	shl    $0x3,%eax
f010a2c1:	01 c8                	add    %ecx,%eax
f010a2c3:	05 b0 00 00 00       	add    $0xb0,%eax
f010a2c8:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010a2cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a2ce:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2d1:	89 d0                	mov    %edx,%eax
f010a2d3:	01 c0                	add    %eax,%eax
f010a2d5:	01 d0                	add    %edx,%eax
f010a2d7:	c1 e0 03             	shl    $0x3,%eax
f010a2da:	01 c8                	add    %ecx,%eax
f010a2dc:	05 b4 00 00 00       	add    $0xb4,%eax
f010a2e1:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010a2e7:	90                   	nop
}
f010a2e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a2eb:	c9                   	leave  
f010a2ec:	c3                   	ret    

f010a2ed <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010a2ed:	55                   	push   %ebp
f010a2ee:	89 e5                	mov    %esp,%ebp
f010a2f0:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a2f3:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a2f7:	76 19                	jbe    f010a312 <env_table_ws_clear_entry+0x25>
f010a2f9:	68 08 59 12 f0       	push   $0xf0125908
f010a2fe:	68 39 59 12 f0       	push   $0xf0125939
f010a303:	68 4b 01 00 00       	push   $0x14b
f010a308:	68 64 57 12 f0       	push   $0xf0125764
f010a30d:	e8 27 60 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010a312:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a315:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a318:	89 d0                	mov    %edx,%eax
f010a31a:	01 c0                	add    %eax,%eax
f010a31c:	01 d0                	add    %edx,%eax
f010a31e:	c1 e0 03             	shl    $0x3,%eax
f010a321:	01 c8                	add    %ecx,%eax
f010a323:	05 ac 00 00 00       	add    $0xac,%eax
f010a328:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010a32e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a331:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a334:	89 d0                	mov    %edx,%eax
f010a336:	01 c0                	add    %eax,%eax
f010a338:	01 d0                	add    %edx,%eax
f010a33a:	c1 e0 03             	shl    $0x3,%eax
f010a33d:	01 c8                	add    %ecx,%eax
f010a33f:	05 b0 00 00 00       	add    $0xb0,%eax
f010a344:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010a347:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a34a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a34d:	89 d0                	mov    %edx,%eax
f010a34f:	01 c0                	add    %eax,%eax
f010a351:	01 d0                	add    %edx,%eax
f010a353:	c1 e0 03             	shl    $0x3,%eax
f010a356:	01 c8                	add    %ecx,%eax
f010a358:	05 b4 00 00 00       	add    $0xb4,%eax
f010a35d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010a363:	90                   	nop
f010a364:	c9                   	leave  
f010a365:	c3                   	ret    

f010a366 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010a366:	55                   	push   %ebp
f010a367:	89 e5                	mov    %esp,%ebp
f010a369:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a36c:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a370:	76 19                	jbe    f010a38b <env_table_ws_get_virtual_address+0x25>
f010a372:	68 08 59 12 f0       	push   $0xf0125908
f010a377:	68 39 59 12 f0       	push   $0xf0125939
f010a37c:	68 53 01 00 00       	push   $0x153
f010a381:	68 64 57 12 f0       	push   $0xf0125764
f010a386:	e8 ae 5f ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010a38b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a38e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a391:	89 d0                	mov    %edx,%eax
f010a393:	01 c0                	add    %eax,%eax
f010a395:	01 d0                	add    %edx,%eax
f010a397:	c1 e0 03             	shl    $0x3,%eax
f010a39a:	01 c8                	add    %ecx,%eax
f010a39c:	05 ac 00 00 00       	add    $0xac,%eax
f010a3a1:	8b 00                	mov    (%eax),%eax
f010a3a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a3a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a3a9:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010a3ae:	c9                   	leave  
f010a3af:	c3                   	ret    

f010a3b0 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010a3b0:	55                   	push   %ebp
f010a3b1:	89 e5                	mov    %esp,%ebp
f010a3b3:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a3b6:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a3ba:	76 19                	jbe    f010a3d5 <env_table_ws_get_time_stamp+0x25>
f010a3bc:	68 08 59 12 f0       	push   $0xf0125908
f010a3c1:	68 39 59 12 f0       	push   $0xf0125939
f010a3c6:	68 5a 01 00 00       	push   $0x15a
f010a3cb:	68 64 57 12 f0       	push   $0xf0125764
f010a3d0:	e8 64 5f ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010a3d5:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a3d8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a3db:	89 d0                	mov    %edx,%eax
f010a3dd:	01 c0                	add    %eax,%eax
f010a3df:	01 d0                	add    %edx,%eax
f010a3e1:	c1 e0 03             	shl    $0x3,%eax
f010a3e4:	01 c8                	add    %ecx,%eax
f010a3e6:	05 b4 00 00 00       	add    $0xb4,%eax
f010a3eb:	8b 00                	mov    (%eax),%eax
}
f010a3ed:	c9                   	leave  
f010a3ee:	c3                   	ret    

f010a3ef <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010a3ef:	55                   	push   %ebp
f010a3f0:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010a3f2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a3f5:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a3f8:	89 d0                	mov    %edx,%eax
f010a3fa:	01 c0                	add    %eax,%eax
f010a3fc:	01 d0                	add    %edx,%eax
f010a3fe:	c1 e0 03             	shl    $0x3,%eax
f010a401:	01 c8                	add    %ecx,%eax
f010a403:	05 b0 00 00 00       	add    $0xb0,%eax
f010a408:	8a 00                	mov    (%eax),%al
f010a40a:	0f b6 c0             	movzbl %al,%eax
}
f010a40d:	5d                   	pop    %ebp
f010a40e:	c3                   	ret    

f010a40f <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010a40f:	55                   	push   %ebp
f010a410:	89 e5                	mov    %esp,%ebp
f010a412:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010a415:	83 ec 04             	sub    $0x4,%esp
f010a418:	68 83 59 12 f0       	push   $0xf0125983
f010a41d:	68 6a 01 00 00       	push   $0x16a
f010a422:	68 64 57 12 f0       	push   $0xf0125764
f010a427:	e8 0d 5f ff ff       	call   f0100339 <_panic>

f010a42c <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010a42c:	55                   	push   %ebp
f010a42d:	89 e5                	mov    %esp,%ebp
f010a42f:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010a432:	83 ec 04             	sub    $0x4,%esp
f010a435:	68 83 59 12 f0       	push   $0xf0125983
f010a43a:	68 6f 01 00 00       	push   $0x16f
f010a43f:	68 64 57 12 f0       	push   $0xf0125764
f010a444:	e8 f0 5e ff ff       	call   f0100339 <_panic>

f010a449 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010a449:	55                   	push   %ebp
f010a44a:	89 e5                	mov    %esp,%ebp
f010a44c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010a44f:	83 ec 04             	sub    $0x4,%esp
f010a452:	68 94 59 12 f0       	push   $0xf0125994
f010a457:	6a 22                	push   $0x22
f010a459:	68 c2 59 12 f0       	push   $0xf01259c2
f010a45e:	e8 d6 5e ff ff       	call   f0100339 <_panic>

f010a463 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010a463:	55                   	push   %ebp
f010a464:	89 e5                	mov    %esp,%ebp
f010a466:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010a469:	83 ec 04             	sub    $0x4,%esp
f010a46c:	68 e0 59 12 f0       	push   $0xf01259e0
f010a471:	6a 35                	push   $0x35
f010a473:	68 c2 59 12 f0       	push   $0xf01259c2
f010a478:	e8 bc 5e ff ff       	call   f0100339 <_panic>

f010a47d <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010a47d:	55                   	push   %ebp
f010a47e:	89 e5                	mov    %esp,%ebp
f010a480:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010a483:	83 ec 04             	sub    $0x4,%esp
f010a486:	68 10 5a 12 f0       	push   $0xf0125a10
f010a48b:	6a 45                	push   $0x45
f010a48d:	68 c2 59 12 f0       	push   $0xf01259c2
f010a492:	e8 a2 5e ff ff       	call   f0100339 <_panic>

f010a497 <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010a497:	55                   	push   %ebp
f010a498:	89 e5                	mov    %esp,%ebp
f010a49a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010a49d:	83 ec 04             	sub    $0x4,%esp
f010a4a0:	68 3c 5a 12 f0       	push   $0xf0125a3c
f010a4a5:	6a 53                	push   $0x53
f010a4a7:	68 c2 59 12 f0       	push   $0xf01259c2
f010a4ac:	e8 88 5e ff ff       	call   f0100339 <_panic>

f010a4b1 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010a4b1:	55                   	push   %ebp
f010a4b2:	89 e5                	mov    %esp,%ebp
f010a4b4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010a4b7:	83 ec 04             	sub    $0x4,%esp
f010a4ba:	68 6c 5a 12 f0       	push   $0xf0125a6c
f010a4bf:	6a 5d                	push   $0x5d
f010a4c1:	68 c2 59 12 f0       	push   $0xf01259c2
f010a4c6:	e8 6e 5e ff ff       	call   f0100339 <_panic>

f010a4cb <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010a4cb:	55                   	push   %ebp
f010a4cc:	89 e5                	mov    %esp,%ebp
f010a4ce:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010a4d1:	83 ec 04             	sub    $0x4,%esp
f010a4d4:	68 a4 5a 12 f0       	push   $0xf0125aa4
f010a4d9:	6a 6a                	push   $0x6a
f010a4db:	68 c2 59 12 f0       	push   $0xf01259c2
f010a4e0:	e8 54 5e ff ff       	call   f0100339 <_panic>

f010a4e5 <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010a4e5:	55                   	push   %ebp
f010a4e6:	89 e5                	mov    %esp,%ebp
f010a4e8:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
//	return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010a4eb:	e8 98 0e 00 00       	call   f010b388 <get_cpu_proc>
f010a4f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(numOfPages > 0)
f010a4f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a4f7:	7e 61                	jle    f010a55a <sys_sbrk+0x75>
	{
		uint32 size = numOfPages * PAGE_SIZE;
f010a4f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4fc:	c1 e0 0c             	shl    $0xc,%eax
f010a4ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 prev_brk = env->heap_brk;
f010a502:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a505:	8b 40 7c             	mov    0x7c(%eax),%eax
f010a508:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(env->heap_brk + size > env->heap_hard_limit || LIST_SIZE(&MemFrameLists.free_frame_list) < 1) return (void *)-1;
f010a50b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a50e:	8b 50 7c             	mov    0x7c(%eax),%edx
f010a511:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a514:	01 c2                	add    %eax,%edx
f010a516:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a519:	8b 40 78             	mov    0x78(%eax),%eax
f010a51c:	39 c2                	cmp    %eax,%edx
f010a51e:	77 09                	ja     f010a529 <sys_sbrk+0x44>
f010a520:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f010a525:	85 c0                	test   %eax,%eax
f010a527:	75 07                	jne    f010a530 <sys_sbrk+0x4b>
f010a529:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010a52e:	eb 3d                	jmp    f010a56d <sys_sbrk+0x88>
		allocate_user_mem(env, prev_brk, size);
f010a530:	83 ec 04             	sub    $0x4,%esp
f010a533:	ff 75 f0             	pushl  -0x10(%ebp)
f010a536:	ff 75 ec             	pushl  -0x14(%ebp)
f010a539:	ff 75 f4             	pushl  -0xc(%ebp)
f010a53c:	e8 2e 00 00 00       	call   f010a56f <allocate_user_mem>
f010a541:	83 c4 10             	add    $0x10,%esp
		env->heap_brk += size;
f010a544:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a547:	8b 50 7c             	mov    0x7c(%eax),%edx
f010a54a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a54d:	01 c2                	add    %eax,%edx
f010a54f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a552:	89 50 7c             	mov    %edx,0x7c(%eax)
		return (void *)prev_brk;
f010a555:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a558:	eb 13                	jmp    f010a56d <sys_sbrk+0x88>

	}
	else if(numOfPages == 0)
f010a55a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a55e:	75 08                	jne    f010a568 <sys_sbrk+0x83>
	{
		return (void *) env->heap_brk;
f010a560:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a563:	8b 40 7c             	mov    0x7c(%eax),%eax
f010a566:	eb 05                	jmp    f010a56d <sys_sbrk+0x88>
	}

	return (void *)-1;
f010a568:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
f010a56d:	c9                   	leave  
f010a56e:	c3                   	ret    

f010a56f <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a56f:	55                   	push   %ebp
f010a570:	89 e5                	mov    %esp,%ebp
f010a572:	83 ec 28             	sub    $0x28,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010a575:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010a57c:	8b 55 10             	mov    0x10(%ebp),%edx
f010a57f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a582:	01 d0                	add    %edx,%eax
f010a584:	48                   	dec    %eax
f010a585:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a588:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a58b:	ba 00 00 00 00       	mov    $0x0,%edx
f010a590:	f7 75 f0             	divl   -0x10(%ebp)
f010a593:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a596:	29 d0                	sub    %edx,%eax
f010a598:	c1 e8 0c             	shr    $0xc,%eax
f010a59b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for(int i = 0; i < no_of_pages; i++){
f010a59e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a5a5:	eb 78                	jmp    f010a61f <allocate_user_mem+0xb0>
		uint32* ptr_table;
		int ret = get_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,&ptr_table);
f010a5a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5aa:	c1 e0 0c             	shl    $0xc,%eax
f010a5ad:	89 c2                	mov    %eax,%edx
f010a5af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5b2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010a5b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5b8:	8b 40 64             	mov    0x64(%eax),%eax
f010a5bb:	83 ec 04             	sub    $0x4,%esp
f010a5be:	8d 55 e0             	lea    -0x20(%ebp),%edx
f010a5c1:	52                   	push   %edx
f010a5c2:	51                   	push   %ecx
f010a5c3:	50                   	push   %eax
f010a5c4:	e8 26 de ff ff       	call   f01083ef <get_page_table>
f010a5c9:	83 c4 10             	add    $0x10,%esp
f010a5cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(ret == TABLE_NOT_EXIST)
f010a5cf:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f010a5d3:	75 23                	jne    f010a5f8 <allocate_user_mem+0x89>
		{
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
f010a5d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5d8:	c1 e0 0c             	shl    $0xc,%eax
f010a5db:	89 c2                	mov    %eax,%edx
f010a5dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5e0:	01 c2                	add    %eax,%edx
f010a5e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e5:	8b 40 64             	mov    0x64(%eax),%eax
f010a5e8:	83 ec 08             	sub    $0x8,%esp
f010a5eb:	52                   	push   %edx
f010a5ec:	50                   	push   %eax
f010a5ed:	e8 53 df ff ff       	call   f0108545 <create_page_table>
f010a5f2:	83 c4 10             	add    $0x10,%esp
f010a5f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
f010a5f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5fb:	c1 e0 0c             	shl    $0xc,%eax
f010a5fe:	89 c2                	mov    %eax,%edx
f010a600:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a603:	01 c2                	add    %eax,%edx
f010a605:	8b 45 08             	mov    0x8(%ebp),%eax
f010a608:	8b 40 64             	mov    0x64(%eax),%eax
f010a60b:	6a 00                	push   $0x0
f010a60d:	68 00 02 00 00       	push   $0x200
f010a612:	52                   	push   %edx
f010a613:	50                   	push   %eax
f010a614:	e8 af ef ff ff       	call   f01095c8 <pt_set_page_permissions>
f010a619:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
//	panic("allocate_user_mem() is not implemented yet...!!");
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for(int i = 0; i < no_of_pages; i++){
f010a61c:	ff 45 f4             	incl   -0xc(%ebp)
f010a61f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a622:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a625:	72 80                	jb     f010a5a7 <allocate_user_mem+0x38>
			ptr_table = create_page_table(e->env_page_directory,(i*PAGE_SIZE)+virtual_address);
		}
		pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,PERM_MARKED,0);
	}

}
f010a627:	90                   	nop
f010a628:	c9                   	leave  
f010a629:	c3                   	ret    

f010a62a <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a62a:	55                   	push   %ebp
f010a62b:	89 e5                	mov    %esp,%ebp
f010a62d:	83 ec 28             	sub    $0x28,%esp

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010a630:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010a637:	8b 55 10             	mov    0x10(%ebp),%edx
f010a63a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a63d:	01 d0                	add    %edx,%eax
f010a63f:	48                   	dec    %eax
f010a640:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a643:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a646:	ba 00 00 00 00       	mov    $0x0,%edx
f010a64b:	f7 75 f0             	divl   -0x10(%ebp)
f010a64e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a651:	29 d0                	sub    %edx,%eax
f010a653:	c1 e8 0c             	shr    $0xc,%eax
f010a656:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(int i = 0; i < no_of_pages; i++){
f010a659:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a660:	e9 86 00 00 00       	jmp    f010a6eb <free_user_mem+0xc1>
			pt_set_page_permissions(e->env_page_directory,(i*PAGE_SIZE)+virtual_address,0,PERM_MARKED);
f010a665:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a668:	c1 e0 0c             	shl    $0xc,%eax
f010a66b:	89 c2                	mov    %eax,%edx
f010a66d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a670:	01 c2                	add    %eax,%edx
f010a672:	8b 45 08             	mov    0x8(%ebp),%eax
f010a675:	8b 40 64             	mov    0x64(%eax),%eax
f010a678:	68 00 02 00 00       	push   $0x200
f010a67d:	6a 00                	push   $0x0
f010a67f:	52                   	push   %edx
f010a680:	50                   	push   %eax
f010a681:	e8 42 ef ff ff       	call   f01095c8 <pt_set_page_permissions>
f010a686:	83 c4 10             	add    $0x10,%esp
			int ret = pf_read_env_page(e,(void*)((i*PAGE_SIZE)+virtual_address));
f010a689:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a68c:	c1 e0 0c             	shl    $0xc,%eax
f010a68f:	89 c2                	mov    %eax,%edx
f010a691:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a694:	01 d0                	add    %edx,%eax
f010a696:	83 ec 08             	sub    $0x8,%esp
f010a699:	50                   	push   %eax
f010a69a:	ff 75 08             	pushl  0x8(%ebp)
f010a69d:	e8 3f 9e ff ff       	call   f01044e1 <pf_read_env_page>
f010a6a2:	83 c4 10             	add    $0x10,%esp
f010a6a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
f010a6a8:	83 7d e4 f7          	cmpl   $0xfffffff7,-0x1c(%ebp)
f010a6ac:	75 1e                	jne    f010a6cc <free_user_mem+0xa2>
f010a6ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6b1:	c1 e0 0c             	shl    $0xc,%eax
f010a6b4:	89 c2                	mov    %eax,%edx
f010a6b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a6b9:	01 d0                	add    %edx,%eax
f010a6bb:	83 ec 08             	sub    $0x8,%esp
f010a6be:	50                   	push   %eax
f010a6bf:	ff 75 08             	pushl  0x8(%ebp)
f010a6c2:	e8 a2 f1 ff ff       	call   f0109869 <env_page_ws_invalidate>
f010a6c7:	83 c4 10             	add    $0x10,%esp
f010a6ca:	eb 1c                	jmp    f010a6e8 <free_user_mem+0xbe>
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);
f010a6cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6cf:	c1 e0 0c             	shl    $0xc,%eax
f010a6d2:	89 c2                	mov    %eax,%edx
f010a6d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a6d7:	01 d0                	add    %edx,%eax
f010a6d9:	83 ec 08             	sub    $0x8,%esp
f010a6dc:	50                   	push   %eax
f010a6dd:	ff 75 08             	pushl  0x8(%ebp)
f010a6e0:	e8 bf 9e ff ff       	call   f01045a4 <pf_remove_env_page>
f010a6e5:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
//	panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	uint32 no_of_pages = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
		for(int i = 0; i < no_of_pages; i++){
f010a6e8:	ff 45 f4             	incl   -0xc(%ebp)
f010a6eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6ee:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a6f1:	0f 82 6e ff ff ff    	jb     f010a665 <free_user_mem+0x3b>
			if(ret == E_PAGE_NOT_EXIST_IN_PF) env_page_ws_invalidate(e, (i*PAGE_SIZE)+virtual_address);
			else pf_remove_env_page(e, (i*PAGE_SIZE)+virtual_address);


		}
}
f010a6f7:	90                   	nop
f010a6f8:	c9                   	leave  
f010a6f9:	c3                   	ret    

f010a6fa <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a6fa:	55                   	push   %ebp
f010a6fb:	89 e5                	mov    %esp,%ebp
f010a6fd:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010a700:	83 ec 04             	sub    $0x4,%esp
f010a703:	68 dc 5a 12 f0       	push   $0xf0125adc
f010a708:	68 e0 00 00 00       	push   $0xe0
f010a70d:	68 c2 59 12 f0       	push   $0xf01259c2
f010a712:	e8 22 5c ff ff       	call   f0100339 <_panic>

f010a717 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010a717:	55                   	push   %ebp
f010a718:	89 e5                	mov    %esp,%ebp
f010a71a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010a71d:	83 ec 04             	sub    $0x4,%esp
f010a720:	68 1c 5b 12 f0       	push   $0xf0125b1c
f010a725:	68 ea 00 00 00       	push   $0xea
f010a72a:	68 c2 59 12 f0       	push   $0xf01259c2
f010a72f:	e8 05 5c ff ff       	call   f0100339 <_panic>

f010a734 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010a734:	55                   	push   %ebp
f010a735:	89 e5                	mov    %esp,%ebp
f010a737:	56                   	push   %esi
f010a738:	53                   	push   %ebx
f010a739:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010a73c:	c7 45 f4 c9 02 00 00 	movl   $0x2c9,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010a743:	e9 b0 01 00 00       	jmp    f010a8f8 <env_init+0x1c4>
	{
		envs[iEnv].env_status = ENV_FREE;
f010a748:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a74e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a751:	89 d0                	mov    %edx,%eax
f010a753:	c1 e0 03             	shl    $0x3,%eax
f010a756:	01 d0                	add    %edx,%eax
f010a758:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a75f:	01 d8                	add    %ebx,%eax
f010a761:	01 c0                	add    %eax,%eax
f010a763:	01 d0                	add    %edx,%eax
f010a765:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a76c:	01 d8                	add    %ebx,%eax
f010a76e:	01 d0                	add    %edx,%eax
f010a770:	01 c8                	add    %ecx,%eax
f010a772:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010a779:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a77f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a782:	89 d0                	mov    %edx,%eax
f010a784:	c1 e0 03             	shl    $0x3,%eax
f010a787:	01 d0                	add    %edx,%eax
f010a789:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a790:	01 d8                	add    %ebx,%eax
f010a792:	01 c0                	add    %eax,%eax
f010a794:	01 d0                	add    %edx,%eax
f010a796:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a79d:	01 d8                	add    %ebx,%eax
f010a79f:	01 d0                	add    %edx,%eax
f010a7a1:	01 c8                	add    %ecx,%eax
f010a7a3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010a7aa:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a7b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7b3:	89 d0                	mov    %edx,%eax
f010a7b5:	c1 e0 03             	shl    $0x3,%eax
f010a7b8:	01 d0                	add    %edx,%eax
f010a7ba:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7c1:	01 d8                	add    %ebx,%eax
f010a7c3:	01 c0                	add    %eax,%eax
f010a7c5:	01 d0                	add    %edx,%eax
f010a7c7:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a7ce:	01 d8                	add    %ebx,%eax
f010a7d0:	01 d0                	add    %edx,%eax
f010a7d2:	01 c8                	add    %ecx,%eax
f010a7d4:	85 c0                	test   %eax,%eax
f010a7d6:	75 14                	jne    f010a7ec <env_init+0xb8>
f010a7d8:	83 ec 04             	sub    $0x4,%esp
f010a7db:	68 48 5b 12 f0       	push   $0xf0125b48
f010a7e0:	6a 65                	push   $0x65
f010a7e2:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010a7e7:	e8 4d 5b ff ff       	call   f0100339 <_panic>
f010a7ec:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a7f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7f5:	89 d0                	mov    %edx,%eax
f010a7f7:	c1 e0 03             	shl    $0x3,%eax
f010a7fa:	01 d0                	add    %edx,%eax
f010a7fc:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a803:	01 d8                	add    %ebx,%eax
f010a805:	01 c0                	add    %eax,%eax
f010a807:	01 d0                	add    %edx,%eax
f010a809:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a810:	01 d8                	add    %ebx,%eax
f010a812:	01 d0                	add    %edx,%eax
f010a814:	01 c8                	add    %ecx,%eax
f010a816:	8b 15 d4 47 69 f0    	mov    0xf06947d4,%edx
f010a81c:	89 50 08             	mov    %edx,0x8(%eax)
f010a81f:	8b 40 08             	mov    0x8(%eax),%eax
f010a822:	85 c0                	test   %eax,%eax
f010a824:	74 35                	je     f010a85b <env_init+0x127>
f010a826:	8b 0d d4 47 69 f0    	mov    0xf06947d4,%ecx
f010a82c:	8b 1d d0 47 69 f0    	mov    0xf06947d0,%ebx
f010a832:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a835:	89 d0                	mov    %edx,%eax
f010a837:	c1 e0 03             	shl    $0x3,%eax
f010a83a:	01 d0                	add    %edx,%eax
f010a83c:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010a843:	01 f0                	add    %esi,%eax
f010a845:	01 c0                	add    %eax,%eax
f010a847:	01 d0                	add    %edx,%eax
f010a849:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f010a850:	01 f0                	add    %esi,%eax
f010a852:	01 d0                	add    %edx,%eax
f010a854:	01 d8                	add    %ebx,%eax
f010a856:	89 41 0c             	mov    %eax,0xc(%ecx)
f010a859:	eb 2f                	jmp    f010a88a <env_init+0x156>
f010a85b:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a861:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a864:	89 d0                	mov    %edx,%eax
f010a866:	c1 e0 03             	shl    $0x3,%eax
f010a869:	01 d0                	add    %edx,%eax
f010a86b:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a872:	01 d8                	add    %ebx,%eax
f010a874:	01 c0                	add    %eax,%eax
f010a876:	01 d0                	add    %edx,%eax
f010a878:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a87f:	01 d8                	add    %ebx,%eax
f010a881:	01 d0                	add    %edx,%eax
f010a883:	01 c8                	add    %ecx,%eax
f010a885:	a3 d8 47 69 f0       	mov    %eax,0xf06947d8
f010a88a:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a890:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a893:	89 d0                	mov    %edx,%eax
f010a895:	c1 e0 03             	shl    $0x3,%eax
f010a898:	01 d0                	add    %edx,%eax
f010a89a:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8a1:	01 d8                	add    %ebx,%eax
f010a8a3:	01 c0                	add    %eax,%eax
f010a8a5:	01 d0                	add    %edx,%eax
f010a8a7:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8ae:	01 d8                	add    %ebx,%eax
f010a8b0:	01 d0                	add    %edx,%eax
f010a8b2:	01 c8                	add    %ecx,%eax
f010a8b4:	a3 d4 47 69 f0       	mov    %eax,0xf06947d4
f010a8b9:	8b 0d d0 47 69 f0    	mov    0xf06947d0,%ecx
f010a8bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a8c2:	89 d0                	mov    %edx,%eax
f010a8c4:	c1 e0 03             	shl    $0x3,%eax
f010a8c7:	01 d0                	add    %edx,%eax
f010a8c9:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8d0:	01 d8                	add    %ebx,%eax
f010a8d2:	01 c0                	add    %eax,%eax
f010a8d4:	01 d0                	add    %edx,%eax
f010a8d6:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010a8dd:	01 d8                	add    %ebx,%eax
f010a8df:	01 d0                	add    %edx,%eax
f010a8e1:	01 c8                	add    %ecx,%eax
f010a8e3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010a8ea:	a1 e0 47 69 f0       	mov    0xf06947e0,%eax
f010a8ef:	40                   	inc    %eax
f010a8f0:	a3 e0 47 69 f0       	mov    %eax,0xf06947e0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010a8f5:	ff 4d f4             	decl   -0xc(%ebp)
f010a8f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a8fc:	0f 89 46 fe ff ff    	jns    f010a748 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010a902:	90                   	nop
f010a903:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010a906:	5b                   	pop    %ebx
f010a907:	5e                   	pop    %esi
f010a908:	5d                   	pop    %ebp
f010a909:	c3                   	ret    

f010a90a <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010a90a:	55                   	push   %ebp
f010a90b:	89 e5                	mov    %esp,%ebp
f010a90d:	57                   	push   %edi
f010a90e:	56                   	push   %esi
f010a90f:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010a915:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010a91c:	83 ec 0c             	sub    $0xc,%esp
f010a91f:	ff 75 08             	pushl  0x8(%ebp)
f010a922:	e8 b8 1e 00 00       	call   f010c7df <get_user_program_info>
f010a927:	83 c4 10             	add    $0x10,%esp
f010a92a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010a92d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010a931:	75 0a                	jne    f010a93d <env_create+0x33>
	{
		return NULL;
f010a933:	b8 00 00 00 00       	mov    $0x0,%eax
f010a938:	e9 aa 09 00 00       	jmp    f010b2e7 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010a93d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a940:	8b 40 08             	mov    0x8(%eax),%eax
f010a943:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010a946:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010a94d:	00 00 00 
	if(allocate_environment(&e) < 0)
f010a950:	83 ec 0c             	sub    $0xc,%esp
f010a953:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010a959:	50                   	push   %eax
f010a95a:	e8 96 0e 00 00       	call   f010b7f5 <allocate_environment>
f010a95f:	83 c4 10             	add    $0x10,%esp
f010a962:	85 c0                	test   %eax,%eax
f010a964:	79 0a                	jns    f010a970 <env_create+0x66>
	{
		return NULL;
f010a966:	b8 00 00 00 00       	mov    $0x0,%eax
f010a96b:	e9 77 09 00 00       	jmp    f010b2e7 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010a970:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a973:	8b 00                	mov    (%eax),%eax
f010a975:	83 ec 0c             	sub    $0xc,%esp
f010a978:	50                   	push   %eax
f010a979:	e8 46 4c 01 00       	call   f011f5c4 <strlen>
f010a97e:	83 c4 10             	add    $0x10,%esp
f010a981:	83 f8 3f             	cmp    $0x3f,%eax
f010a984:	7f 1d                	jg     f010a9a3 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010a986:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a989:	8b 00                	mov    (%eax),%eax
f010a98b:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a991:	83 c2 20             	add    $0x20,%edx
f010a994:	83 ec 08             	sub    $0x8,%esp
f010a997:	50                   	push   %eax
f010a998:	52                   	push   %edx
f010a999:	e8 75 4c 01 00       	call   f011f613 <strcpy>
f010a99e:	83 c4 10             	add    $0x10,%esp
f010a9a1:	eb 1d                	jmp    f010a9c0 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010a9a3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a9a6:	8b 00                	mov    (%eax),%eax
f010a9a8:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a9ae:	83 c2 20             	add    $0x20,%edx
f010a9b1:	83 ec 04             	sub    $0x4,%esp
f010a9b4:	6a 3f                	push   $0x3f
f010a9b6:	50                   	push   %eax
f010a9b7:	52                   	push   %edx
f010a9b8:	e8 84 4c 01 00       	call   f011f641 <strncpy>
f010a9bd:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010a9c0:	e8 fc 13 00 00       	call   f010bdc1 <create_user_directory>
f010a9c5:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010a9c8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a9cb:	83 ec 0c             	sub    $0xc,%esp
f010a9ce:	50                   	push   %eax
f010a9cf:	e8 5b eb ff ff       	call   f010952f <kheap_physical_address>
f010a9d4:	83 c4 10             	add    $0x10,%esp
f010a9d7:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010a9da:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9e0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9e3:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a9e9:	83 ec 0c             	sub    $0xc,%esp
f010a9ec:	6a 02                	push   $0x2
f010a9ee:	e8 d0 45 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f010a9f3:	83 c4 10             	add    $0x10,%esp
f010a9f6:	85 c0                	test   %eax,%eax
f010a9f8:	74 21                	je     f010aa1b <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010a9fa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa00:	8b 55 10             	mov    0x10(%ebp),%edx
f010aa03:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010aa09:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa0f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa12:	2b 55 10             	sub    0x10(%ebp),%edx
f010aa15:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010aa1b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010aa1f:	75 12                	jne    f010aa33 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010aa21:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa27:	c7 80 8c 05 00 00 0a 	movl   $0xa,0x58c(%eax)
f010aa2e:	00 00 00 
f010aa31:	eb 0f                	jmp    f010aa42 <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010aa33:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa39:	8b 55 14             	mov    0x14(%ebp),%edx
f010aa3c:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010aa42:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa48:	83 ec 04             	sub    $0x4,%esp
f010aa4b:	ff 75 bc             	pushl  -0x44(%ebp)
f010aa4e:	ff 75 c0             	pushl  -0x40(%ebp)
f010aa51:	50                   	push   %eax
f010aa52:	e8 c8 14 00 00       	call   f010bf1f <initialize_environment>
f010aa57:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010aa5a:	e8 70 c7 ff ff       	call   f01071cf <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010aa5f:	0f 20 d8             	mov    %cr3,%eax
f010aa62:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010aa65:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010aa68:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010aa6b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa71:	8b 40 68             	mov    0x68(%eax),%eax
f010aa74:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010aa7a:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010aa80:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010aa83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010aa8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010aa91:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa97:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010aa9d:	48                   	dec    %eax
f010aa9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010aaa1:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010aaa8:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010aaab:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010aab1:	83 ec 08             	sub    $0x8,%esp
f010aab4:	ff 75 c8             	pushl  -0x38(%ebp)
f010aab7:	50                   	push   %eax
f010aab8:	e8 34 1a 00 00       	call   f010c4f1 <PROGRAM_SEGMENT_FIRST>
f010aabd:	83 c4 0c             	add    $0xc,%esp
f010aac0:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010aac6:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010aacc:	b9 05 00 00 00       	mov    $0x5,%ecx
f010aad1:	89 c7                	mov    %eax,%edi
f010aad3:	89 d6                	mov    %edx,%esi
f010aad5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010aad7:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010aadd:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010aae0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010aae3:	8b 40 10             	mov    0x10(%eax),%eax
f010aae6:	83 f8 ff             	cmp    $0xffffffff,%eax
f010aae9:	75 07                	jne    f010aaf2 <env_create+0x1e8>
f010aaeb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010aaf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010aaf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aaf8:	e9 fa 02 00 00       	jmp    f010adf7 <env_create+0x4ed>
		{
			segment_counter++;
f010aafd:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010ab00:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010ab07:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010ab0a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab10:	83 ec 0c             	sub    $0xc,%esp
f010ab13:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010ab19:	52                   	push   %edx
f010ab1a:	ff 75 ec             	pushl  -0x14(%ebp)
f010ab1d:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010ab23:	52                   	push   %edx
f010ab24:	ff 75 f4             	pushl  -0xc(%ebp)
f010ab27:	50                   	push   %eax
f010ab28:	e8 86 0d 00 00       	call   f010b8b3 <program_segment_alloc_map_copy_workingset>
f010ab2d:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010ab30:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010ab36:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010ab39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab3c:	8b 00                	mov    (%eax),%eax
f010ab3e:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010ab41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ab44:	8b 40 0c             	mov    0xc(%eax),%eax
f010ab47:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010ab4a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ab4d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010ab50:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010ab53:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ab58:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010ab5b:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010ab62:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010ab65:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010ab68:	01 d0                	add    %edx,%eax
f010ab6a:	48                   	dec    %eax
f010ab6b:	89 45 98             	mov    %eax,-0x68(%ebp)
f010ab6e:	8b 45 98             	mov    -0x68(%ebp),%eax
f010ab71:	ba 00 00 00 00       	mov    $0x0,%edx
f010ab76:	f7 75 9c             	divl   -0x64(%ebp)
f010ab79:	8b 45 98             	mov    -0x68(%ebp),%eax
f010ab7c:	29 d0                	sub    %edx,%eax
f010ab7e:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010ab81:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ab84:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010ab87:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010ab8a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010ab8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010ab90:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f010ab96:	8b 45 90             	mov    -0x70(%ebp),%eax
f010ab99:	01 d0                	add    %edx,%eax
f010ab9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010ab9e:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010aba2:	74 73                	je     f010ac17 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010aba4:	a1 0c da 6b f0       	mov    0xf06bda0c,%eax
f010aba9:	83 ec 04             	sub    $0x4,%esp
f010abac:	68 00 10 00 00       	push   $0x1000
f010abb1:	6a 00                	push   $0x0
f010abb3:	50                   	push   %eax
f010abb4:	e8 f9 4b 01 00       	call   f011f7b2 <memset>
f010abb9:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010abbc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010abbf:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010abc2:	eb 13                	jmp    f010abd7 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010abc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010abc7:	8a 10                	mov    (%eax),%dl
f010abc9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010abcc:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010abce:	ff 45 dc             	incl   -0x24(%ebp)
f010abd1:	ff 45 e4             	incl   -0x1c(%ebp)
f010abd4:	ff 45 e0             	incl   -0x20(%ebp)
f010abd7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010abda:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010abdd:	72 e5                	jb     f010abc4 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010abdf:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f010abe5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010abeb:	83 ec 04             	sub    $0x4,%esp
f010abee:	52                   	push   %edx
f010abef:	ff 75 a0             	pushl  -0x60(%ebp)
f010abf2:	50                   	push   %eax
f010abf3:	e8 39 96 ff ff       	call   f0104231 <pf_add_env_page>
f010abf8:	83 c4 10             	add    $0x10,%esp
f010abfb:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010abfe:	75 17                	jne    f010ac17 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ac00:	83 ec 04             	sub    $0x4,%esp
f010ac03:	68 88 5b 12 f0       	push   $0xf0125b88
f010ac08:	68 f5 00 00 00       	push   $0xf5
f010ac0d:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010ac12:	e8 22 57 ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010ac17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac1a:	8b 50 04             	mov    0x4(%eax),%edx
f010ac1d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ac20:	01 d0                	add    %edx,%eax
f010ac22:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010ac25:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010ac28:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ac2d:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010ac30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac33:	8b 50 04             	mov    0x4(%eax),%edx
f010ac36:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ac39:	01 d0                	add    %edx,%eax
f010ac3b:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010ac3e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010ac41:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010ac44:	eb 43                	jmp    f010ac89 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010ac46:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ac49:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ac4f:	83 ec 04             	sub    $0x4,%esp
f010ac52:	ff 75 e4             	pushl  -0x1c(%ebp)
f010ac55:	52                   	push   %edx
f010ac56:	50                   	push   %eax
f010ac57:	e8 d5 95 ff ff       	call   f0104231 <pf_add_env_page>
f010ac5c:	83 c4 10             	add    $0x10,%esp
f010ac5f:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ac62:	75 17                	jne    f010ac7b <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ac64:	83 ec 04             	sub    $0x4,%esp
f010ac67:	68 88 5b 12 f0       	push   $0xf0125b88
f010ac6c:	68 02 01 00 00       	push   $0x102
f010ac71:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010ac76:	e8 be 56 ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010ac7b:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010ac82:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010ac89:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ac8c:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010ac8f:	72 b5                	jb     f010ac46 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010ac91:	a1 0c da 6b f0       	mov    0xf06bda0c,%eax
f010ac96:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010ac99:	83 ec 04             	sub    $0x4,%esp
f010ac9c:	68 00 10 00 00       	push   $0x1000
f010aca1:	6a 00                	push   $0x0
f010aca3:	ff 75 e0             	pushl  -0x20(%ebp)
f010aca6:	e8 07 4b 01 00       	call   f011f7b2 <memset>
f010acab:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010acae:	8b 45 88             	mov    -0x78(%ebp),%eax
f010acb1:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010acb4:	eb 13                	jmp    f010acc9 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010acb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010acb9:	8a 10                	mov    (%eax),%dl
f010acbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010acbe:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010acc0:	ff 45 dc             	incl   -0x24(%ebp)
f010acc3:	ff 45 e4             	incl   -0x1c(%ebp)
f010acc6:	ff 45 e0             	incl   -0x20(%ebp)
f010acc9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010accc:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010accf:	72 e5                	jb     f010acb6 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010acd1:	8b 15 0c da 6b f0    	mov    0xf06bda0c,%edx
f010acd7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010acdd:	83 ec 04             	sub    $0x4,%esp
f010ace0:	52                   	push   %edx
f010ace1:	ff 75 88             	pushl  -0x78(%ebp)
f010ace4:	50                   	push   %eax
f010ace5:	e8 47 95 ff ff       	call   f0104231 <pf_add_env_page>
f010acea:	83 c4 10             	add    $0x10,%esp
f010aced:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010acf0:	75 17                	jne    f010ad09 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010acf2:	83 ec 04             	sub    $0x4,%esp
f010acf5:	68 88 5b 12 f0       	push   $0xf0125b88
f010acfa:	68 11 01 00 00       	push   $0x111
f010acff:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010ad04:	e8 30 56 ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010ad09:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010ad10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad13:	8b 50 04             	mov    0x4(%eax),%edx
f010ad16:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ad19:	01 c2                	add    %eax,%edx
f010ad1b:	8b 45 80             	mov    -0x80(%ebp),%eax
f010ad1e:	01 d0                	add    %edx,%eax
f010ad20:	48                   	dec    %eax
f010ad21:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010ad27:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010ad2d:	ba 00 00 00 00       	mov    $0x0,%edx
f010ad32:	f7 75 80             	divl   -0x80(%ebp)
f010ad35:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010ad3b:	29 d0                	sub    %edx,%eax
f010ad3d:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010ad40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad43:	8b 50 08             	mov    0x8(%eax),%edx
f010ad46:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010ad49:	01 d0                	add    %edx,%eax
f010ad4b:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010ad4e:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010ad54:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010ad5b:	eb 41                	jmp    f010ad9e <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010ad5d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ad63:	83 ec 04             	sub    $0x4,%esp
f010ad66:	6a 01                	push   $0x1
f010ad68:	ff 75 d8             	pushl  -0x28(%ebp)
f010ad6b:	50                   	push   %eax
f010ad6c:	e8 8f 93 ff ff       	call   f0104100 <pf_add_empty_env_page>
f010ad71:	83 c4 10             	add    $0x10,%esp
f010ad74:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010ad77:	75 17                	jne    f010ad90 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010ad79:	83 ec 04             	sub    $0x4,%esp
f010ad7c:	68 88 5b 12 f0       	push   $0xf0125b88
f010ad81:	68 1e 01 00 00       	push   $0x11e
f010ad86:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010ad8b:	e8 a9 55 ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010ad90:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010ad97:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010ad9e:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010ada5:	10 00 00 
f010ada8:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010adae:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010adb4:	01 d0                	add    %edx,%eax
f010adb6:	48                   	dec    %eax
f010adb7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010adbd:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010adc3:	ba 00 00 00 00       	mov    $0x0,%edx
f010adc8:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010adce:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010add4:	29 d0                	sub    %edx,%eax
f010add6:	89 c2                	mov    %eax,%edx
f010add8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010addb:	39 c2                	cmp    %eax,%edx
f010addd:	0f 87 7a ff ff ff    	ja     f010ad5d <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010ade3:	83 ec 08             	sub    $0x8,%esp
f010ade6:	ff 75 c8             	pushl  -0x38(%ebp)
f010ade9:	ff 75 f4             	pushl  -0xc(%ebp)
f010adec:	e8 f5 15 00 00       	call   f010c3e6 <PROGRAM_SEGMENT_NEXT>
f010adf1:	83 c4 10             	add    $0x10,%esp
f010adf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010adf7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010adfb:	0f 85 fc fc ff ff    	jne    f010aafd <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ae01:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae07:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010ae0d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010ae10:	eb 77                	jmp    f010ae89 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010ae12:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ae15:	8b 00                	mov    (%eax),%eax
f010ae17:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010ae1d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae23:	8b 40 64             	mov    0x64(%eax),%eax
f010ae26:	83 ec 04             	sub    $0x4,%esp
f010ae29:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010ae2f:	52                   	push   %edx
f010ae30:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010ae36:	50                   	push   %eax
f010ae37:	e8 b3 d5 ff ff       	call   f01083ef <get_page_table>
f010ae3c:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010ae3f:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010ae45:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010ae4b:	c1 ea 0c             	shr    $0xc,%edx
f010ae4e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010ae54:	c1 e2 02             	shl    $0x2,%edx
f010ae57:	01 d0                	add    %edx,%eax
f010ae59:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010ae5f:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010ae65:	c1 e9 0c             	shr    $0xc,%ecx
f010ae68:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010ae6e:	c1 e1 02             	shl    $0x2,%ecx
f010ae71:	01 ca                	add    %ecx,%edx
f010ae73:	8b 12                	mov    (%edx),%edx
f010ae75:	83 e2 bf             	and    $0xffffffbf,%edx
f010ae78:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ae7a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae80:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010ae86:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010ae89:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ae8f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010ae93:	74 08                	je     f010ae9d <env_create+0x593>
f010ae95:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ae98:	8b 52 10             	mov    0x10(%edx),%edx
f010ae9b:	eb 05                	jmp    f010aea2 <env_create+0x598>
f010ae9d:	ba 00 00 00 00       	mov    $0x0,%edx
f010aea2:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010aea8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010aeae:	85 c0                	test   %eax,%eax
f010aeb0:	0f 85 5c ff ff ff    	jne    f010ae12 <env_create+0x508>
f010aeb6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010aeba:	0f 85 52 ff ff ff    	jne    f010ae12 <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010aec0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010aec3:	8b 50 08             	mov    0x8(%eax),%edx
f010aec6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aecc:	83 ec 08             	sub    $0x8,%esp
f010aecf:	52                   	push   %edx
f010aed0:	50                   	push   %eax
f010aed1:	e8 d0 14 00 00       	call   f010c3a6 <set_environment_entry_point>
f010aed6:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010aed9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aedf:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010aee6:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010aeed:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010aef0:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010aef7:	e9 42 03 00 00       	jmp    f010b23e <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010aefc:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010af03:	00 00 00 
			allocate_frame(&pp);
f010af06:	83 ec 0c             	sub    $0xc,%esp
f010af09:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010af0f:	50                   	push   %eax
f010af10:	e8 9d d2 ff ff       	call   f01081b2 <allocate_frame>
f010af15:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010af18:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010af1e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af24:	8b 40 64             	mov    0x64(%eax),%eax
f010af27:	6a 06                	push   $0x6
f010af29:	ff 75 d0             	pushl  -0x30(%ebp)
f010af2c:	52                   	push   %edx
f010af2d:	50                   	push   %eax
f010af2e:	e8 50 d9 ff ff       	call   f0108883 <loadtime_map_frame>
f010af33:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010af36:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010af39:	83 ec 04             	sub    $0x4,%esp
f010af3c:	68 00 10 00 00       	push   $0x1000
f010af41:	6a 00                	push   $0x0
f010af43:	50                   	push   %eax
f010af44:	e8 69 48 01 00       	call   f011f7b2 <memset>
f010af49:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010af4c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af52:	83 ec 08             	sub    $0x8,%esp
f010af55:	ff 75 d0             	pushl  -0x30(%ebp)
f010af58:	50                   	push   %eax
f010af59:	e8 a0 e8 ff ff       	call   f01097fe <env_page_ws_list_create_element>
f010af5e:	83 c4 10             	add    $0x10,%esp
f010af61:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010af64:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010af68:	75 17                	jne    f010af81 <env_create+0x677>
f010af6a:	83 ec 04             	sub    $0x4,%esp
f010af6d:	68 d0 5b 12 f0       	push   $0xf0125bd0
f010af72:	68 5d 01 00 00       	push   $0x15d
f010af77:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010af7c:	e8 b8 53 ff ff       	call   f0100339 <_panic>
f010af81:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010af87:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010af8d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010af90:	89 50 14             	mov    %edx,0x14(%eax)
f010af93:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010af96:	8b 40 14             	mov    0x14(%eax),%eax
f010af99:	85 c0                	test   %eax,%eax
f010af9b:	74 14                	je     f010afb1 <env_create+0x6a7>
f010af9d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afa3:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010afa9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afac:	89 50 10             	mov    %edx,0x10(%eax)
f010afaf:	eb 0f                	jmp    f010afc0 <env_create+0x6b6>
f010afb1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afb7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afba:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010afc0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afc6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010afc9:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010afcf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010afd2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010afd9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010afdf:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010afe5:	42                   	inc    %edx
f010afe6:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010afec:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aff2:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010aff8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010affe:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b004:	39 c2                	cmp    %eax,%edx
f010b006:	75 1a                	jne    f010b022 <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b008:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b00e:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b014:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b01a:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010b020:	eb 10                	jmp    f010b032 <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b022:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b028:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010b02f:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b032:	83 ec 0c             	sub    $0xc,%esp
f010b035:	6a 02                	push   $0x2
f010b037:	e8 87 3f 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f010b03c:	83 c4 10             	add    $0x10,%esp
f010b03f:	85 c0                	test   %eax,%eax
f010b041:	0f 84 d3 01 00 00    	je     f010b21a <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b047:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b04b:	75 17                	jne    f010b064 <env_create+0x75a>
f010b04d:	83 ec 04             	sub    $0x4,%esp
f010b050:	68 f3 5b 12 f0       	push   $0xf0125bf3
f010b055:	68 6a 01 00 00       	push   $0x16a
f010b05a:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b05f:	e8 d5 52 ff ff       	call   f0100339 <_panic>
f010b064:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b067:	8b 40 10             	mov    0x10(%eax),%eax
f010b06a:	85 c0                	test   %eax,%eax
f010b06c:	74 11                	je     f010b07f <env_create+0x775>
f010b06e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b071:	8b 40 10             	mov    0x10(%eax),%eax
f010b074:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b077:	8b 52 14             	mov    0x14(%edx),%edx
f010b07a:	89 50 14             	mov    %edx,0x14(%eax)
f010b07d:	eb 12                	jmp    f010b091 <env_create+0x787>
f010b07f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b085:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b088:	8b 52 14             	mov    0x14(%edx),%edx
f010b08b:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b091:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b094:	8b 40 14             	mov    0x14(%eax),%eax
f010b097:	85 c0                	test   %eax,%eax
f010b099:	74 11                	je     f010b0ac <env_create+0x7a2>
f010b09b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b09e:	8b 40 14             	mov    0x14(%eax),%eax
f010b0a1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0a4:	8b 52 10             	mov    0x10(%edx),%edx
f010b0a7:	89 50 10             	mov    %edx,0x10(%eax)
f010b0aa:	eb 12                	jmp    f010b0be <env_create+0x7b4>
f010b0ac:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b0b5:	8b 52 10             	mov    0x10(%edx),%edx
f010b0b8:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b0be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0c1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b0c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b0cb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b0d2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0d8:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010b0de:	4a                   	dec    %edx
f010b0df:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b0e5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0eb:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b0f1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b0f7:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b0fd:	39 c2                	cmp    %eax,%edx
f010b0ff:	0f 83 8d 00 00 00    	jae    f010b192 <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b105:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b109:	75 17                	jne    f010b122 <env_create+0x818>
f010b10b:	83 ec 04             	sub    $0x4,%esp
f010b10e:	68 48 5b 12 f0       	push   $0xf0125b48
f010b113:	68 6f 01 00 00       	push   $0x16f
f010b118:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b11d:	e8 17 52 ff ff       	call   f0100339 <_panic>
f010b122:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b128:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b12e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b131:	89 50 10             	mov    %edx,0x10(%eax)
f010b134:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b137:	8b 40 10             	mov    0x10(%eax),%eax
f010b13a:	85 c0                	test   %eax,%eax
f010b13c:	74 14                	je     f010b152 <env_create+0x848>
f010b13e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b144:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b14a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b14d:	89 50 14             	mov    %edx,0x14(%eax)
f010b150:	eb 0f                	jmp    f010b161 <env_create+0x857>
f010b152:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b158:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b15b:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b161:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b167:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b16a:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b170:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b173:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b17a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b180:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010b186:	42                   	inc    %edx
f010b187:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b18d:	e9 88 00 00 00       	jmp    f010b21a <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b192:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010b196:	75 17                	jne    f010b1af <env_create+0x8a5>
f010b198:	83 ec 04             	sub    $0x4,%esp
f010b19b:	68 48 5b 12 f0       	push   $0xf0125b48
f010b1a0:	68 73 01 00 00       	push   $0x173
f010b1a5:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b1aa:	e8 8a 51 ff ff       	call   f0100339 <_panic>
f010b1af:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1b5:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010b1bb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b1be:	89 50 10             	mov    %edx,0x10(%eax)
f010b1c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b1c4:	8b 40 10             	mov    0x10(%eax),%eax
f010b1c7:	85 c0                	test   %eax,%eax
f010b1c9:	74 14                	je     f010b1df <env_create+0x8d5>
f010b1cb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1d1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b1d7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b1da:	89 50 14             	mov    %edx,0x14(%eax)
f010b1dd:	eb 0f                	jmp    f010b1ee <env_create+0x8e4>
f010b1df:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1e5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b1e8:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b1ee:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b1f4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010b1f7:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010b1fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b200:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b207:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b20d:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f010b213:	42                   	inc    %edx
f010b214:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b21a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b220:	83 ec 04             	sub    $0x4,%esp
f010b223:	6a 01                	push   $0x1
f010b225:	ff 75 d0             	pushl  -0x30(%ebp)
f010b228:	50                   	push   %eax
f010b229:	e8 d2 8e ff ff       	call   f0104100 <pf_add_empty_env_page>
f010b22e:	83 c4 10             	add    $0x10,%esp
f010b231:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b237:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010b23e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b241:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010b247:	0f 83 af fc ff ff    	jae    f010aefc <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b24d:	83 ec 0c             	sub    $0xc,%esp
f010b250:	6a 02                	push   $0x2
f010b252:	e8 6c 3d 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f010b257:	83 c4 10             	add    $0x10,%esp
f010b25a:	85 c0                	test   %eax,%eax
f010b25c:	74 72                	je     f010b2d0 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010b25e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b265:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b26b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b271:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b274:	eb 2b                	jmp    f010b2a1 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b276:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b279:	8b 10                	mov    (%eax),%edx
f010b27b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b281:	8b 40 64             	mov    0x64(%eax),%eax
f010b284:	6a 01                	push   $0x1
f010b286:	6a 00                	push   $0x0
f010b288:	52                   	push   %edx
f010b289:	50                   	push   %eax
f010b28a:	e8 39 e3 ff ff       	call   f01095c8 <pt_set_page_permissions>
f010b28f:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b292:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b298:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b29e:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b2a1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b2a7:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b2ab:	74 08                	je     f010b2b5 <env_create+0x9ab>
f010b2ad:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b2b0:	8b 52 10             	mov    0x10(%edx),%edx
f010b2b3:	eb 05                	jmp    f010b2ba <env_create+0x9b0>
f010b2b5:	ba 00 00 00 00       	mov    $0x0,%edx
f010b2ba:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b2c0:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b2c6:	85 c0                	test   %eax,%eax
f010b2c8:	75 ac                	jne    f010b276 <env_create+0x96c>
f010b2ca:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b2ce:	75 a6                	jne    f010b276 <env_create+0x96c>
f010b2d0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b2d3:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b2d6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b2d9:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b2dc:	e8 40 bf ff ff       	call   f0107221 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b2e1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010b2e7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010b2ea:	5e                   	pop    %esi
f010b2eb:	5f                   	pop    %edi
f010b2ec:	5d                   	pop    %ebp
f010b2ed:	c3                   	ret    

f010b2ee <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b2ee:	55                   	push   %ebp
f010b2ef:	89 e5                	mov    %esp,%ebp
f010b2f1:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010b2f4:	83 ec 0c             	sub    $0xc,%esp
f010b2f7:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b2fc:	e8 9c 43 00 00       	call   f010f69d <release_spinlock>
f010b301:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b304:	a1 60 e9 17 f0       	mov    0xf017e960,%eax
f010b309:	85 c0                	test   %eax,%eax
f010b30b:	74 30                	je     f010b33d <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b30d:	e8 76 00 00 00       	call   f010b388 <get_cpu_proc>
f010b312:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b315:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b318:	8b 40 10             	mov    0x10(%eax),%eax
f010b31b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b31e:	83 c2 20             	add    $0x20,%edx
f010b321:	83 ec 04             	sub    $0x4,%esp
f010b324:	50                   	push   %eax
f010b325:	52                   	push   %edx
f010b326:	68 11 5c 12 f0       	push   $0xf0125c11
f010b32b:	e8 5b 5c ff ff       	call   f0100f8b <cprintf>
f010b330:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b333:	c7 05 60 e9 17 f0 00 	movl   $0x0,0xf017e960
f010b33a:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b33d:	90                   	nop
f010b33e:	c9                   	leave  
f010b33f:	c3                   	ret    

f010b340 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b340:	55                   	push   %ebp
f010b341:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010b343:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010b344:	5d                   	pop    %ebp
f010b345:	c3                   	ret    

f010b346 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010b346:	55                   	push   %ebp
f010b347:	89 e5                	mov    %esp,%ebp
f010b349:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010b34c:	e8 37 00 00 00       	call   f010b388 <get_cpu_proc>
f010b351:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010b354:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b358:	75 19                	jne    f010b373 <env_exit+0x2d>
f010b35a:	68 27 5c 12 f0       	push   $0xf0125c27
f010b35f:	68 37 5c 12 f0       	push   $0xf0125c37
f010b364:	68 ed 01 00 00       	push   $0x1ed
f010b369:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b36e:	e8 c6 4f ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010b373:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b376:	8b 40 10             	mov    0x10(%eax),%eax
f010b379:	83 ec 0c             	sub    $0xc,%esp
f010b37c:	50                   	push   %eax
f010b37d:	e8 a7 a4 ff ff       	call   f0105829 <sched_exit_env>
f010b382:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010b385:	90                   	nop
f010b386:	c9                   	leave  
f010b387:	c3                   	ret    

f010b388 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010b388:	55                   	push   %ebp
f010b389:	89 e5                	mov    %esp,%ebp
f010b38b:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010b38e:	e8 3c be ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b393:	e8 74 bd ff ff       	call   f010710c <mycpu>
f010b398:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010b39b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b39e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b3a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010b3a7:	e8 75 be ff ff       	call   f0107221 <popcli>
	return p;
f010b3ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010b3af:	c9                   	leave  
f010b3b0:	c3                   	ret    

f010b3b1 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010b3b1:	55                   	push   %ebp
f010b3b2:	89 e5                	mov    %esp,%ebp
f010b3b4:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010b3b7:	e8 13 be ff ff       	call   f01071cf <pushcli>
	c = mycpu();
f010b3bc:	e8 4b bd ff ff       	call   f010710c <mycpu>
f010b3c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010b3c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b3c7:	8b 55 08             	mov    0x8(%ebp),%edx
f010b3ca:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010b3d0:	e8 4c be ff ff       	call   f0107221 <popcli>
}
f010b3d5:	90                   	nop
f010b3d6:	c9                   	leave  
f010b3d7:	c3                   	ret    

f010b3d8 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010b3d8:	55                   	push   %ebp
f010b3d9:	89 e5                	mov    %esp,%ebp
f010b3db:	53                   	push   %ebx
f010b3dc:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010b3df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b3e3:	75 16                	jne    f010b3fb <envid2env+0x23>
		*env_store = get_cpu_proc();
f010b3e5:	e8 9e ff ff ff       	call   f010b388 <get_cpu_proc>
f010b3ea:	89 c2                	mov    %eax,%edx
f010b3ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b3ef:	89 10                	mov    %edx,(%eax)
		return 0;
f010b3f1:	b8 00 00 00 00       	mov    $0x0,%eax
f010b3f6:	e9 aa 00 00 00       	jmp    f010b4a5 <envid2env+0xcd>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010b3fb:	8b 1d d0 47 69 f0    	mov    0xf06947d0,%ebx
f010b401:	83 ec 0c             	sub    $0xc,%esp
f010b404:	68 ca 02 00 00       	push   $0x2ca
f010b409:	e8 14 27 01 00       	call   f011db22 <nearest_pow2_ceil>
f010b40e:	83 c4 10             	add    $0x10,%esp
f010b411:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b414:	8b 45 08             	mov    0x8(%ebp),%eax
f010b417:	21 c2                	and    %eax,%edx
f010b419:	89 d0                	mov    %edx,%eax
f010b41b:	c1 e0 03             	shl    $0x3,%eax
f010b41e:	01 d0                	add    %edx,%eax
f010b420:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b427:	01 c8                	add    %ecx,%eax
f010b429:	01 c0                	add    %eax,%eax
f010b42b:	01 d0                	add    %edx,%eax
f010b42d:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010b434:	01 c8                	add    %ecx,%eax
f010b436:	01 d0                	add    %edx,%eax
f010b438:	01 d8                	add    %ebx,%eax
f010b43a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010b43d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b440:	8b 40 18             	mov    0x18(%eax),%eax
f010b443:	85 c0                	test   %eax,%eax
f010b445:	74 0b                	je     f010b452 <envid2env+0x7a>
f010b447:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b44a:	8b 40 10             	mov    0x10(%eax),%eax
f010b44d:	3b 45 08             	cmp    0x8(%ebp),%eax
f010b450:	74 10                	je     f010b462 <envid2env+0x8a>
		*env_store = 0;
f010b452:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b455:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010b45b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010b460:	eb 43                	jmp    f010b4a5 <envid2env+0xcd>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010b462:	e8 21 ff ff ff       	call   f010b388 <get_cpu_proc>
f010b467:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010b46a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010b46e:	74 28                	je     f010b498 <envid2env+0xc0>
f010b470:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b473:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010b476:	74 20                	je     f010b498 <envid2env+0xc0>
f010b478:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b47b:	8b 50 14             	mov    0x14(%eax),%edx
f010b47e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b481:	8b 40 10             	mov    0x10(%eax),%eax
f010b484:	39 c2                	cmp    %eax,%edx
f010b486:	74 10                	je     f010b498 <envid2env+0xc0>
		*env_store = 0;
f010b488:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b48b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010b491:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010b496:	eb 0d                	jmp    f010b4a5 <envid2env+0xcd>
	}

	*env_store = e;
f010b498:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b49b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b49e:	89 10                	mov    %edx,(%eax)
	return 0;
f010b4a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b4a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b4a8:	c9                   	leave  
f010b4a9:	c3                   	ret    

f010b4aa <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010b4aa:	55                   	push   %ebp
f010b4ab:	89 e5                	mov    %esp,%ebp
f010b4ad:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010b4b0:	83 ec 0c             	sub    $0xc,%esp
f010b4b3:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b4b8:	e8 59 41 00 00       	call   f010f616 <acquire_spinlock>
f010b4bd:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010b4c0:	e8 c3 fe ff ff       	call   f010b388 <get_cpu_proc>
f010b4c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010b4c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b4cc:	75 19                	jne    f010b4e7 <yield+0x3d>
f010b4ce:	68 4c 5c 12 f0       	push   $0xf0125c4c
f010b4d3:	68 37 5c 12 f0       	push   $0xf0125c37
f010b4d8:	68 4c 02 00 00       	push   $0x24c
f010b4dd:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b4e2:	e8 52 4e ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010b4e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4ea:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010b4f1:	e8 13 00 00 00       	call   f010b509 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010b4f6:	83 ec 0c             	sub    $0xc,%esp
f010b4f9:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b4fe:	e8 9a 41 00 00       	call   f010f69d <release_spinlock>
f010b503:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010b506:	90                   	nop
f010b507:	c9                   	leave  
f010b508:	c3                   	ret    

f010b509 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010b509:	55                   	push   %ebp
f010b50a:	89 e5                	mov    %esp,%ebp
f010b50c:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010b50f:	e8 74 fe ff ff       	call   f010b388 <get_cpu_proc>
f010b514:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010b517:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b51b:	75 19                	jne    f010b536 <sched+0x2d>
f010b51d:	68 4c 5c 12 f0       	push   $0xf0125c4c
f010b522:	68 37 5c 12 f0       	push   $0xf0125c37
f010b527:	68 60 02 00 00       	push   $0x260
f010b52c:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b531:	e8 03 4e ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010b536:	83 ec 0c             	sub    $0xc,%esp
f010b539:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010b53e:	e8 ec 42 00 00       	call   f010f82f <holding_spinlock>
f010b543:	83 c4 10             	add    $0x10,%esp
f010b546:	85 c0                	test   %eax,%eax
f010b548:	75 17                	jne    f010b561 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010b54a:	83 ec 04             	sub    $0x4,%esp
f010b54d:	68 58 5c 12 f0       	push   $0xf0125c58
f010b552:	68 64 02 00 00       	push   $0x264
f010b557:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b55c:	e8 d8 4d ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010b561:	e8 a6 bb ff ff       	call   f010710c <mycpu>
f010b566:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010b56c:	83 f8 01             	cmp    $0x1,%eax
f010b56f:	74 20                	je     f010b591 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010b571:	e8 96 bb ff ff       	call   f010710c <mycpu>
f010b576:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010b57c:	50                   	push   %eax
f010b57d:	68 9a 5c 12 f0       	push   $0xf0125c9a
f010b582:	68 67 02 00 00       	push   $0x267
f010b587:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b58c:	e8 a8 4d ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010b591:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b594:	8b 40 18             	mov    0x18(%eax),%eax
f010b597:	83 f8 02             	cmp    $0x2,%eax
f010b59a:	75 17                	jne    f010b5b3 <sched+0xaa>
		panic("sched a running process");
f010b59c:	83 ec 04             	sub    $0x4,%esp
f010b59f:	68 b1 5c 12 f0       	push   $0xf0125cb1
f010b5a4:	68 6a 02 00 00       	push   $0x26a
f010b5a9:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b5ae:	e8 86 4d ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010b5b3:	9c                   	pushf  
f010b5b4:	58                   	pop    %eax
f010b5b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010b5b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010b5bb:	25 00 02 00 00       	and    $0x200,%eax
f010b5c0:	85 c0                	test   %eax,%eax
f010b5c2:	74 17                	je     f010b5db <sched+0xd2>
		panic("sched is interruptible!");
f010b5c4:	83 ec 04             	sub    $0x4,%esp
f010b5c7:	68 c9 5c 12 f0       	push   $0xf0125cc9
f010b5cc:	68 6c 02 00 00       	push   $0x26c
f010b5d1:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b5d6:	e8 5e 4d ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010b5db:	e8 2c bb ff ff       	call   f010710c <mycpu>
f010b5e0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010b5e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010b5e9:	e8 1e bb ff ff       	call   f010710c <mycpu>
f010b5ee:	8b 40 04             	mov    0x4(%eax),%eax
f010b5f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b5f4:	83 c2 04             	add    $0x4,%edx
f010b5f7:	83 ec 08             	sub    $0x8,%esp
f010b5fa:	50                   	push   %eax
f010b5fb:	52                   	push   %edx
f010b5fc:	e8 70 95 ff ff       	call   f0104b71 <context_switch>
f010b601:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010b604:	e8 03 bb ff ff       	call   f010710c <mycpu>
f010b609:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b60c:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010b612:	90                   	nop
f010b613:	c9                   	leave  
f010b614:	c3                   	ret    

f010b615 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010b615:	55                   	push   %ebp
f010b616:	89 e5                	mov    %esp,%ebp
f010b618:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010b61b:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f010b620:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b623:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010b626:	0f 22 d8             	mov    %eax,%cr3
}
f010b629:	90                   	nop
f010b62a:	c9                   	leave  
f010b62b:	c3                   	ret    

f010b62c <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010b62c:	55                   	push   %ebp
f010b62d:	89 e5                	mov    %esp,%ebp
f010b62f:	53                   	push   %ebx
f010b630:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010b633:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b637:	75 17                	jne    f010b650 <switchuvm+0x24>
		panic("switchuvm: no process");
f010b639:	83 ec 04             	sub    $0x4,%esp
f010b63c:	68 e1 5c 12 f0       	push   $0xf0125ce1
f010b641:	68 81 02 00 00       	push   $0x281
f010b646:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b64b:	e8 e9 4c ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010b650:	8b 45 08             	mov    0x8(%ebp),%eax
f010b653:	8b 40 70             	mov    0x70(%eax),%eax
f010b656:	85 c0                	test   %eax,%eax
f010b658:	75 17                	jne    f010b671 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010b65a:	83 ec 04             	sub    $0x4,%esp
f010b65d:	68 f7 5c 12 f0       	push   $0xf0125cf7
f010b662:	68 83 02 00 00       	push   $0x283
f010b667:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b66c:	e8 c8 4c ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010b671:	8b 45 08             	mov    0x8(%ebp),%eax
f010b674:	8b 40 64             	mov    0x64(%eax),%eax
f010b677:	85 c0                	test   %eax,%eax
f010b679:	75 17                	jne    f010b692 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010b67b:	83 ec 04             	sub    $0x4,%esp
f010b67e:	68 0c 5d 12 f0       	push   $0xf0125d0c
f010b683:	68 85 02 00 00       	push   $0x285
f010b688:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b68d:	e8 a7 4c ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010b692:	e8 38 bb ff ff       	call   f01071cf <pushcli>
	struct cpu* c = mycpu();
f010b697:	e8 70 ba ff ff       	call   f010710c <mycpu>
f010b69c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010b69f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6a2:	8b 55 08             	mov    0x8(%ebp),%edx
f010b6a5:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010b6ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6ae:	83 c0 0c             	add    $0xc,%eax
f010b6b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6b4:	83 c2 0c             	add    $0xc,%edx
f010b6b7:	c1 ea 10             	shr    $0x10,%edx
f010b6ba:	88 d3                	mov    %dl,%bl
f010b6bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6bf:	83 c2 0c             	add    $0xc,%edx
f010b6c2:	c1 ea 18             	shr    $0x18,%edx
f010b6c5:	88 d1                	mov    %dl,%cl
f010b6c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6ca:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010b6d1:	68 00 
f010b6d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b6d6:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010b6dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6e0:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010b6e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6e9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b6ef:	83 e2 f0             	and    $0xfffffff0,%edx
f010b6f2:	83 ca 09             	or     $0x9,%edx
f010b6f5:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b6fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6fe:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b704:	83 ca 10             	or     $0x10,%edx
f010b707:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b70d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b710:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b716:	83 e2 9f             	and    $0xffffff9f,%edx
f010b719:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b71f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b722:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b728:	83 ca 80             	or     $0xffffff80,%edx
f010b72b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010b731:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b734:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b73a:	83 e2 f0             	and    $0xfffffff0,%edx
f010b73d:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b743:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b746:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b74c:	83 e2 ef             	and    $0xffffffef,%edx
f010b74f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b755:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b758:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b75e:	83 e2 df             	and    $0xffffffdf,%edx
f010b761:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b767:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b76a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b770:	83 ca 40             	or     $0x40,%edx
f010b773:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b779:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b77c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b782:	83 e2 7f             	and    $0x7f,%edx
f010b785:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b78b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b78e:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010b794:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b797:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b79d:	83 e2 ef             	and    $0xffffffef,%edx
f010b7a0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010b7a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7a9:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b7af:	8b 40 70             	mov    0x70(%eax),%eax
f010b7b2:	05 00 80 00 00       	add    $0x8000,%eax
f010b7b7:	89 c2                	mov    %eax,%edx
f010b7b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7bc:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010b7bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7c2:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010b7c8:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010b7ce:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010b7d2:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010b7d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7d8:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b7de:	8b 40 68             	mov    0x68(%eax),%eax
f010b7e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b7e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b7e7:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010b7ea:	e8 32 ba ff ff       	call   f0107221 <popcli>
}
f010b7ef:	90                   	nop
f010b7f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b7f3:	c9                   	leave  
f010b7f4:	c3                   	ret    

f010b7f5 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010b7f5:	55                   	push   %ebp
f010b7f6:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010b7f8:	8b 15 d4 47 69 f0    	mov    0xf06947d4,%edx
f010b7fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010b801:	89 10                	mov    %edx,(%eax)
f010b803:	8b 45 08             	mov    0x8(%ebp),%eax
f010b806:	8b 00                	mov    (%eax),%eax
f010b808:	85 c0                	test   %eax,%eax
f010b80a:	75 07                	jne    f010b813 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010b80c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010b811:	eb 11                	jmp    f010b824 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010b813:	8b 45 08             	mov    0x8(%ebp),%eax
f010b816:	8b 00                	mov    (%eax),%eax
f010b818:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010b81f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b824:	5d                   	pop    %ebp
f010b825:	c3                   	ret    

f010b826 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010b826:	55                   	push   %ebp
f010b827:	89 e5                	mov    %esp,%ebp
f010b829:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010b82c:	83 ec 04             	sub    $0x4,%esp
f010b82f:	68 bc 05 00 00       	push   $0x5bc
f010b834:	6a 00                	push   $0x0
f010b836:	ff 75 08             	pushl  0x8(%ebp)
f010b839:	e8 74 3f 01 00       	call   f011f7b2 <memset>
f010b83e:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010b841:	8b 45 08             	mov    0x8(%ebp),%eax
f010b844:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010b84b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b84f:	75 17                	jne    f010b868 <free_environment+0x42>
f010b851:	83 ec 04             	sub    $0x4,%esp
f010b854:	68 48 5b 12 f0       	push   $0xf0125b48
f010b859:	68 c0 02 00 00       	push   $0x2c0
f010b85e:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b863:	e8 d1 4a ff ff       	call   f0100339 <_panic>
f010b868:	8b 15 d4 47 69 f0    	mov    0xf06947d4,%edx
f010b86e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b871:	89 50 08             	mov    %edx,0x8(%eax)
f010b874:	8b 45 08             	mov    0x8(%ebp),%eax
f010b877:	8b 40 08             	mov    0x8(%eax),%eax
f010b87a:	85 c0                	test   %eax,%eax
f010b87c:	74 0d                	je     f010b88b <free_environment+0x65>
f010b87e:	a1 d4 47 69 f0       	mov    0xf06947d4,%eax
f010b883:	8b 55 08             	mov    0x8(%ebp),%edx
f010b886:	89 50 0c             	mov    %edx,0xc(%eax)
f010b889:	eb 08                	jmp    f010b893 <free_environment+0x6d>
f010b88b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b88e:	a3 d8 47 69 f0       	mov    %eax,0xf06947d8
f010b893:	8b 45 08             	mov    0x8(%ebp),%eax
f010b896:	a3 d4 47 69 f0       	mov    %eax,0xf06947d4
f010b89b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b89e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b8a5:	a1 e0 47 69 f0       	mov    0xf06947e0,%eax
f010b8aa:	40                   	inc    %eax
f010b8ab:	a3 e0 47 69 f0       	mov    %eax,0xf06947e0
}
f010b8b0:	90                   	nop
f010b8b1:	c9                   	leave  
f010b8b2:	c3                   	ret    

f010b8b3 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010b8b3:	55                   	push   %ebp
f010b8b4:	89 e5                	mov    %esp,%ebp
f010b8b6:	53                   	push   %ebx
f010b8b7:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010b8ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8bd:	8b 40 0c             	mov    0xc(%eax),%eax
f010b8c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010b8c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8c6:	8b 40 08             	mov    0x8(%eax),%eax
f010b8c9:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010b8cc:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010b8d3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010b8d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b8d9:	01 c2                	add    %eax,%edx
f010b8db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b8de:	01 d0                	add    %edx,%eax
f010b8e0:	48                   	dec    %eax
f010b8e1:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b8e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b8e7:	ba 00 00 00 00       	mov    $0x0,%edx
f010b8ec:	f7 75 dc             	divl   -0x24(%ebp)
f010b8ef:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b8f2:	29 d0                	sub    %edx,%eax
f010b8f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010b8f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b8fa:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010b8fd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b900:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b905:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010b908:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010b90f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010b916:	8b 45 10             	mov    0x10(%ebp),%eax
f010b919:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010b91f:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010b926:	0f 85 f5 03 00 00    	jne    f010bd21 <program_segment_alloc_map_copy_workingset+0x46e>
f010b92c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b92f:	83 c0 20             	add    $0x20,%eax
f010b932:	83 ec 08             	sub    $0x8,%esp
f010b935:	68 20 5d 12 f0       	push   $0xf0125d20
f010b93a:	50                   	push   %eax
f010b93b:	e8 90 3d 01 00       	call   f011f6d0 <strcmp>
f010b940:	83 c4 10             	add    $0x10,%esp
f010b943:	85 c0                	test   %eax,%eax
f010b945:	0f 84 d6 03 00 00    	je     f010bd21 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010b94b:	8b 45 14             	mov    0x14(%ebp),%eax
f010b94e:	83 f8 06             	cmp    $0x6,%eax
f010b951:	76 05                	jbe    f010b958 <program_segment_alloc_map_copy_workingset+0xa5>
f010b953:	b8 06 00 00 00       	mov    $0x6,%eax
f010b958:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b95b:	e9 c1 03 00 00       	jmp    f010bd21 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010b960:	83 ec 0c             	sub    $0xc,%esp
f010b963:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010b966:	50                   	push   %eax
f010b967:	e8 46 c8 ff ff       	call   f01081b2 <allocate_frame>
f010b96c:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010b96f:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b972:	8b 45 08             	mov    0x8(%ebp),%eax
f010b975:	8b 40 64             	mov    0x64(%eax),%eax
f010b978:	6a 06                	push   $0x6
f010b97a:	ff 75 f4             	pushl  -0xc(%ebp)
f010b97d:	52                   	push   %edx
f010b97e:	50                   	push   %eax
f010b97f:	e8 ff ce ff ff       	call   f0108883 <loadtime_map_frame>
f010b984:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010b987:	83 ec 08             	sub    $0x8,%esp
f010b98a:	ff 75 f4             	pushl  -0xc(%ebp)
f010b98d:	ff 75 08             	pushl  0x8(%ebp)
f010b990:	e8 69 de ff ff       	call   f01097fe <env_page_ws_list_create_element>
f010b995:	83 c4 10             	add    $0x10,%esp
f010b998:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010b99b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b99e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b9a5:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b9a9:	75 17                	jne    f010b9c2 <program_segment_alloc_map_copy_workingset+0x10f>
f010b9ab:	83 ec 04             	sub    $0x4,%esp
f010b9ae:	68 d0 5b 12 f0       	push   $0xf0125bd0
f010b9b3:	68 ea 02 00 00       	push   $0x2ea
f010b9b8:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010b9bd:	e8 77 49 ff ff       	call   f0100339 <_panic>
f010b9c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9c5:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b9cb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b9ce:	89 50 14             	mov    %edx,0x14(%eax)
f010b9d1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b9d4:	8b 40 14             	mov    0x14(%eax),%eax
f010b9d7:	85 c0                	test   %eax,%eax
f010b9d9:	74 11                	je     f010b9ec <program_segment_alloc_map_copy_workingset+0x139>
f010b9db:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9de:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b9e4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b9e7:	89 50 10             	mov    %edx,0x10(%eax)
f010b9ea:	eb 0c                	jmp    f010b9f8 <program_segment_alloc_map_copy_workingset+0x145>
f010b9ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9ef:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b9f2:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b9f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9fb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b9fe:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010ba04:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba07:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010ba0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba11:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010ba17:	8d 50 01             	lea    0x1(%eax),%edx
f010ba1a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba1d:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010ba23:	83 ec 0c             	sub    $0xc,%esp
f010ba26:	6a 02                	push   $0x2
f010ba28:	e8 96 35 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f010ba2d:	83 c4 10             	add    $0x10,%esp
f010ba30:	85 c0                	test   %eax,%eax
f010ba32:	0f 84 b3 01 00 00    	je     f010bbeb <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010ba38:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010ba3c:	75 17                	jne    f010ba55 <program_segment_alloc_map_copy_workingset+0x1a2>
f010ba3e:	83 ec 04             	sub    $0x4,%esp
f010ba41:	68 f3 5b 12 f0       	push   $0xf0125bf3
f010ba46:	68 f6 02 00 00       	push   $0x2f6
f010ba4b:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010ba50:	e8 e4 48 ff ff       	call   f0100339 <_panic>
f010ba55:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba58:	8b 40 10             	mov    0x10(%eax),%eax
f010ba5b:	85 c0                	test   %eax,%eax
f010ba5d:	74 11                	je     f010ba70 <program_segment_alloc_map_copy_workingset+0x1bd>
f010ba5f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba62:	8b 40 10             	mov    0x10(%eax),%eax
f010ba65:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba68:	8b 52 14             	mov    0x14(%edx),%edx
f010ba6b:	89 50 14             	mov    %edx,0x14(%eax)
f010ba6e:	eb 0f                	jmp    f010ba7f <program_segment_alloc_map_copy_workingset+0x1cc>
f010ba70:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba73:	8b 50 14             	mov    0x14(%eax),%edx
f010ba76:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba79:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010ba7f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba82:	8b 40 14             	mov    0x14(%eax),%eax
f010ba85:	85 c0                	test   %eax,%eax
f010ba87:	74 11                	je     f010ba9a <program_segment_alloc_map_copy_workingset+0x1e7>
f010ba89:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba8c:	8b 40 14             	mov    0x14(%eax),%eax
f010ba8f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ba92:	8b 52 10             	mov    0x10(%edx),%edx
f010ba95:	89 50 10             	mov    %edx,0x10(%eax)
f010ba98:	eb 0f                	jmp    f010baa9 <program_segment_alloc_map_copy_workingset+0x1f6>
f010ba9a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ba9d:	8b 50 10             	mov    0x10(%eax),%edx
f010baa0:	8b 45 08             	mov    0x8(%ebp),%eax
f010baa3:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010baa9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010baac:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010bab3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bab6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010babd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bac0:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010bac6:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bac9:	8b 45 08             	mov    0x8(%ebp),%eax
f010bacc:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010bad2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bad5:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010badb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bade:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010bae4:	48                   	dec    %eax
f010bae5:	39 c2                	cmp    %eax,%edx
f010bae7:	0f 83 80 00 00 00    	jae    f010bb6d <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010baed:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010baf1:	75 17                	jne    f010bb0a <program_segment_alloc_map_copy_workingset+0x257>
f010baf3:	83 ec 04             	sub    $0x4,%esp
f010baf6:	68 48 5b 12 f0       	push   $0xf0125b48
f010bafb:	68 fa 02 00 00       	push   $0x2fa
f010bb00:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010bb05:	e8 2f 48 ff ff       	call   f0100339 <_panic>
f010bb0a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb0d:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010bb13:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb16:	89 50 10             	mov    %edx,0x10(%eax)
f010bb19:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb1c:	8b 40 10             	mov    0x10(%eax),%eax
f010bb1f:	85 c0                	test   %eax,%eax
f010bb21:	74 11                	je     f010bb34 <program_segment_alloc_map_copy_workingset+0x281>
f010bb23:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb26:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010bb2c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bb2f:	89 50 14             	mov    %edx,0x14(%eax)
f010bb32:	eb 0c                	jmp    f010bb40 <program_segment_alloc_map_copy_workingset+0x28d>
f010bb34:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb37:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bb3a:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010bb40:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb43:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bb46:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010bb4c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb4f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bb56:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb59:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010bb5f:	8d 50 01             	lea    0x1(%eax),%edx
f010bb62:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb65:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010bb6b:	eb 7e                	jmp    f010bbeb <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010bb6d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010bb71:	75 17                	jne    f010bb8a <program_segment_alloc_map_copy_workingset+0x2d7>
f010bb73:	83 ec 04             	sub    $0x4,%esp
f010bb76:	68 48 5b 12 f0       	push   $0xf0125b48
f010bb7b:	68 ff 02 00 00       	push   $0x2ff
f010bb80:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010bb85:	e8 af 47 ff ff       	call   f0100339 <_panic>
f010bb8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb8d:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010bb93:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb96:	89 50 10             	mov    %edx,0x10(%eax)
f010bb99:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bb9c:	8b 40 10             	mov    0x10(%eax),%eax
f010bb9f:	85 c0                	test   %eax,%eax
f010bba1:	74 11                	je     f010bbb4 <program_segment_alloc_map_copy_workingset+0x301>
f010bba3:	8b 45 08             	mov    0x8(%ebp),%eax
f010bba6:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010bbac:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bbaf:	89 50 14             	mov    %edx,0x14(%eax)
f010bbb2:	eb 0c                	jmp    f010bbc0 <program_segment_alloc_map_copy_workingset+0x30d>
f010bbb4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbb7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bbba:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010bbc0:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbc3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010bbc6:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010bbcc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010bbcf:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bbd6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbd9:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010bbdf:	8d 50 01             	lea    0x1(%eax),%edx
f010bbe2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbe5:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010bbeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbee:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010bbf4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbf7:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010bbfd:	39 c2                	cmp    %eax,%edx
f010bbff:	75 14                	jne    f010bc15 <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010bc01:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc04:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010bc0a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc0d:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010bc13:	eb 0d                	jmp    f010bc22 <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010bc15:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc18:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010bc1f:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010bc22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc25:	c1 e8 16             	shr    $0x16,%eax
f010bc28:	89 c2                	mov    %eax,%edx
f010bc2a:	8b 45 18             	mov    0x18(%ebp),%eax
f010bc2d:	8b 00                	mov    (%eax),%eax
f010bc2f:	39 c2                	cmp    %eax,%edx
f010bc31:	0f 84 d3 00 00 00    	je     f010bd0a <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010bc37:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc3a:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bc40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc43:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010bc46:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010bc49:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010bc4e:	89 c1                	mov    %eax,%ecx
f010bc50:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010bc53:	89 d0                	mov    %edx,%eax
f010bc55:	01 c0                	add    %eax,%eax
f010bc57:	01 d0                	add    %edx,%eax
f010bc59:	c1 e0 03             	shl    $0x3,%eax
f010bc5c:	01 d8                	add    %ebx,%eax
f010bc5e:	05 ac 00 00 00       	add    $0xac,%eax
f010bc63:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010bc65:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc68:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bc6e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bc71:	89 d0                	mov    %edx,%eax
f010bc73:	01 c0                	add    %eax,%eax
f010bc75:	01 d0                	add    %edx,%eax
f010bc77:	c1 e0 03             	shl    $0x3,%eax
f010bc7a:	01 c8                	add    %ecx,%eax
f010bc7c:	05 b0 00 00 00       	add    $0xb0,%eax
f010bc81:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010bc84:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc87:	8b 90 5c 05 00 00    	mov    0x55c(%eax),%edx
f010bc8d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010bc90:	89 d0                	mov    %edx,%eax
f010bc92:	01 c0                	add    %eax,%eax
f010bc94:	01 d0                	add    %edx,%eax
f010bc96:	c1 e0 03             	shl    $0x3,%eax
f010bc99:	01 c8                	add    %ecx,%eax
f010bc9b:	05 b4 00 00 00       	add    $0xb4,%eax
f010bca0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010bca6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bca9:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bcaf:	8d 50 01             	lea    0x1(%eax),%edx
f010bcb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcb5:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010bcbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcbe:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bcc4:	b9 32 00 00 00       	mov    $0x32,%ecx
f010bcc9:	ba 00 00 00 00       	mov    $0x0,%edx
f010bcce:	f7 f1                	div    %ecx
f010bcd0:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcd3:	89 90 5c 05 00 00    	mov    %edx,0x55c(%eax)
			if (e->table_last_WS_index == 0)
f010bcd9:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcdc:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010bce2:	85 c0                	test   %eax,%eax
f010bce4:	75 17                	jne    f010bcfd <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010bce6:	83 ec 04             	sub    $0x4,%esp
f010bce9:	68 24 5d 12 f0       	push   $0xf0125d24
f010bcee:	68 27 03 00 00       	push   $0x327
f010bcf3:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010bcf8:	e8 3c 46 ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010bcfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd00:	c1 e8 16             	shr    $0x16,%eax
f010bd03:	89 c2                	mov    %eax,%edx
f010bd05:	8b 45 18             	mov    0x18(%ebp),%eax
f010bd08:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010bd0a:	8b 45 10             	mov    0x10(%ebp),%eax
f010bd0d:	8b 00                	mov    (%eax),%eax
f010bd0f:	8d 50 01             	lea    0x1(%eax),%edx
f010bd12:	8b 45 10             	mov    0x10(%ebp),%eax
f010bd15:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010bd17:	ff 45 f0             	incl   -0x10(%ebp)
f010bd1a:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010bd21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd24:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010bd27:	73 0c                	jae    f010bd35 <program_segment_alloc_map_copy_workingset+0x482>
f010bd29:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bd2c:	3b 45 14             	cmp    0x14(%ebp),%eax
f010bd2f:	0f 82 2b fc ff ff    	jb     f010b960 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010bd35:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd38:	8b 00                	mov    (%eax),%eax
f010bd3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010bd3d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd40:	8b 40 0c             	mov    0xc(%eax),%eax
f010bd43:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bd46:	eb 10                	jmp    f010bd58 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010bd48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bd4b:	8a 10                	mov    (%eax),%dl
f010bd4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bd50:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010bd52:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010bd55:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bd58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bd5b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010bd5e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010bd61:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bd66:	89 c2                	mov    %eax,%edx
f010bd68:	8b 45 10             	mov    0x10(%ebp),%eax
f010bd6b:	8b 00                	mov    (%eax),%eax
f010bd6d:	c1 e0 0c             	shl    $0xc,%eax
f010bd70:	01 c2                	add    %eax,%edx
f010bd72:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bd75:	39 c2                	cmp    %eax,%edx
f010bd77:	76 1d                	jbe    f010bd96 <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010bd79:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd7c:	8b 50 04             	mov    0x4(%eax),%edx
f010bd7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bd82:	01 c2                	add    %eax,%edx
f010bd84:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010bd87:	39 c2                	cmp    %eax,%edx
f010bd89:	77 bd                	ja     f010bd48 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010bd8b:	eb 09                	jmp    f010bd96 <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010bd8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bd90:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010bd93:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010bd96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bd99:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010bd9c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010bd9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bda4:	89 c2                	mov    %eax,%edx
f010bda6:	8b 45 10             	mov    0x10(%ebp),%eax
f010bda9:	8b 00                	mov    (%eax),%eax
f010bdab:	c1 e0 0c             	shl    $0xc,%eax
f010bdae:	01 c2                	add    %eax,%edx
f010bdb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010bdb3:	39 c2                	cmp    %eax,%edx
f010bdb5:	77 d6                	ja     f010bd8d <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010bdb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bdbc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bdbf:	c9                   	leave  
f010bdc0:	c3                   	ret    

f010bdc1 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010bdc1:	55                   	push   %ebp
f010bdc2:	89 e5                	mov    %esp,%ebp
f010bdc4:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010bdc7:	83 ec 0c             	sub    $0xc,%esp
f010bdca:	68 00 10 00 00       	push   $0x1000
f010bdcf:	e8 15 d4 ff ff       	call   f01091e9 <kmalloc>
f010bdd4:	83 c4 10             	add    $0x10,%esp
f010bdd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010bdda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bdde:	75 17                	jne    f010bdf7 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010bde0:	83 ec 04             	sub    $0x4,%esp
f010bde3:	68 c7 5d 12 f0       	push   $0xf0125dc7
f010bde8:	68 57 03 00 00       	push   $0x357
f010bded:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010bdf2:	e8 42 45 ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010bdf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010bdfa:	c9                   	leave  
f010bdfb:	c3                   	ret    

f010bdfc <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010bdfc:	55                   	push   %ebp
f010bdfd:	89 e5                	mov    %esp,%ebp
f010bdff:	83 ec 28             	sub    $0x28,%esp
//allocate space for the user kernel stack.
//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
f010be02:	83 ec 0c             	sub    $0xc,%esp
f010be05:	68 00 80 00 00       	push   $0x8000
f010be0a:	e8 da d3 ff ff       	call   f01091e9 <kmalloc>
f010be0f:	83 c4 10             	add    $0x10,%esp
f010be12:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
f010be15:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f010be1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be1f:	05 ff 7f 00 00       	add    $0x7fff,%eax
f010be24:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010be27:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010be2a:	ba 00 00 00 00       	mov    $0x0,%edx
f010be2f:	f7 75 ec             	divl   -0x14(%ebp)
f010be32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010be35:	29 d0                	sub    %edx,%eax
f010be37:	85 c0                	test   %eax,%eax
f010be39:	79 05                	jns    f010be40 <create_user_kern_stack+0x44>
f010be3b:	05 ff 0f 00 00       	add    $0xfff,%eax
f010be40:	c1 f8 0c             	sar    $0xc,%eax
f010be43:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i=1; i<num_pages; i++)
f010be46:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f010be4d:	eb 72                	jmp    f010bec1 <create_user_kern_stack+0xc5>
	{
		uint32* ptr_page_table = NULL;
f010be4f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		struct FrameInfo * ptr_FrameInfo = get_frame_info(ptr_page_directory, (uint32)va + i*PAGE_SIZE, &ptr_page_table);
f010be56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be59:	c1 e0 0c             	shl    $0xc,%eax
f010be5c:	89 c2                	mov    %eax,%edx
f010be5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010be61:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f010be64:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010be69:	83 ec 04             	sub    $0x4,%esp
f010be6c:	8d 55 dc             	lea    -0x24(%ebp),%edx
f010be6f:	52                   	push   %edx
f010be70:	51                   	push   %ecx
f010be71:	50                   	push   %eax
f010be72:	e8 f2 c8 ff ff       	call   f0108769 <get_frame_info>
f010be77:	83 c4 10             	add    $0x10,%esp
f010be7a:	89 45 e0             	mov    %eax,-0x20(%ebp)
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
f010be7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be80:	c1 e0 0c             	shl    $0xc,%eax
f010be83:	89 c2                	mov    %eax,%edx
f010be85:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010be88:	01 d0                	add    %edx,%eax
f010be8a:	6a 01                	push   $0x1
f010be8c:	50                   	push   %eax
f010be8d:	ff 75 e0             	pushl  -0x20(%ebp)
f010be90:	ff 75 08             	pushl  0x8(%ebp)
f010be93:	e8 e7 c7 ff ff       	call   f010867f <map_frame>
f010be98:	83 c4 10             	add    $0x10,%esp
		if(i == 0){
f010be9b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be9f:	75 1d                	jne    f010bebe <create_user_kern_stack+0xc2>
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
f010bea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bea4:	c1 e0 0c             	shl    $0xc,%eax
f010bea7:	89 c2                	mov    %eax,%edx
f010bea9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010beac:	01 d0                	add    %edx,%eax
f010beae:	6a 01                	push   $0x1
f010beb0:	6a 00                	push   $0x0
f010beb2:	50                   	push   %eax
f010beb3:	ff 75 08             	pushl  0x8(%ebp)
f010beb6:	e8 0d d7 ff ff       	call   f01095c8 <pt_set_page_permissions>
f010bebb:	83 c4 10             	add    $0x10,%esp
//return a pointer to the start of the allocated space (including the GUARD PAGE)
//On failure: panic

	uint32* va = kmalloc(KERNEL_STACK_SIZE); //takes free space address
	uint32 num_pages = ROUNDUP(KERNEL_STACK_SIZE, PAGE_SIZE) / PAGE_SIZE;
	for (int i=1; i<num_pages; i++)
f010bebe:	ff 45 f4             	incl   -0xc(%ebp)
f010bec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bec4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010bec7:	72 86                	jb     f010be4f <create_user_kern_stack+0x53>
		map_frame(ptr_user_page_directory, ptr_FrameInfo, (uint32)va + i*PAGE_SIZE, PERM_PRESENT);
		if(i == 0){
			pt_set_page_permissions(ptr_user_page_directory, (uint32)va + i*PAGE_SIZE, 0, PERM_PRESENT);
		}
	}
	    return va;
f010bec9:	8b 45 f0             	mov    -0x10(%ebp),%eax
void* kstack = (void*) __cur_k_stk;
__cur_k_stk += KERNEL_STACK_SIZE;
return kstack ;
//panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010becc:	c9                   	leave  
f010becd:	c3                   	ret    

f010bece <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010bece:	55                   	push   %ebp
f010becf:	89 e5                	mov    %esp,%ebp
f010bed1:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010bed4:	83 ec 04             	sub    $0x4,%esp
f010bed7:	68 e4 5d 12 f0       	push   $0xf0125de4
f010bedc:	68 8e 03 00 00       	push   $0x38e
f010bee1:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010bee6:	e8 4e 44 ff ff       	call   f0100339 <_panic>

f010beeb <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010beeb:	55                   	push   %ebp
f010beec:	89 e5                	mov    %esp,%ebp
f010beee:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
	e->heap_start = daStart;
f010bef1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bef4:	8b 55 0c             	mov    0xc(%ebp),%edx
f010bef7:	89 50 74             	mov    %edx,0x74(%eax)
	e->heap_hard_limit = daLimit;
f010befa:	8b 45 08             	mov    0x8(%ebp),%eax
f010befd:	8b 55 10             	mov    0x10(%ebp),%edx
f010bf00:	89 50 78             	mov    %edx,0x78(%eax)
	e->heap_brk = daStart;
f010bf03:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf06:	8b 55 0c             	mov    0xc(%ebp),%edx
f010bf09:	89 50 7c             	mov    %edx,0x7c(%eax)

	initialize_dynamic_allocator(daStart,0);
f010bf0c:	83 ec 08             	sub    $0x8,%esp
f010bf0f:	6a 00                	push   $0x0
f010bf11:	ff 75 0c             	pushl  0xc(%ebp)
f010bf14:	e8 7a 42 01 00       	call   f0120193 <initialize_dynamic_allocator>
f010bf19:	83 c4 10             	add    $0x10,%esp
}
f010bf1c:	90                   	nop
f010bf1d:	c9                   	leave  
f010bf1e:	c3                   	ret    

f010bf1f <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010bf1f:	55                   	push   %ebp
f010bf20:	89 e5                	mov    %esp,%ebp
f010bf22:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010bf25:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf28:	8b 55 0c             	mov    0xc(%ebp),%edx
f010bf2b:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010bf2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf31:	8b 55 10             	mov    0x10(%ebp),%edx
f010bf34:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010bf37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bf3e:	eb 17                	jmp    f010bf57 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010bf40:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf43:	8b 40 64             	mov    0x64(%eax),%eax
f010bf46:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf49:	c1 e2 02             	shl    $0x2,%edx
f010bf4c:	01 d0                	add    %edx,%eax
f010bf4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010bf54:	ff 45 f4             	incl   -0xc(%ebp)
f010bf57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf5a:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010bf5f:	76 df                	jbe    f010bf40 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010bf61:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010bf68:	eb 22                	jmp    f010bf8c <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010bf6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf6d:	8b 40 64             	mov    0x64(%eax),%eax
f010bf70:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bf73:	c1 e2 02             	shl    $0x2,%edx
f010bf76:	01 c2                	add    %eax,%edx
f010bf78:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f010bf7d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010bf80:	c1 e1 02             	shl    $0x2,%ecx
f010bf83:	01 c8                	add    %ecx,%eax
f010bf85:	8b 00                	mov    (%eax),%eax
f010bf87:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010bf89:	ff 45 f4             	incl   -0xc(%ebp)
f010bf8c:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010bf93:	7e d5                	jle    f010bf6a <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010bf95:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf98:	8b 40 64             	mov    0x64(%eax),%eax
f010bf9b:	83 ec 0c             	sub    $0xc,%esp
f010bf9e:	50                   	push   %eax
f010bf9f:	e8 58 fe ff ff       	call   f010bdfc <create_user_kern_stack>
f010bfa4:	83 c4 10             	add    $0x10,%esp
f010bfa7:	89 c2                	mov    %eax,%edx
f010bfa9:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfac:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010bfaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfb2:	8b 40 70             	mov    0x70(%eax),%eax
f010bfb5:	05 00 80 00 00       	add    $0x8000,%eax
f010bfba:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010bfbd:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010bfc1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfc4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bfc7:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010bfc9:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010bfcd:	ba 0c e0 10 f0       	mov    $0xf010e00c,%edx
f010bfd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bfd5:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010bfd7:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010bfdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfde:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bfe1:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010bfe4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfe7:	8b 40 04             	mov    0x4(%eax),%eax
f010bfea:	83 ec 04             	sub    $0x4,%esp
f010bfed:	6a 20                	push   $0x20
f010bfef:	6a 00                	push   $0x0
f010bff1:	50                   	push   %eax
f010bff2:	e8 bb 37 01 00       	call   f011f7b2 <memset>
f010bff7:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010bffa:	8b 45 08             	mov    0x8(%ebp),%eax
f010bffd:	8b 40 04             	mov    0x4(%eax),%eax
f010c000:	ba ee b2 10 f0       	mov    $0xf010b2ee,%edx
f010c005:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c008:	8b 45 08             	mov    0x8(%ebp),%eax
f010c00b:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c012:	00 00 00 
f010c015:	8b 45 08             	mov    0x8(%ebp),%eax
f010c018:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c01f:	00 00 00 
f010c022:	8b 45 08             	mov    0x8(%ebp),%eax
f010c025:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c02c:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c02f:	83 ec 0c             	sub    $0xc,%esp
f010c032:	6a 02                	push   $0x2
f010c034:	e8 8a 2f 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f010c039:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c03c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c043:	eb 54                	jmp    f010c099 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c045:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c048:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c04b:	89 d0                	mov    %edx,%eax
f010c04d:	01 c0                	add    %eax,%eax
f010c04f:	01 d0                	add    %edx,%eax
f010c051:	c1 e0 03             	shl    $0x3,%eax
f010c054:	01 c8                	add    %ecx,%eax
f010c056:	05 ac 00 00 00       	add    $0xac,%eax
f010c05b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c061:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c064:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c067:	89 d0                	mov    %edx,%eax
f010c069:	01 c0                	add    %eax,%eax
f010c06b:	01 d0                	add    %edx,%eax
f010c06d:	c1 e0 03             	shl    $0x3,%eax
f010c070:	01 c8                	add    %ecx,%eax
f010c072:	05 b0 00 00 00       	add    $0xb0,%eax
f010c077:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c07a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c07d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c080:	89 d0                	mov    %edx,%eax
f010c082:	01 c0                	add    %eax,%eax
f010c084:	01 d0                	add    %edx,%eax
f010c086:	c1 e0 03             	shl    $0x3,%eax
f010c089:	01 c8                	add    %ecx,%eax
f010c08b:	05 b4 00 00 00       	add    $0xb4,%eax
f010c090:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c096:	ff 45 f4             	incl   -0xc(%ebp)
f010c099:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c09d:	7e a6                	jle    f010c045 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c09f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0a2:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
f010c0a9:	00 00 00 

	e->pageFaultsCounter=0;
f010c0ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0af:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010c0b6:	00 00 00 
	e->tableFaultsCounter=0;
f010c0b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0bc:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010c0c3:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c0c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0c9:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c0d0:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c0d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0d6:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c0dd:	00 00 00 

	e->nModifiedPages=0;
f010c0e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0e3:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c0ea:	00 00 00 
	e->nNotModifiedPages=0;
f010c0ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0f0:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c0f7:	00 00 00 
	e->nClocks = 0;
f010c0fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0fd:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c104:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c107:	8b 45 08             	mov    0x8(%ebp),%eax
f010c10a:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c111:	00 00 00 
	e->nPageOut = 0;
f010c114:	8b 45 08             	mov    0x8(%ebp),%eax
f010c117:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c11e:	00 00 00 
	e->nNewPageAdded = 0;
f010c121:	8b 45 08             	mov    0x8(%ebp),%eax
f010c124:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c12b:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010c12e:	83 ec 04             	sub    $0x4,%esp
f010c131:	68 00 00 00 82       	push   $0x82000000
f010c136:	68 00 00 00 80       	push   $0x80000000
f010c13b:	ff 75 08             	pushl  0x8(%ebp)
f010c13e:	e8 a8 fd ff ff       	call   f010beeb <initialize_uheap_dynamic_allocator>
f010c143:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c146:	83 ec 0c             	sub    $0xc,%esp
f010c149:	ff 75 08             	pushl  0x8(%ebp)
f010c14c:	e8 06 00 00 00       	call   f010c157 <complete_environment_initialization>
f010c151:	83 c4 10             	add    $0x10,%esp
}
f010c154:	90                   	nop
f010c155:	c9                   	leave  
f010c156:	c3                   	ret    

f010c157 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c157:	55                   	push   %ebp
f010c158:	89 e5                	mov    %esp,%ebp
f010c15a:	53                   	push   %ebx
f010c15b:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c15e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c161:	8b 40 64             	mov    0x64(%eax),%eax
f010c164:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c16a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c16d:	8b 40 68             	mov    0x68(%eax),%eax
f010c170:	83 c8 03             	or     $0x3,%eax
f010c173:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c175:	8b 45 08             	mov    0x8(%ebp),%eax
f010c178:	8b 40 64             	mov    0x64(%eax),%eax
f010c17b:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c181:	8b 45 08             	mov    0x8(%ebp),%eax
f010c184:	8b 40 68             	mov    0x68(%eax),%eax
f010c187:	83 c8 05             	or     $0x5,%eax
f010c18a:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c18c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c18f:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c196:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010c199:	8b 45 08             	mov    0x8(%ebp),%eax
f010c19c:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010c1a3:	00 00 00 
	e->disk_env_tabledir = 0;
f010c1a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1a9:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c1b0:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010c1b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1b6:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c1bd:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c1c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1c3:	8b 58 10             	mov    0x10(%eax),%ebx
f010c1c6:	83 ec 0c             	sub    $0xc,%esp
f010c1c9:	68 ca 02 00 00       	push   $0x2ca
f010c1ce:	e8 84 19 01 00       	call   f011db57 <log2_ceil>
f010c1d3:	83 c4 10             	add    $0x10,%esp
f010c1d6:	ba 01 00 00 00       	mov    $0x1,%edx
f010c1db:	88 c1                	mov    %al,%cl
f010c1dd:	d3 e2                	shl    %cl,%edx
f010c1df:	89 d0                	mov    %edx,%eax
f010c1e1:	01 d8                	add    %ebx,%eax
f010c1e3:	89 c3                	mov    %eax,%ebx
f010c1e5:	83 ec 0c             	sub    $0xc,%esp
f010c1e8:	68 ca 02 00 00       	push   $0x2ca
f010c1ed:	e8 30 19 01 00       	call   f011db22 <nearest_pow2_ceil>
f010c1f2:	83 c4 10             	add    $0x10,%esp
f010c1f5:	f7 d8                	neg    %eax
f010c1f7:	21 d8                	and    %ebx,%eax
f010c1f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c1fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c200:	7f 1e                	jg     f010c220 <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010c202:	83 ec 0c             	sub    $0xc,%esp
f010c205:	68 ca 02 00 00       	push   $0x2ca
f010c20a:	e8 48 19 01 00       	call   f011db57 <log2_ceil>
f010c20f:	83 c4 10             	add    $0x10,%esp
f010c212:	ba 01 00 00 00       	mov    $0x1,%edx
f010c217:	88 c1                	mov    %al,%cl
f010c219:	d3 e2                	shl    %cl,%edx
f010c21b:	89 d0                	mov    %edx,%eax
f010c21d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c220:	8b 45 08             	mov    0x8(%ebp),%eax
f010c223:	8b 15 d0 47 69 f0    	mov    0xf06947d0,%edx
f010c229:	29 d0                	sub    %edx,%eax
f010c22b:	c1 f8 02             	sar    $0x2,%eax
f010c22e:	89 c2                	mov    %eax,%edx
f010c230:	89 d0                	mov    %edx,%eax
f010c232:	c1 e0 03             	shl    $0x3,%eax
f010c235:	01 d0                	add    %edx,%eax
f010c237:	c1 e0 03             	shl    $0x3,%eax
f010c23a:	01 d0                	add    %edx,%eax
f010c23c:	c1 e0 02             	shl    $0x2,%eax
f010c23f:	01 d0                	add    %edx,%eax
f010c241:	01 c0                	add    %eax,%eax
f010c243:	01 d0                	add    %edx,%eax
f010c245:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010c24c:	01 c8                	add    %ecx,%eax
f010c24e:	c1 e0 02             	shl    $0x2,%eax
f010c251:	01 d0                	add    %edx,%eax
f010c253:	c1 e0 03             	shl    $0x3,%eax
f010c256:	01 d0                	add    %edx,%eax
f010c258:	c1 e0 05             	shl    $0x5,%eax
f010c25b:	29 d0                	sub    %edx,%eax
f010c25d:	c1 e0 02             	shl    $0x2,%eax
f010c260:	01 d0                	add    %edx,%eax
f010c262:	01 c0                	add    %eax,%eax
f010c264:	01 d0                	add    %edx,%eax
f010c266:	c1 e0 03             	shl    $0x3,%eax
f010c269:	01 d0                	add    %edx,%eax
f010c26b:	c1 e0 04             	shl    $0x4,%eax
f010c26e:	29 d0                	sub    %edx,%eax
f010c270:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c273:	89 c2                	mov    %eax,%edx
f010c275:	8b 45 08             	mov    0x8(%ebp),%eax
f010c278:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c27b:	e8 08 f1 ff ff       	call   f010b388 <get_cpu_proc>
f010c280:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c283:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c287:	75 0c                	jne    f010c295 <complete_environment_initialization+0x13e>
		e->env_parent_id = 0;//no parent;
f010c289:	8b 45 08             	mov    0x8(%ebp),%eax
f010c28c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c293:	eb 0c                	jmp    f010c2a1 <complete_environment_initialization+0x14a>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c295:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c298:	8b 50 10             	mov    0x10(%eax),%edx
f010c29b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c29e:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c2a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2a4:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c2ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2ae:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c2b5:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c2b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2bb:	8b 00                	mov    (%eax),%eax
f010c2bd:	83 ec 04             	sub    $0x4,%esp
f010c2c0:	6a 44                	push   $0x44
f010c2c2:	6a 00                	push   $0x0
f010c2c4:	50                   	push   %eax
f010c2c5:	e8 e8 34 01 00       	call   f011f7b2 <memset>
f010c2ca:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c2cd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2d0:	8b 00                	mov    (%eax),%eax
f010c2d2:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c2d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2db:	8b 00                	mov    (%eax),%eax
f010c2dd:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c2e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2e6:	8b 00                	mov    (%eax),%eax
f010c2e8:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c2ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f1:	8b 00                	mov    (%eax),%eax
f010c2f3:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c2fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2fd:	8b 00                	mov    (%eax),%eax
f010c2ff:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c305:	8b 45 08             	mov    0x8(%ebp),%eax
f010c308:	8b 00                	mov    (%eax),%eax
f010c30a:	8b 55 08             	mov    0x8(%ebp),%edx
f010c30d:	8b 12                	mov    (%edx),%edx
f010c30f:	8b 52 38             	mov    0x38(%edx),%edx
f010c312:	80 ce 02             	or     $0x2,%dh
f010c315:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c318:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c31c:	75 17                	jne    f010c335 <complete_environment_initialization+0x1de>
f010c31e:	83 ec 04             	sub    $0x4,%esp
f010c321:	68 f3 5b 12 f0       	push   $0xf0125bf3
f010c326:	68 67 04 00 00       	push   $0x467
f010c32b:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010c330:	e8 04 40 ff ff       	call   f0100339 <_panic>
f010c335:	8b 45 08             	mov    0x8(%ebp),%eax
f010c338:	8b 40 08             	mov    0x8(%eax),%eax
f010c33b:	85 c0                	test   %eax,%eax
f010c33d:	74 11                	je     f010c350 <complete_environment_initialization+0x1f9>
f010c33f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c342:	8b 40 08             	mov    0x8(%eax),%eax
f010c345:	8b 55 08             	mov    0x8(%ebp),%edx
f010c348:	8b 52 0c             	mov    0xc(%edx),%edx
f010c34b:	89 50 0c             	mov    %edx,0xc(%eax)
f010c34e:	eb 0b                	jmp    f010c35b <complete_environment_initialization+0x204>
f010c350:	8b 45 08             	mov    0x8(%ebp),%eax
f010c353:	8b 40 0c             	mov    0xc(%eax),%eax
f010c356:	a3 d8 47 69 f0       	mov    %eax,0xf06947d8
f010c35b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c35e:	8b 40 0c             	mov    0xc(%eax),%eax
f010c361:	85 c0                	test   %eax,%eax
f010c363:	74 11                	je     f010c376 <complete_environment_initialization+0x21f>
f010c365:	8b 45 08             	mov    0x8(%ebp),%eax
f010c368:	8b 40 0c             	mov    0xc(%eax),%eax
f010c36b:	8b 55 08             	mov    0x8(%ebp),%edx
f010c36e:	8b 52 08             	mov    0x8(%edx),%edx
f010c371:	89 50 08             	mov    %edx,0x8(%eax)
f010c374:	eb 0b                	jmp    f010c381 <complete_environment_initialization+0x22a>
f010c376:	8b 45 08             	mov    0x8(%ebp),%eax
f010c379:	8b 40 08             	mov    0x8(%eax),%eax
f010c37c:	a3 d4 47 69 f0       	mov    %eax,0xf06947d4
f010c381:	8b 45 08             	mov    0x8(%ebp),%eax
f010c384:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010c38b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c38e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c395:	a1 e0 47 69 f0       	mov    0xf06947e0,%eax
f010c39a:	48                   	dec    %eax
f010c39b:	a3 e0 47 69 f0       	mov    %eax,0xf06947e0
	return ;
f010c3a0:	90                   	nop
}
f010c3a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c3a4:	c9                   	leave  
f010c3a5:	c3                   	ret    

f010c3a6 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010c3a6:	55                   	push   %ebp
f010c3a7:	89 e5                	mov    %esp,%ebp
f010c3a9:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c3ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3af:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c3b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3b5:	8b 00                	mov    (%eax),%eax
f010c3b7:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c3bc:	74 17                	je     f010c3d5 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010c3be:	83 ec 04             	sub    $0x4,%esp
f010c3c1:	68 19 5e 12 f0       	push   $0xf0125e19
f010c3c6:	68 73 04 00 00       	push   $0x473
f010c3cb:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010c3d0:	e8 64 3f ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010c3d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3d8:	8b 00                	mov    (%eax),%eax
f010c3da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c3dd:	8b 52 18             	mov    0x18(%edx),%edx
f010c3e0:	89 50 30             	mov    %edx,0x30(%eax)
}
f010c3e3:	90                   	nop
f010c3e4:	c9                   	leave  
f010c3e5:	c3                   	ret    

f010c3e6 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010c3e6:	55                   	push   %ebp
f010c3e7:	89 e5                	mov    %esp,%ebp
f010c3e9:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010c3ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3ef:	8b 40 10             	mov    0x10(%eax),%eax
f010c3f2:	8d 48 01             	lea    0x1(%eax),%ecx
f010c3f5:	8b 55 08             	mov    0x8(%ebp),%edx
f010c3f8:	89 4a 10             	mov    %ecx,0x10(%edx)
f010c3fb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c3fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c401:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c404:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c407:	8b 00                	mov    (%eax),%eax
f010c409:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c40e:	74 17                	je     f010c427 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010c410:	83 ec 04             	sub    $0x4,%esp
f010c413:	68 19 5e 12 f0       	push   $0xf0125e19
f010c418:	68 81 04 00 00       	push   $0x481
f010c41d:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010c422:	e8 12 3f ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c427:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c42a:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c42d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c430:	01 d0                	add    %edx,%eax
f010c432:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010c435:	eb 0f                	jmp    f010c446 <PROGRAM_SEGMENT_NEXT+0x60>
f010c437:	8b 45 08             	mov    0x8(%ebp),%eax
f010c43a:	8b 40 10             	mov    0x10(%eax),%eax
f010c43d:	8d 50 01             	lea    0x1(%eax),%edx
f010c440:	8b 45 08             	mov    0x8(%ebp),%eax
f010c443:	89 50 10             	mov    %edx,0x10(%eax)
f010c446:	8b 45 08             	mov    0x8(%ebp),%eax
f010c449:	8b 40 10             	mov    0x10(%eax),%eax
f010c44c:	c1 e0 05             	shl    $0x5,%eax
f010c44f:	89 c2                	mov    %eax,%edx
f010c451:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c454:	01 d0                	add    %edx,%eax
f010c456:	8b 00                	mov    (%eax),%eax
f010c458:	83 f8 01             	cmp    $0x1,%eax
f010c45b:	74 13                	je     f010c470 <PROGRAM_SEGMENT_NEXT+0x8a>
f010c45d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c460:	8b 50 10             	mov    0x10(%eax),%edx
f010c463:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c466:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c469:	0f b7 c0             	movzwl %ax,%eax
f010c46c:	39 c2                	cmp    %eax,%edx
f010c46e:	72 c7                	jb     f010c437 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010c470:	8b 45 08             	mov    0x8(%ebp),%eax
f010c473:	8b 40 10             	mov    0x10(%eax),%eax
f010c476:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010c479:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c47c:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c47f:	0f b7 c0             	movzwl %ax,%eax
f010c482:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010c485:	7e 63                	jle    f010c4ea <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010c487:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c48a:	c1 e0 05             	shl    $0x5,%eax
f010c48d:	89 c2                	mov    %eax,%edx
f010c48f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c492:	01 d0                	add    %edx,%eax
f010c494:	8b 50 04             	mov    0x4(%eax),%edx
f010c497:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c49a:	01 c2                	add    %eax,%edx
f010c49c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c49f:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010c4a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4a4:	c1 e0 05             	shl    $0x5,%eax
f010c4a7:	89 c2                	mov    %eax,%edx
f010c4a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4ac:	01 d0                	add    %edx,%eax
f010c4ae:	8b 50 14             	mov    0x14(%eax),%edx
f010c4b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4b4:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010c4b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4ba:	c1 e0 05             	shl    $0x5,%eax
f010c4bd:	89 c2                	mov    %eax,%edx
f010c4bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4c2:	01 d0                	add    %edx,%eax
f010c4c4:	8b 50 10             	mov    0x10(%eax),%edx
f010c4c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4ca:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010c4cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4d0:	c1 e0 05             	shl    $0x5,%eax
f010c4d3:	89 c2                	mov    %eax,%edx
f010c4d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4d8:	01 d0                	add    %edx,%eax
f010c4da:	8b 40 08             	mov    0x8(%eax),%eax
f010c4dd:	89 c2                	mov    %eax,%edx
f010c4df:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e2:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010c4e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e8:	eb 05                	jmp    f010c4ef <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010c4ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c4ef:	c9                   	leave  
f010c4f0:	c3                   	ret    

f010c4f1 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010c4f1:	55                   	push   %ebp
f010c4f2:	89 e5                	mov    %esp,%ebp
f010c4f4:	57                   	push   %edi
f010c4f5:	56                   	push   %esi
f010c4f6:	53                   	push   %ebx
f010c4f7:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010c4fa:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c501:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c504:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c507:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c50a:	8b 00                	mov    (%eax),%eax
f010c50c:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c511:	74 17                	je     f010c52a <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010c513:	83 ec 04             	sub    $0x4,%esp
f010c516:	68 19 5e 12 f0       	push   $0xf0125e19
f010c51b:	68 9d 04 00 00       	push   $0x49d
f010c520:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010c525:	e8 0f 3e ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c52a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c52d:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c530:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c533:	01 d0                	add    %edx,%eax
f010c535:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010c538:	eb 07                	jmp    f010c541 <PROGRAM_SEGMENT_FIRST+0x50>
f010c53a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c53d:	40                   	inc    %eax
f010c53e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c541:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c544:	c1 e0 05             	shl    $0x5,%eax
f010c547:	89 c2                	mov    %eax,%edx
f010c549:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c54c:	01 d0                	add    %edx,%eax
f010c54e:	8b 00                	mov    (%eax),%eax
f010c550:	83 f8 01             	cmp    $0x1,%eax
f010c553:	74 10                	je     f010c565 <PROGRAM_SEGMENT_FIRST+0x74>
f010c555:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010c558:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c55b:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c55e:	0f b7 c0             	movzwl %ax,%eax
f010c561:	39 c2                	cmp    %eax,%edx
f010c563:	72 d5                	jb     f010c53a <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010c565:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c568:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010c56b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c56e:	8b 40 2c             	mov    0x2c(%eax),%eax
f010c571:	0f b7 c0             	movzwl %ax,%eax
f010c574:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010c577:	7e 68                	jle    f010c5e1 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010c579:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c57c:	c1 e0 05             	shl    $0x5,%eax
f010c57f:	89 c2                	mov    %eax,%edx
f010c581:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c584:	01 d0                	add    %edx,%eax
f010c586:	8b 50 04             	mov    0x4(%eax),%edx
f010c589:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c58c:	01 d0                	add    %edx,%eax
f010c58e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010c591:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c594:	c1 e0 05             	shl    $0x5,%eax
f010c597:	89 c2                	mov    %eax,%edx
f010c599:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c59c:	01 d0                	add    %edx,%eax
f010c59e:	8b 40 14             	mov    0x14(%eax),%eax
f010c5a1:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010c5a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c5a7:	c1 e0 05             	shl    $0x5,%eax
f010c5aa:	89 c2                	mov    %eax,%edx
f010c5ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c5af:	01 d0                	add    %edx,%eax
f010c5b1:	8b 40 10             	mov    0x10(%eax),%eax
f010c5b4:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010c5b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c5ba:	c1 e0 05             	shl    $0x5,%eax
f010c5bd:	89 c2                	mov    %eax,%edx
f010c5bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c5c2:	01 d0                	add    %edx,%eax
f010c5c4:	8b 40 08             	mov    0x8(%eax),%eax
f010c5c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010c5ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5cd:	89 c3                	mov    %eax,%ebx
f010c5cf:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010c5d2:	ba 05 00 00 00       	mov    $0x5,%edx
f010c5d7:	89 df                	mov    %ebx,%edi
f010c5d9:	89 c6                	mov    %eax,%esi
f010c5db:	89 d1                	mov    %edx,%ecx
f010c5dd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010c5df:	eb 1c                	jmp    f010c5fd <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010c5e1:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010c5e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5eb:	89 c3                	mov    %eax,%ebx
f010c5ed:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010c5f0:	ba 05 00 00 00       	mov    $0x5,%edx
f010c5f5:	89 df                	mov    %ebx,%edi
f010c5f7:	89 c6                	mov    %eax,%esi
f010c5f9:	89 d1                	mov    %edx,%ecx
f010c5fb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010c5fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c600:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010c603:	5b                   	pop    %ebx
f010c604:	5e                   	pop    %esi
f010c605:	5f                   	pop    %edi
f010c606:	5d                   	pop    %ebp
f010c607:	c2 04 00             	ret    $0x4

f010c60a <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010c60a:	55                   	push   %ebp
f010c60b:	89 e5                	mov    %esp,%ebp
f010c60d:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010c610:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010c617:	83 ec 0c             	sub    $0xc,%esp
f010c61a:	68 80 d3 6b f0       	push   $0xf06bd380
f010c61f:	e8 f2 2f 00 00       	call   f010f616 <acquire_spinlock>
f010c624:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010c627:	a1 70 d3 6b f0       	mov    0xf06bd370,%eax
f010c62c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c62f:	e9 c3 00 00 00       	jmp    f010c6f7 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010c634:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c637:	8b 40 0c             	mov    0xc(%eax),%eax
f010c63a:	3b 45 08             	cmp    0x8(%ebp),%eax
f010c63d:	0f 85 ac 00 00 00    	jne    f010c6ef <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010c643:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c646:	8b 50 10             	mov    0x10(%eax),%edx
f010c649:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c64c:	8b 40 0c             	mov    0xc(%eax),%eax
f010c64f:	8b 40 64             	mov    0x64(%eax),%eax
f010c652:	83 ec 08             	sub    $0x8,%esp
f010c655:	52                   	push   %edx
f010c656:	50                   	push   %eax
f010c657:	e8 79 d0 ff ff       	call   f01096d5 <pt_clear_page_table_entry>
f010c65c:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010c65f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c663:	75 17                	jne    f010c67c <cleanup_buffers+0x72>
f010c665:	83 ec 04             	sub    $0x4,%esp
f010c668:	68 f3 5b 12 f0       	push   $0xf0125bf3
f010c66d:	68 c6 04 00 00       	push   $0x4c6
f010c672:	68 6b 5b 12 f0       	push   $0xf0125b6b
f010c677:	e8 bd 3c ff ff       	call   f0100339 <_panic>
f010c67c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c67f:	8b 00                	mov    (%eax),%eax
f010c681:	85 c0                	test   %eax,%eax
f010c683:	74 10                	je     f010c695 <cleanup_buffers+0x8b>
f010c685:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c688:	8b 00                	mov    (%eax),%eax
f010c68a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c68d:	8b 52 04             	mov    0x4(%edx),%edx
f010c690:	89 50 04             	mov    %edx,0x4(%eax)
f010c693:	eb 0b                	jmp    f010c6a0 <cleanup_buffers+0x96>
f010c695:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c698:	8b 40 04             	mov    0x4(%eax),%eax
f010c69b:	a3 74 d3 6b f0       	mov    %eax,0xf06bd374
f010c6a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6a3:	8b 40 04             	mov    0x4(%eax),%eax
f010c6a6:	85 c0                	test   %eax,%eax
f010c6a8:	74 0f                	je     f010c6b9 <cleanup_buffers+0xaf>
f010c6aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6ad:	8b 40 04             	mov    0x4(%eax),%eax
f010c6b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c6b3:	8b 12                	mov    (%edx),%edx
f010c6b5:	89 10                	mov    %edx,(%eax)
f010c6b7:	eb 0a                	jmp    f010c6c3 <cleanup_buffers+0xb9>
f010c6b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6bc:	8b 00                	mov    (%eax),%eax
f010c6be:	a3 70 d3 6b f0       	mov    %eax,0xf06bd370
f010c6c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6c6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010c6cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c6cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010c6d6:	a1 7c d3 6b f0       	mov    0xf06bd37c,%eax
f010c6db:	48                   	dec    %eax
f010c6dc:	a3 7c d3 6b f0       	mov    %eax,0xf06bd37c

				free_frame(ptr_fi);
f010c6e1:	83 ec 0c             	sub    $0xc,%esp
f010c6e4:	ff 75 f4             	pushl  -0xc(%ebp)
f010c6e7:	e8 1a bc ff ff       	call   f0108306 <free_frame>
f010c6ec:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010c6ef:	a1 78 d3 6b f0       	mov    0xf06bd378,%eax
f010c6f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010c6f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c6fb:	74 07                	je     f010c704 <cleanup_buffers+0xfa>
f010c6fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c700:	8b 00                	mov    (%eax),%eax
f010c702:	eb 05                	jmp    f010c709 <cleanup_buffers+0xff>
f010c704:	b8 00 00 00 00       	mov    $0x0,%eax
f010c709:	a3 78 d3 6b f0       	mov    %eax,0xf06bd378
f010c70e:	a1 78 d3 6b f0       	mov    0xf06bd378,%eax
f010c713:	85 c0                	test   %eax,%eax
f010c715:	0f 85 19 ff ff ff    	jne    f010c634 <cleanup_buffers+0x2a>
f010c71b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c71f:	0f 85 0f ff ff ff    	jne    f010c634 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010c725:	83 ec 0c             	sub    $0xc,%esp
f010c728:	68 80 d3 6b f0       	push   $0xf06bd380
f010c72d:	e8 6b 2f 00 00       	call   f010f69d <release_spinlock>
f010c732:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010c735:	90                   	nop
f010c736:	c9                   	leave  
f010c737:	c3                   	ret    

f010c738 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010c738:	55                   	push   %ebp
f010c739:	89 e5                	mov    %esp,%ebp
f010c73b:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010c73e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010c742:	7e 06                	jle    f010c74a <set_program_priority+0x12>
f010c744:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010c748:	7e 14                	jle    f010c75e <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010c74a:	83 ec 04             	sub    $0x4,%esp
f010c74d:	68 30 5e 12 f0       	push   $0xf0125e30
f010c752:	6a 10                	push   $0x10
f010c754:	68 54 5e 12 f0       	push   $0xf0125e54
f010c759:	e8 db 3b ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010c75e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c762:	74 78                	je     f010c7dc <set_program_priority+0xa4>
		return;
	switch(priority)
f010c764:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010c768:	77 56                	ja     f010c7c0 <set_program_priority+0x88>
f010c76a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c76d:	c1 e0 02             	shl    $0x2,%eax
f010c770:	05 90 5e 12 f0       	add    $0xf0125e90,%eax
f010c775:	8b 00                	mov    (%eax),%eax
f010c777:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010c779:	83 ec 08             	sub    $0x8,%esp
f010c77c:	6a 01                	push   $0x1
f010c77e:	ff 75 08             	pushl  0x8(%ebp)
f010c781:	e8 a6 dc ff ff       	call   f010a42c <half_WS_Size>
f010c786:	83 c4 10             	add    $0x10,%esp
			break;
f010c789:	eb 35                	jmp    f010c7c0 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010c78b:	83 ec 08             	sub    $0x8,%esp
f010c78e:	6a 00                	push   $0x0
f010c790:	ff 75 08             	pushl  0x8(%ebp)
f010c793:	e8 94 dc ff ff       	call   f010a42c <half_WS_Size>
f010c798:	83 c4 10             	add    $0x10,%esp
			break;
f010c79b:	eb 23                	jmp    f010c7c0 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010c79d:	83 ec 08             	sub    $0x8,%esp
f010c7a0:	6a 01                	push   $0x1
f010c7a2:	ff 75 08             	pushl  0x8(%ebp)
f010c7a5:	e8 65 dc ff ff       	call   f010a40f <double_WS_Size>
f010c7aa:	83 c4 10             	add    $0x10,%esp
			break;
f010c7ad:	eb 11                	jmp    f010c7c0 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010c7af:	83 ec 08             	sub    $0x8,%esp
f010c7b2:	6a 00                	push   $0x0
f010c7b4:	ff 75 08             	pushl  0x8(%ebp)
f010c7b7:	e8 53 dc ff ff       	call   f010a40f <double_WS_Size>
f010c7bc:	83 c4 10             	add    $0x10,%esp
			break;
f010c7bf:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010c7c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c7c9:	83 ec 08             	sub    $0x8,%esp
f010c7cc:	50                   	push   %eax
f010c7cd:	68 71 5e 12 f0       	push   $0xf0125e71
f010c7d2:	e8 b4 47 ff ff       	call   f0100f8b <cprintf>
f010c7d7:	83 c4 10             	add    $0x10,%esp
f010c7da:	eb 01                	jmp    f010c7dd <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010c7dc:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010c7dd:	c9                   	leave  
f010c7de:	c3                   	ret    

f010c7df <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010c7df:	55                   	push   %ebp
f010c7e0:	89 e5                	mov    %esp,%ebp
f010c7e2:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c7e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c7ec:	eb 29                	jmp    f010c817 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010c7ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c7f1:	89 d0                	mov    %edx,%eax
f010c7f3:	01 c0                	add    %eax,%eax
f010c7f5:	01 d0                	add    %edx,%eax
f010c7f7:	c1 e0 02             	shl    $0x2,%eax
f010c7fa:	05 80 e9 17 f0       	add    $0xf017e980,%eax
f010c7ff:	8b 00                	mov    (%eax),%eax
f010c801:	83 ec 08             	sub    $0x8,%esp
f010c804:	50                   	push   %eax
f010c805:	ff 75 08             	pushl  0x8(%ebp)
f010c808:	e8 c3 2e 01 00       	call   f011f6d0 <strcmp>
f010c80d:	83 c4 10             	add    $0x10,%esp
f010c810:	85 c0                	test   %eax,%eax
f010c812:	74 0f                	je     f010c823 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c814:	ff 45 f4             	incl   -0xc(%ebp)
f010c817:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c81c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c81f:	7c cd                	jl     f010c7ee <get_user_program_info+0xf>
f010c821:	eb 01                	jmp    f010c824 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010c823:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c824:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c829:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c82c:	75 1a                	jne    f010c848 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010c82e:	83 ec 08             	sub    $0x8,%esp
f010c831:	ff 75 08             	pushl  0x8(%ebp)
f010c834:	68 f5 6b 12 f0       	push   $0xf0126bf5
f010c839:	e8 4d 47 ff ff       	call   f0100f8b <cprintf>
f010c83e:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c841:	b8 00 00 00 00       	mov    $0x0,%eax
f010c846:	eb 11                	jmp    f010c859 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010c848:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c84b:	89 d0                	mov    %edx,%eax
f010c84d:	01 c0                	add    %eax,%eax
f010c84f:	01 d0                	add    %edx,%eax
f010c851:	c1 e0 02             	shl    $0x2,%eax
f010c854:	05 80 e9 17 f0       	add    $0xf017e980,%eax
}
f010c859:	c9                   	leave  
f010c85a:	c3                   	ret    

f010c85b <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010c85b:	55                   	push   %ebp
f010c85c:	89 e5                	mov    %esp,%ebp
f010c85e:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c861:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c868:	eb 2d                	jmp    f010c897 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010c86a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c86d:	89 d0                	mov    %edx,%eax
f010c86f:	01 c0                	add    %eax,%eax
f010c871:	01 d0                	add    %edx,%eax
f010c873:	c1 e0 02             	shl    $0x2,%eax
f010c876:	05 80 e9 17 f0       	add    $0xf017e980,%eax
f010c87b:	8b 00                	mov    (%eax),%eax
f010c87d:	8b 55 08             	mov    0x8(%ebp),%edx
f010c880:	83 c2 20             	add    $0x20,%edx
f010c883:	83 ec 08             	sub    $0x8,%esp
f010c886:	50                   	push   %eax
f010c887:	52                   	push   %edx
f010c888:	e8 43 2e 01 00       	call   f011f6d0 <strcmp>
f010c88d:	83 c4 10             	add    $0x10,%esp
f010c890:	85 c0                	test   %eax,%eax
f010c892:	74 0f                	je     f010c8a3 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c894:	ff 45 f4             	incl   -0xc(%ebp)
f010c897:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c89c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c89f:	7c c9                	jl     f010c86a <get_user_program_info_by_env+0xf>
f010c8a1:	eb 01                	jmp    f010c8a4 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010c8a3:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c8a4:	a1 e4 ec 17 f0       	mov    0xf017ece4,%eax
f010c8a9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c8ac:	75 17                	jne    f010c8c5 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010c8ae:	83 ec 0c             	sub    $0xc,%esp
f010c8b1:	68 10 6c 12 f0       	push   $0xf0126c10
f010c8b6:	e8 d0 46 ff ff       	call   f0100f8b <cprintf>
f010c8bb:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c8be:	b8 00 00 00 00       	mov    $0x0,%eax
f010c8c3:	eb 11                	jmp    f010c8d6 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010c8c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c8c8:	89 d0                	mov    %edx,%eax
f010c8ca:	01 c0                	add    %eax,%eax
f010c8cc:	01 d0                	add    %edx,%eax
f010c8ce:	c1 e0 02             	shl    $0x2,%eax
f010c8d1:	05 80 e9 17 f0       	add    $0xf017e980,%eax
}
f010c8d6:	c9                   	leave  
f010c8d7:	c3                   	ret    

f010c8d8 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010c8d8:	55                   	push   %ebp
f010c8d9:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010c8db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8de:	83 f8 13             	cmp    $0x13,%eax
f010c8e1:	77 0c                	ja     f010c8ef <trapname+0x17>
		return excnames[trapno];
f010c8e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8e6:	8b 04 85 00 70 12 f0 	mov    -0xfed9000(,%eax,4),%eax
f010c8ed:	eb 2c                	jmp    f010c91b <trapname+0x43>
	if (trapno == T_SYSCALL)
f010c8ef:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010c8f3:	75 07                	jne    f010c8fc <trapname+0x24>
		return "System call";
f010c8f5:	b8 40 6c 12 f0       	mov    $0xf0126c40,%eax
f010c8fa:	eb 1f                	jmp    f010c91b <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010c8fc:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010c900:	75 07                	jne    f010c909 <trapname+0x31>
		return "Clock Interrupt";
f010c902:	b8 4c 6c 12 f0       	mov    $0xf0126c4c,%eax
f010c907:	eb 12                	jmp    f010c91b <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010c909:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010c90d:	75 07                	jne    f010c916 <trapname+0x3e>
		return "Keyboard Interrupt";
f010c90f:	b8 5c 6c 12 f0       	mov    $0xf0126c5c,%eax
f010c914:	eb 05                	jmp    f010c91b <trapname+0x43>
	return "(unknown trap)";
f010c916:	b8 6f 6c 12 f0       	mov    $0xf0126c6f,%eax
}
f010c91b:	5d                   	pop    %ebp
f010c91c:	c3                   	ret    

f010c91d <ts_init>:


void ts_init(void)
{
f010c91d:	55                   	push   %ebp
f010c91e:	89 e5                	mov    %esp,%ebp
f010c920:	53                   	push   %ebx
f010c921:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010c924:	e8 a6 a8 ff ff       	call   f01071cf <pushcli>

	struct cpu* c = mycpu();
f010c929:	e8 de a7 ff ff       	call   f010710c <mycpu>
f010c92e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010c931:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c934:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c93b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c93e:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c944:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c947:	83 c0 0c             	add    $0xc,%eax
f010c94a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c94d:	83 c2 0c             	add    $0xc,%edx
f010c950:	c1 ea 10             	shr    $0x10,%edx
f010c953:	88 d3                	mov    %dl,%bl
f010c955:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c958:	83 c2 0c             	add    $0xc,%edx
f010c95b:	c1 ea 18             	shr    $0x18,%edx
f010c95e:	88 d1                	mov    %dl,%cl
f010c960:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c963:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c96a:	68 00 
f010c96c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c96f:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c976:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c979:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c97f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c982:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c988:	83 e2 f0             	and    $0xfffffff0,%edx
f010c98b:	83 ca 09             	or     $0x9,%edx
f010c98e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c994:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c997:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c99d:	83 ca 10             	or     $0x10,%edx
f010c9a0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c9a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9a9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c9af:	83 e2 9f             	and    $0xffffff9f,%edx
f010c9b2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c9b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9bb:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c9c1:	83 ca 80             	or     $0xffffff80,%edx
f010c9c4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c9ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9cd:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c9d3:	83 e2 f0             	and    $0xfffffff0,%edx
f010c9d6:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c9dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9df:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c9e5:	83 e2 ef             	and    $0xffffffef,%edx
f010c9e8:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c9ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9f1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c9f7:	83 e2 df             	and    $0xffffffdf,%edx
f010c9fa:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ca00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca03:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ca09:	83 ca 40             	or     $0x40,%edx
f010ca0c:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ca12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca15:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010ca1b:	83 e2 7f             	and    $0x7f,%edx
f010ca1e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010ca24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca27:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010ca2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca30:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010ca36:	83 e2 ef             	and    $0xffffffef,%edx
f010ca39:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010ca3f:	e8 dd a7 ff ff       	call   f0107221 <popcli>
f010ca44:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010ca4a:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010ca4e:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010ca51:	90                   	nop
f010ca52:	83 c4 14             	add    $0x14,%esp
f010ca55:	5b                   	pop    %ebx
f010ca56:	5d                   	pop    %ebp
f010ca57:	c3                   	ret    

f010ca58 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010ca58:	55                   	push   %ebp
f010ca59:	89 e5                	mov    %esp,%ebp
f010ca5b:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010ca5e:	b8 06 df 10 f0       	mov    $0xf010df06,%eax
f010ca63:	66 a3 40 48 69 f0    	mov    %ax,0xf0694840
f010ca69:	66 c7 05 42 48 69 f0 	movw   $0x8,0xf0694842
f010ca70:	08 00 
f010ca72:	a0 44 48 69 f0       	mov    0xf0694844,%al
f010ca77:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca7a:	a2 44 48 69 f0       	mov    %al,0xf0694844
f010ca7f:	a0 44 48 69 f0       	mov    0xf0694844,%al
f010ca84:	83 e0 1f             	and    $0x1f,%eax
f010ca87:	a2 44 48 69 f0       	mov    %al,0xf0694844
f010ca8c:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010ca91:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca94:	83 c8 0e             	or     $0xe,%eax
f010ca97:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010ca9c:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010caa1:	83 e0 ef             	and    $0xffffffef,%eax
f010caa4:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010caa9:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010caae:	83 e0 9f             	and    $0xffffff9f,%eax
f010cab1:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010cab6:	a0 45 48 69 f0       	mov    0xf0694845,%al
f010cabb:	83 c8 80             	or     $0xffffff80,%eax
f010cabe:	a2 45 48 69 f0       	mov    %al,0xf0694845
f010cac3:	b8 06 df 10 f0       	mov    $0xf010df06,%eax
f010cac8:	c1 e8 10             	shr    $0x10,%eax
f010cacb:	66 a3 46 48 69 f0    	mov    %ax,0xf0694846
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010cad1:	b8 0e df 10 f0       	mov    $0xf010df0e,%eax
f010cad6:	66 a3 70 48 69 f0    	mov    %ax,0xf0694870
f010cadc:	66 c7 05 72 48 69 f0 	movw   $0x8,0xf0694872
f010cae3:	08 00 
f010cae5:	a0 74 48 69 f0       	mov    0xf0694874,%al
f010caea:	83 e0 e0             	and    $0xffffffe0,%eax
f010caed:	a2 74 48 69 f0       	mov    %al,0xf0694874
f010caf2:	a0 74 48 69 f0       	mov    0xf0694874,%al
f010caf7:	83 e0 1f             	and    $0x1f,%eax
f010cafa:	a2 74 48 69 f0       	mov    %al,0xf0694874
f010caff:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb04:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb07:	83 c8 0e             	or     $0xe,%eax
f010cb0a:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb0f:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb14:	83 e0 ef             	and    $0xffffffef,%eax
f010cb17:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb1c:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb21:	83 e0 9f             	and    $0xffffff9f,%eax
f010cb24:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb29:	a0 75 48 69 f0       	mov    0xf0694875,%al
f010cb2e:	83 c8 80             	or     $0xffffff80,%eax
f010cb31:	a2 75 48 69 f0       	mov    %al,0xf0694875
f010cb36:	b8 0e df 10 f0       	mov    $0xf010df0e,%eax
f010cb3b:	c1 e8 10             	shr    $0x10,%eax
f010cb3e:	66 a3 76 48 69 f0    	mov    %ax,0xf0694876
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010cb44:	b8 16 df 10 f0       	mov    $0xf010df16,%eax
f010cb49:	66 a3 00 49 69 f0    	mov    %ax,0xf0694900
f010cb4f:	66 c7 05 02 49 69 f0 	movw   $0x8,0xf0694902
f010cb56:	08 00 
f010cb58:	a0 04 49 69 f0       	mov    0xf0694904,%al
f010cb5d:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb60:	a2 04 49 69 f0       	mov    %al,0xf0694904
f010cb65:	a0 04 49 69 f0       	mov    0xf0694904,%al
f010cb6a:	83 e0 1f             	and    $0x1f,%eax
f010cb6d:	a2 04 49 69 f0       	mov    %al,0xf0694904
f010cb72:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cb77:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb7a:	83 c8 0e             	or     $0xe,%eax
f010cb7d:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cb82:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cb87:	83 e0 ef             	and    $0xffffffef,%eax
f010cb8a:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cb8f:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cb94:	83 c8 60             	or     $0x60,%eax
f010cb97:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cb9c:	a0 05 49 69 f0       	mov    0xf0694905,%al
f010cba1:	83 c8 80             	or     $0xffffff80,%eax
f010cba4:	a2 05 49 69 f0       	mov    %al,0xf0694905
f010cba9:	b8 16 df 10 f0       	mov    $0xf010df16,%eax
f010cbae:	c1 e8 10             	shr    $0x10,%eax
f010cbb1:	66 a3 06 49 69 f0    	mov    %ax,0xf0694906
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010cbb7:	b8 20 df 10 f0       	mov    $0xf010df20,%eax
f010cbbc:	66 a3 08 49 69 f0    	mov    %ax,0xf0694908
f010cbc2:	66 c7 05 0a 49 69 f0 	movw   $0x8,0xf069490a
f010cbc9:	08 00 
f010cbcb:	a0 0c 49 69 f0       	mov    0xf069490c,%al
f010cbd0:	83 e0 e0             	and    $0xffffffe0,%eax
f010cbd3:	a2 0c 49 69 f0       	mov    %al,0xf069490c
f010cbd8:	a0 0c 49 69 f0       	mov    0xf069490c,%al
f010cbdd:	83 e0 1f             	and    $0x1f,%eax
f010cbe0:	a2 0c 49 69 f0       	mov    %al,0xf069490c
f010cbe5:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cbea:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbed:	83 c8 0e             	or     $0xe,%eax
f010cbf0:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cbf5:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cbfa:	83 e0 ef             	and    $0xffffffef,%eax
f010cbfd:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cc02:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cc07:	83 c8 60             	or     $0x60,%eax
f010cc0a:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cc0f:	a0 0d 49 69 f0       	mov    0xf069490d,%al
f010cc14:	83 c8 80             	or     $0xffffff80,%eax
f010cc17:	a2 0d 49 69 f0       	mov    %al,0xf069490d
f010cc1c:	b8 20 df 10 f0       	mov    $0xf010df20,%eax
f010cc21:	c1 e8 10             	shr    $0x10,%eax
f010cc24:	66 a3 0e 49 69 f0    	mov    %ax,0xf069490e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010cc2a:	b8 2a df 10 f0       	mov    $0xf010df2a,%eax
f010cc2f:	66 a3 80 49 69 f0    	mov    %ax,0xf0694980
f010cc35:	66 c7 05 82 49 69 f0 	movw   $0x8,0xf0694982
f010cc3c:	08 00 
f010cc3e:	a0 84 49 69 f0       	mov    0xf0694984,%al
f010cc43:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc46:	a2 84 49 69 f0       	mov    %al,0xf0694984
f010cc4b:	a0 84 49 69 f0       	mov    0xf0694984,%al
f010cc50:	83 e0 1f             	and    $0x1f,%eax
f010cc53:	a2 84 49 69 f0       	mov    %al,0xf0694984
f010cc58:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cc5d:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc60:	83 c8 0e             	or     $0xe,%eax
f010cc63:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010cc68:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cc6d:	83 e0 ef             	and    $0xffffffef,%eax
f010cc70:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010cc75:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cc7a:	83 c8 60             	or     $0x60,%eax
f010cc7d:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010cc82:	a0 85 49 69 f0       	mov    0xf0694985,%al
f010cc87:	83 c8 80             	or     $0xffffff80,%eax
f010cc8a:	a2 85 49 69 f0       	mov    %al,0xf0694985
f010cc8f:	b8 2a df 10 f0       	mov    $0xf010df2a,%eax
f010cc94:	c1 e8 10             	shr    $0x10,%eax
f010cc97:	66 a3 86 49 69 f0    	mov    %ax,0xf0694986

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010cc9d:	b8 34 df 10 f0       	mov    $0xf010df34,%eax
f010cca2:	66 a3 00 48 69 f0    	mov    %ax,0xf0694800
f010cca8:	66 c7 05 02 48 69 f0 	movw   $0x8,0xf0694802
f010ccaf:	08 00 
f010ccb1:	a0 04 48 69 f0       	mov    0xf0694804,%al
f010ccb6:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccb9:	a2 04 48 69 f0       	mov    %al,0xf0694804
f010ccbe:	a0 04 48 69 f0       	mov    0xf0694804,%al
f010ccc3:	83 e0 1f             	and    $0x1f,%eax
f010ccc6:	a2 04 48 69 f0       	mov    %al,0xf0694804
f010cccb:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010ccd0:	83 e0 f0             	and    $0xfffffff0,%eax
f010ccd3:	83 c8 0e             	or     $0xe,%eax
f010ccd6:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010ccdb:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010cce0:	83 e0 ef             	and    $0xffffffef,%eax
f010cce3:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010cce8:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010cced:	83 c8 60             	or     $0x60,%eax
f010ccf0:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010ccf5:	a0 05 48 69 f0       	mov    0xf0694805,%al
f010ccfa:	83 c8 80             	or     $0xffffff80,%eax
f010ccfd:	a2 05 48 69 f0       	mov    %al,0xf0694805
f010cd02:	b8 34 df 10 f0       	mov    $0xf010df34,%eax
f010cd07:	c1 e8 10             	shr    $0x10,%eax
f010cd0a:	66 a3 06 48 69 f0    	mov    %ax,0xf0694806
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010cd10:	b8 3e df 10 f0       	mov    $0xf010df3e,%eax
f010cd15:	66 a3 08 48 69 f0    	mov    %ax,0xf0694808
f010cd1b:	66 c7 05 0a 48 69 f0 	movw   $0x8,0xf069480a
f010cd22:	08 00 
f010cd24:	a0 0c 48 69 f0       	mov    0xf069480c,%al
f010cd29:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd2c:	a2 0c 48 69 f0       	mov    %al,0xf069480c
f010cd31:	a0 0c 48 69 f0       	mov    0xf069480c,%al
f010cd36:	83 e0 1f             	and    $0x1f,%eax
f010cd39:	a2 0c 48 69 f0       	mov    %al,0xf069480c
f010cd3e:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd43:	83 c8 0f             	or     $0xf,%eax
f010cd46:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd4b:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd50:	83 e0 ef             	and    $0xffffffef,%eax
f010cd53:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd58:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd5d:	83 c8 60             	or     $0x60,%eax
f010cd60:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd65:	a0 0d 48 69 f0       	mov    0xf069480d,%al
f010cd6a:	83 c8 80             	or     $0xffffff80,%eax
f010cd6d:	a2 0d 48 69 f0       	mov    %al,0xf069480d
f010cd72:	b8 3e df 10 f0       	mov    $0xf010df3e,%eax
f010cd77:	c1 e8 10             	shr    $0x10,%eax
f010cd7a:	66 a3 0e 48 69 f0    	mov    %ax,0xf069480e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010cd80:	b8 48 df 10 f0       	mov    $0xf010df48,%eax
f010cd85:	66 a3 10 48 69 f0    	mov    %ax,0xf0694810
f010cd8b:	66 c7 05 12 48 69 f0 	movw   $0x8,0xf0694812
f010cd92:	08 00 
f010cd94:	a0 14 48 69 f0       	mov    0xf0694814,%al
f010cd99:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd9c:	a2 14 48 69 f0       	mov    %al,0xf0694814
f010cda1:	a0 14 48 69 f0       	mov    0xf0694814,%al
f010cda6:	83 e0 1f             	and    $0x1f,%eax
f010cda9:	a2 14 48 69 f0       	mov    %al,0xf0694814
f010cdae:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cdb3:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdb6:	83 c8 0e             	or     $0xe,%eax
f010cdb9:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010cdbe:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cdc3:	83 e0 ef             	and    $0xffffffef,%eax
f010cdc6:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010cdcb:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cdd0:	83 c8 60             	or     $0x60,%eax
f010cdd3:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010cdd8:	a0 15 48 69 f0       	mov    0xf0694815,%al
f010cddd:	83 c8 80             	or     $0xffffff80,%eax
f010cde0:	a2 15 48 69 f0       	mov    %al,0xf0694815
f010cde5:	b8 48 df 10 f0       	mov    $0xf010df48,%eax
f010cdea:	c1 e8 10             	shr    $0x10,%eax
f010cded:	66 a3 16 48 69 f0    	mov    %ax,0xf0694816
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010cdf3:	b8 52 df 10 f0       	mov    $0xf010df52,%eax
f010cdf8:	66 a3 18 48 69 f0    	mov    %ax,0xf0694818
f010cdfe:	66 c7 05 1a 48 69 f0 	movw   $0x8,0xf069481a
f010ce05:	08 00 
f010ce07:	a0 1c 48 69 f0       	mov    0xf069481c,%al
f010ce0c:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce0f:	a2 1c 48 69 f0       	mov    %al,0xf069481c
f010ce14:	a0 1c 48 69 f0       	mov    0xf069481c,%al
f010ce19:	83 e0 1f             	and    $0x1f,%eax
f010ce1c:	a2 1c 48 69 f0       	mov    %al,0xf069481c
f010ce21:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce26:	83 c8 0f             	or     $0xf,%eax
f010ce29:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce2e:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce33:	83 e0 ef             	and    $0xffffffef,%eax
f010ce36:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce3b:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce40:	83 c8 60             	or     $0x60,%eax
f010ce43:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce48:	a0 1d 48 69 f0       	mov    0xf069481d,%al
f010ce4d:	83 c8 80             	or     $0xffffff80,%eax
f010ce50:	a2 1d 48 69 f0       	mov    %al,0xf069481d
f010ce55:	b8 52 df 10 f0       	mov    $0xf010df52,%eax
f010ce5a:	c1 e8 10             	shr    $0x10,%eax
f010ce5d:	66 a3 1e 48 69 f0    	mov    %ax,0xf069481e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010ce63:	b8 5c df 10 f0       	mov    $0xf010df5c,%eax
f010ce68:	66 a3 20 48 69 f0    	mov    %ax,0xf0694820
f010ce6e:	66 c7 05 22 48 69 f0 	movw   $0x8,0xf0694822
f010ce75:	08 00 
f010ce77:	a0 24 48 69 f0       	mov    0xf0694824,%al
f010ce7c:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce7f:	a2 24 48 69 f0       	mov    %al,0xf0694824
f010ce84:	a0 24 48 69 f0       	mov    0xf0694824,%al
f010ce89:	83 e0 1f             	and    $0x1f,%eax
f010ce8c:	a2 24 48 69 f0       	mov    %al,0xf0694824
f010ce91:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010ce96:	83 c8 0f             	or     $0xf,%eax
f010ce99:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010ce9e:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010cea3:	83 e0 ef             	and    $0xffffffef,%eax
f010cea6:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010ceab:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010ceb0:	83 c8 60             	or     $0x60,%eax
f010ceb3:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010ceb8:	a0 25 48 69 f0       	mov    0xf0694825,%al
f010cebd:	83 c8 80             	or     $0xffffff80,%eax
f010cec0:	a2 25 48 69 f0       	mov    %al,0xf0694825
f010cec5:	b8 5c df 10 f0       	mov    $0xf010df5c,%eax
f010ceca:	c1 e8 10             	shr    $0x10,%eax
f010cecd:	66 a3 26 48 69 f0    	mov    %ax,0xf0694826
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010ced3:	b8 66 df 10 f0       	mov    $0xf010df66,%eax
f010ced8:	66 a3 28 48 69 f0    	mov    %ax,0xf0694828
f010cede:	66 c7 05 2a 48 69 f0 	movw   $0x8,0xf069482a
f010cee5:	08 00 
f010cee7:	a0 2c 48 69 f0       	mov    0xf069482c,%al
f010ceec:	83 e0 e0             	and    $0xffffffe0,%eax
f010ceef:	a2 2c 48 69 f0       	mov    %al,0xf069482c
f010cef4:	a0 2c 48 69 f0       	mov    0xf069482c,%al
f010cef9:	83 e0 1f             	and    $0x1f,%eax
f010cefc:	a2 2c 48 69 f0       	mov    %al,0xf069482c
f010cf01:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf06:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf09:	83 c8 0e             	or     $0xe,%eax
f010cf0c:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf11:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf16:	83 e0 ef             	and    $0xffffffef,%eax
f010cf19:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf1e:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf23:	83 c8 60             	or     $0x60,%eax
f010cf26:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf2b:	a0 2d 48 69 f0       	mov    0xf069482d,%al
f010cf30:	83 c8 80             	or     $0xffffff80,%eax
f010cf33:	a2 2d 48 69 f0       	mov    %al,0xf069482d
f010cf38:	b8 66 df 10 f0       	mov    $0xf010df66,%eax
f010cf3d:	c1 e8 10             	shr    $0x10,%eax
f010cf40:	66 a3 2e 48 69 f0    	mov    %ax,0xf069482e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010cf46:	b8 70 df 10 f0       	mov    $0xf010df70,%eax
f010cf4b:	66 a3 30 48 69 f0    	mov    %ax,0xf0694830
f010cf51:	66 c7 05 32 48 69 f0 	movw   $0x8,0xf0694832
f010cf58:	08 00 
f010cf5a:	a0 34 48 69 f0       	mov    0xf0694834,%al
f010cf5f:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf62:	a2 34 48 69 f0       	mov    %al,0xf0694834
f010cf67:	a0 34 48 69 f0       	mov    0xf0694834,%al
f010cf6c:	83 e0 1f             	and    $0x1f,%eax
f010cf6f:	a2 34 48 69 f0       	mov    %al,0xf0694834
f010cf74:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cf79:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf7c:	83 c8 0e             	or     $0xe,%eax
f010cf7f:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cf84:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cf89:	83 e0 ef             	and    $0xffffffef,%eax
f010cf8c:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cf91:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cf96:	83 c8 60             	or     $0x60,%eax
f010cf99:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cf9e:	a0 35 48 69 f0       	mov    0xf0694835,%al
f010cfa3:	83 c8 80             	or     $0xffffff80,%eax
f010cfa6:	a2 35 48 69 f0       	mov    %al,0xf0694835
f010cfab:	b8 70 df 10 f0       	mov    $0xf010df70,%eax
f010cfb0:	c1 e8 10             	shr    $0x10,%eax
f010cfb3:	66 a3 36 48 69 f0    	mov    %ax,0xf0694836
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010cfb9:	b8 7a df 10 f0       	mov    $0xf010df7a,%eax
f010cfbe:	66 a3 38 48 69 f0    	mov    %ax,0xf0694838
f010cfc4:	66 c7 05 3a 48 69 f0 	movw   $0x8,0xf069483a
f010cfcb:	08 00 
f010cfcd:	a0 3c 48 69 f0       	mov    0xf069483c,%al
f010cfd2:	83 e0 e0             	and    $0xffffffe0,%eax
f010cfd5:	a2 3c 48 69 f0       	mov    %al,0xf069483c
f010cfda:	a0 3c 48 69 f0       	mov    0xf069483c,%al
f010cfdf:	83 e0 1f             	and    $0x1f,%eax
f010cfe2:	a2 3c 48 69 f0       	mov    %al,0xf069483c
f010cfe7:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010cfec:	83 e0 f0             	and    $0xfffffff0,%eax
f010cfef:	83 c8 0e             	or     $0xe,%eax
f010cff2:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010cff7:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010cffc:	83 e0 ef             	and    $0xffffffef,%eax
f010cfff:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010d004:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010d009:	83 c8 60             	or     $0x60,%eax
f010d00c:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010d011:	a0 3d 48 69 f0       	mov    0xf069483d,%al
f010d016:	83 c8 80             	or     $0xffffff80,%eax
f010d019:	a2 3d 48 69 f0       	mov    %al,0xf069483d
f010d01e:	b8 7a df 10 f0       	mov    $0xf010df7a,%eax
f010d023:	c1 e8 10             	shr    $0x10,%eax
f010d026:	66 a3 3e 48 69 f0    	mov    %ax,0xf069483e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d02c:	b8 80 df 10 f0       	mov    $0xf010df80,%eax
f010d031:	66 a3 50 48 69 f0    	mov    %ax,0xf0694850
f010d037:	66 c7 05 52 48 69 f0 	movw   $0x8,0xf0694852
f010d03e:	08 00 
f010d040:	a0 54 48 69 f0       	mov    0xf0694854,%al
f010d045:	83 e0 e0             	and    $0xffffffe0,%eax
f010d048:	a2 54 48 69 f0       	mov    %al,0xf0694854
f010d04d:	a0 54 48 69 f0       	mov    0xf0694854,%al
f010d052:	83 e0 1f             	and    $0x1f,%eax
f010d055:	a2 54 48 69 f0       	mov    %al,0xf0694854
f010d05a:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d05f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d062:	83 c8 0e             	or     $0xe,%eax
f010d065:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d06a:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d06f:	83 e0 ef             	and    $0xffffffef,%eax
f010d072:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d077:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d07c:	83 c8 60             	or     $0x60,%eax
f010d07f:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d084:	a0 55 48 69 f0       	mov    0xf0694855,%al
f010d089:	83 c8 80             	or     $0xffffff80,%eax
f010d08c:	a2 55 48 69 f0       	mov    %al,0xf0694855
f010d091:	b8 80 df 10 f0       	mov    $0xf010df80,%eax
f010d096:	c1 e8 10             	shr    $0x10,%eax
f010d099:	66 a3 56 48 69 f0    	mov    %ax,0xf0694856
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d09f:	b8 84 df 10 f0       	mov    $0xf010df84,%eax
f010d0a4:	66 a3 58 48 69 f0    	mov    %ax,0xf0694858
f010d0aa:	66 c7 05 5a 48 69 f0 	movw   $0x8,0xf069485a
f010d0b1:	08 00 
f010d0b3:	a0 5c 48 69 f0       	mov    0xf069485c,%al
f010d0b8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0bb:	a2 5c 48 69 f0       	mov    %al,0xf069485c
f010d0c0:	a0 5c 48 69 f0       	mov    0xf069485c,%al
f010d0c5:	83 e0 1f             	and    $0x1f,%eax
f010d0c8:	a2 5c 48 69 f0       	mov    %al,0xf069485c
f010d0cd:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d0d2:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0d5:	83 c8 0e             	or     $0xe,%eax
f010d0d8:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d0dd:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d0e2:	83 e0 ef             	and    $0xffffffef,%eax
f010d0e5:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d0ea:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d0ef:	83 c8 60             	or     $0x60,%eax
f010d0f2:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d0f7:	a0 5d 48 69 f0       	mov    0xf069485d,%al
f010d0fc:	83 c8 80             	or     $0xffffff80,%eax
f010d0ff:	a2 5d 48 69 f0       	mov    %al,0xf069485d
f010d104:	b8 84 df 10 f0       	mov    $0xf010df84,%eax
f010d109:	c1 e8 10             	shr    $0x10,%eax
f010d10c:	66 a3 5e 48 69 f0    	mov    %ax,0xf069485e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d112:	b8 88 df 10 f0       	mov    $0xf010df88,%eax
f010d117:	66 a3 60 48 69 f0    	mov    %ax,0xf0694860
f010d11d:	66 c7 05 62 48 69 f0 	movw   $0x8,0xf0694862
f010d124:	08 00 
f010d126:	a0 64 48 69 f0       	mov    0xf0694864,%al
f010d12b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d12e:	a2 64 48 69 f0       	mov    %al,0xf0694864
f010d133:	a0 64 48 69 f0       	mov    0xf0694864,%al
f010d138:	83 e0 1f             	and    $0x1f,%eax
f010d13b:	a2 64 48 69 f0       	mov    %al,0xf0694864
f010d140:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d145:	83 e0 f0             	and    $0xfffffff0,%eax
f010d148:	83 c8 0e             	or     $0xe,%eax
f010d14b:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d150:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d155:	83 e0 ef             	and    $0xffffffef,%eax
f010d158:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d15d:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d162:	83 c8 60             	or     $0x60,%eax
f010d165:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d16a:	a0 65 48 69 f0       	mov    0xf0694865,%al
f010d16f:	83 c8 80             	or     $0xffffff80,%eax
f010d172:	a2 65 48 69 f0       	mov    %al,0xf0694865
f010d177:	b8 88 df 10 f0       	mov    $0xf010df88,%eax
f010d17c:	c1 e8 10             	shr    $0x10,%eax
f010d17f:	66 a3 66 48 69 f0    	mov    %ax,0xf0694866
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d185:	b8 8c df 10 f0       	mov    $0xf010df8c,%eax
f010d18a:	66 a3 68 48 69 f0    	mov    %ax,0xf0694868
f010d190:	66 c7 05 6a 48 69 f0 	movw   $0x8,0xf069486a
f010d197:	08 00 
f010d199:	a0 6c 48 69 f0       	mov    0xf069486c,%al
f010d19e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1a1:	a2 6c 48 69 f0       	mov    %al,0xf069486c
f010d1a6:	a0 6c 48 69 f0       	mov    0xf069486c,%al
f010d1ab:	83 e0 1f             	and    $0x1f,%eax
f010d1ae:	a2 6c 48 69 f0       	mov    %al,0xf069486c
f010d1b3:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1b8:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1bb:	83 c8 0e             	or     $0xe,%eax
f010d1be:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d1c3:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1c8:	83 e0 ef             	and    $0xffffffef,%eax
f010d1cb:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d1d0:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1d5:	83 c8 60             	or     $0x60,%eax
f010d1d8:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d1dd:	a0 6d 48 69 f0       	mov    0xf069486d,%al
f010d1e2:	83 c8 80             	or     $0xffffff80,%eax
f010d1e5:	a2 6d 48 69 f0       	mov    %al,0xf069486d
f010d1ea:	b8 8c df 10 f0       	mov    $0xf010df8c,%eax
f010d1ef:	c1 e8 10             	shr    $0x10,%eax
f010d1f2:	66 a3 6e 48 69 f0    	mov    %ax,0xf069486e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d1f8:	b8 90 df 10 f0       	mov    $0xf010df90,%eax
f010d1fd:	66 a3 80 48 69 f0    	mov    %ax,0xf0694880
f010d203:	66 c7 05 82 48 69 f0 	movw   $0x8,0xf0694882
f010d20a:	08 00 
f010d20c:	a0 84 48 69 f0       	mov    0xf0694884,%al
f010d211:	83 e0 e0             	and    $0xffffffe0,%eax
f010d214:	a2 84 48 69 f0       	mov    %al,0xf0694884
f010d219:	a0 84 48 69 f0       	mov    0xf0694884,%al
f010d21e:	83 e0 1f             	and    $0x1f,%eax
f010d221:	a2 84 48 69 f0       	mov    %al,0xf0694884
f010d226:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d22b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d22e:	83 c8 0e             	or     $0xe,%eax
f010d231:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d236:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d23b:	83 e0 ef             	and    $0xffffffef,%eax
f010d23e:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d243:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d248:	83 c8 60             	or     $0x60,%eax
f010d24b:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d250:	a0 85 48 69 f0       	mov    0xf0694885,%al
f010d255:	83 c8 80             	or     $0xffffff80,%eax
f010d258:	a2 85 48 69 f0       	mov    %al,0xf0694885
f010d25d:	b8 90 df 10 f0       	mov    $0xf010df90,%eax
f010d262:	c1 e8 10             	shr    $0x10,%eax
f010d265:	66 a3 86 48 69 f0    	mov    %ax,0xf0694886
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d26b:	b8 96 df 10 f0       	mov    $0xf010df96,%eax
f010d270:	66 a3 88 48 69 f0    	mov    %ax,0xf0694888
f010d276:	66 c7 05 8a 48 69 f0 	movw   $0x8,0xf069488a
f010d27d:	08 00 
f010d27f:	a0 8c 48 69 f0       	mov    0xf069488c,%al
f010d284:	83 e0 e0             	and    $0xffffffe0,%eax
f010d287:	a2 8c 48 69 f0       	mov    %al,0xf069488c
f010d28c:	a0 8c 48 69 f0       	mov    0xf069488c,%al
f010d291:	83 e0 1f             	and    $0x1f,%eax
f010d294:	a2 8c 48 69 f0       	mov    %al,0xf069488c
f010d299:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d29e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2a1:	83 c8 0e             	or     $0xe,%eax
f010d2a4:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2a9:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d2ae:	83 e0 ef             	and    $0xffffffef,%eax
f010d2b1:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2b6:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d2bb:	83 c8 60             	or     $0x60,%eax
f010d2be:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2c3:	a0 8d 48 69 f0       	mov    0xf069488d,%al
f010d2c8:	83 c8 80             	or     $0xffffff80,%eax
f010d2cb:	a2 8d 48 69 f0       	mov    %al,0xf069488d
f010d2d0:	b8 96 df 10 f0       	mov    $0xf010df96,%eax
f010d2d5:	c1 e8 10             	shr    $0x10,%eax
f010d2d8:	66 a3 8e 48 69 f0    	mov    %ax,0xf069488e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d2de:	b8 9a df 10 f0       	mov    $0xf010df9a,%eax
f010d2e3:	66 a3 90 48 69 f0    	mov    %ax,0xf0694890
f010d2e9:	66 c7 05 92 48 69 f0 	movw   $0x8,0xf0694892
f010d2f0:	08 00 
f010d2f2:	a0 94 48 69 f0       	mov    0xf0694894,%al
f010d2f7:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2fa:	a2 94 48 69 f0       	mov    %al,0xf0694894
f010d2ff:	a0 94 48 69 f0       	mov    0xf0694894,%al
f010d304:	83 e0 1f             	and    $0x1f,%eax
f010d307:	a2 94 48 69 f0       	mov    %al,0xf0694894
f010d30c:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d311:	83 e0 f0             	and    $0xfffffff0,%eax
f010d314:	83 c8 0e             	or     $0xe,%eax
f010d317:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d31c:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d321:	83 e0 ef             	and    $0xffffffef,%eax
f010d324:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d329:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d32e:	83 c8 60             	or     $0x60,%eax
f010d331:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d336:	a0 95 48 69 f0       	mov    0xf0694895,%al
f010d33b:	83 c8 80             	or     $0xffffff80,%eax
f010d33e:	a2 95 48 69 f0       	mov    %al,0xf0694895
f010d343:	b8 9a df 10 f0       	mov    $0xf010df9a,%eax
f010d348:	c1 e8 10             	shr    $0x10,%eax
f010d34b:	66 a3 96 48 69 f0    	mov    %ax,0xf0694896
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d351:	b8 a0 df 10 f0       	mov    $0xf010dfa0,%eax
f010d356:	66 a3 98 48 69 f0    	mov    %ax,0xf0694898
f010d35c:	66 c7 05 9a 48 69 f0 	movw   $0x8,0xf069489a
f010d363:	08 00 
f010d365:	a0 9c 48 69 f0       	mov    0xf069489c,%al
f010d36a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d36d:	a2 9c 48 69 f0       	mov    %al,0xf069489c
f010d372:	a0 9c 48 69 f0       	mov    0xf069489c,%al
f010d377:	83 e0 1f             	and    $0x1f,%eax
f010d37a:	a2 9c 48 69 f0       	mov    %al,0xf069489c
f010d37f:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d384:	83 e0 f0             	and    $0xfffffff0,%eax
f010d387:	83 c8 0e             	or     $0xe,%eax
f010d38a:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d38f:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d394:	83 e0 ef             	and    $0xffffffef,%eax
f010d397:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d39c:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d3a1:	83 c8 60             	or     $0x60,%eax
f010d3a4:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d3a9:	a0 9d 48 69 f0       	mov    0xf069489d,%al
f010d3ae:	83 c8 80             	or     $0xffffff80,%eax
f010d3b1:	a2 9d 48 69 f0       	mov    %al,0xf069489d
f010d3b6:	b8 a0 df 10 f0       	mov    $0xf010dfa0,%eax
f010d3bb:	c1 e8 10             	shr    $0x10,%eax
f010d3be:	66 a3 9e 48 69 f0    	mov    %ax,0xf069489e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010d3c4:	b8 a6 df 10 f0       	mov    $0xf010dfa6,%eax
f010d3c9:	66 a3 10 49 69 f0    	mov    %ax,0xf0694910
f010d3cf:	66 c7 05 12 49 69 f0 	movw   $0x8,0xf0694912
f010d3d6:	08 00 
f010d3d8:	a0 14 49 69 f0       	mov    0xf0694914,%al
f010d3dd:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3e0:	a2 14 49 69 f0       	mov    %al,0xf0694914
f010d3e5:	a0 14 49 69 f0       	mov    0xf0694914,%al
f010d3ea:	83 e0 1f             	and    $0x1f,%eax
f010d3ed:	a2 14 49 69 f0       	mov    %al,0xf0694914
f010d3f2:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d3f7:	83 e0 f0             	and    $0xfffffff0,%eax
f010d3fa:	83 c8 0e             	or     $0xe,%eax
f010d3fd:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d402:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d407:	83 e0 ef             	and    $0xffffffef,%eax
f010d40a:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d40f:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d414:	83 c8 60             	or     $0x60,%eax
f010d417:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d41c:	a0 15 49 69 f0       	mov    0xf0694915,%al
f010d421:	83 c8 80             	or     $0xffffff80,%eax
f010d424:	a2 15 49 69 f0       	mov    %al,0xf0694915
f010d429:	b8 a6 df 10 f0       	mov    $0xf010dfa6,%eax
f010d42e:	c1 e8 10             	shr    $0x10,%eax
f010d431:	66 a3 16 49 69 f0    	mov    %ax,0xf0694916
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010d437:	b8 ac df 10 f0       	mov    $0xf010dfac,%eax
f010d43c:	66 a3 18 49 69 f0    	mov    %ax,0xf0694918
f010d442:	66 c7 05 1a 49 69 f0 	movw   $0x8,0xf069491a
f010d449:	08 00 
f010d44b:	a0 1c 49 69 f0       	mov    0xf069491c,%al
f010d450:	83 e0 e0             	and    $0xffffffe0,%eax
f010d453:	a2 1c 49 69 f0       	mov    %al,0xf069491c
f010d458:	a0 1c 49 69 f0       	mov    0xf069491c,%al
f010d45d:	83 e0 1f             	and    $0x1f,%eax
f010d460:	a2 1c 49 69 f0       	mov    %al,0xf069491c
f010d465:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d46a:	83 e0 f0             	and    $0xfffffff0,%eax
f010d46d:	83 c8 0e             	or     $0xe,%eax
f010d470:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d475:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d47a:	83 e0 ef             	and    $0xffffffef,%eax
f010d47d:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d482:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d487:	83 c8 60             	or     $0x60,%eax
f010d48a:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d48f:	a0 1d 49 69 f0       	mov    0xf069491d,%al
f010d494:	83 c8 80             	or     $0xffffff80,%eax
f010d497:	a2 1d 49 69 f0       	mov    %al,0xf069491d
f010d49c:	b8 ac df 10 f0       	mov    $0xf010dfac,%eax
f010d4a1:	c1 e8 10             	shr    $0x10,%eax
f010d4a4:	66 a3 1e 49 69 f0    	mov    %ax,0xf069491e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010d4aa:	b8 b2 df 10 f0       	mov    $0xf010dfb2,%eax
f010d4af:	66 a3 20 49 69 f0    	mov    %ax,0xf0694920
f010d4b5:	66 c7 05 22 49 69 f0 	movw   $0x8,0xf0694922
f010d4bc:	08 00 
f010d4be:	a0 24 49 69 f0       	mov    0xf0694924,%al
f010d4c3:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4c6:	a2 24 49 69 f0       	mov    %al,0xf0694924
f010d4cb:	a0 24 49 69 f0       	mov    0xf0694924,%al
f010d4d0:	83 e0 1f             	and    $0x1f,%eax
f010d4d3:	a2 24 49 69 f0       	mov    %al,0xf0694924
f010d4d8:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d4dd:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4e0:	83 c8 0e             	or     $0xe,%eax
f010d4e3:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d4e8:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d4ed:	83 e0 ef             	and    $0xffffffef,%eax
f010d4f0:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d4f5:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d4fa:	83 c8 60             	or     $0x60,%eax
f010d4fd:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d502:	a0 25 49 69 f0       	mov    0xf0694925,%al
f010d507:	83 c8 80             	or     $0xffffff80,%eax
f010d50a:	a2 25 49 69 f0       	mov    %al,0xf0694925
f010d50f:	b8 b2 df 10 f0       	mov    $0xf010dfb2,%eax
f010d514:	c1 e8 10             	shr    $0x10,%eax
f010d517:	66 a3 26 49 69 f0    	mov    %ax,0xf0694926
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010d51d:	b8 b8 df 10 f0       	mov    $0xf010dfb8,%eax
f010d522:	66 a3 28 49 69 f0    	mov    %ax,0xf0694928
f010d528:	66 c7 05 2a 49 69 f0 	movw   $0x8,0xf069492a
f010d52f:	08 00 
f010d531:	a0 2c 49 69 f0       	mov    0xf069492c,%al
f010d536:	83 e0 e0             	and    $0xffffffe0,%eax
f010d539:	a2 2c 49 69 f0       	mov    %al,0xf069492c
f010d53e:	a0 2c 49 69 f0       	mov    0xf069492c,%al
f010d543:	83 e0 1f             	and    $0x1f,%eax
f010d546:	a2 2c 49 69 f0       	mov    %al,0xf069492c
f010d54b:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d550:	83 e0 f0             	and    $0xfffffff0,%eax
f010d553:	83 c8 0e             	or     $0xe,%eax
f010d556:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d55b:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d560:	83 e0 ef             	and    $0xffffffef,%eax
f010d563:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d568:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d56d:	83 c8 60             	or     $0x60,%eax
f010d570:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d575:	a0 2d 49 69 f0       	mov    0xf069492d,%al
f010d57a:	83 c8 80             	or     $0xffffff80,%eax
f010d57d:	a2 2d 49 69 f0       	mov    %al,0xf069492d
f010d582:	b8 b8 df 10 f0       	mov    $0xf010dfb8,%eax
f010d587:	c1 e8 10             	shr    $0x10,%eax
f010d58a:	66 a3 2e 49 69 f0    	mov    %ax,0xf069492e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010d590:	b8 be df 10 f0       	mov    $0xf010dfbe,%eax
f010d595:	66 a3 30 49 69 f0    	mov    %ax,0xf0694930
f010d59b:	66 c7 05 32 49 69 f0 	movw   $0x8,0xf0694932
f010d5a2:	08 00 
f010d5a4:	a0 34 49 69 f0       	mov    0xf0694934,%al
f010d5a9:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5ac:	a2 34 49 69 f0       	mov    %al,0xf0694934
f010d5b1:	a0 34 49 69 f0       	mov    0xf0694934,%al
f010d5b6:	83 e0 1f             	and    $0x1f,%eax
f010d5b9:	a2 34 49 69 f0       	mov    %al,0xf0694934
f010d5be:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d5c3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5c6:	83 c8 0e             	or     $0xe,%eax
f010d5c9:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d5ce:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d5d3:	83 e0 ef             	and    $0xffffffef,%eax
f010d5d6:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d5db:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d5e0:	83 c8 60             	or     $0x60,%eax
f010d5e3:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d5e8:	a0 35 49 69 f0       	mov    0xf0694935,%al
f010d5ed:	83 c8 80             	or     $0xffffff80,%eax
f010d5f0:	a2 35 49 69 f0       	mov    %al,0xf0694935
f010d5f5:	b8 be df 10 f0       	mov    $0xf010dfbe,%eax
f010d5fa:	c1 e8 10             	shr    $0x10,%eax
f010d5fd:	66 a3 36 49 69 f0    	mov    %ax,0xf0694936
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010d603:	b8 c4 df 10 f0       	mov    $0xf010dfc4,%eax
f010d608:	66 a3 38 49 69 f0    	mov    %ax,0xf0694938
f010d60e:	66 c7 05 3a 49 69 f0 	movw   $0x8,0xf069493a
f010d615:	08 00 
f010d617:	a0 3c 49 69 f0       	mov    0xf069493c,%al
f010d61c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d61f:	a2 3c 49 69 f0       	mov    %al,0xf069493c
f010d624:	a0 3c 49 69 f0       	mov    0xf069493c,%al
f010d629:	83 e0 1f             	and    $0x1f,%eax
f010d62c:	a2 3c 49 69 f0       	mov    %al,0xf069493c
f010d631:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d636:	83 e0 f0             	and    $0xfffffff0,%eax
f010d639:	83 c8 0e             	or     $0xe,%eax
f010d63c:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d641:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d646:	83 e0 ef             	and    $0xffffffef,%eax
f010d649:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d64e:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d653:	83 c8 60             	or     $0x60,%eax
f010d656:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d65b:	a0 3d 49 69 f0       	mov    0xf069493d,%al
f010d660:	83 c8 80             	or     $0xffffff80,%eax
f010d663:	a2 3d 49 69 f0       	mov    %al,0xf069493d
f010d668:	b8 c4 df 10 f0       	mov    $0xf010dfc4,%eax
f010d66d:	c1 e8 10             	shr    $0x10,%eax
f010d670:	66 a3 3e 49 69 f0    	mov    %ax,0xf069493e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010d676:	b8 ca df 10 f0       	mov    $0xf010dfca,%eax
f010d67b:	66 a3 40 49 69 f0    	mov    %ax,0xf0694940
f010d681:	66 c7 05 42 49 69 f0 	movw   $0x8,0xf0694942
f010d688:	08 00 
f010d68a:	a0 44 49 69 f0       	mov    0xf0694944,%al
f010d68f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d692:	a2 44 49 69 f0       	mov    %al,0xf0694944
f010d697:	a0 44 49 69 f0       	mov    0xf0694944,%al
f010d69c:	83 e0 1f             	and    $0x1f,%eax
f010d69f:	a2 44 49 69 f0       	mov    %al,0xf0694944
f010d6a4:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6a9:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6ac:	83 c8 0e             	or     $0xe,%eax
f010d6af:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6b4:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6b9:	83 e0 ef             	and    $0xffffffef,%eax
f010d6bc:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6c1:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6c6:	83 c8 60             	or     $0x60,%eax
f010d6c9:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6ce:	a0 45 49 69 f0       	mov    0xf0694945,%al
f010d6d3:	83 c8 80             	or     $0xffffff80,%eax
f010d6d6:	a2 45 49 69 f0       	mov    %al,0xf0694945
f010d6db:	b8 ca df 10 f0       	mov    $0xf010dfca,%eax
f010d6e0:	c1 e8 10             	shr    $0x10,%eax
f010d6e3:	66 a3 46 49 69 f0    	mov    %ax,0xf0694946
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010d6e9:	b8 d0 df 10 f0       	mov    $0xf010dfd0,%eax
f010d6ee:	66 a3 48 49 69 f0    	mov    %ax,0xf0694948
f010d6f4:	66 c7 05 4a 49 69 f0 	movw   $0x8,0xf069494a
f010d6fb:	08 00 
f010d6fd:	a0 4c 49 69 f0       	mov    0xf069494c,%al
f010d702:	83 e0 e0             	and    $0xffffffe0,%eax
f010d705:	a2 4c 49 69 f0       	mov    %al,0xf069494c
f010d70a:	a0 4c 49 69 f0       	mov    0xf069494c,%al
f010d70f:	83 e0 1f             	and    $0x1f,%eax
f010d712:	a2 4c 49 69 f0       	mov    %al,0xf069494c
f010d717:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d71c:	83 e0 f0             	and    $0xfffffff0,%eax
f010d71f:	83 c8 0e             	or     $0xe,%eax
f010d722:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d727:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d72c:	83 e0 ef             	and    $0xffffffef,%eax
f010d72f:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d734:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d739:	83 c8 60             	or     $0x60,%eax
f010d73c:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d741:	a0 4d 49 69 f0       	mov    0xf069494d,%al
f010d746:	83 c8 80             	or     $0xffffff80,%eax
f010d749:	a2 4d 49 69 f0       	mov    %al,0xf069494d
f010d74e:	b8 d0 df 10 f0       	mov    $0xf010dfd0,%eax
f010d753:	c1 e8 10             	shr    $0x10,%eax
f010d756:	66 a3 4e 49 69 f0    	mov    %ax,0xf069494e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010d75c:	b8 d6 df 10 f0       	mov    $0xf010dfd6,%eax
f010d761:	66 a3 50 49 69 f0    	mov    %ax,0xf0694950
f010d767:	66 c7 05 52 49 69 f0 	movw   $0x8,0xf0694952
f010d76e:	08 00 
f010d770:	a0 54 49 69 f0       	mov    0xf0694954,%al
f010d775:	83 e0 e0             	and    $0xffffffe0,%eax
f010d778:	a2 54 49 69 f0       	mov    %al,0xf0694954
f010d77d:	a0 54 49 69 f0       	mov    0xf0694954,%al
f010d782:	83 e0 1f             	and    $0x1f,%eax
f010d785:	a2 54 49 69 f0       	mov    %al,0xf0694954
f010d78a:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d78f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d792:	83 c8 0e             	or     $0xe,%eax
f010d795:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d79a:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d79f:	83 e0 ef             	and    $0xffffffef,%eax
f010d7a2:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d7a7:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d7ac:	83 c8 60             	or     $0x60,%eax
f010d7af:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d7b4:	a0 55 49 69 f0       	mov    0xf0694955,%al
f010d7b9:	83 c8 80             	or     $0xffffff80,%eax
f010d7bc:	a2 55 49 69 f0       	mov    %al,0xf0694955
f010d7c1:	b8 d6 df 10 f0       	mov    $0xf010dfd6,%eax
f010d7c6:	c1 e8 10             	shr    $0x10,%eax
f010d7c9:	66 a3 56 49 69 f0    	mov    %ax,0xf0694956
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010d7cf:	b8 dc df 10 f0       	mov    $0xf010dfdc,%eax
f010d7d4:	66 a3 58 49 69 f0    	mov    %ax,0xf0694958
f010d7da:	66 c7 05 5a 49 69 f0 	movw   $0x8,0xf069495a
f010d7e1:	08 00 
f010d7e3:	a0 5c 49 69 f0       	mov    0xf069495c,%al
f010d7e8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7eb:	a2 5c 49 69 f0       	mov    %al,0xf069495c
f010d7f0:	a0 5c 49 69 f0       	mov    0xf069495c,%al
f010d7f5:	83 e0 1f             	and    $0x1f,%eax
f010d7f8:	a2 5c 49 69 f0       	mov    %al,0xf069495c
f010d7fd:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d802:	83 e0 f0             	and    $0xfffffff0,%eax
f010d805:	83 c8 0e             	or     $0xe,%eax
f010d808:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d80d:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d812:	83 e0 ef             	and    $0xffffffef,%eax
f010d815:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d81a:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d81f:	83 c8 60             	or     $0x60,%eax
f010d822:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d827:	a0 5d 49 69 f0       	mov    0xf069495d,%al
f010d82c:	83 c8 80             	or     $0xffffff80,%eax
f010d82f:	a2 5d 49 69 f0       	mov    %al,0xf069495d
f010d834:	b8 dc df 10 f0       	mov    $0xf010dfdc,%eax
f010d839:	c1 e8 10             	shr    $0x10,%eax
f010d83c:	66 a3 5e 49 69 f0    	mov    %ax,0xf069495e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010d842:	b8 e2 df 10 f0       	mov    $0xf010dfe2,%eax
f010d847:	66 a3 60 49 69 f0    	mov    %ax,0xf0694960
f010d84d:	66 c7 05 62 49 69 f0 	movw   $0x8,0xf0694962
f010d854:	08 00 
f010d856:	a0 64 49 69 f0       	mov    0xf0694964,%al
f010d85b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d85e:	a2 64 49 69 f0       	mov    %al,0xf0694964
f010d863:	a0 64 49 69 f0       	mov    0xf0694964,%al
f010d868:	83 e0 1f             	and    $0x1f,%eax
f010d86b:	a2 64 49 69 f0       	mov    %al,0xf0694964
f010d870:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d875:	83 e0 f0             	and    $0xfffffff0,%eax
f010d878:	83 c8 0e             	or     $0xe,%eax
f010d87b:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d880:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d885:	83 e0 ef             	and    $0xffffffef,%eax
f010d888:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d88d:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d892:	83 c8 60             	or     $0x60,%eax
f010d895:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d89a:	a0 65 49 69 f0       	mov    0xf0694965,%al
f010d89f:	83 c8 80             	or     $0xffffff80,%eax
f010d8a2:	a2 65 49 69 f0       	mov    %al,0xf0694965
f010d8a7:	b8 e2 df 10 f0       	mov    $0xf010dfe2,%eax
f010d8ac:	c1 e8 10             	shr    $0x10,%eax
f010d8af:	66 a3 66 49 69 f0    	mov    %ax,0xf0694966
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010d8b5:	b8 e8 df 10 f0       	mov    $0xf010dfe8,%eax
f010d8ba:	66 a3 68 49 69 f0    	mov    %ax,0xf0694968
f010d8c0:	66 c7 05 6a 49 69 f0 	movw   $0x8,0xf069496a
f010d8c7:	08 00 
f010d8c9:	a0 6c 49 69 f0       	mov    0xf069496c,%al
f010d8ce:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8d1:	a2 6c 49 69 f0       	mov    %al,0xf069496c
f010d8d6:	a0 6c 49 69 f0       	mov    0xf069496c,%al
f010d8db:	83 e0 1f             	and    $0x1f,%eax
f010d8de:	a2 6c 49 69 f0       	mov    %al,0xf069496c
f010d8e3:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d8e8:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8eb:	83 c8 0e             	or     $0xe,%eax
f010d8ee:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d8f3:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d8f8:	83 e0 ef             	and    $0xffffffef,%eax
f010d8fb:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d900:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d905:	83 c8 60             	or     $0x60,%eax
f010d908:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d90d:	a0 6d 49 69 f0       	mov    0xf069496d,%al
f010d912:	83 c8 80             	or     $0xffffff80,%eax
f010d915:	a2 6d 49 69 f0       	mov    %al,0xf069496d
f010d91a:	b8 e8 df 10 f0       	mov    $0xf010dfe8,%eax
f010d91f:	c1 e8 10             	shr    $0x10,%eax
f010d922:	66 a3 6e 49 69 f0    	mov    %ax,0xf069496e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010d928:	b8 ee df 10 f0       	mov    $0xf010dfee,%eax
f010d92d:	66 a3 70 49 69 f0    	mov    %ax,0xf0694970
f010d933:	66 c7 05 72 49 69 f0 	movw   $0x8,0xf0694972
f010d93a:	08 00 
f010d93c:	a0 74 49 69 f0       	mov    0xf0694974,%al
f010d941:	83 e0 e0             	and    $0xffffffe0,%eax
f010d944:	a2 74 49 69 f0       	mov    %al,0xf0694974
f010d949:	a0 74 49 69 f0       	mov    0xf0694974,%al
f010d94e:	83 e0 1f             	and    $0x1f,%eax
f010d951:	a2 74 49 69 f0       	mov    %al,0xf0694974
f010d956:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d95b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d95e:	83 c8 0e             	or     $0xe,%eax
f010d961:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d966:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d96b:	83 e0 ef             	and    $0xffffffef,%eax
f010d96e:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d973:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d978:	83 c8 60             	or     $0x60,%eax
f010d97b:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d980:	a0 75 49 69 f0       	mov    0xf0694975,%al
f010d985:	83 c8 80             	or     $0xffffff80,%eax
f010d988:	a2 75 49 69 f0       	mov    %al,0xf0694975
f010d98d:	b8 ee df 10 f0       	mov    $0xf010dfee,%eax
f010d992:	c1 e8 10             	shr    $0x10,%eax
f010d995:	66 a3 76 49 69 f0    	mov    %ax,0xf0694976
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010d99b:	b8 f4 df 10 f0       	mov    $0xf010dff4,%eax
f010d9a0:	66 a3 78 49 69 f0    	mov    %ax,0xf0694978
f010d9a6:	66 c7 05 7a 49 69 f0 	movw   $0x8,0xf069497a
f010d9ad:	08 00 
f010d9af:	a0 7c 49 69 f0       	mov    0xf069497c,%al
f010d9b4:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9b7:	a2 7c 49 69 f0       	mov    %al,0xf069497c
f010d9bc:	a0 7c 49 69 f0       	mov    0xf069497c,%al
f010d9c1:	83 e0 1f             	and    $0x1f,%eax
f010d9c4:	a2 7c 49 69 f0       	mov    %al,0xf069497c
f010d9c9:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010d9ce:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9d1:	83 c8 0e             	or     $0xe,%eax
f010d9d4:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010d9d9:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010d9de:	83 e0 ef             	and    $0xffffffef,%eax
f010d9e1:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010d9e6:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010d9eb:	83 c8 60             	or     $0x60,%eax
f010d9ee:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010d9f3:	a0 7d 49 69 f0       	mov    0xf069497d,%al
f010d9f8:	83 c8 80             	or     $0xffffff80,%eax
f010d9fb:	a2 7d 49 69 f0       	mov    %al,0xf069497d
f010da00:	b8 f4 df 10 f0       	mov    $0xf010dff4,%eax
f010da05:	c1 e8 10             	shr    $0x10,%eax
f010da08:	66 a3 7e 49 69 f0    	mov    %ax,0xf069497e
f010da0e:	c7 45 fc 00 48 69 f0 	movl   $0xf0694800,-0x4(%ebp)
f010da15:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010da1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010da1f:	48                   	dec    %eax
f010da20:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010da24:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010da27:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010da2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010da2e:	c1 e8 10             	shr    $0x10,%eax
f010da31:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010da35:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010da38:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010da3b:	90                   	nop
f010da3c:	c9                   	leave  
f010da3d:	c3                   	ret    

f010da3e <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010da3e:	55                   	push   %ebp
f010da3f:	89 e5                	mov    %esp,%ebp
f010da41:	53                   	push   %ebx
f010da42:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010da45:	83 ec 08             	sub    $0x8,%esp
f010da48:	ff 75 08             	pushl  0x8(%ebp)
f010da4b:	68 7e 6c 12 f0       	push   $0xf0126c7e
f010da50:	e8 36 35 ff ff       	call   f0100f8b <cprintf>
f010da55:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010da58:	8b 45 08             	mov    0x8(%ebp),%eax
f010da5b:	83 ec 0c             	sub    $0xc,%esp
f010da5e:	50                   	push   %eax
f010da5f:	e8 fd 00 00 00       	call   f010db61 <print_regs>
f010da64:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010da67:	8b 45 08             	mov    0x8(%ebp),%eax
f010da6a:	8b 40 20             	mov    0x20(%eax),%eax
f010da6d:	0f b7 c0             	movzwl %ax,%eax
f010da70:	83 ec 08             	sub    $0x8,%esp
f010da73:	50                   	push   %eax
f010da74:	68 90 6c 12 f0       	push   $0xf0126c90
f010da79:	e8 0d 35 ff ff       	call   f0100f8b <cprintf>
f010da7e:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010da81:	8b 45 08             	mov    0x8(%ebp),%eax
f010da84:	8b 40 24             	mov    0x24(%eax),%eax
f010da87:	0f b7 c0             	movzwl %ax,%eax
f010da8a:	83 ec 08             	sub    $0x8,%esp
f010da8d:	50                   	push   %eax
f010da8e:	68 a3 6c 12 f0       	push   $0xf0126ca3
f010da93:	e8 f3 34 ff ff       	call   f0100f8b <cprintf>
f010da98:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010da9b:	8b 45 08             	mov    0x8(%ebp),%eax
f010da9e:	8b 58 28             	mov    0x28(%eax),%ebx
f010daa1:	8b 45 08             	mov    0x8(%ebp),%eax
f010daa4:	8b 40 28             	mov    0x28(%eax),%eax
f010daa7:	83 ec 0c             	sub    $0xc,%esp
f010daaa:	50                   	push   %eax
f010daab:	e8 28 ee ff ff       	call   f010c8d8 <trapname>
f010dab0:	83 c4 10             	add    $0x10,%esp
f010dab3:	89 c2                	mov    %eax,%edx
f010dab5:	8b 45 08             	mov    0x8(%ebp),%eax
f010dab8:	8b 40 28             	mov    0x28(%eax),%eax
f010dabb:	53                   	push   %ebx
f010dabc:	52                   	push   %edx
f010dabd:	50                   	push   %eax
f010dabe:	68 b6 6c 12 f0       	push   $0xf0126cb6
f010dac3:	e8 c3 34 ff ff       	call   f0100f8b <cprintf>
f010dac8:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010dacb:	8b 45 08             	mov    0x8(%ebp),%eax
f010dace:	8b 40 2c             	mov    0x2c(%eax),%eax
f010dad1:	83 ec 08             	sub    $0x8,%esp
f010dad4:	50                   	push   %eax
f010dad5:	68 cd 6c 12 f0       	push   $0xf0126ccd
f010dada:	e8 ac 34 ff ff       	call   f0100f8b <cprintf>
f010dadf:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010dae2:	8b 45 08             	mov    0x8(%ebp),%eax
f010dae5:	8b 40 30             	mov    0x30(%eax),%eax
f010dae8:	83 ec 08             	sub    $0x8,%esp
f010daeb:	50                   	push   %eax
f010daec:	68 dc 6c 12 f0       	push   $0xf0126cdc
f010daf1:	e8 95 34 ff ff       	call   f0100f8b <cprintf>
f010daf6:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010daf9:	8b 45 08             	mov    0x8(%ebp),%eax
f010dafc:	8b 40 34             	mov    0x34(%eax),%eax
f010daff:	0f b7 c0             	movzwl %ax,%eax
f010db02:	83 ec 08             	sub    $0x8,%esp
f010db05:	50                   	push   %eax
f010db06:	68 eb 6c 12 f0       	push   $0xf0126ceb
f010db0b:	e8 7b 34 ff ff       	call   f0100f8b <cprintf>
f010db10:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010db13:	8b 45 08             	mov    0x8(%ebp),%eax
f010db16:	8b 40 38             	mov    0x38(%eax),%eax
f010db19:	83 ec 08             	sub    $0x8,%esp
f010db1c:	50                   	push   %eax
f010db1d:	68 fe 6c 12 f0       	push   $0xf0126cfe
f010db22:	e8 64 34 ff ff       	call   f0100f8b <cprintf>
f010db27:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010db2a:	8b 45 08             	mov    0x8(%ebp),%eax
f010db2d:	8b 40 3c             	mov    0x3c(%eax),%eax
f010db30:	83 ec 08             	sub    $0x8,%esp
f010db33:	50                   	push   %eax
f010db34:	68 0d 6d 12 f0       	push   $0xf0126d0d
f010db39:	e8 4d 34 ff ff       	call   f0100f8b <cprintf>
f010db3e:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010db41:	8b 45 08             	mov    0x8(%ebp),%eax
f010db44:	8b 40 40             	mov    0x40(%eax),%eax
f010db47:	0f b7 c0             	movzwl %ax,%eax
f010db4a:	83 ec 08             	sub    $0x8,%esp
f010db4d:	50                   	push   %eax
f010db4e:	68 1c 6d 12 f0       	push   $0xf0126d1c
f010db53:	e8 33 34 ff ff       	call   f0100f8b <cprintf>
f010db58:	83 c4 10             	add    $0x10,%esp
}
f010db5b:	90                   	nop
f010db5c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010db5f:	c9                   	leave  
f010db60:	c3                   	ret    

f010db61 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010db61:	55                   	push   %ebp
f010db62:	89 e5                	mov    %esp,%ebp
f010db64:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010db67:	8b 45 08             	mov    0x8(%ebp),%eax
f010db6a:	8b 00                	mov    (%eax),%eax
f010db6c:	83 ec 08             	sub    $0x8,%esp
f010db6f:	50                   	push   %eax
f010db70:	68 2f 6d 12 f0       	push   $0xf0126d2f
f010db75:	e8 11 34 ff ff       	call   f0100f8b <cprintf>
f010db7a:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010db7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010db80:	8b 40 04             	mov    0x4(%eax),%eax
f010db83:	83 ec 08             	sub    $0x8,%esp
f010db86:	50                   	push   %eax
f010db87:	68 3e 6d 12 f0       	push   $0xf0126d3e
f010db8c:	e8 fa 33 ff ff       	call   f0100f8b <cprintf>
f010db91:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010db94:	8b 45 08             	mov    0x8(%ebp),%eax
f010db97:	8b 40 08             	mov    0x8(%eax),%eax
f010db9a:	83 ec 08             	sub    $0x8,%esp
f010db9d:	50                   	push   %eax
f010db9e:	68 4d 6d 12 f0       	push   $0xf0126d4d
f010dba3:	e8 e3 33 ff ff       	call   f0100f8b <cprintf>
f010dba8:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010dbab:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbae:	8b 40 0c             	mov    0xc(%eax),%eax
f010dbb1:	83 ec 08             	sub    $0x8,%esp
f010dbb4:	50                   	push   %eax
f010dbb5:	68 5c 6d 12 f0       	push   $0xf0126d5c
f010dbba:	e8 cc 33 ff ff       	call   f0100f8b <cprintf>
f010dbbf:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010dbc2:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbc5:	8b 40 10             	mov    0x10(%eax),%eax
f010dbc8:	83 ec 08             	sub    $0x8,%esp
f010dbcb:	50                   	push   %eax
f010dbcc:	68 6b 6d 12 f0       	push   $0xf0126d6b
f010dbd1:	e8 b5 33 ff ff       	call   f0100f8b <cprintf>
f010dbd6:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010dbd9:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbdc:	8b 40 14             	mov    0x14(%eax),%eax
f010dbdf:	83 ec 08             	sub    $0x8,%esp
f010dbe2:	50                   	push   %eax
f010dbe3:	68 7a 6d 12 f0       	push   $0xf0126d7a
f010dbe8:	e8 9e 33 ff ff       	call   f0100f8b <cprintf>
f010dbed:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010dbf0:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbf3:	8b 40 18             	mov    0x18(%eax),%eax
f010dbf6:	83 ec 08             	sub    $0x8,%esp
f010dbf9:	50                   	push   %eax
f010dbfa:	68 89 6d 12 f0       	push   $0xf0126d89
f010dbff:	e8 87 33 ff ff       	call   f0100f8b <cprintf>
f010dc04:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010dc07:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc0a:	8b 40 1c             	mov    0x1c(%eax),%eax
f010dc0d:	83 ec 08             	sub    $0x8,%esp
f010dc10:	50                   	push   %eax
f010dc11:	68 98 6d 12 f0       	push   $0xf0126d98
f010dc16:	e8 70 33 ff ff       	call   f0100f8b <cprintf>
f010dc1b:	83 c4 10             	add    $0x10,%esp
}
f010dc1e:	90                   	nop
f010dc1f:	c9                   	leave  
f010dc20:	c3                   	ret    

f010dc21 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010dc21:	55                   	push   %ebp
f010dc22:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010dc24:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc27:	8b 55 0c             	mov    0xc(%ebp),%edx
f010dc2a:	89 14 85 00 50 69 f0 	mov    %edx,-0xf96b000(,%eax,4)
}
f010dc31:	90                   	nop
f010dc32:	5d                   	pop    %ebp
f010dc33:	c3                   	ret    

f010dc34 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010dc34:	55                   	push   %ebp
f010dc35:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010dc37:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc3a:	c7 04 85 00 50 69 f0 	movl   $0x0,-0xf96b000(,%eax,4)
f010dc41:	00 00 00 00 
}
f010dc45:	90                   	nop
f010dc46:	5d                   	pop    %ebp
f010dc47:	c3                   	ret    

f010dc48 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010dc48:	55                   	push   %ebp
f010dc49:	89 e5                	mov    %esp,%ebp
f010dc4b:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010dc4e:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc51:	8b 40 28             	mov    0x28(%eax),%eax
f010dc54:	83 e8 20             	sub    $0x20,%eax
f010dc57:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010dc5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dc5d:	8b 04 85 00 50 69 f0 	mov    -0xf96b000(,%eax,4),%eax
f010dc64:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010dc67:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010dc6b:	74 0e                	je     f010dc7b <irq_dispatch+0x33>
	{
		handler(tf);
f010dc6d:	83 ec 0c             	sub    $0xc,%esp
f010dc70:	ff 75 08             	pushl  0x8(%ebp)
f010dc73:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dc76:	ff d0                	call   *%eax
f010dc78:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010dc7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dc7e:	0f b6 c0             	movzbl %al,%eax
f010dc81:	83 ec 0c             	sub    $0xc,%esp
f010dc84:	50                   	push   %eax
f010dc85:	e8 49 94 ff ff       	call   f01070d3 <pic_sendEOI>
f010dc8a:	83 c4 10             	add    $0x10,%esp
}
f010dc8d:	90                   	nop
f010dc8e:	c9                   	leave  
f010dc8f:	c3                   	ret    

f010dc90 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010dc90:	55                   	push   %ebp
f010dc91:	89 e5                	mov    %esp,%ebp
f010dc93:	57                   	push   %edi
f010dc94:	56                   	push   %esi
f010dc95:	53                   	push   %ebx
f010dc96:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010dc99:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc9c:	8b 40 28             	mov    0x28(%eax),%eax
f010dc9f:	83 f8 0e             	cmp    $0xe,%eax
f010dca2:	75 51                	jne    f010dcf5 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010dca4:	a0 40 50 69 f0       	mov    0xf0695040,%al
f010dca9:	84 c0                	test   %al,%al
f010dcab:	74 1f                	je     f010dccc <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010dcad:	8b 45 08             	mov    0x8(%ebp),%eax
f010dcb0:	8b 40 30             	mov    0x30(%eax),%eax
f010dcb3:	89 c2                	mov    %eax,%edx
f010dcb5:	a0 40 50 69 f0       	mov    0xf0695040,%al
f010dcba:	0f b6 c0             	movzbl %al,%eax
f010dcbd:	01 d0                	add    %edx,%eax
f010dcbf:	89 c2                	mov    %eax,%edx
f010dcc1:	8b 45 08             	mov    0x8(%ebp),%eax
f010dcc4:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010dcc7:	e9 0c 01 00 00       	jmp    f010ddd8 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010dccc:	83 ec 0c             	sub    $0xc,%esp
f010dccf:	6a 01                	push   $0x1
f010dcd1:	e8 ed 12 00 00       	call   f010efc3 <isPageReplacmentAlgorithmLRU>
f010dcd6:	83 c4 10             	add    $0x10,%esp
f010dcd9:	85 c0                	test   %eax,%eax
f010dcdb:	74 05                	je     f010dce2 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010dcdd:	e8 60 8f ff ff       	call   f0106c42 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010dce2:	83 ec 0c             	sub    $0xc,%esp
f010dce5:	ff 75 08             	pushl  0x8(%ebp)
f010dce8:	e8 bb 13 00 00       	call   f010f0a8 <fault_handler>
f010dced:	83 c4 10             	add    $0x10,%esp
f010dcf0:	e9 e3 00 00 00       	jmp    f010ddd8 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010dcf5:	8b 45 08             	mov    0x8(%ebp),%eax
f010dcf8:	8b 40 28             	mov    0x28(%eax),%eax
f010dcfb:	83 f8 30             	cmp    $0x30,%eax
f010dcfe:	75 6e                	jne    f010dd6e <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010dd00:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd03:	8b 40 38             	mov    0x38(%eax),%eax
f010dd06:	25 00 02 00 00       	and    $0x200,%eax
f010dd0b:	85 c0                	test   %eax,%eax
f010dd0d:	74 06                	je     f010dd15 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010dd0f:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010dd10:	e8 cd 6f ff ff       	call   f0104ce2 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010dd15:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd18:	8b 78 04             	mov    0x4(%eax),%edi
f010dd1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd1e:	8b 30                	mov    (%eax),%esi
f010dd20:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd23:	8b 58 10             	mov    0x10(%eax),%ebx
f010dd26:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd29:	8b 48 18             	mov    0x18(%eax),%ecx
f010dd2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd2f:	8b 50 14             	mov    0x14(%eax),%edx
f010dd32:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd35:	8b 40 1c             	mov    0x1c(%eax),%eax
f010dd38:	83 ec 08             	sub    $0x8,%esp
f010dd3b:	57                   	push   %edi
f010dd3c:	56                   	push   %esi
f010dd3d:	53                   	push   %ebx
f010dd3e:	51                   	push   %ecx
f010dd3f:	52                   	push   %edx
f010dd40:	50                   	push   %eax
f010dd41:	e8 a4 09 00 00       	call   f010e6ea <syscall>
f010dd46:	83 c4 20             	add    $0x20,%esp
f010dd49:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010dd4c:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd4f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010dd52:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010dd55:	9c                   	pushf  
f010dd56:	58                   	pop    %eax
f010dd57:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010dd5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010dd5d:	25 00 02 00 00       	and    $0x200,%eax
f010dd62:	85 c0                	test   %eax,%eax
f010dd64:	74 72                	je     f010ddd8 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010dd66:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010dd67:	e8 4e 6f ff ff       	call   f0104cba <kclock_stop>
f010dd6c:	eb 6a                	jmp    f010ddd8 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010dd6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010dd71:	8b 40 28             	mov    0x28(%eax),%eax
f010dd74:	83 f8 08             	cmp    $0x8,%eax
f010dd77:	75 17                	jne    f010dd90 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010dd79:	83 ec 04             	sub    $0x4,%esp
f010dd7c:	68 a7 6d 12 f0       	push   $0xf0126da7
f010dd81:	68 22 01 00 00       	push   $0x122
f010dd86:	68 b6 6d 12 f0       	push   $0xf0126db6
f010dd8b:	e8 a9 25 ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010dd90:	83 ec 0c             	sub    $0xc,%esp
f010dd93:	ff 75 08             	pushl  0x8(%ebp)
f010dd96:	e8 a3 fc ff ff       	call   f010da3e <print_trapframe>
f010dd9b:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010dd9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010dda1:	8b 40 34             	mov    0x34(%eax),%eax
f010dda4:	66 83 f8 08          	cmp    $0x8,%ax
f010dda8:	75 17                	jne    f010ddc1 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010ddaa:	83 ec 04             	sub    $0x4,%esp
f010ddad:	68 c7 6d 12 f0       	push   $0xf0126dc7
f010ddb2:	68 2a 01 00 00       	push   $0x12a
f010ddb7:	68 b6 6d 12 f0       	push   $0xf0126db6
f010ddbc:	e8 78 25 ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010ddc1:	83 ec 04             	sub    $0x4,%esp
f010ddc4:	68 e0 6d 12 f0       	push   $0xf0126de0
f010ddc9:	68 2f 01 00 00       	push   $0x12f
f010ddce:	68 b6 6d 12 f0       	push   $0xf0126db6
f010ddd3:	e8 61 25 ff ff       	call   f0100339 <_panic>
		}
	}
}
f010ddd8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010dddb:	5b                   	pop    %ebx
f010dddc:	5e                   	pop    %esi
f010dddd:	5f                   	pop    %edi
f010ddde:	5d                   	pop    %ebp
f010dddf:	c3                   	ret    

f010dde0 <trap>:

void trap(struct Trapframe *tf)
{
f010dde0:	55                   	push   %ebp
f010dde1:	89 e5                	mov    %esp,%ebp
f010dde3:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010dde6:	e8 cf 6e ff ff       	call   f0104cba <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ddeb:	9c                   	pushf  
f010ddec:	58                   	pop    %eax
f010dded:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010ddf0:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010ddf3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010ddf6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ddf9:	25 00 02 00 00       	and    $0x200,%eax
f010ddfe:	85 c0                	test   %eax,%eax
f010de00:	74 25                	je     f010de27 <trap+0x47>
	{
		print_trapframe(tf);
f010de02:	83 ec 0c             	sub    $0xc,%esp
f010de05:	ff 75 08             	pushl  0x8(%ebp)
f010de08:	e8 31 fc ff ff       	call   f010da3e <print_trapframe>
f010de0d:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010de10:	83 ec 04             	sub    $0x4,%esp
f010de13:	68 00 6e 12 f0       	push   $0xf0126e00
f010de18:	68 45 01 00 00       	push   $0x145
f010de1d:	68 b6 6d 12 f0       	push   $0xf0126db6
f010de22:	e8 12 25 ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010de27:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010de2e:	e8 55 d5 ff ff       	call   f010b388 <get_cpu_proc>
f010de33:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010de36:	8b 45 08             	mov    0x8(%ebp),%eax
f010de39:	8b 40 34             	mov    0x34(%eax),%eax
f010de3c:	0f b7 c0             	movzwl %ax,%eax
f010de3f:	83 e0 03             	and    $0x3,%eax
f010de42:	83 f8 03             	cmp    $0x3,%eax
f010de45:	75 54                	jne    f010de9b <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010de47:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010de4b:	74 0b                	je     f010de58 <trap+0x78>
f010de4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010de50:	8b 40 18             	mov    0x18(%eax),%eax
f010de53:	83 f8 02             	cmp    $0x2,%eax
f010de56:	74 19                	je     f010de71 <trap+0x91>
f010de58:	68 44 6e 12 f0       	push   $0xf0126e44
f010de5d:	68 72 6e 12 f0       	push   $0xf0126e72
f010de62:	68 4d 01 00 00       	push   $0x14d
f010de67:	68 b6 6d 12 f0       	push   $0xf0126db6
f010de6c:	e8 c8 24 ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010de71:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010de74:	8b 00                	mov    (%eax),%eax
f010de76:	3b 45 08             	cmp    0x8(%ebp),%eax
f010de79:	74 19                	je     f010de94 <trap+0xb4>
f010de7b:	68 87 6e 12 f0       	push   $0xf0126e87
f010de80:	68 72 6e 12 f0       	push   $0xf0126e72
f010de85:	68 4f 01 00 00       	push   $0x14f
f010de8a:	68 b6 6d 12 f0       	push   $0xf0126db6
f010de8f:	e8 a5 24 ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010de94:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010de9b:	8b 45 08             	mov    0x8(%ebp),%eax
f010de9e:	8b 40 28             	mov    0x28(%eax),%eax
f010dea1:	83 f8 1f             	cmp    $0x1f,%eax
f010dea4:	76 1b                	jbe    f010dec1 <trap+0xe1>
f010dea6:	8b 45 08             	mov    0x8(%ebp),%eax
f010dea9:	8b 40 28             	mov    0x28(%eax),%eax
f010deac:	83 f8 2f             	cmp    $0x2f,%eax
f010deaf:	77 10                	ja     f010dec1 <trap+0xe1>
	{
		irq_dispatch(tf);
f010deb1:	83 ec 0c             	sub    $0xc,%esp
f010deb4:	ff 75 08             	pushl  0x8(%ebp)
f010deb7:	e8 8c fd ff ff       	call   f010dc48 <irq_dispatch>
f010debc:	83 c4 10             	add    $0x10,%esp
f010debf:	eb 0e                	jmp    f010decf <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010dec1:	83 ec 0c             	sub    $0xc,%esp
f010dec4:	ff 75 08             	pushl  0x8(%ebp)
f010dec7:	e8 c4 fd ff ff       	call   f010dc90 <trap_dispatch>
f010decc:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010decf:	9c                   	pushf  
f010ded0:	58                   	pop    %eax
f010ded1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010ded4:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010ded7:	25 00 02 00 00       	and    $0x200,%eax
f010dedc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010dedf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010dee3:	74 19                	je     f010defe <trap+0x11e>
f010dee5:	68 9d 6e 12 f0       	push   $0xf0126e9d
f010deea:	68 72 6e 12 f0       	push   $0xf0126e72
f010deef:	68 66 01 00 00       	push   $0x166
f010def4:	68 b6 6d 12 f0       	push   $0xf0126db6
f010def9:	e8 3b 24 ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010defe:	e8 df 6d ff ff       	call   f0104ce2 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010df03:	90                   	nop
f010df04:	c9                   	leave  
f010df05:	c3                   	ret    

f010df06 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010df06:	6a 08                	push   $0x8
f010df08:	e9 ed 00 00 00       	jmp    f010dffa <_alltraps>
f010df0d:	90                   	nop

f010df0e <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010df0e:	6a 0e                	push   $0xe
f010df10:	e9 e5 00 00 00       	jmp    f010dffa <_alltraps>
f010df15:	90                   	nop

f010df16 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010df16:	6a 00                	push   $0x0
f010df18:	6a 20                	push   $0x20
f010df1a:	e9 db 00 00 00       	jmp    f010dffa <_alltraps>
f010df1f:	90                   	nop

f010df20 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010df20:	6a 00                	push   $0x0
f010df22:	6a 21                	push   $0x21
f010df24:	e9 d1 00 00 00       	jmp    f010dffa <_alltraps>
f010df29:	90                   	nop

f010df2a <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010df2a:	6a 00                	push   $0x0
f010df2c:	6a 30                	push   $0x30
f010df2e:	e9 c7 00 00 00       	jmp    f010dffa <_alltraps>
f010df33:	90                   	nop

f010df34 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010df34:	6a 00                	push   $0x0
f010df36:	6a 00                	push   $0x0
f010df38:	e9 bd 00 00 00       	jmp    f010dffa <_alltraps>
f010df3d:	90                   	nop

f010df3e <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010df3e:	6a 00                	push   $0x0
f010df40:	6a 01                	push   $0x1
f010df42:	e9 b3 00 00 00       	jmp    f010dffa <_alltraps>
f010df47:	90                   	nop

f010df48 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010df48:	6a 00                	push   $0x0
f010df4a:	6a 02                	push   $0x2
f010df4c:	e9 a9 00 00 00       	jmp    f010dffa <_alltraps>
f010df51:	90                   	nop

f010df52 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010df52:	6a 00                	push   $0x0
f010df54:	6a 03                	push   $0x3
f010df56:	e9 9f 00 00 00       	jmp    f010dffa <_alltraps>
f010df5b:	90                   	nop

f010df5c <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010df5c:	6a 00                	push   $0x0
f010df5e:	6a 04                	push   $0x4
f010df60:	e9 95 00 00 00       	jmp    f010dffa <_alltraps>
f010df65:	90                   	nop

f010df66 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010df66:	6a 00                	push   $0x0
f010df68:	6a 05                	push   $0x5
f010df6a:	e9 8b 00 00 00       	jmp    f010dffa <_alltraps>
f010df6f:	90                   	nop

f010df70 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010df70:	6a 00                	push   $0x0
f010df72:	6a 06                	push   $0x6
f010df74:	e9 81 00 00 00       	jmp    f010dffa <_alltraps>
f010df79:	90                   	nop

f010df7a <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010df7a:	6a 00                	push   $0x0
f010df7c:	6a 07                	push   $0x7
f010df7e:	eb 7a                	jmp    f010dffa <_alltraps>

f010df80 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010df80:	6a 0a                	push   $0xa
f010df82:	eb 76                	jmp    f010dffa <_alltraps>

f010df84 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010df84:	6a 0b                	push   $0xb
f010df86:	eb 72                	jmp    f010dffa <_alltraps>

f010df88 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010df88:	6a 0c                	push   $0xc
f010df8a:	eb 6e                	jmp    f010dffa <_alltraps>

f010df8c <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010df8c:	6a 0d                	push   $0xd
f010df8e:	eb 6a                	jmp    f010dffa <_alltraps>

f010df90 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010df90:	6a 00                	push   $0x0
f010df92:	6a 10                	push   $0x10
f010df94:	eb 64                	jmp    f010dffa <_alltraps>

f010df96 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010df96:	6a 11                	push   $0x11
f010df98:	eb 60                	jmp    f010dffa <_alltraps>

f010df9a <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010df9a:	6a 00                	push   $0x0
f010df9c:	6a 12                	push   $0x12
f010df9e:	eb 5a                	jmp    f010dffa <_alltraps>

f010dfa0 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010dfa0:	6a 00                	push   $0x0
f010dfa2:	6a 13                	push   $0x13
f010dfa4:	eb 54                	jmp    f010dffa <_alltraps>

f010dfa6 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010dfa6:	6a 00                	push   $0x0
f010dfa8:	6a 22                	push   $0x22
f010dfaa:	eb 4e                	jmp    f010dffa <_alltraps>

f010dfac <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010dfac:	6a 00                	push   $0x0
f010dfae:	6a 23                	push   $0x23
f010dfb0:	eb 48                	jmp    f010dffa <_alltraps>

f010dfb2 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010dfb2:	6a 00                	push   $0x0
f010dfb4:	6a 24                	push   $0x24
f010dfb6:	eb 42                	jmp    f010dffa <_alltraps>

f010dfb8 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010dfb8:	6a 00                	push   $0x0
f010dfba:	6a 25                	push   $0x25
f010dfbc:	eb 3c                	jmp    f010dffa <_alltraps>

f010dfbe <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010dfbe:	6a 00                	push   $0x0
f010dfc0:	6a 26                	push   $0x26
f010dfc2:	eb 36                	jmp    f010dffa <_alltraps>

f010dfc4 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010dfc4:	6a 00                	push   $0x0
f010dfc6:	6a 27                	push   $0x27
f010dfc8:	eb 30                	jmp    f010dffa <_alltraps>

f010dfca <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010dfca:	6a 00                	push   $0x0
f010dfcc:	6a 28                	push   $0x28
f010dfce:	eb 2a                	jmp    f010dffa <_alltraps>

f010dfd0 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010dfd0:	6a 00                	push   $0x0
f010dfd2:	6a 29                	push   $0x29
f010dfd4:	eb 24                	jmp    f010dffa <_alltraps>

f010dfd6 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010dfd6:	6a 00                	push   $0x0
f010dfd8:	6a 2a                	push   $0x2a
f010dfda:	eb 1e                	jmp    f010dffa <_alltraps>

f010dfdc <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010dfdc:	6a 00                	push   $0x0
f010dfde:	6a 2b                	push   $0x2b
f010dfe0:	eb 18                	jmp    f010dffa <_alltraps>

f010dfe2 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010dfe2:	6a 00                	push   $0x0
f010dfe4:	6a 2c                	push   $0x2c
f010dfe6:	eb 12                	jmp    f010dffa <_alltraps>

f010dfe8 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010dfe8:	6a 00                	push   $0x0
f010dfea:	6a 2d                	push   $0x2d
f010dfec:	eb 0c                	jmp    f010dffa <_alltraps>

f010dfee <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010dfee:	6a 00                	push   $0x0
f010dff0:	6a 2e                	push   $0x2e
f010dff2:	eb 06                	jmp    f010dffa <_alltraps>

f010dff4 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010dff4:	6a 00                	push   $0x0
f010dff6:	6a 2f                	push   $0x2f
f010dff8:	eb 00                	jmp    f010dffa <_alltraps>

f010dffa <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010dffa:	1e                   	push   %ds
push 	%es
f010dffb:	06                   	push   %es
pushal
f010dffc:	60                   	pusha  

mov 	$(GD_KD), %ax
f010dffd:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e001:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e003:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e005:	54                   	push   %esp
call 	trap
f010e006:	e8 d5 fd ff ff       	call   f010dde0 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e00b:	59                   	pop    %ecx

f010e00c <trapret>:
.globl trapret
trapret:
popal
f010e00c:	61                   	popa   
pop 	%es
f010e00d:	07                   	pop    %es
pop 	%ds
f010e00e:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e00f:	83 c4 08             	add    $0x8,%esp
iret
f010e012:	cf                   	iret   

f010e013 <to_frame_number>:
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);


static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010e013:	55                   	push   %ebp
f010e014:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010e016:	8b 45 08             	mov    0x8(%ebp),%eax
f010e019:	8b 15 c0 d7 6b f0    	mov    0xf06bd7c0,%edx
f010e01f:	29 d0                	sub    %edx,%eax
f010e021:	c1 f8 03             	sar    $0x3,%eax
f010e024:	89 c2                	mov    %eax,%edx
f010e026:	89 d0                	mov    %edx,%eax
f010e028:	c1 e0 02             	shl    $0x2,%eax
f010e02b:	01 d0                	add    %edx,%eax
f010e02d:	c1 e0 02             	shl    $0x2,%eax
f010e030:	01 d0                	add    %edx,%eax
f010e032:	c1 e0 02             	shl    $0x2,%eax
f010e035:	01 d0                	add    %edx,%eax
f010e037:	89 c1                	mov    %eax,%ecx
f010e039:	c1 e1 08             	shl    $0x8,%ecx
f010e03c:	01 c8                	add    %ecx,%eax
f010e03e:	89 c1                	mov    %eax,%ecx
f010e040:	c1 e1 10             	shl    $0x10,%ecx
f010e043:	01 c8                	add    %ecx,%eax
f010e045:	01 c0                	add    %eax,%eax
f010e047:	01 d0                	add    %edx,%eax
}
f010e049:	5d                   	pop    %ebp
f010e04a:	c3                   	ret    

f010e04b <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010e04b:	55                   	push   %ebp
f010e04c:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010e04e:	ff 75 08             	pushl  0x8(%ebp)
f010e051:	e8 bd ff ff ff       	call   f010e013 <to_frame_number>
f010e056:	83 c4 04             	add    $0x4,%esp
f010e059:	c1 e0 0c             	shl    $0xc,%eax
}
f010e05c:	c9                   	leave  
f010e05d:	c3                   	ret    

f010e05e <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010e05e:	55                   	push   %ebp
f010e05f:	89 e5                	mov    %esp,%ebp
f010e061:	83 ec 18             	sub    $0x18,%esp
f010e064:	8b 45 10             	mov    0x10(%ebp),%eax
f010e067:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010e06a:	e8 60 91 ff ff       	call   f01071cf <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010e06f:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010e073:	74 23                	je     f010e098 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e075:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e07a:	8b 40 10             	mov    0x10(%eax),%eax
f010e07d:	8b 15 a0 3f b0 f0    	mov    0xf0b03fa0,%edx
f010e083:	83 c2 20             	add    $0x20,%edx
f010e086:	83 ec 04             	sub    $0x4,%esp
f010e089:	50                   	push   %eax
f010e08a:	52                   	push   %edx
f010e08b:	68 50 70 12 f0       	push   $0xf0127050
f010e090:	e8 f6 2e ff ff       	call   f0100f8b <cprintf>
f010e095:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010e098:	83 ec 04             	sub    $0x4,%esp
f010e09b:	ff 75 08             	pushl  0x8(%ebp)
f010e09e:	ff 75 0c             	pushl  0xc(%ebp)
f010e0a1:	68 59 70 12 f0       	push   $0xf0127059
f010e0a6:	e8 e0 2e ff ff       	call   f0100f8b <cprintf>
f010e0ab:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010e0ae:	e8 6e 91 ff ff       	call   f0107221 <popcli>
}
f010e0b3:	90                   	nop
f010e0b4:	c9                   	leave  
f010e0b5:	c3                   	ret    

f010e0b6 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e0b6:	55                   	push   %ebp
f010e0b7:	89 e5                	mov    %esp,%ebp
f010e0b9:	83 ec 18             	sub    $0x18,%esp
f010e0bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0bf:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e0c2:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e0c6:	83 ec 08             	sub    $0x8,%esp
f010e0c9:	50                   	push   %eax
f010e0ca:	68 5e 70 12 f0       	push   $0xf012705e
f010e0cf:	e8 b7 2e ff ff       	call   f0100f8b <cprintf>
f010e0d4:	83 c4 10             	add    $0x10,%esp
}
f010e0d7:	90                   	nop
f010e0d8:	c9                   	leave  
f010e0d9:	c3                   	ret    

f010e0da <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e0da:	55                   	push   %ebp
f010e0db:	89 e5                	mov    %esp,%ebp
f010e0dd:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e0e0:	9c                   	pushf  
f010e0e1:	58                   	pop    %eax
f010e0e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e0e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e0e8:	25 00 02 00 00       	and    $0x200,%eax
f010e0ed:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e0f0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e0f4:	74 10                	je     f010e106 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e0f6:	e8 c9 2c ff ff       	call   f0100dc4 <cons_getc2>
f010e0fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e0fe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e102:	74 f2                	je     f010e0f6 <sys_cgetc+0x1c>
f010e104:	eb 0e                	jmp    f010e114 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e106:	e8 5e 2c ff ff       	call   f0100d69 <cons_getc>
f010e10b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e10e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e112:	74 f2                	je     f010e106 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e114:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e117:	c9                   	leave  
f010e118:	c3                   	ret    

f010e119 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e119:	55                   	push   %ebp
f010e11a:	89 e5                	mov    %esp,%ebp
f010e11c:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e11f:	e8 8c 2d ff ff       	call   f0100eb0 <cons_lock>
}
f010e124:	90                   	nop
f010e125:	c9                   	leave  
f010e126:	c3                   	ret    

f010e127 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e127:	55                   	push   %ebp
f010e128:	89 e5                	mov    %esp,%ebp
f010e12a:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e12d:	e8 c5 2d ff ff       	call   f0100ef7 <cons_unlock>
}
f010e132:	90                   	nop
f010e133:	c9                   	leave  
f010e134:	c3                   	ret    

f010e135 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e135:	55                   	push   %ebp
f010e136:	89 e5                	mov    %esp,%ebp
f010e138:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010e13b:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e140:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010e143:	83 ec 0c             	sub    $0xc,%esp
f010e146:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e149:	50                   	push   %eax
f010e14a:	e8 63 a0 ff ff       	call   f01081b2 <allocate_frame>
f010e14f:	83 c4 10             	add    $0x10,%esp
f010e152:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e155:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e159:	75 08                	jne    f010e163 <__sys_allocate_page+0x2e>
		return r ;
f010e15b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e15e:	e9 e9 00 00 00       	jmp    f010e24c <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e163:	8b 45 08             	mov    0x8(%ebp),%eax
f010e166:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e16b:	77 0c                	ja     f010e179 <__sys_allocate_page+0x44>
f010e16d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e170:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e175:	85 c0                	test   %eax,%eax
f010e177:	74 0a                	je     f010e183 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010e179:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e17e:	e9 c9 00 00 00       	jmp    f010e24c <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e183:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e186:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e18b:	83 f8 04             	cmp    $0x4,%eax
f010e18e:	74 0a                	je     f010e19a <__sys_allocate_page+0x65>
		return E_INVAL;
f010e190:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e195:	e9 b2 00 00 00       	jmp    f010e24c <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010e19a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e19d:	83 ec 0c             	sub    $0xc,%esp
f010e1a0:	50                   	push   %eax
f010e1a1:	e8 a5 fe ff ff       	call   f010e04b <to_physical_address>
f010e1a6:	83 c4 10             	add    $0x10,%esp
f010e1a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010e1ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e1af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1b2:	8b 40 64             	mov    0x64(%eax),%eax
f010e1b5:	6a 02                	push   $0x2
f010e1b7:	68 00 00 80 ef       	push   $0xef800000
f010e1bc:	52                   	push   %edx
f010e1bd:	50                   	push   %eax
f010e1be:	e8 bc a4 ff ff       	call   f010867f <map_frame>
f010e1c3:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010e1c6:	83 ec 04             	sub    $0x4,%esp
f010e1c9:	68 00 10 00 00       	push   $0x1000
f010e1ce:	6a 00                	push   $0x0
f010e1d0:	68 00 00 80 ef       	push   $0xef800000
f010e1d5:	e8 d8 15 01 00       	call   f011f7b2 <memset>
f010e1da:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010e1dd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e1e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e1e3:	8b 40 08             	mov    0x8(%eax),%eax
f010e1e6:	40                   	inc    %eax
f010e1e7:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010e1eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1ee:	8b 40 64             	mov    0x64(%eax),%eax
f010e1f1:	83 ec 08             	sub    $0x8,%esp
f010e1f4:	68 00 00 80 ef       	push   $0xef800000
f010e1f9:	50                   	push   %eax
f010e1fa:	e8 e0 a5 ff ff       	call   f01087df <unmap_frame>
f010e1ff:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010e202:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e205:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e208:	8b 40 08             	mov    0x8(%eax),%eax
f010e20b:	48                   	dec    %eax
f010e20c:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010e210:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e213:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e216:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e219:	8b 40 64             	mov    0x64(%eax),%eax
f010e21c:	ff 75 0c             	pushl  0xc(%ebp)
f010e21f:	51                   	push   %ecx
f010e220:	52                   	push   %edx
f010e221:	50                   	push   %eax
f010e222:	e8 58 a4 ff ff       	call   f010867f <map_frame>
f010e227:	83 c4 10             	add    $0x10,%esp
f010e22a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010e22d:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e231:	75 14                	jne    f010e247 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010e233:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e236:	83 ec 0c             	sub    $0xc,%esp
f010e239:	50                   	push   %eax
f010e23a:	e8 80 a1 ff ff       	call   f01083bf <decrement_references>
f010e23f:	83 c4 10             	add    $0x10,%esp
		return r;
f010e242:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e245:	eb 05                	jmp    f010e24c <__sys_allocate_page+0x117>
	}
	return 0 ;
f010e247:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e24c:	c9                   	leave  
f010e24d:	c3                   	ret    

f010e24e <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e24e:	55                   	push   %ebp
f010e24f:	89 e5                	mov    %esp,%ebp
f010e251:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e254:	83 ec 04             	sub    $0x4,%esp
f010e257:	68 61 70 12 f0       	push   $0xf0127061
f010e25c:	68 dc 00 00 00       	push   $0xdc
f010e261:	68 7f 70 12 f0       	push   $0xf012707f
f010e266:	e8 ce 20 ff ff       	call   f0100339 <_panic>

f010e26b <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010e26b:	55                   	push   %ebp
f010e26c:	89 e5                	mov    %esp,%ebp
f010e26e:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010e271:	83 ec 04             	sub    $0x4,%esp
f010e274:	68 94 70 12 f0       	push   $0xf0127094
f010e279:	68 ed 00 00 00       	push   $0xed
f010e27e:	68 7f 70 12 f0       	push   $0xf012707f
f010e283:	e8 b1 20 ff ff       	call   f0100339 <_panic>

f010e288 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e288:	55                   	push   %ebp
f010e289:	89 e5                	mov    %esp,%ebp
f010e28b:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e28e:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e293:	8b 40 64             	mov    0x64(%eax),%eax
f010e296:	83 ec 04             	sub    $0x4,%esp
f010e299:	ff 75 0c             	pushl  0xc(%ebp)
f010e29c:	ff 75 08             	pushl  0x8(%ebp)
f010e29f:	50                   	push   %eax
f010e2a0:	e8 26 c2 ff ff       	call   f010a4cb <calculate_required_frames>
f010e2a5:	83 c4 10             	add    $0x10,%esp
}
f010e2a8:	c9                   	leave  
f010e2a9:	c3                   	ret    

f010e2aa <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e2aa:	55                   	push   %ebp
f010e2ab:	89 e5                	mov    %esp,%ebp
f010e2ad:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e2b0:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e2b3:	83 ec 0c             	sub    $0xc,%esp
f010e2b6:	50                   	push   %eax
f010e2b7:	e8 a5 a6 ff ff       	call   f0108961 <calculate_available_frames>
f010e2bc:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e2bf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e2c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e2c5:	01 d0                	add    %edx,%eax
}
f010e2c7:	c9                   	leave  
f010e2c8:	c3                   	ret    

f010e2c9 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e2c9:	55                   	push   %ebp
f010e2ca:	89 e5                	mov    %esp,%ebp
f010e2cc:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e2cf:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e2d2:	83 ec 0c             	sub    $0xc,%esp
f010e2d5:	50                   	push   %eax
f010e2d6:	e8 86 a6 ff ff       	call   f0108961 <calculate_available_frames>
f010e2db:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e2de:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e2e1:	c9                   	leave  
f010e2e2:	c3                   	ret    

f010e2e3 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e2e3:	55                   	push   %ebp
f010e2e4:	89 e5                	mov    %esp,%ebp
f010e2e6:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e2e9:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e2ec:	83 ec 0c             	sub    $0xc,%esp
f010e2ef:	50                   	push   %eax
f010e2f0:	e8 6c a6 ff ff       	call   f0108961 <calculate_available_frames>
f010e2f5:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e2f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e2fb:	c9                   	leave  
f010e2fc:	c3                   	ret    

f010e2fd <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e2fd:	55                   	push   %ebp
f010e2fe:	89 e5                	mov    %esp,%ebp
f010e300:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e303:	83 ec 0c             	sub    $0xc,%esp
f010e306:	ff 75 08             	pushl  0x8(%ebp)
f010e309:	e8 4d 00 01 00       	call   f011e35b <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e30e:	83 c4 10             	add    $0x10,%esp
}
f010e311:	c9                   	leave  
f010e312:	c3                   	ret    

f010e313 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e313:	55                   	push   %ebp
f010e314:	89 e5                	mov    %esp,%ebp
f010e316:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e319:	e8 68 ff 00 00       	call   f011e286 <scarce_memory>
}
f010e31e:	90                   	nop
f010e31f:	c9                   	leave  
f010e320:	c3                   	ret    

f010e321 <sys_clearFFL>:

void sys_clearFFL()
{
f010e321:	55                   	push   %ebp
f010e322:	89 e5                	mov    %esp,%ebp
f010e324:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010e327:	83 ec 0c             	sub    $0xc,%esp
f010e32a:	68 80 d3 6b f0       	push   $0xf06bd380
f010e32f:	e8 e2 12 00 00       	call   f010f616 <acquire_spinlock>
f010e334:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e337:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f010e33c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e33f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e346:	eb 12                	jmp    f010e35a <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010e348:	83 ec 0c             	sub    $0xc,%esp
f010e34b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e34e:	50                   	push   %eax
f010e34f:	e8 5e 9e ff ff       	call   f01081b2 <allocate_frame>
f010e354:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e357:	ff 45 f4             	incl   -0xc(%ebp)
f010e35a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e35d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e360:	7c e6                	jl     f010e348 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010e362:	83 ec 0c             	sub    $0xc,%esp
f010e365:	68 80 d3 6b f0       	push   $0xf06bd380
f010e36a:	e8 2e 13 00 00       	call   f010f69d <release_spinlock>
f010e36f:	83 c4 10             	add    $0x10,%esp
}
f010e372:	90                   	nop
f010e373:	c9                   	leave  
f010e374:	c3                   	ret    

f010e375 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010e375:	55                   	push   %ebp
f010e376:	89 e5                	mov    %esp,%ebp
f010e378:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010e37b:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e380:	83 ec 0c             	sub    $0xc,%esp
f010e383:	50                   	push   %eax
f010e384:	e8 76 64 ff ff       	call   f01047ff <pf_calculate_allocated_pages>
f010e389:	83 c4 10             	add    $0x10,%esp
}
f010e38c:	c9                   	leave  
f010e38d:	c3                   	ret    

f010e38e <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010e38e:	55                   	push   %ebp
f010e38f:	89 e5                	mov    %esp,%ebp
f010e391:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010e394:	e8 ed 0c 00 00       	call   f010f086 <isBufferingEnabled>
f010e399:	84 c0                	test   %al,%al
f010e39b:	74 19                	je     f010e3b6 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010e39d:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e3a2:	83 ec 04             	sub    $0x4,%esp
f010e3a5:	ff 75 0c             	pushl  0xc(%ebp)
f010e3a8:	ff 75 08             	pushl  0x8(%ebp)
f010e3ab:	50                   	push   %eax
f010e3ac:	e8 49 c3 ff ff       	call   f010a6fa <__free_user_mem_with_buffering>
f010e3b1:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010e3b4:	eb 18                	jmp    f010e3ce <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010e3b6:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e3bb:	83 ec 04             	sub    $0x4,%esp
f010e3be:	ff 75 0c             	pushl  0xc(%ebp)
f010e3c1:	ff 75 08             	pushl  0x8(%ebp)
f010e3c4:	50                   	push   %eax
f010e3c5:	e8 60 c2 ff ff       	call   f010a62a <free_user_mem>
f010e3ca:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010e3cd:	90                   	nop
}
f010e3ce:	c9                   	leave  
f010e3cf:	c3                   	ret    

f010e3d0 <check_Param>:
// Youssef Mohsen
void check_Param(uint32 virtual_address)
{
f010e3d0:	55                   	push   %ebp
f010e3d1:	89 e5                	mov    %esp,%ebp
f010e3d3:	83 ec 08             	sub    $0x8,%esp
	if(virtual_address == 0)
f010e3d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e3da:	75 07                	jne    f010e3e3 <check_Param+0x13>
	{
		env_exit();
f010e3dc:	e8 65 cf ff ff       	call   f010b346 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e3e1:	eb 25                	jmp    f010e408 <check_Param+0x38>
{
	if(virtual_address == 0)
	{
		env_exit();
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
f010e3e3:	81 7d 08 00 00 00 a0 	cmpl   $0xa0000000,0x8(%ebp)
f010e3ea:	77 07                	ja     f010e3f3 <check_Param+0x23>
f010e3ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3ef:	85 c0                	test   %eax,%eax
f010e3f1:	78 07                	js     f010e3fa <check_Param+0x2a>
	{
		env_exit();
f010e3f3:	e8 4e cf ff ff       	call   f010b346 <env_exit>
	}
	else if(virtual_address >= KERNEL_BASE)
	{
		env_exit();
	}
}
f010e3f8:	eb 0e                	jmp    f010e408 <check_Param+0x38>
	}
	else if(virtual_address > USER_HEAP_MAX || virtual_address < USER_HEAP_START)
	{
		env_exit();
	}
	else if(virtual_address >= KERNEL_BASE)
f010e3fa:	81 7d 08 ff ff ff ef 	cmpl   $0xefffffff,0x8(%ebp)
f010e401:	76 05                	jbe    f010e408 <check_Param+0x38>
	{
		env_exit();
f010e403:	e8 3e cf ff ff       	call   f010b346 <env_exit>
	}
}
f010e408:	90                   	nop
f010e409:	c9                   	leave  
f010e40a:	c3                   	ret    

f010e40b <sys_allocate_user_mem>:
// Youssef Mohsen
void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010e40b:	55                   	push   %ebp
f010e40c:	89 e5                	mov    %esp,%ebp
f010e40e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010e411:	83 ec 0c             	sub    $0xc,%esp
f010e414:	ff 75 08             	pushl  0x8(%ebp)
f010e417:	e8 b4 ff ff ff       	call   f010e3d0 <check_Param>
f010e41c:	83 c4 10             	add    $0x10,%esp
	allocate_user_mem(cur_env, virtual_address, size);
f010e41f:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e424:	83 ec 04             	sub    $0x4,%esp
f010e427:	ff 75 0c             	pushl  0xc(%ebp)
f010e42a:	ff 75 08             	pushl  0x8(%ebp)
f010e42d:	50                   	push   %eax
f010e42e:	e8 3c c1 ff ff       	call   f010a56f <allocate_user_mem>
f010e433:	83 c4 10             	add    $0x10,%esp
	return;
f010e436:	90                   	nop
}
f010e437:	c9                   	leave  
f010e438:	c3                   	ret    

f010e439 <sys_allocate_chunk>:
// Youssef Mohsen
void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010e439:	55                   	push   %ebp
f010e43a:	89 e5                	mov    %esp,%ebp
f010e43c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	check_Param(virtual_address);
f010e43f:	83 ec 0c             	sub    $0xc,%esp
f010e442:	ff 75 08             	pushl  0x8(%ebp)
f010e445:	e8 86 ff ff ff       	call   f010e3d0 <check_Param>
f010e44a:	83 c4 10             	add    $0x10,%esp
	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010e44d:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e452:	8b 40 64             	mov    0x64(%eax),%eax
f010e455:	ff 75 10             	pushl  0x10(%ebp)
f010e458:	ff 75 0c             	pushl  0xc(%ebp)
f010e45b:	ff 75 08             	pushl  0x8(%ebp)
f010e45e:	50                   	push   %eax
f010e45f:	e8 33 c0 ff ff       	call   f010a497 <allocate_chunk>
f010e464:	83 c4 10             	add    $0x10,%esp
	return;
f010e467:	90                   	nop
}
f010e468:	c9                   	leave  
f010e469:	c3                   	ret    

f010e46a <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010e46a:	55                   	push   %ebp
f010e46b:	89 e5                	mov    %esp,%ebp
f010e46d:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010e470:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e475:	ff 75 10             	pushl  0x10(%ebp)
f010e478:	ff 75 0c             	pushl  0xc(%ebp)
f010e47b:	ff 75 08             	pushl  0x8(%ebp)
f010e47e:	50                   	push   %eax
f010e47f:	e8 93 c2 ff ff       	call   f010a717 <move_user_mem>
f010e484:	83 c4 10             	add    $0x10,%esp
	return;
f010e487:	90                   	nop
}
f010e488:	c9                   	leave  
f010e489:	c3                   	ret    

f010e48a <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010e48a:	55                   	push   %ebp
f010e48b:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010e48d:	a1 a4 d7 6b f0       	mov    0xf06bd7a4,%eax
}
f010e492:	5d                   	pop    %ebp
f010e493:	c3                   	ret    

f010e494 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010e494:	55                   	push   %ebp
f010e495:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010e497:	8b 45 08             	mov    0x8(%ebp),%eax
f010e49a:	a3 a4 d7 6b f0       	mov    %eax,0xf06bd7a4
}
f010e49f:	90                   	nop
f010e4a0:	5d                   	pop    %ebp
f010e4a1:	c3                   	ret    

f010e4a2 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010e4a2:	55                   	push   %ebp
f010e4a3:	89 e5                	mov    %esp,%ebp
f010e4a5:	83 ec 18             	sub    $0x18,%esp
f010e4a8:	8b 45 10             	mov    0x10(%ebp),%eax
f010e4ab:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010e4ae:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010e4b2:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e4b7:	8b 40 10             	mov    0x10(%eax),%eax
f010e4ba:	83 ec 0c             	sub    $0xc,%esp
f010e4bd:	ff 75 14             	pushl  0x14(%ebp)
f010e4c0:	52                   	push   %edx
f010e4c1:	ff 75 0c             	pushl  0xc(%ebp)
f010e4c4:	ff 75 08             	pushl  0x8(%ebp)
f010e4c7:	50                   	push   %eax
f010e4c8:	e8 b8 a7 ff ff       	call   f0108c85 <createSharedObject>
f010e4cd:	83 c4 20             	add    $0x20,%esp
}
f010e4d0:	c9                   	leave  
f010e4d1:	c3                   	ret    

f010e4d2 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010e4d2:	55                   	push   %ebp
f010e4d3:	89 e5                	mov    %esp,%ebp
f010e4d5:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010e4d8:	83 ec 08             	sub    $0x8,%esp
f010e4db:	ff 75 0c             	pushl  0xc(%ebp)
f010e4de:	ff 75 08             	pushl  0x8(%ebp)
f010e4e1:	e8 9a a5 ff ff       	call   f0108a80 <getSizeOfSharedObject>
f010e4e6:	83 c4 10             	add    $0x10,%esp
}
f010e4e9:	c9                   	leave  
f010e4ea:	c3                   	ret    

f010e4eb <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010e4eb:	55                   	push   %ebp
f010e4ec:	89 e5                	mov    %esp,%ebp
f010e4ee:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010e4f1:	83 ec 04             	sub    $0x4,%esp
f010e4f4:	ff 75 10             	pushl  0x10(%ebp)
f010e4f7:	ff 75 0c             	pushl  0xc(%ebp)
f010e4fa:	ff 75 08             	pushl  0x8(%ebp)
f010e4fd:	e8 16 a9 ff ff       	call   f0108e18 <getSharedObject>
f010e502:	83 c4 10             	add    $0x10,%esp
}
f010e505:	c9                   	leave  
f010e506:	c3                   	ret    

f010e507 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010e507:	55                   	push   %ebp
f010e508:	89 e5                	mov    %esp,%ebp
f010e50a:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010e50d:	83 ec 08             	sub    $0x8,%esp
f010e510:	ff 75 0c             	pushl  0xc(%ebp)
f010e513:	ff 75 08             	pushl  0x8(%ebp)
f010e516:	e8 f2 a9 ff ff       	call   f0108f0d <freeSharedObject>
f010e51b:	83 c4 10             	add    $0x10,%esp
}
f010e51e:	c9                   	leave  
f010e51f:	c3                   	ret    

f010e520 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010e520:	55                   	push   %ebp
f010e521:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010e523:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e528:	8b 40 10             	mov    0x10(%eax),%eax
}
f010e52b:	5d                   	pop    %ebp
f010e52c:	c3                   	ret    

f010e52d <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010e52d:	55                   	push   %ebp
f010e52e:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010e530:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e535:	89 c2                	mov    %eax,%edx
f010e537:	a1 d0 47 69 f0       	mov    0xf06947d0,%eax
f010e53c:	29 c2                	sub    %eax,%edx
f010e53e:	89 d0                	mov    %edx,%eax
f010e540:	c1 f8 02             	sar    $0x2,%eax
f010e543:	89 c2                	mov    %eax,%edx
f010e545:	89 d0                	mov    %edx,%eax
f010e547:	c1 e0 03             	shl    $0x3,%eax
f010e54a:	01 d0                	add    %edx,%eax
f010e54c:	c1 e0 03             	shl    $0x3,%eax
f010e54f:	01 d0                	add    %edx,%eax
f010e551:	c1 e0 02             	shl    $0x2,%eax
f010e554:	01 d0                	add    %edx,%eax
f010e556:	01 c0                	add    %eax,%eax
f010e558:	01 d0                	add    %edx,%eax
f010e55a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010e561:	01 c8                	add    %ecx,%eax
f010e563:	c1 e0 02             	shl    $0x2,%eax
f010e566:	01 d0                	add    %edx,%eax
f010e568:	c1 e0 03             	shl    $0x3,%eax
f010e56b:	01 d0                	add    %edx,%eax
f010e56d:	c1 e0 05             	shl    $0x5,%eax
f010e570:	29 d0                	sub    %edx,%eax
f010e572:	c1 e0 02             	shl    $0x2,%eax
f010e575:	01 d0                	add    %edx,%eax
f010e577:	01 c0                	add    %eax,%eax
f010e579:	01 d0                	add    %edx,%eax
f010e57b:	c1 e0 03             	shl    $0x3,%eax
f010e57e:	01 d0                	add    %edx,%eax
f010e580:	c1 e0 04             	shl    $0x4,%eax
f010e583:	29 d0                	sub    %edx,%eax
}
f010e585:	5d                   	pop    %ebp
f010e586:	c3                   	ret    

f010e587 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010e587:	55                   	push   %ebp
f010e588:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010e58a:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e58f:	8b 40 14             	mov    0x14(%eax),%eax
}
f010e592:	5d                   	pop    %ebp
f010e593:	c3                   	ret    

f010e594 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010e594:	55                   	push   %ebp
f010e595:	89 e5                	mov    %esp,%ebp
f010e597:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010e59a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e59e:	75 0a                	jne    f010e5aa <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010e5a0:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e5a8:	eb 22                	jmp    f010e5cc <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010e5aa:	83 ec 04             	sub    $0x4,%esp
f010e5ad:	6a 00                	push   $0x0
f010e5af:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010e5b2:	50                   	push   %eax
f010e5b3:	ff 75 08             	pushl  0x8(%ebp)
f010e5b6:	e8 1d ce ff ff       	call   f010b3d8 <envid2env>
f010e5bb:	83 c4 10             	add    $0x10,%esp
f010e5be:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e5c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e5c5:	79 05                	jns    f010e5cc <sys_destroy_env+0x38>
	{
		return r;
f010e5c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5ca:	eb 5e                	jmp    f010e62a <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010e5cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e5cf:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5d4:	39 c2                	cmp    %eax,%edx
f010e5d6:	75 1b                	jne    f010e5f3 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010e5d8:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5dd:	8b 40 10             	mov    0x10(%eax),%eax
f010e5e0:	83 ec 08             	sub    $0x8,%esp
f010e5e3:	50                   	push   %eax
f010e5e4:	68 b3 70 12 f0       	push   $0xf01270b3
f010e5e9:	e8 9d 29 ff ff       	call   f0100f8b <cprintf>
f010e5ee:	83 c4 10             	add    $0x10,%esp
f010e5f1:	eb 20                	jmp    f010e613 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010e5f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e5f6:	8b 50 10             	mov    0x10(%eax),%edx
f010e5f9:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e5fe:	8b 40 10             	mov    0x10(%eax),%eax
f010e601:	83 ec 04             	sub    $0x4,%esp
f010e604:	52                   	push   %edx
f010e605:	50                   	push   %eax
f010e606:	68 ce 70 12 f0       	push   $0xf01270ce
f010e60b:	e8 7b 29 ff ff       	call   f0100f8b <cprintf>
f010e610:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010e613:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e616:	8b 40 10             	mov    0x10(%eax),%eax
f010e619:	83 ec 0c             	sub    $0xc,%esp
f010e61c:	50                   	push   %eax
f010e61d:	e8 96 74 ff ff       	call   f0105ab8 <sched_kill_env>
f010e622:	83 c4 10             	add    $0x10,%esp

	return 0;
f010e625:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e62a:	c9                   	leave  
f010e62b:	c3                   	ret    

f010e62c <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010e62c:	55                   	push   %ebp
f010e62d:	89 e5                	mov    %esp,%ebp
f010e62f:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010e632:	e8 0f cd ff ff       	call   f010b346 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010e637:	90                   	nop
f010e638:	c9                   	leave  
f010e639:	c3                   	ret    

f010e63a <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010e63a:	55                   	push   %ebp
f010e63b:	89 e5                	mov    %esp,%ebp
f010e63d:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010e640:	ff 75 14             	pushl  0x14(%ebp)
f010e643:	ff 75 10             	pushl  0x10(%ebp)
f010e646:	ff 75 0c             	pushl  0xc(%ebp)
f010e649:	ff 75 08             	pushl  0x8(%ebp)
f010e64c:	e8 b9 c2 ff ff       	call   f010a90a <env_create>
f010e651:	83 c4 10             	add    $0x10,%esp
f010e654:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010e657:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e65b:	75 07                	jne    f010e664 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010e65d:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010e662:	eb 14                	jmp    f010e678 <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010e664:	83 ec 0c             	sub    $0xc,%esp
f010e667:	ff 75 f4             	pushl  -0xc(%ebp)
f010e66a:	e8 ad 70 ff ff       	call   f010571c <sched_new_env>
f010e66f:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010e672:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e675:	8b 40 10             	mov    0x10(%eax),%eax
}
f010e678:	c9                   	leave  
f010e679:	c3                   	ret    

f010e67a <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010e67a:	55                   	push   %ebp
f010e67b:	89 e5                	mov    %esp,%ebp
f010e67d:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010e680:	8b 45 08             	mov    0x8(%ebp),%eax
f010e683:	83 ec 0c             	sub    $0xc,%esp
f010e686:	50                   	push   %eax
f010e687:	e8 e6 70 ff ff       	call   f0105772 <sched_run_env>
f010e68c:	83 c4 10             	add    $0x10,%esp
}
f010e68f:	90                   	nop
f010e690:	c9                   	leave  
f010e691:	c3                   	ret    

f010e692 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010e692:	55                   	push   %ebp
f010e693:	89 e5                	mov    %esp,%ebp
f010e695:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010e698:	0f 31                	rdtsc  
f010e69a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010e69d:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010e6a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e6a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e6a6:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e6a9:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010e6ac:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010e6af:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e6b2:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e6b5:	89 01                	mov    %eax,(%ecx)
f010e6b7:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010e6ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6bd:	c9                   	leave  
f010e6be:	c2 04 00             	ret    $0x4

f010e6c1 <sys_rcr2>:

uint32 sys_rcr2()
{
f010e6c1:	55                   	push   %ebp
f010e6c2:	89 e5                	mov    %esp,%ebp
f010e6c4:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e6c7:	0f 20 d0             	mov    %cr2,%eax
f010e6ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010e6cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010e6d0:	90                   	nop
}
f010e6d1:	c9                   	leave  
f010e6d2:	c3                   	ret    

f010e6d3 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010e6d3:	55                   	push   %ebp
f010e6d4:	89 e5                	mov    %esp,%ebp
f010e6d6:	83 ec 04             	sub    $0x4,%esp
f010e6d9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6dc:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010e6df:	8a 45 fc             	mov    -0x4(%ebp),%al
f010e6e2:	a2 40 50 69 f0       	mov    %al,0xf0695040
}
f010e6e7:	90                   	nop
f010e6e8:	c9                   	leave  
f010e6e9:	c3                   	ret    

f010e6ea <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010e6ea:	55                   	push   %ebp
f010e6eb:	89 e5                	mov    %esp,%ebp
f010e6ed:	56                   	push   %esi
f010e6ee:	53                   	push   %ebx
f010e6ef:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010e6f2:	e8 91 cc ff ff       	call   f010b388 <get_cpu_proc>
f010e6f7:	a3 a0 3f b0 f0       	mov    %eax,0xf0b03fa0
	assert(cur_env != NULL);
f010e6fc:	a1 a0 3f b0 f0       	mov    0xf0b03fa0,%eax
f010e701:	85 c0                	test   %eax,%eax
f010e703:	75 19                	jne    f010e71e <syscall+0x34>
f010e705:	68 e6 70 12 f0       	push   $0xf01270e6
f010e70a:	68 f6 70 12 f0       	push   $0xf01270f6
f010e70f:	68 05 02 00 00       	push   $0x205
f010e714:	68 7f 70 12 f0       	push   $0xf012707f
f010e719:	e8 1b 1c ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010e71e:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010e722:	0f 87 06 04 00 00    	ja     f010eb2e <syscall+0x444>
f010e728:	8b 45 08             	mov    0x8(%ebp),%eax
f010e72b:	c1 e0 02             	shl    $0x2,%eax
f010e72e:	05 0c 71 12 f0       	add    $0xf012710c,%eax
f010e733:	8b 00                	mov    (%eax),%eax
f010e735:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here
	case SYS_sbrk:
		return (uint32)sys_sbrk(a1);
f010e737:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e73a:	83 ec 0c             	sub    $0xc,%esp
f010e73d:	50                   	push   %eax
f010e73e:	e8 a2 bd ff ff       	call   f010a4e5 <sys_sbrk>
f010e743:	83 c4 10             	add    $0x10,%esp
f010e746:	e9 e8 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_free_user_mem:
		sys_free_user_mem(a1,a2);
f010e74b:	83 ec 08             	sub    $0x8,%esp
f010e74e:	ff 75 10             	pushl  0x10(%ebp)
f010e751:	ff 75 0c             	pushl  0xc(%ebp)
f010e754:	e8 35 fc ff ff       	call   f010e38e <sys_free_user_mem>
f010e759:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e75c:	b8 00 00 00 00       	mov    $0x0,%eax
f010e761:	e9 cd 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1,a2);
f010e766:	83 ec 08             	sub    $0x8,%esp
f010e769:	ff 75 10             	pushl  0x10(%ebp)
f010e76c:	ff 75 0c             	pushl  0xc(%ebp)
f010e76f:	e8 97 fc ff ff       	call   f010e40b <sys_allocate_user_mem>
f010e774:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e777:	b8 00 00 00 00       	mov    $0x0,%eax
f010e77c:	e9 b2 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010e781:	8b 45 14             	mov    0x14(%ebp),%eax
f010e784:	0f b6 d0             	movzbl %al,%edx
f010e787:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e78a:	83 ec 04             	sub    $0x4,%esp
f010e78d:	52                   	push   %edx
f010e78e:	ff 75 10             	pushl  0x10(%ebp)
f010e791:	50                   	push   %eax
f010e792:	e8 c7 f8 ff ff       	call   f010e05e <sys_cputs>
f010e797:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e79a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e79f:	e9 8f 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010e7a4:	e8 31 f9 ff ff       	call   f010e0da <sys_cgetc>
f010e7a9:	e9 85 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010e7ae:	e8 66 f9 ff ff       	call   f010e119 <sys_lock_cons>
		return 0;
f010e7b3:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7b8:	e9 76 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010e7bd:	e8 65 f9 ff ff       	call   f010e127 <sys_unlock_cons>
		return 0;
f010e7c2:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7c7:	e9 67 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010e7cc:	83 ec 08             	sub    $0x8,%esp
f010e7cf:	ff 75 10             	pushl  0x10(%ebp)
f010e7d2:	ff 75 0c             	pushl  0xc(%ebp)
f010e7d5:	e8 ae fa ff ff       	call   f010e288 <sys_calculate_required_frames>
f010e7da:	83 c4 10             	add    $0x10,%esp
f010e7dd:	e9 51 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010e7e2:	e8 c3 fa ff ff       	call   f010e2aa <sys_calculate_free_frames>
f010e7e7:	e9 47 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010e7ec:	e8 d8 fa ff ff       	call   f010e2c9 <sys_calculate_modified_frames>
f010e7f1:	e9 3d 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010e7f6:	e8 e8 fa ff ff       	call   f010e2e3 <sys_calculate_notmod_frames>
f010e7fb:	e9 33 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010e800:	e8 70 fb ff ff       	call   f010e375 <sys_pf_calculate_allocated_pages>
f010e805:	e9 29 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010e80a:	83 ec 0c             	sub    $0xc,%esp
f010e80d:	ff 75 0c             	pushl  0xc(%ebp)
f010e810:	e8 e8 fa ff ff       	call   f010e2fd <sys_calculate_pages_tobe_removed_ready_exit>
f010e815:	83 c4 10             	add    $0x10,%esp
f010e818:	e9 16 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010e81d:	e8 f1 fa ff ff       	call   f010e313 <sys_scarce_memory>
		return 0;
f010e822:	b8 00 00 00 00       	mov    $0x0,%eax
f010e827:	e9 07 03 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010e82c:	83 ec 04             	sub    $0x4,%esp
f010e82f:	ff 75 14             	pushl  0x14(%ebp)
f010e832:	ff 75 10             	pushl  0x10(%ebp)
f010e835:	ff 75 0c             	pushl  0xc(%ebp)
f010e838:	e8 fc fb ff ff       	call   f010e439 <sys_allocate_chunk>
f010e83d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e840:	b8 00 00 00 00       	mov    $0x0,%eax
f010e845:	e9 e9 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010e84a:	8b 55 10             	mov    0x10(%ebp),%edx
f010e84d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e850:	83 ec 08             	sub    $0x8,%esp
f010e853:	52                   	push   %edx
f010e854:	50                   	push   %eax
f010e855:	e8 db f8 ff ff       	call   f010e135 <__sys_allocate_page>
f010e85a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e85d:	b8 00 00 00 00       	mov    $0x0,%eax
f010e862:	e9 cc 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010e867:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010e86a:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e86d:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e870:	8b 55 10             	mov    0x10(%ebp),%edx
f010e873:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e876:	83 ec 0c             	sub    $0xc,%esp
f010e879:	56                   	push   %esi
f010e87a:	53                   	push   %ebx
f010e87b:	51                   	push   %ecx
f010e87c:	52                   	push   %edx
f010e87d:	50                   	push   %eax
f010e87e:	e8 cb f9 ff ff       	call   f010e24e <__sys_map_frame>
f010e883:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e886:	b8 00 00 00 00       	mov    $0x0,%eax
f010e88b:	e9 a3 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010e890:	8b 55 10             	mov    0x10(%ebp),%edx
f010e893:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e896:	83 ec 08             	sub    $0x8,%esp
f010e899:	52                   	push   %edx
f010e89a:	50                   	push   %eax
f010e89b:	e8 cb f9 ff ff       	call   f010e26b <__sys_unmap_frame>
f010e8a0:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e8a3:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8a8:	e9 86 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010e8ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8b0:	0f be c0             	movsbl %al,%eax
f010e8b3:	83 ec 0c             	sub    $0xc,%esp
f010e8b6:	50                   	push   %eax
f010e8b7:	e8 fa f7 ff ff       	call   f010e0b6 <sys_cputc>
f010e8bc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e8bf:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8c4:	e9 6a 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010e8c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8cc:	0f be c0             	movsbl %al,%eax
f010e8cf:	83 ec 0c             	sub    $0xc,%esp
f010e8d2:	50                   	push   %eax
f010e8d3:	e8 49 fa ff ff       	call   f010e321 <sys_clearFFL>
f010e8d8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e8db:	b8 00 00 00 00       	mov    $0x0,%eax
f010e8e0:	e9 4e 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010e8e5:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e8e8:	8b 45 14             	mov    0x14(%ebp),%eax
f010e8eb:	0f b6 d0             	movzbl %al,%edx
f010e8ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8f1:	51                   	push   %ecx
f010e8f2:	52                   	push   %edx
f010e8f3:	ff 75 10             	pushl  0x10(%ebp)
f010e8f6:	50                   	push   %eax
f010e8f7:	e8 a6 fb ff ff       	call   f010e4a2 <sys_createSharedObject>
f010e8fc:	83 c4 10             	add    $0x10,%esp
f010e8ff:	e9 2f 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010e904:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e907:	8b 55 10             	mov    0x10(%ebp),%edx
f010e90a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e90d:	83 ec 04             	sub    $0x4,%esp
f010e910:	51                   	push   %ecx
f010e911:	52                   	push   %edx
f010e912:	50                   	push   %eax
f010e913:	e8 d3 fb ff ff       	call   f010e4eb <sys_getSharedObject>
f010e918:	83 c4 10             	add    $0x10,%esp
f010e91b:	e9 13 02 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010e920:	8b 55 10             	mov    0x10(%ebp),%edx
f010e923:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e926:	83 ec 08             	sub    $0x8,%esp
f010e929:	52                   	push   %edx
f010e92a:	50                   	push   %eax
f010e92b:	e8 d7 fb ff ff       	call   f010e507 <sys_freeSharedObject>
f010e930:	83 c4 10             	add    $0x10,%esp
f010e933:	e9 fb 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010e938:	8b 55 10             	mov    0x10(%ebp),%edx
f010e93b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e93e:	83 ec 08             	sub    $0x8,%esp
f010e941:	52                   	push   %edx
f010e942:	50                   	push   %eax
f010e943:	e8 8a fb ff ff       	call   f010e4d2 <sys_getSizeOfSharedObject>
f010e948:	83 c4 10             	add    $0x10,%esp
f010e94b:	e9 e3 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010e950:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e953:	ff 75 18             	pushl  0x18(%ebp)
f010e956:	ff 75 14             	pushl  0x14(%ebp)
f010e959:	ff 75 10             	pushl  0x10(%ebp)
f010e95c:	50                   	push   %eax
f010e95d:	e8 d8 fc ff ff       	call   f010e63a <sys_create_env>
f010e962:	83 c4 10             	add    $0x10,%esp
f010e965:	e9 c9 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010e96a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e96d:	83 ec 0c             	sub    $0xc,%esp
f010e970:	50                   	push   %eax
f010e971:	e8 04 fd ff ff       	call   f010e67a <sys_run_env>
f010e976:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e979:	b8 00 00 00 00       	mov    $0x0,%eax
f010e97e:	e9 b0 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010e983:	e8 a5 fb ff ff       	call   f010e52d <sys_getenvindex>
f010e988:	e9 a6 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010e98d:	e8 8e fb ff ff       	call   f010e520 <sys_getenvid>
f010e992:	e9 9c 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010e997:	e8 eb fb ff ff       	call   f010e587 <sys_getparentenvid>
f010e99c:	e9 92 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010e9a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9a4:	83 ec 0c             	sub    $0xc,%esp
f010e9a7:	50                   	push   %eax
f010e9a8:	e8 e7 fb ff ff       	call   f010e594 <sys_destroy_env>
f010e9ad:	83 c4 10             	add    $0x10,%esp
f010e9b0:	e9 7e 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010e9b5:	e8 72 fc ff ff       	call   f010e62c <sys_exit_env>
		return 0;
f010e9ba:	b8 00 00 00 00       	mov    $0x0,%eax
f010e9bf:	e9 6f 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010e9c4:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e9c7:	83 ec 0c             	sub    $0xc,%esp
f010e9ca:	50                   	push   %eax
f010e9cb:	e8 c2 fc ff ff       	call   f010e692 <sys_get_virtual_time>
f010e9d0:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010e9d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010e9d9:	8b 45 10             	mov    0x10(%ebp),%eax
f010e9dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010e9df:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e9e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9e5:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010e9e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e9ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e9ed:	89 10                	mov    %edx,(%eax)
		return 0;
f010e9ef:	b8 00 00 00 00       	mov    $0x0,%eax
f010e9f4:	e9 3a 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010e9f9:	83 ec 04             	sub    $0x4,%esp
f010e9fc:	ff 75 14             	pushl  0x14(%ebp)
f010e9ff:	ff 75 10             	pushl  0x10(%ebp)
f010ea02:	ff 75 0c             	pushl  0xc(%ebp)
f010ea05:	e8 60 fa ff ff       	call   f010e46a <sys_move_user_mem>
f010ea0a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ea0d:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea12:	e9 1c 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010ea17:	e8 a5 fc ff ff       	call   f010e6c1 <sys_rcr2>
f010ea1c:	e9 12 01 00 00       	jmp    f010eb33 <syscall+0x449>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010ea21:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea24:	0f b6 c0             	movzbl %al,%eax
f010ea27:	83 ec 0c             	sub    $0xc,%esp
f010ea2a:	50                   	push   %eax
f010ea2b:	e8 a3 fc ff ff       	call   f010e6d3 <sys_bypassPageFault>
f010ea30:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ea33:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea38:	e9 f6 00 00 00       	jmp    f010eb33 <syscall+0x449>

	case SYS_rsttst:
		rsttst();
f010ea3d:	e8 f8 ee 00 00       	call   f011d93a <rsttst>
		return 0;
f010ea42:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea47:	e9 e7 00 00 00       	jmp    f010eb33 <syscall+0x449>
	case SYS_inctst:
		inctst();
f010ea4c:	e8 31 ef 00 00       	call   f011d982 <inctst>
		return 0;
f010ea51:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea56:	e9 d8 00 00 00       	jmp    f010eb33 <syscall+0x449>
	case SYS_chktst:
		chktst(a1);
f010ea5b:	83 ec 0c             	sub    $0xc,%esp
f010ea5e:	ff 75 0c             	pushl  0xc(%ebp)
f010ea61:	e8 5e f0 00 00       	call   f011dac4 <chktst>
f010ea66:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ea69:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea6e:	e9 c0 00 00 00       	jmp    f010eb33 <syscall+0x449>
	case SYS_gettst:
		return gettst();
f010ea73:	e8 3e ef 00 00       	call   f011d9b6 <gettst>
f010ea78:	e9 b6 00 00 00       	jmp    f010eb33 <syscall+0x449>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010ea7d:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010ea80:	8b 45 18             	mov    0x18(%ebp),%eax
f010ea83:	0f be c0             	movsbl %al,%eax
f010ea86:	83 ec 0c             	sub    $0xc,%esp
f010ea89:	52                   	push   %edx
f010ea8a:	50                   	push   %eax
f010ea8b:	ff 75 14             	pushl  0x14(%ebp)
f010ea8e:	ff 75 10             	pushl  0x10(%ebp)
f010ea91:	ff 75 0c             	pushl  0xc(%ebp)
f010ea94:	e8 27 ef 00 00       	call   f011d9c0 <tst>
f010ea99:	83 c4 20             	add    $0x20,%esp
		return 0;
f010ea9c:	b8 00 00 00 00       	mov    $0x0,%eax
f010eaa1:	e9 8d 00 00 00       	jmp    f010eb33 <syscall+0x449>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010eaa6:	e8 df f9 ff ff       	call   f010e48a <sys_get_heap_strategy>
f010eaab:	e9 83 00 00 00       	jmp    f010eb33 <syscall+0x449>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010eab0:	83 ec 0c             	sub    $0xc,%esp
f010eab3:	ff 75 0c             	pushl  0xc(%ebp)
f010eab6:	e8 d9 f9 ff ff       	call   f010e494 <sys_set_uheap_strategy>
f010eabb:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eabe:	b8 00 00 00 00       	mov    $0x0,%eax
f010eac3:	eb 6e                	jmp    f010eb33 <syscall+0x449>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010eac5:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010eac8:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010eacb:	8b 55 10             	mov    0x10(%ebp),%edx
f010eace:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ead1:	53                   	push   %ebx
f010ead2:	51                   	push   %ecx
f010ead3:	52                   	push   %edx
f010ead4:	50                   	push   %eax
f010ead5:	e8 b3 1d 00 00       	call   f011088d <sys_check_LRU_lists>
f010eada:	83 c4 10             	add    $0x10,%esp
f010eadd:	eb 54                	jmp    f010eb33 <syscall+0x449>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010eadf:	8b 55 10             	mov    0x10(%ebp),%edx
f010eae2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eae5:	83 ec 08             	sub    $0x8,%esp
f010eae8:	52                   	push   %edx
f010eae9:	50                   	push   %eax
f010eaea:	e8 60 1f 00 00       	call   f0110a4f <sys_check_LRU_lists_free>
f010eaef:	83 c4 10             	add    $0x10,%esp
f010eaf2:	eb 3f                	jmp    f010eb33 <syscall+0x449>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010eaf4:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010eaf7:	8b 55 10             	mov    0x10(%ebp),%edx
f010eafa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eafd:	51                   	push   %ecx
f010eafe:	ff 75 14             	pushl  0x14(%ebp)
f010eb01:	52                   	push   %edx
f010eb02:	50                   	push   %eax
f010eb03:	e8 d4 20 00 00       	call   f0110bdc <sys_check_WS_list>
f010eb08:	83 c4 10             	add    $0x10,%esp
f010eb0b:	eb 26                	jmp    f010eb33 <syscall+0x449>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010eb0d:	8b 55 10             	mov    0x10(%ebp),%edx
f010eb10:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb13:	83 ec 08             	sub    $0x8,%esp
f010eb16:	52                   	push   %edx
f010eb17:	50                   	push   %eax
f010eb18:	e8 a8 f1 00 00       	call   f011dcc5 <sys_utilities>
f010eb1d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eb20:	b8 00 00 00 00       	mov    $0x0,%eax
f010eb25:	eb 0c                	jmp    f010eb33 <syscall+0x449>

	case NSYSCALLS:
		return 	-E_INVAL;
f010eb27:	b8 03 00 00 00       	mov    $0x3,%eax
f010eb2c:	eb 05                	jmp    f010eb33 <syscall+0x449>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010eb2e:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010eb33:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010eb36:	5b                   	pop    %ebx
f010eb37:	5e                   	pop    %esi
f010eb38:	5d                   	pop    %ebp
f010eb39:	c3                   	ret    

f010eb3a <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010eb3a:	55                   	push   %ebp
f010eb3b:	89 e5                	mov    %esp,%ebp
f010eb3d:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010eb40:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb43:	8b 00                	mov    (%eax),%eax
f010eb45:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010eb48:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb4b:	8b 00                	mov    (%eax),%eax
f010eb4d:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010eb50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010eb57:	e9 ca 00 00 00       	jmp    f010ec26 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010eb5c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010eb5f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010eb62:	01 d0                	add    %edx,%eax
f010eb64:	89 c2                	mov    %eax,%edx
f010eb66:	c1 ea 1f             	shr    $0x1f,%edx
f010eb69:	01 d0                	add    %edx,%eax
f010eb6b:	d1 f8                	sar    %eax
f010eb6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010eb70:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eb73:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010eb76:	eb 03                	jmp    f010eb7b <stab_binsearch+0x41>
			m--;
f010eb78:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010eb7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eb7e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010eb81:	7c 1e                	jl     f010eba1 <stab_binsearch+0x67>
f010eb83:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010eb86:	89 d0                	mov    %edx,%eax
f010eb88:	01 c0                	add    %eax,%eax
f010eb8a:	01 d0                	add    %edx,%eax
f010eb8c:	c1 e0 02             	shl    $0x2,%eax
f010eb8f:	89 c2                	mov    %eax,%edx
f010eb91:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb94:	01 d0                	add    %edx,%eax
f010eb96:	8a 40 04             	mov    0x4(%eax),%al
f010eb99:	0f b6 c0             	movzbl %al,%eax
f010eb9c:	3b 45 14             	cmp    0x14(%ebp),%eax
f010eb9f:	75 d7                	jne    f010eb78 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010eba1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eba4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010eba7:	7d 09                	jge    f010ebb2 <stab_binsearch+0x78>
			l = true_m + 1;
f010eba9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ebac:	40                   	inc    %eax
f010ebad:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010ebb0:	eb 74                	jmp    f010ec26 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010ebb2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010ebb9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ebbc:	89 d0                	mov    %edx,%eax
f010ebbe:	01 c0                	add    %eax,%eax
f010ebc0:	01 d0                	add    %edx,%eax
f010ebc2:	c1 e0 02             	shl    $0x2,%eax
f010ebc5:	89 c2                	mov    %eax,%edx
f010ebc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebca:	01 d0                	add    %edx,%eax
f010ebcc:	8b 40 08             	mov    0x8(%eax),%eax
f010ebcf:	3b 45 18             	cmp    0x18(%ebp),%eax
f010ebd2:	73 11                	jae    f010ebe5 <stab_binsearch+0xab>
			*region_left = m;
f010ebd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebd7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ebda:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010ebdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ebdf:	40                   	inc    %eax
f010ebe0:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010ebe3:	eb 41                	jmp    f010ec26 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010ebe5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ebe8:	89 d0                	mov    %edx,%eax
f010ebea:	01 c0                	add    %eax,%eax
f010ebec:	01 d0                	add    %edx,%eax
f010ebee:	c1 e0 02             	shl    $0x2,%eax
f010ebf1:	89 c2                	mov    %eax,%edx
f010ebf3:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebf6:	01 d0                	add    %edx,%eax
f010ebf8:	8b 40 08             	mov    0x8(%eax),%eax
f010ebfb:	3b 45 18             	cmp    0x18(%ebp),%eax
f010ebfe:	76 14                	jbe    f010ec14 <stab_binsearch+0xda>
			*region_right = m - 1;
f010ec00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec03:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ec06:	8b 45 10             	mov    0x10(%ebp),%eax
f010ec09:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010ec0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec0e:	48                   	dec    %eax
f010ec0f:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ec12:	eb 12                	jmp    f010ec26 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010ec14:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec17:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ec1a:	89 10                	mov    %edx,(%eax)
			l = m;
f010ec1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec1f:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010ec22:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010ec26:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ec29:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010ec2c:	0f 8e 2a ff ff ff    	jle    f010eb5c <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010ec32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec36:	75 0f                	jne    f010ec47 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010ec38:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec3b:	8b 00                	mov    (%eax),%eax
f010ec3d:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ec40:	8b 45 10             	mov    0x10(%ebp),%eax
f010ec43:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010ec45:	eb 3d                	jmp    f010ec84 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010ec47:	8b 45 10             	mov    0x10(%ebp),%eax
f010ec4a:	8b 00                	mov    (%eax),%eax
f010ec4c:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010ec4f:	eb 03                	jmp    f010ec54 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010ec51:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010ec54:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec57:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010ec59:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010ec5c:	7d 1e                	jge    f010ec7c <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010ec5e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ec61:	89 d0                	mov    %edx,%eax
f010ec63:	01 c0                	add    %eax,%eax
f010ec65:	01 d0                	add    %edx,%eax
f010ec67:	c1 e0 02             	shl    $0x2,%eax
f010ec6a:	89 c2                	mov    %eax,%edx
f010ec6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec6f:	01 d0                	add    %edx,%eax
f010ec71:	8a 40 04             	mov    0x4(%eax),%al
f010ec74:	0f b6 c0             	movzbl %al,%eax
f010ec77:	3b 45 14             	cmp    0x14(%ebp),%eax
f010ec7a:	75 d5                	jne    f010ec51 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010ec7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec7f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ec82:	89 10                	mov    %edx,(%eax)
	}
}
f010ec84:	90                   	nop
f010ec85:	c9                   	leave  
f010ec86:	c3                   	ret    

f010ec87 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010ec87:	55                   	push   %ebp
f010ec88:	89 e5                	mov    %esp,%ebp
f010ec8a:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010ec8d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec90:	c7 00 c8 71 12 f0    	movl   $0xf01271c8,(%eax)
	info->eip_line = 0;
f010ec96:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec99:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010eca0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eca3:	c7 40 08 c8 71 12 f0 	movl   $0xf01271c8,0x8(%eax)
	info->eip_fn_namelen = 9;
f010ecaa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecad:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010ecb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecb7:	8b 55 08             	mov    0x8(%ebp),%edx
f010ecba:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010ecbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecc0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010ecc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecca:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010eccf:	76 1e                	jbe    f010ecef <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010ecd1:	c7 45 f4 5c 0f 13 f0 	movl   $0xf0130f5c,-0xc(%ebp)
		stab_end = __STAB_END__;
f010ecd8:	c7 45 f0 c0 3e 16 f0 	movl   $0xf0163ec0,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010ecdf:	c7 45 ec c1 3e 16 f0 	movl   $0xf0163ec1,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010ece6:	c7 45 e8 e1 57 17 f0 	movl   $0xf01757e1,-0x18(%ebp)
f010eced:	eb 2a                	jmp    f010ed19 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010ecef:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010ecf6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ecf9:	8b 00                	mov    (%eax),%eax
f010ecfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010ecfe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ed01:	8b 40 04             	mov    0x4(%eax),%eax
f010ed04:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010ed07:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ed0a:	8b 40 08             	mov    0x8(%eax),%eax
f010ed0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010ed10:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ed13:	8b 40 0c             	mov    0xc(%eax),%eax
f010ed16:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010ed19:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ed1c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010ed1f:	76 0a                	jbe    f010ed2b <debuginfo_eip+0xa4>
f010ed21:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ed24:	48                   	dec    %eax
f010ed25:	8a 00                	mov    (%eax),%al
f010ed27:	84 c0                	test   %al,%al
f010ed29:	74 0a                	je     f010ed35 <debuginfo_eip+0xae>
		return -1;
f010ed2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ed30:	e9 01 02 00 00       	jmp    f010ef36 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010ed35:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010ed3c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ed3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed42:	29 c2                	sub    %eax,%edx
f010ed44:	89 d0                	mov    %edx,%eax
f010ed46:	c1 f8 02             	sar    $0x2,%eax
f010ed49:	89 c2                	mov    %eax,%edx
f010ed4b:	89 d0                	mov    %edx,%eax
f010ed4d:	c1 e0 02             	shl    $0x2,%eax
f010ed50:	01 d0                	add    %edx,%eax
f010ed52:	c1 e0 02             	shl    $0x2,%eax
f010ed55:	01 d0                	add    %edx,%eax
f010ed57:	c1 e0 02             	shl    $0x2,%eax
f010ed5a:	01 d0                	add    %edx,%eax
f010ed5c:	89 c1                	mov    %eax,%ecx
f010ed5e:	c1 e1 08             	shl    $0x8,%ecx
f010ed61:	01 c8                	add    %ecx,%eax
f010ed63:	89 c1                	mov    %eax,%ecx
f010ed65:	c1 e1 10             	shl    $0x10,%ecx
f010ed68:	01 c8                	add    %ecx,%eax
f010ed6a:	01 c0                	add    %eax,%eax
f010ed6c:	01 d0                	add    %edx,%eax
f010ed6e:	48                   	dec    %eax
f010ed6f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010ed72:	ff 75 08             	pushl  0x8(%ebp)
f010ed75:	6a 64                	push   $0x64
f010ed77:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010ed7a:	50                   	push   %eax
f010ed7b:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010ed7e:	50                   	push   %eax
f010ed7f:	ff 75 f4             	pushl  -0xc(%ebp)
f010ed82:	e8 b3 fd ff ff       	call   f010eb3a <stab_binsearch>
f010ed87:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010ed8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ed8d:	85 c0                	test   %eax,%eax
f010ed8f:	75 0a                	jne    f010ed9b <debuginfo_eip+0x114>
		return -1;
f010ed91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010ed96:	e9 9b 01 00 00       	jmp    f010ef36 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010ed9b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ed9e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010eda1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010eda4:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010eda7:	ff 75 08             	pushl  0x8(%ebp)
f010edaa:	6a 24                	push   $0x24
f010edac:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010edaf:	50                   	push   %eax
f010edb0:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010edb3:	50                   	push   %eax
f010edb4:	ff 75 f4             	pushl  -0xc(%ebp)
f010edb7:	e8 7e fd ff ff       	call   f010eb3a <stab_binsearch>
f010edbc:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010edbf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010edc2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010edc5:	39 c2                	cmp    %eax,%edx
f010edc7:	0f 8f 86 00 00 00    	jg     f010ee53 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010edcd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010edd0:	89 c2                	mov    %eax,%edx
f010edd2:	89 d0                	mov    %edx,%eax
f010edd4:	01 c0                	add    %eax,%eax
f010edd6:	01 d0                	add    %edx,%eax
f010edd8:	c1 e0 02             	shl    $0x2,%eax
f010eddb:	89 c2                	mov    %eax,%edx
f010eddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ede0:	01 d0                	add    %edx,%eax
f010ede2:	8b 00                	mov    (%eax),%eax
f010ede4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010ede7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010edea:	29 d1                	sub    %edx,%ecx
f010edec:	89 ca                	mov    %ecx,%edx
f010edee:	39 d0                	cmp    %edx,%eax
f010edf0:	73 22                	jae    f010ee14 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010edf2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010edf5:	89 c2                	mov    %eax,%edx
f010edf7:	89 d0                	mov    %edx,%eax
f010edf9:	01 c0                	add    %eax,%eax
f010edfb:	01 d0                	add    %edx,%eax
f010edfd:	c1 e0 02             	shl    $0x2,%eax
f010ee00:	89 c2                	mov    %eax,%edx
f010ee02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee05:	01 d0                	add    %edx,%eax
f010ee07:	8b 10                	mov    (%eax),%edx
f010ee09:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee0c:	01 c2                	add    %eax,%edx
f010ee0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee11:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010ee14:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ee17:	89 c2                	mov    %eax,%edx
f010ee19:	89 d0                	mov    %edx,%eax
f010ee1b:	01 c0                	add    %eax,%eax
f010ee1d:	01 d0                	add    %edx,%eax
f010ee1f:	c1 e0 02             	shl    $0x2,%eax
f010ee22:	89 c2                	mov    %eax,%edx
f010ee24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee27:	01 d0                	add    %edx,%eax
f010ee29:	8b 50 08             	mov    0x8(%eax),%edx
f010ee2c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee2f:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010ee32:	8b 55 08             	mov    0x8(%ebp),%edx
f010ee35:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee38:	8b 40 10             	mov    0x10(%eax),%eax
f010ee3b:	29 c2                	sub    %eax,%edx
f010ee3d:	89 d0                	mov    %edx,%eax
f010ee3f:	c1 f8 02             	sar    $0x2,%eax
f010ee42:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010ee45:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ee48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010ee4b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ee4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010ee51:	eb 15                	jmp    f010ee68 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010ee53:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee56:	8b 55 08             	mov    0x8(%ebp),%edx
f010ee59:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010ee5c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ee5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010ee62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010ee65:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010ee68:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee6b:	8b 40 08             	mov    0x8(%eax),%eax
f010ee6e:	83 ec 08             	sub    $0x8,%esp
f010ee71:	6a 3a                	push   $0x3a
f010ee73:	50                   	push   %eax
f010ee74:	e8 0d 09 01 00       	call   f011f786 <strfind>
f010ee79:	83 c4 10             	add    $0x10,%esp
f010ee7c:	89 c2                	mov    %eax,%edx
f010ee7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee81:	8b 40 08             	mov    0x8(%eax),%eax
f010ee84:	29 c2                	sub    %eax,%edx
f010ee86:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee89:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010ee8c:	eb 03                	jmp    f010ee91 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010ee8e:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010ee91:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010ee94:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010ee97:	7c 4e                	jl     f010eee7 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010ee99:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ee9c:	89 d0                	mov    %edx,%eax
f010ee9e:	01 c0                	add    %eax,%eax
f010eea0:	01 d0                	add    %edx,%eax
f010eea2:	c1 e0 02             	shl    $0x2,%eax
f010eea5:	89 c2                	mov    %eax,%edx
f010eea7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eeaa:	01 d0                	add    %edx,%eax
f010eeac:	8a 40 04             	mov    0x4(%eax),%al
f010eeaf:	3c 84                	cmp    $0x84,%al
f010eeb1:	74 34                	je     f010eee7 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010eeb3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010eeb6:	89 d0                	mov    %edx,%eax
f010eeb8:	01 c0                	add    %eax,%eax
f010eeba:	01 d0                	add    %edx,%eax
f010eebc:	c1 e0 02             	shl    $0x2,%eax
f010eebf:	89 c2                	mov    %eax,%edx
f010eec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eec4:	01 d0                	add    %edx,%eax
f010eec6:	8a 40 04             	mov    0x4(%eax),%al
f010eec9:	3c 64                	cmp    $0x64,%al
f010eecb:	75 c1                	jne    f010ee8e <debuginfo_eip+0x207>
f010eecd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010eed0:	89 d0                	mov    %edx,%eax
f010eed2:	01 c0                	add    %eax,%eax
f010eed4:	01 d0                	add    %edx,%eax
f010eed6:	c1 e0 02             	shl    $0x2,%eax
f010eed9:	89 c2                	mov    %eax,%edx
f010eedb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eede:	01 d0                	add    %edx,%eax
f010eee0:	8b 40 08             	mov    0x8(%eax),%eax
f010eee3:	85 c0                	test   %eax,%eax
f010eee5:	74 a7                	je     f010ee8e <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010eee7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010eeea:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010eeed:	7c 42                	jl     f010ef31 <debuginfo_eip+0x2aa>
f010eeef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010eef2:	89 d0                	mov    %edx,%eax
f010eef4:	01 c0                	add    %eax,%eax
f010eef6:	01 d0                	add    %edx,%eax
f010eef8:	c1 e0 02             	shl    $0x2,%eax
f010eefb:	89 c2                	mov    %eax,%edx
f010eefd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef00:	01 d0                	add    %edx,%eax
f010ef02:	8b 00                	mov    (%eax),%eax
f010ef04:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010ef07:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ef0a:	29 d1                	sub    %edx,%ecx
f010ef0c:	89 ca                	mov    %ecx,%edx
f010ef0e:	39 d0                	cmp    %edx,%eax
f010ef10:	73 1f                	jae    f010ef31 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010ef12:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010ef15:	89 d0                	mov    %edx,%eax
f010ef17:	01 c0                	add    %eax,%eax
f010ef19:	01 d0                	add    %edx,%eax
f010ef1b:	c1 e0 02             	shl    $0x2,%eax
f010ef1e:	89 c2                	mov    %eax,%edx
f010ef20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef23:	01 d0                	add    %edx,%eax
f010ef25:	8b 10                	mov    (%eax),%edx
f010ef27:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef2a:	01 c2                	add    %eax,%edx
f010ef2c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef2f:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010ef31:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef36:	c9                   	leave  
f010ef37:	c3                   	ret    

f010ef38 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010ef38:	55                   	push   %ebp
f010ef39:	89 e5                	mov    %esp,%ebp
f010ef3b:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010ef3e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010ef42:	74 1c                	je     f010ef60 <setPageReplacmentAlgorithmLRU+0x28>
f010ef44:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ef48:	74 16                	je     f010ef60 <setPageReplacmentAlgorithmLRU+0x28>
f010ef4a:	68 d4 71 12 f0       	push   $0xf01271d4
f010ef4f:	68 1e 72 12 f0       	push   $0xf012721e
f010ef54:	6a 1a                	push   $0x1a
f010ef56:	68 33 72 12 f0       	push   $0xf0127233
f010ef5b:	e8 d9 13 ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010ef60:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef63:	a3 10 da 6b f0       	mov    %eax,0xf06bda10
}
f010ef68:	90                   	nop
f010ef69:	c9                   	leave  
f010ef6a:	c3                   	ret    

f010ef6b <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010ef6b:	55                   	push   %ebp
f010ef6c:	89 e5                	mov    %esp,%ebp
f010ef6e:	c7 05 10 da 6b f0 03 	movl   $0x3,0xf06bda10
f010ef75:	00 00 00 
f010ef78:	90                   	nop
f010ef79:	5d                   	pop    %ebp
f010ef7a:	c3                   	ret    

f010ef7b <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010ef7b:	55                   	push   %ebp
f010ef7c:	89 e5                	mov    %esp,%ebp
f010ef7e:	c7 05 10 da 6b f0 04 	movl   $0x4,0xf06bda10
f010ef85:	00 00 00 
f010ef88:	90                   	nop
f010ef89:	5d                   	pop    %ebp
f010ef8a:	c3                   	ret    

f010ef8b <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010ef8b:	55                   	push   %ebp
f010ef8c:	89 e5                	mov    %esp,%ebp
f010ef8e:	c7 05 10 da 6b f0 05 	movl   $0x5,0xf06bda10
f010ef95:	00 00 00 
f010ef98:	90                   	nop
f010ef99:	5d                   	pop    %ebp
f010ef9a:	c3                   	ret    

f010ef9b <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010ef9b:	55                   	push   %ebp
f010ef9c:	89 e5                	mov    %esp,%ebp
f010ef9e:	c7 05 10 da 6b f0 07 	movl   $0x7,0xf06bda10
f010efa5:	00 00 00 
f010efa8:	90                   	nop
f010efa9:	5d                   	pop    %ebp
f010efaa:	c3                   	ret    

f010efab <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010efab:	55                   	push   %ebp
f010efac:	89 e5                	mov    %esp,%ebp
f010efae:	c7 05 10 da 6b f0 06 	movl   $0x6,0xf06bda10
f010efb5:	00 00 00 
f010efb8:	8b 45 08             	mov    0x8(%ebp),%eax
f010efbb:	a3 54 d3 6b f0       	mov    %eax,0xf06bd354
f010efc0:	90                   	nop
f010efc1:	5d                   	pop    %ebp
f010efc2:	c3                   	ret    

f010efc3 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010efc3:	55                   	push   %ebp
f010efc4:	89 e5                	mov    %esp,%ebp
f010efc6:	8b 15 10 da 6b f0    	mov    0xf06bda10,%edx
f010efcc:	8b 45 08             	mov    0x8(%ebp),%eax
f010efcf:	39 c2                	cmp    %eax,%edx
f010efd1:	0f 94 c0             	sete   %al
f010efd4:	0f b6 c0             	movzbl %al,%eax
f010efd7:	5d                   	pop    %ebp
f010efd8:	c3                   	ret    

f010efd9 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010efd9:	55                   	push   %ebp
f010efda:	89 e5                	mov    %esp,%ebp
f010efdc:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010efe1:	83 f8 03             	cmp    $0x3,%eax
f010efe4:	75 07                	jne    f010efed <isPageReplacmentAlgorithmCLOCK+0x14>
f010efe6:	b8 01 00 00 00       	mov    $0x1,%eax
f010efeb:	eb 05                	jmp    f010eff2 <isPageReplacmentAlgorithmCLOCK+0x19>
f010efed:	b8 00 00 00 00       	mov    $0x0,%eax
f010eff2:	5d                   	pop    %ebp
f010eff3:	c3                   	ret    

f010eff4 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010eff4:	55                   	push   %ebp
f010eff5:	89 e5                	mov    %esp,%ebp
f010eff7:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010effc:	83 f8 04             	cmp    $0x4,%eax
f010efff:	75 07                	jne    f010f008 <isPageReplacmentAlgorithmFIFO+0x14>
f010f001:	b8 01 00 00 00       	mov    $0x1,%eax
f010f006:	eb 05                	jmp    f010f00d <isPageReplacmentAlgorithmFIFO+0x19>
f010f008:	b8 00 00 00 00       	mov    $0x0,%eax
f010f00d:	5d                   	pop    %ebp
f010f00e:	c3                   	ret    

f010f00f <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f00f:	55                   	push   %ebp
f010f010:	89 e5                	mov    %esp,%ebp
f010f012:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010f017:	83 f8 05             	cmp    $0x5,%eax
f010f01a:	75 07                	jne    f010f023 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f01c:	b8 01 00 00 00       	mov    $0x1,%eax
f010f021:	eb 05                	jmp    f010f028 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f023:	b8 00 00 00 00       	mov    $0x0,%eax
f010f028:	5d                   	pop    %ebp
f010f029:	c3                   	ret    

f010f02a <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f02a:	55                   	push   %ebp
f010f02b:	89 e5                	mov    %esp,%ebp
f010f02d:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010f032:	83 f8 07             	cmp    $0x7,%eax
f010f035:	75 07                	jne    f010f03e <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f037:	b8 01 00 00 00       	mov    $0x1,%eax
f010f03c:	eb 05                	jmp    f010f043 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f03e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f043:	5d                   	pop    %ebp
f010f044:	c3                   	ret    

f010f045 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f045:	55                   	push   %ebp
f010f046:	89 e5                	mov    %esp,%ebp
f010f048:	a1 10 da 6b f0       	mov    0xf06bda10,%eax
f010f04d:	83 f8 06             	cmp    $0x6,%eax
f010f050:	75 07                	jne    f010f059 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f052:	b8 01 00 00 00       	mov    $0x1,%eax
f010f057:	eb 05                	jmp    f010f05e <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f059:	b8 00 00 00 00       	mov    $0x0,%eax
f010f05e:	5d                   	pop    %ebp
f010f05f:	c3                   	ret    

f010f060 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f060:	55                   	push   %ebp
f010f061:	89 e5                	mov    %esp,%ebp
f010f063:	8b 45 08             	mov    0x8(%ebp),%eax
f010f066:	a3 b8 d7 6b f0       	mov    %eax,0xf06bd7b8
f010f06b:	90                   	nop
f010f06c:	5d                   	pop    %ebp
f010f06d:	c3                   	ret    

f010f06e <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f06e:	55                   	push   %ebp
f010f06f:	89 e5                	mov    %esp,%ebp
f010f071:	a1 b8 d7 6b f0       	mov    0xf06bd7b8,%eax
f010f076:	5d                   	pop    %ebp
f010f077:	c3                   	ret    

f010f078 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f078:	55                   	push   %ebp
f010f079:	89 e5                	mov    %esp,%ebp
f010f07b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f07e:	a3 94 da 6b f0       	mov    %eax,0xf06bda94
f010f083:	90                   	nop
f010f084:	5d                   	pop    %ebp
f010f085:	c3                   	ret    

f010f086 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f086:	55                   	push   %ebp
f010f087:	89 e5                	mov    %esp,%ebp
f010f089:	a1 94 da 6b f0       	mov    0xf06bda94,%eax
f010f08e:	5d                   	pop    %ebp
f010f08f:	c3                   	ret    

f010f090 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f090:	55                   	push   %ebp
f010f091:	89 e5                	mov    %esp,%ebp
f010f093:	8b 45 08             	mov    0x8(%ebp),%eax
f010f096:	a3 30 db 6b f0       	mov    %eax,0xf06bdb30
f010f09b:	90                   	nop
f010f09c:	5d                   	pop    %ebp
f010f09d:	c3                   	ret    

f010f09e <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f09e:	55                   	push   %ebp
f010f09f:	89 e5                	mov    %esp,%ebp
f010f0a1:	a1 30 db 6b f0       	mov    0xf06bdb30,%eax
f010f0a6:	5d                   	pop    %ebp
f010f0a7:	c3                   	ret    

f010f0a8 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f0a8:	55                   	push   %ebp
f010f0a9:	89 e5                	mov    %esp,%ebp
f010f0ab:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f0ae:	0f 20 d0             	mov    %cr2,%eax
f010f0b1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f0b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f0b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f0ba:	e8 c9 c2 ff ff       	call   f010b388 <get_cpu_proc>
f010f0bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f0c2:	a1 4c 50 69 f0       	mov    0xf069504c,%eax
f010f0c7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f0ca:	75 50                	jne    f010f11c <fault_handler+0x74>
f010f0cc:	a1 58 50 69 f0       	mov    0xf0695058,%eax
f010f0d1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f0d4:	75 46                	jne    f010f11c <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f0d6:	a0 54 50 69 f0       	mov    0xf0695054,%al
f010f0db:	40                   	inc    %eax
f010f0dc:	a2 54 50 69 f0       	mov    %al,0xf0695054
		if (num_repeated_fault == 3)
f010f0e1:	a0 54 50 69 f0       	mov    0xf0695054,%al
f010f0e6:	3c 03                	cmp    $0x3,%al
f010f0e8:	75 4d                	jne    f010f137 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f0ea:	83 ec 0c             	sub    $0xc,%esp
f010f0ed:	ff 75 08             	pushl  0x8(%ebp)
f010f0f0:	e8 49 e9 ff ff       	call   f010da3e <print_trapframe>
f010f0f5:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f0f8:	8b 15 48 50 69 f0    	mov    0xf0695048,%edx
f010f0fe:	a1 50 50 69 f0       	mov    0xf0695050,%eax
f010f103:	83 ec 08             	sub    $0x8,%esp
f010f106:	ff 75 ec             	pushl  -0x14(%ebp)
f010f109:	52                   	push   %edx
f010f10a:	50                   	push   %eax
f010f10b:	68 50 72 12 f0       	push   $0xf0127250
f010f110:	6a 58                	push   $0x58
f010f112:	68 33 72 12 f0       	push   $0xf0127233
f010f117:	e8 1d 12 ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f11c:	a1 4c 50 69 f0       	mov    0xf069504c,%eax
f010f121:	a3 50 50 69 f0       	mov    %eax,0xf0695050
		before_last_eip = last_eip;
f010f126:	a1 44 50 69 f0       	mov    0xf0695044,%eax
f010f12b:	a3 48 50 69 f0       	mov    %eax,0xf0695048
		num_repeated_fault = 0;
f010f130:	c6 05 54 50 69 f0 00 	movb   $0x0,0xf0695054
	}
	last_eip = (uint32)tf->tf_eip;
f010f137:	8b 45 08             	mov    0x8(%ebp),%eax
f010f13a:	8b 40 30             	mov    0x30(%eax),%eax
f010f13d:	a3 44 50 69 f0       	mov    %eax,0xf0695044
	last_fault_va = fault_va ;
f010f142:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f145:	a3 4c 50 69 f0       	mov    %eax,0xf069504c
	last_faulted_env = cur_env;
f010f14a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f14d:	a3 58 50 69 f0       	mov    %eax,0xf0695058
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f152:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010f159:	8b 45 08             	mov    0x8(%ebp),%eax
f010f15c:	8b 40 34             	mov    0x34(%eax),%eax
f010f15f:	0f b7 c0             	movzwl %ax,%eax
f010f162:	83 e0 03             	and    $0x3,%eax
f010f165:	83 f8 03             	cmp    $0x3,%eax
f010f168:	75 07                	jne    f010f171 <fault_handler+0xc9>
		userTrap = 1;
f010f16a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010f171:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f175:	0f 85 c2 00 00 00    	jne    f010f23d <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010f17b:	e8 8c 7f ff ff       	call   f010710c <mycpu>
f010f180:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010f183:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010f187:	74 2f                	je     f010f1b8 <fault_handler+0x110>
f010f189:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f18c:	8b 40 70             	mov    0x70(%eax),%eax
f010f18f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f192:	77 24                	ja     f010f1b8 <fault_handler+0x110>
f010f194:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f197:	8b 40 70             	mov    0x70(%eax),%eax
f010f19a:	05 00 10 00 00       	add    $0x1000,%eax
f010f19f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f1a2:	76 14                	jbe    f010f1b8 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010f1a4:	83 ec 04             	sub    $0x4,%esp
f010f1a7:	68 c0 72 12 f0       	push   $0xf01272c0
f010f1ac:	6a 6f                	push   $0x6f
f010f1ae:	68 33 72 12 f0       	push   $0xf0127233
f010f1b3:	e8 81 11 ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010f1b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f1bb:	8b 40 08             	mov    0x8(%eax),%eax
f010f1be:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f1c1:	77 5d                	ja     f010f220 <fault_handler+0x178>
f010f1c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f1c6:	8b 40 08             	mov    0x8(%eax),%eax
f010f1c9:	05 00 10 00 00       	add    $0x1000,%eax
f010f1ce:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f1d1:	76 4d                	jbe    f010f220 <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010f1d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f1d6:	ba a0 d4 6b f0       	mov    $0xf06bd4a0,%edx
f010f1db:	29 d0                	sub    %edx,%eax
f010f1dd:	c1 f8 03             	sar    $0x3,%eax
f010f1e0:	89 c2                	mov    %eax,%edx
f010f1e2:	89 d0                	mov    %edx,%eax
f010f1e4:	c1 e0 02             	shl    $0x2,%eax
f010f1e7:	01 d0                	add    %edx,%eax
f010f1e9:	01 c0                	add    %eax,%eax
f010f1eb:	01 d0                	add    %edx,%eax
f010f1ed:	c1 e0 03             	shl    $0x3,%eax
f010f1f0:	01 d0                	add    %edx,%eax
f010f1f2:	89 c1                	mov    %eax,%ecx
f010f1f4:	c1 e1 0b             	shl    $0xb,%ecx
f010f1f7:	01 c8                	add    %ecx,%eax
f010f1f9:	c1 e0 05             	shl    $0x5,%eax
f010f1fc:	01 d0                	add    %edx,%eax
f010f1fe:	c1 e0 02             	shl    $0x2,%eax
f010f201:	01 d0                	add    %edx,%eax
f010f203:	01 c0                	add    %eax,%eax
f010f205:	01 d0                	add    %edx,%eax
f010f207:	c1 e0 03             	shl    $0x3,%eax
f010f20a:	01 d0                	add    %edx,%eax
f010f20c:	f7 d8                	neg    %eax
f010f20e:	50                   	push   %eax
f010f20f:	68 e8 72 12 f0       	push   $0xf01272e8
f010f214:	6a 71                	push   $0x71
f010f216:	68 33 72 12 f0       	push   $0xf0127233
f010f21b:	e8 19 11 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010f220:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010f227:	76 3a                	jbe    f010f263 <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010f229:	83 ec 04             	sub    $0x4,%esp
f010f22c:	68 1c 73 12 f0       	push   $0xf012731c
f010f231:	6a 74                	push   $0x74
f010f233:	68 33 72 12 f0       	push   $0xf0127233
f010f238:	e8 fc 10 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010f23d:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010f244:	76 1d                	jbe    f010f263 <fault_handler+0x1bb>
f010f246:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010f24d:	77 14                	ja     f010f263 <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010f24f:	83 ec 04             	sub    $0x4,%esp
f010f252:	68 40 73 12 f0       	push   $0xf0127340
f010f257:	6a 7c                	push   $0x7c
f010f259:	68 33 72 12 f0       	push   $0xf0127233
f010f25e:	e8 d6 10 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010f263:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f266:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010f269:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010f26d:	75 25                	jne    f010f294 <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010f26f:	83 ec 0c             	sub    $0xc,%esp
f010f272:	ff 75 08             	pushl  0x8(%ebp)
f010f275:	e8 c4 e7 ff ff       	call   f010da3e <print_trapframe>
f010f27a:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010f27d:	83 ec 04             	sub    $0x4,%esp
f010f280:	68 61 73 12 f0       	push   $0xf0127361
f010f285:	68 85 00 00 00       	push   $0x85
f010f28a:	68 33 72 12 f0       	push   $0xf0127233
f010f28f:	e8 a5 10 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010f294:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f297:	8b 40 64             	mov    0x64(%eax),%eax
f010f29a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f29d:	c1 ea 16             	shr    $0x16,%edx
f010f2a0:	c1 e2 02             	shl    $0x2,%edx
f010f2a3:	01 d0                	add    %edx,%eax
f010f2a5:	8b 00                	mov    (%eax),%eax
f010f2a7:	83 e0 01             	and    $0x1,%eax
f010f2aa:	85 c0                	test   %eax,%eax
f010f2ac:	75 2b                	jne    f010f2d9 <fault_handler+0x231>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010f2ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2b1:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f010f2b7:	8d 50 01             	lea    0x1(%eax),%edx
f010f2ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2bd:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		table_fault_handler(faulted_env, fault_va);
f010f2c3:	83 ec 08             	sub    $0x8,%esp
f010f2c6:	ff 75 ec             	pushl  -0x14(%ebp)
f010f2c9:	ff 75 e0             	pushl  -0x20(%ebp)
f010f2cc:	e8 1e 01 00 00       	call   f010f3ef <table_fault_handler>
f010f2d1:	83 c4 10             	add    $0x10,%esp
f010f2d4:	e9 07 01 00 00       	jmp    f010f3e0 <fault_handler+0x338>
	}
	else
	{
		if (userTrap)
f010f2d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f2dd:	0f 84 82 00 00 00    	je     f010f365 <fault_handler+0x2bd>
		{
			//============================================================================================
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			if (fault_va >= USER_LIMIT)
f010f2e3:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f010f2ea:	76 07                	jbe    f010f2f3 <fault_handler+0x24b>
			{
				env_exit();
f010f2ec:	e8 55 c0 ff ff       	call   f010b346 <env_exit>
f010f2f1:	eb 72                	jmp    f010f365 <fault_handler+0x2bd>
			}
			else if(((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_MARKED) != PERM_MARKED) && (fault_va>=USER_HEAP_START && fault_va<=USER_HEAP_MAX))
f010f2f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f2f6:	8b 40 64             	mov    0x64(%eax),%eax
f010f2f9:	83 ec 08             	sub    $0x8,%esp
f010f2fc:	ff 75 ec             	pushl  -0x14(%ebp)
f010f2ff:	50                   	push   %eax
f010f300:	e8 87 a3 ff ff       	call   f010968c <pt_get_page_permissions>
f010f305:	83 c4 10             	add    $0x10,%esp
f010f308:	25 00 02 00 00       	and    $0x200,%eax
f010f30d:	85 c0                	test   %eax,%eax
f010f30f:	75 17                	jne    f010f328 <fault_handler+0x280>
f010f311:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f314:	85 c0                	test   %eax,%eax
f010f316:	79 10                	jns    f010f328 <fault_handler+0x280>
f010f318:	81 7d ec 00 00 00 a0 	cmpl   $0xa0000000,-0x14(%ebp)
f010f31f:	77 07                	ja     f010f328 <fault_handler+0x280>
			{
				env_exit();
f010f321:	e8 20 c0 ff ff       	call   f010b346 <env_exit>
f010f326:	eb 3d                	jmp    f010f365 <fault_handler+0x2bd>
			}
			else if ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_PRESENT) && ((pt_get_page_permissions(faulted_env->env_page_directory,fault_va) & PERM_WRITEABLE)))
f010f328:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f32b:	8b 40 64             	mov    0x64(%eax),%eax
f010f32e:	83 ec 08             	sub    $0x8,%esp
f010f331:	ff 75 ec             	pushl  -0x14(%ebp)
f010f334:	50                   	push   %eax
f010f335:	e8 52 a3 ff ff       	call   f010968c <pt_get_page_permissions>
f010f33a:	83 c4 10             	add    $0x10,%esp
f010f33d:	83 e0 01             	and    $0x1,%eax
f010f340:	85 c0                	test   %eax,%eax
f010f342:	74 21                	je     f010f365 <fault_handler+0x2bd>
f010f344:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f347:	8b 40 64             	mov    0x64(%eax),%eax
f010f34a:	83 ec 08             	sub    $0x8,%esp
f010f34d:	ff 75 ec             	pushl  -0x14(%ebp)
f010f350:	50                   	push   %eax
f010f351:	e8 36 a3 ff ff       	call   f010968c <pt_get_page_permissions>
f010f356:	83 c4 10             	add    $0x10,%esp
f010f359:	83 e0 02             	and    $0x2,%eax
f010f35c:	85 c0                	test   %eax,%eax
f010f35e:	74 05                	je     f010f365 <fault_handler+0x2bd>
			{
				env_exit();
f010f360:	e8 e1 bf ff ff       	call   f010b346 <env_exit>
			}
			//============================================================================================
		}

		//2022: Check if fault due to Access Rights
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010f365:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f368:	8b 40 64             	mov    0x64(%eax),%eax
f010f36b:	83 ec 08             	sub    $0x8,%esp
f010f36e:	ff 75 ec             	pushl  -0x14(%ebp)
f010f371:	50                   	push   %eax
f010f372:	e8 15 a3 ff ff       	call   f010968c <pt_get_page_permissions>
f010f377:	83 c4 10             	add    $0x10,%esp
f010f37a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010f37d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f380:	83 e0 01             	and    $0x1,%eax
f010f383:	85 c0                	test   %eax,%eax
f010f385:	74 17                	je     f010f39e <fault_handler+0x2f6>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010f387:	ff 75 ec             	pushl  -0x14(%ebp)
f010f38a:	68 78 73 12 f0       	push   $0xf0127378
f010f38f:	68 ad 00 00 00       	push   $0xad
f010f394:	68 33 72 12 f0       	push   $0xf0127233
f010f399:	e8 9b 0f ff ff       	call   f0100339 <_panic>
		//============================================================================================


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010f39e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3a1:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f010f3a7:	8d 50 01             	lea    0x1(%eax),%edx
f010f3aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f3ad:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010f3b3:	e8 ce fc ff ff       	call   f010f086 <isBufferingEnabled>
f010f3b8:	84 c0                	test   %al,%al
f010f3ba:	74 13                	je     f010f3cf <fault_handler+0x327>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010f3bc:	83 ec 08             	sub    $0x8,%esp
f010f3bf:	ff 75 ec             	pushl  -0x14(%ebp)
f010f3c2:	ff 75 e0             	pushl  -0x20(%ebp)
f010f3c5:	e8 fe 01 00 00       	call   f010f5c8 <__page_fault_handler_with_buffering>
f010f3ca:	83 c4 10             	add    $0x10,%esp
f010f3cd:	eb 11                	jmp    f010f3e0 <fault_handler+0x338>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010f3cf:	83 ec 08             	sub    $0x8,%esp
f010f3d2:	ff 75 ec             	pushl  -0x14(%ebp)
f010f3d5:	ff 75 e0             	pushl  -0x20(%ebp)
f010f3d8:	e8 33 00 00 00       	call   f010f410 <page_fault_handler>
f010f3dd:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010f3e0:	0f 20 d8             	mov    %cr3,%eax
f010f3e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010f3e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f3e9:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010f3ec:	90                   	nop
f010f3ed:	c9                   	leave  
f010f3ee:	c3                   	ret    

f010f3ef <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010f3ef:	55                   	push   %ebp
f010f3f0:	89 e5                	mov    %esp,%ebp
f010f3f2:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010f3f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3f8:	8b 40 64             	mov    0x64(%eax),%eax
f010f3fb:	83 ec 08             	sub    $0x8,%esp
f010f3fe:	ff 75 0c             	pushl  0xc(%ebp)
f010f401:	50                   	push   %eax
f010f402:	e8 3e 91 ff ff       	call   f0108545 <create_page_table>
f010f407:	83 c4 10             	add    $0x10,%esp
f010f40a:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010f40d:	90                   	nop
f010f40e:	c9                   	leave  
f010f40f:	c3                   	ret    

f010f410 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010f410:	55                   	push   %ebp
f010f411:	89 e5                	mov    %esp,%ebp
f010f413:	83 ec 28             	sub    $0x28,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010f416:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010f41d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f420:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010f426:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010f429:	8b 45 08             	mov    0x8(%ebp),%eax
f010f42c:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010f432:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f435:	0f 86 74 01 00 00    	jbe    f010f5af <page_fault_handler+0x19f>
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
		//refer to the project presentation and documentation for details
		int ret = pf_read_env_page(faulted_env,(void*)fault_va);
f010f43b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f43e:	83 ec 08             	sub    $0x8,%esp
f010f441:	50                   	push   %eax
f010f442:	ff 75 08             	pushl  0x8(%ebp)
f010f445:	e8 97 50 ff ff       	call   f01044e1 <pf_read_env_page>
f010f44a:	83 c4 10             	add    $0x10,%esp
f010f44d:	89 45 ec             	mov    %eax,-0x14(%ebp)

		if (ret == E_PAGE_NOT_EXIST_IN_PF)
f010f450:	83 7d ec f7          	cmpl   $0xfffffff7,-0x14(%ebp)
f010f454:	75 45                	jne    f010f49b <page_fault_handler+0x8b>
		{
			if (!( (USER_HEAP_START <= fault_va && fault_va < USER_HEAP_MAX) || (USTACKBOTTOM <= fault_va && fault_va < USTACKTOP) ) )
f010f456:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f459:	85 c0                	test   %eax,%eax
f010f45b:	79 09                	jns    f010f466 <page_fault_handler+0x56>
f010f45d:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010f464:	76 35                	jbe    f010f49b <page_fault_handler+0x8b>
f010f466:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
f010f46d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f470:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010f475:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010f478:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f47b:	ba 00 00 00 00       	mov    $0x0,%edx
f010f480:	f7 75 e8             	divl   -0x18(%ebp)
f010f483:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f486:	29 d0                	sub    %edx,%eax
f010f488:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010f48b:	77 09                	ja     f010f496 <page_fault_handler+0x86>
f010f48d:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010f494:	76 05                	jbe    f010f49b <page_fault_handler+0x8b>
			{
				env_exit();
f010f496:	e8 ab be ff ff       	call   f010b346 <env_exit>
			}
		}

		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
f010f49b:	83 ec 0c             	sub    $0xc,%esp
f010f49e:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f4a1:	50                   	push   %eax
f010f4a2:	e8 0b 8d ff ff       	call   f01081b2 <allocate_frame>
f010f4a7:	83 c4 10             	add    $0x10,%esp
f010f4aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if(retk != E_NO_MEM)
f010f4ad:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f010f4b1:	74 34                	je     f010f4e7 <page_fault_handler+0xd7>
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
f010f4b3:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010f4b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4b9:	8b 40 64             	mov    0x64(%eax),%eax
f010f4bc:	6a 06                	push   $0x6
f010f4be:	ff 75 0c             	pushl  0xc(%ebp)
f010f4c1:	52                   	push   %edx
f010f4c2:	50                   	push   %eax
f010f4c3:	e8 b7 91 ff ff       	call   f010867f <map_frame>
f010f4c8:	83 c4 10             	add    $0x10,%esp
		} else panic("Placement: no memory");
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
f010f4cb:	83 ec 08             	sub    $0x8,%esp
f010f4ce:	ff 75 0c             	pushl  0xc(%ebp)
f010f4d1:	ff 75 08             	pushl  0x8(%ebp)
f010f4d4:	e8 25 a3 ff ff       	call   f01097fe <env_page_ws_list_create_element>
f010f4d9:	83 c4 10             	add    $0x10,%esp
f010f4dc:	89 45 dc             	mov    %eax,-0x24(%ebp)
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010f4df:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f010f4e3:	75 30                	jne    f010f515 <page_fault_handler+0x105>
f010f4e5:	eb 17                	jmp    f010f4fe <page_fault_handler+0xee>
		struct FrameInfo * ptr_frame;
		int retk = allocate_frame(&ptr_frame);
		if(retk != E_NO_MEM)
		{
			map_frame(faulted_env->env_page_directory,ptr_frame,fault_va, PERM_USER | PERM_WRITEABLE);
		} else panic("Placement: no memory");
f010f4e7:	83 ec 04             	sub    $0x4,%esp
f010f4ea:	68 bc 73 12 f0       	push   $0xf01273bc
f010f4ef:	68 03 01 00 00       	push   $0x103
f010f4f4:	68 33 72 12 f0       	push   $0xf0127233
f010f4f9:	e8 3b 0e ff ff       	call   f0100339 <_panic>
		struct WorkingSetElement* wse = env_page_ws_list_create_element(faulted_env, fault_va);
		LIST_INSERT_TAIL(&(faulted_env->page_WS_list), wse);
f010f4fe:	83 ec 04             	sub    $0x4,%esp
f010f501:	68 d4 73 12 f0       	push   $0xf01273d4
f010f506:	68 05 01 00 00       	push   $0x105
f010f50b:	68 33 72 12 f0       	push   $0xf0127233
f010f510:	e8 24 0e ff ff       	call   f0100339 <_panic>
f010f515:	8b 45 08             	mov    0x8(%ebp),%eax
f010f518:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010f51e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f521:	89 50 14             	mov    %edx,0x14(%eax)
f010f524:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f527:	8b 40 14             	mov    0x14(%eax),%eax
f010f52a:	85 c0                	test   %eax,%eax
f010f52c:	74 11                	je     f010f53f <page_fault_handler+0x12f>
f010f52e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f531:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010f537:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f53a:	89 50 10             	mov    %edx,0x10(%eax)
f010f53d:	eb 0c                	jmp    f010f54b <page_fault_handler+0x13b>
f010f53f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f542:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f545:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010f54b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f54e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010f551:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010f557:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f55a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010f561:	8b 45 08             	mov    0x8(%ebp),%eax
f010f564:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010f56a:	8d 50 01             	lea    0x1(%eax),%edx
f010f56d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f570:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		if (LIST_SIZE(&(faulted_env->page_WS_list)) == faulted_env->page_WS_max_size)
f010f576:	8b 45 08             	mov    0x8(%ebp),%eax
f010f579:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010f57f:	8b 45 08             	mov    0x8(%ebp),%eax
f010f582:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010f588:	39 c2                	cmp    %eax,%edx
f010f58a:	75 14                	jne    f010f5a0 <page_fault_handler+0x190>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
f010f58c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f58f:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010f595:	8b 45 08             	mov    0x8(%ebp),%eax
f010f598:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010f59e:	eb 26                	jmp    f010f5c6 <page_fault_handler+0x1b6>
		{
			faulted_env->page_last_WS_element = LIST_FIRST(&(faulted_env->page_WS_list));
		}
		else
		{
			faulted_env->page_last_WS_element = NULL;
f010f5a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5a3:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010f5aa:	00 00 00 
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}
f010f5ad:	eb 17                	jmp    f010f5c6 <page_fault_handler+0x1b6>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010f5af:	83 ec 04             	sub    $0x4,%esp
f010f5b2:	68 f8 73 12 f0       	push   $0xf01273f8
f010f5b7:	68 15 01 00 00       	push   $0x115
f010f5bc:	68 33 72 12 f0       	push   $0xf0127233
f010f5c1:	e8 73 0d ff ff       	call   f0100339 <_panic>
	}
}
f010f5c6:	c9                   	leave  
f010f5c7:	c3                   	ret    

f010f5c8 <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010f5c8:	55                   	push   %ebp
f010f5c9:	89 e5                	mov    %esp,%ebp
f010f5cb:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010f5ce:	83 ec 04             	sub    $0x4,%esp
f010f5d1:	68 38 74 12 f0       	push   $0xf0127438
f010f5d6:	68 1d 01 00 00       	push   $0x11d
f010f5db:	68 33 72 12 f0       	push   $0xf0127233
f010f5e0:	e8 54 0d ff ff       	call   f0100339 <_panic>

f010f5e5 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010f5e5:	55                   	push   %ebp
f010f5e6:	89 e5                	mov    %esp,%ebp
f010f5e8:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010f5eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5ee:	83 c0 04             	add    $0x4,%eax
f010f5f1:	83 ec 08             	sub    $0x8,%esp
f010f5f4:	ff 75 0c             	pushl  0xc(%ebp)
f010f5f7:	50                   	push   %eax
f010f5f8:	e8 16 00 01 00       	call   f011f613 <strcpy>
f010f5fd:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010f600:	8b 45 08             	mov    0x8(%ebp),%eax
f010f603:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010f609:	8b 45 08             	mov    0x8(%ebp),%eax
f010f60c:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010f613:	90                   	nop
f010f614:	c9                   	leave  
f010f615:	c3                   	ret    

f010f616 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010f616:	55                   	push   %ebp
f010f617:	89 e5                	mov    %esp,%ebp
f010f619:	53                   	push   %ebx
f010f61a:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010f61d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f620:	83 ec 0c             	sub    $0xc,%esp
f010f623:	50                   	push   %eax
f010f624:	e8 06 02 00 00       	call   f010f82f <holding_spinlock>
f010f629:	83 c4 10             	add    $0x10,%esp
f010f62c:	85 c0                	test   %eax,%eax
f010f62e:	74 18                	je     f010f648 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010f630:	8b 45 08             	mov    0x8(%ebp),%eax
f010f633:	83 c0 04             	add    $0x4,%eax
f010f636:	50                   	push   %eax
f010f637:	68 7c 74 12 f0       	push   $0xf012747c
f010f63c:	6a 1f                	push   $0x1f
f010f63e:	68 b9 74 12 f0       	push   $0xf01274b9
f010f643:	e8 f1 0c ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010f648:	e8 82 7b ff ff       	call   f01071cf <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010f64d:	90                   	nop
f010f64e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f651:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010f654:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010f65b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f65e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f661:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010f664:	f0 87 02             	lock xchg %eax,(%edx)
f010f667:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010f66a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f66d:	85 c0                	test   %eax,%eax
f010f66f:	75 dd                	jne    f010f64e <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010f671:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010f676:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010f679:	e8 8e 7a ff ff       	call   f010710c <mycpu>
f010f67e:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010f681:	8b 45 08             	mov    0x8(%ebp),%eax
f010f684:	83 c0 48             	add    $0x48,%eax
f010f687:	83 ec 08             	sub    $0x8,%esp
f010f68a:	50                   	push   %eax
f010f68b:	8d 45 08             	lea    0x8(%ebp),%eax
f010f68e:	50                   	push   %eax
f010f68f:	e8 74 00 00 00       	call   f010f708 <getcallerpcs>
f010f694:	83 c4 10             	add    $0x10,%esp

}
f010f697:	90                   	nop
f010f698:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010f69b:	c9                   	leave  
f010f69c:	c3                   	ret    

f010f69d <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010f69d:	55                   	push   %ebp
f010f69e:	89 e5                	mov    %esp,%ebp
f010f6a0:	83 ec 08             	sub    $0x8,%esp
//	cprintf("Proccess: %d", get_cpu_proc());
	if(!holding_spinlock(lk))
f010f6a3:	83 ec 0c             	sub    $0xc,%esp
f010f6a6:	ff 75 08             	pushl  0x8(%ebp)
f010f6a9:	e8 81 01 00 00       	call   f010f82f <holding_spinlock>
f010f6ae:	83 c4 10             	add    $0x10,%esp
f010f6b1:	85 c0                	test   %eax,%eax
f010f6b3:	75 26                	jne    f010f6db <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010f6b5:	83 ec 0c             	sub    $0xc,%esp
f010f6b8:	ff 75 08             	pushl  0x8(%ebp)
f010f6bb:	e8 08 01 00 00       	call   f010f7c8 <printcallstack>
f010f6c0:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010f6c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6c6:	83 c0 04             	add    $0x4,%eax
f010f6c9:	50                   	push   %eax
f010f6ca:	68 d0 74 12 f0       	push   $0xf01274d0
f010f6cf:	6a 3c                	push   $0x3c
f010f6d1:	68 b9 74 12 f0       	push   $0xf01274b9
f010f6d6:	e8 5e 0c ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010f6db:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6de:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010f6e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6e8:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010f6ef:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010f6f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f6f7:	8b 55 08             	mov    0x8(%ebp),%edx
f010f6fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010f700:	e8 1c 7b ff ff       	call   f0107221 <popcli>
}
f010f705:	90                   	nop
f010f706:	c9                   	leave  
f010f707:	c3                   	ret    

f010f708 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010f708:	55                   	push   %ebp
f010f709:	89 e5                	mov    %esp,%ebp
f010f70b:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010f70e:	e8 75 bc ff ff       	call   f010b388 <get_cpu_proc>
f010f713:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010f716:	e8 f1 79 ff ff       	call   f010710c <mycpu>
f010f71b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010f71e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f721:	83 e8 08             	sub    $0x8,%eax
f010f724:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010f727:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010f72e:	eb 67                	jmp    f010f797 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010f730:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f734:	74 67                	je     f010f79d <getcallerpcs+0x95>
f010f736:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010f73d:	76 5e                	jbe    f010f79d <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010f73f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f742:	8b 40 08             	mov    0x8(%eax),%eax
f010f745:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010f74a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f74d:	77 10                	ja     f010f75f <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010f74f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f752:	8b 40 08             	mov    0x8(%eax),%eax
f010f755:	05 00 90 00 00       	add    $0x9000,%eax
f010f75a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f75d:	77 3e                	ja     f010f79d <getcallerpcs+0x95>
f010f75f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f763:	74 10                	je     f010f775 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010f765:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f768:	8b 40 70             	mov    0x70(%eax),%eax
f010f76b:	05 00 80 00 00       	add    $0x8000,%eax
f010f770:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f773:	76 28                	jbe    f010f79d <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010f775:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f778:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f77f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f782:	01 c2                	add    %eax,%edx
f010f784:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f787:	8b 40 04             	mov    0x4(%eax),%eax
f010f78a:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010f78c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f78f:	8b 00                	mov    (%eax),%eax
f010f791:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010f794:	ff 45 f0             	incl   -0x10(%ebp)
f010f797:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010f79b:	7e 93                	jle    f010f730 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010f79d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f7a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010f7a3:	eb 18                	jmp    f010f7bd <getcallerpcs+0xb5>
		pcs[i] = 0;
f010f7a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f7a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f7af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7b2:	01 d0                	add    %edx,%eax
f010f7b4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010f7ba:	ff 45 f0             	incl   -0x10(%ebp)
f010f7bd:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010f7c1:	7e e2                	jle    f010f7a5 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010f7c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010f7c6:	c9                   	leave  
f010f7c7:	c3                   	ret    

f010f7c8 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010f7c8:	55                   	push   %ebp
f010f7c9:	89 e5                	mov    %esp,%ebp
f010f7cb:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010f7ce:	83 ec 0c             	sub    $0xc,%esp
f010f7d1:	68 0e 75 12 f0       	push   $0xf012750e
f010f7d6:	e8 b0 17 ff ff       	call   f0100f8b <cprintf>
f010f7db:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010f7de:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7e1:	83 c0 48             	add    $0x48,%eax
f010f7e4:	83 ec 08             	sub    $0x8,%esp
f010f7e7:	50                   	push   %eax
f010f7e8:	8d 45 08             	lea    0x8(%ebp),%eax
f010f7eb:	50                   	push   %eax
f010f7ec:	e8 17 ff ff ff       	call   f010f708 <getcallerpcs>
f010f7f1:	83 c4 10             	add    $0x10,%esp
f010f7f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010f7f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010f7fe:	eb 24                	jmp    f010f824 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010f800:	8b 45 08             	mov    0x8(%ebp),%eax
f010f803:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f806:	83 c2 10             	add    $0x10,%edx
f010f809:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010f80d:	83 ec 04             	sub    $0x4,%esp
f010f810:	50                   	push   %eax
f010f811:	ff 75 f4             	pushl  -0xc(%ebp)
f010f814:	68 1e 75 12 f0       	push   $0xf012751e
f010f819:	e8 6d 17 ff ff       	call   f0100f8b <cprintf>
f010f81e:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010f821:	ff 45 f4             	incl   -0xc(%ebp)
f010f824:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f827:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010f82a:	7c d4                	jl     f010f800 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010f82c:	90                   	nop
f010f82d:	c9                   	leave  
f010f82e:	c3                   	ret    

f010f82f <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010f82f:	55                   	push   %ebp
f010f830:	89 e5                	mov    %esp,%ebp
f010f832:	53                   	push   %ebx
f010f833:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010f836:	e8 94 79 ff ff       	call   f01071cf <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010f83b:	8b 45 08             	mov    0x8(%ebp),%eax
f010f83e:	8b 00                	mov    (%eax),%eax
f010f840:	85 c0                	test   %eax,%eax
f010f842:	74 16                	je     f010f85a <holding_spinlock+0x2b>
f010f844:	8b 45 08             	mov    0x8(%ebp),%eax
f010f847:	8b 58 44             	mov    0x44(%eax),%ebx
f010f84a:	e8 bd 78 ff ff       	call   f010710c <mycpu>
f010f84f:	39 c3                	cmp    %eax,%ebx
f010f851:	75 07                	jne    f010f85a <holding_spinlock+0x2b>
f010f853:	b8 01 00 00 00       	mov    $0x1,%eax
f010f858:	eb 05                	jmp    f010f85f <holding_spinlock+0x30>
f010f85a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f85f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010f862:	e8 ba 79 ff ff       	call   f0107221 <popcli>
	return r;
f010f867:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010f86a:	83 c4 14             	add    $0x14,%esp
f010f86d:	5b                   	pop    %ebx
f010f86e:	5d                   	pop    %ebp
f010f86f:	c3                   	ret    

f010f870 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010f870:	55                   	push   %ebp
f010f871:	89 e5                	mov    %esp,%ebp
f010f873:	83 ec 08             	sub    $0x8,%esp

	init_channel(&(lk->chan), "sleep lock channel");
f010f876:	8b 45 08             	mov    0x8(%ebp),%eax
f010f879:	83 c0 74             	add    $0x74,%eax
f010f87c:	83 ec 08             	sub    $0x8,%esp
f010f87f:	68 2d 75 12 f0       	push   $0xf012752d
f010f884:	50                   	push   %eax
f010f885:	e8 4c 01 00 00       	call   f010f9d6 <init_channel>
f010f88a:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010f88d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f890:	83 c0 04             	add    $0x4,%eax
f010f893:	83 ec 08             	sub    $0x8,%esp
f010f896:	68 40 75 12 f0       	push   $0xf0127540
f010f89b:	50                   	push   %eax
f010f89c:	e8 44 fd ff ff       	call   f010f5e5 <init_spinlock>
f010f8a1:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010f8a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8a7:	05 c4 00 00 00       	add    $0xc4,%eax
f010f8ac:	83 ec 08             	sub    $0x8,%esp
f010f8af:	ff 75 0c             	pushl  0xc(%ebp)
f010f8b2:	50                   	push   %eax
f010f8b3:	e8 5b fd 00 00       	call   f011f613 <strcpy>
f010f8b8:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010f8bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010f8c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8c7:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010f8ce:	00 00 00 
}
f010f8d1:	90                   	nop
f010f8d2:	c9                   	leave  
f010f8d3:	c3                   	ret    

f010f8d4 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk) // is the sleeplock holded by this process or not
{
f010f8d4:	55                   	push   %ebp
f010f8d5:	89 e5                	mov    %esp,%ebp
f010f8d7:	53                   	push   %ebx
f010f8d8:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010f8db:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8de:	83 c0 04             	add    $0x4,%eax
f010f8e1:	83 ec 0c             	sub    $0xc,%esp
f010f8e4:	50                   	push   %eax
f010f8e5:	e8 2c fd ff ff       	call   f010f616 <acquire_spinlock>
f010f8ea:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010f8ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8f0:	8b 00                	mov    (%eax),%eax
f010f8f2:	85 c0                	test   %eax,%eax
f010f8f4:	74 1c                	je     f010f912 <holding_sleeplock+0x3e>
f010f8f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8f9:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010f8ff:	e8 84 ba ff ff       	call   f010b388 <get_cpu_proc>
f010f904:	8b 40 10             	mov    0x10(%eax),%eax
f010f907:	39 c3                	cmp    %eax,%ebx
f010f909:	75 07                	jne    f010f912 <holding_sleeplock+0x3e>
f010f90b:	b8 01 00 00 00       	mov    $0x1,%eax
f010f910:	eb 05                	jmp    f010f917 <holding_sleeplock+0x43>
f010f912:	b8 00 00 00 00       	mov    $0x0,%eax
f010f917:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010f91a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f91d:	83 c0 04             	add    $0x4,%eax
f010f920:	83 ec 0c             	sub    $0xc,%esp
f010f923:	50                   	push   %eax
f010f924:	e8 74 fd ff ff       	call   f010f69d <release_spinlock>
f010f929:	83 c4 10             	add    $0x10,%esp
	return r;
f010f92c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010f92f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010f932:	c9                   	leave  
f010f933:	c3                   	ret    

f010f934 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010f934:	55                   	push   %ebp
f010f935:	89 e5                	mov    %esp,%ebp
f010f937:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010f93a:	8b 45 08             	mov    0x8(%ebp),%eax
f010f93d:	83 c0 04             	add    $0x4,%eax
f010f940:	83 ec 0c             	sub    $0xc,%esp
f010f943:	50                   	push   %eax
f010f944:	e8 cd fc ff ff       	call   f010f616 <acquire_spinlock>
f010f949:	83 c4 10             	add    $0x10,%esp
	    while (lk->locked) {
f010f94c:	eb 19                	jmp    f010f967 <acquire_sleeplock+0x33>
	        sleep(&lk->chan, &(lk->lk));
f010f94e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f951:	8d 50 04             	lea    0x4(%eax),%edx
f010f954:	8b 45 08             	mov    0x8(%ebp),%eax
f010f957:	83 c0 74             	add    $0x74,%eax
f010f95a:	83 ec 08             	sub    $0x8,%esp
f010f95d:	52                   	push   %edx
f010f95e:	50                   	push   %eax
f010f95f:	e8 9f 00 00 00       	call   f010fa03 <sleep>
f010f964:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
	    while (lk->locked) {
f010f967:	8b 45 08             	mov    0x8(%ebp),%eax
f010f96a:	8b 00                	mov    (%eax),%eax
f010f96c:	85 c0                	test   %eax,%eax
f010f96e:	75 de                	jne    f010f94e <acquire_sleeplock+0x1a>
	        sleep(&lk->chan, &(lk->lk));
	    }

	    lk->locked = 1;
f010f970:	8b 45 08             	mov    0x8(%ebp),%eax
f010f973:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	  release_spinlock(&(lk->lk));
f010f979:	8b 45 08             	mov    0x8(%ebp),%eax
f010f97c:	83 c0 04             	add    $0x4,%eax
f010f97f:	83 ec 0c             	sub    $0xc,%esp
f010f982:	50                   	push   %eax
f010f983:	e8 15 fd ff ff       	call   f010f69d <release_spinlock>
f010f988:	83 c4 10             	add    $0x10,%esp

}
f010f98b:	90                   	nop
f010f98c:	c9                   	leave  
f010f98d:	c3                   	ret    

f010f98e <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010f98e:	55                   	push   %ebp
f010f98f:	89 e5                	mov    %esp,%ebp
f010f991:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");

	 acquire_spinlock(&(lk->lk));
f010f994:	8b 45 08             	mov    0x8(%ebp),%eax
f010f997:	83 c0 04             	add    $0x4,%eax
f010f99a:	83 ec 0c             	sub    $0xc,%esp
f010f99d:	50                   	push   %eax
f010f99e:	e8 73 fc ff ff       	call   f010f616 <acquire_spinlock>
f010f9a3:	83 c4 10             	add    $0x10,%esp

	 wakeup_all(&(lk->chan));
f010f9a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9a9:	83 c0 74             	add    $0x74,%eax
f010f9ac:	83 ec 0c             	sub    $0xc,%esp
f010f9af:	50                   	push   %eax
f010f9b0:	e8 3f 01 00 00       	call   f010faf4 <wakeup_all>
f010f9b5:	83 c4 10             	add    $0x10,%esp

	 lk->locked = 0;
f010f9b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9bb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	 release_spinlock(&(lk->lk));
f010f9c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9c4:	83 c0 04             	add    $0x4,%eax
f010f9c7:	83 ec 0c             	sub    $0xc,%esp
f010f9ca:	50                   	push   %eax
f010f9cb:	e8 cd fc ff ff       	call   f010f69d <release_spinlock>
f010f9d0:	83 c4 10             	add    $0x10,%esp
}
f010f9d3:	90                   	nop
f010f9d4:	c9                   	leave  
f010f9d5:	c3                   	ret    

f010f9d6 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010f9d6:	55                   	push   %ebp
f010f9d7:	89 e5                	mov    %esp,%ebp
f010f9d9:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010f9dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9df:	83 c0 10             	add    $0x10,%eax
f010f9e2:	83 ec 08             	sub    $0x8,%esp
f010f9e5:	ff 75 0c             	pushl  0xc(%ebp)
f010f9e8:	50                   	push   %eax
f010f9e9:	e8 25 fc 00 00       	call   f011f613 <strcpy>
f010f9ee:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010f9f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9f4:	83 ec 0c             	sub    $0xc,%esp
f010f9f7:	50                   	push   %eax
f010f9f8:	e8 6c 55 ff ff       	call   f0104f69 <init_queue>
f010f9fd:	83 c4 10             	add    $0x10,%esp
}
f010fa00:	90                   	nop
f010fa01:	c9                   	leave  
f010fa02:	c3                   	ret    

f010fa03 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010fa03:	55                   	push   %ebp
f010fa04:	89 e5                	mov    %esp,%ebp
f010fa06:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(ProcessQueues.qlock));
f010fa09:	83 ec 0c             	sub    $0xc,%esp
f010fa0c:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fa11:	e8 00 fc ff ff       	call   f010f616 <acquire_spinlock>
f010fa16:	83 c4 10             	add    $0x10,%esp
	enqueue(&chan->queue,get_cpu_proc());
f010fa19:	e8 6a b9 ff ff       	call   f010b388 <get_cpu_proc>
f010fa1e:	89 c2                	mov    %eax,%edx
f010fa20:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa23:	83 ec 08             	sub    $0x8,%esp
f010fa26:	52                   	push   %edx
f010fa27:	50                   	push   %eax
f010fa28:	e8 7d 55 ff ff       	call   f0104faa <enqueue>
f010fa2d:	83 c4 10             	add    $0x10,%esp
	get_cpu_proc()->env_status = ENV_BLOCKED;
f010fa30:	e8 53 b9 ff ff       	call   f010b388 <get_cpu_proc>
f010fa35:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	release_spinlock(lk);
f010fa3c:	83 ec 0c             	sub    $0xc,%esp
f010fa3f:	ff 75 0c             	pushl  0xc(%ebp)
f010fa42:	e8 56 fc ff ff       	call   f010f69d <release_spinlock>
f010fa47:	83 c4 10             	add    $0x10,%esp
	sched();
f010fa4a:	e8 ba ba ff ff       	call   f010b509 <sched>
	release_spinlock(&(ProcessQueues.qlock));
f010fa4f:	83 ec 0c             	sub    $0xc,%esp
f010fa52:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fa57:	e8 41 fc ff ff       	call   f010f69d <release_spinlock>
f010fa5c:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f010fa5f:	83 ec 0c             	sub    $0xc,%esp
f010fa62:	ff 75 0c             	pushl  0xc(%ebp)
f010fa65:	e8 ac fb ff ff       	call   f010f616 <acquire_spinlock>
f010fa6a:	83 c4 10             	add    $0x10,%esp
}
f010fa6d:	90                   	nop
f010fa6e:	c9                   	leave  
f010fa6f:	c3                   	ret    

f010fa70 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010fa70:	55                   	push   %ebp
f010fa71:	89 e5                	mov    %esp,%ebp
f010fa73:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_one is not implemented yet");
	//Your Code is Here...

	if(queue_size(&chan->queue)){
f010fa76:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa79:	83 ec 0c             	sub    $0xc,%esp
f010fa7c:	50                   	push   %eax
f010fa7d:	e8 10 55 ff ff       	call   f0104f92 <queue_size>
f010fa82:	83 c4 10             	add    $0x10,%esp
f010fa85:	85 c0                	test   %eax,%eax
f010fa87:	74 68                	je     f010faf1 <wakeup_one+0x81>
		bool locked_by_me = 0;
f010fa89:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		if(!holding_spinlock(&ProcessQueues.qlock)){
f010fa90:	83 ec 0c             	sub    $0xc,%esp
f010fa93:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fa98:	e8 92 fd ff ff       	call   f010f82f <holding_spinlock>
f010fa9d:	83 c4 10             	add    $0x10,%esp
f010faa0:	85 c0                	test   %eax,%eax
f010faa2:	75 17                	jne    f010fabb <wakeup_one+0x4b>
			acquire_spinlock(&(ProcessQueues.qlock));
f010faa4:	83 ec 0c             	sub    $0xc,%esp
f010faa7:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010faac:	e8 65 fb ff ff       	call   f010f616 <acquire_spinlock>
f010fab1:	83 c4 10             	add    $0x10,%esp
			locked_by_me = 1;
f010fab4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		}
		struct Env* waked_up_process = dequeue(&chan->queue);
f010fabb:	8b 45 08             	mov    0x8(%ebp),%eax
f010fabe:	83 ec 0c             	sub    $0xc,%esp
f010fac1:	50                   	push   %eax
f010fac2:	e8 74 55 ff ff       	call   f010503b <dequeue>
f010fac7:	83 c4 10             	add    $0x10,%esp
f010faca:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(waked_up_process);
f010facd:	83 ec 0c             	sub    $0xc,%esp
f010fad0:	ff 75 f0             	pushl  -0x10(%ebp)
f010fad3:	e8 9e 57 ff ff       	call   f0105276 <sched_insert_ready0>
f010fad8:	83 c4 10             	add    $0x10,%esp
		if(locked_by_me) release_spinlock(&(ProcessQueues.qlock));
f010fadb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fadf:	74 10                	je     f010faf1 <wakeup_one+0x81>
f010fae1:	83 ec 0c             	sub    $0xc,%esp
f010fae4:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fae9:	e8 af fb ff ff       	call   f010f69d <release_spinlock>
f010faee:	83 c4 10             	add    $0x10,%esp
	}
}
f010faf1:	90                   	nop
f010faf2:	c9                   	leave  
f010faf3:	c3                   	ret    

f010faf4 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010faf4:	55                   	push   %ebp
f010faf5:	89 e5                	mov    %esp,%ebp
f010faf7:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
f010fafa:	83 ec 0c             	sub    $0xc,%esp
f010fafd:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fb02:	e8 0f fb ff ff       	call   f010f616 <acquire_spinlock>
f010fb07:	83 c4 10             	add    $0x10,%esp
	while(queue_size(&chan->queue)){
f010fb0a:	eb 0e                	jmp    f010fb1a <wakeup_all+0x26>
		wakeup_one(chan);
f010fb0c:	83 ec 0c             	sub    $0xc,%esp
f010fb0f:	ff 75 08             	pushl  0x8(%ebp)
f010fb12:	e8 59 ff ff ff       	call   f010fa70 <wakeup_one>
f010fb17:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("wakeup_all is not implemented yet");
	//Your Code is Here...
//	cprintf("81\n");
	acquire_spinlock(&(ProcessQueues.qlock));
	while(queue_size(&chan->queue)){
f010fb1a:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb1d:	83 ec 0c             	sub    $0xc,%esp
f010fb20:	50                   	push   %eax
f010fb21:	e8 6c 54 ff ff       	call   f0104f92 <queue_size>
f010fb26:	83 c4 10             	add    $0x10,%esp
f010fb29:	85 c0                	test   %eax,%eax
f010fb2b:	75 df                	jne    f010fb0c <wakeup_all+0x18>
		wakeup_one(chan);
	}
	release_spinlock(&(ProcessQueues.qlock));
f010fb2d:	83 ec 0c             	sub    $0xc,%esp
f010fb30:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fb35:	e8 63 fb ff ff       	call   f010f69d <release_spinlock>
f010fb3a:	83 c4 10             	add    $0x10,%esp
}
f010fb3d:	90                   	nop
f010fb3e:	c9                   	leave  
f010fb3f:	c3                   	ret    

f010fb40 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010fb40:	55                   	push   %ebp
f010fb41:	89 e5                	mov    %esp,%ebp
f010fb43:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010fb46:	83 ec 04             	sub    $0x4,%esp
f010fb49:	68 54 75 12 f0       	push   $0xf0127554
f010fb4e:	6a 13                	push   $0x13
f010fb50:	68 7b 75 12 f0       	push   $0xf012757b
f010fb55:	e8 df 07 ff ff       	call   f0100339 <_panic>

f010fb5a <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010fb5a:	55                   	push   %ebp
f010fb5b:	89 e5                	mov    %esp,%ebp
f010fb5d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010fb60:	83 ec 04             	sub    $0x4,%esp
f010fb63:	68 94 75 12 f0       	push   $0xf0127594
f010fb68:	6a 1b                	push   $0x1b
f010fb6a:	68 7b 75 12 f0       	push   $0xf012757b
f010fb6f:	e8 c5 07 ff ff       	call   f0100339 <_panic>

f010fb74 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010fb74:	55                   	push   %ebp
f010fb75:	89 e5                	mov    %esp,%ebp
f010fb77:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010fb7a:	83 ec 04             	sub    $0x4,%esp
f010fb7d:	68 bc 75 12 f0       	push   $0xf01275bc
f010fb82:	6a 24                	push   $0x24
f010fb84:	68 7b 75 12 f0       	push   $0xf012757b
f010fb89:	e8 ab 07 ff ff       	call   f0100339 <_panic>

f010fb8e <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010fb8e:	55                   	push   %ebp
f010fb8f:	89 e5                	mov    %esp,%ebp
f010fb91:	c7 05 58 d8 6b f0 01 	movl   $0x1,0xf06bd858
f010fb98:	00 00 00 
f010fb9b:	90                   	nop
f010fb9c:	5d                   	pop    %ebp
f010fb9d:	c3                   	ret    

f010fb9e <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010fb9e:	55                   	push   %ebp
f010fb9f:	89 e5                	mov    %esp,%ebp
f010fba1:	c7 05 58 d8 6b f0 02 	movl   $0x2,0xf06bd858
f010fba8:	00 00 00 
f010fbab:	90                   	nop
f010fbac:	5d                   	pop    %ebp
f010fbad:	c3                   	ret    

f010fbae <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010fbae:	55                   	push   %ebp
f010fbaf:	89 e5                	mov    %esp,%ebp
f010fbb1:	c7 05 58 d8 6b f0 03 	movl   $0x3,0xf06bd858
f010fbb8:	00 00 00 
f010fbbb:	90                   	nop
f010fbbc:	5d                   	pop    %ebp
f010fbbd:	c3                   	ret    

f010fbbe <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010fbbe:	55                   	push   %ebp
f010fbbf:	89 e5                	mov    %esp,%ebp
f010fbc1:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010fbc6:	83 f8 01             	cmp    $0x1,%eax
f010fbc9:	75 04                	jne    f010fbcf <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010fbcb:	b0 01                	mov    $0x1,%al
f010fbcd:	eb 02                	jmp    f010fbd1 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010fbcf:	b0 00                	mov    $0x0,%al
f010fbd1:	5d                   	pop    %ebp
f010fbd2:	c3                   	ret    

f010fbd3 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010fbd3:	55                   	push   %ebp
f010fbd4:	89 e5                	mov    %esp,%ebp
f010fbd6:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010fbdb:	83 f8 02             	cmp    $0x2,%eax
f010fbde:	75 04                	jne    f010fbe4 <isKHeapPlacementStrategyBESTFIT+0x11>
f010fbe0:	b0 01                	mov    $0x1,%al
f010fbe2:	eb 02                	jmp    f010fbe6 <isKHeapPlacementStrategyBESTFIT+0x13>
f010fbe4:	b0 00                	mov    $0x0,%al
f010fbe6:	5d                   	pop    %ebp
f010fbe7:	c3                   	ret    

f010fbe8 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010fbe8:	55                   	push   %ebp
f010fbe9:	89 e5                	mov    %esp,%ebp
f010fbeb:	a1 58 d8 6b f0       	mov    0xf06bd858,%eax
f010fbf0:	83 f8 03             	cmp    $0x3,%eax
f010fbf3:	75 04                	jne    f010fbf9 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010fbf5:	b0 01                	mov    $0x1,%al
f010fbf7:	eb 02                	jmp    f010fbfb <isKHeapPlacementStrategyNEXTFIT+0x13>
f010fbf9:	b0 00                	mov    $0x0,%al
f010fbfb:	5d                   	pop    %ebp
f010fbfc:	c3                   	ret    

f010fbfd <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010fbfd:	55                   	push   %ebp
f010fbfe:	89 e5                	mov    %esp,%ebp
f010fc00:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010fc03:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010fc0a:	eb 26                	jmp    f010fc32 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010fc0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc0f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fc16:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc19:	01 c2                	add    %eax,%edx
f010fc1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fc1e:	40                   	inc    %eax
f010fc1f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fc26:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc29:	01 c8                	add    %ecx,%eax
f010fc2b:	8b 00                	mov    (%eax),%eax
f010fc2d:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010fc2f:	ff 45 f4             	incl   -0xc(%ebp)
f010fc32:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc35:	48                   	dec    %eax
f010fc36:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fc39:	7f d1                	jg     f010fc0c <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010fc3b:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010fc3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010fc45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010fc4c:	eb 35                	jmp    f010fc83 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010fc4e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fc51:	89 d0                	mov    %edx,%eax
f010fc53:	01 c0                	add    %eax,%eax
f010fc55:	01 d0                	add    %edx,%eax
f010fc57:	c1 e0 02             	shl    $0x2,%eax
f010fc5a:	05 00 ed 17 f0       	add    $0xf017ed00,%eax
f010fc5f:	8b 10                	mov    (%eax),%edx
f010fc61:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc64:	8b 00                	mov    (%eax),%eax
f010fc66:	83 ec 08             	sub    $0x8,%esp
f010fc69:	52                   	push   %edx
f010fc6a:	50                   	push   %eax
f010fc6b:	e8 60 fa 00 00       	call   f011f6d0 <strcmp>
f010fc70:	83 c4 10             	add    $0x10,%esp
f010fc73:	85 c0                	test   %eax,%eax
f010fc75:	75 09                	jne    f010fc80 <tst_handler+0x83>
		{
			test_found = 1;
f010fc77:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010fc7e:	eb 0f                	jmp    f010fc8f <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010fc80:	ff 45 ec             	incl   -0x14(%ebp)
f010fc83:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fc86:	a1 b4 ed 17 f0       	mov    0xf017edb4,%eax
f010fc8b:	39 c2                	cmp    %eax,%edx
f010fc8d:	72 bf                	jb     f010fc4e <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010fc8f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fc93:	74 29                	je     f010fcbe <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010fc95:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fc98:	89 d0                	mov    %edx,%eax
f010fc9a:	01 c0                	add    %eax,%eax
f010fc9c:	01 d0                	add    %edx,%eax
f010fc9e:	c1 e0 02             	shl    $0x2,%eax
f010fca1:	05 08 ed 17 f0       	add    $0xf017ed08,%eax
f010fca6:	8b 00                	mov    (%eax),%eax
f010fca8:	83 ec 08             	sub    $0x8,%esp
f010fcab:	ff 75 0c             	pushl  0xc(%ebp)
f010fcae:	ff 75 08             	pushl  0x8(%ebp)
f010fcb1:	ff d0                	call   *%eax
f010fcb3:	83 c4 10             	add    $0x10,%esp
f010fcb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010fcb9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fcbc:	eb 1b                	jmp    f010fcd9 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010fcbe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fcc1:	8b 00                	mov    (%eax),%eax
f010fcc3:	83 ec 08             	sub    $0x8,%esp
f010fcc6:	50                   	push   %eax
f010fcc7:	68 fc 78 12 f0       	push   $0xf01278fc
f010fccc:	e8 ba 12 ff ff       	call   f0100f8b <cprintf>
f010fcd1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fcd4:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010fcd9:	c9                   	leave  
f010fcda:	c3                   	ret    

f010fcdb <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010fcdb:	55                   	push   %ebp
f010fcdc:	89 e5                	mov    %esp,%ebp
f010fcde:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010fce1:	e8 69 d0 00 00       	call   f011cd4f <test_three_creation_functions>
	return 0;
f010fce6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fceb:	c9                   	leave  
f010fcec:	c3                   	ret    

f010fced <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010fced:	55                   	push   %ebp
f010fcee:	89 e5                	mov    %esp,%ebp
f010fcf0:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010fcf3:	e8 03 69 00 00       	call   f01165fb <test_priority_normal_and_higher>
	return 0;
f010fcf8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fcfd:	c9                   	leave  
f010fcfe:	c3                   	ret    

f010fcff <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010fcff:	55                   	push   %ebp
f010fd00:	89 e5                	mov    %esp,%ebp
f010fd02:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010fd05:	e8 0b 69 00 00       	call   f0116615 <test_priority_normal_and_lower>
	return 0;
f010fd0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd0f:	c9                   	leave  
f010fd10:	c3                   	ret    

f010fd11 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010fd11:	55                   	push   %ebp
f010fd12:	89 e5                	mov    %esp,%ebp
f010fd14:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010fd17:	e8 e6 d1 00 00       	call   f011cf02 <test_kfreeall>
	return 0;
f010fd1c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd21:	c9                   	leave  
f010fd22:	c3                   	ret    

f010fd23 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010fd23:	55                   	push   %ebp
f010fd24:	89 e5                	mov    %esp,%ebp
f010fd26:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010fd29:	e8 f1 d1 00 00       	call   f011cf1f <test_kexpand>
	return 0;
f010fd2e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd33:	c9                   	leave  
f010fd34:	c3                   	ret    

f010fd35 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010fd35:	55                   	push   %ebp
f010fd36:	89 e5                	mov    %esp,%ebp
f010fd38:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010fd3b:	e8 fc d1 00 00       	call   f011cf3c <test_kshrink>
	return 0;
f010fd40:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd45:	c9                   	leave  
f010fd46:	c3                   	ret    

f010fd47 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010fd47:	55                   	push   %ebp
f010fd48:	89 e5                	mov    %esp,%ebp
f010fd4a:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010fd4d:	e8 07 d2 00 00       	call   f011cf59 <test_kfreelast>
	return 0;
f010fd52:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd57:	c9                   	leave  
f010fd58:	c3                   	ret    

f010fd59 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010fd59:	55                   	push   %ebp
f010fd5a:	89 e5                	mov    %esp,%ebp
f010fd5c:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010fd5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fd62:	83 c0 04             	add    $0x4,%eax
f010fd65:	8b 00                	mov    (%eax),%eax
f010fd67:	83 ec 04             	sub    $0x4,%esp
f010fd6a:	6a 0a                	push   $0xa
f010fd6c:	6a 00                	push   $0x0
f010fd6e:	50                   	push   %eax
f010fd6f:	e8 b0 fb 00 00       	call   f011f924 <strtol>
f010fd74:	83 c4 10             	add    $0x10,%esp
f010fd77:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010fd7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010fd81:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010fd88:	83 ec 0c             	sub    $0xc,%esp
f010fd8b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fd90:	e8 81 f8 ff ff       	call   f010f616 <acquire_spinlock>
f010fd95:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010fd98:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f010fd9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fda0:	eb 3b                	jmp    f010fddd <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010fda2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fda5:	83 c0 20             	add    $0x20,%eax
f010fda8:	83 ec 08             	sub    $0x8,%esp
f010fdab:	68 0f 79 12 f0       	push   $0xf012790f
f010fdb0:	50                   	push   %eax
f010fdb1:	e8 1a f9 00 00       	call   f011f6d0 <strcmp>
f010fdb6:	83 c4 10             	add    $0x10,%esp
f010fdb9:	85 c0                	test   %eax,%eax
f010fdbb:	75 12                	jne    f010fdcf <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010fdbd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fdc1:	74 07                	je     f010fdca <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010fdc3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010fdca:	ff 45 f4             	incl   -0xc(%ebp)
f010fdcd:	eb 06                	jmp    f010fdd5 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010fdcf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fdd3:	74 31                	je     f010fe06 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010fdd5:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010fdda:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fddd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fde1:	74 08                	je     f010fdeb <tst_sc_MLFQ+0x92>
f010fde3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fde6:	8b 40 08             	mov    0x8(%eax),%eax
f010fde9:	eb 05                	jmp    f010fdf0 <tst_sc_MLFQ+0x97>
f010fdeb:	b8 00 00 00 00       	mov    $0x0,%eax
f010fdf0:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f010fdf5:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f010fdfa:	85 c0                	test   %eax,%eax
f010fdfc:	75 a4                	jne    f010fda2 <tst_sc_MLFQ+0x49>
f010fdfe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fe02:	75 9e                	jne    f010fda2 <tst_sc_MLFQ+0x49>
f010fe04:	eb 01                	jmp    f010fe07 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010fe06:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010fe07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe0a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010fe0d:	75 12                	jne    f010fe21 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010fe0f:	83 ec 0c             	sub    $0xc,%esp
f010fe12:	68 18 79 12 f0       	push   $0xf0127918
f010fe17:	e8 6f 11 ff ff       	call   f0100f8b <cprintf>
f010fe1c:	83 c4 10             	add    $0x10,%esp
f010fe1f:	eb 17                	jmp    f010fe38 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010fe21:	83 ec 04             	sub    $0x4,%esp
f010fe24:	68 51 79 12 f0       	push   $0xf0127951
f010fe29:	68 9b 00 00 00       	push   $0x9b
f010fe2e:	68 67 79 12 f0       	push   $0xf0127967
f010fe33:	e8 01 05 ff ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010fe38:	83 ec 0c             	sub    $0xc,%esp
f010fe3b:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f010fe40:	e8 58 f8 ff ff       	call   f010f69d <release_spinlock>
f010fe45:	83 c4 10             	add    $0x10,%esp
	return 0;
f010fe48:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fe4d:	c9                   	leave  
f010fe4e:	c3                   	ret    

f010fe4f <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010fe4f:	55                   	push   %ebp
f010fe50:	89 e5                	mov    %esp,%ebp
f010fe52:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010fe55:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010fe59:	74 17                	je     f010fe72 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010fe5b:	83 ec 0c             	sub    $0xc,%esp
f010fe5e:	68 80 79 12 f0       	push   $0xf0127980
f010fe63:	e8 23 11 ff ff       	call   f0100f8b <cprintf>
f010fe68:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fe6b:	b8 00 00 00 00       	mov    $0x0,%eax
f010fe70:	eb 45                	jmp    f010feb7 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010fe72:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fe75:	83 c0 04             	add    $0x4,%eax
f010fe78:	8b 00                	mov    (%eax),%eax
f010fe7a:	83 ec 04             	sub    $0x4,%esp
f010fe7d:	6a 0a                	push   $0xa
f010fe7f:	6a 00                	push   $0x0
f010fe81:	50                   	push   %eax
f010fe82:	e8 9d fa 00 00       	call   f011f924 <strtol>
f010fe87:	83 c4 10             	add    $0x10,%esp
f010fe8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010fe8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fe90:	83 f8 01             	cmp    $0x1,%eax
f010fe93:	74 10                	je     f010fea5 <tst_bsd_nice+0x56>
f010fe95:	83 f8 02             	cmp    $0x2,%eax
f010fe98:	74 12                	je     f010feac <tst_bsd_nice+0x5d>
f010fe9a:	85 c0                	test   %eax,%eax
f010fe9c:	75 14                	jne    f010feb2 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010fe9e:	e8 b9 d2 00 00       	call   f011d15c <test_bsd_nice_0>
		break;
f010fea3:	eb 0d                	jmp    f010feb2 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010fea5:	e8 3c d5 00 00       	call   f011d3e6 <test_bsd_nice_1>
		break;
f010feaa:	eb 06                	jmp    f010feb2 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010feac:	e8 49 d7 00 00       	call   f011d5fa <test_bsd_nice_2>
		break;
f010feb1:	90                   	nop
	}
	return 0;
f010feb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010feb7:	c9                   	leave  
f010feb8:	c3                   	ret    

f010feb9 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010feb9:	55                   	push   %ebp
f010feba:	89 e5                	mov    %esp,%ebp
f010febc:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010febf:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010fec3:	74 17                	je     f010fedc <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010fec5:	83 ec 0c             	sub    $0xc,%esp
f010fec8:	68 c0 79 12 f0       	push   $0xf01279c0
f010fecd:	e8 b9 10 ff ff       	call   f0100f8b <cprintf>
f010fed2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fed5:	b8 00 00 00 00       	mov    $0x0,%eax
f010feda:	eb 0a                	jmp    f010fee6 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010fedc:	e8 3f 15 00 00       	call   f0111420 <test_str2lower_function>
	return 0;
f010fee1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fee6:	c9                   	leave  
f010fee7:	c3                   	ret    

f010fee8 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010fee8:	55                   	push   %ebp
f010fee9:	89 e5                	mov    %esp,%ebp
f010feeb:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010feee:	e8 63 11 00 00       	call   f0111056 <TestAutoCompleteCommand>
f010fef3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010fef6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fefb:	c9                   	leave  
f010fefc:	c3                   	ret    

f010fefd <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010fefd:	55                   	push   %ebp
f010fefe:	89 e5                	mov    %esp,%ebp
f010ff00:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010ff03:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ff07:	74 1a                	je     f010ff23 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010ff09:	83 ec 0c             	sub    $0xc,%esp
f010ff0c:	68 f4 79 12 f0       	push   $0xf01279f4
f010ff11:	e8 75 10 ff ff       	call   f0100f8b <cprintf>
f010ff16:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ff19:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff1e:	e9 2f 01 00 00       	jmp    f0110052 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010ff23:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff26:	83 c0 04             	add    $0x4,%eax
f010ff29:	8b 00                	mov    (%eax),%eax
f010ff2b:	83 ec 08             	sub    $0x8,%esp
f010ff2e:	68 31 7a 12 f0       	push   $0xf0127a31
f010ff33:	50                   	push   %eax
f010ff34:	e8 97 f7 00 00       	call   f011f6d0 <strcmp>
f010ff39:	83 c4 10             	add    $0x10,%esp
f010ff3c:	85 c0                	test   %eax,%eax
f010ff3e:	75 0a                	jne    f010ff4a <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010ff40:	e8 40 08 00 00       	call   f0110785 <test_initialize_dynamic_allocator>
f010ff45:	e9 03 01 00 00       	jmp    f011004d <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010ff4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff4d:	83 c0 04             	add    $0x4,%eax
f010ff50:	8b 00                	mov    (%eax),%eax
f010ff52:	83 ec 08             	sub    $0x8,%esp
f010ff55:	68 36 7a 12 f0       	push   $0xf0127a36
f010ff5a:	50                   	push   %eax
f010ff5b:	e8 70 f7 00 00       	call   f011f6d0 <strcmp>
f010ff60:	83 c4 10             	add    $0x10,%esp
f010ff63:	85 c0                	test   %eax,%eax
f010ff65:	75 0a                	jne    f010ff71 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010ff67:	e8 4d 08 00 00       	call   f01107b9 <test_alloc_block_FF>
f010ff6c:	e9 dc 00 00 00       	jmp    f011004d <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010ff71:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff74:	83 c0 04             	add    $0x4,%eax
f010ff77:	8b 00                	mov    (%eax),%eax
f010ff79:	83 ec 08             	sub    $0x8,%esp
f010ff7c:	68 3e 7a 12 f0       	push   $0xf0127a3e
f010ff81:	50                   	push   %eax
f010ff82:	e8 49 f7 00 00       	call   f011f6d0 <strcmp>
f010ff87:	83 c4 10             	add    $0x10,%esp
f010ff8a:	85 c0                	test   %eax,%eax
f010ff8c:	75 0a                	jne    f010ff98 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010ff8e:	e8 43 08 00 00       	call   f01107d6 <test_alloc_block_BF>
f010ff93:	e9 b5 00 00 00       	jmp    f011004d <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010ff98:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff9b:	83 c0 04             	add    $0x4,%eax
f010ff9e:	8b 00                	mov    (%eax),%eax
f010ffa0:	83 ec 08             	sub    $0x8,%esp
f010ffa3:	68 46 7a 12 f0       	push   $0xf0127a46
f010ffa8:	50                   	push   %eax
f010ffa9:	e8 22 f7 00 00       	call   f011f6d0 <strcmp>
f010ffae:	83 c4 10             	add    $0x10,%esp
f010ffb1:	85 c0                	test   %eax,%eax
f010ffb3:	75 0a                	jne    f010ffbf <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010ffb5:	e8 3c 08 00 00       	call   f01107f6 <test_alloc_block_NF>
f010ffba:	e9 8e 00 00 00       	jmp    f011004d <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010ffbf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ffc2:	83 c0 04             	add    $0x4,%eax
f010ffc5:	8b 00                	mov    (%eax),%eax
f010ffc7:	83 ec 08             	sub    $0x8,%esp
f010ffca:	68 4e 7a 12 f0       	push   $0xf0127a4e
f010ffcf:	50                   	push   %eax
f010ffd0:	e8 fb f6 00 00       	call   f011f6d0 <strcmp>
f010ffd5:	83 c4 10             	add    $0x10,%esp
f010ffd8:	85 c0                	test   %eax,%eax
f010ffda:	75 07                	jne    f010ffe3 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010ffdc:	e8 1b 08 00 00       	call   f01107fc <test_free_block_FF>
f010ffe1:	eb 6a                	jmp    f011004d <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010ffe3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ffe6:	83 c0 04             	add    $0x4,%eax
f010ffe9:	8b 00                	mov    (%eax),%eax
f010ffeb:	83 ec 08             	sub    $0x8,%esp
f010ffee:	68 55 7a 12 f0       	push   $0xf0127a55
f010fff3:	50                   	push   %eax
f010fff4:	e8 d7 f6 00 00       	call   f011f6d0 <strcmp>
f010fff9:	83 c4 10             	add    $0x10,%esp
f010fffc:	85 c0                	test   %eax,%eax
f010fffe:	75 07                	jne    f0110007 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f0110000:	e8 14 08 00 00       	call   f0110819 <test_free_block_BF>
f0110005:	eb 46                	jmp    f011004d <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f0110007:	8b 45 0c             	mov    0xc(%ebp),%eax
f011000a:	83 c0 04             	add    $0x4,%eax
f011000d:	8b 00                	mov    (%eax),%eax
f011000f:	83 ec 08             	sub    $0x8,%esp
f0110012:	68 5c 7a 12 f0       	push   $0xf0127a5c
f0110017:	50                   	push   %eax
f0110018:	e8 b3 f6 00 00       	call   f011f6d0 <strcmp>
f011001d:	83 c4 10             	add    $0x10,%esp
f0110020:	85 c0                	test   %eax,%eax
f0110022:	75 07                	jne    f011002b <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f0110024:	e8 0d 08 00 00       	call   f0110836 <test_free_block_NF>
f0110029:	eb 22                	jmp    f011004d <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f011002b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011002e:	83 c0 04             	add    $0x4,%eax
f0110031:	8b 00                	mov    (%eax),%eax
f0110033:	83 ec 08             	sub    $0x8,%esp
f0110036:	68 63 7a 12 f0       	push   $0xf0127a63
f011003b:	50                   	push   %eax
f011003c:	e8 8f f6 00 00       	call   f011f6d0 <strcmp>
f0110041:	83 c4 10             	add    $0x10,%esp
f0110044:	85 c0                	test   %eax,%eax
f0110046:	75 05                	jne    f011004d <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f0110048:	e8 06 08 00 00       	call   f0110853 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f011004d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110052:	c9                   	leave  
f0110053:	c3                   	ret    

f0110054 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f0110054:	55                   	push   %ebp
f0110055:	89 e5                	mov    %esp,%ebp
f0110057:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011005a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011005e:	74 1a                	je     f011007a <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f0110060:	83 ec 0c             	sub    $0xc,%esp
f0110063:	68 70 7a 12 f0       	push   $0xf0127a70
f0110068:	e8 1e 0f ff ff       	call   f0100f8b <cprintf>
f011006d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110070:	b8 00 00 00 00       	mov    $0x0,%eax
f0110075:	e9 e1 00 00 00       	jmp    f011015b <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f011007a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011007d:	83 c0 04             	add    $0x4,%eax
f0110080:	8b 00                	mov    (%eax),%eax
f0110082:	83 ec 08             	sub    $0x8,%esp
f0110085:	68 a9 7a 12 f0       	push   $0xf0127aa9
f011008a:	50                   	push   %eax
f011008b:	e8 40 f6 00 00       	call   f011f6d0 <strcmp>
f0110090:	83 c4 10             	add    $0x10,%esp
f0110093:	85 c0                	test   %eax,%eax
f0110095:	75 0a                	jne    f01100a1 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f0110097:	e8 97 1c 00 00       	call   f0111d33 <test_cut_paste_pages>
f011009c:	e9 b5 00 00 00       	jmp    f0110156 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01100a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100a4:	83 c0 04             	add    $0x4,%eax
f01100a7:	8b 00                	mov    (%eax),%eax
f01100a9:	83 ec 08             	sub    $0x8,%esp
f01100ac:	68 b2 7a 12 f0       	push   $0xf0127ab2
f01100b1:	50                   	push   %eax
f01100b2:	e8 19 f6 00 00       	call   f011f6d0 <strcmp>
f01100b7:	83 c4 10             	add    $0x10,%esp
f01100ba:	85 c0                	test   %eax,%eax
f01100bc:	75 0a                	jne    f01100c8 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01100be:	e8 bb 26 00 00       	call   f011277e <test_copy_paste_chunk>
f01100c3:	e9 8e 00 00 00       	jmp    f0110156 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01100c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100cb:	83 c0 04             	add    $0x4,%eax
f01100ce:	8b 00                	mov    (%eax),%eax
f01100d0:	83 ec 08             	sub    $0x8,%esp
f01100d3:	68 bc 7a 12 f0       	push   $0xf0127abc
f01100d8:	50                   	push   %eax
f01100d9:	e8 f2 f5 00 00       	call   f011f6d0 <strcmp>
f01100de:	83 c4 10             	add    $0x10,%esp
f01100e1:	85 c0                	test   %eax,%eax
f01100e3:	75 07                	jne    f01100ec <tst_chunks+0x98>
	{
		test_share_chunk();
f01100e5:	e8 92 37 00 00       	call   f011387c <test_share_chunk>
f01100ea:	eb 6a                	jmp    f0110156 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f01100ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f01100ef:	83 c0 04             	add    $0x4,%eax
f01100f2:	8b 00                	mov    (%eax),%eax
f01100f4:	83 ec 08             	sub    $0x8,%esp
f01100f7:	68 c2 7a 12 f0       	push   $0xf0127ac2
f01100fc:	50                   	push   %eax
f01100fd:	e8 ce f5 00 00       	call   f011f6d0 <strcmp>
f0110102:	83 c4 10             	add    $0x10,%esp
f0110105:	85 c0                	test   %eax,%eax
f0110107:	75 07                	jne    f0110110 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110109:	e8 96 41 00 00       	call   f01142a4 <test_allocate_chunk>
f011010e:	eb 46                	jmp    f0110156 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110110:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110113:	83 c0 04             	add    $0x4,%eax
f0110116:	8b 00                	mov    (%eax),%eax
f0110118:	83 ec 08             	sub    $0x8,%esp
f011011b:	68 cb 7a 12 f0       	push   $0xf0127acb
f0110120:	50                   	push   %eax
f0110121:	e8 aa f5 00 00       	call   f011f6d0 <strcmp>
f0110126:	83 c4 10             	add    $0x10,%esp
f0110129:	85 c0                	test   %eax,%eax
f011012b:	75 07                	jne    f0110134 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f011012d:	e8 79 4a 00 00       	call   f0114bab <test_calculate_required_frames>
f0110132:	eb 22                	jmp    f0110156 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0110134:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110137:	83 c0 04             	add    $0x4,%eax
f011013a:	8b 00                	mov    (%eax),%eax
f011013c:	83 ec 08             	sub    $0x8,%esp
f011013f:	68 da 7a 12 f0       	push   $0xf0127ada
f0110144:	50                   	push   %eax
f0110145:	e8 86 f5 00 00       	call   f011f6d0 <strcmp>
f011014a:	83 c4 10             	add    $0x10,%esp
f011014d:	85 c0                	test   %eax,%eax
f011014f:	75 05                	jne    f0110156 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110151:	e8 c9 52 00 00       	call   f011541f <test_calculate_allocated_space>
	}
	return 0;
f0110156:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011015b:	c9                   	leave  
f011015c:	c3                   	ret    

f011015d <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f011015d:	55                   	push   %ebp
f011015e:	89 e5                	mov    %esp,%ebp
f0110160:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110163:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110167:	74 1a                	je     f0110183 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f0110169:	83 ec 0c             	sub    $0xc,%esp
f011016c:	68 ec 7a 12 f0       	push   $0xf0127aec
f0110171:	e8 15 0e ff ff       	call   f0100f8b <cprintf>
f0110176:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110179:	b8 00 00 00 00       	mov    $0x0,%eax
f011017e:	e9 ba 00 00 00       	jmp    f011023d <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0110183:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110186:	83 c0 04             	add    $0x4,%eax
f0110189:	8b 00                	mov    (%eax),%eax
f011018b:	83 ec 08             	sub    $0x8,%esp
f011018e:	68 22 7b 12 f0       	push   $0xf0127b22
f0110193:	50                   	push   %eax
f0110194:	e8 37 f5 00 00       	call   f011f6d0 <strcmp>
f0110199:	83 c4 10             	add    $0x10,%esp
f011019c:	85 c0                	test   %eax,%eax
f011019e:	75 0a                	jne    f01101aa <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01101a0:	e8 01 16 00 00       	call   f01117a6 <test_pt_set_page_permissions>
f01101a5:	e9 8e 00 00 00       	jmp    f0110238 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01101aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101ad:	83 c0 04             	add    $0x4,%eax
f01101b0:	8b 00                	mov    (%eax),%eax
f01101b2:	83 ec 08             	sub    $0x8,%esp
f01101b5:	68 2a 7b 12 f0       	push   $0xf0127b2a
f01101ba:	50                   	push   %eax
f01101bb:	e8 10 f5 00 00       	call   f011f6d0 <strcmp>
f01101c0:	83 c4 10             	add    $0x10,%esp
f01101c3:	85 c0                	test   %eax,%eax
f01101c5:	75 07                	jne    f01101ce <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f01101c7:	e8 49 18 00 00       	call   f0111a15 <test_pt_set_page_permissions_invalid_va>
f01101cc:	eb 6a                	jmp    f0110238 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f01101ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101d1:	83 c0 04             	add    $0x4,%eax
f01101d4:	8b 00                	mov    (%eax),%eax
f01101d6:	83 ec 08             	sub    $0x8,%esp
f01101d9:	68 32 7b 12 f0       	push   $0xf0127b32
f01101de:	50                   	push   %eax
f01101df:	e8 ec f4 00 00       	call   f011f6d0 <strcmp>
f01101e4:	83 c4 10             	add    $0x10,%esp
f01101e7:	85 c0                	test   %eax,%eax
f01101e9:	75 07                	jne    f01101f2 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f01101eb:	e8 6e 18 00 00       	call   f0111a5e <test_pt_get_page_permissions>
f01101f0:	eb 46                	jmp    f0110238 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f01101f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101f5:	83 c0 04             	add    $0x4,%eax
f01101f8:	8b 00                	mov    (%eax),%eax
f01101fa:	83 ec 08             	sub    $0x8,%esp
f01101fd:	68 3a 7b 12 f0       	push   $0xf0127b3a
f0110202:	50                   	push   %eax
f0110203:	e8 c8 f4 00 00       	call   f011f6d0 <strcmp>
f0110208:	83 c4 10             	add    $0x10,%esp
f011020b:	85 c0                	test   %eax,%eax
f011020d:	75 07                	jne    f0110216 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f011020f:	e8 8e 19 00 00       	call   f0111ba2 <test_pt_clear_page_table_entry>
f0110214:	eb 22                	jmp    f0110238 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110216:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110219:	83 c0 04             	add    $0x4,%eax
f011021c:	8b 00                	mov    (%eax),%eax
f011021e:	83 ec 08             	sub    $0x8,%esp
f0110221:	68 41 7b 12 f0       	push   $0xf0127b41
f0110226:	50                   	push   %eax
f0110227:	e8 a4 f4 00 00       	call   f011f6d0 <strcmp>
f011022c:	83 c4 10             	add    $0x10,%esp
f011022f:	85 c0                	test   %eax,%eax
f0110231:	75 05                	jne    f0110238 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0110233:	e8 c3 1a 00 00       	call   f0111cfb <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f0110238:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011023d:	c9                   	leave  
f011023e:	c3                   	ret    

f011023f <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f011023f:	55                   	push   %ebp
f0110240:	89 e5                	mov    %esp,%ebp
f0110242:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0110245:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110248:	83 c0 08             	add    $0x8,%eax
f011024b:	8b 00                	mov    (%eax),%eax
f011024d:	83 ec 08             	sub    $0x8,%esp
f0110250:	68 48 7b 12 f0       	push   $0xf0127b48
f0110255:	50                   	push   %eax
f0110256:	e8 75 f4 00 00       	call   f011f6d0 <strcmp>
f011025b:	83 c4 10             	add    $0x10,%esp
f011025e:	85 c0                	test   %eax,%eax
f0110260:	75 20                	jne    f0110282 <tst_kheap+0x43>
f0110262:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110266:	74 1a                	je     f0110282 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f0110268:	83 ec 0c             	sub    $0xc,%esp
f011026b:	68 50 7b 12 f0       	push   $0xf0127b50
f0110270:	e8 16 0d ff ff       	call   f0100f8b <cprintf>
f0110275:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110278:	b8 00 00 00 00       	mov    $0x0,%eax
f011027d:	e9 42 04 00 00       	jmp    f01106c4 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0110282:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110285:	83 c0 08             	add    $0x8,%eax
f0110288:	8b 00                	mov    (%eax),%eax
f011028a:	83 ec 08             	sub    $0x8,%esp
f011028d:	68 48 7b 12 f0       	push   $0xf0127b48
f0110292:	50                   	push   %eax
f0110293:	e8 38 f4 00 00       	call   f011f6d0 <strcmp>
f0110298:	83 c4 10             	add    $0x10,%esp
f011029b:	85 c0                	test   %eax,%eax
f011029d:	74 43                	je     f01102e2 <tst_kheap+0xa3>
f011029f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01102a3:	74 3d                	je     f01102e2 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f01102a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102a8:	83 c0 08             	add    $0x8,%eax
f01102ab:	8b 00                	mov    (%eax),%eax
f01102ad:	83 ec 08             	sub    $0x8,%esp
f01102b0:	68 a0 7b 12 f0       	push   $0xf0127ba0
f01102b5:	50                   	push   %eax
f01102b6:	e8 15 f4 00 00       	call   f011f6d0 <strcmp>
f01102bb:	83 c4 10             	add    $0x10,%esp
f01102be:	85 c0                	test   %eax,%eax
f01102c0:	74 20                	je     f01102e2 <tst_kheap+0xa3>
f01102c2:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f01102c6:	74 1a                	je     f01102e2 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f01102c8:	83 ec 0c             	sub    $0xc,%esp
f01102cb:	68 ac 7b 12 f0       	push   $0xf0127bac
f01102d0:	e8 b6 0c ff ff       	call   f0100f8b <cprintf>
f01102d5:	83 c4 10             	add    $0x10,%esp
			return 0;
f01102d8:	b8 00 00 00 00       	mov    $0x0,%eax
f01102dd:	e9 e2 03 00 00       	jmp    f01106c4 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f01102e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102e5:	83 c0 04             	add    $0x4,%eax
f01102e8:	8b 00                	mov    (%eax),%eax
f01102ea:	83 ec 08             	sub    $0x8,%esp
f01102ed:	68 f1 7b 12 f0       	push   $0xf0127bf1
f01102f2:	50                   	push   %eax
f01102f3:	e8 d8 f3 00 00       	call   f011f6d0 <strcmp>
f01102f8:	83 c4 10             	add    $0x10,%esp
f01102fb:	85 c0                	test   %eax,%eax
f01102fd:	74 1d                	je     f011031c <tst_kheap+0xdd>
f01102ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110302:	83 c0 04             	add    $0x4,%eax
f0110305:	8b 00                	mov    (%eax),%eax
f0110307:	83 ec 08             	sub    $0x8,%esp
f011030a:	68 f4 7b 12 f0       	push   $0xf0127bf4
f011030f:	50                   	push   %eax
f0110310:	e8 bb f3 00 00       	call   f011f6d0 <strcmp>
f0110315:	83 c4 10             	add    $0x10,%esp
f0110318:	85 c0                	test   %eax,%eax
f011031a:	75 1a                	jne    f0110336 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f011031c:	e8 6d f8 ff ff       	call   f010fb8e <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110321:	83 ec 0c             	sub    $0xc,%esp
f0110324:	68 f8 7b 12 f0       	push   $0xf0127bf8
f0110329:	e8 5d 0c ff ff       	call   f0100f8b <cprintf>
f011032e:	83 c4 10             	add    $0x10,%esp
f0110331:	e9 a0 00 00 00       	jmp    f01103d6 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110336:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110339:	83 c0 04             	add    $0x4,%eax
f011033c:	8b 00                	mov    (%eax),%eax
f011033e:	83 ec 08             	sub    $0x8,%esp
f0110341:	68 25 7c 12 f0       	push   $0xf0127c25
f0110346:	50                   	push   %eax
f0110347:	e8 84 f3 00 00       	call   f011f6d0 <strcmp>
f011034c:	83 c4 10             	add    $0x10,%esp
f011034f:	85 c0                	test   %eax,%eax
f0110351:	74 1d                	je     f0110370 <tst_kheap+0x131>
f0110353:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110356:	83 c0 04             	add    $0x4,%eax
f0110359:	8b 00                	mov    (%eax),%eax
f011035b:	83 ec 08             	sub    $0x8,%esp
f011035e:	68 28 7c 12 f0       	push   $0xf0127c28
f0110363:	50                   	push   %eax
f0110364:	e8 67 f3 00 00       	call   f011f6d0 <strcmp>
f0110369:	83 c4 10             	add    $0x10,%esp
f011036c:	85 c0                	test   %eax,%eax
f011036e:	75 17                	jne    f0110387 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0110370:	e8 29 f8 ff ff       	call   f010fb9e <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110375:	83 ec 0c             	sub    $0xc,%esp
f0110378:	68 2c 7c 12 f0       	push   $0xf0127c2c
f011037d:	e8 09 0c ff ff       	call   f0100f8b <cprintf>
f0110382:	83 c4 10             	add    $0x10,%esp
f0110385:	eb 4f                	jmp    f01103d6 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110387:	8b 45 0c             	mov    0xc(%ebp),%eax
f011038a:	83 c0 04             	add    $0x4,%eax
f011038d:	8b 00                	mov    (%eax),%eax
f011038f:	83 ec 08             	sub    $0x8,%esp
f0110392:	68 58 7c 12 f0       	push   $0xf0127c58
f0110397:	50                   	push   %eax
f0110398:	e8 33 f3 00 00       	call   f011f6d0 <strcmp>
f011039d:	83 c4 10             	add    $0x10,%esp
f01103a0:	85 c0                	test   %eax,%eax
f01103a2:	74 1d                	je     f01103c1 <tst_kheap+0x182>
f01103a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103a7:	83 c0 04             	add    $0x4,%eax
f01103aa:	8b 00                	mov    (%eax),%eax
f01103ac:	83 ec 08             	sub    $0x8,%esp
f01103af:	68 5b 7c 12 f0       	push   $0xf0127c5b
f01103b4:	50                   	push   %eax
f01103b5:	e8 16 f3 00 00       	call   f011f6d0 <strcmp>
f01103ba:	83 c4 10             	add    $0x10,%esp
f01103bd:	85 c0                	test   %eax,%eax
f01103bf:	75 15                	jne    f01103d6 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f01103c1:	e8 e8 f7 ff ff       	call   f010fbae <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f01103c6:	83 ec 0c             	sub    $0xc,%esp
f01103c9:	68 60 7c 12 f0       	push   $0xf0127c60
f01103ce:	e8 b8 0b ff ff       	call   f0100f8b <cprintf>
f01103d3:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f01103d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103d9:	83 c0 08             	add    $0x8,%eax
f01103dc:	8b 00                	mov    (%eax),%eax
f01103de:	83 ec 08             	sub    $0x8,%esp
f01103e1:	68 48 7b 12 f0       	push   $0xf0127b48
f01103e6:	50                   	push   %eax
f01103e7:	e8 e4 f2 00 00       	call   f011f6d0 <strcmp>
f01103ec:	83 c4 10             	add    $0x10,%esp
f01103ef:	85 c0                	test   %eax,%eax
f01103f1:	0f 85 13 01 00 00    	jne    f011050a <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f01103f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103fa:	83 c0 0c             	add    $0xc,%eax
f01103fd:	8b 00                	mov    (%eax),%eax
f01103ff:	83 ec 04             	sub    $0x4,%esp
f0110402:	6a 0a                	push   $0xa
f0110404:	6a 00                	push   $0x0
f0110406:	50                   	push   %eax
f0110407:	e8 18 f5 00 00       	call   f011f924 <strtol>
f011040c:	83 c4 10             	add    $0x10,%esp
f011040f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110412:	e8 a7 f7 ff ff       	call   f010fbbe <isKHeapPlacementStrategyFIRSTFIT>
f0110417:	84 c0                	test   %al,%al
f0110419:	74 54                	je     f011046f <tst_kheap+0x230>
		{
			if (testNum == 0)
f011041b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011041f:	75 1a                	jne    f011043b <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0110421:	83 ec 0c             	sub    $0xc,%esp
f0110424:	68 8c 7c 12 f0       	push   $0xf0127c8c
f0110429:	e8 5d 0b ff ff       	call   f0100f8b <cprintf>
f011042e:	83 c4 10             	add    $0x10,%esp
				return 0;
f0110431:	b8 00 00 00 00       	mov    $0x0,%eax
f0110436:	e9 89 02 00 00       	jmp    f01106c4 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f011043b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f011043f:	75 0a                	jne    f011044b <tst_kheap+0x20c>
				test_kmalloc();
f0110441:	e8 ec 61 00 00       	call   f0116632 <test_kmalloc>
f0110446:	e9 b5 00 00 00       	jmp    f0110500 <tst_kheap+0x2c1>
			else if (testNum == 2)
f011044b:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011044f:	75 0a                	jne    f011045b <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0110451:	e8 68 6d 00 00       	call   f01171be <test_kmalloc_firstfit1>
f0110456:	e9 a5 00 00 00       	jmp    f0110500 <tst_kheap+0x2c1>
			else if (testNum == 3)
f011045b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011045f:	0f 85 9b 00 00 00    	jne    f0110500 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0110465:	e8 38 78 00 00       	call   f0117ca2 <test_kmalloc_firstfit2>
f011046a:	e9 91 00 00 00       	jmp    f0110500 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f011046f:	e8 5f f7 ff ff       	call   f010fbd3 <isKHeapPlacementStrategyBESTFIT>
f0110474:	84 c0                	test   %al,%al
f0110476:	74 47                	je     f01104bf <tst_kheap+0x280>
		{
			if (testNum == 0)
f0110478:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011047c:	75 1a                	jne    f0110498 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f011047e:	83 ec 0c             	sub    $0xc,%esp
f0110481:	68 dc 7c 12 f0       	push   $0xf0127cdc
f0110486:	e8 00 0b ff ff       	call   f0100f8b <cprintf>
f011048b:	83 c4 10             	add    $0x10,%esp
				return 0;
f011048e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110493:	e9 2c 02 00 00       	jmp    f01106c4 <tst_kheap+0x485>
			}
			if (testNum == 1)
f0110498:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f011049c:	75 07                	jne    f01104a5 <tst_kheap+0x266>
				test_kmalloc();
f011049e:	e8 8f 61 00 00       	call   f0116632 <test_kmalloc>
f01104a3:	eb 5b                	jmp    f0110500 <tst_kheap+0x2c1>
			else if (testNum == 2)
f01104a5:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01104a9:	75 07                	jne    f01104b2 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f01104ab:	e8 2b c8 00 00       	call   f011ccdb <test_kmalloc_bestfit1>
f01104b0:	eb 4e                	jmp    f0110500 <tst_kheap+0x2c1>
			else if (testNum == 3)
f01104b2:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f01104b6:	75 48                	jne    f0110500 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f01104b8:	e8 3b c8 00 00       	call   f011ccf8 <test_kmalloc_bestfit2>
f01104bd:	eb 41                	jmp    f0110500 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f01104bf:	e8 24 f7 ff ff       	call   f010fbe8 <isKHeapPlacementStrategyNEXTFIT>
f01104c4:	84 c0                	test   %al,%al
f01104c6:	74 38                	je     f0110500 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f01104c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01104cc:	75 1a                	jne    f01104e8 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f01104ce:	83 ec 0c             	sub    $0xc,%esp
f01104d1:	68 2c 7d 12 f0       	push   $0xf0127d2c
f01104d6:	e8 b0 0a ff ff       	call   f0100f8b <cprintf>
f01104db:	83 c4 10             	add    $0x10,%esp
				return 0;
f01104de:	b8 00 00 00 00       	mov    $0x0,%eax
f01104e3:	e9 dc 01 00 00       	jmp    f01106c4 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f01104e8:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01104ec:	75 07                	jne    f01104f5 <tst_kheap+0x2b6>
				test_kmalloc();
f01104ee:	e8 3f 61 00 00       	call   f0116632 <test_kmalloc>
f01104f3:	eb 0b                	jmp    f0110500 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f01104f5:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01104f9:	75 05                	jne    f0110500 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f01104fb:	e8 be c7 00 00       	call   f011ccbe <test_kmalloc_nextfit>
		}
		return 0;
f0110500:	b8 00 00 00 00       	mov    $0x0,%eax
f0110505:	e9 ba 01 00 00       	jmp    f01106c4 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f011050a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011050d:	83 c0 08             	add    $0x8,%eax
f0110510:	8b 00                	mov    (%eax),%eax
f0110512:	83 ec 08             	sub    $0x8,%esp
f0110515:	68 7a 7d 12 f0       	push   $0xf0127d7a
f011051a:	50                   	push   %eax
f011051b:	e8 b0 f1 00 00       	call   f011f6d0 <strcmp>
f0110520:	83 c4 10             	add    $0x10,%esp
f0110523:	85 c0                	test   %eax,%eax
f0110525:	75 2f                	jne    f0110556 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0110527:	e8 92 f6 ff ff       	call   f010fbbe <isKHeapPlacementStrategyFIRSTFIT>
f011052c:	84 c0                	test   %al,%al
f011052e:	74 0f                	je     f011053f <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0110530:	e8 74 82 00 00       	call   f01187a9 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0110535:	b8 00 00 00 00       	mov    $0x0,%eax
f011053a:	e9 85 01 00 00       	jmp    f01106c4 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f011053f:	83 ec 04             	sub    $0x4,%esp
f0110542:	68 80 7d 12 f0       	push   $0xf0127d80
f0110547:	68 ac 01 00 00       	push   $0x1ac
f011054c:	68 67 79 12 f0       	push   $0xf0127967
f0110551:	e8 e3 fd fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0110556:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110559:	83 c0 08             	add    $0x8,%eax
f011055c:	8b 00                	mov    (%eax),%eax
f011055e:	83 ec 08             	sub    $0x8,%esp
f0110561:	68 c1 7d 12 f0       	push   $0xf0127dc1
f0110566:	50                   	push   %eax
f0110567:	e8 64 f1 00 00       	call   f011f6d0 <strcmp>
f011056c:	83 c4 10             	add    $0x10,%esp
f011056f:	85 c0                	test   %eax,%eax
f0110571:	75 28                	jne    f011059b <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0110573:	e8 5b f6 ff ff       	call   f010fbd3 <isKHeapPlacementStrategyBESTFIT>
f0110578:	84 c0                	test   %al,%al
f011057a:	75 09                	jne    f0110585 <tst_kheap+0x346>
f011057c:	e8 3d f6 ff ff       	call   f010fbbe <isKHeapPlacementStrategyFIRSTFIT>
f0110581:	84 c0                	test   %al,%al
f0110583:	74 07                	je     f011058c <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0110585:	e8 ee 8a 00 00       	call   f0119078 <test_kfree_bestfirstfit>
f011058a:	eb 05                	jmp    f0110591 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f011058c:	e8 a1 c7 00 00       	call   f011cd32 <test_kfree>
		}
		return 0;
f0110591:	b8 00 00 00 00       	mov    $0x0,%eax
f0110596:	e9 29 01 00 00       	jmp    f01106c4 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f011059b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011059e:	83 c0 08             	add    $0x8,%eax
f01105a1:	8b 00                	mov    (%eax),%eax
f01105a3:	83 ec 08             	sub    $0x8,%esp
f01105a6:	68 c7 7d 12 f0       	push   $0xf0127dc7
f01105ab:	50                   	push   %eax
f01105ac:	e8 1f f1 00 00       	call   f011f6d0 <strcmp>
f01105b1:	83 c4 10             	add    $0x10,%esp
f01105b4:	85 c0                	test   %eax,%eax
f01105b6:	75 0f                	jne    f01105c7 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f01105b8:	e8 17 a1 00 00       	call   f011a6d4 <test_kheap_phys_addr>
		return 0;
f01105bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01105c2:	e9 fd 00 00 00       	jmp    f01106c4 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f01105c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105ca:	83 c0 08             	add    $0x8,%eax
f01105cd:	8b 00                	mov    (%eax),%eax
f01105cf:	83 ec 08             	sub    $0x8,%esp
f01105d2:	68 d1 7d 12 f0       	push   $0xf0127dd1
f01105d7:	50                   	push   %eax
f01105d8:	e8 f3 f0 00 00       	call   f011f6d0 <strcmp>
f01105dd:	83 c4 10             	add    $0x10,%esp
f01105e0:	85 c0                	test   %eax,%eax
f01105e2:	75 0f                	jne    f01105f3 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f01105e4:	e8 ce ae 00 00       	call   f011b4b7 <test_kheap_virt_addr>
		return 0;
f01105e9:	b8 00 00 00 00       	mov    $0x0,%eax
f01105ee:	e9 d1 00 00 00       	jmp    f01106c4 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f01105f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105f6:	83 c0 08             	add    $0x8,%eax
f01105f9:	8b 00                	mov    (%eax),%eax
f01105fb:	83 ec 08             	sub    $0x8,%esp
f01105fe:	68 a0 7b 12 f0       	push   $0xf0127ba0
f0110603:	50                   	push   %eax
f0110604:	e8 c7 f0 00 00       	call   f011f6d0 <strcmp>
f0110609:	83 c4 10             	add    $0x10,%esp
f011060c:	85 c0                	test   %eax,%eax
f011060e:	0f 85 89 00 00 00    	jne    f011069d <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f0110614:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110617:	83 c0 0c             	add    $0xc,%eax
f011061a:	8b 00                	mov    (%eax),%eax
f011061c:	83 ec 04             	sub    $0x4,%esp
f011061f:	6a 0a                	push   $0xa
f0110621:	6a 00                	push   $0x0
f0110623:	50                   	push   %eax
f0110624:	e8 fb f2 00 00       	call   f011f924 <strtol>
f0110629:	83 c4 10             	add    $0x10,%esp
f011062c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f011062f:	e8 8a f5 ff ff       	call   f010fbbe <isKHeapPlacementStrategyFIRSTFIT>
f0110634:	84 c0                	test   %al,%al
f0110636:	74 42                	je     f011067a <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0110638:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011063c:	75 17                	jne    f0110655 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f011063e:	83 ec 0c             	sub    $0xc,%esp
f0110641:	68 8c 7c 12 f0       	push   $0xf0127c8c
f0110646:	e8 40 09 ff ff       	call   f0100f8b <cprintf>
f011064b:	83 c4 10             	add    $0x10,%esp
				return 0;
f011064e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110653:	eb 6f                	jmp    f01106c4 <tst_kheap+0x485>
			}
			if (testNum==1)
f0110655:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0110659:	75 07                	jne    f0110662 <tst_kheap+0x423>
				test_krealloc_FF1();
f011065b:	e8 50 c9 00 00       	call   f011cfb0 <test_krealloc_FF1>
f0110660:	eb 18                	jmp    f011067a <tst_kheap+0x43b>
			else if (testNum==2)
f0110662:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0110666:	75 07                	jne    f011066f <tst_kheap+0x430>
				test_krealloc_FF2();
f0110668:	e8 60 c9 00 00       	call   f011cfcd <test_krealloc_FF2>
f011066d:	eb 0b                	jmp    f011067a <tst_kheap+0x43b>
			else if (testNum==3)
f011066f:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0110673:	75 05                	jne    f011067a <tst_kheap+0x43b>
				test_krealloc_FF3();
f0110675:	e8 70 c9 00 00       	call   f011cfea <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f011067a:	e8 69 f5 ff ff       	call   f010fbe8 <isKHeapPlacementStrategyNEXTFIT>
f011067f:	84 c0                	test   %al,%al
f0110681:	74 05                	je     f0110688 <tst_kheap+0x449>
		{
			test_krealloc();
f0110683:	e8 ee c8 00 00       	call   f011cf76 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0110688:	e8 46 f5 ff ff       	call   f010fbd3 <isKHeapPlacementStrategyBESTFIT>
f011068d:	84 c0                	test   %al,%al
f011068f:	74 05                	je     f0110696 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0110691:	e8 fd c8 00 00       	call   f011cf93 <test_krealloc_BF>
		}
		return 0;
f0110696:	b8 00 00 00 00       	mov    $0x0,%eax
f011069b:	eb 27                	jmp    f01106c4 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f011069d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106a0:	83 c0 08             	add    $0x8,%eax
f01106a3:	8b 00                	mov    (%eax),%eax
f01106a5:	83 ec 08             	sub    $0x8,%esp
f01106a8:	68 db 7d 12 f0       	push   $0xf0127ddb
f01106ad:	50                   	push   %eax
f01106ae:	e8 1d f0 00 00       	call   f011f6d0 <strcmp>
f01106b3:	83 c4 10             	add    $0x10,%esp
f01106b6:	85 c0                	test   %eax,%eax
f01106b8:	75 05                	jne    f01106bf <tst_kheap+0x480>
	{
		test_ksbrk();
f01106ba:	e8 1d bb 00 00       	call   f011c1dc <test_ksbrk>
	}
	return 0;
f01106bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106c4:	c9                   	leave  
f01106c5:	c3                   	ret    

f01106c6 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f01106c6:	55                   	push   %ebp
f01106c7:	89 e5                	mov    %esp,%ebp
f01106c9:	83 ec 28             	sub    $0x28,%esp
f01106cc:	8b 45 14             	mov    0x14(%ebp),%eax
f01106cf:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f01106d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01106d5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01106d8:	74 1d                	je     f01106f7 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f01106da:	83 ec 04             	sub    $0x4,%esp
f01106dd:	ff 75 08             	pushl  0x8(%ebp)
f01106e0:	ff 75 0c             	pushl  0xc(%ebp)
f01106e3:	68 e0 7d 12 f0       	push   $0xf0127de0
f01106e8:	e8 9e 08 ff ff       	call   f0100f8b <cprintf>
f01106ed:	83 c4 10             	add    $0x10,%esp
		return 0;
f01106f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01106f5:	eb 55                	jmp    f011074c <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f01106f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01106fa:	8b 40 fc             	mov    -0x4(%eax),%eax
f01106fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f0110700:	8b 45 10             	mov    0x10(%ebp),%eax
f0110703:	8d 50 f8             	lea    -0x8(%eax),%edx
f0110706:	8b 45 08             	mov    0x8(%ebp),%eax
f0110709:	01 d0                	add    %edx,%eax
f011070b:	8b 00                	mov    (%eax),%eax
f011070d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f0110710:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0110714:	0b 45 10             	or     0x10(%ebp),%eax
f0110717:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f011071a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011071d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110720:	75 08                	jne    f011072a <check_block+0x64>
f0110722:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110725:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0110728:	74 1d                	je     f0110747 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f011072a:	ff 75 f0             	pushl  -0x10(%ebp)
f011072d:	ff 75 f4             	pushl  -0xc(%ebp)
f0110730:	ff 75 ec             	pushl  -0x14(%ebp)
f0110733:	68 10 7e 12 f0       	push   $0xf0127e10
f0110738:	e8 4e 08 ff ff       	call   f0100f8b <cprintf>
f011073d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110740:	b8 00 00 00 00       	mov    $0x0,%eax
f0110745:	eb 05                	jmp    f011074c <check_block+0x86>
	}
	return 1;
f0110747:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011074c:	c9                   	leave  
f011074d:	c3                   	ret    

f011074e <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f011074e:	55                   	push   %ebp
f011074f:	89 e5                	mov    %esp,%ebp
f0110751:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0110754:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0110759:	3b 45 08             	cmp    0x8(%ebp),%eax
f011075c:	74 20                	je     f011077e <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f011075e:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0110763:	83 ec 04             	sub    $0x4,%esp
f0110766:	50                   	push   %eax
f0110767:	ff 75 08             	pushl  0x8(%ebp)
f011076a:	68 4c 7e 12 f0       	push   $0xf0127e4c
f011076f:	e8 17 08 ff ff       	call   f0100f8b <cprintf>
f0110774:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110777:	b8 00 00 00 00       	mov    $0x0,%eax
f011077c:	eb 05                	jmp    f0110783 <check_list_size+0x35>
	}
	return 1;
f011077e:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110783:	c9                   	leave  
f0110784:	c3                   	ret    

f0110785 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110785:	55                   	push   %ebp
f0110786:	89 e5                	mov    %esp,%ebp
f0110788:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f011078b:	83 ec 04             	sub    $0x4,%esp
f011078e:	68 80 7e 12 f0       	push   $0xf0127e80
f0110793:	6a 3f                	push   $0x3f
f0110795:	68 e0 7e 12 f0       	push   $0xf0127ee0
f011079a:	e8 9a fb fe ff       	call   f0100339 <_panic>

f011079f <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f011079f:	55                   	push   %ebp
f01107a0:	89 e5                	mov    %esp,%ebp
f01107a2:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01107a5:	83 ec 04             	sub    $0x4,%esp
f01107a8:	68 04 7f 12 f0       	push   $0xf0127f04
f01107ad:	6a 61                	push   $0x61
f01107af:	68 e0 7e 12 f0       	push   $0xf0127ee0
f01107b4:	e8 80 fb fe ff       	call   f0100339 <_panic>

f01107b9 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f01107b9:	55                   	push   %ebp
f01107ba:	89 e5                	mov    %esp,%ebp
f01107bc:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01107bf:	83 ec 04             	sub    $0x4,%esp
f01107c2:	68 54 7f 12 f0       	push   $0xf0127f54
f01107c7:	68 e7 00 00 00       	push   $0xe7
f01107cc:	68 e0 7e 12 f0       	push   $0xf0127ee0
f01107d1:	e8 63 fb fe ff       	call   f0100339 <_panic>

f01107d6 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f01107d6:	55                   	push   %ebp
f01107d7:	89 e5                	mov    %esp,%ebp
f01107d9:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01107df:	83 ec 04             	sub    $0x4,%esp
f01107e2:	68 a8 7f 12 f0       	push   $0xf0127fa8
f01107e7:	68 88 01 00 00       	push   $0x188
f01107ec:	68 e0 7e 12 f0       	push   $0xf0127ee0
f01107f1:	e8 43 fb fe ff       	call   f0100339 <_panic>

f01107f6 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f01107f6:	55                   	push   %ebp
f01107f7:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f01107f9:	90                   	nop
f01107fa:	5d                   	pop    %ebp
f01107fb:	c3                   	ret    

f01107fc <test_free_block_FF>:

void test_free_block_FF()
{
f01107fc:	55                   	push   %ebp
f01107fd:	89 e5                	mov    %esp,%ebp
f01107ff:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110802:	83 ec 04             	sub    $0x4,%esp
f0110805:	68 fc 7f 12 f0       	push   $0xf0127ffc
f011080a:	68 4e 02 00 00       	push   $0x24e
f011080f:	68 e0 7e 12 f0       	push   $0xf0127ee0
f0110814:	e8 20 fb fe ff       	call   f0100339 <_panic>

f0110819 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f0110819:	55                   	push   %ebp
f011081a:	89 e5                	mov    %esp,%ebp
f011081c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011081f:	83 ec 04             	sub    $0x4,%esp
f0110822:	68 fc 7f 12 f0       	push   $0xf0127ffc
f0110827:	68 9a 03 00 00       	push   $0x39a
f011082c:	68 e0 7e 12 f0       	push   $0xf0127ee0
f0110831:	e8 03 fb fe ff       	call   f0100339 <_panic>

f0110836 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0110836:	55                   	push   %ebp
f0110837:	89 e5                	mov    %esp,%ebp
f0110839:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011083c:	83 ec 04             	sub    $0x4,%esp
f011083f:	68 49 80 12 f0       	push   $0xf0128049
f0110844:	68 ba 04 00 00       	push   $0x4ba
f0110849:	68 e0 7e 12 f0       	push   $0xf0127ee0
f011084e:	e8 e6 fa fe ff       	call   f0100339 <_panic>

f0110853 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110853:	55                   	push   %ebp
f0110854:	89 e5                	mov    %esp,%ebp
f0110856:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110859:	83 ec 04             	sub    $0x4,%esp
f011085c:	68 fc 7f 12 f0       	push   $0xf0127ffc
f0110861:	68 c0 04 00 00       	push   $0x4c0
f0110866:	68 e0 7e 12 f0       	push   $0xf0127ee0
f011086b:	e8 c9 fa fe ff       	call   f0100339 <_panic>

f0110870 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110870:	55                   	push   %ebp
f0110871:	89 e5                	mov    %esp,%ebp
f0110873:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110876:	83 ec 04             	sub    $0x4,%esp
f0110879:	68 fc 7f 12 f0       	push   $0xf0127ffc
f011087e:	68 e7 05 00 00       	push   $0x5e7
f0110883:	68 e0 7e 12 f0       	push   $0xf0127ee0
f0110888:	e8 ac fa fe ff       	call   f0100339 <_panic>

f011088d <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f011088d:	55                   	push   %ebp
f011088e:	89 e5                	mov    %esp,%ebp
f0110890:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110893:	e8 f0 aa ff ff       	call   f010b388 <get_cpu_proc>
f0110898:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f011089b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011089f:	75 16                	jne    f01108b7 <sys_check_LRU_lists+0x2a>
f01108a1:	68 5c 80 12 f0       	push   $0xf012805c
f01108a6:	68 6c 80 12 f0       	push   $0xf012806c
f01108ab:	6a 10                	push   $0x10
f01108ad:	68 81 80 12 f0       	push   $0xf0128081
f01108b2:	e8 82 fa fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f01108b7:	83 ec 0c             	sub    $0xc,%esp
f01108ba:	68 a0 80 12 f0       	push   $0xf01280a0
f01108bf:	e8 c7 06 ff ff       	call   f0100f8b <cprintf>
f01108c4:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f01108c7:	83 ec 0c             	sub    $0xc,%esp
f01108ca:	ff 75 e0             	pushl  -0x20(%ebp)
f01108cd:	e8 f4 94 ff ff       	call   f0109dc6 <env_page_ws_print>
f01108d2:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f01108d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01108d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f01108db:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f01108e2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f01108e9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01108ed:	0f 84 a5 00 00 00    	je     f0110998 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f01108f3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01108fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01108fd:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110903:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110906:	eb 4a                	jmp    f0110952 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0110908:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011090b:	8b 00                	mov    (%eax),%eax
f011090d:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110910:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110913:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110918:	89 c2                	mov    %eax,%edx
f011091a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011091d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110924:	8b 45 08             	mov    0x8(%ebp),%eax
f0110927:	01 c8                	add    %ecx,%eax
f0110929:	8b 00                	mov    (%eax),%eax
f011092b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011092e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110931:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110936:	39 c2                	cmp    %eax,%edx
f0110938:	74 09                	je     f0110943 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f011093a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110941:	eb 3e                	jmp    f0110981 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0110943:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110946:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110949:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f011094f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110952:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110956:	74 08                	je     f0110960 <sys_check_LRU_lists+0xd3>
f0110958:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011095b:	8b 40 10             	mov    0x10(%eax),%eax
f011095e:	eb 05                	jmp    f0110965 <sys_check_LRU_lists+0xd8>
f0110960:	b8 00 00 00 00       	mov    $0x0,%eax
f0110965:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110968:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f011096e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110971:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110977:	85 c0                	test   %eax,%eax
f0110979:	75 8d                	jne    f0110908 <sys_check_LRU_lists+0x7b>
f011097b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011097f:	75 87                	jne    f0110908 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0110981:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110984:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f011098a:	8b 45 10             	mov    0x10(%ebp),%eax
f011098d:	39 c2                	cmp    %eax,%edx
f011098f:	74 07                	je     f0110998 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0110991:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0110998:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011099c:	0f 84 a5 00 00 00    	je     f0110a47 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f01109a2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01109a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01109ac:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01109b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01109b5:	eb 4a                	jmp    f0110a01 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f01109b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01109ba:	8b 00                	mov    (%eax),%eax
f01109bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01109bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01109c2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01109c7:	89 c2                	mov    %eax,%edx
f01109c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01109cc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01109d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109d6:	01 c8                	add    %ecx,%eax
f01109d8:	8b 00                	mov    (%eax),%eax
f01109da:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01109dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01109e0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01109e5:	39 c2                	cmp    %eax,%edx
f01109e7:	74 09                	je     f01109f2 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01109e9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01109f0:	eb 3e                	jmp    f0110a30 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01109f2:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01109f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01109f8:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f01109fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110a01:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110a05:	74 08                	je     f0110a0f <sys_check_LRU_lists+0x182>
f0110a07:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110a0a:	8b 40 10             	mov    0x10(%eax),%eax
f0110a0d:	eb 05                	jmp    f0110a14 <sys_check_LRU_lists+0x187>
f0110a0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a14:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0110a17:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0110a1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110a20:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110a26:	85 c0                	test   %eax,%eax
f0110a28:	75 8d                	jne    f01109b7 <sys_check_LRU_lists+0x12a>
f0110a2a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110a2e:	75 87                	jne    f01109b7 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0110a30:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110a33:	8b 90 7c 05 00 00    	mov    0x57c(%eax),%edx
f0110a39:	8b 45 14             	mov    0x14(%ebp),%eax
f0110a3c:	39 c2                	cmp    %eax,%edx
f0110a3e:	74 07                	je     f0110a47 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0110a40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0110a47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110a4a:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0110a4d:	c9                   	leave  
f0110a4e:	c3                   	ret    

f0110a4f <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0110a4f:	55                   	push   %ebp
f0110a50:	89 e5                	mov    %esp,%ebp
f0110a52:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110a55:	e8 2e a9 ff ff       	call   f010b388 <get_cpu_proc>
f0110a5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0110a5d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0110a61:	75 16                	jne    f0110a79 <sys_check_LRU_lists_free+0x2a>
f0110a63:	68 5c 80 12 f0       	push   $0xf012805c
f0110a68:	68 6c 80 12 f0       	push   $0xf012806c
f0110a6d:	6a 45                	push   $0x45
f0110a6f:	68 81 80 12 f0       	push   $0xf0128081
f0110a74:	e8 c0 f8 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0110a79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110a7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0110a7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110a86:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110a89:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0110a8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110a92:	eb 65                	jmp    f0110af9 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0110a94:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0110a9b:	eb 3a                	jmp    f0110ad7 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0110a9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110aa0:	8b 00                	mov    (%eax),%eax
f0110aa2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110aa5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110aa8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110aad:	89 c2                	mov    %eax,%edx
f0110aaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110ab2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110ab9:	8b 45 08             	mov    0x8(%ebp),%eax
f0110abc:	01 c8                	add    %ecx,%eax
f0110abe:	8b 00                	mov    (%eax),%eax
f0110ac0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0110ac3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110ac6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110acb:	39 c2                	cmp    %eax,%edx
f0110acd:	75 05                	jne    f0110ad4 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0110acf:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110ad2:	eb 0b                	jmp    f0110adf <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0110ad4:	ff 45 ec             	incl   -0x14(%ebp)
f0110ad7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110ada:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110add:	7c be                	jl     f0110a9d <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0110adf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110ae3:	7e 08                	jle    f0110aed <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f0110ae5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ae8:	e9 ed 00 00 00       	jmp    f0110bda <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110aed:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110af0:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110af6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110af9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110afd:	74 08                	je     f0110b07 <sys_check_LRU_lists_free+0xb8>
f0110aff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110b02:	8b 40 10             	mov    0x10(%eax),%eax
f0110b05:	eb 05                	jmp    f0110b0c <sys_check_LRU_lists_free+0xbd>
f0110b07:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b0c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0110b0f:	89 82 68 05 00 00    	mov    %eax,0x568(%edx)
f0110b15:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110b18:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0110b1e:	85 c0                	test   %eax,%eax
f0110b20:	0f 85 6e ff ff ff    	jne    f0110a94 <sys_check_LRU_lists_free+0x45>
f0110b26:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110b2a:	0f 85 64 ff ff ff    	jne    f0110a94 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110b30:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110b33:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0110b39:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110b3c:	eb 62                	jmp    f0110ba0 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0110b3e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110b45:	eb 3a                	jmp    f0110b81 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0110b47:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110b4a:	8b 00                	mov    (%eax),%eax
f0110b4c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0110b4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110b52:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110b57:	89 c2                	mov    %eax,%edx
f0110b59:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110b5c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110b63:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b66:	01 c8                	add    %ecx,%eax
f0110b68:	8b 00                	mov    (%eax),%eax
f0110b6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110b6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110b70:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110b75:	39 c2                	cmp    %eax,%edx
f0110b77:	75 05                	jne    f0110b7e <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0110b79:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110b7c:	eb 0b                	jmp    f0110b89 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0110b7e:	ff 45 e8             	incl   -0x18(%ebp)
f0110b81:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110b84:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110b87:	7c be                	jl     f0110b47 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0110b89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110b8d:	7e 05                	jle    f0110b94 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0110b8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110b92:	eb 46                	jmp    f0110bda <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110b94:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110b97:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110b9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110ba0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110ba4:	74 08                	je     f0110bae <sys_check_LRU_lists_free+0x15f>
f0110ba6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110ba9:	8b 40 10             	mov    0x10(%eax),%eax
f0110bac:	eb 05                	jmp    f0110bb3 <sys_check_LRU_lists_free+0x164>
f0110bae:	b8 00 00 00 00       	mov    $0x0,%eax
f0110bb3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0110bb6:	89 82 78 05 00 00    	mov    %eax,0x578(%edx)
f0110bbc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110bbf:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0110bc5:	85 c0                	test   %eax,%eax
f0110bc7:	0f 85 71 ff ff ff    	jne    f0110b3e <sys_check_LRU_lists_free+0xef>
f0110bcd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110bd1:	0f 85 67 ff ff ff    	jne    f0110b3e <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0110bd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110bda:	c9                   	leave  
f0110bdb:	c3                   	ret    

f0110bdc <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0110bdc:	55                   	push   %ebp
f0110bdd:	89 e5                	mov    %esp,%ebp
f0110bdf:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f0110be2:	e8 a1 a7 ff ff       	call   f010b388 <get_cpu_proc>
f0110be7:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0110bea:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0110bee:	75 16                	jne    f0110c06 <sys_check_WS_list+0x2a>
f0110bf0:	68 5c 80 12 f0       	push   $0xf012805c
f0110bf5:	68 6c 80 12 f0       	push   $0xf012806c
f0110bfa:	6a 79                	push   $0x79
f0110bfc:	68 81 80 12 f0       	push   $0xf0128081
f0110c01:	e8 33 f7 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0110c06:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110c09:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0110c0c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f0110c13:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0110c17:	74 06                	je     f0110c1f <sys_check_WS_list+0x43>
f0110c19:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110c1d:	75 1f                	jne    f0110c3e <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0110c1f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c22:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f0110c28:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c2b:	39 c2                	cmp    %eax,%edx
f0110c2d:	74 0f                	je     f0110c3e <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0110c2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110c39:	e9 15 03 00 00       	jmp    f0110f53 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0110c3e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110c42:	74 39                	je     f0110c7d <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110c44:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110c47:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110c4d:	8b 00                	mov    (%eax),%eax
f0110c4f:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0110c52:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110c55:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110c5a:	89 c2                	mov    %eax,%edx
f0110c5c:	8b 45 10             	mov    0x10(%ebp),%eax
f0110c5f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0110c62:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110c65:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110c6a:	39 c2                	cmp    %eax,%edx
f0110c6c:	74 0f                	je     f0110c7d <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0110c6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110c78:	e9 d6 02 00 00       	jmp    f0110f53 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0110c7d:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110c81:	0f 85 3c 01 00 00    	jne    f0110dc3 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0110c87:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0110c8e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110c92:	74 4c                	je     f0110ce0 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110c94:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110c9b:	eb 3b                	jmp    f0110cd8 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110c9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110ca0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110ca7:	8b 45 08             	mov    0x8(%ebp),%eax
f0110caa:	01 d0                	add    %edx,%eax
f0110cac:	8b 00                	mov    (%eax),%eax
f0110cae:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0110cb1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110cb4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110cb9:	89 c2                	mov    %eax,%edx
f0110cbb:	8b 45 10             	mov    0x10(%ebp),%eax
f0110cbe:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0110cc1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0110cc4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110cc9:	39 c2                	cmp    %eax,%edx
f0110ccb:	75 08                	jne    f0110cd5 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0110ccd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110cd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0110cd3:	eb 0b                	jmp    f0110ce0 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110cd5:	ff 45 e8             	incl   -0x18(%ebp)
f0110cd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110cdb:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110cde:	7c bd                	jl     f0110c9d <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0110ce0:	83 ec 08             	sub    $0x8,%esp
f0110ce3:	ff 75 ec             	pushl  -0x14(%ebp)
f0110ce6:	68 c8 80 12 f0       	push   $0xf01280c8
f0110ceb:	e8 9b 02 ff ff       	call   f0100f8b <cprintf>
f0110cf0:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0110cf3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110cf6:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110cfc:	85 c0                	test   %eax,%eax
f0110cfe:	74 0e                	je     f0110d0e <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0110d00:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d03:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0110d09:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110d0c:	eb 0c                	jmp    f0110d1a <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110d0e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d11:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110d17:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0110d1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d1d:	8b 00                	mov    (%eax),%eax
f0110d1f:	83 ec 08             	sub    $0x8,%esp
f0110d22:	50                   	push   %eax
f0110d23:	68 e7 80 12 f0       	push   $0xf01280e7
f0110d28:	e8 5e 02 ff ff       	call   f0100f8b <cprintf>
f0110d2d:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110d30:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0110d37:	eb 79                	jmp    f0110db2 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0110d39:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d3c:	8b 00                	mov    (%eax),%eax
f0110d3e:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0110d41:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0110d44:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110d49:	89 c2                	mov    %eax,%edx
f0110d4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110d4e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110d55:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d58:	01 c8                	add    %ecx,%eax
f0110d5a:	8b 00                	mov    (%eax),%eax
f0110d5c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0110d5f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110d62:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110d67:	39 c2                	cmp    %eax,%edx
f0110d69:	74 0c                	je     f0110d77 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f0110d6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110d72:	e9 d9 01 00 00       	jmp    f0110f50 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0110d77:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110d7a:	40                   	inc    %eax
f0110d7b:	89 c2                	mov    %eax,%edx
f0110d7d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110d80:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f0110d86:	89 d0                	mov    %edx,%eax
f0110d88:	ba 00 00 00 00       	mov    $0x0,%edx
f0110d8d:	f7 f1                	div    %ecx
f0110d8f:	89 d0                	mov    %edx,%eax
f0110d91:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0110d94:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110d97:	8b 40 10             	mov    0x10(%eax),%eax
f0110d9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0110d9d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110da1:	75 0c                	jne    f0110daf <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110da3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110da6:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110dac:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110daf:	ff 45 e4             	incl   -0x1c(%ebp)
f0110db2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110db5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110db8:	0f 8c 7b ff ff ff    	jl     f0110d39 <sys_check_WS_list+0x15d>
f0110dbe:	e9 8d 01 00 00       	jmp    f0110f50 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0110dc3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0110dc7:	74 0a                	je     f0110dd3 <sys_check_WS_list+0x1f7>
f0110dc9:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0110dcd:	0f 85 be 00 00 00    	jne    f0110e91 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110dd3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0110dda:	e9 a1 00 00 00       	jmp    f0110e80 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0110ddf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110de6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110de9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110def:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110df2:	eb 47                	jmp    f0110e3b <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110df7:	8b 00                	mov    (%eax),%eax
f0110df9:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0110dfc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110dff:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110e04:	89 c2                	mov    %eax,%edx
f0110e06:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110e09:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110e10:	8b 45 08             	mov    0x8(%ebp),%eax
f0110e13:	01 c8                	add    %ecx,%eax
f0110e15:	8b 00                	mov    (%eax),%eax
f0110e17:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0110e1a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110e1d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110e22:	39 c2                	cmp    %eax,%edx
f0110e24:	75 09                	jne    f0110e2f <sys_check_WS_list+0x253>
				{
					found = 1;
f0110e26:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f0110e2d:	eb 3b                	jmp    f0110e6a <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110e2f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110e32:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110e38:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110e3b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e3f:	74 08                	je     f0110e49 <sys_check_WS_list+0x26d>
f0110e41:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110e44:	8b 40 10             	mov    0x10(%eax),%eax
f0110e47:	eb 05                	jmp    f0110e4e <sys_check_WS_list+0x272>
f0110e49:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e4e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0110e51:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0110e57:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110e5a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110e60:	85 c0                	test   %eax,%eax
f0110e62:	75 90                	jne    f0110df4 <sys_check_WS_list+0x218>
f0110e64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e68:	75 8a                	jne    f0110df4 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f0110e6a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0110e6e:	75 0d                	jne    f0110e7d <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0110e70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110e77:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110e78:	e9 d3 00 00 00       	jmp    f0110f50 <sys_check_WS_list+0x374>
f0110e7d:	ff 45 e0             	incl   -0x20(%ebp)
f0110e80:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110e83:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110e86:	0f 8c 53 ff ff ff    	jl     f0110ddf <sys_check_WS_list+0x203>
f0110e8c:	e9 bf 00 00 00       	jmp    f0110f50 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0110e91:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0110e95:	0f 85 b5 00 00 00    	jne    f0110f50 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110e9b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0110ea2:	e9 9d 00 00 00       	jmp    f0110f44 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f0110ea7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110eae:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110eb1:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110eb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110eba:	eb 47                	jmp    f0110f03 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110ebc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110ebf:	8b 00                	mov    (%eax),%eax
f0110ec1:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0110ec4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110ec7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110ecc:	89 c2                	mov    %eax,%edx
f0110ece:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110ed1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110ed8:	8b 45 08             	mov    0x8(%ebp),%eax
f0110edb:	01 c8                	add    %ecx,%eax
f0110edd:	8b 00                	mov    (%eax),%eax
f0110edf:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0110ee2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0110ee5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110eea:	39 c2                	cmp    %eax,%edx
f0110eec:	75 09                	jne    f0110ef7 <sys_check_WS_list+0x31b>
				{
					found = 1;
f0110eee:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f0110ef5:	eb 3b                	jmp    f0110f32 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110ef7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110efa:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110f00:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110f03:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f07:	74 08                	je     f0110f11 <sys_check_WS_list+0x335>
f0110f09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110f0c:	8b 40 10             	mov    0x10(%eax),%eax
f0110f0f:	eb 05                	jmp    f0110f16 <sys_check_WS_list+0x33a>
f0110f11:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f16:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0110f19:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0110f1f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110f22:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0110f28:	85 c0                	test   %eax,%eax
f0110f2a:	75 90                	jne    f0110ebc <sys_check_WS_list+0x2e0>
f0110f2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f30:	75 8a                	jne    f0110ebc <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f0110f32:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0110f36:	74 09                	je     f0110f41 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0110f38:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110f3f:	eb 0f                	jmp    f0110f50 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110f41:	ff 45 d8             	incl   -0x28(%ebp)
f0110f44:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110f47:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110f4a:	0f 8c 57 ff ff ff    	jl     f0110ea7 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f0110f50:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0110f53:	c9                   	leave  
f0110f54:	c3                   	ret    

f0110f55 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0110f55:	55                   	push   %ebp
f0110f56:	89 e5                	mov    %esp,%ebp
f0110f58:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f0110f5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0110f62:	8b 15 24 da 6b f0    	mov    0xf06bda24,%edx
f0110f68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f6b:	39 c2                	cmp    %eax,%edx
f0110f6d:	74 0a                	je     f0110f79 <hasExpectedCommands+0x24>
		return 0;
f0110f6f:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f74:	e9 8b 00 00 00       	jmp    f0111004 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0110f79:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0110f7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110f81:	eb 55                	jmp    f0110fd8 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110f83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0110f8a:	eb 2a                	jmp    f0110fb6 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0110f8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110f8f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110f96:	8b 45 08             	mov    0x8(%ebp),%eax
f0110f99:	01 d0                	add    %edx,%eax
f0110f9b:	8b 10                	mov    (%eax),%edx
f0110f9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110fa0:	8b 00                	mov    (%eax),%eax
f0110fa2:	83 ec 08             	sub    $0x8,%esp
f0110fa5:	52                   	push   %edx
f0110fa6:	50                   	push   %eax
f0110fa7:	e8 24 e7 00 00       	call   f011f6d0 <strcmp>
f0110fac:	83 c4 10             	add    $0x10,%esp
f0110faf:	85 c0                	test   %eax,%eax
f0110fb1:	74 0d                	je     f0110fc0 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110fb3:	ff 45 f0             	incl   -0x10(%ebp)
f0110fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110fb9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110fbc:	7c ce                	jl     f0110f8c <hasExpectedCommands+0x37>
f0110fbe:	eb 01                	jmp    f0110fc1 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0110fc0:	90                   	nop
		if (i == commandsCount)
f0110fc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110fc4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110fc7:	75 07                	jne    f0110fd0 <hasExpectedCommands+0x7b>
			return 0;
f0110fc9:	b8 00 00 00 00       	mov    $0x0,%eax
f0110fce:	eb 34                	jmp    f0111004 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0110fd0:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0110fd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110fd8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110fdc:	74 08                	je     f0110fe6 <hasExpectedCommands+0x91>
f0110fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110fe1:	8b 40 10             	mov    0x10(%eax),%eax
f0110fe4:	eb 05                	jmp    f0110feb <hasExpectedCommands+0x96>
f0110fe6:	b8 00 00 00 00       	mov    $0x0,%eax
f0110feb:	a3 20 da 6b f0       	mov    %eax,0xf06bda20
f0110ff0:	a1 20 da 6b f0       	mov    0xf06bda20,%eax
f0110ff5:	85 c0                	test   %eax,%eax
f0110ff7:	75 8a                	jne    f0110f83 <hasExpectedCommands+0x2e>
f0110ff9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110ffd:	75 84                	jne    f0110f83 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f0110fff:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111004:	c9                   	leave  
f0111005:	c3                   	ret    

f0111006 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0111006:	55                   	push   %ebp
f0111007:	89 e5                	mov    %esp,%ebp
f0111009:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011100c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111013:	eb 2e                	jmp    f0111043 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0111015:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111018:	89 d0                	mov    %edx,%eax
f011101a:	01 c0                	add    %eax,%eax
f011101c:	01 d0                	add    %edx,%eax
f011101e:	c1 e0 03             	shl    $0x3,%eax
f0111021:	05 40 e5 17 f0       	add    $0xf017e540,%eax
f0111026:	8b 00                	mov    (%eax),%eax
f0111028:	83 ec 08             	sub    $0x8,%esp
f011102b:	ff 75 08             	pushl  0x8(%ebp)
f011102e:	50                   	push   %eax
f011102f:	e8 9c e6 00 00       	call   f011f6d0 <strcmp>
f0111034:	83 c4 10             	add    $0x10,%esp
f0111037:	85 c0                	test   %eax,%eax
f0111039:	75 05                	jne    f0111040 <getIndexOfCommand+0x3a>
			return i;
f011103b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011103e:	eb 14                	jmp    f0111054 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111040:	ff 45 f4             	incl   -0xc(%ebp)
f0111043:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111046:	a1 48 e9 17 f0       	mov    0xf017e948,%eax
f011104b:	39 c2                	cmp    %eax,%edx
f011104d:	72 c6                	jb     f0111015 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f011104f:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111054:	c9                   	leave  
f0111055:	c3                   	ret    

f0111056 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111056:	55                   	push   %ebp
f0111057:	89 e5                	mov    %esp,%ebp
f0111059:	57                   	push   %edi
f011105a:	56                   	push   %esi
f011105b:	53                   	push   %ebx
f011105c:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111062:	83 ec 0c             	sub    $0xc,%esp
f0111065:	68 20 81 12 f0       	push   $0xf0128120
f011106a:	e8 1c ff fe ff       	call   f0100f8b <cprintf>
f011106f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111072:	83 ec 0c             	sub    $0xc,%esp
f0111075:	68 44 81 12 f0       	push   $0xf0128144
f011107a:	e8 0c ff fe ff       	call   f0100f8b <cprintf>
f011107f:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111082:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0111089:	c7 45 8c 5f 81 12 f0 	movl   $0xf012815f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111090:	83 ec 08             	sub    $0x8,%esp
f0111093:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0111096:	50                   	push   %eax
f0111097:	6a 01                	push   $0x1
f0111099:	e8 32 11 ff ff       	call   f01021d0 <process_command>
f011109e:	83 c4 10             	add    $0x10,%esp
f01110a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01110a4:	83 ec 0c             	sub    $0xc,%esp
f01110a7:	68 6c 81 12 f0       	push   $0xf012816c
f01110ac:	e8 da fe fe ff       	call   f0100f8b <cprintf>
f01110b1:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f01110b4:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01110b7:	83 ec 0c             	sub    $0xc,%esp
f01110ba:	50                   	push   %eax
f01110bb:	e8 46 ff ff ff       	call   f0111006 <getIndexOfCommand>
f01110c0:	83 c4 10             	add    $0x10,%esp
f01110c3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01110c6:	75 0f                	jne    f01110d7 <TestAutoCompleteCommand+0x81>
f01110c8:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f01110cd:	85 c0                	test   %eax,%eax
f01110cf:	75 06                	jne    f01110d7 <TestAutoCompleteCommand+0x81>
		eval += 15;
f01110d1:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01110d5:	eb 10                	jmp    f01110e7 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01110d7:	83 ec 0c             	sub    $0xc,%esp
f01110da:	68 9c 81 12 f0       	push   $0xf012819c
f01110df:	e8 a7 fe fe ff       	call   f0100f8b <cprintf>
f01110e4:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01110e7:	83 ec 0c             	sub    $0xc,%esp
f01110ea:	68 ec 81 12 f0       	push   $0xf01281ec
f01110ef:	e8 97 fe fe ff       	call   f0100f8b <cprintf>
f01110f4:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01110f7:	c7 45 88 12 82 12 f0 	movl   $0xf0128212,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01110fe:	83 ec 08             	sub    $0x8,%esp
f0111101:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111104:	50                   	push   %eax
f0111105:	6a 01                	push   $0x1
f0111107:	e8 c4 10 ff ff       	call   f01021d0 <process_command>
f011110c:	83 c4 10             	add    $0x10,%esp
f011110f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111112:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111116:	75 30                	jne    f0111148 <TestAutoCompleteCommand+0xf2>
f0111118:	8d 45 90             	lea    -0x70(%ebp),%eax
f011111b:	bb f0 85 12 f0       	mov    $0xf01285f0,%ebx
f0111120:	ba 03 00 00 00       	mov    $0x3,%edx
f0111125:	89 c7                	mov    %eax,%edi
f0111127:	89 de                	mov    %ebx,%esi
f0111129:	89 d1                	mov    %edx,%ecx
f011112b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011112d:	83 ec 08             	sub    $0x8,%esp
f0111130:	6a 03                	push   $0x3
f0111132:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111135:	50                   	push   %eax
f0111136:	e8 1a fe ff ff       	call   f0110f55 <hasExpectedCommands>
f011113b:	83 c4 10             	add    $0x10,%esp
f011113e:	85 c0                	test   %eax,%eax
f0111140:	74 06                	je     f0111148 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111142:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111146:	eb 10                	jmp    f0111158 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111148:	83 ec 0c             	sub    $0xc,%esp
f011114b:	68 18 82 12 f0       	push   $0xf0128218
f0111150:	e8 36 fe fe ff       	call   f0100f8b <cprintf>
f0111155:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111158:	83 ec 0c             	sub    $0xc,%esp
f011115b:	68 68 82 12 f0       	push   $0xf0128268
f0111160:	e8 26 fe fe ff       	call   f0100f8b <cprintf>
f0111165:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111168:	c7 45 84 8d 82 12 f0 	movl   $0xf012828d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f011116f:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111172:	83 ec 04             	sub    $0x4,%esp
f0111175:	50                   	push   %eax
f0111176:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111179:	50                   	push   %eax
f011117a:	68 90 82 12 f0       	push   $0xf0128290
f011117f:	e8 07 fe fe ff       	call   f0100f8b <cprintf>
f0111184:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111187:	83 ec 08             	sub    $0x8,%esp
f011118a:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011118d:	50                   	push   %eax
f011118e:	6a 01                	push   $0x1
f0111190:	e8 3b 10 ff ff       	call   f01021d0 <process_command>
f0111195:	83 c4 10             	add    $0x10,%esp
f0111198:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f011119b:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f011119f:	75 1b                	jne    f01111bc <TestAutoCompleteCommand+0x166>
f01111a1:	83 ec 08             	sub    $0x8,%esp
f01111a4:	6a 01                	push   $0x1
f01111a6:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01111a9:	50                   	push   %eax
f01111aa:	e8 a6 fd ff ff       	call   f0110f55 <hasExpectedCommands>
f01111af:	83 c4 10             	add    $0x10,%esp
f01111b2:	85 c0                	test   %eax,%eax
f01111b4:	74 06                	je     f01111bc <TestAutoCompleteCommand+0x166>
		eval += 15;
f01111b6:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01111ba:	eb 10                	jmp    f01111cc <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01111bc:	83 ec 0c             	sub    $0xc,%esp
f01111bf:	68 b0 82 12 f0       	push   $0xf01282b0
f01111c4:	e8 c2 fd fe ff       	call   f0100f8b <cprintf>
f01111c9:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01111cc:	83 ec 0c             	sub    $0xc,%esp
f01111cf:	68 08 83 12 f0       	push   $0xf0128308
f01111d4:	e8 b2 fd fe ff       	call   f0100f8b <cprintf>
f01111d9:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01111dc:	c7 45 80 2e 83 12 f0 	movl   $0xf012832e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01111e3:	83 ec 08             	sub    $0x8,%esp
f01111e6:	8d 45 80             	lea    -0x80(%ebp),%eax
f01111e9:	50                   	push   %eax
f01111ea:	6a 01                	push   $0x1
f01111ec:	e8 df 0f ff ff       	call   f01021d0 <process_command>
f01111f1:	83 c4 10             	add    $0x10,%esp
f01111f4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f01111f7:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f01111fb:	75 0f                	jne    f011120c <TestAutoCompleteCommand+0x1b6>
f01111fd:	a1 24 da 6b f0       	mov    0xf06bda24,%eax
f0111202:	85 c0                	test   %eax,%eax
f0111204:	75 06                	jne    f011120c <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111206:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011120a:	eb 10                	jmp    f011121c <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011120c:	83 ec 0c             	sub    $0xc,%esp
f011120f:	68 34 83 12 f0       	push   $0xf0128334
f0111214:	e8 72 fd fe ff       	call   f0100f8b <cprintf>
f0111219:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f011121c:	83 ec 0c             	sub    $0xc,%esp
f011121f:	68 84 83 12 f0       	push   $0xf0128384
f0111224:	e8 62 fd fe ff       	call   f0100f8b <cprintf>
f0111229:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011122c:	c7 85 7c ff ff ff a9 	movl   $0xf01283a9,-0x84(%ebp)
f0111233:	83 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111236:	83 ec 08             	sub    $0x8,%esp
f0111239:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011123f:	50                   	push   %eax
f0111240:	6a 01                	push   $0x1
f0111242:	e8 89 0f ff ff       	call   f01021d0 <process_command>
f0111247:	83 c4 10             	add    $0x10,%esp
f011124a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011124d:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111251:	75 30                	jne    f0111283 <TestAutoCompleteCommand+0x22d>
f0111253:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111256:	bb 80 86 12 f0       	mov    $0xf0128680,%ebx
f011125b:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111260:	89 c7                	mov    %eax,%edi
f0111262:	89 de                	mov    %ebx,%esi
f0111264:	89 d1                	mov    %edx,%ecx
f0111266:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111268:	83 ec 08             	sub    $0x8,%esp
f011126b:	6a 0c                	push   $0xc
f011126d:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111270:	50                   	push   %eax
f0111271:	e8 df fc ff ff       	call   f0110f55 <hasExpectedCommands>
f0111276:	83 c4 10             	add    $0x10,%esp
f0111279:	85 c0                	test   %eax,%eax
f011127b:	74 06                	je     f0111283 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f011127d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111281:	eb 10                	jmp    f0111293 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111283:	83 ec 0c             	sub    $0xc,%esp
f0111286:	68 ac 83 12 f0       	push   $0xf01283ac
f011128b:	e8 fb fc fe ff       	call   f0100f8b <cprintf>
f0111290:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111293:	83 ec 0c             	sub    $0xc,%esp
f0111296:	68 04 84 12 f0       	push   $0xf0128404
f011129b:	e8 eb fc fe ff       	call   f0100f8b <cprintf>
f01112a0:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01112a3:	c7 85 78 ff ff ff 29 	movl   $0xf0128429,-0x88(%ebp)
f01112aa:	84 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01112ad:	83 ec 08             	sub    $0x8,%esp
f01112b0:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01112b6:	50                   	push   %eax
f01112b7:	6a 01                	push   $0x1
f01112b9:	e8 12 0f ff ff       	call   f01021d0 <process_command>
f01112be:	83 c4 10             	add    $0x10,%esp
f01112c1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01112c4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01112c8:	75 30                	jne    f01112fa <TestAutoCompleteCommand+0x2a4>
f01112ca:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01112cd:	bb c8 86 12 f0       	mov    $0xf01286c8,%ebx
f01112d2:	ba 05 00 00 00       	mov    $0x5,%edx
f01112d7:	89 c7                	mov    %eax,%edi
f01112d9:	89 de                	mov    %ebx,%esi
f01112db:	89 d1                	mov    %edx,%ecx
f01112dd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01112df:	83 ec 08             	sub    $0x8,%esp
f01112e2:	6a 05                	push   $0x5
f01112e4:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01112e7:	50                   	push   %eax
f01112e8:	e8 68 fc ff ff       	call   f0110f55 <hasExpectedCommands>
f01112ed:	83 c4 10             	add    $0x10,%esp
f01112f0:	85 c0                	test   %eax,%eax
f01112f2:	74 06                	je     f01112fa <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f01112f4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01112f8:	eb 10                	jmp    f011130a <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f01112fa:	83 ec 0c             	sub    $0xc,%esp
f01112fd:	68 2c 84 12 f0       	push   $0xf012842c
f0111302:	e8 84 fc fe ff       	call   f0100f8b <cprintf>
f0111307:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f011130a:	83 ec 0c             	sub    $0xc,%esp
f011130d:	68 84 84 12 f0       	push   $0xf0128484
f0111312:	e8 74 fc fe ff       	call   f0100f8b <cprintf>
f0111317:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f011131a:	c7 85 70 ff ff ff b0 	movl   $0xf01284b0,-0x90(%ebp)
f0111321:	84 12 f0 
f0111324:	c7 85 74 ff ff ff b5 	movl   $0xf01284b5,-0x8c(%ebp)
f011132b:	84 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f011132e:	83 ec 08             	sub    $0x8,%esp
f0111331:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111337:	50                   	push   %eax
f0111338:	6a 02                	push   $0x2
f011133a:	e8 91 0e ff ff       	call   f01021d0 <process_command>
f011133f:	83 c4 10             	add    $0x10,%esp
f0111342:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111345:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011134b:	83 ec 0c             	sub    $0xc,%esp
f011134e:	50                   	push   %eax
f011134f:	e8 b2 fc ff ff       	call   f0111006 <getIndexOfCommand>
f0111354:	83 c4 10             	add    $0x10,%esp
f0111357:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011135a:	75 0f                	jne    f011136b <TestAutoCompleteCommand+0x315>
f011135c:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f0111361:	85 c0                	test   %eax,%eax
f0111363:	75 06                	jne    f011136b <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111365:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111369:	eb 10                	jmp    f011137b <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011136b:	83 ec 0c             	sub    $0xc,%esp
f011136e:	68 bc 84 12 f0       	push   $0xf01284bc
f0111373:	e8 13 fc fe ff       	call   f0100f8b <cprintf>
f0111378:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f011137b:	83 ec 0c             	sub    $0xc,%esp
f011137e:	68 0c 85 12 f0       	push   $0xf012850c
f0111383:	e8 03 fc fe ff       	call   f0100f8b <cprintf>
f0111388:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f011138b:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111391:	bb f0 86 12 f0       	mov    $0xf01286f0,%ebx
f0111396:	ba 03 00 00 00       	mov    $0x3,%edx
f011139b:	89 c7                	mov    %eax,%edi
f011139d:	89 de                	mov    %ebx,%esi
f011139f:	89 d1                	mov    %edx,%ecx
f01113a1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01113a3:	83 ec 08             	sub    $0x8,%esp
f01113a6:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01113ac:	50                   	push   %eax
f01113ad:	6a 03                	push   $0x3
f01113af:	e8 1c 0e ff ff       	call   f01021d0 <process_command>
f01113b4:	83 c4 10             	add    $0x10,%esp
f01113b7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f01113ba:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f01113c0:	83 ec 0c             	sub    $0xc,%esp
f01113c3:	50                   	push   %eax
f01113c4:	e8 3d fc ff ff       	call   f0111006 <getIndexOfCommand>
f01113c9:	83 c4 10             	add    $0x10,%esp
f01113cc:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01113cf:	75 0f                	jne    f01113e0 <TestAutoCompleteCommand+0x38a>
f01113d1:	a1 18 da 6b f0       	mov    0xf06bda18,%eax
f01113d6:	85 c0                	test   %eax,%eax
f01113d8:	75 06                	jne    f01113e0 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f01113da:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01113de:	eb 10                	jmp    f01113f0 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01113e0:	83 ec 0c             	sub    $0xc,%esp
f01113e3:	68 40 85 12 f0       	push   $0xf0128540
f01113e8:	e8 9e fb fe ff       	call   f0100f8b <cprintf>
f01113ed:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f01113f0:	83 ec 08             	sub    $0x8,%esp
f01113f3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01113f6:	68 90 85 12 f0       	push   $0xf0128590
f01113fb:	e8 8b fb fe ff       	call   f0100f8b <cprintf>
f0111400:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111403:	83 ec 0c             	sub    $0xc,%esp
f0111406:	68 c0 85 12 f0       	push   $0xf01285c0
f011140b:	e8 7b fb fe ff       	call   f0100f8b <cprintf>
f0111410:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111413:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111418:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011141b:	5b                   	pop    %ebx
f011141c:	5e                   	pop    %esi
f011141d:	5f                   	pop    %edi
f011141e:	5d                   	pop    %ebp
f011141f:	c3                   	ret    

f0111420 <test_str2lower_function>:

int test_str2lower_function()
{
f0111420:	55                   	push   %ebp
f0111421:	89 e5                	mov    %esp,%ebp
f0111423:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111429:	83 ec 0c             	sub    $0xc,%esp
f011142c:	68 fc 86 12 f0       	push   $0xf01286fc
f0111431:	e8 55 fb fe ff       	call   f0100f8b <cprintf>
f0111436:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111439:	83 ec 0c             	sub    $0xc,%esp
f011143c:	68 1d 87 12 f0       	push   $0xf012871d
f0111441:	e8 45 fb fe ff       	call   f0100f8b <cprintf>
f0111446:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111449:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111450:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111457:	c7 45 ec 37 87 12 f0 	movl   $0xf0128737,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f011145e:	83 ec 08             	sub    $0x8,%esp
f0111461:	ff 75 ec             	pushl  -0x14(%ebp)
f0111464:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f011146a:	50                   	push   %eax
f011146b:	e8 3d e8 00 00       	call   f011fcad <str2lower>
f0111470:	83 c4 10             	add    $0x10,%esp
f0111473:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111476:	83 ec 0c             	sub    $0xc,%esp
f0111479:	ff 75 e8             	pushl  -0x18(%ebp)
f011147c:	e8 43 e1 00 00       	call   f011f5c4 <strlen>
f0111481:	83 c4 10             	add    $0x10,%esp
f0111484:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111487:	83 ec 08             	sub    $0x8,%esp
f011148a:	68 42 87 12 f0       	push   $0xf0128742
f011148f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111492:	e8 39 e2 00 00       	call   f011f6d0 <strcmp>
f0111497:	83 c4 10             	add    $0x10,%esp
f011149a:	85 c0                	test   %eax,%eax
f011149c:	75 13                	jne    f01114b1 <test_str2lower_function+0x91>
f011149e:	83 ec 0c             	sub    $0xc,%esp
f01114a1:	ff 75 ec             	pushl  -0x14(%ebp)
f01114a4:	e8 1b e1 00 00       	call   f011f5c4 <strlen>
f01114a9:	83 c4 10             	add    $0x10,%esp
f01114ac:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01114af:	74 15                	je     f01114c6 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f01114b1:	83 ec 08             	sub    $0x8,%esp
f01114b4:	ff 75 e8             	pushl  -0x18(%ebp)
f01114b7:	68 50 87 12 f0       	push   $0xf0128750
f01114bc:	e8 ca fa fe ff       	call   f0100f8b <cprintf>
f01114c1:	83 c4 10             	add    $0x10,%esp
f01114c4:	eb 04                	jmp    f01114ca <test_str2lower_function+0xaa>
	else
		eval += 10;
f01114c6:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f01114ca:	c7 45 e0 b2 87 12 f0 	movl   $0xf01287b2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f01114d1:	83 ec 08             	sub    $0x8,%esp
f01114d4:	ff 75 e0             	pushl  -0x20(%ebp)
f01114d7:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01114dd:	50                   	push   %eax
f01114de:	e8 ca e7 00 00       	call   f011fcad <str2lower>
f01114e3:	83 c4 10             	add    $0x10,%esp
f01114e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01114e9:	83 ec 0c             	sub    $0xc,%esp
f01114ec:	ff 75 e8             	pushl  -0x18(%ebp)
f01114ef:	e8 d0 e0 00 00       	call   f011f5c4 <strlen>
f01114f4:	83 c4 10             	add    $0x10,%esp
f01114f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f01114fa:	83 ec 08             	sub    $0x8,%esp
f01114fd:	68 b2 87 12 f0       	push   $0xf01287b2
f0111502:	ff 75 e8             	pushl  -0x18(%ebp)
f0111505:	e8 c6 e1 00 00       	call   f011f6d0 <strcmp>
f011150a:	83 c4 10             	add    $0x10,%esp
f011150d:	85 c0                	test   %eax,%eax
f011150f:	75 13                	jne    f0111524 <test_str2lower_function+0x104>
f0111511:	83 ec 0c             	sub    $0xc,%esp
f0111514:	ff 75 e0             	pushl  -0x20(%ebp)
f0111517:	e8 a8 e0 00 00       	call   f011f5c4 <strlen>
f011151c:	83 c4 10             	add    $0x10,%esp
f011151f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111522:	74 15                	je     f0111539 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111524:	83 ec 08             	sub    $0x8,%esp
f0111527:	ff 75 e8             	pushl  -0x18(%ebp)
f011152a:	68 b4 87 12 f0       	push   $0xf01287b4
f011152f:	e8 57 fa fe ff       	call   f0100f8b <cprintf>
f0111534:	83 c4 10             	add    $0x10,%esp
f0111537:	eb 04                	jmp    f011153d <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111539:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f011153d:	c7 45 dc 0c 88 12 f0 	movl   $0xf012880c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111544:	83 ec 08             	sub    $0x8,%esp
f0111547:	ff 75 dc             	pushl  -0x24(%ebp)
f011154a:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111550:	50                   	push   %eax
f0111551:	e8 57 e7 00 00       	call   f011fcad <str2lower>
f0111556:	83 c4 10             	add    $0x10,%esp
f0111559:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011155c:	83 ec 0c             	sub    $0xc,%esp
f011155f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111562:	e8 5d e0 00 00       	call   f011f5c4 <strlen>
f0111567:	83 c4 10             	add    $0x10,%esp
f011156a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f011156d:	83 ec 08             	sub    $0x8,%esp
f0111570:	68 0c 88 12 f0       	push   $0xf012880c
f0111575:	ff 75 e8             	pushl  -0x18(%ebp)
f0111578:	e8 53 e1 00 00       	call   f011f6d0 <strcmp>
f011157d:	83 c4 10             	add    $0x10,%esp
f0111580:	85 c0                	test   %eax,%eax
f0111582:	75 13                	jne    f0111597 <test_str2lower_function+0x177>
f0111584:	83 ec 0c             	sub    $0xc,%esp
f0111587:	ff 75 dc             	pushl  -0x24(%ebp)
f011158a:	e8 35 e0 00 00       	call   f011f5c4 <strlen>
f011158f:	83 c4 10             	add    $0x10,%esp
f0111592:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111595:	74 15                	je     f01115ac <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111597:	83 ec 08             	sub    $0x8,%esp
f011159a:	ff 75 e8             	pushl  -0x18(%ebp)
f011159d:	68 18 88 12 f0       	push   $0xf0128818
f01115a2:	e8 e4 f9 fe ff       	call   f0100f8b <cprintf>
f01115a7:	83 c4 10             	add    $0x10,%esp
f01115aa:	eb 04                	jmp    f01115b0 <test_str2lower_function+0x190>
	else
		eval += 15;
f01115ac:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f01115b0:	c7 45 d8 7b 88 12 f0 	movl   $0xf012887b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f01115b7:	83 ec 08             	sub    $0x8,%esp
f01115ba:	ff 75 d8             	pushl  -0x28(%ebp)
f01115bd:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f01115c3:	50                   	push   %eax
f01115c4:	e8 e4 e6 00 00       	call   f011fcad <str2lower>
f01115c9:	83 c4 10             	add    $0x10,%esp
f01115cc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01115cf:	83 ec 0c             	sub    $0xc,%esp
f01115d2:	ff 75 e8             	pushl  -0x18(%ebp)
f01115d5:	e8 ea df 00 00       	call   f011f5c4 <strlen>
f01115da:	83 c4 10             	add    $0x10,%esp
f01115dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f01115e0:	83 ec 08             	sub    $0x8,%esp
f01115e3:	68 7b 88 12 f0       	push   $0xf012887b
f01115e8:	ff 75 e8             	pushl  -0x18(%ebp)
f01115eb:	e8 e0 e0 00 00       	call   f011f6d0 <strcmp>
f01115f0:	83 c4 10             	add    $0x10,%esp
f01115f3:	85 c0                	test   %eax,%eax
f01115f5:	75 13                	jne    f011160a <test_str2lower_function+0x1ea>
f01115f7:	83 ec 0c             	sub    $0xc,%esp
f01115fa:	ff 75 d8             	pushl  -0x28(%ebp)
f01115fd:	e8 c2 df 00 00       	call   f011f5c4 <strlen>
f0111602:	83 c4 10             	add    $0x10,%esp
f0111605:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111608:	74 15                	je     f011161f <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f011160a:	83 ec 08             	sub    $0x8,%esp
f011160d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111610:	68 88 88 12 f0       	push   $0xf0128888
f0111615:	e8 71 f9 fe ff       	call   f0100f8b <cprintf>
f011161a:	83 c4 10             	add    $0x10,%esp
f011161d:	eb 04                	jmp    f0111623 <test_str2lower_function+0x203>
	else
		eval += 15;
f011161f:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111623:	c7 45 d4 ea 88 12 f0 	movl   $0xf01288ea,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f011162a:	83 ec 08             	sub    $0x8,%esp
f011162d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111630:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111636:	50                   	push   %eax
f0111637:	e8 71 e6 00 00       	call   f011fcad <str2lower>
f011163c:	83 c4 10             	add    $0x10,%esp
f011163f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111642:	83 ec 0c             	sub    $0xc,%esp
f0111645:	ff 75 e8             	pushl  -0x18(%ebp)
f0111648:	e8 77 df 00 00       	call   f011f5c4 <strlen>
f011164d:	83 c4 10             	add    $0x10,%esp
f0111650:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111653:	83 ec 08             	sub    $0x8,%esp
f0111656:	68 00 89 12 f0       	push   $0xf0128900
f011165b:	ff 75 e8             	pushl  -0x18(%ebp)
f011165e:	e8 6d e0 00 00       	call   f011f6d0 <strcmp>
f0111663:	83 c4 10             	add    $0x10,%esp
f0111666:	85 c0                	test   %eax,%eax
f0111668:	75 13                	jne    f011167d <test_str2lower_function+0x25d>
f011166a:	83 ec 0c             	sub    $0xc,%esp
f011166d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111670:	e8 4f df 00 00       	call   f011f5c4 <strlen>
f0111675:	83 c4 10             	add    $0x10,%esp
f0111678:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011167b:	74 15                	je     f0111692 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f011167d:	83 ec 08             	sub    $0x8,%esp
f0111680:	ff 75 e8             	pushl  -0x18(%ebp)
f0111683:	68 18 89 12 f0       	push   $0xf0128918
f0111688:	e8 fe f8 fe ff       	call   f0100f8b <cprintf>
f011168d:	83 c4 10             	add    $0x10,%esp
f0111690:	eb 04                	jmp    f0111696 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111692:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111696:	c7 45 d0 85 89 12 f0 	movl   $0xf0128985,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f011169d:	83 ec 08             	sub    $0x8,%esp
f01116a0:	ff 75 d0             	pushl  -0x30(%ebp)
f01116a3:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f01116a9:	50                   	push   %eax
f01116aa:	e8 fe e5 00 00       	call   f011fcad <str2lower>
f01116af:	83 c4 10             	add    $0x10,%esp
f01116b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01116b5:	83 ec 0c             	sub    $0xc,%esp
f01116b8:	ff 75 e8             	pushl  -0x18(%ebp)
f01116bb:	e8 04 df 00 00       	call   f011f5c4 <strlen>
f01116c0:	83 c4 10             	add    $0x10,%esp
f01116c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f01116c6:	83 ec 08             	sub    $0x8,%esp
f01116c9:	68 91 89 12 f0       	push   $0xf0128991
f01116ce:	ff 75 e8             	pushl  -0x18(%ebp)
f01116d1:	e8 fa df 00 00       	call   f011f6d0 <strcmp>
f01116d6:	83 c4 10             	add    $0x10,%esp
f01116d9:	85 c0                	test   %eax,%eax
f01116db:	75 13                	jne    f01116f0 <test_str2lower_function+0x2d0>
f01116dd:	83 ec 0c             	sub    $0xc,%esp
f01116e0:	ff 75 d0             	pushl  -0x30(%ebp)
f01116e3:	e8 dc de 00 00       	call   f011f5c4 <strlen>
f01116e8:	83 c4 10             	add    $0x10,%esp
f01116eb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01116ee:	74 15                	je     f0111705 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f01116f0:	83 ec 08             	sub    $0x8,%esp
f01116f3:	ff 75 e8             	pushl  -0x18(%ebp)
f01116f6:	68 a0 89 12 f0       	push   $0xf01289a0
f01116fb:	e8 8b f8 fe ff       	call   f0100f8b <cprintf>
f0111700:	83 c4 10             	add    $0x10,%esp
f0111703:	eb 04                	jmp    f0111709 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111705:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111709:	c7 45 cc 03 8a 12 f0 	movl   $0xf0128a03,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111710:	83 ec 08             	sub    $0x8,%esp
f0111713:	ff 75 cc             	pushl  -0x34(%ebp)
f0111716:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f011171c:	50                   	push   %eax
f011171d:	e8 8b e5 00 00       	call   f011fcad <str2lower>
f0111722:	83 c4 10             	add    $0x10,%esp
f0111725:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111728:	83 ec 0c             	sub    $0xc,%esp
f011172b:	ff 75 e8             	pushl  -0x18(%ebp)
f011172e:	e8 91 de 00 00       	call   f011f5c4 <strlen>
f0111733:	83 c4 10             	add    $0x10,%esp
f0111736:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111739:	83 ec 08             	sub    $0x8,%esp
f011173c:	68 1e 8a 12 f0       	push   $0xf0128a1e
f0111741:	ff 75 e8             	pushl  -0x18(%ebp)
f0111744:	e8 87 df 00 00       	call   f011f6d0 <strcmp>
f0111749:	83 c4 10             	add    $0x10,%esp
f011174c:	85 c0                	test   %eax,%eax
f011174e:	75 13                	jne    f0111763 <test_str2lower_function+0x343>
f0111750:	83 ec 0c             	sub    $0xc,%esp
f0111753:	ff 75 cc             	pushl  -0x34(%ebp)
f0111756:	e8 69 de 00 00       	call   f011f5c4 <strlen>
f011175b:	83 c4 10             	add    $0x10,%esp
f011175e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111761:	74 15                	je     f0111778 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111763:	83 ec 08             	sub    $0x8,%esp
f0111766:	ff 75 e8             	pushl  -0x18(%ebp)
f0111769:	68 3c 8a 12 f0       	push   $0xf0128a3c
f011176e:	e8 18 f8 fe ff       	call   f0100f8b <cprintf>
f0111773:	83 c4 10             	add    $0x10,%esp
f0111776:	eb 04                	jmp    f011177c <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111778:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f011177c:	83 ec 08             	sub    $0x8,%esp
f011177f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111782:	68 b0 8a 12 f0       	push   $0xf0128ab0
f0111787:	e8 ff f7 fe ff       	call   f0100f8b <cprintf>
f011178c:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f011178f:	83 ec 0c             	sub    $0xc,%esp
f0111792:	68 c0 85 12 f0       	push   $0xf01285c0
f0111797:	e8 ef f7 fe ff       	call   f0100f8b <cprintf>
f011179c:	83 c4 10             	add    $0x10,%esp
	return 0;
f011179f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01117a4:	c9                   	leave  
f01117a5:	c3                   	ret    

f01117a6 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f01117a6:	55                   	push   %ebp
f01117a7:	89 e5                	mov    %esp,%ebp
f01117a9:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f01117ac:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f01117b3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f01117ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01117c1:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01117c6:	ff 75 ec             	pushl  -0x14(%ebp)
f01117c9:	ff 75 f0             	pushl  -0x10(%ebp)
f01117cc:	ff 75 f4             	pushl  -0xc(%ebp)
f01117cf:	50                   	push   %eax
f01117d0:	e8 f3 7d ff ff       	call   f01095c8 <pt_set_page_permissions>
f01117d5:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01117d8:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01117dd:	ff 75 ec             	pushl  -0x14(%ebp)
f01117e0:	ff 75 f0             	pushl  -0x10(%ebp)
f01117e3:	ff 75 f4             	pushl  -0xc(%ebp)
f01117e6:	50                   	push   %eax
f01117e7:	e8 74 4b 00 00       	call   f0116360 <CP>
f01117ec:	83 c4 10             	add    $0x10,%esp
f01117ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01117f2:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01117f6:	74 17                	je     f011180f <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f01117f8:	83 ec 04             	sub    $0x4,%esp
f01117fb:	68 e0 8a 12 f0       	push   $0xf0128ae0
f0111800:	68 23 01 00 00       	push   $0x123
f0111805:	68 02 8b 12 f0       	push   $0xf0128b02
f011180a:	e8 2a eb fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f011180f:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111816:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f011181d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111824:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111829:	ff 75 ec             	pushl  -0x14(%ebp)
f011182c:	ff 75 f0             	pushl  -0x10(%ebp)
f011182f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111832:	50                   	push   %eax
f0111833:	e8 90 7d ff ff       	call   f01095c8 <pt_set_page_permissions>
f0111838:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011183b:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111840:	ff 75 ec             	pushl  -0x14(%ebp)
f0111843:	ff 75 f0             	pushl  -0x10(%ebp)
f0111846:	ff 75 f4             	pushl  -0xc(%ebp)
f0111849:	50                   	push   %eax
f011184a:	e8 11 4b 00 00       	call   f0116360 <CP>
f011184f:	83 c4 10             	add    $0x10,%esp
f0111852:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111855:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111859:	74 17                	je     f0111872 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f011185b:	83 ec 04             	sub    $0x4,%esp
f011185e:	68 20 8b 12 f0       	push   $0xf0128b20
f0111863:	68 2f 01 00 00       	push   $0x12f
f0111868:	68 02 8b 12 f0       	push   $0xf0128b02
f011186d:	e8 c7 ea fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111872:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0111879:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111880:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111887:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011188c:	ff 75 ec             	pushl  -0x14(%ebp)
f011188f:	ff 75 f0             	pushl  -0x10(%ebp)
f0111892:	ff 75 f4             	pushl  -0xc(%ebp)
f0111895:	50                   	push   %eax
f0111896:	e8 2d 7d ff ff       	call   f01095c8 <pt_set_page_permissions>
f011189b:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011189e:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01118a3:	ff 75 ec             	pushl  -0x14(%ebp)
f01118a6:	ff 75 f0             	pushl  -0x10(%ebp)
f01118a9:	ff 75 f4             	pushl  -0xc(%ebp)
f01118ac:	50                   	push   %eax
f01118ad:	e8 ae 4a 00 00       	call   f0116360 <CP>
f01118b2:	83 c4 10             	add    $0x10,%esp
f01118b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01118b8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01118bc:	74 17                	je     f01118d5 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f01118be:	83 ec 04             	sub    $0x4,%esp
f01118c1:	68 44 8b 12 f0       	push   $0xf0128b44
f01118c6:	68 3a 01 00 00       	push   $0x13a
f01118cb:	68 02 8b 12 f0       	push   $0xf0128b02
f01118d0:	e8 64 ea fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f01118d5:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f01118dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f01118e3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01118ea:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01118ef:	ff 75 ec             	pushl  -0x14(%ebp)
f01118f2:	ff 75 f0             	pushl  -0x10(%ebp)
f01118f5:	ff 75 f4             	pushl  -0xc(%ebp)
f01118f8:	50                   	push   %eax
f01118f9:	e8 ca 7c ff ff       	call   f01095c8 <pt_set_page_permissions>
f01118fe:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111901:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111906:	ff 75 ec             	pushl  -0x14(%ebp)
f0111909:	ff 75 f0             	pushl  -0x10(%ebp)
f011190c:	ff 75 f4             	pushl  -0xc(%ebp)
f011190f:	50                   	push   %eax
f0111910:	e8 4b 4a 00 00       	call   f0116360 <CP>
f0111915:	83 c4 10             	add    $0x10,%esp
f0111918:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011191b:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011191f:	74 17                	je     f0111938 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111921:	83 ec 04             	sub    $0x4,%esp
f0111924:	68 68 8b 12 f0       	push   $0xf0128b68
f0111929:	68 46 01 00 00       	push   $0x146
f011192e:	68 02 8b 12 f0       	push   $0xf0128b02
f0111933:	e8 01 ea fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0111938:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f011193f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0111946:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011194d:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111952:	ff 75 ec             	pushl  -0x14(%ebp)
f0111955:	ff 75 f0             	pushl  -0x10(%ebp)
f0111958:	ff 75 f4             	pushl  -0xc(%ebp)
f011195b:	50                   	push   %eax
f011195c:	e8 67 7c ff ff       	call   f01095c8 <pt_set_page_permissions>
f0111961:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111964:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111969:	ff 75 ec             	pushl  -0x14(%ebp)
f011196c:	ff 75 f0             	pushl  -0x10(%ebp)
f011196f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111972:	50                   	push   %eax
f0111973:	e8 e8 49 00 00       	call   f0116360 <CP>
f0111978:	83 c4 10             	add    $0x10,%esp
f011197b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011197e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111982:	74 17                	je     f011199b <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0111984:	83 ec 04             	sub    $0x4,%esp
f0111987:	68 8c 8b 12 f0       	push   $0xf0128b8c
f011198c:	68 52 01 00 00       	push   $0x152
f0111991:	68 02 8b 12 f0       	push   $0xf0128b02
f0111996:	e8 9e e9 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f011199b:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01119a2:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f01119a9:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01119b0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01119b5:	ff 75 ec             	pushl  -0x14(%ebp)
f01119b8:	ff 75 f0             	pushl  -0x10(%ebp)
f01119bb:	ff 75 f4             	pushl  -0xc(%ebp)
f01119be:	50                   	push   %eax
f01119bf:	e8 04 7c ff ff       	call   f01095c8 <pt_set_page_permissions>
f01119c4:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01119c7:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f01119cc:	ff 75 ec             	pushl  -0x14(%ebp)
f01119cf:	ff 75 f0             	pushl  -0x10(%ebp)
f01119d2:	ff 75 f4             	pushl  -0xc(%ebp)
f01119d5:	50                   	push   %eax
f01119d6:	e8 85 49 00 00       	call   f0116360 <CP>
f01119db:	83 c4 10             	add    $0x10,%esp
f01119de:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01119e1:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01119e5:	74 17                	je     f01119fe <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01119e7:	83 ec 04             	sub    $0x4,%esp
f01119ea:	68 b0 8b 12 f0       	push   $0xf0128bb0
f01119ef:	68 5e 01 00 00       	push   $0x15e
f01119f4:	68 02 8b 12 f0       	push   $0xf0128b02
f01119f9:	e8 3b e9 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f01119fe:	83 ec 0c             	sub    $0xc,%esp
f0111a01:	68 dc 8b 12 f0       	push   $0xf0128bdc
f0111a06:	e8 80 f5 fe ff       	call   f0100f8b <cprintf>
f0111a0b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111a0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111a13:	c9                   	leave  
f0111a14:	c3                   	ret    

f0111a15 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0111a15:	55                   	push   %ebp
f0111a16:	89 e5                	mov    %esp,%ebp
f0111a18:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0111a1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111a22:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111a29:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111a30:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111a35:	ff 75 ec             	pushl  -0x14(%ebp)
f0111a38:	ff 75 f0             	pushl  -0x10(%ebp)
f0111a3b:	ff 75 f4             	pushl  -0xc(%ebp)
f0111a3e:	50                   	push   %eax
f0111a3f:	e8 84 7b ff ff       	call   f01095c8 <pt_set_page_permissions>
f0111a44:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0111a47:	83 ec 04             	sub    $0x4,%esp
f0111a4a:	68 2c 8c 12 f0       	push   $0xf0128c2c
f0111a4f:	68 6b 01 00 00       	push   $0x16b
f0111a54:	68 02 8b 12 f0       	push   $0xf0128b02
f0111a59:	e8 db e8 fe ff       	call   f0100339 <_panic>

f0111a5e <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0111a5e:	55                   	push   %ebp
f0111a5f:	89 e5                	mov    %esp,%ebp
f0111a61:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0111a64:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0111a6b:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111a70:	83 ec 08             	sub    $0x8,%esp
f0111a73:	ff 75 f4             	pushl  -0xc(%ebp)
f0111a76:	50                   	push   %eax
f0111a77:	e8 10 7c ff ff       	call   f010968c <pt_get_page_permissions>
f0111a7c:	83 c4 10             	add    $0x10,%esp
f0111a7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0111a82:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0111a86:	74 17                	je     f0111a9f <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0111a88:	83 ec 04             	sub    $0x4,%esp
f0111a8b:	68 c8 8c 12 f0       	push   $0xf0128cc8
f0111a90:	68 79 01 00 00       	push   $0x179
f0111a95:	68 02 8b 12 f0       	push   $0xf0128b02
f0111a9a:	e8 9a e8 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0111a9f:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111aa6:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111aab:	83 ec 08             	sub    $0x8,%esp
f0111aae:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ab1:	50                   	push   %eax
f0111ab2:	e8 d5 7b ff ff       	call   f010968c <pt_get_page_permissions>
f0111ab7:	83 c4 10             	add    $0x10,%esp
f0111aba:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0111abd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111ac1:	74 17                	je     f0111ada <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0111ac3:	83 ec 04             	sub    $0x4,%esp
f0111ac6:	68 ec 8c 12 f0       	push   $0xf0128cec
f0111acb:	68 81 01 00 00       	push   $0x181
f0111ad0:	68 02 8b 12 f0       	push   $0xf0128b02
f0111ad5:	e8 5f e8 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0111ada:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111ae1:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111ae6:	83 ec 08             	sub    $0x8,%esp
f0111ae9:	ff 75 f4             	pushl  -0xc(%ebp)
f0111aec:	50                   	push   %eax
f0111aed:	e8 9a 7b ff ff       	call   f010968c <pt_get_page_permissions>
f0111af2:	83 c4 10             	add    $0x10,%esp
f0111af5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111af8:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111afc:	74 17                	je     f0111b15 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0111afe:	83 ec 04             	sub    $0x4,%esp
f0111b01:	68 10 8d 12 f0       	push   $0xf0128d10
f0111b06:	68 89 01 00 00       	push   $0x189
f0111b0b:	68 02 8b 12 f0       	push   $0xf0128b02
f0111b10:	e8 24 e8 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f0111b15:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111b1c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111b21:	83 ec 08             	sub    $0x8,%esp
f0111b24:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b27:	50                   	push   %eax
f0111b28:	e8 5f 7b ff ff       	call   f010968c <pt_get_page_permissions>
f0111b2d:	83 c4 10             	add    $0x10,%esp
f0111b30:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111b33:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111b37:	74 17                	je     f0111b50 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0111b39:	83 ec 04             	sub    $0x4,%esp
f0111b3c:	68 34 8d 12 f0       	push   $0xf0128d34
f0111b41:	68 90 01 00 00       	push   $0x190
f0111b46:	68 02 8b 12 f0       	push   $0xf0128b02
f0111b4b:	e8 e9 e7 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0111b50:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111b57:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111b5c:	83 ec 08             	sub    $0x8,%esp
f0111b5f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b62:	50                   	push   %eax
f0111b63:	e8 24 7b ff ff       	call   f010968c <pt_get_page_permissions>
f0111b68:	83 c4 10             	add    $0x10,%esp
f0111b6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0111b6e:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0111b72:	74 17                	je     f0111b8b <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0111b74:	83 ec 04             	sub    $0x4,%esp
f0111b77:	68 58 8d 12 f0       	push   $0xf0128d58
f0111b7c:	68 97 01 00 00       	push   $0x197
f0111b81:	68 02 8b 12 f0       	push   $0xf0128b02
f0111b86:	e8 ae e7 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0111b8b:	83 ec 0c             	sub    $0xc,%esp
f0111b8e:	68 7c 8d 12 f0       	push   $0xf0128d7c
f0111b93:	e8 f3 f3 fe ff       	call   f0100f8b <cprintf>
f0111b98:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111b9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111ba0:	c9                   	leave  
f0111ba1:	c3                   	ret    

f0111ba2 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0111ba2:	55                   	push   %ebp
f0111ba3:	89 e5                	mov    %esp,%ebp
f0111ba5:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0111ba8:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111baf:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111bb4:	83 ec 08             	sub    $0x8,%esp
f0111bb7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bba:	50                   	push   %eax
f0111bbb:	e8 15 7b ff ff       	call   f01096d5 <pt_clear_page_table_entry>
f0111bc0:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0111bc3:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111bc8:	83 ec 08             	sub    $0x8,%esp
f0111bcb:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bce:	50                   	push   %eax
f0111bcf:	e8 e8 46 00 00       	call   f01162bc <CE>
f0111bd4:	83 c4 10             	add    $0x10,%esp
f0111bd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111bda:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111bde:	74 17                	je     f0111bf7 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0111be0:	83 ec 04             	sub    $0x4,%esp
f0111be3:	68 c4 8d 12 f0       	push   $0xf0128dc4
f0111be8:	68 a7 01 00 00       	push   $0x1a7
f0111bed:	68 02 8b 12 f0       	push   $0xf0128b02
f0111bf2:	e8 42 e7 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0111bf7:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111bfe:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c03:	83 ec 08             	sub    $0x8,%esp
f0111c06:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c09:	50                   	push   %eax
f0111c0a:	e8 c6 7a ff ff       	call   f01096d5 <pt_clear_page_table_entry>
f0111c0f:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111c12:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c17:	83 ec 08             	sub    $0x8,%esp
f0111c1a:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c1d:	50                   	push   %eax
f0111c1e:	e8 99 46 00 00       	call   f01162bc <CE>
f0111c23:	83 c4 10             	add    $0x10,%esp
f0111c26:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111c29:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111c2d:	74 17                	je     f0111c46 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0111c2f:	83 ec 04             	sub    $0x4,%esp
f0111c32:	68 f0 8d 12 f0       	push   $0xf0128df0
f0111c37:	68 af 01 00 00       	push   $0x1af
f0111c3c:	68 02 8b 12 f0       	push   $0xf0128b02
f0111c41:	e8 f3 e6 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0111c46:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111c4d:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c52:	83 ec 08             	sub    $0x8,%esp
f0111c55:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c58:	50                   	push   %eax
f0111c59:	e8 77 7a ff ff       	call   f01096d5 <pt_clear_page_table_entry>
f0111c5e:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111c61:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111c66:	83 ec 08             	sub    $0x8,%esp
f0111c69:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c6c:	50                   	push   %eax
f0111c6d:	e8 4a 46 00 00       	call   f01162bc <CE>
f0111c72:	83 c4 10             	add    $0x10,%esp
f0111c75:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111c78:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111c7c:	74 17                	je     f0111c95 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0111c7e:	83 ec 04             	sub    $0x4,%esp
f0111c81:	68 1c 8e 12 f0       	push   $0xf0128e1c
f0111c86:	68 b7 01 00 00       	push   $0x1b7
f0111c8b:	68 02 8b 12 f0       	push   $0xf0128b02
f0111c90:	e8 a4 e6 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0111c95:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111c9c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111ca1:	83 ec 08             	sub    $0x8,%esp
f0111ca4:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ca7:	50                   	push   %eax
f0111ca8:	e8 28 7a ff ff       	call   f01096d5 <pt_clear_page_table_entry>
f0111cad:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111cb0:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111cb5:	83 ec 08             	sub    $0x8,%esp
f0111cb8:	ff 75 f4             	pushl  -0xc(%ebp)
f0111cbb:	50                   	push   %eax
f0111cbc:	e8 fb 45 00 00       	call   f01162bc <CE>
f0111cc1:	83 c4 10             	add    $0x10,%esp
f0111cc4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111cc7:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111ccb:	74 17                	je     f0111ce4 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0111ccd:	83 ec 04             	sub    $0x4,%esp
f0111cd0:	68 48 8e 12 f0       	push   $0xf0128e48
f0111cd5:	68 bf 01 00 00       	push   $0x1bf
f0111cda:	68 02 8b 12 f0       	push   $0xf0128b02
f0111cdf:	e8 55 e6 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0111ce4:	83 ec 0c             	sub    $0xc,%esp
f0111ce7:	68 74 8e 12 f0       	push   $0xf0128e74
f0111cec:	e8 9a f2 fe ff       	call   f0100f8b <cprintf>
f0111cf1:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111cf4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111cf9:	c9                   	leave  
f0111cfa:	c3                   	ret    

f0111cfb <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0111cfb:	55                   	push   %ebp
f0111cfc:	89 e5                	mov    %esp,%ebp
f0111cfe:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0111d01:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111d08:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0111d0d:	83 ec 08             	sub    $0x8,%esp
f0111d10:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d13:	50                   	push   %eax
f0111d14:	e8 bc 79 ff ff       	call   f01096d5 <pt_clear_page_table_entry>
f0111d19:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0111d1c:	83 ec 04             	sub    $0x4,%esp
f0111d1f:	68 c0 8e 12 f0       	push   $0xf0128ec0
f0111d24:	68 ca 01 00 00       	push   $0x1ca
f0111d29:	68 02 8b 12 f0       	push   $0xf0128b02
f0111d2e:	e8 06 e6 fe ff       	call   f0100339 <_panic>

f0111d33 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0111d33:	55                   	push   %ebp
f0111d34:	89 e5                	mov    %esp,%ebp
f0111d36:	57                   	push   %edi
f0111d37:	56                   	push   %esi
f0111d38:	53                   	push   %ebx
f0111d39:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0111d3f:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0111d45:	bb 04 92 12 f0       	mov    $0xf0129204,%ebx
f0111d4a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111d4f:	89 c7                	mov    %eax,%edi
f0111d51:	89 de                	mov    %ebx,%esi
f0111d53:	89 d1                	mov    %edx,%ecx
f0111d55:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111d57:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0111d5d:	b9 23 00 00 00       	mov    $0x23,%ecx
f0111d62:	b0 00                	mov    $0x0,%al
f0111d64:	89 d7                	mov    %edx,%edi
f0111d66:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0111d68:	6a 00                	push   $0x0
f0111d6a:	6a 0a                	push   $0xa
f0111d6c:	6a 14                	push   $0x14
f0111d6e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0111d74:	50                   	push   %eax
f0111d75:	e8 90 8b ff ff       	call   f010a90a <env_create>
f0111d7a:	83 c4 10             	add    $0x10,%esp
f0111d7d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0111d80:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d83:	8b 40 64             	mov    0x64(%eax),%eax
f0111d86:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0111d89:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d8c:	8b 40 68             	mov    0x68(%eax),%eax
f0111d8f:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0111d92:	8b 45 90             	mov    -0x70(%ebp),%eax
f0111d95:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0111d98:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0111d9f:	75 70 20 
f0111da2:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0111da9:	00 00 00 
f0111dac:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0111db2:	b9 03 00 00 00       	mov    $0x3,%ecx
f0111db7:	b8 00 00 00 00       	mov    $0x0,%eax
f0111dbc:	89 d7                	mov    %edx,%edi
f0111dbe:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111dc0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111dc3:	8b 40 10             	mov    0x10(%eax),%eax
f0111dc6:	83 ec 08             	sub    $0x8,%esp
f0111dc9:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111dcf:	52                   	push   %edx
f0111dd0:	50                   	push   %eax
f0111dd1:	e8 94 dc 00 00       	call   f011fa6a <ltostr>
f0111dd6:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0111dd9:	83 ec 04             	sub    $0x4,%esp
f0111ddc:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111de2:	50                   	push   %eax
f0111de3:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0111de9:	50                   	push   %eax
f0111dea:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0111df0:	50                   	push   %eax
f0111df1:	e8 4d dd 00 00       	call   f011fb43 <strcconcat>
f0111df6:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0111df9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0111e00:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0111e07:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0111e0e:	83 ec 0c             	sub    $0xc,%esp
f0111e11:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e14:	e8 85 45 00 00       	call   f011639e <ClearUserSpace>
f0111e19:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0111e1c:	83 ec 04             	sub    $0x4,%esp
f0111e1f:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0111e25:	50                   	push   %eax
f0111e26:	68 56 8f 12 f0       	push   $0xf0128f56
f0111e2b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111e31:	50                   	push   %eax
f0111e32:	e8 0c dd 00 00       	call   f011fb43 <strcconcat>
f0111e37:	83 c4 10             	add    $0x10,%esp
f0111e3a:	83 ec 0c             	sub    $0xc,%esp
f0111e3d:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0111e43:	50                   	push   %eax
f0111e44:	e8 b2 00 ff ff       	call   f0101efb <execute_command>
f0111e49:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0111e4c:	83 ec 04             	sub    $0x4,%esp
f0111e4f:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0111e55:	50                   	push   %eax
f0111e56:	68 61 8f 12 f0       	push   $0xf0128f61
f0111e5b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111e61:	50                   	push   %eax
f0111e62:	e8 dc dc 00 00       	call   f011fb43 <strcconcat>
f0111e67:	83 c4 10             	add    $0x10,%esp
f0111e6a:	83 ec 0c             	sub    $0xc,%esp
f0111e6d:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0111e73:	50                   	push   %eax
f0111e74:	e8 82 00 ff ff       	call   f0101efb <execute_command>
f0111e79:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0111e7c:	83 ec 04             	sub    $0x4,%esp
f0111e7f:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111e85:	50                   	push   %eax
f0111e86:	68 6c 8f 12 f0       	push   $0xf0128f6c
f0111e8b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111e91:	50                   	push   %eax
f0111e92:	e8 ac dc 00 00       	call   f011fb43 <strcconcat>
f0111e97:	83 c4 10             	add    $0x10,%esp
f0111e9a:	83 ec 0c             	sub    $0xc,%esp
f0111e9d:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111ea3:	50                   	push   %eax
f0111ea4:	e8 52 00 ff ff       	call   f0101efb <execute_command>
f0111ea9:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0111eac:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0111eb3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111eb6:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0111eb9:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0111ec0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ec3:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0111ec6:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0111ecd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ed0:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0111ed3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111ed6:	83 ec 08             	sub    $0x8,%esp
f0111ed9:	50                   	push   %eax
f0111eda:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111edd:	e8 9d 44 00 00       	call   f011637f <GP>
f0111ee2:	83 c4 10             	add    $0x10,%esp
f0111ee5:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0111ee8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0111eef:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0111ef6:	e8 af c3 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0111efb:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0111efe:	83 ec 0c             	sub    $0xc,%esp
f0111f01:	68 78 8f 12 f0       	push   $0xf0128f78
f0111f06:	e8 80 f0 fe ff       	call   f0100f8b <cprintf>
f0111f0b:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0111f0e:	6a 03                	push   $0x3
f0111f10:	68 00 00 90 02       	push   $0x2900000
f0111f15:	68 00 00 80 02       	push   $0x2800000
f0111f1a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f1d:	e8 27 85 ff ff       	call   f010a449 <cut_paste_pages>
f0111f22:	83 c4 10             	add    $0x10,%esp
f0111f25:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0111f28:	e8 7d c3 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0111f2d:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0111f30:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0111f37:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0111f3b:	75 08                	jne    f0111f45 <test_cut_paste_pages+0x212>
f0111f3d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111f40:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0111f43:	74 2b                	je     f0111f70 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0111f45:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111f48:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111f4b:	83 ec 0c             	sub    $0xc,%esp
f0111f4e:	50                   	push   %eax
f0111f4f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111f52:	68 a8 8f 12 f0       	push   $0xf0128fa8
f0111f57:	68 04 02 00 00       	push   $0x204
f0111f5c:	68 02 8b 12 f0       	push   $0xf0128b02
f0111f61:	e8 70 e5 fe ff       	call   f01004d6 <_warn>
f0111f66:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0111f69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0111f70:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111f74:	74 04                	je     f0111f7a <test_cut_paste_pages+0x247>
f0111f76:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0111f7a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0111f81:	83 ec 08             	sub    $0x8,%esp
f0111f84:	6a 00                	push   $0x0
f0111f86:	6a 01                	push   $0x1
f0111f88:	6a 00                	push   $0x0
f0111f8a:	68 ff 0f 00 00       	push   $0xfff
f0111f8f:	ff 75 bc             	pushl  -0x44(%ebp)
f0111f92:	6a 01                	push   $0x1
f0111f94:	68 00 30 00 00       	push   $0x3000
f0111f99:	68 00 00 90 02       	push   $0x2900000
f0111f9e:	68 00 00 80 02       	push   $0x2800000
f0111fa3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111fa6:	e8 27 44 00 00       	call   f01163d2 <CCP>
f0111fab:	83 c4 30             	add    $0x30,%esp
f0111fae:	83 f8 01             	cmp    $0x1,%eax
f0111fb1:	74 21                	je     f0111fd4 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111fb3:	83 ec 04             	sub    $0x4,%esp
f0111fb6:	68 fc 8f 12 f0       	push   $0xf0128ffc
f0111fbb:	68 0c 02 00 00       	push   $0x20c
f0111fc0:	68 02 8b 12 f0       	push   $0xf0128b02
f0111fc5:	e8 0c e5 fe ff       	call   f01004d6 <_warn>
f0111fca:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111fcd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0111fd4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111fd8:	74 04                	je     f0111fde <test_cut_paste_pages+0x2ab>
f0111fda:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0111fde:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0111fe5:	83 ec 04             	sub    $0x4,%esp
f0111fe8:	6a 00                	push   $0x0
f0111fea:	68 00 00 90 02       	push   $0x2900000
f0111fef:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111ff2:	e8 b7 41 00 00       	call   f01161ae <CB>
f0111ff7:	83 c4 10             	add    $0x10,%esp
f0111ffa:	85 c0                	test   %eax,%eax
f0111ffc:	0f 84 f6 00 00 00    	je     f01120f8 <test_cut_paste_pages+0x3c5>
f0112002:	83 ec 04             	sub    $0x4,%esp
f0112005:	6a 00                	push   $0x0
f0112007:	68 00 10 90 02       	push   $0x2901000
f011200c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011200f:	e8 9a 41 00 00       	call   f01161ae <CB>
f0112014:	83 c4 10             	add    $0x10,%esp
f0112017:	85 c0                	test   %eax,%eax
f0112019:	0f 84 d9 00 00 00    	je     f01120f8 <test_cut_paste_pages+0x3c5>
f011201f:	83 ec 04             	sub    $0x4,%esp
f0112022:	6a 00                	push   $0x0
f0112024:	68 00 20 90 02       	push   $0x2902000
f0112029:	ff 75 d4             	pushl  -0x2c(%ebp)
f011202c:	e8 7d 41 00 00       	call   f01161ae <CB>
f0112031:	83 c4 10             	add    $0x10,%esp
f0112034:	85 c0                	test   %eax,%eax
f0112036:	0f 84 bc 00 00 00    	je     f01120f8 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f011203c:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112043:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f011204a:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112051:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112054:	8a 00                	mov    (%eax),%al
f0112056:	3c 61                	cmp    $0x61,%al
f0112058:	75 12                	jne    f011206c <test_cut_paste_pages+0x339>
f011205a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011205d:	8a 00                	mov    (%eax),%al
f011205f:	3c 62                	cmp    $0x62,%al
f0112061:	75 09                	jne    f011206c <test_cut_paste_pages+0x339>
f0112063:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112066:	8a 00                	mov    (%eax),%al
f0112068:	3c 63                	cmp    $0x63,%al
f011206a:	74 21                	je     f011208d <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011206c:	83 ec 04             	sub    $0x4,%esp
f011206f:	68 48 90 12 f0       	push   $0xf0129048
f0112074:	68 19 02 00 00       	push   $0x219
f0112079:	68 02 8b 12 f0       	push   $0xf0128b02
f011207e:	e8 53 e4 fe ff       	call   f01004d6 <_warn>
f0112083:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112086:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011208d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112091:	74 04                	je     f0112097 <test_cut_paste_pages+0x364>
f0112093:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112097:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f011209e:	83 ec 04             	sub    $0x4,%esp
f01120a1:	6a 01                	push   $0x1
f01120a3:	68 00 10 90 02       	push   $0x2901000
f01120a8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01120ab:	e8 fe 40 00 00       	call   f01161ae <CB>
f01120b0:	83 c4 10             	add    $0x10,%esp
f01120b3:	85 c0                	test   %eax,%eax
f01120b5:	74 41                	je     f01120f8 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f01120b7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01120ba:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f01120bd:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01120c0:	8a 00                	mov    (%eax),%al
f01120c2:	3c 79                	cmp    $0x79,%al
f01120c4:	74 21                	je     f01120e7 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01120c6:	83 ec 04             	sub    $0x4,%esp
f01120c9:	68 48 90 12 f0       	push   $0xf0129048
f01120ce:	68 24 02 00 00       	push   $0x224
f01120d3:	68 02 8b 12 f0       	push   $0xf0128b02
f01120d8:	e8 f9 e3 fe ff       	call   f01004d6 <_warn>
f01120dd:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01120e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01120e7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01120eb:	74 04                	je     f01120f1 <test_cut_paste_pages+0x3be>
f01120ed:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01120f1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f01120f8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01120fb:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f01120fe:	6a 02                	push   $0x2
f0112100:	68 00 f0 bf 02       	push   $0x2bff000
f0112105:	68 00 10 90 02       	push   $0x2901000
f011210a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011210d:	e8 37 83 ff ff       	call   f010a449 <cut_paste_pages>
f0112112:	83 c4 10             	add    $0x10,%esp
f0112115:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112118:	e8 8d c1 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011211d:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112120:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112124:	75 0b                	jne    f0112131 <test_cut_paste_pages+0x3fe>
f0112126:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112129:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011212c:	83 f8 01             	cmp    $0x1,%eax
f011212f:	74 2b                	je     f011215c <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112131:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112134:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112137:	83 ec 0c             	sub    $0xc,%esp
f011213a:	50                   	push   %eax
f011213b:	ff 75 b4             	pushl  -0x4c(%ebp)
f011213e:	68 a8 8f 12 f0       	push   $0xf0128fa8
f0112143:	68 35 02 00 00       	push   $0x235
f0112148:	68 02 8b 12 f0       	push   $0xf0128b02
f011214d:	e8 84 e3 fe ff       	call   f01004d6 <_warn>
f0112152:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112155:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011215c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112160:	74 04                	je     f0112166 <test_cut_paste_pages+0x433>
f0112162:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112166:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011216d:	83 ec 08             	sub    $0x8,%esp
f0112170:	6a 00                	push   $0x0
f0112172:	6a 01                	push   $0x1
f0112174:	6a 00                	push   $0x0
f0112176:	68 ff 0f 00 00       	push   $0xfff
f011217b:	ff 75 bc             	pushl  -0x44(%ebp)
f011217e:	6a 01                	push   $0x1
f0112180:	68 00 20 00 00       	push   $0x2000
f0112185:	68 00 f0 bf 02       	push   $0x2bff000
f011218a:	68 00 10 90 02       	push   $0x2901000
f011218f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112192:	e8 3b 42 00 00       	call   f01163d2 <CCP>
f0112197:	83 c4 30             	add    $0x30,%esp
f011219a:	83 f8 01             	cmp    $0x1,%eax
f011219d:	74 21                	je     f01121c0 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011219f:	83 ec 04             	sub    $0x4,%esp
f01121a2:	68 fc 8f 12 f0       	push   $0xf0128ffc
f01121a7:	68 3d 02 00 00       	push   $0x23d
f01121ac:	68 02 8b 12 f0       	push   $0xf0128b02
f01121b1:	e8 20 e3 fe ff       	call   f01004d6 <_warn>
f01121b6:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01121b9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01121c0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01121c4:	74 04                	je     f01121ca <test_cut_paste_pages+0x497>
f01121c6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01121ca:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f01121d1:	83 ec 04             	sub    $0x4,%esp
f01121d4:	6a 00                	push   $0x0
f01121d6:	68 ff f7 bf 02       	push   $0x2bff7ff
f01121db:	ff 75 d4             	pushl  -0x2c(%ebp)
f01121de:	e8 cb 3f 00 00       	call   f01161ae <CB>
f01121e3:	83 c4 10             	add    $0x10,%esp
f01121e6:	85 c0                	test   %eax,%eax
f01121e8:	74 6b                	je     f0112255 <test_cut_paste_pages+0x522>
f01121ea:	83 ec 04             	sub    $0x4,%esp
f01121ed:	6a 00                	push   $0x0
f01121ef:	68 ff 0f c0 02       	push   $0x2c00fff
f01121f4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01121f7:	e8 b2 3f 00 00       	call   f01161ae <CB>
f01121fc:	83 c4 10             	add    $0x10,%esp
f01121ff:	85 c0                	test   %eax,%eax
f0112201:	74 52                	je     f0112255 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112203:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f011220a:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112211:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112214:	8a 00                	mov    (%eax),%al
f0112216:	3c 79                	cmp    $0x79,%al
f0112218:	75 09                	jne    f0112223 <test_cut_paste_pages+0x4f0>
f011221a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011221d:	8a 00                	mov    (%eax),%al
f011221f:	3c 63                	cmp    $0x63,%al
f0112221:	74 21                	je     f0112244 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112223:	83 ec 04             	sub    $0x4,%esp
f0112226:	68 48 90 12 f0       	push   $0xf0129048
f011222b:	68 49 02 00 00       	push   $0x249
f0112230:	68 02 8b 12 f0       	push   $0xf0128b02
f0112235:	e8 9c e2 fe ff       	call   f01004d6 <_warn>
f011223a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011223d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112244:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112248:	74 04                	je     f011224e <test_cut_paste_pages+0x51b>
f011224a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011224e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112255:	83 ec 0c             	sub    $0xc,%esp
f0112258:	68 81 90 12 f0       	push   $0xf0129081
f011225d:	e8 29 ed fe ff       	call   f0100f8b <cprintf>
f0112262:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112265:	83 ec 0c             	sub    $0xc,%esp
f0112268:	68 90 90 12 f0       	push   $0xf0129090
f011226d:	e8 19 ed fe ff       	call   f0100f8b <cprintf>
f0112272:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112275:	83 ec 04             	sub    $0x4,%esp
f0112278:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011227e:	50                   	push   %eax
f011227f:	68 b9 90 12 f0       	push   $0xf01290b9
f0112284:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011228a:	50                   	push   %eax
f011228b:	e8 b3 d8 00 00       	call   f011fb43 <strcconcat>
f0112290:	83 c4 10             	add    $0x10,%esp
f0112293:	83 ec 0c             	sub    $0xc,%esp
f0112296:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011229c:	50                   	push   %eax
f011229d:	e8 59 fc fe ff       	call   f0101efb <execute_command>
f01122a2:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01122a5:	83 ec 04             	sub    $0x4,%esp
f01122a8:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01122ae:	50                   	push   %eax
f01122af:	68 c4 90 12 f0       	push   $0xf01290c4
f01122b4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01122ba:	50                   	push   %eax
f01122bb:	e8 83 d8 00 00       	call   f011fb43 <strcconcat>
f01122c0:	83 c4 10             	add    $0x10,%esp
f01122c3:	83 ec 0c             	sub    $0xc,%esp
f01122c6:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01122cc:	50                   	push   %eax
f01122cd:	e8 29 fc fe ff       	call   f0101efb <execute_command>
f01122d2:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f01122d5:	83 ec 04             	sub    $0x4,%esp
f01122d8:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01122de:	50                   	push   %eax
f01122df:	68 cf 90 12 f0       	push   $0xf01290cf
f01122e4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01122ea:	50                   	push   %eax
f01122eb:	e8 53 d8 00 00       	call   f011fb43 <strcconcat>
f01122f0:	83 c4 10             	add    $0x10,%esp
f01122f3:	83 ec 0c             	sub    $0xc,%esp
f01122f6:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01122fc:	50                   	push   %eax
f01122fd:	e8 f9 fb fe ff       	call   f0101efb <execute_command>
f0112302:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112305:	83 ec 04             	sub    $0x4,%esp
f0112308:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011230e:	50                   	push   %eax
f011230f:	68 da 90 12 f0       	push   $0xf01290da
f0112314:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011231a:	50                   	push   %eax
f011231b:	e8 23 d8 00 00       	call   f011fb43 <strcconcat>
f0112320:	83 c4 10             	add    $0x10,%esp
f0112323:	83 ec 0c             	sub    $0xc,%esp
f0112326:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011232c:	50                   	push   %eax
f011232d:	e8 c9 fb fe ff       	call   f0101efb <execute_command>
f0112332:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112335:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f011233c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011233f:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112342:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112349:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011234c:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f011234f:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112356:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112359:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f011235c:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112363:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112366:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112369:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112370:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112373:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112376:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f011237d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112380:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112383:	83 ec 08             	sub    $0x8,%esp
f0112386:	68 00 00 c0 01       	push   $0x1c00000
f011238b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011238e:	e8 ec 3f 00 00       	call   f011637f <GP>
f0112393:	83 c4 10             	add    $0x10,%esp
f0112396:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112399:	83 ec 08             	sub    $0x8,%esp
f011239c:	68 00 00 40 01       	push   $0x1400000
f01123a1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01123a4:	e8 d6 3f 00 00       	call   f011637f <GP>
f01123a9:	83 c4 10             	add    $0x10,%esp
f01123ac:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f01123af:	e8 f6 be ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01123b4:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f01123b7:	6a 01                	push   $0x1
f01123b9:	68 00 00 40 01       	push   $0x1400000
f01123be:	68 00 00 c0 01       	push   $0x1c00000
f01123c3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01123c6:	e8 7e 80 ff ff       	call   f010a449 <cut_paste_pages>
f01123cb:	83 c4 10             	add    $0x10,%esp
f01123ce:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01123d1:	e8 d4 be ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01123d6:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01123d9:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f01123dd:	75 08                	jne    f01123e7 <test_cut_paste_pages+0x6b4>
f01123df:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01123e2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01123e5:	74 2b                	je     f0112412 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f01123e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01123ea:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01123ed:	83 ec 0c             	sub    $0xc,%esp
f01123f0:	50                   	push   %eax
f01123f1:	ff 75 b4             	pushl  -0x4c(%ebp)
f01123f4:	68 e8 90 12 f0       	push   $0xf01290e8
f01123f9:	68 6c 02 00 00       	push   $0x26c
f01123fe:	68 02 8b 12 f0       	push   $0xf0128b02
f0112403:	e8 ce e0 fe ff       	call   f01004d6 <_warn>
f0112408:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011240b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112412:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112416:	74 04                	je     f011241c <test_cut_paste_pages+0x6e9>
f0112418:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011241c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112423:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f011242a:	83 ec 08             	sub    $0x8,%esp
f011242d:	6a 00                	push   $0x0
f011242f:	68 ff 0f 00 00       	push   $0xfff
f0112434:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112437:	68 ff 0f 00 00       	push   $0xfff
f011243c:	ff 75 a0             	pushl  -0x60(%ebp)
f011243f:	6a 01                	push   $0x1
f0112441:	68 00 10 00 00       	push   $0x1000
f0112446:	68 00 00 40 01       	push   $0x1400000
f011244b:	68 00 00 c0 01       	push   $0x1c00000
f0112450:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112453:	e8 7a 3f 00 00       	call   f01163d2 <CCP>
f0112458:	83 c4 30             	add    $0x30,%esp
f011245b:	83 f8 01             	cmp    $0x1,%eax
f011245e:	74 28                	je     f0112488 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112460:	83 ec 04             	sub    $0x4,%esp
f0112463:	68 fc 8f 12 f0       	push   $0xf0128ffc
f0112468:	68 75 02 00 00       	push   $0x275
f011246d:	68 02 8b 12 f0       	push   $0xf0128b02
f0112472:	e8 5f e0 fe ff       	call   f01004d6 <_warn>
f0112477:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011247a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112481:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112488:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011248c:	74 04                	je     f0112492 <test_cut_paste_pages+0x75f>
f011248e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112492:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112499:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011249d:	0f 84 92 00 00 00    	je     f0112535 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f01124a3:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01124aa:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01124b1:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01124b8:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01124bf:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01124c6:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01124cd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01124d0:	8a 00                	mov    (%eax),%al
f01124d2:	3c 61                	cmp    $0x61,%al
f01124d4:	75 2d                	jne    f0112503 <test_cut_paste_pages+0x7d0>
f01124d6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01124d9:	8a 00                	mov    (%eax),%al
f01124db:	3c 78                	cmp    $0x78,%al
f01124dd:	75 24                	jne    f0112503 <test_cut_paste_pages+0x7d0>
f01124df:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01124e2:	8a 00                	mov    (%eax),%al
f01124e4:	3c 62                	cmp    $0x62,%al
f01124e6:	75 1b                	jne    f0112503 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01124e8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01124eb:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01124ed:	3c 79                	cmp    $0x79,%al
f01124ef:	75 12                	jne    f0112503 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01124f1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01124f4:	8a 00                	mov    (%eax),%al
f01124f6:	3c 63                	cmp    $0x63,%al
f01124f8:	75 09                	jne    f0112503 <test_cut_paste_pages+0x7d0>
f01124fa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01124fd:	8a 00                	mov    (%eax),%al
f01124ff:	3c 7a                	cmp    $0x7a,%al
f0112501:	74 21                	je     f0112524 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112503:	83 ec 04             	sub    $0x4,%esp
f0112506:	68 48 90 12 f0       	push   $0xf0129048
f011250b:	68 87 02 00 00       	push   $0x287
f0112510:	68 02 8b 12 f0       	push   $0xf0128b02
f0112515:	e8 bc df fe ff       	call   f01004d6 <_warn>
f011251a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011251d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112524:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112528:	74 04                	je     f011252e <test_cut_paste_pages+0x7fb>
f011252a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011252e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112535:	e8 70 bd ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011253a:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f011253d:	6a 03                	push   $0x3
f011253f:	68 00 f0 bf 01       	push   $0x1bff000
f0112544:	68 00 00 40 01       	push   $0x1400000
f0112549:	ff 75 d4             	pushl  -0x2c(%ebp)
f011254c:	e8 f8 7e ff ff       	call   f010a449 <cut_paste_pages>
f0112551:	83 c4 10             	add    $0x10,%esp
f0112554:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112557:	e8 4e bd ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011255c:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011255f:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112563:	75 08                	jne    f011256d <test_cut_paste_pages+0x83a>
f0112565:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112568:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011256b:	74 2b                	je     f0112598 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011256d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112570:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112573:	83 ec 0c             	sub    $0xc,%esp
f0112576:	50                   	push   %eax
f0112577:	ff 75 b4             	pushl  -0x4c(%ebp)
f011257a:	68 e8 90 12 f0       	push   $0xf01290e8
f011257f:	68 96 02 00 00       	push   $0x296
f0112584:	68 02 8b 12 f0       	push   $0xf0128b02
f0112589:	e8 48 df fe ff       	call   f01004d6 <_warn>
f011258e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112591:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112598:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011259c:	74 04                	je     f01125a2 <test_cut_paste_pages+0x86f>
f011259e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01125a2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f01125a9:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01125b0:	83 ec 04             	sub    $0x4,%esp
f01125b3:	6a 00                	push   $0x0
f01125b5:	68 00 00 40 01       	push   $0x1400000
f01125ba:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125bd:	e8 ec 3b 00 00       	call   f01161ae <CB>
f01125c2:	83 c4 10             	add    $0x10,%esp
f01125c5:	83 f8 01             	cmp    $0x1,%eax
f01125c8:	0f 85 80 00 00 00    	jne    f011264e <test_cut_paste_pages+0x91b>
f01125ce:	83 ec 04             	sub    $0x4,%esp
f01125d1:	6a 00                	push   $0x0
f01125d3:	68 00 10 40 01       	push   $0x1401000
f01125d8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125db:	e8 ce 3b 00 00       	call   f01161ae <CB>
f01125e0:	83 c4 10             	add    $0x10,%esp
f01125e3:	83 f8 01             	cmp    $0x1,%eax
f01125e6:	75 66                	jne    f011264e <test_cut_paste_pages+0x91b>
f01125e8:	83 ec 04             	sub    $0x4,%esp
f01125eb:	6a 00                	push   $0x0
f01125ed:	68 00 20 40 01       	push   $0x1402000
f01125f2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125f5:	e8 b4 3b 00 00       	call   f01161ae <CB>
f01125fa:	83 c4 10             	add    $0x10,%esp
f01125fd:	83 f8 01             	cmp    $0x1,%eax
f0112600:	75 4c                	jne    f011264e <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112602:	83 ec 04             	sub    $0x4,%esp
f0112605:	6a 00                	push   $0x0
f0112607:	68 00 f0 bf 01       	push   $0x1bff000
f011260c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011260f:	e8 9a 3b 00 00       	call   f01161ae <CB>
f0112614:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112617:	85 c0                	test   %eax,%eax
f0112619:	75 33                	jne    f011264e <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f011261b:	83 ec 04             	sub    $0x4,%esp
f011261e:	6a 00                	push   $0x0
f0112620:	68 00 00 c0 01       	push   $0x1c00000
f0112625:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112628:	e8 81 3b 00 00       	call   f01161ae <CB>
f011262d:	83 c4 10             	add    $0x10,%esp
f0112630:	83 f8 01             	cmp    $0x1,%eax
f0112633:	75 19                	jne    f011264e <test_cut_paste_pages+0x91b>
f0112635:	83 ec 04             	sub    $0x4,%esp
f0112638:	6a 00                	push   $0x0
f011263a:	68 00 10 c0 01       	push   $0x1c01000
f011263f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112642:	e8 67 3b 00 00       	call   f01161ae <CB>
f0112647:	83 c4 10             	add    $0x10,%esp
f011264a:	85 c0                	test   %eax,%eax
f011264c:	74 28                	je     f0112676 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f011264e:	83 ec 04             	sub    $0x4,%esp
f0112651:	68 48 91 12 f0       	push   $0xf0129148
f0112656:	68 9f 02 00 00       	push   $0x29f
f011265b:	68 02 8b 12 f0       	push   $0xf0128b02
f0112660:	e8 71 de fe ff       	call   f01004d6 <_warn>
f0112665:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112668:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f011266f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112676:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011267a:	74 04                	je     f0112680 <test_cut_paste_pages+0x94d>
f011267c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112680:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112687:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011268b:	0f 84 99 00 00 00    	je     f011272a <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112691:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112698:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f011269f:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01126a6:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01126ad:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01126b4:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01126bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01126be:	8a 00                	mov    (%eax),%al
f01126c0:	3c 61                	cmp    $0x61,%al
f01126c2:	75 2d                	jne    f01126f1 <test_cut_paste_pages+0x9be>
f01126c4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01126c7:	8a 00                	mov    (%eax),%al
f01126c9:	3c 78                	cmp    $0x78,%al
f01126cb:	75 24                	jne    f01126f1 <test_cut_paste_pages+0x9be>
f01126cd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01126d0:	8a 00                	mov    (%eax),%al
f01126d2:	3c 62                	cmp    $0x62,%al
f01126d4:	75 1b                	jne    f01126f1 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01126d6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01126d9:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01126db:	3c 79                	cmp    $0x79,%al
f01126dd:	75 12                	jne    f01126f1 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01126df:	8b 45 98             	mov    -0x68(%ebp),%eax
f01126e2:	8a 00                	mov    (%eax),%al
f01126e4:	3c 63                	cmp    $0x63,%al
f01126e6:	75 09                	jne    f01126f1 <test_cut_paste_pages+0x9be>
f01126e8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01126eb:	8a 00                	mov    (%eax),%al
f01126ed:	3c 7a                	cmp    $0x7a,%al
f01126ef:	74 28                	je     f0112719 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f01126f1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f01126f8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01126ff:	83 ec 04             	sub    $0x4,%esp
f0112702:	68 48 90 12 f0       	push   $0xf0129048
f0112707:	68 b3 02 00 00       	push   $0x2b3
f011270c:	68 02 8b 12 f0       	push   $0xf0128b02
f0112711:	e8 c0 dd fe ff       	call   f01004d6 <_warn>
f0112716:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112719:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011271d:	74 04                	je     f0112723 <test_cut_paste_pages+0x9f0>
f011271f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112723:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f011272a:	83 ec 0c             	sub    $0xc,%esp
f011272d:	68 81 91 12 f0       	push   $0xf0129181
f0112732:	e8 54 e8 fe ff       	call   f0100f8b <cprintf>
f0112737:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f011273a:	83 ec 08             	sub    $0x8,%esp
f011273d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112740:	68 90 91 12 f0       	push   $0xf0129190
f0112745:	e8 41 e8 fe ff       	call   f0100f8b <cprintf>
f011274a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011274d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112751:	75 10                	jne    f0112763 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112753:	83 ec 0c             	sub    $0xc,%esp
f0112756:	68 c4 91 12 f0       	push   $0xf01291c4
f011275b:	e8 2b e8 fe ff       	call   f0100f8b <cprintf>
f0112760:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112763:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0112768:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011276b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011276e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112771:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112776:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112779:	5b                   	pop    %ebx
f011277a:	5e                   	pop    %esi
f011277b:	5f                   	pop    %edi
f011277c:	5d                   	pop    %ebp
f011277d:	c3                   	ret    

f011277e <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f011277e:	55                   	push   %ebp
f011277f:	89 e5                	mov    %esp,%ebp
f0112781:	57                   	push   %edi
f0112782:	56                   	push   %esi
f0112783:	53                   	push   %ebx
f0112784:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011278a:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112790:	bb 04 92 12 f0       	mov    $0xf0129204,%ebx
f0112795:	ba 0f 00 00 00       	mov    $0xf,%edx
f011279a:	89 c7                	mov    %eax,%edi
f011279c:	89 de                	mov    %ebx,%esi
f011279e:	89 d1                	mov    %edx,%ecx
f01127a0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01127a2:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f01127a8:	b9 23 00 00 00       	mov    $0x23,%ecx
f01127ad:	b0 00                	mov    $0x0,%al
f01127af:	89 d7                	mov    %edx,%edi
f01127b1:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01127b3:	6a 00                	push   $0x0
f01127b5:	6a 0a                	push   $0xa
f01127b7:	6a 14                	push   $0x14
f01127b9:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f01127bf:	50                   	push   %eax
f01127c0:	e8 45 81 ff ff       	call   f010a90a <env_create>
f01127c5:	83 c4 10             	add    $0x10,%esp
f01127c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01127cb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01127ce:	8b 40 64             	mov    0x64(%eax),%eax
f01127d1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01127d4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01127d7:	8b 40 68             	mov    0x68(%eax),%eax
f01127da:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01127e0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01127e6:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01127e9:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f01127f0:	75 70 20 
f01127f3:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f01127fa:	00 00 00 
f01127fd:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112803:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112808:	b8 00 00 00 00       	mov    $0x0,%eax
f011280d:	89 d7                	mov    %edx,%edi
f011280f:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112811:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112814:	8b 40 10             	mov    0x10(%eax),%eax
f0112817:	83 ec 08             	sub    $0x8,%esp
f011281a:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112820:	52                   	push   %edx
f0112821:	50                   	push   %eax
f0112822:	e8 43 d2 00 00       	call   f011fa6a <ltostr>
f0112827:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011282a:	83 ec 04             	sub    $0x4,%esp
f011282d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112833:	50                   	push   %eax
f0112834:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f011283a:	50                   	push   %eax
f011283b:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112841:	50                   	push   %eax
f0112842:	e8 fc d2 00 00       	call   f011fb43 <strcconcat>
f0112847:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f011284a:	83 ec 0c             	sub    $0xc,%esp
f011284d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112850:	e8 49 3b 00 00       	call   f011639e <ClearUserSpace>
f0112855:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112858:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f011285f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112866:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011286d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112874:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011287b:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112882:	83 ec 0c             	sub    $0xc,%esp
f0112885:	68 38 92 12 f0       	push   $0xf0129238
f011288a:	e8 fc e6 fe ff       	call   f0100f8b <cprintf>
f011288f:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112892:	83 ec 04             	sub    $0x4,%esp
f0112895:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011289b:	50                   	push   %eax
f011289c:	68 6e 92 12 f0       	push   $0xf012926e
f01128a1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01128a7:	50                   	push   %eax
f01128a8:	e8 96 d2 00 00       	call   f011fb43 <strcconcat>
f01128ad:	83 c4 10             	add    $0x10,%esp
f01128b0:	83 ec 0c             	sub    $0xc,%esp
f01128b3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01128b9:	50                   	push   %eax
f01128ba:	e8 3c f6 fe ff       	call   f0101efb <execute_command>
f01128bf:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f01128c2:	83 ec 04             	sub    $0x4,%esp
f01128c5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01128cb:	50                   	push   %eax
f01128cc:	68 73 92 12 f0       	push   $0xf0129273
f01128d1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01128d7:	50                   	push   %eax
f01128d8:	e8 66 d2 00 00       	call   f011fb43 <strcconcat>
f01128dd:	83 c4 10             	add    $0x10,%esp
f01128e0:	83 ec 0c             	sub    $0xc,%esp
f01128e3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01128e9:	50                   	push   %eax
f01128ea:	e8 0c f6 fe ff       	call   f0101efb <execute_command>
f01128ef:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f01128f2:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01128f8:	bb 79 95 12 f0       	mov    $0xf0129579,%ebx
f01128fd:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112902:	89 c7                	mov    %eax,%edi
f0112904:	89 de                	mov    %ebx,%esi
f0112906:	89 d1                	mov    %edx,%ecx
f0112908:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011290a:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112910:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112915:	b0 00                	mov    $0x0,%al
f0112917:	89 d7                	mov    %edx,%edi
f0112919:	f3 aa                	rep stos %al,%es:(%edi)
f011291b:	83 ec 0c             	sub    $0xc,%esp
f011291e:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112924:	50                   	push   %eax
f0112925:	e8 d1 f5 fe ff       	call   f0101efb <execute_command>
f011292a:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f011292d:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112933:	bb dd 95 12 f0       	mov    $0xf01295dd,%ebx
f0112938:	ba 0f 00 00 00       	mov    $0xf,%edx
f011293d:	89 c7                	mov    %eax,%edi
f011293f:	89 de                	mov    %ebx,%esi
f0112941:	89 d1                	mov    %edx,%ecx
f0112943:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112945:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f011294b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112950:	b0 00                	mov    $0x0,%al
f0112952:	89 d7                	mov    %edx,%edi
f0112954:	f3 aa                	rep stos %al,%es:(%edi)
f0112956:	83 ec 0c             	sub    $0xc,%esp
f0112959:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011295f:	50                   	push   %eax
f0112960:	e8 96 f5 fe ff       	call   f0101efb <execute_command>
f0112965:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0112968:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011296e:	bb 41 96 12 f0       	mov    $0xf0129641,%ebx
f0112973:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112978:	89 c7                	mov    %eax,%edi
f011297a:	89 de                	mov    %ebx,%esi
f011297c:	89 d1                	mov    %edx,%ecx
f011297e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112980:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112986:	b9 55 00 00 00       	mov    $0x55,%ecx
f011298b:	b0 00                	mov    $0x0,%al
f011298d:	89 d7                	mov    %edx,%edi
f011298f:	f3 aa                	rep stos %al,%es:(%edi)
f0112991:	83 ec 0c             	sub    $0xc,%esp
f0112994:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011299a:	50                   	push   %eax
f011299b:	e8 5b f5 fe ff       	call   f0101efb <execute_command>
f01129a0:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f01129a3:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01129a9:	bb a5 96 12 f0       	mov    $0xf01296a5,%ebx
f01129ae:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129b3:	89 c7                	mov    %eax,%edi
f01129b5:	89 de                	mov    %ebx,%esi
f01129b7:	89 d1                	mov    %edx,%ecx
f01129b9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129bb:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01129c1:	b9 55 00 00 00       	mov    $0x55,%ecx
f01129c6:	b0 00                	mov    $0x0,%al
f01129c8:	89 d7                	mov    %edx,%edi
f01129ca:	f3 aa                	rep stos %al,%es:(%edi)
f01129cc:	83 ec 0c             	sub    $0xc,%esp
f01129cf:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01129d5:	50                   	push   %eax
f01129d6:	e8 20 f5 fe ff       	call   f0101efb <execute_command>
f01129db:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f01129de:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01129e4:	bb 09 97 12 f0       	mov    $0xf0129709,%ebx
f01129e9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129ee:	89 c7                	mov    %eax,%edi
f01129f0:	89 de                	mov    %ebx,%esi
f01129f2:	89 d1                	mov    %edx,%ecx
f01129f4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129f6:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01129fc:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a01:	b0 00                	mov    $0x0,%al
f0112a03:	89 d7                	mov    %edx,%edi
f0112a05:	f3 aa                	rep stos %al,%es:(%edi)
f0112a07:	83 ec 0c             	sub    $0xc,%esp
f0112a0a:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112a10:	50                   	push   %eax
f0112a11:	e8 e5 f4 fe ff       	call   f0101efb <execute_command>
f0112a16:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0112a19:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112a1f:	bb 6d 97 12 f0       	mov    $0xf012976d,%ebx
f0112a24:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a29:	89 c7                	mov    %eax,%edi
f0112a2b:	89 de                	mov    %ebx,%esi
f0112a2d:	89 d1                	mov    %edx,%ecx
f0112a2f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a31:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112a37:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a3c:	b0 00                	mov    $0x0,%al
f0112a3e:	89 d7                	mov    %edx,%edi
f0112a40:	f3 aa                	rep stos %al,%es:(%edi)
f0112a42:	83 ec 0c             	sub    $0xc,%esp
f0112a45:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112a4b:	50                   	push   %eax
f0112a4c:	e8 aa f4 fe ff       	call   f0101efb <execute_command>
f0112a51:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0112a54:	83 ec 04             	sub    $0x4,%esp
f0112a57:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112a5d:	50                   	push   %eax
f0112a5e:	68 7b 92 12 f0       	push   $0xf012927b
f0112a63:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112a69:	50                   	push   %eax
f0112a6a:	e8 d4 d0 00 00       	call   f011fb43 <strcconcat>
f0112a6f:	83 c4 10             	add    $0x10,%esp
f0112a72:	83 ec 0c             	sub    $0xc,%esp
f0112a75:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112a7b:	50                   	push   %eax
f0112a7c:	e8 7a f4 fe ff       	call   f0101efb <execute_command>
f0112a81:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0112a84:	83 ec 04             	sub    $0x4,%esp
f0112a87:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112a8d:	50                   	push   %eax
f0112a8e:	68 85 92 12 f0       	push   $0xf0129285
f0112a93:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112a99:	50                   	push   %eax
f0112a9a:	e8 a4 d0 00 00       	call   f011fb43 <strcconcat>
f0112a9f:	83 c4 10             	add    $0x10,%esp
f0112aa2:	83 ec 0c             	sub    $0xc,%esp
f0112aa5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112aab:	50                   	push   %eax
f0112aac:	e8 4a f4 fe ff       	call   f0101efb <execute_command>
f0112ab1:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0112ab4:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112aba:	bb d1 97 12 f0       	mov    $0xf01297d1,%ebx
f0112abf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ac4:	89 c7                	mov    %eax,%edi
f0112ac6:	89 de                	mov    %ebx,%esi
f0112ac8:	89 d1                	mov    %edx,%ecx
f0112aca:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112acc:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112ad2:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112ad7:	b0 00                	mov    $0x0,%al
f0112ad9:	89 d7                	mov    %edx,%edi
f0112adb:	f3 aa                	rep stos %al,%es:(%edi)
f0112add:	83 ec 0c             	sub    $0xc,%esp
f0112ae0:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112ae6:	50                   	push   %eax
f0112ae7:	e8 0f f4 fe ff       	call   f0101efb <execute_command>
f0112aec:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0112aef:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112af5:	bb 35 98 12 f0       	mov    $0xf0129835,%ebx
f0112afa:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112aff:	89 c7                	mov    %eax,%edi
f0112b01:	89 de                	mov    %ebx,%esi
f0112b03:	89 d1                	mov    %edx,%ecx
f0112b05:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112b07:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112b0d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112b12:	b0 00                	mov    $0x0,%al
f0112b14:	89 d7                	mov    %edx,%edi
f0112b16:	f3 aa                	rep stos %al,%es:(%edi)
f0112b18:	83 ec 0c             	sub    $0xc,%esp
f0112b1b:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112b21:	50                   	push   %eax
f0112b22:	e8 d4 f3 fe ff       	call   f0101efb <execute_command>
f0112b27:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0112b2a:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112b30:	bb 99 98 12 f0       	mov    $0xf0129899,%ebx
f0112b35:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112b3a:	89 c7                	mov    %eax,%edi
f0112b3c:	89 de                	mov    %ebx,%esi
f0112b3e:	89 d1                	mov    %edx,%ecx
f0112b40:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112b42:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112b48:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112b4d:	b0 00                	mov    $0x0,%al
f0112b4f:	89 d7                	mov    %edx,%edi
f0112b51:	f3 aa                	rep stos %al,%es:(%edi)
f0112b53:	83 ec 0c             	sub    $0xc,%esp
f0112b56:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112b5c:	50                   	push   %eax
f0112b5d:	e8 99 f3 fe ff       	call   f0101efb <execute_command>
f0112b62:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0112b65:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0112b6c:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0112b73:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0112b7a:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0112b81:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0112b88:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0112b8f:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0112b96:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0112b9d:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0112ba4:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0112bab:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0112bb2:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0112bb9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112bbc:	8a 00                	mov    (%eax),%al
f0112bbe:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0112bc4:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112bc7:	8a 00                	mov    (%eax),%al
f0112bc9:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0112bcf:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112bd2:	8a 00                	mov    (%eax),%al
f0112bd4:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112bda:	e8 cb b6 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0112bdf:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0112be2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112be5:	89 d0                	mov    %edx,%eax
f0112be7:	01 c0                	add    %eax,%eax
f0112be9:	01 d0                	add    %edx,%eax
f0112beb:	01 c0                	add    %eax,%eax
f0112bed:	50                   	push   %eax
f0112bee:	68 00 00 10 00       	push   $0x100000
f0112bf3:	6a 00                	push   $0x0
f0112bf5:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bf8:	e8 66 78 ff ff       	call   f010a463 <copy_paste_chunk>
f0112bfd:	83 c4 10             	add    $0x10,%esp
f0112c00:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112c03:	e8 a2 b6 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0112c08:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0112c0b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0112c12:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0112c16:	75 08                	jne    f0112c20 <test_copy_paste_chunk+0x4a2>
f0112c18:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112c1b:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0112c1e:	74 2b                	je     f0112c4b <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112c20:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112c23:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112c26:	83 ec 0c             	sub    $0xc,%esp
f0112c29:	50                   	push   %eax
f0112c2a:	ff 75 88             	pushl  -0x78(%ebp)
f0112c2d:	68 94 92 12 f0       	push   $0xf0129294
f0112c32:	68 06 03 00 00       	push   $0x306
f0112c37:	68 02 8b 12 f0       	push   $0xf0128b02
f0112c3c:	e8 95 d8 fe ff       	call   f01004d6 <_warn>
f0112c41:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112c44:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112c4b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c4f:	74 04                	je     f0112c55 <test_copy_paste_chunk+0x4d7>
f0112c51:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112c55:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0112c5c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112c5f:	8a 00                	mov    (%eax),%al
f0112c61:	3c 61                	cmp    $0x61,%al
f0112c63:	75 75                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112c65:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112c68:	8a 00                	mov    (%eax),%al
f0112c6a:	3c 78                	cmp    $0x78,%al
f0112c6c:	75 6c                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112c6e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112c71:	8a 00                	mov    (%eax),%al
f0112c73:	3c 62                	cmp    $0x62,%al
f0112c75:	75 63                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112c77:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112c7a:	8a 00                	mov    (%eax),%al
f0112c7c:	3c 79                	cmp    $0x79,%al
f0112c7e:	75 5a                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112c80:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112c83:	8a 00                	mov    (%eax),%al
f0112c85:	3c 63                	cmp    $0x63,%al
f0112c87:	75 51                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112c89:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112c8c:	8a 00                	mov    (%eax),%al
f0112c8e:	3c 7a                	cmp    $0x7a,%al
f0112c90:	75 48                	jne    f0112cda <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0112c92:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112c95:	8a 00                	mov    (%eax),%al
f0112c97:	3c 64                	cmp    $0x64,%al
f0112c99:	75 3f                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112c9b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112c9e:	8a 10                	mov    (%eax),%dl
f0112ca0:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0112ca6:	38 c2                	cmp    %al,%dl
f0112ca8:	75 30                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112caa:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112cad:	8a 00                	mov    (%eax),%al
f0112caf:	3c 65                	cmp    $0x65,%al
f0112cb1:	75 27                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112cb3:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112cb6:	8a 10                	mov    (%eax),%dl
f0112cb8:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0112cbe:	38 c2                	cmp    %al,%dl
f0112cc0:	75 18                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112cc2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112cc5:	8a 00                	mov    (%eax),%al
f0112cc7:	3c 66                	cmp    $0x66,%al
f0112cc9:	75 0f                	jne    f0112cda <test_copy_paste_chunk+0x55c>
f0112ccb:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112cce:	8a 10                	mov    (%eax),%dl
f0112cd0:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0112cd6:	38 c2                	cmp    %al,%dl
f0112cd8:	74 21                	je     f0112cfb <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112cda:	83 ec 04             	sub    $0x4,%esp
f0112cdd:	68 f8 92 12 f0       	push   $0xf01292f8
f0112ce2:	68 0f 03 00 00       	push   $0x30f
f0112ce7:	68 02 8b 12 f0       	push   $0xf0128b02
f0112cec:	e8 e5 d7 fe ff       	call   f01004d6 <_warn>
f0112cf1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112cf4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112cfb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112cff:	74 04                	je     f0112d05 <test_copy_paste_chunk+0x587>
f0112d01:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112d05:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0112d0c:	83 ec 0c             	sub    $0xc,%esp
f0112d0f:	68 32 93 12 f0       	push   $0xf0129332
f0112d14:	e8 72 e2 fe ff       	call   f0100f8b <cprintf>
f0112d19:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0112d1c:	83 ec 0c             	sub    $0xc,%esp
f0112d1f:	68 44 93 12 f0       	push   $0xf0129344
f0112d24:	e8 62 e2 fe ff       	call   f0100f8b <cprintf>
f0112d29:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0112d2c:	83 ec 04             	sub    $0x4,%esp
f0112d2f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d35:	50                   	push   %eax
f0112d36:	68 7a 93 12 f0       	push   $0xf012937a
f0112d3b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112d41:	50                   	push   %eax
f0112d42:	e8 fc cd 00 00       	call   f011fb43 <strcconcat>
f0112d47:	83 c4 10             	add    $0x10,%esp
f0112d4a:	83 ec 0c             	sub    $0xc,%esp
f0112d4d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d53:	50                   	push   %eax
f0112d54:	e8 a2 f1 fe ff       	call   f0101efb <execute_command>
f0112d59:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0112d5c:	83 ec 04             	sub    $0x4,%esp
f0112d5f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d65:	50                   	push   %eax
f0112d66:	68 84 93 12 f0       	push   $0xf0129384
f0112d6b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112d71:	50                   	push   %eax
f0112d72:	e8 cc cd 00 00       	call   f011fb43 <strcconcat>
f0112d77:	83 c4 10             	add    $0x10,%esp
f0112d7a:	83 ec 0c             	sub    $0xc,%esp
f0112d7d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d83:	50                   	push   %eax
f0112d84:	e8 72 f1 fe ff       	call   f0101efb <execute_command>
f0112d89:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0112d8c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112d92:	bb fd 98 12 f0       	mov    $0xf01298fd,%ebx
f0112d97:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d9c:	89 c7                	mov    %eax,%edi
f0112d9e:	89 de                	mov    %ebx,%esi
f0112da0:	89 d1                	mov    %edx,%ecx
f0112da2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112da4:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112daa:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112daf:	b0 00                	mov    $0x0,%al
f0112db1:	89 d7                	mov    %edx,%edi
f0112db3:	f3 aa                	rep stos %al,%es:(%edi)
f0112db5:	83 ec 0c             	sub    $0xc,%esp
f0112db8:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112dbe:	50                   	push   %eax
f0112dbf:	e8 37 f1 fe ff       	call   f0101efb <execute_command>
f0112dc4:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0112dc7:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112dcd:	bb 61 99 12 f0       	mov    $0xf0129961,%ebx
f0112dd2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112dd7:	89 c7                	mov    %eax,%edi
f0112dd9:	89 de                	mov    %ebx,%esi
f0112ddb:	89 d1                	mov    %edx,%ecx
f0112ddd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ddf:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112de5:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112dea:	b0 00                	mov    $0x0,%al
f0112dec:	89 d7                	mov    %edx,%edi
f0112dee:	f3 aa                	rep stos %al,%es:(%edi)
f0112df0:	83 ec 0c             	sub    $0xc,%esp
f0112df3:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112df9:	50                   	push   %eax
f0112dfa:	e8 fc f0 fe ff       	call   f0101efb <execute_command>
f0112dff:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0112e02:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112e08:	bb c5 99 12 f0       	mov    $0xf01299c5,%ebx
f0112e0d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e12:	89 c7                	mov    %eax,%edi
f0112e14:	89 de                	mov    %ebx,%esi
f0112e16:	89 d1                	mov    %edx,%ecx
f0112e18:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e1a:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112e20:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e25:	b0 00                	mov    $0x0,%al
f0112e27:	89 d7                	mov    %edx,%edi
f0112e29:	f3 aa                	rep stos %al,%es:(%edi)
f0112e2b:	83 ec 0c             	sub    $0xc,%esp
f0112e2e:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112e34:	50                   	push   %eax
f0112e35:	e8 c1 f0 fe ff       	call   f0101efb <execute_command>
f0112e3a:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0112e3d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112e43:	bb 29 9a 12 f0       	mov    $0xf0129a29,%ebx
f0112e48:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e4d:	89 c7                	mov    %eax,%edi
f0112e4f:	89 de                	mov    %ebx,%esi
f0112e51:	89 d1                	mov    %edx,%ecx
f0112e53:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e55:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0112e5b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e60:	b0 00                	mov    $0x0,%al
f0112e62:	89 d7                	mov    %edx,%edi
f0112e64:	f3 aa                	rep stos %al,%es:(%edi)
f0112e66:	83 ec 0c             	sub    $0xc,%esp
f0112e69:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112e6f:	50                   	push   %eax
f0112e70:	e8 86 f0 fe ff       	call   f0101efb <execute_command>
f0112e75:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0112e78:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112e7e:	bb 8d 9a 12 f0       	mov    $0xf0129a8d,%ebx
f0112e83:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e88:	89 c7                	mov    %eax,%edi
f0112e8a:	89 de                	mov    %ebx,%esi
f0112e8c:	89 d1                	mov    %edx,%ecx
f0112e8e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e90:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0112e96:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e9b:	b0 00                	mov    $0x0,%al
f0112e9d:	89 d7                	mov    %edx,%edi
f0112e9f:	f3 aa                	rep stos %al,%es:(%edi)
f0112ea1:	83 ec 0c             	sub    $0xc,%esp
f0112ea4:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112eaa:	50                   	push   %eax
f0112eab:	e8 4b f0 fe ff       	call   f0101efb <execute_command>
f0112eb0:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0112eb3:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112eb9:	bb f1 9a 12 f0       	mov    $0xf0129af1,%ebx
f0112ebe:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ec3:	89 c7                	mov    %eax,%edi
f0112ec5:	89 de                	mov    %ebx,%esi
f0112ec7:	89 d1                	mov    %edx,%ecx
f0112ec9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112ecb:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112ed1:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112ed6:	b0 00                	mov    $0x0,%al
f0112ed8:	89 d7                	mov    %edx,%edi
f0112eda:	f3 aa                	rep stos %al,%es:(%edi)
f0112edc:	83 ec 0c             	sub    $0xc,%esp
f0112edf:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112ee5:	50                   	push   %eax
f0112ee6:	e8 10 f0 fe ff       	call   f0101efb <execute_command>
f0112eeb:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0112eee:	83 ec 04             	sub    $0x4,%esp
f0112ef1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112ef7:	50                   	push   %eax
f0112ef8:	68 8e 93 12 f0       	push   $0xf012938e
f0112efd:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f03:	50                   	push   %eax
f0112f04:	e8 3a cc 00 00       	call   f011fb43 <strcconcat>
f0112f09:	83 c4 10             	add    $0x10,%esp
f0112f0c:	83 ec 0c             	sub    $0xc,%esp
f0112f0f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112f15:	50                   	push   %eax
f0112f16:	e8 e0 ef fe ff       	call   f0101efb <execute_command>
f0112f1b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0112f1e:	83 ec 04             	sub    $0x4,%esp
f0112f21:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112f27:	50                   	push   %eax
f0112f28:	68 98 93 12 f0       	push   $0xf0129398
f0112f2d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112f33:	50                   	push   %eax
f0112f34:	e8 0a cc 00 00       	call   f011fb43 <strcconcat>
f0112f39:	83 c4 10             	add    $0x10,%esp
f0112f3c:	83 ec 0c             	sub    $0xc,%esp
f0112f3f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112f45:	50                   	push   %eax
f0112f46:	e8 b0 ef fe ff       	call   f0101efb <execute_command>
f0112f4b:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0112f4e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112f54:	bb 55 9b 12 f0       	mov    $0xf0129b55,%ebx
f0112f59:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f5e:	89 c7                	mov    %eax,%edi
f0112f60:	89 de                	mov    %ebx,%esi
f0112f62:	89 d1                	mov    %edx,%ecx
f0112f64:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f66:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112f6c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f71:	b0 00                	mov    $0x0,%al
f0112f73:	89 d7                	mov    %edx,%edi
f0112f75:	f3 aa                	rep stos %al,%es:(%edi)
f0112f77:	83 ec 0c             	sub    $0xc,%esp
f0112f7a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112f80:	50                   	push   %eax
f0112f81:	e8 75 ef fe ff       	call   f0101efb <execute_command>
f0112f86:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0112f89:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112f8f:	bb b9 9b 12 f0       	mov    $0xf0129bb9,%ebx
f0112f94:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f99:	89 c7                	mov    %eax,%edi
f0112f9b:	89 de                	mov    %ebx,%esi
f0112f9d:	89 d1                	mov    %edx,%ecx
f0112f9f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112fa1:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112fa7:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fac:	b0 00                	mov    $0x0,%al
f0112fae:	89 d7                	mov    %edx,%edi
f0112fb0:	f3 aa                	rep stos %al,%es:(%edi)
f0112fb2:	83 ec 0c             	sub    $0xc,%esp
f0112fb5:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112fbb:	50                   	push   %eax
f0112fbc:	e8 3a ef fe ff       	call   f0101efb <execute_command>
f0112fc1:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0112fc4:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112fca:	bb 1d 9c 12 f0       	mov    $0xf0129c1d,%ebx
f0112fcf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112fd4:	89 c7                	mov    %eax,%edi
f0112fd6:	89 de                	mov    %ebx,%esi
f0112fd8:	89 d1                	mov    %edx,%ecx
f0112fda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112fdc:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112fe2:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112fe7:	b0 00                	mov    $0x0,%al
f0112fe9:	89 d7                	mov    %edx,%edi
f0112feb:	f3 aa                	rep stos %al,%es:(%edi)
f0112fed:	83 ec 0c             	sub    $0xc,%esp
f0112ff0:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112ff6:	50                   	push   %eax
f0112ff7:	e8 ff ee fe ff       	call   f0101efb <execute_command>
f0112ffc:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0112fff:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113006:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f011300d:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113014:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f011301b:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113022:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113029:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113030:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113037:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f011303e:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113045:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f011304c:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113053:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113056:	8a 00                	mov    (%eax),%al
f0113058:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011305e:	e8 47 b2 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113063:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113066:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113069:	89 d0                	mov    %edx,%eax
f011306b:	01 c0                	add    %eax,%eax
f011306d:	01 d0                	add    %edx,%eax
f011306f:	01 c0                	add    %eax,%eax
f0113071:	50                   	push   %eax
f0113072:	68 00 00 40 00       	push   $0x400000
f0113077:	68 00 00 20 00       	push   $0x200000
f011307c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011307f:	e8 df 73 ff ff       	call   f010a463 <copy_paste_chunk>
f0113084:	83 c4 10             	add    $0x10,%esp
f0113087:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011308a:	e8 1b b2 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011308f:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113092:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113099:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f011309d:	75 08                	jne    f01130a7 <test_copy_paste_chunk+0x929>
f011309f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01130a2:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01130a5:	74 2b                	je     f01130d2 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01130a7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01130aa:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01130ad:	83 ec 0c             	sub    $0xc,%esp
f01130b0:	50                   	push   %eax
f01130b1:	ff 75 80             	pushl  -0x80(%ebp)
f01130b4:	68 a4 93 12 f0       	push   $0xf01293a4
f01130b9:	68 3f 03 00 00       	push   $0x33f
f01130be:	68 02 8b 12 f0       	push   $0xf0128b02
f01130c3:	e8 0e d4 fe ff       	call   f01004d6 <_warn>
f01130c8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01130cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01130d2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01130d6:	74 04                	je     f01130dc <test_copy_paste_chunk+0x95e>
f01130d8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01130dc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f01130e3:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f01130ea:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01130ed:	83 ec 08             	sub    $0x8,%esp
f01130f0:	6a 01                	push   $0x1
f01130f2:	6a 07                	push   $0x7
f01130f4:	6a 07                	push   $0x7
f01130f6:	6a 07                	push   $0x7
f01130f8:	6a 07                	push   $0x7
f01130fa:	6a 01                	push   $0x1
f01130fc:	68 00 20 00 00       	push   $0x2000
f0113101:	68 00 00 40 00       	push   $0x400000
f0113106:	68 00 00 20 00       	push   $0x200000
f011310b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011310e:	e8 bf 32 00 00       	call   f01163d2 <CCP>
f0113113:	83 c4 30             	add    $0x30,%esp
f0113116:	83 f8 01             	cmp    $0x1,%eax
f0113119:	74 2b                	je     f0113146 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f011311b:	83 ec 04             	sub    $0x4,%esp
f011311e:	68 f8 93 12 f0       	push   $0xf01293f8
f0113123:	68 48 03 00 00       	push   $0x348
f0113128:	68 02 8b 12 f0       	push   $0xf0128b02
f011312d:	e8 a4 d3 fe ff       	call   f01004d6 <_warn>
f0113132:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113135:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f011313c:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113143:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113146:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011314a:	74 04                	je     f0113150 <test_copy_paste_chunk+0x9d2>
f011314c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113150:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113157:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011315a:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011315d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113160:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113163:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113166:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113169:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011316c:	8a 00                	mov    (%eax),%al
f011316e:	3c 61                	cmp    $0x61,%al
f0113170:	75 69                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f0113172:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113175:	8a 00                	mov    (%eax),%al
f0113177:	3c 61                	cmp    $0x61,%al
f0113179:	75 60                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f011317b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011317e:	8a 00                	mov    (%eax),%al
f0113180:	3c 79                	cmp    $0x79,%al
f0113182:	75 57                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f0113184:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113187:	8a 00                	mov    (%eax),%al
f0113189:	3c 62                	cmp    $0x62,%al
f011318b:	75 4e                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f011318d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113190:	8a 00                	mov    (%eax),%al
f0113192:	3c 63                	cmp    $0x63,%al
f0113194:	75 45                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f0113196:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113199:	8a 00                	mov    (%eax),%al
f011319b:	3c 7a                	cmp    $0x7a,%al
f011319d:	75 3c                	jne    f01131db <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f011319f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01131a2:	8a 00                	mov    (%eax),%al
f01131a4:	3c 77                	cmp    $0x77,%al
f01131a6:	75 33                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f01131a8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01131ab:	8a 00                	mov    (%eax),%al
f01131ad:	3c 64                	cmp    $0x64,%al
f01131af:	75 2a                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f01131b1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01131b4:	8a 00                	mov    (%eax),%al
f01131b6:	3c 65                	cmp    $0x65,%al
f01131b8:	75 21                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f01131ba:	8b 45 98             	mov    -0x68(%ebp),%eax
f01131bd:	8a 00                	mov    (%eax),%al
f01131bf:	3c 65                	cmp    $0x65,%al
f01131c1:	75 18                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f01131c3:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01131c6:	8a 00                	mov    (%eax),%al
f01131c8:	3c 66                	cmp    $0x66,%al
f01131ca:	75 0f                	jne    f01131db <test_copy_paste_chunk+0xa5d>
f01131cc:	8b 45 90             	mov    -0x70(%ebp),%eax
f01131cf:	8a 10                	mov    (%eax),%dl
f01131d1:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01131d7:	38 c2                	cmp    %al,%dl
f01131d9:	74 21                	je     f01131fc <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01131db:	83 ec 04             	sub    $0x4,%esp
f01131de:	68 f8 92 12 f0       	push   $0xf01292f8
f01131e3:	68 56 03 00 00       	push   $0x356
f01131e8:	68 02 8b 12 f0       	push   $0xf0128b02
f01131ed:	e8 e4 d2 fe ff       	call   f01004d6 <_warn>
f01131f2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01131f5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01131fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113200:	74 04                	je     f0113206 <test_copy_paste_chunk+0xa88>
f0113202:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113206:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f011320d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113210:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113213:	e8 92 b0 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113218:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f011321b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011321e:	89 c2                	mov    %eax,%edx
f0113220:	01 d2                	add    %edx,%edx
f0113222:	01 d0                	add    %edx,%eax
f0113224:	50                   	push   %eax
f0113225:	68 00 08 20 00       	push   $0x200800
f011322a:	68 00 08 40 00       	push   $0x400800
f011322f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113232:	e8 2c 72 ff ff       	call   f010a463 <copy_paste_chunk>
f0113237:	83 c4 10             	add    $0x10,%esp
f011323a:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011323d:	e8 68 b0 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113242:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113245:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113249:	75 08                	jne    f0113253 <test_copy_paste_chunk+0xad5>
f011324b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011324e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113251:	74 2b                	je     f011327e <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113253:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113256:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113259:	83 ec 0c             	sub    $0xc,%esp
f011325c:	50                   	push   %eax
f011325d:	ff 75 80             	pushl  -0x80(%ebp)
f0113260:	68 a4 93 12 f0       	push   $0xf01293a4
f0113265:	68 66 03 00 00       	push   $0x366
f011326a:	68 02 8b 12 f0       	push   $0xf0128b02
f011326f:	e8 62 d2 fe ff       	call   f01004d6 <_warn>
f0113274:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113277:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011327e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113282:	74 04                	je     f0113288 <test_copy_paste_chunk+0xb0a>
f0113284:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113288:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f011328f:	83 ec 08             	sub    $0x8,%esp
f0113292:	6a 01                	push   $0x1
f0113294:	6a 07                	push   $0x7
f0113296:	6a 07                	push   $0x7
f0113298:	6a 07                	push   $0x7
f011329a:	6a 07                	push   $0x7
f011329c:	6a 01                	push   $0x1
f011329e:	68 00 20 00 00       	push   $0x2000
f01132a3:	68 00 00 20 00       	push   $0x200000
f01132a8:	68 00 00 40 00       	push   $0x400000
f01132ad:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132b0:	e8 1d 31 00 00       	call   f01163d2 <CCP>
f01132b5:	83 c4 30             	add    $0x30,%esp
f01132b8:	83 f8 01             	cmp    $0x1,%eax
f01132bb:	74 21                	je     f01132de <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01132bd:	83 ec 04             	sub    $0x4,%esp
f01132c0:	68 44 94 12 f0       	push   $0xf0129444
f01132c5:	68 6e 03 00 00       	push   $0x36e
f01132ca:	68 02 8b 12 f0       	push   $0xf0128b02
f01132cf:	e8 02 d2 fe ff       	call   f01004d6 <_warn>
f01132d4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01132d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01132de:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01132e2:	74 04                	je     f01132e8 <test_copy_paste_chunk+0xb6a>
f01132e4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01132e8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01132ef:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01132f2:	8a 00                	mov    (%eax),%al
f01132f4:	3c 61                	cmp    $0x61,%al
f01132f6:	75 69                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f01132f8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01132fb:	8a 00                	mov    (%eax),%al
f01132fd:	3c 61                	cmp    $0x61,%al
f01132ff:	75 60                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f0113301:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113304:	8a 00                	mov    (%eax),%al
f0113306:	3c 79                	cmp    $0x79,%al
f0113308:	75 57                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f011330a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011330d:	8a 00                	mov    (%eax),%al
f011330f:	3c 62                	cmp    $0x62,%al
f0113311:	75 4e                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f0113313:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113316:	8a 00                	mov    (%eax),%al
f0113318:	3c 7a                	cmp    $0x7a,%al
f011331a:	75 45                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f011331c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011331f:	8a 00                	mov    (%eax),%al
f0113321:	3c 7a                	cmp    $0x7a,%al
f0113323:	75 3c                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113325:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113328:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011332a:	3c 64                	cmp    $0x64,%al
f011332c:	75 33                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011332e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113331:	8a 00                	mov    (%eax),%al
f0113333:	3c 64                	cmp    $0x64,%al
f0113335:	75 2a                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f0113337:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011333a:	8a 00                	mov    (%eax),%al
f011333c:	3c 65                	cmp    $0x65,%al
f011333e:	75 21                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f0113340:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113343:	8a 00                	mov    (%eax),%al
f0113345:	3c 78                	cmp    $0x78,%al
f0113347:	75 18                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f0113349:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011334c:	8a 00                	mov    (%eax),%al
f011334e:	3c 66                	cmp    $0x66,%al
f0113350:	75 0f                	jne    f0113361 <test_copy_paste_chunk+0xbe3>
f0113352:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113355:	8a 10                	mov    (%eax),%dl
f0113357:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011335d:	38 c2                	cmp    %al,%dl
f011335f:	74 21                	je     f0113382 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113361:	83 ec 04             	sub    $0x4,%esp
f0113364:	68 f8 92 12 f0       	push   $0xf01292f8
f0113369:	68 77 03 00 00       	push   $0x377
f011336e:	68 02 8b 12 f0       	push   $0xf0128b02
f0113373:	e8 5e d1 fe ff       	call   f01004d6 <_warn>
f0113378:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011337b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113382:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113386:	74 04                	je     f011338c <test_copy_paste_chunk+0xc0e>
f0113388:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011338c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113393:	83 ec 0c             	sub    $0xc,%esp
f0113396:	68 8f 94 12 f0       	push   $0xf012948f
f011339b:	e8 eb db fe ff       	call   f0100f8b <cprintf>
f01133a0:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01133a3:	83 ec 0c             	sub    $0xc,%esp
f01133a6:	68 a0 94 12 f0       	push   $0xf01294a0
f01133ab:	e8 db db fe ff       	call   f0100f8b <cprintf>
f01133b0:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f01133b3:	83 ec 04             	sub    $0x4,%esp
f01133b6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01133bc:	50                   	push   %eax
f01133bd:	68 d4 94 12 f0       	push   $0xf01294d4
f01133c2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01133c8:	50                   	push   %eax
f01133c9:	e8 75 c7 00 00       	call   f011fb43 <strcconcat>
f01133ce:	83 c4 10             	add    $0x10,%esp
f01133d1:	83 ec 0c             	sub    $0xc,%esp
f01133d4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01133da:	50                   	push   %eax
f01133db:	e8 1b eb fe ff       	call   f0101efb <execute_command>
f01133e0:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f01133e3:	83 ec 04             	sub    $0x4,%esp
f01133e6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01133ec:	50                   	push   %eax
f01133ed:	68 de 94 12 f0       	push   $0xf01294de
f01133f2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01133f8:	50                   	push   %eax
f01133f9:	e8 45 c7 00 00       	call   f011fb43 <strcconcat>
f01133fe:	83 c4 10             	add    $0x10,%esp
f0113401:	83 ec 0c             	sub    $0xc,%esp
f0113404:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011340a:	50                   	push   %eax
f011340b:	e8 eb ea fe ff       	call   f0101efb <execute_command>
f0113410:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113413:	83 ec 04             	sub    $0x4,%esp
f0113416:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011341c:	50                   	push   %eax
f011341d:	68 e8 94 12 f0       	push   $0xf01294e8
f0113422:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113428:	50                   	push   %eax
f0113429:	e8 15 c7 00 00       	call   f011fb43 <strcconcat>
f011342e:	83 c4 10             	add    $0x10,%esp
f0113431:	83 ec 0c             	sub    $0xc,%esp
f0113434:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011343a:	50                   	push   %eax
f011343b:	e8 bb ea fe ff       	call   f0101efb <execute_command>
f0113440:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113443:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113449:	bb 81 9c 12 f0       	mov    $0xf0129c81,%ebx
f011344e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113453:	89 c7                	mov    %eax,%edi
f0113455:	89 de                	mov    %ebx,%esi
f0113457:	89 d1                	mov    %edx,%ecx
f0113459:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011345b:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113461:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113466:	b0 00                	mov    $0x0,%al
f0113468:	89 d7                	mov    %edx,%edi
f011346a:	f3 aa                	rep stos %al,%es:(%edi)
f011346c:	83 ec 0c             	sub    $0xc,%esp
f011346f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113475:	50                   	push   %eax
f0113476:	e8 80 ea fe ff       	call   f0101efb <execute_command>
f011347b:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f011347e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113484:	bb e5 9c 12 f0       	mov    $0xf0129ce5,%ebx
f0113489:	ba 0f 00 00 00       	mov    $0xf,%edx
f011348e:	89 c7                	mov    %eax,%edi
f0113490:	89 de                	mov    %ebx,%esi
f0113492:	89 d1                	mov    %edx,%ecx
f0113494:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113496:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011349c:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134a1:	b0 00                	mov    $0x0,%al
f01134a3:	89 d7                	mov    %edx,%edi
f01134a5:	f3 aa                	rep stos %al,%es:(%edi)
f01134a7:	83 ec 0c             	sub    $0xc,%esp
f01134aa:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01134b0:	50                   	push   %eax
f01134b1:	e8 45 ea fe ff       	call   f0101efb <execute_command>
f01134b6:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f01134b9:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01134bf:	bb 49 9d 12 f0       	mov    $0xf0129d49,%ebx
f01134c4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134c9:	89 c7                	mov    %eax,%edi
f01134cb:	89 de                	mov    %ebx,%esi
f01134cd:	89 d1                	mov    %edx,%ecx
f01134cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134d1:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01134d7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134dc:	b0 00                	mov    $0x0,%al
f01134de:	89 d7                	mov    %edx,%edi
f01134e0:	f3 aa                	rep stos %al,%es:(%edi)
f01134e2:	83 ec 0c             	sub    $0xc,%esp
f01134e5:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01134eb:	50                   	push   %eax
f01134ec:	e8 0a ea fe ff       	call   f0101efb <execute_command>
f01134f1:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01134f4:	e8 b1 ad ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01134f9:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f01134fc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01134ff:	89 d0                	mov    %edx,%eax
f0113501:	01 c0                	add    %eax,%eax
f0113503:	01 d0                	add    %edx,%eax
f0113505:	c1 e0 02             	shl    $0x2,%eax
f0113508:	50                   	push   %eax
f0113509:	68 00 00 90 00       	push   $0x900000
f011350e:	68 00 00 80 00       	push   $0x800000
f0113513:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113516:	e8 48 6f ff ff       	call   f010a463 <copy_paste_chunk>
f011351b:	83 c4 10             	add    $0x10,%esp
f011351e:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113524:	e8 81 ad ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113529:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011352c:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113533:	75 0b                	jne    f0113540 <test_copy_paste_chunk+0xdc2>
f0113535:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113538:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011353b:	83 f8 03             	cmp    $0x3,%eax
f011353e:	74 2e                	je     f011356e <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113540:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113543:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113546:	83 ec 0c             	sub    $0xc,%esp
f0113549:	50                   	push   %eax
f011354a:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113550:	68 a4 93 12 f0       	push   $0xf01293a4
f0113555:	68 95 03 00 00       	push   $0x395
f011355a:	68 02 8b 12 f0       	push   $0xf0128b02
f011355f:	e8 72 cf fe ff       	call   f01004d6 <_warn>
f0113564:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113567:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011356e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113572:	74 04                	je     f0113578 <test_copy_paste_chunk+0xdfa>
f0113574:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113578:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f011357f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113586:	83 ec 08             	sub    $0x8,%esp
f0113589:	6a 01                	push   $0x1
f011358b:	6a 07                	push   $0x7
f011358d:	6a 07                	push   $0x7
f011358f:	6a 07                	push   $0x7
f0113591:	6a 07                	push   $0x7
f0113593:	6a 01                	push   $0x1
f0113595:	68 00 30 00 00       	push   $0x3000
f011359a:	68 00 00 90 00       	push   $0x900000
f011359f:	68 00 00 80 00       	push   $0x800000
f01135a4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01135a7:	e8 26 2e 00 00       	call   f01163d2 <CCP>
f01135ac:	83 c4 30             	add    $0x30,%esp
f01135af:	83 f8 01             	cmp    $0x1,%eax
f01135b2:	74 28                	je     f01135dc <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01135b4:	83 ec 04             	sub    $0x4,%esp
f01135b7:	68 44 94 12 f0       	push   $0xf0129444
f01135bc:	68 9e 03 00 00       	push   $0x39e
f01135c1:	68 02 8b 12 f0       	push   $0xf0128b02
f01135c6:	e8 0b cf fe ff       	call   f01004d6 <_warn>
f01135cb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01135ce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f01135d5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f01135dc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01135e0:	74 04                	je     f01135e6 <test_copy_paste_chunk+0xe68>
f01135e2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01135e6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01135ed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01135f1:	0f 84 9e 00 00 00    	je     f0113695 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f01135f7:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f01135fe:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113605:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f011360c:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113613:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f011361a:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113621:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113624:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113627:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011362a:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f011362d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113630:	8a 00                	mov    (%eax),%al
f0113632:	3c 61                	cmp    $0x61,%al
f0113634:	75 2d                	jne    f0113663 <test_copy_paste_chunk+0xee5>
f0113636:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113639:	8a 00                	mov    (%eax),%al
f011363b:	3c 61                	cmp    $0x61,%al
f011363d:	75 24                	jne    f0113663 <test_copy_paste_chunk+0xee5>
f011363f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113642:	8a 00                	mov    (%eax),%al
f0113644:	3c 79                	cmp    $0x79,%al
f0113646:	75 1b                	jne    f0113663 <test_copy_paste_chunk+0xee5>
f0113648:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011364b:	8a 00                	mov    (%eax),%al
f011364d:	3c 62                	cmp    $0x62,%al
f011364f:	75 12                	jne    f0113663 <test_copy_paste_chunk+0xee5>
f0113651:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113654:	8a 00                	mov    (%eax),%al
f0113656:	3c 63                	cmp    $0x63,%al
f0113658:	75 09                	jne    f0113663 <test_copy_paste_chunk+0xee5>
f011365a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011365d:	8a 00                	mov    (%eax),%al
f011365f:	3c 7a                	cmp    $0x7a,%al
f0113661:	74 21                	je     f0113684 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113663:	83 ec 04             	sub    $0x4,%esp
f0113666:	68 f8 92 12 f0       	push   $0xf01292f8
f011366b:	68 b0 03 00 00       	push   $0x3b0
f0113670:	68 02 8b 12 f0       	push   $0xf0128b02
f0113675:	e8 5c ce fe ff       	call   f01004d6 <_warn>
f011367a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011367d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113684:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113688:	74 04                	je     f011368e <test_copy_paste_chunk+0xf10>
f011368a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f011368e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113695:	e8 10 ac ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011369a:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f011369d:	6a 00                	push   $0x0
f011369f:	6a 02                	push   $0x2
f01136a1:	68 00 10 90 00       	push   $0x901000
f01136a6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136a9:	e8 b1 2b 00 00       	call   f011625f <SB>
f01136ae:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f01136b1:	6a 00                	push   $0x0
f01136b3:	6a 02                	push   $0x2
f01136b5:	68 00 20 90 00       	push   $0x902000
f01136ba:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136bd:	e8 9d 2b 00 00       	call   f011625f <SB>
f01136c2:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f01136c5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01136c8:	c1 e0 03             	shl    $0x3,%eax
f01136cb:	50                   	push   %eax
f01136cc:	68 00 f0 bf 00       	push   $0xbff000
f01136d1:	68 00 10 90 00       	push   $0x901000
f01136d6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136d9:	e8 85 6d ff ff       	call   f010a463 <copy_paste_chunk>
f01136de:	83 c4 10             	add    $0x10,%esp
f01136e1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01136e7:	e8 be ab ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01136ec:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f01136ef:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01136f6:	75 0b                	jne    f0113703 <test_copy_paste_chunk+0xf85>
f01136f8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01136fb:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01136fe:	83 f8 03             	cmp    $0x3,%eax
f0113701:	74 2e                	je     f0113731 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113703:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113706:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113709:	83 ec 0c             	sub    $0xc,%esp
f011370c:	50                   	push   %eax
f011370d:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113713:	68 a4 93 12 f0       	push   $0xf01293a4
f0113718:	68 c0 03 00 00       	push   $0x3c0
f011371d:	68 02 8b 12 f0       	push   $0xf0128b02
f0113722:	e8 af cd fe ff       	call   f01004d6 <_warn>
f0113727:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011372a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113731:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113735:	74 04                	je     f011373b <test_copy_paste_chunk+0xfbd>
f0113737:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011373b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113742:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113749:	83 ec 08             	sub    $0x8,%esp
f011374c:	6a 01                	push   $0x1
f011374e:	6a 07                	push   $0x7
f0113750:	6a 03                	push   $0x3
f0113752:	6a 07                	push   $0x7
f0113754:	6a 03                	push   $0x3
f0113756:	6a 01                	push   $0x1
f0113758:	68 00 20 00 00       	push   $0x2000
f011375d:	68 00 f0 bf 00       	push   $0xbff000
f0113762:	68 00 10 90 00       	push   $0x901000
f0113767:	ff 75 d4             	pushl  -0x2c(%ebp)
f011376a:	e8 63 2c 00 00       	call   f01163d2 <CCP>
f011376f:	83 c4 30             	add    $0x30,%esp
f0113772:	83 f8 01             	cmp    $0x1,%eax
f0113775:	74 28                	je     f011379f <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113777:	83 ec 04             	sub    $0x4,%esp
f011377a:	68 44 94 12 f0       	push   $0xf0129444
f011377f:	68 c9 03 00 00       	push   $0x3c9
f0113784:	68 02 8b 12 f0       	push   $0xf0128b02
f0113789:	e8 48 cd fe ff       	call   f01004d6 <_warn>
f011378e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113791:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113798:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f011379f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01137a3:	74 04                	je     f01137a9 <test_copy_paste_chunk+0x102b>
f01137a5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01137a9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01137b0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01137b4:	74 72                	je     f0113828 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f01137b6:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f01137bd:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f01137c4:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f01137cb:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f01137d2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01137d5:	8a 00                	mov    (%eax),%al
f01137d7:	3c 62                	cmp    $0x62,%al
f01137d9:	75 1b                	jne    f01137f6 <test_copy_paste_chunk+0x1078>
f01137db:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01137de:	8a 00                	mov    (%eax),%al
f01137e0:	3c 62                	cmp    $0x62,%al
f01137e2:	75 12                	jne    f01137f6 <test_copy_paste_chunk+0x1078>
f01137e4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01137e7:	8a 00                	mov    (%eax),%al
f01137e9:	3c 7a                	cmp    $0x7a,%al
f01137eb:	75 09                	jne    f01137f6 <test_copy_paste_chunk+0x1078>
f01137ed:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01137f0:	8a 00                	mov    (%eax),%al
f01137f2:	3c 7a                	cmp    $0x7a,%al
f01137f4:	74 21                	je     f0113817 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01137f6:	83 ec 04             	sub    $0x4,%esp
f01137f9:	68 f8 92 12 f0       	push   $0xf01292f8
f01137fe:	68 d5 03 00 00       	push   $0x3d5
f0113803:	68 02 8b 12 f0       	push   $0xf0128b02
f0113808:	e8 c9 cc fe ff       	call   f01004d6 <_warn>
f011380d:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113810:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113817:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011381b:	74 04                	je     f0113821 <test_copy_paste_chunk+0x10a3>
f011381d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113821:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113828:	83 ec 0c             	sub    $0xc,%esp
f011382b:	68 f2 94 12 f0       	push   $0xf01294f2
f0113830:	e8 56 d7 fe ff       	call   f0100f8b <cprintf>
f0113835:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113838:	83 ec 08             	sub    $0x8,%esp
f011383b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011383e:	68 04 95 12 f0       	push   $0xf0129504
f0113843:	e8 43 d7 fe ff       	call   f0100f8b <cprintf>
f0113848:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011384b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011384f:	75 10                	jne    f0113861 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113851:	83 ec 0c             	sub    $0xc,%esp
f0113854:	68 38 95 12 f0       	push   $0xf0129538
f0113859:	e8 2d d7 fe ff       	call   f0100f8b <cprintf>
f011385e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113861:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0113866:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113869:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011386c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011386f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113874:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113877:	5b                   	pop    %ebx
f0113878:	5e                   	pop    %esi
f0113879:	5f                   	pop    %edi
f011387a:	5d                   	pop    %ebp
f011387b:	c3                   	ret    

f011387c <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f011387c:	55                   	push   %ebp
f011387d:	89 e5                	mov    %esp,%ebp
f011387f:	57                   	push   %edi
f0113880:	56                   	push   %esi
f0113881:	53                   	push   %ebx
f0113882:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113888:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011388e:	bb 04 92 12 f0       	mov    $0xf0129204,%ebx
f0113893:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113898:	89 c7                	mov    %eax,%edi
f011389a:	89 de                	mov    %ebx,%esi
f011389c:	89 d1                	mov    %edx,%ecx
f011389e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138a0:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f01138a6:	b9 23 00 00 00       	mov    $0x23,%ecx
f01138ab:	b0 00                	mov    $0x0,%al
f01138ad:	89 d7                	mov    %edx,%edi
f01138af:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01138b1:	6a 00                	push   $0x0
f01138b3:	6a 0a                	push   $0xa
f01138b5:	6a 14                	push   $0x14
f01138b7:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f01138bd:	50                   	push   %eax
f01138be:	e8 47 70 ff ff       	call   f010a90a <env_create>
f01138c3:	83 c4 10             	add    $0x10,%esp
f01138c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01138c9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01138cc:	8b 40 64             	mov    0x64(%eax),%eax
f01138cf:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01138d2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01138d5:	8b 40 68             	mov    0x68(%eax),%eax
f01138d8:	89 45 80             	mov    %eax,-0x80(%ebp)
f01138db:	8b 45 80             	mov    -0x80(%ebp),%eax
f01138de:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f01138e1:	83 ec 0c             	sub    $0xc,%esp
f01138e4:	ff 75 cc             	pushl  -0x34(%ebp)
f01138e7:	e8 b2 2a 00 00       	call   f011639e <ClearUserSpace>
f01138ec:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01138ef:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01138f6:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f01138fd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113904:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0113908:	83 ec 0c             	sub    $0xc,%esp
f011390b:	68 b0 9d 12 f0       	push   $0xf0129db0
f0113910:	e8 76 d6 fe ff       	call   f0100f8b <cprintf>
f0113915:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0113918:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f011391f:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113926:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113929:	8a 00                	mov    (%eax),%al
f011392b:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113931:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113934:	8a 00                	mov    (%eax),%al
f0113936:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011393c:	e8 69 a9 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113941:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0113944:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113947:	89 d0                	mov    %edx,%eax
f0113949:	01 c0                	add    %eax,%eax
f011394b:	01 d0                	add    %edx,%eax
f011394d:	01 c0                	add    %eax,%eax
f011394f:	83 ec 0c             	sub    $0xc,%esp
f0113952:	6a 02                	push   $0x2
f0113954:	50                   	push   %eax
f0113955:	68 00 40 10 f0       	push   $0xf0104000
f011395a:	68 00 00 10 f0       	push   $0xf0100000
f011395f:	ff 75 cc             	pushl  -0x34(%ebp)
f0113962:	e8 16 6b ff ff       	call   f010a47d <share_chunk>
f0113967:	83 c4 20             	add    $0x20,%esp
f011396a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011396d:	e8 38 a9 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113972:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113975:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0113979:	75 08                	jne    f0113983 <test_share_chunk+0x107>
f011397b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011397e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113981:	74 28                	je     f01139ab <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0113983:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113986:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113989:	83 ec 0c             	sub    $0xc,%esp
f011398c:	50                   	push   %eax
f011398d:	ff 75 b0             	pushl  -0x50(%ebp)
f0113990:	68 dc 9d 12 f0       	push   $0xf0129ddc
f0113995:	68 11 04 00 00       	push   $0x411
f011399a:	68 02 8b 12 f0       	push   $0xf0128b02
f011399f:	e8 32 cb fe ff       	call   f01004d6 <_warn>
f01139a4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01139a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01139ab:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01139af:	74 04                	je     f01139b5 <test_share_chunk+0x139>
f01139b1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01139b5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f01139b9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01139bc:	c1 e0 03             	shl    $0x3,%eax
f01139bf:	83 ec 08             	sub    $0x8,%esp
f01139c2:	68 fd 00 00 00       	push   $0xfd
f01139c7:	6a 07                	push   $0x7
f01139c9:	6a 03                	push   $0x3
f01139cb:	6a 07                	push   $0x7
f01139cd:	6a 03                	push   $0x3
f01139cf:	6a 01                	push   $0x1
f01139d1:	50                   	push   %eax
f01139d2:	68 00 40 10 f0       	push   $0xf0104000
f01139d7:	68 00 00 10 f0       	push   $0xf0100000
f01139dc:	ff 75 cc             	pushl  -0x34(%ebp)
f01139df:	e8 ee 29 00 00       	call   f01163d2 <CCP>
f01139e4:	83 c4 30             	add    $0x30,%esp
f01139e7:	85 c0                	test   %eax,%eax
f01139e9:	75 1e                	jne    f0113a09 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01139eb:	83 ec 04             	sub    $0x4,%esp
f01139ee:	68 38 9e 12 f0       	push   $0xf0129e38
f01139f3:	68 19 04 00 00       	push   $0x419
f01139f8:	68 02 8b 12 f0       	push   $0xf0128b02
f01139fd:	e8 d4 ca fe ff       	call   f01004d6 <_warn>
f0113a02:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a05:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113a09:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113a0d:	74 04                	je     f0113a13 <test_share_chunk+0x197>
f0113a0f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0113a13:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a16:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0113a19:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a1c:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0113a1f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a22:	8a 00                	mov    (%eax),%al
f0113a24:	3c 41                	cmp    $0x41,%al
f0113a26:	75 09                	jne    f0113a31 <test_share_chunk+0x1b5>
f0113a28:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a2b:	8a 00                	mov    (%eax),%al
f0113a2d:	3c 42                	cmp    $0x42,%al
f0113a2f:	74 1e                	je     f0113a4f <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113a31:	83 ec 04             	sub    $0x4,%esp
f0113a34:	68 80 9e 12 f0       	push   $0xf0129e80
f0113a39:	68 23 04 00 00       	push   $0x423
f0113a3e:	68 02 8b 12 f0       	push   $0xf0128b02
f0113a43:	e8 8e ca fe ff       	call   f01004d6 <_warn>
f0113a48:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113a4b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0113a4f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113a53:	74 04                	je     f0113a59 <test_share_chunk+0x1dd>
f0113a55:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113a59:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0113a5d:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0113a63:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a66:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0113a68:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0113a6e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a71:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0113a73:	83 ec 0c             	sub    $0xc,%esp
f0113a76:	68 b5 9e 12 f0       	push   $0xf0129eb5
f0113a7b:	e8 0b d5 fe ff       	call   f0100f8b <cprintf>
f0113a80:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0113a83:	83 ec 0c             	sub    $0xc,%esp
f0113a86:	68 c4 9e 12 f0       	push   $0xf0129ec4
f0113a8b:	e8 fb d4 fe ff       	call   f0100f8b <cprintf>
f0113a90:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113a93:	e8 12 a8 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113a98:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0113a9b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113a9e:	c1 e0 05             	shl    $0x5,%eax
f0113aa1:	83 ec 0c             	sub    $0xc,%esp
f0113aa4:	68 02 0e 00 00       	push   $0xe02
f0113aa9:	50                   	push   %eax
f0113aaa:	68 00 00 00 40       	push   $0x40000000
f0113aaf:	68 00 00 00 f0       	push   $0xf0000000
f0113ab4:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ab7:	e8 c1 69 ff ff       	call   f010a47d <share_chunk>
f0113abc:	83 c4 20             	add    $0x20,%esp
f0113abf:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ac2:	e8 e3 a7 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113ac7:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0113aca:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113ace:	75 1f                	jne    f0113aef <test_share_chunk+0x273>
f0113ad0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ad3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113ad6:	89 c1                	mov    %eax,%ecx
f0113ad8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113adb:	c1 e0 05             	shl    $0x5,%eax
f0113ade:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113ae1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113ae8:	99                   	cltd   
f0113ae9:	f7 fb                	idiv   %ebx
f0113aeb:	39 c1                	cmp    %eax,%ecx
f0113aed:	74 28                	je     f0113b17 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113aef:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113af2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113af5:	83 ec 0c             	sub    $0xc,%esp
f0113af8:	50                   	push   %eax
f0113af9:	ff 75 a8             	pushl  -0x58(%ebp)
f0113afc:	68 00 9f 12 f0       	push   $0xf0129f00
f0113b01:	68 3b 04 00 00       	push   $0x43b
f0113b06:	68 02 8b 12 f0       	push   $0xf0128b02
f0113b0b:	e8 c6 c9 fe ff       	call   f01004d6 <_warn>
f0113b10:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b13:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113b17:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113b1b:	74 04                	je     f0113b21 <test_share_chunk+0x2a5>
f0113b1d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b21:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113b25:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113b2c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b2f:	c1 e0 05             	shl    $0x5,%eax
f0113b32:	83 ec 08             	sub    $0x8,%esp
f0113b35:	6a 02                	push   $0x2
f0113b37:	6a 07                	push   $0x7
f0113b39:	6a 03                	push   $0x3
f0113b3b:	68 07 0e 00 00       	push   $0xe07
f0113b40:	68 03 0e 00 00       	push   $0xe03
f0113b45:	6a ff                	push   $0xffffffff
f0113b47:	50                   	push   %eax
f0113b48:	68 00 00 00 40       	push   $0x40000000
f0113b4d:	68 00 00 00 f0       	push   $0xf0000000
f0113b52:	ff 75 cc             	pushl  -0x34(%ebp)
f0113b55:	e8 78 28 00 00       	call   f01163d2 <CCP>
f0113b5a:	83 c4 30             	add    $0x30,%esp
f0113b5d:	85 c0                	test   %eax,%eax
f0113b5f:	75 25                	jne    f0113b86 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113b61:	83 ec 04             	sub    $0x4,%esp
f0113b64:	68 38 9e 12 f0       	push   $0xf0129e38
f0113b69:	68 44 04 00 00       	push   $0x444
f0113b6e:	68 02 8b 12 f0       	push   $0xf0128b02
f0113b73:	e8 5e c9 fe ff       	call   f01004d6 <_warn>
f0113b78:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113b7b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113b7f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113b86:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b89:	89 d0                	mov    %edx,%eax
f0113b8b:	01 c0                	add    %eax,%eax
f0113b8d:	01 d0                	add    %edx,%eax
f0113b8f:	c1 e0 02             	shl    $0x2,%eax
f0113b92:	83 ec 08             	sub    $0x8,%esp
f0113b95:	6a 02                	push   $0x2
f0113b97:	6a 07                	push   $0x7
f0113b99:	6a 03                	push   $0x3
f0113b9b:	68 07 0e 00 00       	push   $0xe07
f0113ba0:	68 03 0e 00 00       	push   $0xe03
f0113ba5:	6a 02                	push   $0x2
f0113ba7:	50                   	push   %eax
f0113ba8:	68 00 00 00 40       	push   $0x40000000
f0113bad:	68 00 00 00 f0       	push   $0xf0000000
f0113bb2:	ff 75 cc             	pushl  -0x34(%ebp)
f0113bb5:	e8 18 28 00 00       	call   f01163d2 <CCP>
f0113bba:	83 c4 30             	add    $0x30,%esp
f0113bbd:	85 c0                	test   %eax,%eax
f0113bbf:	75 1e                	jne    f0113bdf <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113bc1:	83 ec 04             	sub    $0x4,%esp
f0113bc4:	68 38 9e 12 f0       	push   $0xf0129e38
f0113bc9:	68 4b 04 00 00       	push   $0x44b
f0113bce:	68 02 8b 12 f0       	push   $0xf0128b02
f0113bd3:	e8 fe c8 fe ff       	call   f01004d6 <_warn>
f0113bd8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113bdb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113bdf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113be3:	74 04                	je     f0113be9 <test_share_chunk+0x36d>
f0113be5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113be9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0113bed:	b8 90 84 b0 f0       	mov    $0xf0b08490,%eax
f0113bf2:	05 00 00 00 10       	add    $0x10000000,%eax
f0113bf7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113bfa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113bfd:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0113c02:	83 ec 08             	sub    $0x8,%esp
f0113c05:	6a 02                	push   $0x2
f0113c07:	6a 07                	push   $0x7
f0113c09:	6a 03                	push   $0x3
f0113c0b:	68 07 0e 00 00       	push   $0xe07
f0113c10:	68 03 0e 00 00       	push   $0xe03
f0113c15:	6a 02                	push   $0x2
f0113c17:	50                   	push   %eax
f0113c18:	68 00 00 0a 40       	push   $0x400a0000
f0113c1d:	68 00 00 0a f0       	push   $0xf00a0000
f0113c22:	ff 75 cc             	pushl  -0x34(%ebp)
f0113c25:	e8 a8 27 00 00       	call   f01163d2 <CCP>
f0113c2a:	83 c4 30             	add    $0x30,%esp
f0113c2d:	85 c0                	test   %eax,%eax
f0113c2f:	75 1e                	jne    f0113c4f <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113c31:	83 ec 04             	sub    $0x4,%esp
f0113c34:	68 38 9e 12 f0       	push   $0xf0129e38
f0113c39:	68 55 04 00 00       	push   $0x455
f0113c3e:	68 02 8b 12 f0       	push   $0xf0128b02
f0113c43:	e8 8e c8 fe ff       	call   f01004d6 <_warn>
f0113c48:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c4b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113c4f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113c53:	74 04                	je     f0113c59 <test_share_chunk+0x3dd>
f0113c55:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c59:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113c5d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113c61:	0f 84 a4 00 00 00    	je     f0113d0b <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0113c67:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0113c6e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c71:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0113c74:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0113c7b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c7e:	8a 00                	mov    (%eax),%al
f0113c80:	3c 41                	cmp    $0x41,%al
f0113c82:	75 09                	jne    f0113c8d <test_share_chunk+0x411>
f0113c84:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113c87:	8a 00                	mov    (%eax),%al
f0113c89:	3c 41                	cmp    $0x41,%al
f0113c8b:	74 1e                	je     f0113cab <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113c8d:	83 ec 04             	sub    $0x4,%esp
f0113c90:	68 80 9e 12 f0       	push   $0xf0129e80
f0113c95:	68 62 04 00 00       	push   $0x462
f0113c9a:	68 02 8b 12 f0       	push   $0xf0128b02
f0113c9f:	e8 32 c8 fe ff       	call   f01004d6 <_warn>
f0113ca4:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113ca7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113cab:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113caf:	74 04                	je     f0113cb5 <test_share_chunk+0x439>
f0113cb1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113cb5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0113cb9:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0113cc0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113cc3:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0113cc6:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0113ccd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113cd0:	8a 00                	mov    (%eax),%al
f0113cd2:	3c 43                	cmp    $0x43,%al
f0113cd4:	75 09                	jne    f0113cdf <test_share_chunk+0x463>
f0113cd6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113cd9:	8a 00                	mov    (%eax),%al
f0113cdb:	3c 43                	cmp    $0x43,%al
f0113cdd:	74 1e                	je     f0113cfd <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113cdf:	83 ec 04             	sub    $0x4,%esp
f0113ce2:	68 80 9e 12 f0       	push   $0xf0129e80
f0113ce7:	68 6d 04 00 00       	push   $0x46d
f0113cec:	68 02 8b 12 f0       	push   $0xf0128b02
f0113cf1:	e8 e0 c7 fe ff       	call   f01004d6 <_warn>
f0113cf6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113cf9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113cfd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113d01:	74 04                	je     f0113d07 <test_share_chunk+0x48b>
f0113d03:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113d07:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0113d0b:	83 ec 0c             	sub    $0xc,%esp
f0113d0e:	68 8f 94 12 f0       	push   $0xf012948f
f0113d13:	e8 73 d2 fe ff       	call   f0100f8b <cprintf>
f0113d18:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0113d1b:	83 ec 0c             	sub    $0xc,%esp
f0113d1e:	68 50 9f 12 f0       	push   $0xf0129f50
f0113d23:	e8 63 d2 fe ff       	call   f0100f8b <cprintf>
f0113d28:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113d2b:	e8 7a a5 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113d30:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0113d33:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d36:	89 d0                	mov    %edx,%eax
f0113d38:	c1 e0 03             	shl    $0x3,%eax
f0113d3b:	01 d0                	add    %edx,%eax
f0113d3d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0113d44:	01 d0                	add    %edx,%eax
f0113d46:	c1 e0 03             	shl    $0x3,%eax
f0113d49:	83 ec 0c             	sub    $0xc,%esp
f0113d4c:	6a 06                	push   $0x6
f0113d4e:	50                   	push   %eax
f0113d4f:	6a 00                	push   $0x0
f0113d51:	68 00 00 00 40       	push   $0x40000000
f0113d56:	ff 75 cc             	pushl  -0x34(%ebp)
f0113d59:	e8 1f 67 ff ff       	call   f010a47d <share_chunk>
f0113d5e:	83 c4 20             	add    $0x20,%esp
f0113d61:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113d64:	e8 41 a5 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113d69:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0113d6c:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0113d70:	75 0b                	jne    f0113d7d <test_share_chunk+0x501>
f0113d72:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d75:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113d78:	83 f8 01             	cmp    $0x1,%eax
f0113d7b:	74 28                	je     f0113da5 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113d7d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d80:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113d83:	83 ec 0c             	sub    $0xc,%esp
f0113d86:	50                   	push   %eax
f0113d87:	ff 75 a0             	pushl  -0x60(%ebp)
f0113d8a:	68 00 9f 12 f0       	push   $0xf0129f00
f0113d8f:	68 83 04 00 00       	push   $0x483
f0113d94:	68 02 8b 12 f0       	push   $0xf0128b02
f0113d99:	e8 38 c7 fe ff       	call   f01004d6 <_warn>
f0113d9e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113da1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113da5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113da9:	74 04                	je     f0113daf <test_share_chunk+0x533>
f0113dab:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113daf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113db3:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113dba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113dbd:	05 00 80 02 00       	add    $0x28000,%eax
f0113dc2:	c1 e0 02             	shl    $0x2,%eax
f0113dc5:	83 ec 08             	sub    $0x8,%esp
f0113dc8:	6a 02                	push   $0x2
f0113dca:	6a 07                	push   $0x7
f0113dcc:	6a 03                	push   $0x3
f0113dce:	6a 07                	push   $0x7
f0113dd0:	6a 07                	push   $0x7
f0113dd2:	6a ff                	push   $0xffffffff
f0113dd4:	50                   	push   %eax
f0113dd5:	6a 00                	push   $0x0
f0113dd7:	68 00 00 00 40       	push   $0x40000000
f0113ddc:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ddf:	e8 ee 25 00 00       	call   f01163d2 <CCP>
f0113de4:	83 c4 30             	add    $0x30,%esp
f0113de7:	85 c0                	test   %eax,%eax
f0113de9:	75 25                	jne    f0113e10 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113deb:	83 ec 04             	sub    $0x4,%esp
f0113dee:	68 38 9e 12 f0       	push   $0xf0129e38
f0113df3:	68 8c 04 00 00       	push   $0x48c
f0113df8:	68 02 8b 12 f0       	push   $0xf0128b02
f0113dfd:	e8 d4 c6 fe ff       	call   f01004d6 <_warn>
f0113e02:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e05:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113e09:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113e10:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113e13:	89 d0                	mov    %edx,%eax
f0113e15:	01 c0                	add    %eax,%eax
f0113e17:	01 d0                	add    %edx,%eax
f0113e19:	c1 e0 02             	shl    $0x2,%eax
f0113e1c:	83 ec 08             	sub    $0x8,%esp
f0113e1f:	6a 02                	push   $0x2
f0113e21:	6a 07                	push   $0x7
f0113e23:	6a 03                	push   $0x3
f0113e25:	6a 07                	push   $0x7
f0113e27:	6a 07                	push   $0x7
f0113e29:	6a 03                	push   $0x3
f0113e2b:	50                   	push   %eax
f0113e2c:	6a 00                	push   $0x0
f0113e2e:	68 00 00 00 40       	push   $0x40000000
f0113e33:	ff 75 cc             	pushl  -0x34(%ebp)
f0113e36:	e8 97 25 00 00       	call   f01163d2 <CCP>
f0113e3b:	83 c4 30             	add    $0x30,%esp
f0113e3e:	85 c0                	test   %eax,%eax
f0113e40:	75 1e                	jne    f0113e60 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113e42:	83 ec 04             	sub    $0x4,%esp
f0113e45:	68 38 9e 12 f0       	push   $0xf0129e38
f0113e4a:	68 93 04 00 00       	push   $0x493
f0113e4f:	68 02 8b 12 f0       	push   $0xf0128b02
f0113e54:	e8 7d c6 fe ff       	call   f01004d6 <_warn>
f0113e59:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e5c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113e60:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113e64:	74 04                	je     f0113e6a <test_share_chunk+0x5ee>
f0113e66:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e6a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113e6e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113e71:	89 d0                	mov    %edx,%eax
f0113e73:	01 c0                	add    %eax,%eax
f0113e75:	01 d0                	add    %edx,%eax
f0113e77:	c1 e0 02             	shl    $0x2,%eax
f0113e7a:	f7 d8                	neg    %eax
f0113e7c:	05 00 00 0a 00       	add    $0xa0000,%eax
f0113e81:	83 ec 08             	sub    $0x8,%esp
f0113e84:	6a 02                	push   $0x2
f0113e86:	6a 07                	push   $0x7
f0113e88:	6a 03                	push   $0x3
f0113e8a:	6a 07                	push   $0x7
f0113e8c:	6a 07                	push   $0x7
f0113e8e:	6a 02                	push   $0x2
f0113e90:	50                   	push   %eax
f0113e91:	68 00 30 00 00       	push   $0x3000
f0113e96:	68 00 30 00 40       	push   $0x40003000
f0113e9b:	ff 75 cc             	pushl  -0x34(%ebp)
f0113e9e:	e8 2f 25 00 00       	call   f01163d2 <CCP>
f0113ea3:	83 c4 30             	add    $0x30,%esp
f0113ea6:	85 c0                	test   %eax,%eax
f0113ea8:	75 1e                	jne    f0113ec8 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113eaa:	83 ec 04             	sub    $0x4,%esp
f0113ead:	68 38 9e 12 f0       	push   $0xf0129e38
f0113eb2:	68 9b 04 00 00       	push   $0x49b
f0113eb7:	68 02 8b 12 f0       	push   $0xf0128b02
f0113ebc:	e8 15 c6 fe ff       	call   f01004d6 <_warn>
f0113ec1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ec4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113ec8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113ecc:	74 04                	je     f0113ed2 <test_share_chunk+0x656>
f0113ece:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113ed2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113ed6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113ed9:	c1 e0 02             	shl    $0x2,%eax
f0113edc:	83 ec 08             	sub    $0x8,%esp
f0113edf:	6a 02                	push   $0x2
f0113ee1:	6a 07                	push   $0x7
f0113ee3:	6a 03                	push   $0x3
f0113ee5:	6a 07                	push   $0x7
f0113ee7:	6a 07                	push   $0x7
f0113ee9:	6a 03                	push   $0x3
f0113eeb:	50                   	push   %eax
f0113eec:	68 00 00 0a 00       	push   $0xa0000
f0113ef1:	68 00 00 0a 40       	push   $0x400a0000
f0113ef6:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ef9:	e8 d4 24 00 00       	call   f01163d2 <CCP>
f0113efe:	83 c4 30             	add    $0x30,%esp
f0113f01:	85 c0                	test   %eax,%eax
f0113f03:	75 1e                	jne    f0113f23 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113f05:	83 ec 04             	sub    $0x4,%esp
f0113f08:	68 38 9e 12 f0       	push   $0xf0129e38
f0113f0d:	68 a3 04 00 00       	push   $0x4a3
f0113f12:	68 02 8b 12 f0       	push   $0xf0128b02
f0113f17:	e8 ba c5 fe ff       	call   f01004d6 <_warn>
f0113f1c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f1f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113f23:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113f27:	74 04                	je     f0113f2d <test_share_chunk+0x6b1>
f0113f29:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f2d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113f31:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0113f35:	0f 84 92 00 00 00    	je     f0113fcd <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0113f3b:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0113f42:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0113f49:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0113f50:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0113f57:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113f5a:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0113f5d:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0113f64:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0113f6b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f6e:	8a 00                	mov    (%eax),%al
f0113f70:	3c 41                	cmp    $0x41,%al
f0113f72:	75 2d                	jne    f0113fa1 <test_share_chunk+0x725>
f0113f74:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113f77:	8a 00                	mov    (%eax),%al
f0113f79:	3c 41                	cmp    $0x41,%al
f0113f7b:	75 24                	jne    f0113fa1 <test_share_chunk+0x725>
f0113f7d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113f80:	8a 00                	mov    (%eax),%al
f0113f82:	3c 41                	cmp    $0x41,%al
f0113f84:	75 1b                	jne    f0113fa1 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113f86:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113f89:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0113f8b:	3c 44                	cmp    $0x44,%al
f0113f8d:	75 12                	jne    f0113fa1 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113f8f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113f92:	8a 00                	mov    (%eax),%al
f0113f94:	3c 44                	cmp    $0x44,%al
f0113f96:	75 09                	jne    f0113fa1 <test_share_chunk+0x725>
f0113f98:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113f9b:	8a 00                	mov    (%eax),%al
f0113f9d:	3c 44                	cmp    $0x44,%al
f0113f9f:	74 1e                	je     f0113fbf <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113fa1:	83 ec 04             	sub    $0x4,%esp
f0113fa4:	68 80 9e 12 f0       	push   $0xf0129e80
f0113fa9:	68 b5 04 00 00       	push   $0x4b5
f0113fae:	68 02 8b 12 f0       	push   $0xf0128b02
f0113fb3:	e8 1e c5 fe ff       	call   f01004d6 <_warn>
f0113fb8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113fbb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113fbf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113fc3:	74 04                	je     f0113fc9 <test_share_chunk+0x74d>
f0113fc5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113fc9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113fcd:	83 ec 0c             	sub    $0xc,%esp
f0113fd0:	68 f2 94 12 f0       	push   $0xf01294f2
f0113fd5:	e8 b1 cf fe ff       	call   f0100f8b <cprintf>
f0113fda:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0113fdd:	83 ec 0c             	sub    $0xc,%esp
f0113fe0:	68 8c 9f 12 f0       	push   $0xf0129f8c
f0113fe5:	e8 a1 cf fe ff       	call   f0100f8b <cprintf>
f0113fea:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113fed:	e8 b8 a2 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0113ff2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0113ff5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113ff8:	89 d0                	mov    %edx,%eax
f0113ffa:	01 c0                	add    %eax,%eax
f0113ffc:	01 d0                	add    %edx,%eax
f0113ffe:	01 c0                	add    %eax,%eax
f0114000:	01 d0                	add    %edx,%eax
f0114002:	83 ec 0c             	sub    $0xc,%esp
f0114005:	6a 04                	push   $0x4
f0114007:	50                   	push   %eax
f0114008:	68 00 fc 3f 00       	push   $0x3ffc00
f011400d:	68 00 fc 09 00       	push   $0x9fc00
f0114012:	ff 75 cc             	pushl  -0x34(%ebp)
f0114015:	e8 63 64 ff ff       	call   f010a47d <share_chunk>
f011401a:	83 c4 20             	add    $0x20,%esp
f011401d:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114020:	e8 85 a2 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0114025:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114028:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f011402c:	75 0b                	jne    f0114039 <test_share_chunk+0x7bd>
f011402e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114031:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114034:	83 f8 01             	cmp    $0x1,%eax
f0114037:	74 28                	je     f0114061 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114039:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011403c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011403f:	83 ec 0c             	sub    $0xc,%esp
f0114042:	50                   	push   %eax
f0114043:	ff 75 8c             	pushl  -0x74(%ebp)
f0114046:	68 00 9f 12 f0       	push   $0xf0129f00
f011404b:	68 cb 04 00 00       	push   $0x4cb
f0114050:	68 02 8b 12 f0       	push   $0xf0128b02
f0114055:	e8 7c c4 fe ff       	call   f01004d6 <_warn>
f011405a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011405d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114061:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114065:	74 04                	je     f011406b <test_share_chunk+0x7ef>
f0114067:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011406b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011406f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114076:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114079:	89 d0                	mov    %edx,%eax
f011407b:	01 c0                	add    %eax,%eax
f011407d:	01 d0                	add    %edx,%eax
f011407f:	c1 e0 02             	shl    $0x2,%eax
f0114082:	83 ec 08             	sub    $0x8,%esp
f0114085:	6a 02                	push   $0x2
f0114087:	6a 07                	push   $0x7
f0114089:	6a 07                	push   $0x7
f011408b:	6a 07                	push   $0x7
f011408d:	6a 05                	push   $0x5
f011408f:	6a ff                	push   $0xffffffff
f0114091:	50                   	push   %eax
f0114092:	68 00 f0 3f 00       	push   $0x3ff000
f0114097:	68 00 f0 09 00       	push   $0x9f000
f011409c:	ff 75 cc             	pushl  -0x34(%ebp)
f011409f:	e8 2e 23 00 00       	call   f01163d2 <CCP>
f01140a4:	83 c4 30             	add    $0x30,%esp
f01140a7:	85 c0                	test   %eax,%eax
f01140a9:	75 25                	jne    f01140d0 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01140ab:	83 ec 04             	sub    $0x4,%esp
f01140ae:	68 38 9e 12 f0       	push   $0xf0129e38
f01140b3:	68 d4 04 00 00       	push   $0x4d4
f01140b8:	68 02 8b 12 f0       	push   $0xf0128b02
f01140bd:	e8 14 c4 fe ff       	call   f01004d6 <_warn>
f01140c2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01140c5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01140c9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01140d0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01140d4:	74 04                	je     f01140da <test_share_chunk+0x85e>
f01140d6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01140da:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01140de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01140e1:	c1 e0 02             	shl    $0x2,%eax
f01140e4:	83 ec 08             	sub    $0x8,%esp
f01140e7:	6a 02                	push   $0x2
f01140e9:	6a 07                	push   $0x7
f01140eb:	6a 07                	push   $0x7
f01140ed:	6a 07                	push   $0x7
f01140ef:	6a 05                	push   $0x5
f01140f1:	6a 03                	push   $0x3
f01140f3:	50                   	push   %eax
f01140f4:	68 00 f0 3f 00       	push   $0x3ff000
f01140f9:	68 00 f0 09 00       	push   $0x9f000
f01140fe:	ff 75 cc             	pushl  -0x34(%ebp)
f0114101:	e8 cc 22 00 00       	call   f01163d2 <CCP>
f0114106:	83 c4 30             	add    $0x30,%esp
f0114109:	85 c0                	test   %eax,%eax
f011410b:	75 1e                	jne    f011412b <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011410d:	83 ec 04             	sub    $0x4,%esp
f0114110:	68 38 9e 12 f0       	push   $0xf0129e38
f0114115:	68 dd 04 00 00       	push   $0x4dd
f011411a:	68 02 8b 12 f0       	push   $0xf0128b02
f011411f:	e8 b2 c3 fe ff       	call   f01004d6 <_warn>
f0114124:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114127:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011412b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011412f:	74 04                	je     f0114135 <test_share_chunk+0x8b9>
f0114131:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114135:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114139:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011413c:	c1 e0 03             	shl    $0x3,%eax
f011413f:	83 ec 08             	sub    $0x8,%esp
f0114142:	6a 02                	push   $0x2
f0114144:	6a 07                	push   $0x7
f0114146:	6a 07                	push   $0x7
f0114148:	6a 07                	push   $0x7
f011414a:	6a 05                	push   $0x5
f011414c:	6a 04                	push   $0x4
f011414e:	50                   	push   %eax
f011414f:	68 00 00 40 00       	push   $0x400000
f0114154:	68 00 00 0a 00       	push   $0xa0000
f0114159:	ff 75 cc             	pushl  -0x34(%ebp)
f011415c:	e8 71 22 00 00       	call   f01163d2 <CCP>
f0114161:	83 c4 30             	add    $0x30,%esp
f0114164:	85 c0                	test   %eax,%eax
f0114166:	75 1e                	jne    f0114186 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114168:	83 ec 04             	sub    $0x4,%esp
f011416b:	68 38 9e 12 f0       	push   $0xf0129e38
f0114170:	68 e5 04 00 00       	push   $0x4e5
f0114175:	68 02 8b 12 f0       	push   $0xf0128b02
f011417a:	e8 57 c3 fe ff       	call   f01004d6 <_warn>
f011417f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114182:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114186:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011418a:	74 04                	je     f0114190 <test_share_chunk+0x914>
f011418c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114190:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114194:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114198:	0f 84 b2 00 00 00    	je     f0114250 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f011419e:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01141a5:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01141ac:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01141b3:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f01141ba:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01141c1:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01141c8:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01141cf:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01141d6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01141d9:	8a 00                	mov    (%eax),%al
f01141db:	3c 44                	cmp    $0x44,%al
f01141dd:	75 45                	jne    f0114224 <test_share_chunk+0x9a8>
f01141df:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01141e2:	8a 00                	mov    (%eax),%al
f01141e4:	3c 44                	cmp    $0x44,%al
f01141e6:	75 3c                	jne    f0114224 <test_share_chunk+0x9a8>
f01141e8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01141eb:	8a 00                	mov    (%eax),%al
f01141ed:	3c 44                	cmp    $0x44,%al
f01141ef:	75 33                	jne    f0114224 <test_share_chunk+0x9a8>
f01141f1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01141f4:	8a 00                	mov    (%eax),%al
f01141f6:	3c 44                	cmp    $0x44,%al
f01141f8:	75 2a                	jne    f0114224 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01141fa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01141fd:	8a 10                	mov    (%eax),%dl
f01141ff:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114202:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114204:	38 c2                	cmp    %al,%dl
f0114206:	75 1c                	jne    f0114224 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114208:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011420b:	8a 10                	mov    (%eax),%dl
f011420d:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114210:	8a 00                	mov    (%eax),%al
f0114212:	38 c2                	cmp    %al,%dl
f0114214:	75 0e                	jne    f0114224 <test_share_chunk+0x9a8>
f0114216:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114219:	8a 10                	mov    (%eax),%dl
f011421b:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011421e:	8a 00                	mov    (%eax),%al
f0114220:	38 c2                	cmp    %al,%dl
f0114222:	74 1e                	je     f0114242 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114224:	83 ec 04             	sub    $0x4,%esp
f0114227:	68 80 9e 12 f0       	push   $0xf0129e80
f011422c:	68 fa 04 00 00       	push   $0x4fa
f0114231:	68 02 8b 12 f0       	push   $0xf0128b02
f0114236:	e8 9b c2 fe ff       	call   f01004d6 <_warn>
f011423b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011423e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114242:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114246:	74 04                	je     f011424c <test_share_chunk+0x9d0>
f0114248:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011424c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114250:	83 ec 0c             	sub    $0xc,%esp
f0114253:	68 c4 9f 12 f0       	push   $0xf0129fc4
f0114258:	e8 2e cd fe ff       	call   f0100f8b <cprintf>
f011425d:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114260:	83 ec 08             	sub    $0x8,%esp
f0114263:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114266:	68 d4 9f 12 f0       	push   $0xf0129fd4
f011426b:	e8 1b cd fe ff       	call   f0100f8b <cprintf>
f0114270:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114273:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114277:	75 10                	jne    f0114289 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114279:	83 ec 0c             	sub    $0xc,%esp
f011427c:	68 04 a0 12 f0       	push   $0xf012a004
f0114281:	e8 05 cd fe ff       	call   f0100f8b <cprintf>
f0114286:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114289:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f011428e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114291:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114294:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114297:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011429c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011429f:	5b                   	pop    %ebx
f01142a0:	5e                   	pop    %esi
f01142a1:	5f                   	pop    %edi
f01142a2:	5d                   	pop    %ebp
f01142a3:	c3                   	ret    

f01142a4 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01142a4:	55                   	push   %ebp
f01142a5:	89 e5                	mov    %esp,%ebp
f01142a7:	57                   	push   %edi
f01142a8:	56                   	push   %esi
f01142a9:	53                   	push   %ebx
f01142aa:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01142b0:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01142b6:	bb 04 92 12 f0       	mov    $0xf0129204,%ebx
f01142bb:	ba 0f 00 00 00       	mov    $0xf,%edx
f01142c0:	89 c7                	mov    %eax,%edi
f01142c2:	89 de                	mov    %ebx,%esi
f01142c4:	89 d1                	mov    %edx,%ecx
f01142c6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01142c8:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01142ce:	b9 23 00 00 00       	mov    $0x23,%ecx
f01142d3:	b0 00                	mov    $0x0,%al
f01142d5:	89 d7                	mov    %edx,%edi
f01142d7:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01142d9:	6a 00                	push   $0x0
f01142db:	6a 0a                	push   $0xa
f01142dd:	6a 14                	push   $0x14
f01142df:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01142e5:	50                   	push   %eax
f01142e6:	e8 1f 66 ff ff       	call   f010a90a <env_create>
f01142eb:	83 c4 10             	add    $0x10,%esp
f01142ee:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01142f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01142f4:	8b 40 64             	mov    0x64(%eax),%eax
f01142f7:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01142fa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01142fd:	8b 40 68             	mov    0x68(%eax),%eax
f0114300:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114303:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114306:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114309:	83 ec 0c             	sub    $0xc,%esp
f011430c:	ff 75 cc             	pushl  -0x34(%ebp)
f011430f:	e8 8a 20 00 00       	call   f011639e <ClearUserSpace>
f0114314:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114317:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011431e:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114325:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f011432c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114330:	83 ec 0c             	sub    $0xc,%esp
f0114333:	68 40 a0 12 f0       	push   $0xf012a040
f0114338:	e8 4e cc fe ff       	call   f0100f8b <cprintf>
f011433d:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114340:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114347:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f011434e:	eb 03                	jmp    f0114353 <test_allocate_chunk+0xaf>
f0114350:	ff 4d e4             	decl   -0x1c(%ebp)
f0114353:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011435a:	76 09                	jbe    f0114365 <test_allocate_chunk+0xc1>
f011435c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011435f:	8a 00                	mov    (%eax),%al
f0114361:	84 c0                	test   %al,%al
f0114363:	74 eb                	je     f0114350 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114365:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011436c:	75 06                	jne    f0114374 <test_allocate_chunk+0xd0>
f011436e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114371:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114374:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114377:	8a 00                	mov    (%eax),%al
f0114379:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f011437f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114382:	8a 00                	mov    (%eax),%al
f0114384:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f011438a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011438d:	8a 00                	mov    (%eax),%al
f011438f:	0f be c0             	movsbl %al,%eax
f0114392:	83 ec 08             	sub    $0x8,%esp
f0114395:	50                   	push   %eax
f0114396:	68 6a a0 12 f0       	push   $0xf012a06a
f011439b:	e8 eb cb fe ff       	call   f0100f8b <cprintf>
f01143a0:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01143a3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01143a6:	8a 00                	mov    (%eax),%al
f01143a8:	0f be c0             	movsbl %al,%eax
f01143ab:	83 ec 08             	sub    $0x8,%esp
f01143ae:	50                   	push   %eax
f01143af:	68 76 a0 12 f0       	push   $0xf012a076
f01143b4:	e8 d2 cb fe ff       	call   f0100f8b <cprintf>
f01143b9:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f01143bc:	83 ec 08             	sub    $0x8,%esp
f01143bf:	68 00 f0 bf ef       	push   $0xefbff000
f01143c4:	ff 75 cc             	pushl  -0x34(%ebp)
f01143c7:	e8 b3 1f 00 00       	call   f011637f <GP>
f01143cc:	83 c4 10             	add    $0x10,%esp
f01143cf:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01143d2:	e8 d3 9e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01143d7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f01143da:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01143dd:	c1 e0 02             	shl    $0x2,%eax
f01143e0:	6a 02                	push   $0x2
f01143e2:	50                   	push   %eax
f01143e3:	68 00 f0 bf ef       	push   $0xefbff000
f01143e8:	ff 75 cc             	pushl  -0x34(%ebp)
f01143eb:	e8 a7 60 ff ff       	call   f010a497 <allocate_chunk>
f01143f0:	83 c4 10             	add    $0x10,%esp
f01143f3:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01143f6:	e8 af 9e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01143fb:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01143fe:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114402:	75 08                	jne    f011440c <test_allocate_chunk+0x168>
f0114404:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114407:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011440a:	74 2a                	je     f0114436 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011440c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011440f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114412:	83 ec 08             	sub    $0x8,%esp
f0114415:	6a 00                	push   $0x0
f0114417:	50                   	push   %eax
f0114418:	ff 75 b0             	pushl  -0x50(%ebp)
f011441b:	68 84 a0 12 f0       	push   $0xf012a084
f0114420:	68 3a 05 00 00       	push   $0x53a
f0114425:	68 02 8b 12 f0       	push   $0xf0128b02
f011442a:	e8 a7 c0 fe ff       	call   f01004d6 <_warn>
f011442f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114432:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114436:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011443a:	74 04                	je     f0114440 <test_allocate_chunk+0x19c>
f011443c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114440:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114444:	e8 61 9e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0114449:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f011444c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011444f:	01 c0                	add    %eax,%eax
f0114451:	89 c1                	mov    %eax,%ecx
f0114453:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114456:	89 d0                	mov    %edx,%eax
f0114458:	c1 e0 02             	shl    $0x2,%eax
f011445b:	01 d0                	add    %edx,%eax
f011445d:	f7 d8                	neg    %eax
f011445f:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114464:	6a 02                	push   $0x2
f0114466:	51                   	push   %ecx
f0114467:	50                   	push   %eax
f0114468:	ff 75 cc             	pushl  -0x34(%ebp)
f011446b:	e8 27 60 ff ff       	call   f010a497 <allocate_chunk>
f0114470:	83 c4 10             	add    $0x10,%esp
f0114473:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114476:	e8 2f 9e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011447b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011447e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114482:	75 08                	jne    f011448c <test_allocate_chunk+0x1e8>
f0114484:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114487:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011448a:	74 2a                	je     f01144b6 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011448c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011448f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114492:	83 ec 08             	sub    $0x8,%esp
f0114495:	6a 00                	push   $0x0
f0114497:	50                   	push   %eax
f0114498:	ff 75 b0             	pushl  -0x50(%ebp)
f011449b:	68 84 a0 12 f0       	push   $0xf012a084
f01144a0:	68 48 05 00 00       	push   $0x548
f01144a5:	68 02 8b 12 f0       	push   $0xf0128b02
f01144aa:	e8 27 c0 fe ff       	call   f01004d6 <_warn>
f01144af:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01144b2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01144b6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01144ba:	74 04                	je     f01144c0 <test_allocate_chunk+0x21c>
f01144bc:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01144c0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f01144c4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01144c7:	c1 e0 02             	shl    $0x2,%eax
f01144ca:	83 ec 08             	sub    $0x8,%esp
f01144cd:	6a 03                	push   $0x3
f01144cf:	6a 00                	push   $0x0
f01144d1:	6a 00                	push   $0x0
f01144d3:	68 ff 0f 00 00       	push   $0xfff
f01144d8:	ff 75 b8             	pushl  -0x48(%ebp)
f01144db:	6a 01                	push   $0x1
f01144dd:	50                   	push   %eax
f01144de:	68 00 f0 bf ef       	push   $0xefbff000
f01144e3:	6a 00                	push   $0x0
f01144e5:	ff 75 cc             	pushl  -0x34(%ebp)
f01144e8:	e8 e5 1e 00 00       	call   f01163d2 <CCP>
f01144ed:	83 c4 30             	add    $0x30,%esp
f01144f0:	85 c0                	test   %eax,%eax
f01144f2:	75 1e                	jne    f0114512 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01144f4:	83 ec 04             	sub    $0x4,%esp
f01144f7:	68 ec a0 12 f0       	push   $0xf012a0ec
f01144fc:	68 50 05 00 00       	push   $0x550
f0114501:	68 02 8b 12 f0       	push   $0xf0128b02
f0114506:	e8 cb bf fe ff       	call   f01004d6 <_warn>
f011450b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011450e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114512:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114516:	74 04                	je     f011451c <test_allocate_chunk+0x278>
f0114518:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011451c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114520:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114523:	8a 10                	mov    (%eax),%dl
f0114525:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f011452b:	38 c2                	cmp    %al,%dl
f011452d:	75 0f                	jne    f011453e <test_allocate_chunk+0x29a>
f011452f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114532:	8a 10                	mov    (%eax),%dl
f0114534:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f011453a:	38 c2                	cmp    %al,%dl
f011453c:	74 1e                	je     f011455c <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011453e:	83 ec 04             	sub    $0x4,%esp
f0114541:	68 38 a1 12 f0       	push   $0xf012a138
f0114546:	68 58 05 00 00       	push   $0x558
f011454b:	68 02 8b 12 f0       	push   $0xf0128b02
f0114550:	e8 81 bf fe ff       	call   f01004d6 <_warn>
f0114555:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114558:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011455c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114560:	74 04                	je     f0114566 <test_allocate_chunk+0x2c2>
f0114562:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114566:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011456a:	83 ec 0c             	sub    $0xc,%esp
f011456d:	68 b5 9e 12 f0       	push   $0xf0129eb5
f0114572:	e8 14 ca fe ff       	call   f0100f8b <cprintf>
f0114577:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f011457a:	83 ec 0c             	sub    $0xc,%esp
f011457d:	68 70 a1 12 f0       	push   $0xf012a170
f0114582:	e8 04 ca fe ff       	call   f0100f8b <cprintf>
f0114587:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011458a:	e8 1b 9d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011458f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114592:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114595:	c1 e0 05             	shl    $0x5,%eax
f0114598:	68 02 0e 00 00       	push   $0xe02
f011459d:	50                   	push   %eax
f011459e:	6a 00                	push   $0x0
f01145a0:	ff 75 cc             	pushl  -0x34(%ebp)
f01145a3:	e8 ef 5e ff ff       	call   f010a497 <allocate_chunk>
f01145a8:	83 c4 10             	add    $0x10,%esp
f01145ab:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01145ae:	e8 f7 9c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01145b3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f01145b6:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01145ba:	75 36                	jne    f01145f2 <test_allocate_chunk+0x34e>
f01145bc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01145bf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01145c2:	89 c1                	mov    %eax,%ecx
f01145c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01145c7:	c1 e0 05             	shl    $0x5,%eax
f01145ca:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01145cd:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01145d4:	99                   	cltd   
f01145d5:	f7 fe                	idiv   %esi
f01145d7:	89 c3                	mov    %eax,%ebx
f01145d9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01145dc:	c1 e0 05             	shl    $0x5,%eax
f01145df:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01145e2:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01145e9:	99                   	cltd   
f01145ea:	f7 fe                	idiv   %esi
f01145ec:	01 d8                	add    %ebx,%eax
f01145ee:	39 c1                	cmp    %eax,%ecx
f01145f0:	74 54                	je     f0114646 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f01145f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01145f5:	c1 e0 05             	shl    $0x5,%eax
f01145f8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01145fb:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114602:	99                   	cltd   
f0114603:	f7 ff                	idiv   %edi
f0114605:	89 c1                	mov    %eax,%ecx
f0114607:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011460a:	c1 e0 05             	shl    $0x5,%eax
f011460d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114610:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114617:	99                   	cltd   
f0114618:	f7 fe                	idiv   %esi
f011461a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011461d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114620:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114623:	83 ec 08             	sub    $0x8,%esp
f0114626:	52                   	push   %edx
f0114627:	50                   	push   %eax
f0114628:	ff 75 a8             	pushl  -0x58(%ebp)
f011462b:	68 b0 a1 12 f0       	push   $0xf012a1b0
f0114630:	68 6d 05 00 00       	push   $0x56d
f0114635:	68 02 8b 12 f0       	push   $0xf0128b02
f011463a:	e8 97 be fe ff       	call   f01004d6 <_warn>
f011463f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114642:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114646:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011464a:	74 04                	je     f0114650 <test_allocate_chunk+0x3ac>
f011464c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114650:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114654:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011465b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011465e:	c1 e0 05             	shl    $0x5,%eax
f0114661:	83 ec 08             	sub    $0x8,%esp
f0114664:	6a 03                	push   $0x3
f0114666:	6a 00                	push   $0x0
f0114668:	6a 00                	push   $0x0
f011466a:	68 07 0e 00 00       	push   $0xe07
f011466f:	68 03 0e 00 00       	push   $0xe03
f0114674:	6a 01                	push   $0x1
f0114676:	50                   	push   %eax
f0114677:	6a 00                	push   $0x0
f0114679:	6a 00                	push   $0x0
f011467b:	ff 75 cc             	pushl  -0x34(%ebp)
f011467e:	e8 4f 1d 00 00       	call   f01163d2 <CCP>
f0114683:	83 c4 30             	add    $0x30,%esp
f0114686:	85 c0                	test   %eax,%eax
f0114688:	75 25                	jne    f01146af <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011468a:	83 ec 04             	sub    $0x4,%esp
f011468d:	68 ec a0 12 f0       	push   $0xf012a0ec
f0114692:	68 76 05 00 00       	push   $0x576
f0114697:	68 02 8b 12 f0       	push   $0xf0128b02
f011469c:	e8 35 be fe ff       	call   f01004d6 <_warn>
f01146a1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146a4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01146a8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f01146af:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01146b3:	74 04                	je     f01146b9 <test_allocate_chunk+0x415>
f01146b5:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01146b9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f01146bd:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01146c1:	74 5a                	je     f011471d <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f01146c3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01146c6:	01 c0                	add    %eax,%eax
f01146c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01146cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01146ce:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f01146d1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146d4:	01 c0                	add    %eax,%eax
f01146d6:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01146d9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01146dc:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01146df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01146e2:	8a 00                	mov    (%eax),%al
f01146e4:	3c 4b                	cmp    $0x4b,%al
f01146e6:	75 09                	jne    f01146f1 <test_allocate_chunk+0x44d>
f01146e8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01146eb:	8a 00                	mov    (%eax),%al
f01146ed:	3c 4d                	cmp    $0x4d,%al
f01146ef:	74 1e                	je     f011470f <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01146f1:	83 ec 04             	sub    $0x4,%esp
f01146f4:	68 38 a1 12 f0       	push   $0xf012a138
f01146f9:	68 84 05 00 00       	push   $0x584
f01146fe:	68 02 8b 12 f0       	push   $0xf0128b02
f0114703:	e8 ce bd fe ff       	call   f01004d6 <_warn>
f0114708:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011470b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f011470f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114713:	74 04                	je     f0114719 <test_allocate_chunk+0x475>
f0114715:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114719:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f011471d:	83 ec 0c             	sub    $0xc,%esp
f0114720:	68 8f 94 12 f0       	push   $0xf012948f
f0114725:	e8 61 c8 fe ff       	call   f0100f8b <cprintf>
f011472a:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f011472d:	83 ec 0c             	sub    $0xc,%esp
f0114730:	68 10 a2 12 f0       	push   $0xf012a210
f0114735:	e8 51 c8 fe ff       	call   f0100f8b <cprintf>
f011473a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011473d:	e8 68 9b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0114742:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114745:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114748:	c1 e0 06             	shl    $0x6,%eax
f011474b:	89 c2                	mov    %eax,%edx
f011474d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114750:	c1 e0 05             	shl    $0x5,%eax
f0114753:	6a 00                	push   $0x0
f0114755:	52                   	push   %edx
f0114756:	50                   	push   %eax
f0114757:	ff 75 cc             	pushl  -0x34(%ebp)
f011475a:	e8 38 5d ff ff       	call   f010a497 <allocate_chunk>
f011475f:	83 c4 10             	add    $0x10,%esp
f0114762:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114765:	e8 40 9b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011476a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011476d:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114771:	75 36                	jne    f01147a9 <test_allocate_chunk+0x505>
f0114773:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114776:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114779:	89 c1                	mov    %eax,%ecx
f011477b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011477e:	c1 e0 06             	shl    $0x6,%eax
f0114781:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114784:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011478b:	99                   	cltd   
f011478c:	f7 ff                	idiv   %edi
f011478e:	89 c3                	mov    %eax,%ebx
f0114790:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114793:	c1 e0 06             	shl    $0x6,%eax
f0114796:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114799:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01147a0:	99                   	cltd   
f01147a1:	f7 fe                	idiv   %esi
f01147a3:	01 d8                	add    %ebx,%eax
f01147a5:	39 c1                	cmp    %eax,%ecx
f01147a7:	74 54                	je     f01147fd <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f01147a9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147ac:	c1 e0 06             	shl    $0x6,%eax
f01147af:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01147b2:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01147b9:	99                   	cltd   
f01147ba:	f7 fb                	idiv   %ebx
f01147bc:	89 c1                	mov    %eax,%ecx
f01147be:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147c1:	c1 e0 06             	shl    $0x6,%eax
f01147c4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01147c7:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01147ce:	99                   	cltd   
f01147cf:	f7 ff                	idiv   %edi
f01147d1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01147d4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01147d7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01147da:	83 ec 08             	sub    $0x8,%esp
f01147dd:	52                   	push   %edx
f01147de:	50                   	push   %eax
f01147df:	ff 75 a4             	pushl  -0x5c(%ebp)
f01147e2:	68 b0 a1 12 f0       	push   $0xf012a1b0
f01147e7:	68 9a 05 00 00       	push   $0x59a
f01147ec:	68 02 8b 12 f0       	push   $0xf0128b02
f01147f1:	e8 e0 bc fe ff       	call   f01004d6 <_warn>
f01147f6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01147f9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01147fd:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114801:	74 04                	je     f0114807 <test_allocate_chunk+0x563>
f0114803:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114807:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f011480b:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114812:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114815:	c1 e0 06             	shl    $0x6,%eax
f0114818:	89 c2                	mov    %eax,%edx
f011481a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011481d:	c1 e0 05             	shl    $0x5,%eax
f0114820:	83 ec 08             	sub    $0x8,%esp
f0114823:	6a 03                	push   $0x3
f0114825:	6a 00                	push   $0x0
f0114827:	6a 00                	push   $0x0
f0114829:	68 07 0e 00 00       	push   $0xe07
f011482e:	6a 01                	push   $0x1
f0114830:	6a 01                	push   $0x1
f0114832:	52                   	push   %edx
f0114833:	50                   	push   %eax
f0114834:	6a 00                	push   $0x0
f0114836:	ff 75 cc             	pushl  -0x34(%ebp)
f0114839:	e8 94 1b 00 00       	call   f01163d2 <CCP>
f011483e:	83 c4 30             	add    $0x30,%esp
f0114841:	85 c0                	test   %eax,%eax
f0114843:	75 25                	jne    f011486a <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114845:	83 ec 04             	sub    $0x4,%esp
f0114848:	68 ec a0 12 f0       	push   $0xf012a0ec
f011484d:	68 a3 05 00 00       	push   $0x5a3
f0114852:	68 02 8b 12 f0       	push   $0xf0128b02
f0114857:	e8 7a bc fe ff       	call   f01004d6 <_warn>
f011485c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011485f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114863:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f011486a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011486e:	74 04                	je     f0114874 <test_allocate_chunk+0x5d0>
f0114870:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114874:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0114878:	83 ec 0c             	sub    $0xc,%esp
f011487b:	68 f2 94 12 f0       	push   $0xf01294f2
f0114880:	e8 06 c7 fe ff       	call   f0100f8b <cprintf>
f0114885:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0114888:	83 ec 0c             	sub    $0xc,%esp
f011488b:	68 50 a2 12 f0       	push   $0xf012a250
f0114890:	e8 f6 c6 fe ff       	call   f0100f8b <cprintf>
f0114895:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114898:	e8 0d 9a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011489d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f01148a0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01148a3:	c1 e0 06             	shl    $0x6,%eax
f01148a6:	68 06 0e 00 00       	push   $0xe06
f01148ab:	50                   	push   %eax
f01148ac:	68 00 00 00 80       	push   $0x80000000
f01148b1:	ff 75 cc             	pushl  -0x34(%ebp)
f01148b4:	e8 de 5b ff ff       	call   f010a497 <allocate_chunk>
f01148b9:	83 c4 10             	add    $0x10,%esp
f01148bc:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01148bf:	e8 e6 99 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01148c4:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f01148c7:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f01148cb:	75 36                	jne    f0114903 <test_allocate_chunk+0x65f>
f01148cd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01148d0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01148d3:	89 c1                	mov    %eax,%ecx
f01148d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01148d8:	c1 e0 06             	shl    $0x6,%eax
f01148db:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01148de:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01148e5:	99                   	cltd   
f01148e6:	f7 fb                	idiv   %ebx
f01148e8:	89 c3                	mov    %eax,%ebx
f01148ea:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01148ed:	c1 e0 06             	shl    $0x6,%eax
f01148f0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01148f3:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01148fa:	99                   	cltd   
f01148fb:	f7 fe                	idiv   %esi
f01148fd:	01 d8                	add    %ebx,%eax
f01148ff:	39 c1                	cmp    %eax,%ecx
f0114901:	74 54                	je     f0114957 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114903:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114906:	c1 e0 06             	shl    $0x6,%eax
f0114909:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011490c:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114913:	99                   	cltd   
f0114914:	f7 ff                	idiv   %edi
f0114916:	89 c1                	mov    %eax,%ecx
f0114918:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011491b:	c1 e0 06             	shl    $0x6,%eax
f011491e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114921:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114928:	99                   	cltd   
f0114929:	f7 fb                	idiv   %ebx
f011492b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011492e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114931:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114934:	83 ec 08             	sub    $0x8,%esp
f0114937:	52                   	push   %edx
f0114938:	50                   	push   %eax
f0114939:	ff 75 9c             	pushl  -0x64(%ebp)
f011493c:	68 b0 a1 12 f0       	push   $0xf012a1b0
f0114941:	68 b9 05 00 00       	push   $0x5b9
f0114946:	68 02 8b 12 f0       	push   $0xf0128b02
f011494b:	e8 86 bb fe ff       	call   f01004d6 <_warn>
f0114950:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114953:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114957:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011495b:	74 04                	je     f0114961 <test_allocate_chunk+0x6bd>
f011495d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114961:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114965:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011496c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011496f:	c1 e0 06             	shl    $0x6,%eax
f0114972:	83 ec 08             	sub    $0x8,%esp
f0114975:	6a 03                	push   $0x3
f0114977:	6a 00                	push   $0x0
f0114979:	6a 00                	push   $0x0
f011497b:	68 07 0e 00 00       	push   $0xe07
f0114980:	68 07 0e 00 00       	push   $0xe07
f0114985:	6a 01                	push   $0x1
f0114987:	50                   	push   %eax
f0114988:	68 00 00 00 80       	push   $0x80000000
f011498d:	6a 00                	push   $0x0
f011498f:	ff 75 cc             	pushl  -0x34(%ebp)
f0114992:	e8 3b 1a 00 00       	call   f01163d2 <CCP>
f0114997:	83 c4 30             	add    $0x30,%esp
f011499a:	85 c0                	test   %eax,%eax
f011499c:	75 25                	jne    f01149c3 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011499e:	83 ec 04             	sub    $0x4,%esp
f01149a1:	68 ec a0 12 f0       	push   $0xf012a0ec
f01149a6:	68 c2 05 00 00       	push   $0x5c2
f01149ab:	68 02 8b 12 f0       	push   $0xf0128b02
f01149b0:	e8 21 bb fe ff       	call   f01004d6 <_warn>
f01149b5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01149b8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01149bc:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f01149c3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01149c7:	74 04                	je     f01149cd <test_allocate_chunk+0x729>
f01149c9:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01149cd:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f01149d1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01149d5:	74 6f                	je     f0114a46 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f01149d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01149da:	01 c0                	add    %eax,%eax
f01149dc:	05 00 00 00 80       	add    $0x80000000,%eax
f01149e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01149e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01149e7:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f01149ea:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01149ed:	89 d0                	mov    %edx,%eax
f01149ef:	c1 e0 02             	shl    $0x2,%eax
f01149f2:	01 d0                	add    %edx,%eax
f01149f4:	01 c0                	add    %eax,%eax
f01149f6:	01 d0                	add    %edx,%eax
f01149f8:	01 c0                	add    %eax,%eax
f01149fa:	05 00 00 00 80       	add    $0x80000000,%eax
f01149ff:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114a02:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114a05:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114a08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114a0b:	8a 00                	mov    (%eax),%al
f0114a0d:	3c 4b                	cmp    $0x4b,%al
f0114a0f:	75 09                	jne    f0114a1a <test_allocate_chunk+0x776>
f0114a11:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114a14:	8a 00                	mov    (%eax),%al
f0114a16:	3c 4d                	cmp    $0x4d,%al
f0114a18:	74 1e                	je     f0114a38 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114a1a:	83 ec 04             	sub    $0x4,%esp
f0114a1d:	68 38 a1 12 f0       	push   $0xf012a138
f0114a22:	68 d0 05 00 00       	push   $0x5d0
f0114a27:	68 02 8b 12 f0       	push   $0xf0128b02
f0114a2c:	e8 a5 ba fe ff       	call   f01004d6 <_warn>
f0114a31:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114a34:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114a38:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114a3c:	74 04                	je     f0114a42 <test_allocate_chunk+0x79e>
f0114a3e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114a42:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114a46:	83 ec 0c             	sub    $0xc,%esp
f0114a49:	68 c4 9f 12 f0       	push   $0xf0129fc4
f0114a4e:	e8 38 c5 fe ff       	call   f0100f8b <cprintf>
f0114a53:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0114a56:	83 ec 0c             	sub    $0xc,%esp
f0114a59:	68 8c a2 12 f0       	push   $0xf012a28c
f0114a5e:	e8 28 c5 fe ff       	call   f0100f8b <cprintf>
f0114a63:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114a66:	e8 3f 98 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0114a6b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0114a6e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a71:	89 d0                	mov    %edx,%eax
f0114a73:	01 c0                	add    %eax,%eax
f0114a75:	01 d0                	add    %edx,%eax
f0114a77:	01 c0                	add    %eax,%eax
f0114a79:	01 d0                	add    %edx,%eax
f0114a7b:	68 04 0e 00 00       	push   $0xe04
f0114a80:	50                   	push   %eax
f0114a81:	68 00 fc 3f 40       	push   $0x403ffc00
f0114a86:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a89:	e8 09 5a ff ff       	call   f010a497 <allocate_chunk>
f0114a8e:	83 c4 10             	add    $0x10,%esp
f0114a91:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114a94:	e8 11 98 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0114a99:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0114a9c:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0114aa0:	75 0b                	jne    f0114aad <test_allocate_chunk+0x809>
f0114aa2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114aa5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114aa8:	83 f8 05             	cmp    $0x5,%eax
f0114aab:	74 2a                	je     f0114ad7 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0114aad:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ab0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ab3:	83 ec 08             	sub    $0x8,%esp
f0114ab6:	6a 05                	push   $0x5
f0114ab8:	50                   	push   %eax
f0114ab9:	ff 75 98             	pushl  -0x68(%ebp)
f0114abc:	68 b0 a1 12 f0       	push   $0xf012a1b0
f0114ac1:	68 e7 05 00 00       	push   $0x5e7
f0114ac6:	68 02 8b 12 f0       	push   $0xf0128b02
f0114acb:	e8 06 ba fe ff       	call   f01004d6 <_warn>
f0114ad0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ad3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114ad7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114adb:	74 04                	je     f0114ae1 <test_allocate_chunk+0x83d>
f0114add:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ae1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114ae5:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114aec:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114aef:	89 d0                	mov    %edx,%eax
f0114af1:	01 c0                	add    %eax,%eax
f0114af3:	01 d0                	add    %edx,%eax
f0114af5:	c1 e0 02             	shl    $0x2,%eax
f0114af8:	83 ec 08             	sub    $0x8,%esp
f0114afb:	6a 03                	push   $0x3
f0114afd:	6a 00                	push   $0x0
f0114aff:	6a 00                	push   $0x0
f0114b01:	68 07 0e 00 00       	push   $0xe07
f0114b06:	68 05 0e 00 00       	push   $0xe05
f0114b0b:	6a 01                	push   $0x1
f0114b0d:	50                   	push   %eax
f0114b0e:	68 00 f0 3f 40       	push   $0x403ff000
f0114b13:	6a 00                	push   $0x0
f0114b15:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b18:	e8 b5 18 00 00       	call   f01163d2 <CCP>
f0114b1d:	83 c4 30             	add    $0x30,%esp
f0114b20:	85 c0                	test   %eax,%eax
f0114b22:	75 25                	jne    f0114b49 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114b24:	83 ec 04             	sub    $0x4,%esp
f0114b27:	68 ec a0 12 f0       	push   $0xf012a0ec
f0114b2c:	68 f0 05 00 00       	push   $0x5f0
f0114b31:	68 02 8b 12 f0       	push   $0xf0128b02
f0114b36:	e8 9b b9 fe ff       	call   f01004d6 <_warn>
f0114b3b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b3e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114b42:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0114b49:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b4d:	74 04                	je     f0114b53 <test_allocate_chunk+0x8af>
f0114b4f:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114b53:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0114b57:	83 ec 0c             	sub    $0xc,%esp
f0114b5a:	68 c3 a2 12 f0       	push   $0xf012a2c3
f0114b5f:	e8 27 c4 fe ff       	call   f0100f8b <cprintf>
f0114b64:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0114b67:	83 ec 08             	sub    $0x8,%esp
f0114b6a:	ff 75 e0             	pushl  -0x20(%ebp)
f0114b6d:	68 d4 a2 12 f0       	push   $0xf012a2d4
f0114b72:	e8 14 c4 fe ff       	call   f0100f8b <cprintf>
f0114b77:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114b7a:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0114b7e:	75 10                	jne    f0114b90 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0114b80:	83 ec 0c             	sub    $0xc,%esp
f0114b83:	68 08 a3 12 f0       	push   $0xf012a308
f0114b88:	e8 fe c3 fe ff       	call   f0100f8b <cprintf>
f0114b8d:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114b90:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0114b95:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114b98:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114b9b:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114b9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114ba3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114ba6:	5b                   	pop    %ebx
f0114ba7:	5e                   	pop    %esi
f0114ba8:	5f                   	pop    %edi
f0114ba9:	5d                   	pop    %ebp
f0114baa:	c3                   	ret    

f0114bab <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0114bab:	55                   	push   %ebp
f0114bac:	89 e5                	mov    %esp,%ebp
f0114bae:	57                   	push   %edi
f0114baf:	56                   	push   %esi
f0114bb0:	53                   	push   %ebx
f0114bb1:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114bb7:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114bba:	bb 04 92 12 f0       	mov    $0xf0129204,%ebx
f0114bbf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114bc4:	89 c7                	mov    %eax,%edi
f0114bc6:	89 de                	mov    %ebx,%esi
f0114bc8:	89 d1                	mov    %edx,%ecx
f0114bca:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114bcc:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0114bcf:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114bd4:	b0 00                	mov    $0x0,%al
f0114bd6:	89 d7                	mov    %edx,%edi
f0114bd8:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114bda:	6a 00                	push   $0x0
f0114bdc:	6a 0a                	push   $0xa
f0114bde:	6a 14                	push   $0x14
f0114be0:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114be3:	50                   	push   %eax
f0114be4:	e8 21 5d ff ff       	call   f010a90a <env_create>
f0114be9:	83 c4 10             	add    $0x10,%esp
f0114bec:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114bef:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114bf2:	8b 40 64             	mov    0x64(%eax),%eax
f0114bf5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0114bf8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114bfb:	8b 40 68             	mov    0x68(%eax),%eax
f0114bfe:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0114c01:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c04:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0114c07:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0114c0e:	75 70 20 
f0114c11:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0114c18:	00 00 00 
f0114c1b:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0114c1e:	b9 03 00 00 00       	mov    $0x3,%ecx
f0114c23:	b8 00 00 00 00       	mov    $0x0,%eax
f0114c28:	89 d7                	mov    %edx,%edi
f0114c2a:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0114c2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114c2f:	8b 40 10             	mov    0x10(%eax),%eax
f0114c32:	83 ec 08             	sub    $0x8,%esp
f0114c35:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0114c3b:	52                   	push   %edx
f0114c3c:	50                   	push   %eax
f0114c3d:	e8 28 ae 00 00       	call   f011fa6a <ltostr>
f0114c42:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0114c45:	83 ec 04             	sub    $0x4,%esp
f0114c48:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114c4e:	50                   	push   %eax
f0114c4f:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0114c55:	50                   	push   %eax
f0114c56:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0114c5c:	50                   	push   %eax
f0114c5d:	e8 e1 ae 00 00       	call   f011fb43 <strcconcat>
f0114c62:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114c65:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0114c6c:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0114c73:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0114c7a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0114c81:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0114c85:	83 ec 0c             	sub    $0xc,%esp
f0114c88:	ff 75 d8             	pushl  -0x28(%ebp)
f0114c8b:	e8 0e 17 00 00       	call   f011639e <ClearUserSpace>
f0114c90:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114c93:	83 ec 0c             	sub    $0xc,%esp
f0114c96:	68 48 a3 12 f0       	push   $0xf012a348
f0114c9b:	e8 eb c2 fe ff       	call   f0100f8b <cprintf>
f0114ca0:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114ca3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114ca6:	c1 e0 03             	shl    $0x3,%eax
f0114ca9:	83 ec 04             	sub    $0x4,%esp
f0114cac:	50                   	push   %eax
f0114cad:	6a 00                	push   $0x0
f0114caf:	ff 75 d8             	pushl  -0x28(%ebp)
f0114cb2:	e8 14 58 ff ff       	call   f010a4cb <calculate_required_frames>
f0114cb7:	83 c4 10             	add    $0x10,%esp
f0114cba:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114cbd:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114cc1:	74 23                	je     f0114ce6 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114cc3:	83 ec 0c             	sub    $0xc,%esp
f0114cc6:	6a 03                	push   $0x3
f0114cc8:	ff 75 c8             	pushl  -0x38(%ebp)
f0114ccb:	68 7c a3 12 f0       	push   $0xf012a37c
f0114cd0:	68 29 06 00 00       	push   $0x629
f0114cd5:	68 02 8b 12 f0       	push   $0xf0128b02
f0114cda:	e8 f7 b7 fe ff       	call   f01004d6 <_warn>
f0114cdf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ce2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ce6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114cea:	74 04                	je     f0114cf0 <test_calculate_required_frames+0x145>
f0114cec:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114cf0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0114cf4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114cf7:	c1 e0 02             	shl    $0x2,%eax
f0114cfa:	83 ec 04             	sub    $0x4,%esp
f0114cfd:	50                   	push   %eax
f0114cfe:	6a 00                	push   $0x0
f0114d00:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d03:	e8 c3 57 ff ff       	call   f010a4cb <calculate_required_frames>
f0114d08:	83 c4 10             	add    $0x10,%esp
f0114d0b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0114d0e:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0114d15:	74 26                	je     f0114d3d <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0114d17:	83 ec 0c             	sub    $0xc,%esp
f0114d1a:	68 01 04 00 00       	push   $0x401
f0114d1f:	ff 75 c8             	pushl  -0x38(%ebp)
f0114d22:	68 7c a3 12 f0       	push   $0xf012a37c
f0114d27:	68 33 06 00 00       	push   $0x633
f0114d2c:	68 02 8b 12 f0       	push   $0xf0128b02
f0114d31:	e8 a0 b7 fe ff       	call   f01004d6 <_warn>
f0114d36:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d39:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d3d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d41:	74 04                	je     f0114d47 <test_calculate_required_frames+0x19c>
f0114d43:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d47:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0114d4b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114d4e:	c1 e0 0a             	shl    $0xa,%eax
f0114d51:	83 ec 04             	sub    $0x4,%esp
f0114d54:	50                   	push   %eax
f0114d55:	6a 00                	push   $0x0
f0114d57:	ff 75 d8             	pushl  -0x28(%ebp)
f0114d5a:	e8 6c 57 ff ff       	call   f010a4cb <calculate_required_frames>
f0114d5f:	83 c4 10             	add    $0x10,%esp
f0114d62:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0114d65:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114d68:	c1 e0 0a             	shl    $0xa,%eax
f0114d6b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114d6e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114d75:	99                   	cltd   
f0114d76:	f7 fb                	idiv   %ebx
f0114d78:	89 c1                	mov    %eax,%ecx
f0114d7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114d7d:	c1 e0 0a             	shl    $0xa,%eax
f0114d80:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114d83:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114d8a:	99                   	cltd   
f0114d8b:	f7 fe                	idiv   %esi
f0114d8d:	01 c8                	add    %ecx,%eax
f0114d8f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114d92:	74 4c                	je     f0114de0 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0114d94:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114d97:	c1 e0 0a             	shl    $0xa,%eax
f0114d9a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114d9d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114da4:	99                   	cltd   
f0114da5:	f7 fb                	idiv   %ebx
f0114da7:	89 c1                	mov    %eax,%ecx
f0114da9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114dac:	c1 e0 0a             	shl    $0xa,%eax
f0114daf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114db2:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114db9:	99                   	cltd   
f0114dba:	f7 fe                	idiv   %esi
f0114dbc:	01 c8                	add    %ecx,%eax
f0114dbe:	83 ec 0c             	sub    $0xc,%esp
f0114dc1:	50                   	push   %eax
f0114dc2:	ff 75 c8             	pushl  -0x38(%ebp)
f0114dc5:	68 7c a3 12 f0       	push   $0xf012a37c
f0114dca:	68 3d 06 00 00       	push   $0x63d
f0114dcf:	68 02 8b 12 f0       	push   $0xf0128b02
f0114dd4:	e8 fd b6 fe ff       	call   f01004d6 <_warn>
f0114dd9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ddc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114de0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114de4:	74 04                	je     f0114dea <test_calculate_required_frames+0x23f>
f0114de6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114dea:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0114dee:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114df1:	89 d0                	mov    %edx,%eax
f0114df3:	01 c0                	add    %eax,%eax
f0114df5:	01 d0                	add    %edx,%eax
f0114df7:	01 c0                	add    %eax,%eax
f0114df9:	83 ec 04             	sub    $0x4,%esp
f0114dfc:	50                   	push   %eax
f0114dfd:	68 00 10 00 00       	push   $0x1000
f0114e02:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e05:	e8 c1 56 ff ff       	call   f010a4cb <calculate_required_frames>
f0114e0a:	83 c4 10             	add    $0x10,%esp
f0114e0d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114e10:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114e14:	74 23                	je     f0114e39 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114e16:	83 ec 0c             	sub    $0xc,%esp
f0114e19:	6a 03                	push   $0x3
f0114e1b:	ff 75 c8             	pushl  -0x38(%ebp)
f0114e1e:	68 7c a3 12 f0       	push   $0xf012a37c
f0114e23:	68 49 06 00 00       	push   $0x649
f0114e28:	68 02 8b 12 f0       	push   $0xf0128b02
f0114e2d:	e8 a4 b6 fe ff       	call   f01004d6 <_warn>
f0114e32:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e35:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114e39:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e3d:	74 04                	je     f0114e43 <test_calculate_required_frames+0x298>
f0114e3f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114e43:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0114e47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114e4a:	89 c2                	mov    %eax,%edx
f0114e4c:	01 d2                	add    %edx,%edx
f0114e4e:	01 d0                	add    %edx,%eax
f0114e50:	83 ec 04             	sub    $0x4,%esp
f0114e53:	50                   	push   %eax
f0114e54:	68 00 18 00 00       	push   $0x1800
f0114e59:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e5c:	e8 6a 56 ff ff       	call   f010a4cb <calculate_required_frames>
f0114e61:	83 c4 10             	add    $0x10,%esp
f0114e64:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114e67:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114e6b:	74 23                	je     f0114e90 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114e6d:	83 ec 0c             	sub    $0xc,%esp
f0114e70:	6a 03                	push   $0x3
f0114e72:	ff 75 c8             	pushl  -0x38(%ebp)
f0114e75:	68 7c a3 12 f0       	push   $0xf012a37c
f0114e7a:	68 53 06 00 00       	push   $0x653
f0114e7f:	68 02 8b 12 f0       	push   $0xf0128b02
f0114e84:	e8 4d b6 fe ff       	call   f01004d6 <_warn>
f0114e89:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e8c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114e90:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e94:	74 04                	je     f0114e9a <test_calculate_required_frames+0x2ef>
f0114e96:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114e9a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0114e9e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114ea1:	89 d0                	mov    %edx,%eax
f0114ea3:	c1 e0 02             	shl    $0x2,%eax
f0114ea6:	01 d0                	add    %edx,%eax
f0114ea8:	01 c0                	add    %eax,%eax
f0114eaa:	83 ec 04             	sub    $0x4,%esp
f0114ead:	50                   	push   %eax
f0114eae:	68 00 00 40 00       	push   $0x400000
f0114eb3:	ff 75 d8             	pushl  -0x28(%ebp)
f0114eb6:	e8 10 56 ff ff       	call   f010a4cb <calculate_required_frames>
f0114ebb:	83 c4 10             	add    $0x10,%esp
f0114ebe:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0114ec1:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0114ec8:	74 26                	je     f0114ef0 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0114eca:	83 ec 0c             	sub    $0xc,%esp
f0114ecd:	68 03 0a 00 00       	push   $0xa03
f0114ed2:	ff 75 c8             	pushl  -0x38(%ebp)
f0114ed5:	68 7c a3 12 f0       	push   $0xf012a37c
f0114eda:	68 5d 06 00 00       	push   $0x65d
f0114edf:	68 02 8b 12 f0       	push   $0xf0128b02
f0114ee4:	e8 ed b5 fe ff       	call   f01004d6 <_warn>
f0114ee9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114eec:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ef0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ef4:	74 04                	je     f0114efa <test_calculate_required_frames+0x34f>
f0114ef6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114efa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0114efe:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114f01:	01 c0                	add    %eax,%eax
f0114f03:	83 ec 04             	sub    $0x4,%esp
f0114f06:	50                   	push   %eax
f0114f07:	68 00 00 70 00       	push   $0x700000
f0114f0c:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f0f:	e8 b7 55 ff ff       	call   f010a4cb <calculate_required_frames>
f0114f14:	83 c4 10             	add    $0x10,%esp
f0114f17:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0114f1a:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0114f21:	74 26                	je     f0114f49 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0114f23:	83 ec 0c             	sub    $0xc,%esp
f0114f26:	68 02 02 00 00       	push   $0x202
f0114f2b:	ff 75 c8             	pushl  -0x38(%ebp)
f0114f2e:	68 7c a3 12 f0       	push   $0xf012a37c
f0114f33:	68 69 06 00 00       	push   $0x669
f0114f38:	68 02 8b 12 f0       	push   $0xf0128b02
f0114f3d:	e8 94 b5 fe ff       	call   f01004d6 <_warn>
f0114f42:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f45:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114f49:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f4d:	74 04                	je     f0114f53 <test_calculate_required_frames+0x3a8>
f0114f4f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114f53:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0114f57:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114f5a:	83 ec 04             	sub    $0x4,%esp
f0114f5d:	50                   	push   %eax
f0114f5e:	68 ff ff 3f 00       	push   $0x3fffff
f0114f63:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f66:	e8 60 55 ff ff       	call   f010a4cb <calculate_required_frames>
f0114f6b:	83 c4 10             	add    $0x10,%esp
f0114f6e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0114f71:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0114f75:	74 23                	je     f0114f9a <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0114f77:	83 ec 0c             	sub    $0xc,%esp
f0114f7a:	6a 04                	push   $0x4
f0114f7c:	ff 75 c8             	pushl  -0x38(%ebp)
f0114f7f:	68 7c a3 12 f0       	push   $0xf012a37c
f0114f84:	68 73 06 00 00       	push   $0x673
f0114f89:	68 02 8b 12 f0       	push   $0xf0128b02
f0114f8e:	e8 43 b5 fe ff       	call   f01004d6 <_warn>
f0114f93:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f96:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114f9a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f9e:	74 04                	je     f0114fa4 <test_calculate_required_frames+0x3f9>
f0114fa0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114fa4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114fa8:	83 ec 0c             	sub    $0xc,%esp
f0114fab:	68 b5 9e 12 f0       	push   $0xf0129eb5
f0114fb0:	e8 d6 bf fe ff       	call   f0100f8b <cprintf>
f0114fb5:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0114fb8:	83 ec 0c             	sub    $0xc,%esp
f0114fbb:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0114fc0:	e8 c6 bf fe ff       	call   f0100f8b <cprintf>
f0114fc5:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0114fc8:	83 ec 04             	sub    $0x4,%esp
f0114fcb:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114fd1:	50                   	push   %eax
f0114fd2:	68 6e 92 12 f0       	push   $0xf012926e
f0114fd7:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114fdd:	50                   	push   %eax
f0114fde:	e8 60 ab 00 00       	call   f011fb43 <strcconcat>
f0114fe3:	83 c4 10             	add    $0x10,%esp
f0114fe6:	83 ec 0c             	sub    $0xc,%esp
f0114fe9:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114fef:	50                   	push   %eax
f0114ff0:	e8 06 cf fe ff       	call   f0101efb <execute_command>
f0114ff5:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114ff8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114ffb:	c1 e0 03             	shl    $0x3,%eax
f0114ffe:	83 ec 04             	sub    $0x4,%esp
f0115001:	50                   	push   %eax
f0115002:	6a 00                	push   $0x0
f0115004:	ff 75 d8             	pushl  -0x28(%ebp)
f0115007:	e8 bf 54 ff ff       	call   f010a4cb <calculate_required_frames>
f011500c:	83 c4 10             	add    $0x10,%esp
f011500f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115012:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115019:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011501c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011501f:	74 24                	je     f0115045 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115021:	83 ec 0c             	sub    $0xc,%esp
f0115024:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115027:	ff 75 c8             	pushl  -0x38(%ebp)
f011502a:	68 7c a3 12 f0       	push   $0xf012a37c
f011502f:	68 87 06 00 00       	push   $0x687
f0115034:	68 02 8b 12 f0       	push   $0xf0128b02
f0115039:	e8 98 b4 fe ff       	call   f01004d6 <_warn>
f011503e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115041:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115045:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115049:	74 04                	je     f011504f <test_calculate_required_frames+0x4a4>
f011504b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011504f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115053:	83 ec 04             	sub    $0x4,%esp
f0115056:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011505c:	50                   	push   %eax
f011505d:	68 7b 92 12 f0       	push   $0xf012927b
f0115062:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115068:	50                   	push   %eax
f0115069:	e8 d5 aa 00 00       	call   f011fb43 <strcconcat>
f011506e:	83 c4 10             	add    $0x10,%esp
f0115071:	83 ec 0c             	sub    $0xc,%esp
f0115074:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011507a:	50                   	push   %eax
f011507b:	e8 7b ce fe ff       	call   f0101efb <execute_command>
f0115080:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115083:	83 ec 04             	sub    $0x4,%esp
f0115086:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011508c:	50                   	push   %eax
f011508d:	68 08 a4 12 f0       	push   $0xf012a408
f0115092:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115098:	50                   	push   %eax
f0115099:	e8 a5 aa 00 00       	call   f011fb43 <strcconcat>
f011509e:	83 c4 10             	add    $0x10,%esp
f01150a1:	83 ec 0c             	sub    $0xc,%esp
f01150a4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01150aa:	50                   	push   %eax
f01150ab:	e8 4b ce fe ff       	call   f0101efb <execute_command>
f01150b0:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f01150b3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01150b6:	c1 e0 03             	shl    $0x3,%eax
f01150b9:	83 ec 04             	sub    $0x4,%esp
f01150bc:	50                   	push   %eax
f01150bd:	6a 00                	push   $0x0
f01150bf:	ff 75 d8             	pushl  -0x28(%ebp)
f01150c2:	e8 04 54 ff ff       	call   f010a4cb <calculate_required_frames>
f01150c7:	83 c4 10             	add    $0x10,%esp
f01150ca:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01150cd:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f01150d4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01150d7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01150da:	74 24                	je     f0115100 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01150dc:	83 ec 0c             	sub    $0xc,%esp
f01150df:	ff 75 c4             	pushl  -0x3c(%ebp)
f01150e2:	ff 75 c8             	pushl  -0x38(%ebp)
f01150e5:	68 7c a3 12 f0       	push   $0xf012a37c
f01150ea:	68 95 06 00 00       	push   $0x695
f01150ef:	68 02 8b 12 f0       	push   $0xf0128b02
f01150f4:	e8 dd b3 fe ff       	call   f01004d6 <_warn>
f01150f9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01150fc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115100:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115104:	74 04                	je     f011510a <test_calculate_required_frames+0x55f>
f0115106:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011510a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011510e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115111:	c1 e0 0a             	shl    $0xa,%eax
f0115114:	83 ec 04             	sub    $0x4,%esp
f0115117:	50                   	push   %eax
f0115118:	6a 00                	push   $0x0
f011511a:	ff 75 d8             	pushl  -0x28(%ebp)
f011511d:	e8 a9 53 ff ff       	call   f010a4cb <calculate_required_frames>
f0115122:	83 c4 10             	add    $0x10,%esp
f0115125:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115128:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011512b:	c1 e0 0a             	shl    $0xa,%eax
f011512e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115131:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115138:	99                   	cltd   
f0115139:	f7 fb                	idiv   %ebx
f011513b:	89 c1                	mov    %eax,%ecx
f011513d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115140:	c1 e0 0a             	shl    $0xa,%eax
f0115143:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115146:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011514d:	99                   	cltd   
f011514e:	f7 fe                	idiv   %esi
f0115150:	01 c8                	add    %ecx,%eax
f0115152:	83 e8 05             	sub    $0x5,%eax
f0115155:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115158:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011515b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011515e:	74 24                	je     f0115184 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115160:	83 ec 0c             	sub    $0xc,%esp
f0115163:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115166:	ff 75 c8             	pushl  -0x38(%ebp)
f0115169:	68 7c a3 12 f0       	push   $0xf012a37c
f011516e:	68 a0 06 00 00       	push   $0x6a0
f0115173:	68 02 8b 12 f0       	push   $0xf0128b02
f0115178:	e8 59 b3 fe ff       	call   f01004d6 <_warn>
f011517d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115180:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115184:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115188:	74 04                	je     f011518e <test_calculate_required_frames+0x5e3>
f011518a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011518e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115192:	83 ec 04             	sub    $0x4,%esp
f0115195:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011519b:	50                   	push   %eax
f011519c:	68 14 a4 12 f0       	push   $0xf012a414
f01151a1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01151a7:	50                   	push   %eax
f01151a8:	e8 96 a9 00 00       	call   f011fb43 <strcconcat>
f01151ad:	83 c4 10             	add    $0x10,%esp
f01151b0:	83 ec 0c             	sub    $0xc,%esp
f01151b3:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01151b9:	50                   	push   %eax
f01151ba:	e8 3c cd fe ff       	call   f0101efb <execute_command>
f01151bf:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01151c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01151c5:	89 c2                	mov    %eax,%edx
f01151c7:	01 d2                	add    %edx,%edx
f01151c9:	01 d0                	add    %edx,%eax
f01151cb:	83 ec 04             	sub    $0x4,%esp
f01151ce:	50                   	push   %eax
f01151cf:	68 00 18 00 00       	push   $0x1800
f01151d4:	ff 75 d8             	pushl  -0x28(%ebp)
f01151d7:	e8 ef 52 ff ff       	call   f010a4cb <calculate_required_frames>
f01151dc:	83 c4 10             	add    $0x10,%esp
f01151df:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01151e2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01151e9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01151ec:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01151ef:	74 24                	je     f0115215 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01151f1:	83 ec 0c             	sub    $0xc,%esp
f01151f4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01151f7:	ff 75 c8             	pushl  -0x38(%ebp)
f01151fa:	68 7c a3 12 f0       	push   $0xf012a37c
f01151ff:	68 af 06 00 00       	push   $0x6af
f0115204:	68 02 8b 12 f0       	push   $0xf0128b02
f0115209:	e8 c8 b2 fe ff       	call   f01004d6 <_warn>
f011520e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115211:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115215:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115219:	74 04                	je     f011521f <test_calculate_required_frames+0x674>
f011521b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011521f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115223:	83 ec 04             	sub    $0x4,%esp
f0115226:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011522c:	50                   	push   %eax
f011522d:	68 d4 94 12 f0       	push   $0xf01294d4
f0115232:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115238:	50                   	push   %eax
f0115239:	e8 05 a9 00 00       	call   f011fb43 <strcconcat>
f011523e:	83 c4 10             	add    $0x10,%esp
f0115241:	83 ec 0c             	sub    $0xc,%esp
f0115244:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011524a:	50                   	push   %eax
f011524b:	e8 ab cc fe ff       	call   f0101efb <execute_command>
f0115250:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115253:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115256:	89 d0                	mov    %edx,%eax
f0115258:	c1 e0 02             	shl    $0x2,%eax
f011525b:	01 d0                	add    %edx,%eax
f011525d:	01 c0                	add    %eax,%eax
f011525f:	83 ec 04             	sub    $0x4,%esp
f0115262:	50                   	push   %eax
f0115263:	68 00 00 40 00       	push   $0x400000
f0115268:	ff 75 d8             	pushl  -0x28(%ebp)
f011526b:	e8 5b 52 ff ff       	call   f010a4cb <calculate_required_frames>
f0115270:	83 c4 10             	add    $0x10,%esp
f0115273:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115276:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f011527d:	74 26                	je     f01152a5 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f011527f:	83 ec 0c             	sub    $0xc,%esp
f0115282:	68 03 0a 00 00       	push   $0xa03
f0115287:	ff 75 c8             	pushl  -0x38(%ebp)
f011528a:	68 7c a3 12 f0       	push   $0xf012a37c
f011528f:	68 bb 06 00 00       	push   $0x6bb
f0115294:	68 02 8b 12 f0       	push   $0xf0128b02
f0115299:	e8 38 b2 fe ff       	call   f01004d6 <_warn>
f011529e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152a1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01152a5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152a9:	74 04                	je     f01152af <test_calculate_required_frames+0x704>
f01152ab:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01152af:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01152b3:	83 ec 04             	sub    $0x4,%esp
f01152b6:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01152bc:	50                   	push   %eax
f01152bd:	68 de 94 12 f0       	push   $0xf01294de
f01152c2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01152c8:	50                   	push   %eax
f01152c9:	e8 75 a8 00 00       	call   f011fb43 <strcconcat>
f01152ce:	83 c4 10             	add    $0x10,%esp
f01152d1:	83 ec 0c             	sub    $0xc,%esp
f01152d4:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01152da:	50                   	push   %eax
f01152db:	e8 1b cc fe ff       	call   f0101efb <execute_command>
f01152e0:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01152e3:	83 ec 04             	sub    $0x4,%esp
f01152e6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01152ec:	50                   	push   %eax
f01152ed:	68 1c a4 12 f0       	push   $0xf012a41c
f01152f2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01152f8:	50                   	push   %eax
f01152f9:	e8 45 a8 00 00       	call   f011fb43 <strcconcat>
f01152fe:	83 c4 10             	add    $0x10,%esp
f0115301:	83 ec 0c             	sub    $0xc,%esp
f0115304:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011530a:	50                   	push   %eax
f011530b:	e8 eb cb fe ff       	call   f0101efb <execute_command>
f0115310:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115313:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115316:	01 c0                	add    %eax,%eax
f0115318:	83 ec 04             	sub    $0x4,%esp
f011531b:	50                   	push   %eax
f011531c:	68 00 00 70 00       	push   $0x700000
f0115321:	ff 75 d8             	pushl  -0x28(%ebp)
f0115324:	e8 a2 51 ff ff       	call   f010a4cb <calculate_required_frames>
f0115329:	83 c4 10             	add    $0x10,%esp
f011532c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f011532f:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115336:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115339:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011533c:	74 24                	je     f0115362 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011533e:	83 ec 0c             	sub    $0xc,%esp
f0115341:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115344:	ff 75 c8             	pushl  -0x38(%ebp)
f0115347:	68 7c a3 12 f0       	push   $0xf012a37c
f011534c:	68 cb 06 00 00       	push   $0x6cb
f0115351:	68 02 8b 12 f0       	push   $0xf0128b02
f0115356:	e8 7b b1 fe ff       	call   f01004d6 <_warn>
f011535b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011535e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115362:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115366:	74 04                	je     f011536c <test_calculate_required_frames+0x7c1>
f0115368:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011536c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115370:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115373:	83 ec 04             	sub    $0x4,%esp
f0115376:	50                   	push   %eax
f0115377:	68 ff ff 3f 00       	push   $0x3fffff
f011537c:	ff 75 d8             	pushl  -0x28(%ebp)
f011537f:	e8 47 51 ff ff       	call   f010a4cb <calculate_required_frames>
f0115384:	83 c4 10             	add    $0x10,%esp
f0115387:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f011538a:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115391:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115394:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115397:	74 24                	je     f01153bd <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115399:	83 ec 0c             	sub    $0xc,%esp
f011539c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011539f:	ff 75 c8             	pushl  -0x38(%ebp)
f01153a2:	68 7c a3 12 f0       	push   $0xf012a37c
f01153a7:	68 d6 06 00 00       	push   $0x6d6
f01153ac:	68 02 8b 12 f0       	push   $0xf0128b02
f01153b1:	e8 20 b1 fe ff       	call   f01004d6 <_warn>
f01153b6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153b9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01153bd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153c1:	74 04                	je     f01153c7 <test_calculate_required_frames+0x81c>
f01153c3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01153c7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01153cb:	83 ec 0c             	sub    $0xc,%esp
f01153ce:	68 8f 94 12 f0       	push   $0xf012948f
f01153d3:	e8 b3 bb fe ff       	call   f0100f8b <cprintf>
f01153d8:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f01153db:	83 ec 08             	sub    $0x8,%esp
f01153de:	ff 75 e4             	pushl  -0x1c(%ebp)
f01153e1:	68 28 a4 12 f0       	push   $0xf012a428
f01153e6:	e8 a0 bb fe ff       	call   f0100f8b <cprintf>
f01153eb:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01153ee:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01153f2:	75 10                	jne    f0115404 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f01153f4:	83 ec 0c             	sub    $0xc,%esp
f01153f7:	68 68 a4 12 f0       	push   $0xf012a468
f01153fc:	e8 8a bb fe ff       	call   f0100f8b <cprintf>
f0115401:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115404:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0115409:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011540c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011540f:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115412:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115417:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011541a:	5b                   	pop    %ebx
f011541b:	5e                   	pop    %esi
f011541c:	5f                   	pop    %edi
f011541d:	5d                   	pop    %ebp
f011541e:	c3                   	ret    

f011541f <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f011541f:	55                   	push   %ebp
f0115420:	89 e5                	mov    %esp,%ebp
f0115422:	57                   	push   %edi
f0115423:	56                   	push   %esi
f0115424:	53                   	push   %ebx
f0115425:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011542b:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011542e:	bb 04 92 12 f0       	mov    $0xf0129204,%ebx
f0115433:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115438:	89 c7                	mov    %eax,%edi
f011543a:	89 de                	mov    %ebx,%esi
f011543c:	89 d1                	mov    %edx,%ecx
f011543e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115440:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115443:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115448:	b0 00                	mov    $0x0,%al
f011544a:	89 d7                	mov    %edx,%edi
f011544c:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011544e:	6a 00                	push   $0x0
f0115450:	6a 0a                	push   $0xa
f0115452:	6a 14                	push   $0x14
f0115454:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115457:	50                   	push   %eax
f0115458:	e8 ad 54 ff ff       	call   f010a90a <env_create>
f011545d:	83 c4 10             	add    $0x10,%esp
f0115460:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115463:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115466:	8b 40 64             	mov    0x64(%eax),%eax
f0115469:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011546c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011546f:	8b 40 68             	mov    0x68(%eax),%eax
f0115472:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115475:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115478:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011547b:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115482:	75 70 20 
f0115485:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011548c:	00 00 00 
f011548f:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115492:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115497:	b8 00 00 00 00       	mov    $0x0,%eax
f011549c:	89 d7                	mov    %edx,%edi
f011549e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01154a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01154a3:	8b 40 10             	mov    0x10(%eax),%eax
f01154a6:	83 ec 08             	sub    $0x8,%esp
f01154a9:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01154af:	52                   	push   %edx
f01154b0:	50                   	push   %eax
f01154b1:	e8 b4 a5 00 00       	call   f011fa6a <ltostr>
f01154b6:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01154b9:	83 ec 04             	sub    $0x4,%esp
f01154bc:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01154c2:	50                   	push   %eax
f01154c3:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01154c9:	50                   	push   %eax
f01154ca:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01154d0:	50                   	push   %eax
f01154d1:	e8 6d a6 00 00       	call   f011fb43 <strcconcat>
f01154d6:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01154d9:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01154e0:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01154e7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f01154ee:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f01154f2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01154f9:	00 00 00 
	uint32 num_tables = 0;
f01154fc:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115503:	00 00 00 
	ClearUserSpace(proc_directory);
f0115506:	83 ec 0c             	sub    $0xc,%esp
f0115509:	ff 75 d8             	pushl  -0x28(%ebp)
f011550c:	e8 8d 0e 00 00       	call   f011639e <ClearUserSpace>
f0115511:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115514:	83 ec 0c             	sub    $0xc,%esp
f0115517:	68 48 a3 12 f0       	push   $0xf012a348
f011551c:	e8 6a ba fe ff       	call   f0100f8b <cprintf>
f0115521:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115524:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115527:	c1 e0 03             	shl    $0x3,%eax
f011552a:	89 c2                	mov    %eax,%edx
f011552c:	83 ec 0c             	sub    $0xc,%esp
f011552f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115535:	50                   	push   %eax
f0115536:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011553c:	50                   	push   %eax
f011553d:	52                   	push   %edx
f011553e:	6a 00                	push   $0x0
f0115540:	ff 75 d8             	pushl  -0x28(%ebp)
f0115543:	e8 69 4f ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115548:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011554b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115551:	85 c0                	test   %eax,%eax
f0115553:	74 27                	je     f011557c <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115555:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011555b:	83 ec 0c             	sub    $0xc,%esp
f011555e:	6a 00                	push   $0x0
f0115560:	50                   	push   %eax
f0115561:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115566:	68 0b 07 00 00       	push   $0x70b
f011556b:	68 02 8b 12 f0       	push   $0xf0128b02
f0115570:	e8 61 af fe ff       	call   f01004d6 <_warn>
f0115575:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115578:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011557c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115582:	85 c0                	test   %eax,%eax
f0115584:	74 27                	je     f01155ad <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115586:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011558c:	83 ec 0c             	sub    $0xc,%esp
f011558f:	6a 00                	push   $0x0
f0115591:	50                   	push   %eax
f0115592:	68 14 a5 12 f0       	push   $0xf012a514
f0115597:	68 10 07 00 00       	push   $0x710
f011559c:	68 02 8b 12 f0       	push   $0xf0128b02
f01155a1:	e8 30 af fe ff       	call   f01004d6 <_warn>
f01155a6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155a9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01155ad:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155b1:	74 04                	je     f01155b7 <test_calculate_allocated_space+0x198>
f01155b3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01155b7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f01155bb:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01155c2:	00 00 00 
		num_pages = 0;
f01155c5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01155cc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f01155cf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01155d2:	c1 e0 02             	shl    $0x2,%eax
f01155d5:	89 c2                	mov    %eax,%edx
f01155d7:	83 ec 0c             	sub    $0xc,%esp
f01155da:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01155e0:	50                   	push   %eax
f01155e1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01155e7:	50                   	push   %eax
f01155e8:	52                   	push   %edx
f01155e9:	6a 00                	push   $0x0
f01155eb:	ff 75 d8             	pushl  -0x28(%ebp)
f01155ee:	e8 be 4e ff ff       	call   f010a4b1 <calculate_allocated_space>
f01155f3:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01155f6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01155fc:	85 c0                	test   %eax,%eax
f01155fe:	74 27                	je     f0115627 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115600:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115606:	83 ec 0c             	sub    $0xc,%esp
f0115609:	6a 00                	push   $0x0
f011560b:	50                   	push   %eax
f011560c:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115611:	68 1c 07 00 00       	push   $0x71c
f0115616:	68 02 8b 12 f0       	push   $0xf0128b02
f011561b:	e8 b6 ae fe ff       	call   f01004d6 <_warn>
f0115620:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115623:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115627:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011562d:	85 c0                	test   %eax,%eax
f011562f:	74 27                	je     f0115658 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115631:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115637:	83 ec 0c             	sub    $0xc,%esp
f011563a:	6a 00                	push   $0x0
f011563c:	50                   	push   %eax
f011563d:	68 14 a5 12 f0       	push   $0xf012a514
f0115642:	68 21 07 00 00       	push   $0x721
f0115647:	68 02 8b 12 f0       	push   $0xf0128b02
f011564c:	e8 85 ae fe ff       	call   f01004d6 <_warn>
f0115651:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115654:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115658:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011565c:	74 04                	je     f0115662 <test_calculate_allocated_space+0x243>
f011565e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115662:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115666:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011566d:	00 00 00 
		num_pages = 0;
f0115670:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115677:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011567a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011567d:	c1 e0 0a             	shl    $0xa,%eax
f0115680:	89 c2                	mov    %eax,%edx
f0115682:	83 ec 0c             	sub    $0xc,%esp
f0115685:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011568b:	50                   	push   %eax
f011568c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115692:	50                   	push   %eax
f0115693:	52                   	push   %edx
f0115694:	6a 00                	push   $0x0
f0115696:	ff 75 d8             	pushl  -0x28(%ebp)
f0115699:	e8 13 4e ff ff       	call   f010a4b1 <calculate_allocated_space>
f011569e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01156a1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01156a7:	85 c0                	test   %eax,%eax
f01156a9:	74 27                	je     f01156d2 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01156ab:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01156b1:	83 ec 0c             	sub    $0xc,%esp
f01156b4:	6a 00                	push   $0x0
f01156b6:	50                   	push   %eax
f01156b7:	68 b4 a4 12 f0       	push   $0xf012a4b4
f01156bc:	68 2d 07 00 00       	push   $0x72d
f01156c1:	68 02 8b 12 f0       	push   $0xf0128b02
f01156c6:	e8 0b ae fe ff       	call   f01004d6 <_warn>
f01156cb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156ce:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01156d2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01156d8:	85 c0                	test   %eax,%eax
f01156da:	74 27                	je     f0115703 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01156dc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01156e2:	83 ec 0c             	sub    $0xc,%esp
f01156e5:	6a 00                	push   $0x0
f01156e7:	50                   	push   %eax
f01156e8:	68 14 a5 12 f0       	push   $0xf012a514
f01156ed:	68 32 07 00 00       	push   $0x732
f01156f2:	68 02 8b 12 f0       	push   $0xf0128b02
f01156f7:	e8 da ad fe ff       	call   f01004d6 <_warn>
f01156fc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115703:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115707:	74 04                	je     f011570d <test_calculate_allocated_space+0x2ee>
f0115709:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011570d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115711:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115718:	00 00 00 
		num_pages = 0;
f011571b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115722:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115725:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115728:	89 d0                	mov    %edx,%eax
f011572a:	01 c0                	add    %eax,%eax
f011572c:	01 d0                	add    %edx,%eax
f011572e:	01 c0                	add    %eax,%eax
f0115730:	05 00 10 00 00       	add    $0x1000,%eax
f0115735:	89 c2                	mov    %eax,%edx
f0115737:	83 ec 0c             	sub    $0xc,%esp
f011573a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115740:	50                   	push   %eax
f0115741:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115747:	50                   	push   %eax
f0115748:	52                   	push   %edx
f0115749:	68 00 10 00 00       	push   $0x1000
f011574e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115751:	e8 5b 4d ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115756:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115759:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011575f:	85 c0                	test   %eax,%eax
f0115761:	74 27                	je     f011578a <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115763:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115769:	83 ec 0c             	sub    $0xc,%esp
f011576c:	6a 00                	push   $0x0
f011576e:	50                   	push   %eax
f011576f:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115774:	68 3f 07 00 00       	push   $0x73f
f0115779:	68 02 8b 12 f0       	push   $0xf0128b02
f011577e:	e8 53 ad fe ff       	call   f01004d6 <_warn>
f0115783:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115786:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011578a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115790:	85 c0                	test   %eax,%eax
f0115792:	74 27                	je     f01157bb <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115794:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011579a:	83 ec 0c             	sub    $0xc,%esp
f011579d:	6a 00                	push   $0x0
f011579f:	50                   	push   %eax
f01157a0:	68 14 a5 12 f0       	push   $0xf012a514
f01157a5:	68 44 07 00 00       	push   $0x744
f01157aa:	68 02 8b 12 f0       	push   $0xf0128b02
f01157af:	e8 22 ad fe ff       	call   f01004d6 <_warn>
f01157b4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157b7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01157bb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157bf:	74 04                	je     f01157c5 <test_calculate_allocated_space+0x3a6>
f01157c1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01157c5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f01157c9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01157d0:	00 00 00 
		num_pages = 0;
f01157d3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01157da:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01157dd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01157e0:	89 c2                	mov    %eax,%edx
f01157e2:	01 d2                	add    %edx,%edx
f01157e4:	01 d0                	add    %edx,%eax
f01157e6:	05 00 18 00 00       	add    $0x1800,%eax
f01157eb:	89 c2                	mov    %eax,%edx
f01157ed:	83 ec 0c             	sub    $0xc,%esp
f01157f0:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01157f6:	50                   	push   %eax
f01157f7:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01157fd:	50                   	push   %eax
f01157fe:	52                   	push   %edx
f01157ff:	68 00 18 00 00       	push   $0x1800
f0115804:	ff 75 d8             	pushl  -0x28(%ebp)
f0115807:	e8 a5 4c ff ff       	call   f010a4b1 <calculate_allocated_space>
f011580c:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011580f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115815:	85 c0                	test   %eax,%eax
f0115817:	74 27                	je     f0115840 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115819:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011581f:	83 ec 0c             	sub    $0xc,%esp
f0115822:	6a 00                	push   $0x0
f0115824:	50                   	push   %eax
f0115825:	68 b4 a4 12 f0       	push   $0xf012a4b4
f011582a:	68 50 07 00 00       	push   $0x750
f011582f:	68 02 8b 12 f0       	push   $0xf0128b02
f0115834:	e8 9d ac fe ff       	call   f01004d6 <_warn>
f0115839:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011583c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115840:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115846:	85 c0                	test   %eax,%eax
f0115848:	74 27                	je     f0115871 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011584a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115850:	83 ec 0c             	sub    $0xc,%esp
f0115853:	6a 00                	push   $0x0
f0115855:	50                   	push   %eax
f0115856:	68 14 a5 12 f0       	push   $0xf012a514
f011585b:	68 55 07 00 00       	push   $0x755
f0115860:	68 02 8b 12 f0       	push   $0xf0128b02
f0115865:	e8 6c ac fe ff       	call   f01004d6 <_warn>
f011586a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011586d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115871:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115875:	74 04                	je     f011587b <test_calculate_allocated_space+0x45c>
f0115877:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011587b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f011587f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115886:	00 00 00 
		num_pages = 0;
f0115889:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115890:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115893:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115896:	89 d0                	mov    %edx,%eax
f0115898:	c1 e0 02             	shl    $0x2,%eax
f011589b:	01 d0                	add    %edx,%eax
f011589d:	01 c0                	add    %eax,%eax
f011589f:	05 00 00 40 00       	add    $0x400000,%eax
f01158a4:	89 c2                	mov    %eax,%edx
f01158a6:	83 ec 0c             	sub    $0xc,%esp
f01158a9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01158af:	50                   	push   %eax
f01158b0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01158b6:	50                   	push   %eax
f01158b7:	52                   	push   %edx
f01158b8:	68 00 00 40 00       	push   $0x400000
f01158bd:	ff 75 d8             	pushl  -0x28(%ebp)
f01158c0:	e8 ec 4b ff ff       	call   f010a4b1 <calculate_allocated_space>
f01158c5:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01158c8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01158ce:	85 c0                	test   %eax,%eax
f01158d0:	74 27                	je     f01158f9 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01158d2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01158d8:	83 ec 0c             	sub    $0xc,%esp
f01158db:	6a 00                	push   $0x0
f01158dd:	50                   	push   %eax
f01158de:	68 b4 a4 12 f0       	push   $0xf012a4b4
f01158e3:	68 61 07 00 00       	push   $0x761
f01158e8:	68 02 8b 12 f0       	push   $0xf0128b02
f01158ed:	e8 e4 ab fe ff       	call   f01004d6 <_warn>
f01158f2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158f5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01158f9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01158ff:	85 c0                	test   %eax,%eax
f0115901:	74 27                	je     f011592a <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115903:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115909:	83 ec 0c             	sub    $0xc,%esp
f011590c:	6a 00                	push   $0x0
f011590e:	50                   	push   %eax
f011590f:	68 14 a5 12 f0       	push   $0xf012a514
f0115914:	68 66 07 00 00       	push   $0x766
f0115919:	68 02 8b 12 f0       	push   $0xf0128b02
f011591e:	e8 b3 ab fe ff       	call   f01004d6 <_warn>
f0115923:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115926:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011592a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011592e:	74 04                	je     f0115934 <test_calculate_allocated_space+0x515>
f0115930:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115934:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0115938:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011593f:	00 00 00 
		num_pages = 0;
f0115942:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115949:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011594c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011594f:	05 00 00 38 00       	add    $0x380000,%eax
f0115954:	01 c0                	add    %eax,%eax
f0115956:	89 c2                	mov    %eax,%edx
f0115958:	83 ec 0c             	sub    $0xc,%esp
f011595b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115961:	50                   	push   %eax
f0115962:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115968:	50                   	push   %eax
f0115969:	52                   	push   %edx
f011596a:	68 00 00 70 00       	push   $0x700000
f011596f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115972:	e8 3a 4b ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115977:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011597a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115980:	85 c0                	test   %eax,%eax
f0115982:	74 27                	je     f01159ab <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115984:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011598a:	83 ec 0c             	sub    $0xc,%esp
f011598d:	6a 00                	push   $0x0
f011598f:	50                   	push   %eax
f0115990:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115995:	68 73 07 00 00       	push   $0x773
f011599a:	68 02 8b 12 f0       	push   $0xf0128b02
f011599f:	e8 32 ab fe ff       	call   f01004d6 <_warn>
f01159a4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159a7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01159ab:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01159b1:	85 c0                	test   %eax,%eax
f01159b3:	74 27                	je     f01159dc <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01159b5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01159bb:	83 ec 0c             	sub    $0xc,%esp
f01159be:	6a 00                	push   $0x0
f01159c0:	50                   	push   %eax
f01159c1:	68 14 a5 12 f0       	push   $0xf012a514
f01159c6:	68 78 07 00 00       	push   $0x778
f01159cb:	68 02 8b 12 f0       	push   $0xf0128b02
f01159d0:	e8 01 ab fe ff       	call   f01004d6 <_warn>
f01159d5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159d8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01159dc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159e0:	74 04                	je     f01159e6 <test_calculate_allocated_space+0x5c7>
f01159e2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01159e6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f01159ea:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01159f1:	00 00 00 
		num_pages = 0;
f01159f4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01159fb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01159fe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115a01:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115a06:	89 c2                	mov    %eax,%edx
f0115a08:	83 ec 0c             	sub    $0xc,%esp
f0115a0b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115a11:	50                   	push   %eax
f0115a12:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115a18:	50                   	push   %eax
f0115a19:	52                   	push   %edx
f0115a1a:	68 ff ff 3f 00       	push   $0x3fffff
f0115a1f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a22:	e8 8a 4a ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115a27:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115a2a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a30:	85 c0                	test   %eax,%eax
f0115a32:	74 27                	je     f0115a5b <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115a34:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a3a:	83 ec 0c             	sub    $0xc,%esp
f0115a3d:	6a 00                	push   $0x0
f0115a3f:	50                   	push   %eax
f0115a40:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115a45:	68 84 07 00 00       	push   $0x784
f0115a4a:	68 02 8b 12 f0       	push   $0xf0128b02
f0115a4f:	e8 82 aa fe ff       	call   f01004d6 <_warn>
f0115a54:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a57:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115a5b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a61:	85 c0                	test   %eax,%eax
f0115a63:	74 27                	je     f0115a8c <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115a65:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a6b:	83 ec 0c             	sub    $0xc,%esp
f0115a6e:	6a 00                	push   $0x0
f0115a70:	50                   	push   %eax
f0115a71:	68 14 a5 12 f0       	push   $0xf012a514
f0115a76:	68 89 07 00 00       	push   $0x789
f0115a7b:	68 02 8b 12 f0       	push   $0xf0128b02
f0115a80:	e8 51 aa fe ff       	call   f01004d6 <_warn>
f0115a85:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a88:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115a8c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a90:	74 04                	je     f0115a96 <test_calculate_allocated_space+0x677>
f0115a92:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115a96:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115a9a:	83 ec 0c             	sub    $0xc,%esp
f0115a9d:	68 b5 9e 12 f0       	push   $0xf0129eb5
f0115aa2:	e8 e4 b4 fe ff       	call   f0100f8b <cprintf>
f0115aa7:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115aaa:	83 ec 0c             	sub    $0xc,%esp
f0115aad:	68 d4 a3 12 f0       	push   $0xf012a3d4
f0115ab2:	e8 d4 b4 fe ff       	call   f0100f8b <cprintf>
f0115ab7:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115aba:	83 ec 04             	sub    $0x4,%esp
f0115abd:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115ac3:	50                   	push   %eax
f0115ac4:	68 6e 92 12 f0       	push   $0xf012926e
f0115ac9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115acf:	50                   	push   %eax
f0115ad0:	e8 6e a0 00 00       	call   f011fb43 <strcconcat>
f0115ad5:	83 c4 10             	add    $0x10,%esp
f0115ad8:	83 ec 0c             	sub    $0xc,%esp
f0115adb:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115ae1:	50                   	push   %eax
f0115ae2:	e8 14 c4 fe ff       	call   f0101efb <execute_command>
f0115ae7:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0115aea:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115af1:	00 00 00 
		num_pages = 0;
f0115af4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115afb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115afe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115b01:	c1 e0 03             	shl    $0x3,%eax
f0115b04:	89 c2                	mov    %eax,%edx
f0115b06:	83 ec 0c             	sub    $0xc,%esp
f0115b09:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115b0f:	50                   	push   %eax
f0115b10:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115b16:	50                   	push   %eax
f0115b17:	52                   	push   %edx
f0115b18:	6a 00                	push   $0x0
f0115b1a:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b1d:	e8 8f 49 ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115b22:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115b25:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0115b2c:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115b33:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b39:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115b3c:	74 28                	je     f0115b66 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115b3e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b44:	83 ec 0c             	sub    $0xc,%esp
f0115b47:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b4a:	50                   	push   %eax
f0115b4b:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115b50:	68 a0 07 00 00       	push   $0x7a0
f0115b55:	68 02 8b 12 f0       	push   $0xf0128b02
f0115b5a:	e8 77 a9 fe ff       	call   f01004d6 <_warn>
f0115b5f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b62:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115b66:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b6c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115b6f:	74 28                	je     f0115b99 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115b71:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b77:	83 ec 0c             	sub    $0xc,%esp
f0115b7a:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115b7d:	50                   	push   %eax
f0115b7e:	68 14 a5 12 f0       	push   $0xf012a514
f0115b83:	68 a5 07 00 00       	push   $0x7a5
f0115b88:	68 02 8b 12 f0       	push   $0xf0128b02
f0115b8d:	e8 44 a9 fe ff       	call   f01004d6 <_warn>
f0115b92:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b95:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b99:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b9d:	74 04                	je     f0115ba3 <test_calculate_allocated_space+0x784>
f0115b9f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ba3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115ba7:	83 ec 04             	sub    $0x4,%esp
f0115baa:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115bb0:	50                   	push   %eax
f0115bb1:	68 7b 92 12 f0       	push   $0xf012927b
f0115bb6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115bbc:	50                   	push   %eax
f0115bbd:	e8 81 9f 00 00       	call   f011fb43 <strcconcat>
f0115bc2:	83 c4 10             	add    $0x10,%esp
f0115bc5:	83 ec 0c             	sub    $0xc,%esp
f0115bc8:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115bce:	50                   	push   %eax
f0115bcf:	e8 27 c3 fe ff       	call   f0101efb <execute_command>
f0115bd4:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115bd7:	83 ec 04             	sub    $0x4,%esp
f0115bda:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115be0:	50                   	push   %eax
f0115be1:	68 08 a4 12 f0       	push   $0xf012a408
f0115be6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115bec:	50                   	push   %eax
f0115bed:	e8 51 9f 00 00       	call   f011fb43 <strcconcat>
f0115bf2:	83 c4 10             	add    $0x10,%esp
f0115bf5:	83 ec 0c             	sub    $0xc,%esp
f0115bf8:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115bfe:	50                   	push   %eax
f0115bff:	e8 f7 c2 fe ff       	call   f0101efb <execute_command>
f0115c04:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0115c07:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115c0e:	00 00 00 
		num_pages = 0;
f0115c11:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115c18:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0115c1b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115c1e:	c1 e0 03             	shl    $0x3,%eax
f0115c21:	89 c2                	mov    %eax,%edx
f0115c23:	83 ec 0c             	sub    $0xc,%esp
f0115c26:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c2c:	50                   	push   %eax
f0115c2d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115c33:	50                   	push   %eax
f0115c34:	52                   	push   %edx
f0115c35:	6a 00                	push   $0x0
f0115c37:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c3a:	e8 72 48 ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115c3f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115c42:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0115c49:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115c50:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c56:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115c59:	74 28                	je     f0115c83 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115c5b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c61:	83 ec 0c             	sub    $0xc,%esp
f0115c64:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c67:	50                   	push   %eax
f0115c68:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115c6d:	68 b6 07 00 00       	push   $0x7b6
f0115c72:	68 02 8b 12 f0       	push   $0xf0128b02
f0115c77:	e8 5a a8 fe ff       	call   f01004d6 <_warn>
f0115c7c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c7f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115c83:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c89:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115c8c:	74 28                	je     f0115cb6 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115c8e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c94:	83 ec 0c             	sub    $0xc,%esp
f0115c97:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115c9a:	50                   	push   %eax
f0115c9b:	68 14 a5 12 f0       	push   $0xf012a514
f0115ca0:	68 bb 07 00 00       	push   $0x7bb
f0115ca5:	68 02 8b 12 f0       	push   $0xf0128b02
f0115caa:	e8 27 a8 fe ff       	call   f01004d6 <_warn>
f0115caf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cb2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115cb6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115cba:	74 04                	je     f0115cc0 <test_calculate_allocated_space+0x8a1>
f0115cbc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115cc0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115cc4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115ccb:	00 00 00 
		num_pages = 0;
f0115cce:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115cd5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115cd8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115cdb:	c1 e0 0a             	shl    $0xa,%eax
f0115cde:	89 c2                	mov    %eax,%edx
f0115ce0:	83 ec 0c             	sub    $0xc,%esp
f0115ce3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ce9:	50                   	push   %eax
f0115cea:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115cf0:	50                   	push   %eax
f0115cf1:	52                   	push   %edx
f0115cf2:	6a 00                	push   $0x0
f0115cf4:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cf7:	e8 b5 47 ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115cfc:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0115cff:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0115d06:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115d0d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d13:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115d16:	74 28                	je     f0115d40 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115d18:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d1e:	83 ec 0c             	sub    $0xc,%esp
f0115d21:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d24:	50                   	push   %eax
f0115d25:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115d2a:	68 c9 07 00 00       	push   $0x7c9
f0115d2f:	68 02 8b 12 f0       	push   $0xf0128b02
f0115d34:	e8 9d a7 fe ff       	call   f01004d6 <_warn>
f0115d39:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d3c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115d40:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d46:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d49:	74 28                	je     f0115d73 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115d4b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d51:	83 ec 0c             	sub    $0xc,%esp
f0115d54:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d57:	50                   	push   %eax
f0115d58:	68 14 a5 12 f0       	push   $0xf012a514
f0115d5d:	68 ce 07 00 00       	push   $0x7ce
f0115d62:	68 02 8b 12 f0       	push   $0xf0128b02
f0115d67:	e8 6a a7 fe ff       	call   f01004d6 <_warn>
f0115d6c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d6f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115d73:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d77:	74 04                	je     f0115d7d <test_calculate_allocated_space+0x95e>
f0115d79:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115d7d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115d81:	83 ec 04             	sub    $0x4,%esp
f0115d84:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115d8a:	50                   	push   %eax
f0115d8b:	68 14 a4 12 f0       	push   $0xf012a414
f0115d90:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d96:	50                   	push   %eax
f0115d97:	e8 a7 9d 00 00       	call   f011fb43 <strcconcat>
f0115d9c:	83 c4 10             	add    $0x10,%esp
f0115d9f:	83 ec 0c             	sub    $0xc,%esp
f0115da2:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115da8:	50                   	push   %eax
f0115da9:	e8 4d c1 fe ff       	call   f0101efb <execute_command>
f0115dae:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0115db1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115db8:	00 00 00 
		num_pages = 0;
f0115dbb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115dc2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115dc5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115dc8:	89 c2                	mov    %eax,%edx
f0115dca:	01 d2                	add    %edx,%edx
f0115dcc:	01 d0                	add    %edx,%eax
f0115dce:	05 00 18 00 00       	add    $0x1800,%eax
f0115dd3:	89 c2                	mov    %eax,%edx
f0115dd5:	83 ec 0c             	sub    $0xc,%esp
f0115dd8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115dde:	50                   	push   %eax
f0115ddf:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115de5:	50                   	push   %eax
f0115de6:	52                   	push   %edx
f0115de7:	68 00 18 00 00       	push   $0x1800
f0115dec:	ff 75 d8             	pushl  -0x28(%ebp)
f0115def:	e8 bd 46 ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115df4:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115df7:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115dfe:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115e05:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e0b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115e0e:	74 28                	je     f0115e38 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115e10:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e16:	83 ec 0c             	sub    $0xc,%esp
f0115e19:	ff 75 c8             	pushl  -0x38(%ebp)
f0115e1c:	50                   	push   %eax
f0115e1d:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115e22:	68 df 07 00 00       	push   $0x7df
f0115e27:	68 02 8b 12 f0       	push   $0xf0128b02
f0115e2c:	e8 a5 a6 fe ff       	call   f01004d6 <_warn>
f0115e31:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e34:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115e38:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e3e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115e41:	74 28                	je     f0115e6b <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115e43:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e49:	83 ec 0c             	sub    $0xc,%esp
f0115e4c:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115e4f:	50                   	push   %eax
f0115e50:	68 14 a5 12 f0       	push   $0xf012a514
f0115e55:	68 e4 07 00 00       	push   $0x7e4
f0115e5a:	68 02 8b 12 f0       	push   $0xf0128b02
f0115e5f:	e8 72 a6 fe ff       	call   f01004d6 <_warn>
f0115e64:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e67:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e6b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e6f:	74 04                	je     f0115e75 <test_calculate_allocated_space+0xa56>
f0115e71:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e75:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115e79:	83 ec 04             	sub    $0x4,%esp
f0115e7c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115e82:	50                   	push   %eax
f0115e83:	68 d4 94 12 f0       	push   $0xf01294d4
f0115e88:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e8e:	50                   	push   %eax
f0115e8f:	e8 af 9c 00 00       	call   f011fb43 <strcconcat>
f0115e94:	83 c4 10             	add    $0x10,%esp
f0115e97:	83 ec 0c             	sub    $0xc,%esp
f0115e9a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115ea0:	50                   	push   %eax
f0115ea1:	e8 55 c0 fe ff       	call   f0101efb <execute_command>
f0115ea6:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0115ea9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115eb0:	00 00 00 
		num_pages = 0;
f0115eb3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115eba:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115ebd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115ec0:	89 d0                	mov    %edx,%eax
f0115ec2:	c1 e0 02             	shl    $0x2,%eax
f0115ec5:	01 d0                	add    %edx,%eax
f0115ec7:	01 c0                	add    %eax,%eax
f0115ec9:	05 00 00 40 00       	add    $0x400000,%eax
f0115ece:	89 c2                	mov    %eax,%edx
f0115ed0:	83 ec 0c             	sub    $0xc,%esp
f0115ed3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ed9:	50                   	push   %eax
f0115eda:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115ee0:	50                   	push   %eax
f0115ee1:	52                   	push   %edx
f0115ee2:	68 00 00 40 00       	push   $0x400000
f0115ee7:	ff 75 d8             	pushl  -0x28(%ebp)
f0115eea:	e8 c2 45 ff ff       	call   f010a4b1 <calculate_allocated_space>
f0115eef:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115ef2:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0115ef9:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115f00:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f06:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115f09:	74 28                	je     f0115f33 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115f0b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f11:	83 ec 0c             	sub    $0xc,%esp
f0115f14:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f17:	50                   	push   %eax
f0115f18:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0115f1d:	68 f4 07 00 00       	push   $0x7f4
f0115f22:	68 02 8b 12 f0       	push   $0xf0128b02
f0115f27:	e8 aa a5 fe ff       	call   f01004d6 <_warn>
f0115f2c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f2f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115f33:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f39:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115f3c:	74 28                	je     f0115f66 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115f3e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f44:	83 ec 0c             	sub    $0xc,%esp
f0115f47:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115f4a:	50                   	push   %eax
f0115f4b:	68 14 a5 12 f0       	push   $0xf012a514
f0115f50:	68 f9 07 00 00       	push   $0x7f9
f0115f55:	68 02 8b 12 f0       	push   $0xf0128b02
f0115f5a:	e8 77 a5 fe ff       	call   f01004d6 <_warn>
f0115f5f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f62:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f66:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f6a:	74 04                	je     f0115f70 <test_calculate_allocated_space+0xb51>
f0115f6c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f70:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115f74:	83 ec 04             	sub    $0x4,%esp
f0115f77:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115f7d:	50                   	push   %eax
f0115f7e:	68 de 94 12 f0       	push   $0xf01294de
f0115f83:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115f89:	50                   	push   %eax
f0115f8a:	e8 b4 9b 00 00       	call   f011fb43 <strcconcat>
f0115f8f:	83 c4 10             	add    $0x10,%esp
f0115f92:	83 ec 0c             	sub    $0xc,%esp
f0115f95:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115f9b:	50                   	push   %eax
f0115f9c:	e8 5a bf fe ff       	call   f0101efb <execute_command>
f0115fa1:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115fa4:	83 ec 04             	sub    $0x4,%esp
f0115fa7:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115fad:	50                   	push   %eax
f0115fae:	68 1c a4 12 f0       	push   $0xf012a41c
f0115fb3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115fb9:	50                   	push   %eax
f0115fba:	e8 84 9b 00 00       	call   f011fb43 <strcconcat>
f0115fbf:	83 c4 10             	add    $0x10,%esp
f0115fc2:	83 ec 0c             	sub    $0xc,%esp
f0115fc5:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115fcb:	50                   	push   %eax
f0115fcc:	e8 2a bf fe ff       	call   f0101efb <execute_command>
f0115fd1:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0115fd4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115fdb:	00 00 00 
		num_pages = 0;
f0115fde:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115fe5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0115fe8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115feb:	05 00 00 38 00       	add    $0x380000,%eax
f0115ff0:	01 c0                	add    %eax,%eax
f0115ff2:	89 c2                	mov    %eax,%edx
f0115ff4:	83 ec 0c             	sub    $0xc,%esp
f0115ff7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ffd:	50                   	push   %eax
f0115ffe:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116004:	50                   	push   %eax
f0116005:	52                   	push   %edx
f0116006:	68 00 00 70 00       	push   $0x700000
f011600b:	ff 75 d8             	pushl  -0x28(%ebp)
f011600e:	e8 9e 44 ff ff       	call   f010a4b1 <calculate_allocated_space>
f0116013:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116016:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f011601d:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116024:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011602a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011602d:	74 28                	je     f0116057 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011602f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116035:	83 ec 0c             	sub    $0xc,%esp
f0116038:	ff 75 c8             	pushl  -0x38(%ebp)
f011603b:	50                   	push   %eax
f011603c:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0116041:	68 0b 08 00 00       	push   $0x80b
f0116046:	68 02 8b 12 f0       	push   $0xf0128b02
f011604b:	e8 86 a4 fe ff       	call   f01004d6 <_warn>
f0116050:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116053:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116057:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011605d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116060:	74 28                	je     f011608a <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116062:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116068:	83 ec 0c             	sub    $0xc,%esp
f011606b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011606e:	50                   	push   %eax
f011606f:	68 14 a5 12 f0       	push   $0xf012a514
f0116074:	68 10 08 00 00       	push   $0x810
f0116079:	68 02 8b 12 f0       	push   $0xf0128b02
f011607e:	e8 53 a4 fe ff       	call   f01004d6 <_warn>
f0116083:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116086:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011608a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011608e:	74 04                	je     f0116094 <test_calculate_allocated_space+0xc75>
f0116090:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116094:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116098:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011609f:	00 00 00 
		num_pages = 0;
f01160a2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160a9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01160ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01160af:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01160b4:	89 c2                	mov    %eax,%edx
f01160b6:	83 ec 0c             	sub    $0xc,%esp
f01160b9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160bf:	50                   	push   %eax
f01160c0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160c6:	50                   	push   %eax
f01160c7:	52                   	push   %edx
f01160c8:	68 ff ff 3f 00       	push   $0x3fffff
f01160cd:	ff 75 d8             	pushl  -0x28(%ebp)
f01160d0:	e8 dc 43 ff ff       	call   f010a4b1 <calculate_allocated_space>
f01160d5:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01160d8:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f01160df:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01160e6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160ec:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01160ef:	74 28                	je     f0116119 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01160f1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160f7:	83 ec 0c             	sub    $0xc,%esp
f01160fa:	ff 75 c8             	pushl  -0x38(%ebp)
f01160fd:	50                   	push   %eax
f01160fe:	68 b4 a4 12 f0       	push   $0xf012a4b4
f0116103:	68 1e 08 00 00       	push   $0x81e
f0116108:	68 02 8b 12 f0       	push   $0xf0128b02
f011610d:	e8 c4 a3 fe ff       	call   f01004d6 <_warn>
f0116112:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116115:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116119:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011611f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116122:	74 28                	je     f011614c <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116124:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011612a:	83 ec 0c             	sub    $0xc,%esp
f011612d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116130:	50                   	push   %eax
f0116131:	68 14 a5 12 f0       	push   $0xf012a514
f0116136:	68 23 08 00 00       	push   $0x823
f011613b:	68 02 8b 12 f0       	push   $0xf0128b02
f0116140:	e8 91 a3 fe ff       	call   f01004d6 <_warn>
f0116145:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116148:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011614c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116150:	74 04                	je     f0116156 <test_calculate_allocated_space+0xd37>
f0116152:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116156:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011615a:	83 ec 0c             	sub    $0xc,%esp
f011615d:	68 8f 94 12 f0       	push   $0xf012948f
f0116162:	e8 24 ae fe ff       	call   f0100f8b <cprintf>
f0116167:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011616a:	83 ec 08             	sub    $0x8,%esp
f011616d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116170:	68 70 a5 12 f0       	push   $0xf012a570
f0116175:	e8 11 ae fe ff       	call   f0100f8b <cprintf>
f011617a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011617d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116181:	75 10                	jne    f0116193 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116183:	83 ec 0c             	sub    $0xc,%esp
f0116186:	68 b0 a5 12 f0       	push   $0xf012a5b0
f011618b:	e8 fb ad fe ff       	call   f0100f8b <cprintf>
f0116190:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116193:	a1 a4 da 6b f0       	mov    0xf06bdaa4,%eax
f0116198:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011619b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011619e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01161a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01161a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01161a9:	5b                   	pop    %ebx
f01161aa:	5e                   	pop    %esi
f01161ab:	5f                   	pop    %edi
f01161ac:	5d                   	pop    %ebp
f01161ad:	c3                   	ret    

f01161ae <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01161ae:	55                   	push   %ebp
f01161af:	89 e5                	mov    %esp,%ebp
f01161b1:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01161b4:	8b 45 10             	mov    0x10(%ebp),%eax
f01161b7:	ba 01 00 00 00       	mov    $0x1,%edx
f01161bc:	88 c1                	mov    %al,%cl
f01161be:	d3 e2                	shl    %cl,%edx
f01161c0:	89 d0                	mov    %edx,%eax
f01161c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01161c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01161c8:	c1 e8 16             	shr    $0x16,%eax
f01161cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01161d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01161d5:	01 d0                	add    %edx,%eax
f01161d7:	8b 00                	mov    (%eax),%eax
f01161d9:	83 e0 01             	and    $0x1,%eax
f01161dc:	85 c0                	test   %eax,%eax
f01161de:	75 07                	jne    f01161e7 <CB+0x39>
f01161e0:	b8 00 00 00 00       	mov    $0x0,%eax
f01161e5:	eb 76                	jmp    f011625d <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01161e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01161ea:	c1 e8 16             	shr    $0x16,%eax
f01161ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01161f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01161f7:	01 d0                	add    %edx,%eax
f01161f9:	8b 00                	mov    (%eax),%eax
f01161fb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116200:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116203:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116206:	c1 e8 0c             	shr    $0xc,%eax
f0116209:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011620c:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f0116211:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116214:	72 17                	jb     f011622d <CB+0x7f>
f0116216:	ff 75 f0             	pushl  -0x10(%ebp)
f0116219:	68 fc a5 12 f0       	push   $0xf012a5fc
f011621e:	68 3e 08 00 00       	push   $0x83e
f0116223:	68 02 8b 12 f0       	push   $0xf0128b02
f0116228:	e8 0c a1 fe ff       	call   f0100339 <_panic>
f011622d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116230:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116235:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116238:	8b 45 0c             	mov    0xc(%ebp),%eax
f011623b:	c1 e8 0c             	shr    $0xc,%eax
f011623e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116243:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011624a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011624d:	01 d0                	add    %edx,%eax
f011624f:	8b 00                	mov    (%eax),%eax
f0116251:	23 45 f4             	and    -0xc(%ebp),%eax
f0116254:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116257:	0f 94 c0             	sete   %al
f011625a:	0f b6 c0             	movzbl %al,%eax
}
f011625d:	c9                   	leave  
f011625e:	c3                   	ret    

f011625f <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f011625f:	55                   	push   %ebp
f0116260:	89 e5                	mov    %esp,%ebp
f0116262:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116265:	68 2b a6 12 f0       	push   $0xf012a62b
f011626a:	68 3a a6 12 f0       	push   $0xf012a63a
f011626f:	68 43 08 00 00       	push   $0x843
f0116274:	68 02 8b 12 f0       	push   $0xf0128b02
f0116279:	e8 bb a0 fe ff       	call   f0100339 <_panic>

f011627e <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f011627e:	55                   	push   %ebp
f011627f:	89 e5                	mov    %esp,%ebp
f0116281:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116284:	68 2b a6 12 f0       	push   $0xf012a62b
f0116289:	68 3a a6 12 f0       	push   $0xf012a63a
f011628e:	68 4d 08 00 00       	push   $0x84d
f0116293:	68 02 8b 12 f0       	push   $0xf0128b02
f0116298:	e8 9c a0 fe ff       	call   f0100339 <_panic>

f011629d <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f011629d:	55                   	push   %ebp
f011629e:	89 e5                	mov    %esp,%ebp
f01162a0:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f01162a3:	68 2b a6 12 f0       	push   $0xf012a62b
f01162a8:	68 3a a6 12 f0       	push   $0xf012a63a
f01162ad:	68 5c 08 00 00       	push   $0x85c
f01162b2:	68 02 8b 12 f0       	push   $0xf0128b02
f01162b7:	e8 7d a0 fe ff       	call   f0100339 <_panic>

f01162bc <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f01162bc:	55                   	push   %ebp
f01162bd:	89 e5                	mov    %esp,%ebp
f01162bf:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01162c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01162c5:	c1 e8 16             	shr    $0x16,%eax
f01162c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01162cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01162d2:	01 d0                	add    %edx,%eax
f01162d4:	8b 00                	mov    (%eax),%eax
f01162d6:	83 e0 01             	and    $0x1,%eax
f01162d9:	85 c0                	test   %eax,%eax
f01162db:	75 07                	jne    f01162e4 <CE+0x28>
f01162dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01162e2:	eb 7a                	jmp    f011635e <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01162e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01162e7:	c1 e8 16             	shr    $0x16,%eax
f01162ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01162f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01162f4:	01 d0                	add    %edx,%eax
f01162f6:	8b 00                	mov    (%eax),%eax
f01162f8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01162fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116300:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116303:	c1 e8 0c             	shr    $0xc,%eax
f0116306:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116309:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011630e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116311:	72 17                	jb     f011632a <CE+0x6e>
f0116313:	ff 75 f4             	pushl  -0xc(%ebp)
f0116316:	68 fc a5 12 f0       	push   $0xf012a5fc
f011631b:	68 65 08 00 00       	push   $0x865
f0116320:	68 02 8b 12 f0       	push   $0xf0128b02
f0116325:	e8 0f a0 fe ff       	call   f0100339 <_panic>
f011632a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011632d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116332:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116335:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116338:	c1 e8 0c             	shr    $0xc,%eax
f011633b:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116340:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116347:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011634a:	01 d0                	add    %edx,%eax
f011634c:	8b 00                	mov    (%eax),%eax
f011634e:	85 c0                	test   %eax,%eax
f0116350:	74 07                	je     f0116359 <CE+0x9d>
f0116352:	b8 00 00 00 00       	mov    $0x0,%eax
f0116357:	eb 05                	jmp    f011635e <CE+0xa2>
	return 1;
f0116359:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011635e:	c9                   	leave  
f011635f:	c3                   	ret    

f0116360 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116360:	55                   	push   %ebp
f0116361:	89 e5                	mov    %esp,%ebp
f0116363:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116366:	68 2b a6 12 f0       	push   $0xf012a62b
f011636b:	68 3a a6 12 f0       	push   $0xf012a63a
f0116370:	68 6c 08 00 00       	push   $0x86c
f0116375:	68 02 8b 12 f0       	push   $0xf0128b02
f011637a:	e8 ba 9f fe ff       	call   f0100339 <_panic>

f011637f <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f011637f:	55                   	push   %ebp
f0116380:	89 e5                	mov    %esp,%ebp
f0116382:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116385:	68 2b a6 12 f0       	push   $0xf012a62b
f011638a:	68 3a a6 12 f0       	push   $0xf012a63a
f011638f:	68 7c 08 00 00       	push   $0x87c
f0116394:	68 02 8b 12 f0       	push   $0xf0128b02
f0116399:	e8 9b 9f fe ff       	call   f0100339 <_panic>

f011639e <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f011639e:	55                   	push   %ebp
f011639f:	89 e5                	mov    %esp,%ebp
f01163a1:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01163a4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01163ab:	eb 18                	jmp    f01163c5 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f01163ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01163b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01163b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01163ba:	01 d0                	add    %edx,%eax
f01163bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01163c2:	ff 45 fc             	incl   -0x4(%ebp)
f01163c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01163c8:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f01163cd:	76 de                	jbe    f01163ad <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f01163cf:	90                   	nop
f01163d0:	c9                   	leave  
f01163d1:	c3                   	ret    

f01163d2 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f01163d2:	55                   	push   %ebp
f01163d3:	89 e5                	mov    %esp,%ebp
f01163d5:	83 ec 38             	sub    $0x38,%esp
f01163d8:	8b 45 2c             	mov    0x2c(%ebp),%eax
f01163db:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f01163de:	8b 45 0c             	mov    0xc(%ebp),%eax
f01163e1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01163e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f01163e9:	8b 45 10             	mov    0x10(%ebp),%eax
f01163ec:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01163f1:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01163f4:	e9 ea 01 00 00       	jmp    f01165e3 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f01163f9:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01163fd:	74 44                	je     f0116443 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f01163ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116402:	83 ec 04             	sub    $0x4,%esp
f0116405:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116408:	52                   	push   %edx
f0116409:	50                   	push   %eax
f011640a:	ff 75 08             	pushl  0x8(%ebp)
f011640d:	e8 57 23 ff ff       	call   f0108769 <get_frame_info>
f0116412:	83 c4 10             	add    $0x10,%esp
f0116415:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116418:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011641b:	85 c0                	test   %eax,%eax
f011641d:	75 24                	jne    f0116443 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f011641f:	83 ec 04             	sub    $0x4,%esp
f0116422:	68 50 a6 12 f0       	push   $0xf012a650
f0116427:	68 99 08 00 00       	push   $0x899
f011642c:	68 02 8b 12 f0       	push   $0xf0128b02
f0116431:	e8 a0 a0 fe ff       	call   f01004d6 <_warn>
f0116436:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116439:	b8 00 00 00 00       	mov    $0x0,%eax
f011643e:	e9 b6 01 00 00       	jmp    f01165f9 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116443:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116446:	83 ec 04             	sub    $0x4,%esp
f0116449:	8d 55 d8             	lea    -0x28(%ebp),%edx
f011644c:	52                   	push   %edx
f011644d:	50                   	push   %eax
f011644e:	ff 75 08             	pushl  0x8(%ebp)
f0116451:	e8 13 23 ff ff       	call   f0108769 <get_frame_info>
f0116456:	83 c4 10             	add    $0x10,%esp
f0116459:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f011645c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011645f:	85 c0                	test   %eax,%eax
f0116461:	75 24                	jne    f0116487 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116463:	83 ec 04             	sub    $0x4,%esp
f0116466:	68 7c a6 12 f0       	push   $0xf012a67c
f011646b:	68 a0 08 00 00       	push   $0x8a0
f0116470:	68 02 8b 12 f0       	push   $0xf0128b02
f0116475:	e8 5c a0 fe ff       	call   f01004d6 <_warn>
f011647a:	83 c4 10             	add    $0x10,%esp
			return 0;
f011647d:	b8 00 00 00 00       	mov    $0x0,%eax
f0116482:	e9 72 01 00 00       	jmp    f01165f9 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116487:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f011648b:	75 70                	jne    f01164fd <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f011648d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116490:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116493:	c1 ea 0c             	shr    $0xc,%edx
f0116496:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011649c:	c1 e2 02             	shl    $0x2,%edx
f011649f:	01 d0                	add    %edx,%eax
f01164a1:	8b 00                	mov    (%eax),%eax
f01164a3:	c1 e8 0c             	shr    $0xc,%eax
f01164a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f01164a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01164ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01164af:	c1 ea 0c             	shr    $0xc,%edx
f01164b2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01164b8:	c1 e2 02             	shl    $0x2,%edx
f01164bb:	01 d0                	add    %edx,%eax
f01164bd:	8b 00                	mov    (%eax),%eax
f01164bf:	c1 e8 0c             	shr    $0xc,%eax
f01164c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f01164c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01164c8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01164cb:	74 30                	je     f01164fd <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f01164cd:	83 ec 04             	sub    $0x4,%esp
f01164d0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01164d3:	ff 75 e8             	pushl  -0x18(%ebp)
f01164d6:	ff 75 f0             	pushl  -0x10(%ebp)
f01164d9:	ff 75 f4             	pushl  -0xc(%ebp)
f01164dc:	68 a8 a6 12 f0       	push   $0xf012a6a8
f01164e1:	68 aa 08 00 00       	push   $0x8aa
f01164e6:	68 02 8b 12 f0       	push   $0xf0128b02
f01164eb:	e8 e6 9f fe ff       	call   f01004d6 <_warn>
f01164f0:	83 c4 20             	add    $0x20,%esp
				return 0;
f01164f3:	b8 00 00 00 00       	mov    $0x0,%eax
f01164f8:	e9 fc 00 00 00       	jmp    f01165f9 <CCP+0x227>
			}
		}
		if (ref != -1)
f01164fd:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116501:	74 52                	je     f0116555 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116503:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116507:	74 0e                	je     f0116517 <CCP+0x145>
f0116509:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011650c:	8b 40 08             	mov    0x8(%eax),%eax
f011650f:	0f b7 c0             	movzwl %ax,%eax
f0116512:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116515:	74 3e                	je     f0116555 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116517:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011651b:	74 0b                	je     f0116528 <CCP+0x156>
f011651d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116520:	8b 40 08             	mov    0x8(%eax),%eax
f0116523:	0f b7 c0             	movzwl %ax,%eax
f0116526:	eb 05                	jmp    f011652d <CCP+0x15b>
f0116528:	b8 00 00 00 00       	mov    $0x0,%eax
f011652d:	83 ec 0c             	sub    $0xc,%esp
f0116530:	50                   	push   %eax
f0116531:	ff 75 f0             	pushl  -0x10(%ebp)
f0116534:	68 04 a7 12 f0       	push   $0xf012a704
f0116539:	68 b2 08 00 00       	push   $0x8b2
f011653e:	68 02 8b 12 f0       	push   $0xf0128b02
f0116543:	e8 8e 9f fe ff       	call   f01004d6 <_warn>
f0116548:	83 c4 20             	add    $0x20,%esp
				return 0;
f011654b:	b8 00 00 00 00       	mov    $0x0,%eax
f0116550:	e9 a4 00 00 00       	jmp    f01165f9 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116555:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116558:	ff 75 20             	pushl  0x20(%ebp)
f011655b:	ff 75 1c             	pushl  0x1c(%ebp)
f011655e:	50                   	push   %eax
f011655f:	ff 75 08             	pushl  0x8(%ebp)
f0116562:	e8 17 fd ff ff       	call   f011627e <CPs>
f0116567:	83 c4 10             	add    $0x10,%esp
f011656a:	85 c0                	test   %eax,%eax
f011656c:	7f 21                	jg     f011658f <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f011656e:	83 ec 04             	sub    $0x4,%esp
f0116571:	68 74 a7 12 f0       	push   $0xf012a774
f0116576:	68 b8 08 00 00       	push   $0x8b8
f011657b:	68 02 8b 12 f0       	push   $0xf0128b02
f0116580:	e8 51 9f fe ff       	call   f01004d6 <_warn>
f0116585:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116588:	b8 00 00 00 00       	mov    $0x0,%eax
f011658d:	eb 6a                	jmp    f01165f9 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f011658f:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116593:	74 3a                	je     f01165cf <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116595:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116598:	ff 75 28             	pushl  0x28(%ebp)
f011659b:	ff 75 24             	pushl  0x24(%ebp)
f011659e:	50                   	push   %eax
f011659f:	ff 75 08             	pushl  0x8(%ebp)
f01165a2:	e8 d7 fc ff ff       	call   f011627e <CPs>
f01165a7:	83 c4 10             	add    $0x10,%esp
f01165aa:	85 c0                	test   %eax,%eax
f01165ac:	7f 21                	jg     f01165cf <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f01165ae:	83 ec 04             	sub    $0x4,%esp
f01165b1:	68 bc a7 12 f0       	push   $0xf012a7bc
f01165b6:	68 bf 08 00 00       	push   $0x8bf
f01165bb:	68 02 8b 12 f0       	push   $0xf0128b02
f01165c0:	e8 11 9f fe ff       	call   f01004d6 <_warn>
f01165c5:	83 c4 10             	add    $0x10,%esp
				return 0;
f01165c8:	b8 00 00 00 00       	mov    $0x0,%eax
f01165cd:	eb 2a                	jmp    f01165f9 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f01165cf:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01165d3:	74 07                	je     f01165dc <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f01165d5:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01165dc:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f01165e3:	8b 55 10             	mov    0x10(%ebp),%edx
f01165e6:	8b 45 14             	mov    0x14(%ebp),%eax
f01165e9:	01 d0                	add    %edx,%eax
f01165eb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01165ee:	0f 87 05 fe ff ff    	ja     f01163f9 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f01165f4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01165f9:	c9                   	leave  
f01165fa:	c3                   	ret    

f01165fb <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f01165fb:	55                   	push   %ebp
f01165fc:	89 e5                	mov    %esp,%ebp
f01165fe:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0116601:	83 ec 04             	sub    $0x4,%esp
f0116604:	68 fc a7 12 f0       	push   $0xf012a7fc
f0116609:	6a 0e                	push   $0xe
f011660b:	68 0c a8 12 f0       	push   $0xf012a80c
f0116610:	e8 24 9d fe ff       	call   f0100339 <_panic>

f0116615 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0116615:	55                   	push   %ebp
f0116616:	89 e5                	mov    %esp,%ebp
f0116618:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f011661b:	83 ec 04             	sub    $0x4,%esp
f011661e:	68 fc a7 12 f0       	push   $0xf012a7fc
f0116623:	68 d7 00 00 00       	push   $0xd7
f0116628:	68 0c a8 12 f0       	push   $0xf012a80c
f011662d:	e8 07 9d fe ff       	call   f0100339 <_panic>

f0116632 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0116632:	55                   	push   %ebp
f0116633:	89 e5                	mov    %esp,%ebp
f0116635:	57                   	push   %edi
f0116636:	53                   	push   %ebx
f0116637:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011663d:	83 ec 0c             	sub    $0xc,%esp
f0116640:	68 28 a8 12 f0       	push   $0xf012a828
f0116645:	e8 41 a9 fe ff       	call   f0100f8b <cprintf>
f011664a:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011664d:	83 ec 0c             	sub    $0xc,%esp
f0116650:	68 58 a8 12 f0       	push   $0xf012a858
f0116655:	e8 31 a9 fe ff       	call   f0100f8b <cprintf>
f011665a:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011665d:	83 ec 0c             	sub    $0xc,%esp
f0116660:	68 28 a8 12 f0       	push   $0xf012a828
f0116665:	e8 21 a9 fe ff       	call   f0100f8b <cprintf>
f011666a:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011666d:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0116671:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0116675:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f011667b:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0116681:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0116688:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f011668f:	e8 16 7c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116694:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0116697:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011669e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f01166a5:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f01166ab:	b9 14 00 00 00       	mov    $0x14,%ecx
f01166b0:	b8 00 00 00 00       	mov    $0x0,%eax
f01166b5:	89 d7                	mov    %edx,%edi
f01166b7:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f01166b9:	83 ec 0c             	sub    $0xc,%esp
f01166bc:	68 b1 a8 12 f0       	push   $0xf012a8b1
f01166c1:	e8 c5 a8 fe ff       	call   f0100f8b <cprintf>
f01166c6:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01166c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f01166d0:	e8 d5 7b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01166d5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01166d8:	e8 c8 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01166dd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f01166e0:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f01166e7:	83 ec 0c             	sub    $0xc,%esp
f01166ea:	ff 75 cc             	pushl  -0x34(%ebp)
f01166ed:	e8 f7 2a ff ff       	call   f01091e9 <kmalloc>
f01166f2:	83 c4 10             	add    $0x10,%esp
f01166f5:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f01166fb:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116701:	85 c0                	test   %eax,%eax
f0116703:	74 17                	je     f011671c <test_kmalloc+0xea>
f0116705:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011670c:	83 ec 0c             	sub    $0xc,%esp
f011670f:	68 d0 a8 12 f0       	push   $0xf012a8d0
f0116714:	e8 72 a8 fe ff       	call   f0100f8b <cprintf>
f0116719:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011671c:	e8 84 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116721:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116724:	74 17                	je     f011673d <test_kmalloc+0x10b>
f0116726:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011672d:	83 ec 0c             	sub    $0xc,%esp
f0116730:	68 04 a9 12 f0       	push   $0xf012a904
f0116735:	e8 51 a8 fe ff       	call   f0100f8b <cprintf>
f011673a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011673d:	e8 68 7b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116742:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0116745:	74 17                	je     f011675e <test_kmalloc+0x12c>
f0116747:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011674e:	83 ec 0c             	sub    $0xc,%esp
f0116751:	68 70 a9 12 f0       	push   $0xf012a970
f0116756:	e8 30 a8 fe ff       	call   f0100f8b <cprintf>
f011675b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011675e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116762:	74 04                	je     f0116768 <test_kmalloc+0x136>
f0116764:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0116768:	83 ec 0c             	sub    $0xc,%esp
f011676b:	68 b4 a9 12 f0       	push   $0xf012a9b4
f0116770:	e8 16 a8 fe ff       	call   f0100f8b <cprintf>
f0116775:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0116778:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011677f:	e8 26 7b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116784:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116787:	e8 19 e1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011678c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011678f:	83 ec 0c             	sub    $0xc,%esp
f0116792:	68 00 fc 1f 00       	push   $0x1ffc00
f0116797:	e8 4d 2a ff ff       	call   f01091e9 <kmalloc>
f011679c:	83 c4 10             	add    $0x10,%esp
f011679f:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01167a5:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01167ab:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01167b0:	74 17                	je     f01167c9 <test_kmalloc+0x197>
f01167b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01167b9:	83 ec 0c             	sub    $0xc,%esp
f01167bc:	68 f8 a9 12 f0       	push   $0xf012a9f8
f01167c1:	e8 c5 a7 fe ff       	call   f0100f8b <cprintf>
f01167c6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01167c9:	e8 d7 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01167ce:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01167d1:	74 17                	je     f01167ea <test_kmalloc+0x1b8>
f01167d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01167da:	83 ec 0c             	sub    $0xc,%esp
f01167dd:	68 4c aa 12 f0       	push   $0xf012aa4c
f01167e2:	e8 a4 a7 fe ff       	call   f0100f8b <cprintf>
f01167e7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01167ea:	e8 bb 7a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01167ef:	89 c2                	mov    %eax,%edx
f01167f1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01167f4:	29 d0                	sub    %edx,%eax
f01167f6:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01167fb:	7f 17                	jg     f0116814 <test_kmalloc+0x1e2>
f01167fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116804:	83 ec 0c             	sub    $0xc,%esp
f0116807:	68 b8 aa 12 f0       	push   $0xf012aab8
f011680c:	e8 7a a7 fe ff       	call   f0100f8b <cprintf>
f0116811:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116814:	e8 91 7a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116819:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011681c:	e8 84 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116821:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0116824:	83 ec 0c             	sub    $0xc,%esp
f0116827:	68 00 fc 1f 00       	push   $0x1ffc00
f011682c:	e8 b8 29 ff ff       	call   f01091e9 <kmalloc>
f0116831:	83 c4 10             	add    $0x10,%esp
f0116834:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011683a:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116840:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0116845:	74 17                	je     f011685e <test_kmalloc+0x22c>
f0116847:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011684e:	83 ec 0c             	sub    $0xc,%esp
f0116851:	68 fc aa 12 f0       	push   $0xf012aafc
f0116856:	e8 30 a7 fe ff       	call   f0100f8b <cprintf>
f011685b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011685e:	e8 42 e0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116863:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116866:	74 17                	je     f011687f <test_kmalloc+0x24d>
f0116868:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011686f:	83 ec 0c             	sub    $0xc,%esp
f0116872:	68 50 ab 12 f0       	push   $0xf012ab50
f0116877:	e8 0f a7 fe ff       	call   f0100f8b <cprintf>
f011687c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011687f:	e8 26 7a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116884:	89 c2                	mov    %eax,%edx
f0116886:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116889:	29 d0                	sub    %edx,%eax
f011688b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116890:	7f 17                	jg     f01168a9 <test_kmalloc+0x277>
f0116892:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116899:	83 ec 0c             	sub    $0xc,%esp
f011689c:	68 bc ab 12 f0       	push   $0xf012abbc
f01168a1:	e8 e5 a6 fe ff       	call   f0100f8b <cprintf>
f01168a6:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f01168a9:	e8 fc 79 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01168ae:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01168b1:	e8 ef df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01168b6:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f01168b9:	83 ec 0c             	sub    $0xc,%esp
f01168bc:	68 ff 07 00 00       	push   $0x7ff
f01168c1:	e8 23 29 ff ff       	call   f01091e9 <kmalloc>
f01168c6:	83 c4 10             	add    $0x10,%esp
f01168c9:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01168cf:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01168d5:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01168da:	76 28                	jbe    f0116904 <test_kmalloc+0x2d2>
f01168dc:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f01168e2:	83 ec 0c             	sub    $0xc,%esp
f01168e5:	6a 00                	push   $0x0
f01168e7:	e8 ca 27 ff ff       	call   f01090b6 <sbrk>
f01168ec:	83 c4 10             	add    $0x10,%esp
f01168ef:	39 c3                	cmp    %eax,%ebx
f01168f1:	73 11                	jae    f0116904 <test_kmalloc+0x2d2>
f01168f3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01168f9:	89 c2                	mov    %eax,%edx
f01168fb:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f0116900:	39 c2                	cmp    %eax,%edx
f0116902:	72 17                	jb     f011691b <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0116904:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011690b:	83 ec 0c             	sub    $0xc,%esp
f011690e:	68 00 ac 12 f0       	push   $0xf012ac00
f0116913:	e8 73 a6 fe ff       	call   f0100f8b <cprintf>
f0116918:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011691b:	e8 85 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116920:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116923:	74 17                	je     f011693c <test_kmalloc+0x30a>
f0116925:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011692c:	83 ec 0c             	sub    $0xc,%esp
f011692f:	68 8c ac 12 f0       	push   $0xf012ac8c
f0116934:	e8 52 a6 fe ff       	call   f0100f8b <cprintf>
f0116939:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011693c:	e8 64 df fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116941:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0116944:	83 ec 0c             	sub    $0xc,%esp
f0116947:	68 ff 07 00 00       	push   $0x7ff
f011694c:	e8 98 28 ff ff       	call   f01091e9 <kmalloc>
f0116951:	83 c4 10             	add    $0x10,%esp
f0116954:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011695a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116960:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0116965:	76 28                	jbe    f011698f <test_kmalloc+0x35d>
f0116967:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011696d:	83 ec 0c             	sub    $0xc,%esp
f0116970:	6a 00                	push   $0x0
f0116972:	e8 3f 27 ff ff       	call   f01090b6 <sbrk>
f0116977:	83 c4 10             	add    $0x10,%esp
f011697a:	39 c3                	cmp    %eax,%ebx
f011697c:	73 11                	jae    f011698f <test_kmalloc+0x35d>
f011697e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116984:	89 c2                	mov    %eax,%edx
f0116986:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011698b:	39 c2                	cmp    %eax,%edx
f011698d:	72 17                	jb     f01169a6 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011698f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116996:	83 ec 0c             	sub    $0xc,%esp
f0116999:	68 f8 ac 12 f0       	push   $0xf012acf8
f011699e:	e8 e8 a5 fe ff       	call   f0100f8b <cprintf>
f01169a3:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01169a6:	e8 fa de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01169ab:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01169ae:	74 17                	je     f01169c7 <test_kmalloc+0x395>
f01169b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169b7:	83 ec 0c             	sub    $0xc,%esp
f01169ba:	68 84 ad 12 f0       	push   $0xf012ad84
f01169bf:	e8 c7 a5 fe ff       	call   f0100f8b <cprintf>
f01169c4:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f01169c7:	e8 de 78 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01169cc:	89 c2                	mov    %eax,%edx
f01169ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01169d1:	29 d0                	sub    %edx,%eax
f01169d3:	83 f8 01             	cmp    $0x1,%eax
f01169d6:	74 17                	je     f01169ef <test_kmalloc+0x3bd>
f01169d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169df:	83 ec 0c             	sub    $0xc,%esp
f01169e2:	68 f0 ad 12 f0       	push   $0xf012adf0
f01169e7:	e8 9f a5 fe ff       	call   f0100f8b <cprintf>
f01169ec:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01169ef:	e8 b6 78 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01169f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01169f7:	e8 a9 de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01169fc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f01169ff:	83 ec 0c             	sub    $0xc,%esp
f0116a02:	68 00 1c 00 00       	push   $0x1c00
f0116a07:	e8 dd 27 ff ff       	call   f01091e9 <kmalloc>
f0116a0c:	83 c4 10             	add    $0x10,%esp
f0116a0f:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116a15:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0116a1b:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116a20:	74 17                	je     f0116a39 <test_kmalloc+0x407>
f0116a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a29:	83 ec 0c             	sub    $0xc,%esp
f0116a2c:	68 10 ae 12 f0       	push   $0xf012ae10
f0116a31:	e8 55 a5 fe ff       	call   f0100f8b <cprintf>
f0116a36:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116a39:	e8 67 de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116a3e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116a41:	74 17                	je     f0116a5a <test_kmalloc+0x428>
f0116a43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a4a:	83 ec 0c             	sub    $0xc,%esp
f0116a4d:	68 64 ae 12 f0       	push   $0xf012ae64
f0116a52:	e8 34 a5 fe ff       	call   f0100f8b <cprintf>
f0116a57:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116a5a:	e8 4b 78 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116a5f:	89 c2                	mov    %eax,%edx
f0116a61:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116a64:	29 d0                	sub    %edx,%eax
f0116a66:	83 f8 01             	cmp    $0x1,%eax
f0116a69:	7f 17                	jg     f0116a82 <test_kmalloc+0x450>
f0116a6b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a72:	83 ec 0c             	sub    $0xc,%esp
f0116a75:	68 d0 ae 12 f0       	push   $0xf012aed0
f0116a7a:	e8 0c a5 fe ff       	call   f0100f8b <cprintf>
f0116a7f:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116a82:	e8 23 78 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116a87:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116a8a:	e8 16 de fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116a8f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0116a92:	83 ec 0c             	sub    $0xc,%esp
f0116a95:	68 00 fc 2f 00       	push   $0x2ffc00
f0116a9a:	e8 4a 27 ff ff       	call   f01091e9 <kmalloc>
f0116a9f:	83 c4 10             	add    $0x10,%esp
f0116aa2:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116aa8:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0116aae:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0116ab3:	74 17                	je     f0116acc <test_kmalloc+0x49a>
f0116ab5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116abc:	83 ec 0c             	sub    $0xc,%esp
f0116abf:	68 14 af 12 f0       	push   $0xf012af14
f0116ac4:	e8 c2 a4 fe ff       	call   f0100f8b <cprintf>
f0116ac9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116acc:	e8 d4 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116ad1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116ad4:	74 17                	je     f0116aed <test_kmalloc+0x4bb>
f0116ad6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116add:	83 ec 0c             	sub    $0xc,%esp
f0116ae0:	68 68 af 12 f0       	push   $0xf012af68
f0116ae5:	e8 a1 a4 fe ff       	call   f0100f8b <cprintf>
f0116aea:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116aed:	e8 b8 77 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116af2:	89 c2                	mov    %eax,%edx
f0116af4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116af7:	29 d0                	sub    %edx,%eax
f0116af9:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116afe:	7f 17                	jg     f0116b17 <test_kmalloc+0x4e5>
f0116b00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b07:	83 ec 0c             	sub    $0xc,%esp
f0116b0a:	68 d4 af 12 f0       	push   $0xf012afd4
f0116b0f:	e8 77 a4 fe ff       	call   f0100f8b <cprintf>
f0116b14:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116b17:	e8 8e 77 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116b1c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116b1f:	e8 81 dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116b24:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0116b27:	83 ec 0c             	sub    $0xc,%esp
f0116b2a:	68 00 fc 5f 00       	push   $0x5ffc00
f0116b2f:	e8 b5 26 ff ff       	call   f01091e9 <kmalloc>
f0116b34:	83 c4 10             	add    $0x10,%esp
f0116b37:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116b3d:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116b43:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0116b48:	74 17                	je     f0116b61 <test_kmalloc+0x52f>
f0116b4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b51:	83 ec 0c             	sub    $0xc,%esp
f0116b54:	68 18 b0 12 f0       	push   $0xf012b018
f0116b59:	e8 2d a4 fe ff       	call   f0100f8b <cprintf>
f0116b5e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116b61:	e8 3f dd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116b66:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116b69:	74 17                	je     f0116b82 <test_kmalloc+0x550>
f0116b6b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b72:	83 ec 0c             	sub    $0xc,%esp
f0116b75:	68 6c b0 12 f0       	push   $0xf012b06c
f0116b7a:	e8 0c a4 fe ff       	call   f0100f8b <cprintf>
f0116b7f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116b82:	e8 23 77 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116b87:	89 c2                	mov    %eax,%edx
f0116b89:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116b8c:	29 d0                	sub    %edx,%eax
f0116b8e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0116b93:	7f 17                	jg     f0116bac <test_kmalloc+0x57a>
f0116b95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b9c:	83 ec 0c             	sub    $0xc,%esp
f0116b9f:	68 d8 b0 12 f0       	push   $0xf012b0d8
f0116ba4:	e8 e2 a3 fe ff       	call   f0100f8b <cprintf>
f0116ba9:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116bac:	e8 f9 76 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116bb1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116bb4:	e8 ec dc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116bb9:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0116bbc:	83 ec 0c             	sub    $0xc,%esp
f0116bbf:	68 00 38 00 00       	push   $0x3800
f0116bc4:	e8 20 26 ff ff       	call   f01091e9 <kmalloc>
f0116bc9:	83 c4 10             	add    $0x10,%esp
f0116bcc:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116bd2:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116bd8:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0116bdd:	74 17                	je     f0116bf6 <test_kmalloc+0x5c4>
f0116bdf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116be6:	83 ec 0c             	sub    $0xc,%esp
f0116be9:	68 1c b1 12 f0       	push   $0xf012b11c
f0116bee:	e8 98 a3 fe ff       	call   f0100f8b <cprintf>
f0116bf3:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116bf6:	e8 aa dc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116bfb:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116bfe:	74 17                	je     f0116c17 <test_kmalloc+0x5e5>
f0116c00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c07:	83 ec 0c             	sub    $0xc,%esp
f0116c0a:	68 70 b1 12 f0       	push   $0xf012b170
f0116c0f:	e8 77 a3 fe ff       	call   f0100f8b <cprintf>
f0116c14:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116c17:	e8 8e 76 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116c1c:	89 c2                	mov    %eax,%edx
f0116c1e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116c21:	29 d0                	sub    %edx,%eax
f0116c23:	83 f8 03             	cmp    $0x3,%eax
f0116c26:	7f 17                	jg     f0116c3f <test_kmalloc+0x60d>
f0116c28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c2f:	83 ec 0c             	sub    $0xc,%esp
f0116c32:	68 dc b1 12 f0       	push   $0xf012b1dc
f0116c37:	e8 4f a3 fe ff       	call   f0100f8b <cprintf>
f0116c3c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0116c3f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116c43:	74 04                	je     f0116c49 <test_kmalloc+0x617>
f0116c45:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0116c49:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0116c50:	83 ec 0c             	sub    $0xc,%esp
f0116c53:	68 20 b2 12 f0       	push   $0xf012b220
f0116c58:	e8 2e a3 fe ff       	call   f0100f8b <cprintf>
f0116c5d:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0116c60:	e8 45 76 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116c65:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116c68:	e8 38 dc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0116c6d:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0116c70:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0116c77:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116c7d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0116c80:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116c83:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116c86:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0116c88:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116c8b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116c8e:	01 c2                	add    %eax,%edx
f0116c90:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116c93:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0116c95:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116c9b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0116c9e:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0116ca5:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116ca8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116cab:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0116cae:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116cb1:	01 c0                	add    %eax,%eax
f0116cb3:	89 c2                	mov    %eax,%edx
f0116cb5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116cb8:	01 c2                	add    %eax,%edx
f0116cba:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116cbe:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0116cc1:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116cc7:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0116cca:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0116cd1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116cd4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116cd7:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0116cd9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116cdc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116ce3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116ce6:	01 c2                	add    %eax,%edx
f0116ce8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116ceb:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0116ced:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0116cf3:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0116cf6:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0116cfd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116d00:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116d03:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0116d05:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116d08:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116d0b:	01 c2                	add    %eax,%edx
f0116d0d:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116d10:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0116d12:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0116d18:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0116d1b:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0116d22:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d25:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116d28:	88 10                	mov    %dl,(%eax)
f0116d2a:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0116d2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116d30:	66 89 42 02          	mov    %ax,0x2(%edx)
f0116d34:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d37:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116d3a:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0116d3d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116d40:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116d47:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d4a:	01 c2                	add    %eax,%edx
f0116d4c:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116d4f:	88 02                	mov    %al,(%edx)
f0116d51:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116d54:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116d5b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d5e:	01 c2                	add    %eax,%edx
f0116d60:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116d64:	66 89 42 02          	mov    %ax,0x2(%edx)
f0116d68:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116d6b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116d72:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116d75:	01 c2                	add    %eax,%edx
f0116d77:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116d7a:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0116d7d:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0116d84:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116d8a:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0116d8d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116d90:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116d93:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0116d95:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116d98:	89 c2                	mov    %eax,%edx
f0116d9a:	c1 ea 1f             	shr    $0x1f,%edx
f0116d9d:	01 d0                	add    %edx,%eax
f0116d9f:	d1 f8                	sar    %eax
f0116da1:	89 c2                	mov    %eax,%edx
f0116da3:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116da6:	01 c2                	add    %eax,%edx
f0116da8:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116dab:	88 c1                	mov    %al,%cl
f0116dad:	c0 e9 07             	shr    $0x7,%cl
f0116db0:	01 c8                	add    %ecx,%eax
f0116db2:	d0 f8                	sar    %al
f0116db4:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0116db6:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116db9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116dbc:	01 c2                	add    %eax,%edx
f0116dbe:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116dc1:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f0116dc3:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116dc9:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0116dcc:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f0116dd3:	8b 55 98             	mov    -0x68(%ebp),%edx
f0116dd6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116dd9:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0116ddc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116ddf:	01 c0                	add    %eax,%eax
f0116de1:	89 c2                	mov    %eax,%edx
f0116de3:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116de6:	01 c2                	add    %eax,%edx
f0116de8:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116dec:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0116def:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116df2:	8a 00                	mov    (%eax),%al
f0116df4:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116df7:	75 0f                	jne    f0116e08 <test_kmalloc+0x7d6>
f0116df9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116dfc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116dff:	01 d0                	add    %edx,%eax
f0116e01:	8a 00                	mov    (%eax),%al
f0116e03:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116e06:	74 17                	je     f0116e1f <test_kmalloc+0x7ed>
f0116e08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e0f:	83 ec 0c             	sub    $0xc,%esp
f0116e12:	68 58 b2 12 f0       	push   $0xf012b258
f0116e17:	e8 6f a1 fe ff       	call   f0100f8b <cprintf>
f0116e1c:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0116e1f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116e22:	66 8b 00             	mov    (%eax),%ax
f0116e25:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116e29:	75 15                	jne    f0116e40 <test_kmalloc+0x80e>
f0116e2b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116e2e:	01 c0                	add    %eax,%eax
f0116e30:	89 c2                	mov    %eax,%edx
f0116e32:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116e35:	01 d0                	add    %edx,%eax
f0116e37:	66 8b 00             	mov    (%eax),%ax
f0116e3a:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116e3e:	74 17                	je     f0116e57 <test_kmalloc+0x825>
f0116e40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e47:	83 ec 0c             	sub    $0xc,%esp
f0116e4a:	68 90 b2 12 f0       	push   $0xf012b290
f0116e4f:	e8 37 a1 fe ff       	call   f0100f8b <cprintf>
f0116e54:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f0116e57:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116e5a:	8b 00                	mov    (%eax),%eax
f0116e5c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0116e5f:	75 16                	jne    f0116e77 <test_kmalloc+0x845>
f0116e61:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116e64:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e6b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116e6e:	01 d0                	add    %edx,%eax
f0116e70:	8b 00                	mov    (%eax),%eax
f0116e72:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0116e75:	74 17                	je     f0116e8e <test_kmalloc+0x85c>
f0116e77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e7e:	83 ec 0c             	sub    $0xc,%esp
f0116e81:	68 cc b2 12 f0       	push   $0xf012b2cc
f0116e86:	e8 00 a1 fe ff       	call   f0100f8b <cprintf>
f0116e8b:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f0116e8e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116e91:	8a 00                	mov    (%eax),%al
f0116e93:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116e96:	75 0f                	jne    f0116ea7 <test_kmalloc+0x875>
f0116e98:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116e9b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116e9e:	01 d0                	add    %edx,%eax
f0116ea0:	8a 00                	mov    (%eax),%al
f0116ea2:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116ea5:	74 17                	je     f0116ebe <test_kmalloc+0x88c>
f0116ea7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116eae:	83 ec 0c             	sub    $0xc,%esp
f0116eb1:	68 08 b3 12 f0       	push   $0xf012b308
f0116eb6:	e8 d0 a0 fe ff       	call   f0100f8b <cprintf>
f0116ebb:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f0116ebe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116ec1:	8a 00                	mov    (%eax),%al
f0116ec3:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116ec6:	75 16                	jne    f0116ede <test_kmalloc+0x8ac>
f0116ec8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116ecb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116ed2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116ed5:	01 d0                	add    %edx,%eax
f0116ed7:	8a 00                	mov    (%eax),%al
f0116ed9:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116edc:	74 17                	je     f0116ef5 <test_kmalloc+0x8c3>
f0116ede:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ee5:	83 ec 0c             	sub    $0xc,%esp
f0116ee8:	68 44 b3 12 f0       	push   $0xf012b344
f0116eed:	e8 99 a0 fe ff       	call   f0100f8b <cprintf>
f0116ef2:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f0116ef5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116ef8:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116efc:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116f00:	75 19                	jne    f0116f1b <test_kmalloc+0x8e9>
f0116f02:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116f05:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116f0c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f0f:	01 d0                	add    %edx,%eax
f0116f11:	66 8b 40 02          	mov    0x2(%eax),%ax
f0116f15:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116f19:	74 17                	je     f0116f32 <test_kmalloc+0x900>
f0116f1b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f22:	83 ec 0c             	sub    $0xc,%esp
f0116f25:	68 80 b3 12 f0       	push   $0xf012b380
f0116f2a:	e8 5c a0 fe ff       	call   f0100f8b <cprintf>
f0116f2f:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f0116f32:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f35:	8b 40 04             	mov    0x4(%eax),%eax
f0116f38:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0116f3b:	75 17                	jne    f0116f54 <test_kmalloc+0x922>
f0116f3d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116f40:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116f47:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116f4a:	01 d0                	add    %edx,%eax
f0116f4c:	8b 40 04             	mov    0x4(%eax),%eax
f0116f4f:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0116f52:	74 17                	je     f0116f6b <test_kmalloc+0x939>
f0116f54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f5b:	83 ec 0c             	sub    $0xc,%esp
f0116f5e:	68 bc b3 12 f0       	push   $0xf012b3bc
f0116f63:	e8 23 a0 fe ff       	call   f0100f8b <cprintf>
f0116f68:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0116f6b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116f6e:	8a 00                	mov    (%eax),%al
f0116f70:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116f73:	75 34                	jne    f0116fa9 <test_kmalloc+0x977>
f0116f75:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116f78:	89 c2                	mov    %eax,%edx
f0116f7a:	c1 ea 1f             	shr    $0x1f,%edx
f0116f7d:	01 d0                	add    %edx,%eax
f0116f7f:	d1 f8                	sar    %eax
f0116f81:	89 c2                	mov    %eax,%edx
f0116f83:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116f86:	01 d0                	add    %edx,%eax
f0116f88:	8a 10                	mov    (%eax),%dl
f0116f8a:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116f8d:	88 c1                	mov    %al,%cl
f0116f8f:	c0 e9 07             	shr    $0x7,%cl
f0116f92:	01 c8                	add    %ecx,%eax
f0116f94:	d0 f8                	sar    %al
f0116f96:	38 c2                	cmp    %al,%dl
f0116f98:	75 0f                	jne    f0116fa9 <test_kmalloc+0x977>
f0116f9a:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116f9d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116fa0:	01 d0                	add    %edx,%eax
f0116fa2:	8a 00                	mov    (%eax),%al
f0116fa4:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116fa7:	74 17                	je     f0116fc0 <test_kmalloc+0x98e>
f0116fa9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fb0:	83 ec 0c             	sub    $0xc,%esp
f0116fb3:	68 f8 b3 12 f0       	push   $0xf012b3f8
f0116fb8:	e8 ce 9f fe ff       	call   f0100f8b <cprintf>
f0116fbd:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f0116fc0:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116fc3:	66 8b 00             	mov    (%eax),%ax
f0116fc6:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116fca:	75 15                	jne    f0116fe1 <test_kmalloc+0x9af>
f0116fcc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0116fcf:	01 c0                	add    %eax,%eax
f0116fd1:	89 c2                	mov    %eax,%edx
f0116fd3:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116fd6:	01 d0                	add    %edx,%eax
f0116fd8:	66 8b 00             	mov    (%eax),%ax
f0116fdb:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0116fdf:	74 17                	je     f0116ff8 <test_kmalloc+0x9c6>
f0116fe1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fe8:	83 ec 0c             	sub    $0xc,%esp
f0116feb:	68 30 b4 12 f0       	push   $0xf012b430
f0116ff0:	e8 96 9f fe ff       	call   f0100f8b <cprintf>
f0116ff5:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116ff8:	e8 ad 72 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0116ffd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117000:	74 17                	je     f0117019 <test_kmalloc+0x9e7>
f0117002:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117009:	83 ec 0c             	sub    $0xc,%esp
f011700c:	68 6c b4 12 f0       	push   $0xf012b46c
f0117011:	e8 75 9f fe ff       	call   f0100f8b <cprintf>
f0117016:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117019:	e8 87 d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011701e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117021:	74 17                	je     f011703a <test_kmalloc+0xa08>
f0117023:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011702a:	83 ec 0c             	sub    $0xc,%esp
f011702d:	68 b0 b4 12 f0       	push   $0xf012b4b0
f0117032:	e8 54 9f fe ff       	call   f0100f8b <cprintf>
f0117037:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f011703a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011703e:	74 04                	je     f0117044 <test_kmalloc+0xa12>
f0117040:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0117044:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f011704b:	83 ec 0c             	sub    $0xc,%esp
f011704e:	68 1c b5 12 f0       	push   $0xf012b51c
f0117053:	e8 33 9f fe ff       	call   f0100f8b <cprintf>
f0117058:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011705b:	e8 4a 72 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117060:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117063:	e8 3d d8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117068:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo);
f011706b:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0117072:	8b 45 90             	mov    -0x70(%ebp),%eax
f0117075:	40                   	inc    %eax
f0117076:	83 ec 0c             	sub    $0xc,%esp
f0117079:	50                   	push   %eax
f011707a:	e8 6a 21 ff ff       	call   f01091e9 <kmalloc>
f011707f:	83 c4 10             	add    $0x10,%esp
f0117082:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0117088:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011708e:	85 c0                	test   %eax,%eax
f0117090:	74 17                	je     f01170a9 <test_kmalloc+0xa77>
f0117092:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117099:	83 ec 0c             	sub    $0xc,%esp
f011709c:	68 40 b5 12 f0       	push   $0xf012b540
f01170a1:	e8 e5 9e fe ff       	call   f0100f8b <cprintf>
f01170a6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170a9:	e8 f7 d7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01170ae:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01170b1:	74 17                	je     f01170ca <test_kmalloc+0xa98>
f01170b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170ba:	83 ec 0c             	sub    $0xc,%esp
f01170bd:	68 78 b5 12 f0       	push   $0xf012b578
f01170c2:	e8 c4 9e fe ff       	call   f0100f8b <cprintf>
f01170c7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01170ca:	e8 db 71 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01170cf:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01170d2:	74 17                	je     f01170eb <test_kmalloc+0xab9>
f01170d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170db:	83 ec 0c             	sub    $0xc,%esp
f01170de:	68 e4 b5 12 f0       	push   $0xf012b5e4
f01170e3:	e8 a3 9e fe ff       	call   f0100f8b <cprintf>
f01170e8:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01170eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01170ef:	74 04                	je     f01170f5 <test_kmalloc+0xac3>
f01170f1:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01170f5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f01170fc:	83 ec 0c             	sub    $0xc,%esp
f01170ff:	68 28 b6 12 f0       	push   $0xf012b628
f0117104:	e8 82 9e fe ff       	call   f0100f8b <cprintf>
f0117109:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f011710c:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117112:	05 00 40 00 00       	add    $0x4000,%eax
f0117117:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f011711a:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0117121:	eb 6a                	jmp    f011718d <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0117123:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f0117128:	83 ec 04             	sub    $0x4,%esp
f011712b:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0117131:	52                   	push   %edx
f0117132:	ff 75 ec             	pushl  -0x14(%ebp)
f0117135:	50                   	push   %eax
f0117136:	e8 b4 12 ff ff       	call   f01083ef <get_page_table>
f011713b:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f011713e:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0117144:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0117147:	c1 ea 0c             	shr    $0xc,%edx
f011714a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117150:	c1 e2 02             	shl    $0x2,%edx
f0117153:	01 d0                	add    %edx,%eax
f0117155:	8b 00                	mov    (%eax),%eax
f0117157:	25 ff 0f 00 00       	and    $0xfff,%eax
f011715c:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011715f:	8b 45 88             	mov    -0x78(%ebp),%eax
f0117162:	83 e0 04             	and    $0x4,%eax
f0117165:	85 c0                	test   %eax,%eax
f0117167:	74 1d                	je     f0117186 <test_kmalloc+0xb54>
			{
				if (correct)
f0117169:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011716d:	74 17                	je     f0117186 <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011716f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117176:	83 ec 0c             	sub    $0xc,%esp
f0117179:	68 6c b6 12 f0       	push   $0xf012b66c
f011717e:	e8 08 9e fe ff       	call   f0100f8b <cprintf>
f0117183:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0117186:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f011718d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117190:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0117193:	72 8e                	jb     f0117123 <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0117195:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117199:	74 04                	je     f011719f <test_kmalloc+0xb6d>
f011719b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f011719f:	83 ec 08             	sub    $0x8,%esp
f01171a2:	ff 75 f4             	pushl  -0xc(%ebp)
f01171a5:	68 bc b6 12 f0       	push   $0xf012b6bc
f01171aa:	e8 dc 9d fe ff       	call   f0100f8b <cprintf>
f01171af:	83 c4 10             	add    $0x10,%esp

	return 1;
f01171b2:	b8 01 00 00 00       	mov    $0x1,%eax

}
f01171b7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01171ba:	5b                   	pop    %ebx
f01171bb:	5f                   	pop    %edi
f01171bc:	5d                   	pop    %ebp
f01171bd:	c3                   	ret    

f01171be <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f01171be:	55                   	push   %ebp
f01171bf:	89 e5                	mov    %esp,%ebp
f01171c1:	57                   	push   %edi
f01171c2:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01171c5:	83 ec 0c             	sub    $0xc,%esp
f01171c8:	68 28 a8 12 f0       	push   $0xf012a828
f01171cd:	e8 b9 9d fe ff       	call   f0100f8b <cprintf>
f01171d2:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01171d5:	83 ec 0c             	sub    $0xc,%esp
f01171d8:	68 58 a8 12 f0       	push   $0xf012a858
f01171dd:	e8 a9 9d fe ff       	call   f0100f8b <cprintf>
f01171e2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01171e5:	83 ec 0c             	sub    $0xc,%esp
f01171e8:	68 28 a8 12 f0       	push   $0xf012a828
f01171ed:	e8 99 9d fe ff       	call   f0100f8b <cprintf>
f01171f2:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01171f5:	8d 55 98             	lea    -0x68(%ebp),%edx
f01171f8:	b9 14 00 00 00       	mov    $0x14,%ecx
f01171fd:	b8 00 00 00 00       	mov    $0x0,%eax
f0117202:	89 d7                	mov    %edx,%edi
f0117204:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117206:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011720d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117214:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f011721b:	83 ec 0c             	sub    $0xc,%esp
f011721e:	68 e8 b6 12 f0       	push   $0xf012b6e8
f0117223:	e8 63 9d fe ff       	call   f0100f8b <cprintf>
f0117228:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011722b:	e8 7a 70 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117230:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117233:	e8 6d d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117238:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f011723b:	83 ec 0c             	sub    $0xc,%esp
f011723e:	68 00 fc 0f 00       	push   $0xffc00
f0117243:	e8 a1 1f ff ff       	call   f01091e9 <kmalloc>
f0117248:	83 c4 10             	add    $0x10,%esp
f011724b:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f011724e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117251:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117256:	74 17                	je     f011726f <test_kmalloc_firstfit1+0xb1>
f0117258:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011725f:	83 ec 0c             	sub    $0xc,%esp
f0117262:	68 28 b7 12 f0       	push   $0xf012b728
f0117267:	e8 1f 9d fe ff       	call   f0100f8b <cprintf>
f011726c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011726f:	e8 31 d6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117274:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117277:	74 17                	je     f0117290 <test_kmalloc_firstfit1+0xd2>
f0117279:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117280:	83 ec 0c             	sub    $0xc,%esp
f0117283:	68 4c aa 12 f0       	push   $0xf012aa4c
f0117288:	e8 fe 9c fe ff       	call   f0100f8b <cprintf>
f011728d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f0117290:	e8 15 70 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117295:	89 c2                	mov    %eax,%edx
f0117297:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011729a:	29 d0                	sub    %edx,%eax
f011729c:	3d ff 00 00 00       	cmp    $0xff,%eax
f01172a1:	7f 17                	jg     f01172ba <test_kmalloc_firstfit1+0xfc>
f01172a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172aa:	83 ec 0c             	sub    $0xc,%esp
f01172ad:	68 5b b7 12 f0       	push   $0xf012b75b
f01172b2:	e8 d4 9c fe ff       	call   f0100f8b <cprintf>
f01172b7:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01172ba:	e8 eb 6f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01172bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01172c2:	e8 de d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01172c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f01172ca:	83 ec 0c             	sub    $0xc,%esp
f01172cd:	68 00 fc 0f 00       	push   $0xffc00
f01172d2:	e8 12 1f ff ff       	call   f01091e9 <kmalloc>
f01172d7:	83 c4 10             	add    $0x10,%esp
f01172da:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f01172dd:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01172e0:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01172e5:	74 17                	je     f01172fe <test_kmalloc_firstfit1+0x140>
f01172e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172ee:	83 ec 0c             	sub    $0xc,%esp
f01172f1:	68 74 b7 12 f0       	push   $0xf012b774
f01172f6:	e8 90 9c fe ff       	call   f0100f8b <cprintf>
f01172fb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01172fe:	e8 a2 d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117303:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117306:	74 17                	je     f011731f <test_kmalloc_firstfit1+0x161>
f0117308:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011730f:	83 ec 0c             	sub    $0xc,%esp
f0117312:	68 50 ab 12 f0       	push   $0xf012ab50
f0117317:	e8 6f 9c fe ff       	call   f0100f8b <cprintf>
f011731c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f011731f:	e8 86 6f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117324:	89 c2                	mov    %eax,%edx
f0117326:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117329:	29 d0                	sub    %edx,%eax
f011732b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117330:	7f 17                	jg     f0117349 <test_kmalloc_firstfit1+0x18b>
f0117332:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117339:	83 ec 0c             	sub    $0xc,%esp
f011733c:	68 a7 b7 12 f0       	push   $0xf012b7a7
f0117341:	e8 45 9c fe ff       	call   f0100f8b <cprintf>
f0117346:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117349:	e8 5c 6f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011734e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117351:	e8 4f d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117356:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0117359:	83 ec 0c             	sub    $0xc,%esp
f011735c:	68 00 fc 0f 00       	push   $0xffc00
f0117361:	e8 83 1e ff ff       	call   f01091e9 <kmalloc>
f0117366:	83 c4 10             	add    $0x10,%esp
f0117369:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f011736c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011736f:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117374:	74 17                	je     f011738d <test_kmalloc_firstfit1+0x1cf>
f0117376:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011737d:	83 ec 0c             	sub    $0xc,%esp
f0117380:	68 c0 b7 12 f0       	push   $0xf012b7c0
f0117385:	e8 01 9c fe ff       	call   f0100f8b <cprintf>
f011738a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011738d:	e8 13 d5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117392:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117395:	74 17                	je     f01173ae <test_kmalloc_firstfit1+0x1f0>
f0117397:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011739e:	83 ec 0c             	sub    $0xc,%esp
f01173a1:	68 8c ac 12 f0       	push   $0xf012ac8c
f01173a6:	e8 e0 9b fe ff       	call   f0100f8b <cprintf>
f01173ab:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f01173ae:	e8 f7 6e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01173b3:	89 c2                	mov    %eax,%edx
f01173b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01173b8:	29 d0                	sub    %edx,%eax
f01173ba:	3d ff 00 00 00       	cmp    $0xff,%eax
f01173bf:	7f 17                	jg     f01173d8 <test_kmalloc_firstfit1+0x21a>
f01173c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173c8:	83 ec 0c             	sub    $0xc,%esp
f01173cb:	68 f3 b7 12 f0       	push   $0xf012b7f3
f01173d0:	e8 b6 9b fe ff       	call   f0100f8b <cprintf>
f01173d5:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01173d8:	e8 cd 6e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01173dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01173e0:	e8 c0 d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01173e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f01173e8:	83 ec 0c             	sub    $0xc,%esp
f01173eb:	68 00 fc 0f 00       	push   $0xffc00
f01173f0:	e8 f4 1d ff ff       	call   f01091e9 <kmalloc>
f01173f5:	83 c4 10             	add    $0x10,%esp
f01173f8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01173fb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01173fe:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0117403:	74 17                	je     f011741c <test_kmalloc_firstfit1+0x25e>
f0117405:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011740c:	83 ec 0c             	sub    $0xc,%esp
f011740f:	68 0c b8 12 f0       	push   $0xf012b80c
f0117414:	e8 72 9b fe ff       	call   f0100f8b <cprintf>
f0117419:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011741c:	e8 84 d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117421:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117424:	74 17                	je     f011743d <test_kmalloc_firstfit1+0x27f>
f0117426:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011742d:	83 ec 0c             	sub    $0xc,%esp
f0117430:	68 84 ad 12 f0       	push   $0xf012ad84
f0117435:	e8 51 9b fe ff       	call   f0100f8b <cprintf>
f011743a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f011743d:	e8 68 6e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117442:	89 c2                	mov    %eax,%edx
f0117444:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117447:	29 d0                	sub    %edx,%eax
f0117449:	3d ff 00 00 00       	cmp    $0xff,%eax
f011744e:	7f 17                	jg     f0117467 <test_kmalloc_firstfit1+0x2a9>
f0117450:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117457:	83 ec 0c             	sub    $0xc,%esp
f011745a:	68 3f b8 12 f0       	push   $0xf012b83f
f011745f:	e8 27 9b fe ff       	call   f0100f8b <cprintf>
f0117464:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117467:	e8 3e 6e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011746c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011746f:	e8 31 d4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117474:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0117477:	83 ec 0c             	sub    $0xc,%esp
f011747a:	68 00 fc 1f 00       	push   $0x1ffc00
f011747f:	e8 65 1d ff ff       	call   f01091e9 <kmalloc>
f0117484:	83 c4 10             	add    $0x10,%esp
f0117487:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f011748a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011748d:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117492:	74 17                	je     f01174ab <test_kmalloc_firstfit1+0x2ed>
f0117494:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011749b:	83 ec 0c             	sub    $0xc,%esp
f011749e:	68 58 b8 12 f0       	push   $0xf012b858
f01174a3:	e8 e3 9a fe ff       	call   f0100f8b <cprintf>
f01174a8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01174ab:	e8 f5 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01174b0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01174b3:	74 17                	je     f01174cc <test_kmalloc_firstfit1+0x30e>
f01174b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174bc:	83 ec 0c             	sub    $0xc,%esp
f01174bf:	68 64 ae 12 f0       	push   $0xf012ae64
f01174c4:	e8 c2 9a fe ff       	call   f0100f8b <cprintf>
f01174c9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f01174cc:	e8 d9 6d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01174d1:	89 c2                	mov    %eax,%edx
f01174d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01174d6:	29 d0                	sub    %edx,%eax
f01174d8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01174dd:	7f 17                	jg     f01174f6 <test_kmalloc_firstfit1+0x338>
f01174df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174e6:	83 ec 0c             	sub    $0xc,%esp
f01174e9:	68 8b b8 12 f0       	push   $0xf012b88b
f01174ee:	e8 98 9a fe ff       	call   f0100f8b <cprintf>
f01174f3:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01174f6:	e8 af 6d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01174fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01174fe:	e8 a2 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117503:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0117506:	83 ec 0c             	sub    $0xc,%esp
f0117509:	68 00 fc 1f 00       	push   $0x1ffc00
f011750e:	e8 d6 1c ff ff       	call   f01091e9 <kmalloc>
f0117513:	83 c4 10             	add    $0x10,%esp
f0117516:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117519:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011751c:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0117521:	74 17                	je     f011753a <test_kmalloc_firstfit1+0x37c>
f0117523:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011752a:	83 ec 0c             	sub    $0xc,%esp
f011752d:	68 a4 b8 12 f0       	push   $0xf012b8a4
f0117532:	e8 54 9a fe ff       	call   f0100f8b <cprintf>
f0117537:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011753a:	e8 66 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011753f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117542:	74 17                	je     f011755b <test_kmalloc_firstfit1+0x39d>
f0117544:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011754b:	83 ec 0c             	sub    $0xc,%esp
f011754e:	68 68 af 12 f0       	push   $0xf012af68
f0117553:	e8 33 9a fe ff       	call   f0100f8b <cprintf>
f0117558:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f011755b:	e8 4a 6d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117560:	89 c2                	mov    %eax,%edx
f0117562:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117565:	29 d0                	sub    %edx,%eax
f0117567:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011756c:	7f 17                	jg     f0117585 <test_kmalloc_firstfit1+0x3c7>
f011756e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117575:	83 ec 0c             	sub    $0xc,%esp
f0117578:	68 d7 b8 12 f0       	push   $0xf012b8d7
f011757d:	e8 09 9a fe ff       	call   f0100f8b <cprintf>
f0117582:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117585:	e8 20 6d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011758a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011758d:	e8 13 d3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117592:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117595:	83 ec 0c             	sub    $0xc,%esp
f0117598:	68 00 fc 2f 00       	push   $0x2ffc00
f011759d:	e8 47 1c ff ff       	call   f01091e9 <kmalloc>
f01175a2:	83 c4 10             	add    $0x10,%esp
f01175a5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01175a8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01175ab:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01175b0:	74 17                	je     f01175c9 <test_kmalloc_firstfit1+0x40b>
f01175b2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175b9:	83 ec 0c             	sub    $0xc,%esp
f01175bc:	68 f0 b8 12 f0       	push   $0xf012b8f0
f01175c1:	e8 c5 99 fe ff       	call   f0100f8b <cprintf>
f01175c6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01175c9:	e8 d7 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01175ce:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01175d1:	74 17                	je     f01175ea <test_kmalloc_firstfit1+0x42c>
f01175d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175da:	83 ec 0c             	sub    $0xc,%esp
f01175dd:	68 6c b0 12 f0       	push   $0xf012b06c
f01175e2:	e8 a4 99 fe ff       	call   f0100f8b <cprintf>
f01175e7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f01175ea:	e8 bb 6c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01175ef:	89 c2                	mov    %eax,%edx
f01175f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01175f4:	29 d0                	sub    %edx,%eax
f01175f6:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01175fb:	7f 17                	jg     f0117614 <test_kmalloc_firstfit1+0x456>
f01175fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117604:	83 ec 0c             	sub    $0xc,%esp
f0117607:	68 23 b9 12 f0       	push   $0xf012b923
f011760c:	e8 7a 99 fe ff       	call   f0100f8b <cprintf>
f0117611:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117614:	e8 91 6c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117619:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011761c:	e8 84 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117621:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0117624:	83 ec 0c             	sub    $0xc,%esp
f0117627:	68 00 fc 2f 00       	push   $0x2ffc00
f011762c:	e8 b8 1b ff ff       	call   f01091e9 <kmalloc>
f0117631:	83 c4 10             	add    $0x10,%esp
f0117634:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0117637:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011763a:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f011763f:	74 17                	je     f0117658 <test_kmalloc_firstfit1+0x49a>
f0117641:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117648:	83 ec 0c             	sub    $0xc,%esp
f011764b:	68 3c b9 12 f0       	push   $0xf012b93c
f0117650:	e8 36 99 fe ff       	call   f0100f8b <cprintf>
f0117655:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117658:	e8 48 d2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011765d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117660:	74 17                	je     f0117679 <test_kmalloc_firstfit1+0x4bb>
f0117662:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117669:	83 ec 0c             	sub    $0xc,%esp
f011766c:	68 70 b1 12 f0       	push   $0xf012b170
f0117671:	e8 15 99 fe ff       	call   f0100f8b <cprintf>
f0117676:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0117679:	e8 2c 6c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011767e:	89 c2                	mov    %eax,%edx
f0117680:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117683:	29 d0                	sub    %edx,%eax
f0117685:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011768a:	7f 17                	jg     f01176a3 <test_kmalloc_firstfit1+0x4e5>
f011768c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117693:	83 ec 0c             	sub    $0xc,%esp
f0117696:	68 6f b9 12 f0       	push   $0xf012b96f
f011769b:	e8 eb 98 fe ff       	call   f0100f8b <cprintf>
f01176a0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01176a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01176a7:	74 04                	je     f01176ad <test_kmalloc_firstfit1+0x4ef>
f01176a9:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01176ad:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f01176b4:	83 ec 0c             	sub    $0xc,%esp
f01176b7:	68 88 b9 12 f0       	push   $0xf012b988
f01176bc:	e8 ca 98 fe ff       	call   f0100f8b <cprintf>
f01176c1:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01176c4:	e8 e1 6b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01176c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01176cc:	e8 d4 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01176d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f01176d4:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01176d7:	83 ec 0c             	sub    $0xc,%esp
f01176da:	50                   	push   %eax
f01176db:	e8 69 1d ff ff       	call   f0109449 <kfree>
f01176e0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01176e3:	e8 bd d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01176e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01176eb:	74 17                	je     f0117704 <test_kmalloc_firstfit1+0x546>
f01176ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176f4:	83 ec 0c             	sub    $0xc,%esp
f01176f7:	68 b0 b9 12 f0       	push   $0xf012b9b0
f01176fc:	e8 8a 98 fe ff       	call   f0100f8b <cprintf>
f0117701:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0117704:	e8 a1 6b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117709:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011770c:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117711:	7f 17                	jg     f011772a <test_kmalloc_firstfit1+0x56c>
f0117713:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011771a:	83 ec 0c             	sub    $0xc,%esp
f011771d:	68 1b ba 12 f0       	push   $0xf012ba1b
f0117722:	e8 64 98 fe ff       	call   f0100f8b <cprintf>
f0117727:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011772a:	e8 7b 6b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011772f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117732:	e8 6e d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117737:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f011773a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011773d:	83 ec 0c             	sub    $0xc,%esp
f0117740:	50                   	push   %eax
f0117741:	e8 03 1d ff ff       	call   f0109449 <kfree>
f0117746:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117749:	e8 57 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011774e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117751:	74 17                	je     f011776a <test_kmalloc_firstfit1+0x5ac>
f0117753:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011775a:	83 ec 0c             	sub    $0xc,%esp
f011775d:	68 2c ba 12 f0       	push   $0xf012ba2c
f0117762:	e8 24 98 fe ff       	call   f0100f8b <cprintf>
f0117767:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f011776a:	e8 3b 6b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011776f:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117772:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117777:	7f 17                	jg     f0117790 <test_kmalloc_firstfit1+0x5d2>
f0117779:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117780:	83 ec 0c             	sub    $0xc,%esp
f0117783:	68 98 ba 12 f0       	push   $0xf012ba98
f0117788:	e8 fe 97 fe ff       	call   f0100f8b <cprintf>
f011778d:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117790:	e8 15 6b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117795:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117798:	e8 08 d1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011779d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01177a0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01177a3:	83 ec 0c             	sub    $0xc,%esp
f01177a6:	50                   	push   %eax
f01177a7:	e8 9d 1c ff ff       	call   f0109449 <kfree>
f01177ac:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01177af:	e8 f1 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01177b4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01177b7:	74 17                	je     f01177d0 <test_kmalloc_firstfit1+0x612>
f01177b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177c0:	83 ec 0c             	sub    $0xc,%esp
f01177c3:	68 ac ba 12 f0       	push   $0xf012baac
f01177c8:	e8 be 97 fe ff       	call   f0100f8b <cprintf>
f01177cd:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f01177d0:	e8 d5 6a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01177d5:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01177d8:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01177dd:	7f 17                	jg     f01177f6 <test_kmalloc_firstfit1+0x638>
f01177df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177e6:	83 ec 0c             	sub    $0xc,%esp
f01177e9:	68 18 bb 12 f0       	push   $0xf012bb18
f01177ee:	e8 98 97 fe ff       	call   f0100f8b <cprintf>
f01177f3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01177f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01177fa:	74 04                	je     f0117800 <test_kmalloc_firstfit1+0x642>
f01177fc:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117800:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0117807:	83 ec 0c             	sub    $0xc,%esp
f011780a:	68 2c bb 12 f0       	push   $0xf012bb2c
f011780f:	e8 77 97 fe ff       	call   f0100f8b <cprintf>
f0117814:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117817:	e8 8e 6a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011781c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011781f:	e8 81 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117824:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0117827:	83 ec 0c             	sub    $0xc,%esp
f011782a:	68 00 fc 07 00       	push   $0x7fc00
f011782f:	e8 b5 19 ff ff       	call   f01091e9 <kmalloc>
f0117834:	83 c4 10             	add    $0x10,%esp
f0117837:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f011783a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011783d:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0117842:	74 17                	je     f011785b <test_kmalloc_firstfit1+0x69d>
f0117844:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011784b:	83 ec 0c             	sub    $0xc,%esp
f011784e:	68 58 bb 12 f0       	push   $0xf012bb58
f0117853:	e8 33 97 fe ff       	call   f0100f8b <cprintf>
f0117858:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011785b:	e8 45 d0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117860:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117863:	74 17                	je     f011787c <test_kmalloc_firstfit1+0x6be>
f0117865:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011786c:	83 ec 0c             	sub    $0xc,%esp
f011786f:	68 8c bb 12 f0       	push   $0xf012bb8c
f0117874:	e8 12 97 fe ff       	call   f0100f8b <cprintf>
f0117879:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f011787c:	e8 29 6a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117881:	89 c2                	mov    %eax,%edx
f0117883:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117886:	29 d0                	sub    %edx,%eax
f0117888:	83 f8 7f             	cmp    $0x7f,%eax
f011788b:	7f 17                	jg     f01178a4 <test_kmalloc_firstfit1+0x6e6>
f011788d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117894:	83 ec 0c             	sub    $0xc,%esp
f0117897:	68 f8 bb 12 f0       	push   $0xf012bbf8
f011789c:	e8 ea 96 fe ff       	call   f0100f8b <cprintf>
f01178a1:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01178a4:	e8 01 6a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01178a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178ac:	e8 f4 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f01178b4:	83 ec 0c             	sub    $0xc,%esp
f01178b7:	68 00 fc 0f 00       	push   $0xffc00
f01178bc:	e8 28 19 ff ff       	call   f01091e9 <kmalloc>
f01178c1:	83 c4 10             	add    $0x10,%esp
f01178c4:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f01178c7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01178ca:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01178cf:	74 17                	je     f01178e8 <test_kmalloc_firstfit1+0x72a>
f01178d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178d8:	83 ec 0c             	sub    $0xc,%esp
f01178db:	68 10 bc 12 f0       	push   $0xf012bc10
f01178e0:	e8 a6 96 fe ff       	call   f0100f8b <cprintf>
f01178e5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01178e8:	e8 b8 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01178ed:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01178f0:	74 17                	je     f0117909 <test_kmalloc_firstfit1+0x74b>
f01178f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178f9:	83 ec 0c             	sub    $0xc,%esp
f01178fc:	68 44 bc 12 f0       	push   $0xf012bc44
f0117901:	e8 85 96 fe ff       	call   f0100f8b <cprintf>
f0117906:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0117909:	e8 9c 69 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011790e:	89 c2                	mov    %eax,%edx
f0117910:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117913:	29 d0                	sub    %edx,%eax
f0117915:	3d ff 00 00 00       	cmp    $0xff,%eax
f011791a:	7f 17                	jg     f0117933 <test_kmalloc_firstfit1+0x775>
f011791c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117923:	83 ec 0c             	sub    $0xc,%esp
f0117926:	68 b0 bc 12 f0       	push   $0xf012bcb0
f011792b:	e8 5b 96 fe ff       	call   f0100f8b <cprintf>
f0117930:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117933:	e8 72 69 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117938:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011793b:	e8 65 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117940:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0117943:	83 ec 0c             	sub    $0xc,%esp
f0117946:	68 00 fc 03 00       	push   $0x3fc00
f011794b:	e8 99 18 ff ff       	call   f01091e9 <kmalloc>
f0117950:	83 c4 10             	add    $0x10,%esp
f0117953:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0117956:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117959:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f011795e:	74 17                	je     f0117977 <test_kmalloc_firstfit1+0x7b9>
f0117960:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117967:	83 ec 0c             	sub    $0xc,%esp
f011796a:	68 c8 bc 12 f0       	push   $0xf012bcc8
f011796f:	e8 17 96 fe ff       	call   f0100f8b <cprintf>
f0117974:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117977:	e8 29 cf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011797c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011797f:	74 17                	je     f0117998 <test_kmalloc_firstfit1+0x7da>
f0117981:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117988:	83 ec 0c             	sub    $0xc,%esp
f011798b:	68 fc bc 12 f0       	push   $0xf012bcfc
f0117990:	e8 f6 95 fe ff       	call   f0100f8b <cprintf>
f0117995:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0117998:	e8 0d 69 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011799d:	89 c2                	mov    %eax,%edx
f011799f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01179a2:	29 d0                	sub    %edx,%eax
f01179a4:	83 f8 3f             	cmp    $0x3f,%eax
f01179a7:	7f 17                	jg     f01179c0 <test_kmalloc_firstfit1+0x802>
f01179a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179b0:	83 ec 0c             	sub    $0xc,%esp
f01179b3:	68 68 bd 12 f0       	push   $0xf012bd68
f01179b8:	e8 ce 95 fe ff       	call   f0100f8b <cprintf>
f01179bd:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01179c0:	e8 e5 68 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01179c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01179c8:	e8 d8 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01179cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f01179d0:	83 ec 0c             	sub    $0xc,%esp
f01179d3:	68 00 00 20 00       	push   $0x200000
f01179d8:	e8 0c 18 ff ff       	call   f01091e9 <kmalloc>
f01179dd:	83 c4 10             	add    $0x10,%esp
f01179e0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f01179e3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01179e6:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f01179eb:	74 17                	je     f0117a04 <test_kmalloc_firstfit1+0x846>
f01179ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179f4:	83 ec 0c             	sub    $0xc,%esp
f01179f7:	68 80 bd 12 f0       	push   $0xf012bd80
f01179fc:	e8 8a 95 fe ff       	call   f0100f8b <cprintf>
f0117a01:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0117a04:	e8 a1 68 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117a09:	89 c2                	mov    %eax,%edx
f0117a0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117a0e:	29 d0                	sub    %edx,%eax
f0117a10:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117a15:	7f 17                	jg     f0117a2e <test_kmalloc_firstfit1+0x870>
f0117a17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a1e:	83 ec 0c             	sub    $0xc,%esp
f0117a21:	68 b4 bd 12 f0       	push   $0xf012bdb4
f0117a26:	e8 60 95 fe ff       	call   f0100f8b <cprintf>
f0117a2b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a2e:	e8 72 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a33:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a36:	74 17                	je     f0117a4f <test_kmalloc_firstfit1+0x891>
f0117a38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a3f:	83 ec 0c             	sub    $0xc,%esp
f0117a42:	68 cc bd 12 f0       	push   $0xf012bdcc
f0117a47:	e8 3f 95 fe ff       	call   f0100f8b <cprintf>
f0117a4c:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a4f:	e8 56 68 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117a54:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a57:	e8 49 ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0117a5f:	83 ec 0c             	sub    $0xc,%esp
f0117a62:	68 00 fc 3f 00       	push   $0x3ffc00
f0117a67:	e8 7d 17 ff ff       	call   f01091e9 <kmalloc>
f0117a6c:	83 c4 10             	add    $0x10,%esp
f0117a6f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0117a72:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117a75:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0117a7a:	74 17                	je     f0117a93 <test_kmalloc_firstfit1+0x8d5>
f0117a7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a83:	83 ec 0c             	sub    $0xc,%esp
f0117a86:	68 38 be 12 f0       	push   $0xf012be38
f0117a8b:	e8 fb 94 fe ff       	call   f0100f8b <cprintf>
f0117a90:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a93:	e8 0d ce fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117a98:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a9b:	74 17                	je     f0117ab4 <test_kmalloc_firstfit1+0x8f6>
f0117a9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117aa4:	83 ec 0c             	sub    $0xc,%esp
f0117aa7:	68 6c be 12 f0       	push   $0xf012be6c
f0117aac:	e8 da 94 fe ff       	call   f0100f8b <cprintf>
f0117ab1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f0117ab4:	e8 f1 67 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117ab9:	89 c2                	mov    %eax,%edx
f0117abb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117abe:	29 d0                	sub    %edx,%eax
f0117ac0:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f0117ac5:	7f 17                	jg     f0117ade <test_kmalloc_firstfit1+0x920>
f0117ac7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ace:	83 ec 0c             	sub    $0xc,%esp
f0117ad1:	68 d8 be 12 f0       	push   $0xf012bed8
f0117ad6:	e8 b0 94 fe ff       	call   f0100f8b <cprintf>
f0117adb:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117ade:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117ae2:	74 04                	je     f0117ae8 <test_kmalloc_firstfit1+0x92a>
f0117ae4:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0117ae8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0117aef:	83 ec 0c             	sub    $0xc,%esp
f0117af2:	68 f0 be 12 f0       	push   $0xf012bef0
f0117af7:	e8 8f 94 fe ff       	call   f0100f8b <cprintf>
f0117afc:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117aff:	e8 a6 67 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117b04:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b07:	e8 99 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b0c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0117b0f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117b12:	83 ec 0c             	sub    $0xc,%esp
f0117b15:	50                   	push   %eax
f0117b16:	e8 2e 19 ff ff       	call   f0109449 <kfree>
f0117b1b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b1e:	e8 82 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b23:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b26:	74 17                	je     f0117b3f <test_kmalloc_firstfit1+0x981>
f0117b28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b2f:	83 ec 0c             	sub    $0xc,%esp
f0117b32:	68 b0 b4 12 f0       	push   $0xf012b4b0
f0117b37:	e8 4f 94 fe ff       	call   f0100f8b <cprintf>
f0117b3c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0117b3f:	e8 66 67 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117b44:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117b47:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117b4c:	7f 17                	jg     f0117b65 <test_kmalloc_firstfit1+0x9a7>
f0117b4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b55:	83 ec 0c             	sub    $0xc,%esp
f0117b58:	68 24 bf 12 f0       	push   $0xf012bf24
f0117b5d:	e8 29 94 fe ff       	call   f0100f8b <cprintf>
f0117b62:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b65:	e8 40 67 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117b6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b6d:	e8 33 cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b72:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0117b75:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117b78:	83 ec 0c             	sub    $0xc,%esp
f0117b7b:	50                   	push   %eax
f0117b7c:	e8 c8 18 ff ff       	call   f0109449 <kfree>
f0117b81:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b84:	e8 1c cd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117b89:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b8c:	74 17                	je     f0117ba5 <test_kmalloc_firstfit1+0x9e7>
f0117b8e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b95:	83 ec 0c             	sub    $0xc,%esp
f0117b98:	68 78 b5 12 f0       	push   $0xf012b578
f0117b9d:	e8 e9 93 fe ff       	call   f0100f8b <cprintf>
f0117ba2:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0117ba5:	e8 00 67 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117baa:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117bad:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117bb2:	7f 17                	jg     f0117bcb <test_kmalloc_firstfit1+0xa0d>
f0117bb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bbb:	83 ec 0c             	sub    $0xc,%esp
f0117bbe:	68 35 bf 12 f0       	push   $0xf012bf35
f0117bc3:	e8 c3 93 fe ff       	call   f0100f8b <cprintf>
f0117bc8:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117bcb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117bcf:	74 04                	je     f0117bd5 <test_kmalloc_firstfit1+0xa17>
f0117bd1:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117bd5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0117bdc:	83 ec 0c             	sub    $0xc,%esp
f0117bdf:	68 48 bf 12 f0       	push   $0xf012bf48
f0117be4:	e8 a2 93 fe ff       	call   f0100f8b <cprintf>
f0117be9:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0117bec:	e8 b9 66 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117bf1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117bf4:	e8 ac cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117bf9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0117bfc:	83 ec 0c             	sub    $0xc,%esp
f0117bff:	68 00 00 10 00       	push   $0x100000
f0117c04:	e8 e0 15 ff ff       	call   f01091e9 <kmalloc>
f0117c09:	83 c4 10             	add    $0x10,%esp
f0117c0c:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0117c0f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117c12:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f0117c17:	74 17                	je     f0117c30 <test_kmalloc_firstfit1+0xa72>
f0117c19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c20:	83 ec 0c             	sub    $0xc,%esp
f0117c23:	68 88 bf 12 f0       	push   $0xf012bf88
f0117c28:	e8 5e 93 fe ff       	call   f0100f8b <cprintf>
f0117c2d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c30:	e8 70 cc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117c35:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c38:	74 17                	je     f0117c51 <test_kmalloc_firstfit1+0xa93>
f0117c3a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c41:	83 ec 0c             	sub    $0xc,%esp
f0117c44:	68 bc bf 12 f0       	push   $0xf012bfbc
f0117c49:	e8 3d 93 fe ff       	call   f0100f8b <cprintf>
f0117c4e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0117c51:	e8 54 66 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117c56:	89 c2                	mov    %eax,%edx
f0117c58:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c5b:	29 d0                	sub    %edx,%eax
f0117c5d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117c62:	7f 17                	jg     f0117c7b <test_kmalloc_firstfit1+0xabd>
f0117c64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c6b:	83 ec 0c             	sub    $0xc,%esp
f0117c6e:	68 28 c0 12 f0       	push   $0xf012c028
f0117c73:	e8 13 93 fe ff       	call   f0100f8b <cprintf>
f0117c78:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0117c7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117c7f:	74 04                	je     f0117c85 <test_kmalloc_firstfit1+0xac7>
f0117c81:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0117c85:	83 ec 08             	sub    $0x8,%esp
f0117c88:	ff 75 f4             	pushl  -0xc(%ebp)
f0117c8b:	68 40 c0 12 f0       	push   $0xf012c040
f0117c90:	e8 f6 92 fe ff       	call   f0100f8b <cprintf>
f0117c95:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117c98:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117c9d:	8b 7d fc             	mov    -0x4(%ebp),%edi
f0117ca0:	c9                   	leave  
f0117ca1:	c3                   	ret    

f0117ca2 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f0117ca2:	55                   	push   %ebp
f0117ca3:	89 e5                	mov    %esp,%ebp
f0117ca5:	57                   	push   %edi
f0117ca6:	53                   	push   %ebx
f0117ca7:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117caa:	83 ec 0c             	sub    $0xc,%esp
f0117cad:	68 28 a8 12 f0       	push   $0xf012a828
f0117cb2:	e8 d4 92 fe ff       	call   f0100f8b <cprintf>
f0117cb7:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117cba:	83 ec 0c             	sub    $0xc,%esp
f0117cbd:	68 58 a8 12 f0       	push   $0xf012a858
f0117cc2:	e8 c4 92 fe ff       	call   f0100f8b <cprintf>
f0117cc7:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117cca:	83 ec 0c             	sub    $0xc,%esp
f0117ccd:	68 28 a8 12 f0       	push   $0xf012a828
f0117cd2:	e8 b4 92 fe ff       	call   f0100f8b <cprintf>
f0117cd7:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117cda:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117cdd:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117ce2:	b8 00 00 00 00       	mov    $0x0,%eax
f0117ce7:	89 d7                	mov    %edx,%edi
f0117ce9:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0117ceb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0117cf2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0117cf9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0117d00:	83 ec 0c             	sub    $0xc,%esp
f0117d03:	68 78 c0 12 f0       	push   $0xf012c078
f0117d08:	e8 7e 92 fe ff       	call   f0100f8b <cprintf>
f0117d0d:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0117d10:	83 ec 0c             	sub    $0xc,%esp
f0117d13:	68 01 e0 ff 07       	push   $0x7ffe001
f0117d18:	e8 cc 14 ff ff       	call   f01091e9 <kmalloc>
f0117d1d:	83 c4 10             	add    $0x10,%esp
f0117d20:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f0117d23:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117d26:	85 c0                	test   %eax,%eax
f0117d28:	74 17                	je     f0117d41 <test_kmalloc_firstfit2+0x9f>
f0117d2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d31:	83 ec 0c             	sub    $0xc,%esp
f0117d34:	68 ac c0 12 f0       	push   $0xf012c0ac
f0117d39:	e8 4d 92 fe ff       	call   f0100f8b <cprintf>
f0117d3e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117d41:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117d45:	74 04                	je     f0117d4b <test_kmalloc_firstfit2+0xa9>
f0117d47:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117d4b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0117d52:	83 ec 0c             	sub    $0xc,%esp
f0117d55:	68 f4 c0 12 f0       	push   $0xf012c0f4
f0117d5a:	e8 2c 92 fe ff       	call   f0100f8b <cprintf>
f0117d5f:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d62:	e8 43 65 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117d67:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d6a:	e8 36 cb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117d6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0117d72:	83 ec 0c             	sub    $0xc,%esp
f0117d75:	68 00 fc 1f 00       	push   $0x1ffc00
f0117d7a:	e8 6a 14 ff ff       	call   f01091e9 <kmalloc>
f0117d7f:	83 c4 10             	add    $0x10,%esp
f0117d82:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117d85:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117d88:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117d8d:	74 17                	je     f0117da6 <test_kmalloc_firstfit2+0x104>
f0117d8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d96:	83 ec 0c             	sub    $0xc,%esp
f0117d99:	68 74 b7 12 f0       	push   $0xf012b774
f0117d9e:	e8 e8 91 fe ff       	call   f0100f8b <cprintf>
f0117da3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117da6:	e8 fa ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117dab:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117dae:	74 17                	je     f0117dc7 <test_kmalloc_firstfit2+0x125>
f0117db0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117db7:	83 ec 0c             	sub    $0xc,%esp
f0117dba:	68 50 ab 12 f0       	push   $0xf012ab50
f0117dbf:	e8 c7 91 fe ff       	call   f0100f8b <cprintf>
f0117dc4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117dc7:	e8 de 64 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117dcc:	89 c2                	mov    %eax,%edx
f0117dce:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117dd1:	29 d0                	sub    %edx,%eax
f0117dd3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117dd8:	7f 17                	jg     f0117df1 <test_kmalloc_firstfit2+0x14f>
f0117dda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117de1:	83 ec 0c             	sub    $0xc,%esp
f0117de4:	68 a7 b7 12 f0       	push   $0xf012b7a7
f0117de9:	e8 9d 91 fe ff       	call   f0100f8b <cprintf>
f0117dee:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117df1:	e8 b4 64 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117df6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117df9:	e8 a7 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117dfe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0117e01:	83 ec 0c             	sub    $0xc,%esp
f0117e04:	68 00 fc 1f 00       	push   $0x1ffc00
f0117e09:	e8 db 13 ff ff       	call   f01091e9 <kmalloc>
f0117e0e:	83 c4 10             	add    $0x10,%esp
f0117e11:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0117e14:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117e17:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117e1c:	74 17                	je     f0117e35 <test_kmalloc_firstfit2+0x193>
f0117e1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e25:	83 ec 0c             	sub    $0xc,%esp
f0117e28:	68 c0 b7 12 f0       	push   $0xf012b7c0
f0117e2d:	e8 59 91 fe ff       	call   f0100f8b <cprintf>
f0117e32:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117e35:	e8 6b ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e3a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117e3d:	74 17                	je     f0117e56 <test_kmalloc_firstfit2+0x1b4>
f0117e3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e46:	83 ec 0c             	sub    $0xc,%esp
f0117e49:	68 8c ac 12 f0       	push   $0xf012ac8c
f0117e4e:	e8 38 91 fe ff       	call   f0100f8b <cprintf>
f0117e53:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117e56:	e8 4f 64 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117e5b:	89 c2                	mov    %eax,%edx
f0117e5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e60:	29 d0                	sub    %edx,%eax
f0117e62:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117e67:	7f 17                	jg     f0117e80 <test_kmalloc_firstfit2+0x1de>
f0117e69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e70:	83 ec 0c             	sub    $0xc,%esp
f0117e73:	68 f3 b7 12 f0       	push   $0xf012b7f3
f0117e78:	e8 0e 91 fe ff       	call   f0100f8b <cprintf>
f0117e7d:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e80:	e8 25 64 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117e85:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e88:	e8 18 ca fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117e8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0117e90:	83 ec 0c             	sub    $0xc,%esp
f0117e93:	68 00 1c 00 00       	push   $0x1c00
f0117e98:	e8 4c 13 ff ff       	call   f01091e9 <kmalloc>
f0117e9d:	83 c4 10             	add    $0x10,%esp
f0117ea0:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0117ea3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117ea6:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117eab:	74 17                	je     f0117ec4 <test_kmalloc_firstfit2+0x222>
f0117ead:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117eb4:	83 ec 0c             	sub    $0xc,%esp
f0117eb7:	68 0c b8 12 f0       	push   $0xf012b80c
f0117ebc:	e8 ca 90 fe ff       	call   f0100f8b <cprintf>
f0117ec1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ec4:	e8 dc c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117ec9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ecc:	74 17                	je     f0117ee5 <test_kmalloc_firstfit2+0x243>
f0117ece:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ed5:	83 ec 0c             	sub    $0xc,%esp
f0117ed8:	68 84 ad 12 f0       	push   $0xf012ad84
f0117edd:	e8 a9 90 fe ff       	call   f0100f8b <cprintf>
f0117ee2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f0117ee5:	e8 c0 63 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117eea:	89 c2                	mov    %eax,%edx
f0117eec:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117eef:	29 d0                	sub    %edx,%eax
f0117ef1:	83 f8 01             	cmp    $0x1,%eax
f0117ef4:	7f 17                	jg     f0117f0d <test_kmalloc_firstfit2+0x26b>
f0117ef6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117efd:	83 ec 0c             	sub    $0xc,%esp
f0117f00:	68 3f b8 12 f0       	push   $0xf012b83f
f0117f05:	e8 81 90 fe ff       	call   f0100f8b <cprintf>
f0117f0a:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f0d:	e8 98 63 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117f12:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f15:	e8 8b c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f1a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0117f1d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117f20:	83 ec 0c             	sub    $0xc,%esp
f0117f23:	50                   	push   %eax
f0117f24:	e8 20 15 ff ff       	call   f0109449 <kfree>
f0117f29:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117f2c:	e8 74 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f31:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117f34:	74 17                	je     f0117f4d <test_kmalloc_firstfit2+0x2ab>
f0117f36:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f3d:	83 ec 0c             	sub    $0xc,%esp
f0117f40:	68 64 ae 12 f0       	push   $0xf012ae64
f0117f45:	e8 41 90 fe ff       	call   f0100f8b <cprintf>
f0117f4a:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f0117f4d:	e8 58 63 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117f52:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117f55:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117f5a:	7f 17                	jg     f0117f73 <test_kmalloc_firstfit2+0x2d1>
f0117f5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117f63:	83 ec 0c             	sub    $0xc,%esp
f0117f66:	68 3a c1 12 f0       	push   $0xf012c13a
f0117f6b:	e8 1b 90 fe ff       	call   f0100f8b <cprintf>
f0117f70:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117f73:	e8 32 63 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117f78:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117f7b:	e8 25 c9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117f80:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0117f83:	83 ec 0c             	sub    $0xc,%esp
f0117f86:	68 00 fc 2f 00       	push   $0x2ffc00
f0117f8b:	e8 59 12 ff ff       	call   f01091e9 <kmalloc>
f0117f90:	83 c4 10             	add    $0x10,%esp
f0117f93:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117f96:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117f99:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117f9e:	74 17                	je     f0117fb7 <test_kmalloc_firstfit2+0x315>
f0117fa0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fa7:	83 ec 0c             	sub    $0xc,%esp
f0117faa:	68 a4 b8 12 f0       	push   $0xf012b8a4
f0117faf:	e8 d7 8f fe ff       	call   f0100f8b <cprintf>
f0117fb4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117fb7:	e8 e9 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0117fbc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fbf:	74 17                	je     f0117fd8 <test_kmalloc_firstfit2+0x336>
f0117fc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fc8:	83 ec 0c             	sub    $0xc,%esp
f0117fcb:	68 68 af 12 f0       	push   $0xf012af68
f0117fd0:	e8 b6 8f fe ff       	call   f0100f8b <cprintf>
f0117fd5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117fd8:	e8 cd 62 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0117fdd:	89 c2                	mov    %eax,%edx
f0117fdf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fe2:	29 d0                	sub    %edx,%eax
f0117fe4:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117fe9:	7f 17                	jg     f0118002 <test_kmalloc_firstfit2+0x360>
f0117feb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ff2:	83 ec 0c             	sub    $0xc,%esp
f0117ff5:	68 d7 b8 12 f0       	push   $0xf012b8d7
f0117ffa:	e8 8c 8f fe ff       	call   f0100f8b <cprintf>
f0117fff:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118002:	e8 a3 62 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118007:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011800a:	e8 96 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011800f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0118012:	83 ec 0c             	sub    $0xc,%esp
f0118015:	68 00 18 20 00       	push   $0x201800
f011801a:	e8 ca 11 ff ff       	call   f01091e9 <kmalloc>
f011801f:	83 c4 10             	add    $0x10,%esp
f0118022:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0118025:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118028:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011802d:	74 17                	je     f0118046 <test_kmalloc_firstfit2+0x3a4>
f011802f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118036:	83 ec 0c             	sub    $0xc,%esp
f0118039:	68 f0 b8 12 f0       	push   $0xf012b8f0
f011803e:	e8 48 8f fe ff       	call   f0100f8b <cprintf>
f0118043:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118046:	e8 5a c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011804b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011804e:	74 17                	je     f0118067 <test_kmalloc_firstfit2+0x3c5>
f0118050:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118057:	83 ec 0c             	sub    $0xc,%esp
f011805a:	68 6c b0 12 f0       	push   $0xf012b06c
f011805f:	e8 27 8f fe ff       	call   f0100f8b <cprintf>
f0118064:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0118067:	e8 3e 62 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011806c:	89 c2                	mov    %eax,%edx
f011806e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118071:	29 d0                	sub    %edx,%eax
f0118073:	3d 01 02 00 00       	cmp    $0x201,%eax
f0118078:	7f 17                	jg     f0118091 <test_kmalloc_firstfit2+0x3ef>
f011807a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118081:	83 ec 0c             	sub    $0xc,%esp
f0118084:	68 23 b9 12 f0       	push   $0xf012b923
f0118089:	e8 fd 8e fe ff       	call   f0100f8b <cprintf>
f011808e:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118091:	e8 14 62 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118096:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118099:	e8 07 c8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011809e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01180a1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01180a4:	83 ec 0c             	sub    $0xc,%esp
f01180a7:	50                   	push   %eax
f01180a8:	e8 9c 13 ff ff       	call   f0109449 <kfree>
f01180ad:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01180b0:	e8 f0 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01180b5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180b8:	74 17                	je     f01180d1 <test_kmalloc_firstfit2+0x42f>
f01180ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180c1:	83 ec 0c             	sub    $0xc,%esp
f01180c4:	68 70 b1 12 f0       	push   $0xf012b170
f01180c9:	e8 bd 8e fe ff       	call   f0100f8b <cprintf>
f01180ce:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f01180d1:	e8 d4 61 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01180d6:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01180d9:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01180de:	7f 17                	jg     f01180f7 <test_kmalloc_firstfit2+0x455>
f01180e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180e7:	83 ec 0c             	sub    $0xc,%esp
f01180ea:	68 4a c1 12 f0       	push   $0xf012c14a
f01180ef:	e8 97 8e fe ff       	call   f0100f8b <cprintf>
f01180f4:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01180f7:	e8 ae 61 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01180fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01180ff:	e8 a1 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118104:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0118107:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011810a:	83 ec 0c             	sub    $0xc,%esp
f011810d:	50                   	push   %eax
f011810e:	e8 36 13 ff ff       	call   f0109449 <kfree>
f0118113:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f0118116:	e8 8f 61 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011811b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011811e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118123:	7f 17                	jg     f011813c <test_kmalloc_firstfit2+0x49a>
f0118125:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011812c:	83 ec 0c             	sub    $0xc,%esp
f011812f:	68 1b ba 12 f0       	push   $0xf012ba1b
f0118134:	e8 52 8e fe ff       	call   f0100f8b <cprintf>
f0118139:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011813c:	e8 64 c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118141:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118144:	74 17                	je     f011815d <test_kmalloc_firstfit2+0x4bb>
f0118146:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011814d:	83 ec 0c             	sub    $0xc,%esp
f0118150:	68 b0 b9 12 f0       	push   $0xf012b9b0
f0118155:	e8 31 8e fe ff       	call   f0100f8b <cprintf>
f011815a:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011815d:	e8 48 61 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118162:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118165:	e8 3b c7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011816a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f011816d:	83 ec 0c             	sub    $0xc,%esp
f0118170:	68 00 fc 4f 00       	push   $0x4ffc00
f0118175:	e8 6f 10 ff ff       	call   f01091e9 <kmalloc>
f011817a:	83 c4 10             	add    $0x10,%esp
f011817d:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0118180:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118183:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0118188:	74 17                	je     f01181a1 <test_kmalloc_firstfit2+0x4ff>
f011818a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118191:	83 ec 0c             	sub    $0xc,%esp
f0118194:	68 5c c1 12 f0       	push   $0xf012c15c
f0118199:	e8 ed 8d fe ff       	call   f0100f8b <cprintf>
f011819e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181a1:	e8 ff c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181a6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181a9:	74 17                	je     f01181c2 <test_kmalloc_firstfit2+0x520>
f01181ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181b2:	83 ec 0c             	sub    $0xc,%esp
f01181b5:	68 2c ba 12 f0       	push   $0xf012ba2c
f01181ba:	e8 cc 8d fe ff       	call   f0100f8b <cprintf>
f01181bf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f01181c2:	e8 e3 60 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01181c7:	89 c2                	mov    %eax,%edx
f01181c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01181cc:	29 d0                	sub    %edx,%eax
f01181ce:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f01181d3:	7f 17                	jg     f01181ec <test_kmalloc_firstfit2+0x54a>
f01181d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181dc:	83 ec 0c             	sub    $0xc,%esp
f01181df:	68 90 c1 12 f0       	push   $0xf012c190
f01181e4:	e8 a2 8d fe ff       	call   f0100f8b <cprintf>
f01181e9:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01181ec:	e8 b9 60 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01181f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01181f4:	e8 ac c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01181f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f01181fc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01181ff:	83 ec 0c             	sub    $0xc,%esp
f0118202:	50                   	push   %eax
f0118203:	e8 41 12 ff ff       	call   f0109449 <kfree>
f0118208:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011820b:	e8 95 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118210:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118213:	74 17                	je     f011822c <test_kmalloc_firstfit2+0x58a>
f0118215:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011821c:	83 ec 0c             	sub    $0xc,%esp
f011821f:	68 ac ba 12 f0       	push   $0xf012baac
f0118224:	e8 62 8d fe ff       	call   f0100f8b <cprintf>
f0118229:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f011822c:	e8 79 60 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118231:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118234:	83 f8 01             	cmp    $0x1,%eax
f0118237:	7f 17                	jg     f0118250 <test_kmalloc_firstfit2+0x5ae>
f0118239:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118240:	83 ec 0c             	sub    $0xc,%esp
f0118243:	68 18 bb 12 f0       	push   $0xf012bb18
f0118248:	e8 3e 8d fe ff       	call   f0100f8b <cprintf>
f011824d:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0118250:	e8 55 60 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118255:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118258:	e8 48 c6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011825d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0118260:	83 ec 0c             	sub    $0xc,%esp
f0118263:	68 00 04 00 00       	push   $0x400
f0118268:	e8 7c 0f ff ff       	call   f01091e9 <kmalloc>
f011826d:	83 c4 10             	add    $0x10,%esp
f0118270:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118273:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118276:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011827b:	76 22                	jbe    f011829f <test_kmalloc_firstfit2+0x5fd>
f011827d:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0118280:	83 ec 0c             	sub    $0xc,%esp
f0118283:	6a 00                	push   $0x0
f0118285:	e8 2c 0e ff ff       	call   f01090b6 <sbrk>
f011828a:	83 c4 10             	add    $0x10,%esp
f011828d:	39 c3                	cmp    %eax,%ebx
f011828f:	73 0e                	jae    f011829f <test_kmalloc_firstfit2+0x5fd>
f0118291:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118294:	89 c2                	mov    %eax,%edx
f0118296:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011829b:	39 c2                	cmp    %eax,%edx
f011829d:	72 17                	jb     f01182b6 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011829f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182a6:	83 ec 0c             	sub    $0xc,%esp
f01182a9:	68 a8 c1 12 f0       	push   $0xf012c1a8
f01182ae:	e8 d8 8c fe ff       	call   f0100f8b <cprintf>
f01182b3:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01182b6:	e8 ea c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01182bb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01182be:	74 17                	je     f01182d7 <test_kmalloc_firstfit2+0x635>
f01182c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182c7:	83 ec 0c             	sub    $0xc,%esp
f01182ca:	68 8c bb 12 f0       	push   $0xf012bb8c
f01182cf:	e8 b7 8c fe ff       	call   f0100f8b <cprintf>
f01182d4:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01182d7:	e8 c9 c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01182dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f01182df:	83 ec 0c             	sub    $0xc,%esp
f01182e2:	68 00 08 00 00       	push   $0x800
f01182e7:	e8 fd 0e ff ff       	call   f01091e9 <kmalloc>
f01182ec:	83 c4 10             	add    $0x10,%esp
f01182ef:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01182f2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01182f5:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01182fa:	76 22                	jbe    f011831e <test_kmalloc_firstfit2+0x67c>
f01182fc:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f01182ff:	83 ec 0c             	sub    $0xc,%esp
f0118302:	6a 00                	push   $0x0
f0118304:	e8 ad 0d ff ff       	call   f01090b6 <sbrk>
f0118309:	83 c4 10             	add    $0x10,%esp
f011830c:	39 c3                	cmp    %eax,%ebx
f011830e:	73 0e                	jae    f011831e <test_kmalloc_firstfit2+0x67c>
f0118310:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118313:	89 c2                	mov    %eax,%edx
f0118315:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011831a:	39 c2                	cmp    %eax,%edx
f011831c:	72 17                	jb     f0118335 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011831e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118325:	83 ec 0c             	sub    $0xc,%esp
f0118328:	68 34 c2 12 f0       	push   $0xf012c234
f011832d:	e8 59 8c fe ff       	call   f0100f8b <cprintf>
f0118332:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118335:	e8 6b c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011833a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011833d:	74 17                	je     f0118356 <test_kmalloc_firstfit2+0x6b4>
f011833f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118346:	83 ec 0c             	sub    $0xc,%esp
f0118349:	68 44 bc 12 f0       	push   $0xf012bc44
f011834e:	e8 38 8c fe ff       	call   f0100f8b <cprintf>
f0118353:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118356:	e8 4a c5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011835b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f011835e:	83 ec 0c             	sub    $0xc,%esp
f0118361:	68 00 04 00 00       	push   $0x400
f0118366:	e8 7e 0e ff ff       	call   f01091e9 <kmalloc>
f011836b:	83 c4 10             	add    $0x10,%esp
f011836e:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0118371:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118374:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118379:	76 22                	jbe    f011839d <test_kmalloc_firstfit2+0x6fb>
f011837b:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011837e:	83 ec 0c             	sub    $0xc,%esp
f0118381:	6a 00                	push   $0x0
f0118383:	e8 2e 0d ff ff       	call   f01090b6 <sbrk>
f0118388:	83 c4 10             	add    $0x10,%esp
f011838b:	39 c3                	cmp    %eax,%ebx
f011838d:	73 0e                	jae    f011839d <test_kmalloc_firstfit2+0x6fb>
f011838f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118392:	89 c2                	mov    %eax,%edx
f0118394:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f0118399:	39 c2                	cmp    %eax,%edx
f011839b:	72 17                	jb     f01183b4 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011839d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183a4:	83 ec 0c             	sub    $0xc,%esp
f01183a7:	68 c0 c2 12 f0       	push   $0xf012c2c0
f01183ac:	e8 da 8b fe ff       	call   f0100f8b <cprintf>
f01183b1:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183b4:	e8 ec c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01183b9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01183bc:	74 17                	je     f01183d5 <test_kmalloc_firstfit2+0x733>
f01183be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183c5:	83 ec 0c             	sub    $0xc,%esp
f01183c8:	68 fc bc 12 f0       	push   $0xf012bcfc
f01183cd:	e8 b9 8b fe ff       	call   f0100f8b <cprintf>
f01183d2:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f01183d5:	e8 d0 5e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01183da:	89 c2                	mov    %eax,%edx
f01183dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01183df:	29 d0                	sub    %edx,%eax
f01183e1:	83 f8 01             	cmp    $0x1,%eax
f01183e4:	74 17                	je     f01183fd <test_kmalloc_firstfit2+0x75b>
f01183e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183ed:	83 ec 0c             	sub    $0xc,%esp
f01183f0:	68 4c c3 12 f0       	push   $0xf012c34c
f01183f5:	e8 91 8b fe ff       	call   f0100f8b <cprintf>
f01183fa:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f01183fd:	e8 a8 5e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118402:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118405:	e8 9b c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011840a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f011840d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118410:	83 ec 0c             	sub    $0xc,%esp
f0118413:	50                   	push   %eax
f0118414:	e8 30 10 ff ff       	call   f0109449 <kfree>
f0118419:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011841c:	e8 84 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118421:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118424:	74 17                	je     f011843d <test_kmalloc_firstfit2+0x79b>
f0118426:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011842d:	83 ec 0c             	sub    $0xc,%esp
f0118430:	68 cc bd 12 f0       	push   $0xf012bdcc
f0118435:	e8 51 8b fe ff       	call   f0100f8b <cprintf>
f011843a:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011843d:	e8 68 5e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118442:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118445:	74 17                	je     f011845e <test_kmalloc_firstfit2+0x7bc>
f0118447:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011844e:	83 ec 0c             	sub    $0xc,%esp
f0118451:	68 70 c3 12 f0       	push   $0xf012c370
f0118456:	e8 30 8b fe ff       	call   f0100f8b <cprintf>
f011845b:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f011845e:	e8 47 5e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118463:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118466:	e8 3a c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011846b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f011846e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118471:	83 ec 0c             	sub    $0xc,%esp
f0118474:	50                   	push   %eax
f0118475:	e8 cf 0f ff ff       	call   f0109449 <kfree>
f011847a:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011847d:	e8 23 c4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118482:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118485:	74 17                	je     f011849e <test_kmalloc_firstfit2+0x7fc>
f0118487:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011848e:	83 ec 0c             	sub    $0xc,%esp
f0118491:	68 6c be 12 f0       	push   $0xf012be6c
f0118496:	e8 f0 8a fe ff       	call   f0100f8b <cprintf>
f011849b:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011849e:	e8 07 5e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01184a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01184a6:	74 17                	je     f01184bf <test_kmalloc_firstfit2+0x81d>
f01184a8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184af:	83 ec 0c             	sub    $0xc,%esp
f01184b2:	68 d0 c3 12 f0       	push   $0xf012c3d0
f01184b7:	e8 cf 8a fe ff       	call   f0100f8b <cprintf>
f01184bc:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f01184bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01184c3:	74 04                	je     f01184c9 <test_kmalloc_firstfit2+0x827>
f01184c5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f01184c9:	83 ec 0c             	sub    $0xc,%esp
f01184cc:	68 30 c4 12 f0       	push   $0xf012c430
f01184d1:	e8 b5 8a fe ff       	call   f0100f8b <cprintf>
f01184d6:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01184d9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01184e0:	e8 c5 5d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01184e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184e8:	e8 b8 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01184ed:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f01184f0:	83 ec 0c             	sub    $0xc,%esp
f01184f3:	68 00 08 00 00       	push   $0x800
f01184f8:	e8 ec 0c ff ff       	call   f01091e9 <kmalloc>
f01184fd:	83 c4 10             	add    $0x10,%esp
f0118500:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0118503:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0118506:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118509:	39 c2                	cmp    %eax,%edx
f011850b:	74 17                	je     f0118524 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f011850d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118514:	83 ec 0c             	sub    $0xc,%esp
f0118517:	68 68 c4 12 f0       	push   $0xf012c468
f011851c:	e8 6a 8a fe ff       	call   f0100f8b <cprintf>
f0118521:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118524:	e8 7c c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118529:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011852c:	74 17                	je     f0118545 <test_kmalloc_firstfit2+0x8a3>
f011852e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118535:	83 ec 0c             	sub    $0xc,%esp
f0118538:	68 b0 b4 12 f0       	push   $0xf012b4b0
f011853d:	e8 49 8a fe ff       	call   f0100f8b <cprintf>
f0118542:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0118545:	e8 60 5d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011854a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011854d:	74 17                	je     f0118566 <test_kmalloc_firstfit2+0x8c4>
f011854f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118556:	83 ec 0c             	sub    $0xc,%esp
f0118559:	68 9c c4 12 f0       	push   $0xf012c49c
f011855e:	e8 28 8a fe ff       	call   f0100f8b <cprintf>
f0118563:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118566:	e8 3f 5d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011856b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011856e:	e8 32 c3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118573:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0118576:	83 ec 0c             	sub    $0xc,%esp
f0118579:	68 00 04 00 00       	push   $0x400
f011857e:	e8 66 0c ff ff       	call   f01091e9 <kmalloc>
f0118583:	83 c4 10             	add    $0x10,%esp
f0118586:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0118589:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011858c:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011858f:	81 c2 08 08 00 00    	add    $0x808,%edx
f0118595:	39 d0                	cmp    %edx,%eax
f0118597:	74 17                	je     f01185b0 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0118599:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185a0:	83 ec 0c             	sub    $0xc,%esp
f01185a3:	68 b4 c4 12 f0       	push   $0xf012c4b4
f01185a8:	e8 de 89 fe ff       	call   f0100f8b <cprintf>
f01185ad:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185b0:	e8 f0 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01185b5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185b8:	74 17                	je     f01185d1 <test_kmalloc_firstfit2+0x92f>
f01185ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185c1:	83 ec 0c             	sub    $0xc,%esp
f01185c4:	68 78 b5 12 f0       	push   $0xf012b578
f01185c9:	e8 bd 89 fe ff       	call   f0100f8b <cprintf>
f01185ce:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f01185d1:	e8 d4 5c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01185d6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01185d9:	74 17                	je     f01185f2 <test_kmalloc_firstfit2+0x950>
f01185db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185e2:	83 ec 0c             	sub    $0xc,%esp
f01185e5:	68 e8 c4 12 f0       	push   $0xf012c4e8
f01185ea:	e8 9c 89 fe ff       	call   f0100f8b <cprintf>
f01185ef:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f01185f2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01185f6:	74 04                	je     f01185fc <test_kmalloc_firstfit2+0x95a>
f01185f8:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f01185fc:	83 ec 0c             	sub    $0xc,%esp
f01185ff:	68 00 c5 12 f0       	push   $0xf012c500
f0118604:	e8 82 89 fe ff       	call   f0100f8b <cprintf>
f0118609:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f011860c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118613:	e8 92 5c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118618:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011861b:	e8 85 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118620:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0118623:	83 ec 0c             	sub    $0xc,%esp
f0118626:	68 00 04 70 00       	push   $0x700400
f011862b:	e8 b9 0b ff ff       	call   f01091e9 <kmalloc>
f0118630:	83 c4 10             	add    $0x10,%esp
f0118633:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118636:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118639:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011863e:	74 17                	je     f0118657 <test_kmalloc_firstfit2+0x9b5>
f0118640:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118647:	83 ec 0c             	sub    $0xc,%esp
f011864a:	68 88 bf 12 f0       	push   $0xf012bf88
f011864f:	e8 37 89 fe ff       	call   f0100f8b <cprintf>
f0118654:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118657:	e8 49 c2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011865c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011865f:	74 17                	je     f0118678 <test_kmalloc_firstfit2+0x9d6>
f0118661:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118668:	83 ec 0c             	sub    $0xc,%esp
f011866b:	68 bc bf 12 f0       	push   $0xf012bfbc
f0118670:	e8 16 89 fe ff       	call   f0100f8b <cprintf>
f0118675:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118678:	e8 2d 5c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011867d:	89 c2                	mov    %eax,%edx
f011867f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118682:	29 d0                	sub    %edx,%eax
f0118684:	3d 00 07 00 00       	cmp    $0x700,%eax
f0118689:	7f 17                	jg     f01186a2 <test_kmalloc_firstfit2+0xa00>
f011868b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118692:	83 ec 0c             	sub    $0xc,%esp
f0118695:	68 28 c0 12 f0       	push   $0xf012c028
f011869a:	e8 ec 88 fe ff       	call   f0100f8b <cprintf>
f011869f:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01186a2:	e8 03 5c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01186a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186aa:	e8 f6 c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186af:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f01186b2:	83 ec 0c             	sub    $0xc,%esp
f01186b5:	68 00 0c 00 00       	push   $0xc00
f01186ba:	e8 2a 0b ff ff       	call   f01091e9 <kmalloc>
f01186bf:	83 c4 10             	add    $0x10,%esp
f01186c2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f01186c5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01186c8:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f01186cd:	74 17                	je     f01186e6 <test_kmalloc_firstfit2+0xa44>
f01186cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186d6:	83 ec 0c             	sub    $0xc,%esp
f01186d9:	68 34 c5 12 f0       	push   $0xf012c534
f01186de:	e8 a8 88 fe ff       	call   f0100f8b <cprintf>
f01186e3:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01186e6:	e8 ba c1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01186eb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01186ee:	74 17                	je     f0118707 <test_kmalloc_firstfit2+0xa65>
f01186f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186f7:	83 ec 0c             	sub    $0xc,%esp
f01186fa:	68 68 c5 12 f0       	push   $0xf012c568
f01186ff:	e8 87 88 fe ff       	call   f0100f8b <cprintf>
f0118704:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0118707:	e8 9e 5b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011870c:	89 c2                	mov    %eax,%edx
f011870e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118711:	29 d0                	sub    %edx,%eax
f0118713:	85 c0                	test   %eax,%eax
f0118715:	7f 17                	jg     f011872e <test_kmalloc_firstfit2+0xa8c>
f0118717:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011871e:	83 ec 0c             	sub    $0xc,%esp
f0118721:	68 d4 c5 12 f0       	push   $0xf012c5d4
f0118726:	e8 60 88 fe ff       	call   f0100f8b <cprintf>
f011872b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f011872e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118732:	74 04                	je     f0118738 <test_kmalloc_firstfit2+0xa96>
f0118734:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0118738:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f011873f:	83 ec 0c             	sub    $0xc,%esp
f0118742:	68 ec c5 12 f0       	push   $0xf012c5ec
f0118747:	e8 3f 88 fe ff       	call   f0100f8b <cprintf>
f011874c:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f011874f:	83 ec 0c             	sub    $0xc,%esp
f0118752:	68 00 e0 1f 07       	push   $0x71fe000
f0118757:	e8 8d 0a ff ff       	call   f01091e9 <kmalloc>
f011875c:	83 c4 10             	add    $0x10,%esp
f011875f:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0118762:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118765:	85 c0                	test   %eax,%eax
f0118767:	74 17                	je     f0118780 <test_kmalloc_firstfit2+0xade>
f0118769:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118770:	83 ec 0c             	sub    $0xc,%esp
f0118773:	68 40 c6 12 f0       	push   $0xf012c640
f0118778:	e8 0e 88 fe ff       	call   f0100f8b <cprintf>
f011877d:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0118780:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118784:	74 04                	je     f011878a <test_kmalloc_firstfit2+0xae8>
f0118786:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f011878a:	83 ec 08             	sub    $0x8,%esp
f011878d:	ff 75 f4             	pushl  -0xc(%ebp)
f0118790:	68 a8 c6 12 f0       	push   $0xf012c6a8
f0118795:	e8 f1 87 fe ff       	call   f0100f8b <cprintf>
f011879a:	83 c4 10             	add    $0x10,%esp

	return 1;
f011879d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01187a2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01187a5:	5b                   	pop    %ebx
f01187a6:	5f                   	pop    %edi
f01187a7:	5d                   	pop    %ebp
f01187a8:	c3                   	ret    

f01187a9 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f01187a9:	55                   	push   %ebp
f01187aa:	89 e5                	mov    %esp,%ebp
f01187ac:	53                   	push   %ebx
f01187ad:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01187b0:	83 ec 0c             	sub    $0xc,%esp
f01187b3:	68 28 a8 12 f0       	push   $0xf012a828
f01187b8:	e8 ce 87 fe ff       	call   f0100f8b <cprintf>
f01187bd:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01187c0:	83 ec 0c             	sub    $0xc,%esp
f01187c3:	68 58 a8 12 f0       	push   $0xf012a858
f01187c8:	e8 be 87 fe ff       	call   f0100f8b <cprintf>
f01187cd:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01187d0:	83 ec 0c             	sub    $0xc,%esp
f01187d3:	68 28 a8 12 f0       	push   $0xf012a828
f01187d8:	e8 ae 87 fe ff       	call   f0100f8b <cprintf>
f01187dd:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f01187e0:	e8 c5 5a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01187e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f01187e8:	e8 b8 c0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01187ed:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f01187f0:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f01187f7:	83 ec 0c             	sub    $0xc,%esp
f01187fa:	68 dd c6 12 f0       	push   $0xf012c6dd
f01187ff:	e8 87 87 fe ff       	call   f0100f8b <cprintf>
f0118804:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0118807:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f011880c:	ba 00 00 00 00       	mov    $0x0,%edx
f0118811:	f7 75 e4             	divl   -0x1c(%ebp)
f0118814:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0118817:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011881e:	eb 1d                	jmp    f011883d <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0118820:	83 ec 0c             	sub    $0xc,%esp
f0118823:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118826:	e8 be 09 ff ff       	call   f01091e9 <kmalloc>
f011882b:	83 c4 10             	add    $0x10,%esp
f011882e:	89 c2                	mov    %eax,%edx
f0118830:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118833:	89 14 85 60 50 69 f0 	mov    %edx,-0xf96afa0(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f011883a:	ff 45 f4             	incl   -0xc(%ebp)
f011883d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118840:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0118843:	7c db                	jl     f0118820 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0118845:	83 ec 0c             	sub    $0xc,%esp
f0118848:	68 e1 c6 12 f0       	push   $0xf012c6e1
f011884d:	e8 39 87 fe ff       	call   f0100f8b <cprintf>
f0118852:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0118855:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f011885a:	ba 00 00 00 00       	mov    $0x0,%edx
f011885f:	f7 75 e4             	divl   -0x1c(%ebp)
f0118862:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0118865:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118869:	74 1e                	je     f0118889 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f011886b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f011886e:	8d 43 01             	lea    0x1(%ebx),%eax
f0118871:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118874:	83 ec 0c             	sub    $0xc,%esp
f0118877:	ff 75 e0             	pushl  -0x20(%ebp)
f011887a:	e8 6a 09 ff ff       	call   f01091e9 <kmalloc>
f011887f:	83 c4 10             	add    $0x10,%esp
f0118882:	89 04 9d 60 50 69 f0 	mov    %eax,-0xf96afa0(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0118889:	83 ec 04             	sub    $0x4,%esp
f011888c:	ff 75 f0             	pushl  -0x10(%ebp)
f011888f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118892:	68 e8 c6 12 f0       	push   $0xf012c6e8
f0118897:	e8 ef 86 fe ff       	call   f0100f8b <cprintf>
f011889c:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f011889f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01188a6:	eb 36                	jmp    f01188de <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f01188a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188ab:	8b 04 85 60 50 69 f0 	mov    -0xf96afa0(,%eax,4),%eax
f01188b2:	89 c2                	mov    %eax,%edx
f01188b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188b7:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01188bb:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f01188c0:	39 c2                	cmp    %eax,%edx
f01188c2:	74 17                	je     f01188db <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f01188c4:	83 ec 04             	sub    $0x4,%esp
f01188c7:	68 30 c7 12 f0       	push   $0xf012c730
f01188cc:	68 e3 02 00 00       	push   $0x2e3
f01188d1:	68 73 c7 12 f0       	push   $0xf012c773
f01188d6:	e8 5e 7a fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f01188db:	ff 45 f4             	incl   -0xc(%ebp)
f01188de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01188e1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01188e4:	7c c2                	jl     f01188a8 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01188e6:	e8 ba bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01188eb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01188ee:	74 17                	je     f0118907 <test_fastfirstfit+0x15e>
f01188f0:	83 ec 04             	sub    $0x4,%esp
f01188f3:	68 8c c7 12 f0       	push   $0xf012c78c
f01188f8:	68 e6 02 00 00       	push   $0x2e6
f01188fd:	68 73 c7 12 f0       	push   $0xf012c773
f0118902:	e8 32 7a fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0118907:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011890a:	e8 9b 59 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011890f:	29 c3                	sub    %eax,%ebx
f0118911:	89 d8                	mov    %ebx,%eax
f0118913:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0118918:	77 17                	ja     f0118931 <test_fastfirstfit+0x188>
f011891a:	83 ec 04             	sub    $0x4,%esp
f011891d:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118922:	68 e7 02 00 00       	push   $0x2e7
f0118927:	68 73 c7 12 f0       	push   $0xf012c773
f011892c:	e8 08 7a fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0118931:	e8 6f bf fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118936:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0118939:	e8 6c 59 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011893e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0118941:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0118945:	7f 17                	jg     f011895e <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0118947:	83 ec 04             	sub    $0x4,%esp
f011894a:	68 08 c8 12 f0       	push   $0xf012c808
f011894f:	68 ee 02 00 00       	push   $0x2ee
f0118954:	68 73 c7 12 f0       	push   $0xf012c773
f0118959:	e8 db 79 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f011895e:	a1 60 50 69 f0       	mov    0xf0695060,%eax
f0118963:	83 ec 0c             	sub    $0xc,%esp
f0118966:	50                   	push   %eax
f0118967:	e8 dd 0a ff ff       	call   f0109449 <kfree>
f011896c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f011896f:	a1 68 50 69 f0       	mov    0xf0695068,%eax
f0118974:	83 ec 0c             	sub    $0xc,%esp
f0118977:	50                   	push   %eax
f0118978:	e8 cc 0a ff ff       	call   f0109449 <kfree>
f011897d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0118980:	a1 6c 50 69 f0       	mov    0xf069506c,%eax
f0118985:	83 ec 0c             	sub    $0xc,%esp
f0118988:	50                   	push   %eax
f0118989:	e8 bb 0a ff ff       	call   f0109449 <kfree>
f011898e:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0118991:	a1 74 50 69 f0       	mov    0xf0695074,%eax
f0118996:	83 ec 0c             	sub    $0xc,%esp
f0118999:	50                   	push   %eax
f011899a:	e8 aa 0a ff ff       	call   f0109449 <kfree>
f011899f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f01189a2:	a1 88 50 69 f0       	mov    0xf0695088,%eax
f01189a7:	83 ec 0c             	sub    $0xc,%esp
f01189aa:	50                   	push   %eax
f01189ab:	e8 99 0a ff ff       	call   f0109449 <kfree>
f01189b0:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f01189b3:	a1 90 50 69 f0       	mov    0xf0695090,%eax
f01189b8:	83 ec 0c             	sub    $0xc,%esp
f01189bb:	50                   	push   %eax
f01189bc:	e8 88 0a ff ff       	call   f0109449 <kfree>
f01189c1:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f01189c4:	a1 8c 50 69 f0       	mov    0xf069508c,%eax
f01189c9:	83 ec 0c             	sub    $0xc,%esp
f01189cc:	50                   	push   %eax
f01189cd:	e8 77 0a ff ff       	call   f0109449 <kfree>
f01189d2:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f01189d5:	a1 b0 50 69 f0       	mov    0xf06950b0,%eax
f01189da:	83 ec 0c             	sub    $0xc,%esp
f01189dd:	50                   	push   %eax
f01189de:	e8 66 0a ff ff       	call   f0109449 <kfree>
f01189e3:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f01189e6:	a1 c4 50 69 f0       	mov    0xf06950c4,%eax
f01189eb:	83 ec 0c             	sub    $0xc,%esp
f01189ee:	50                   	push   %eax
f01189ef:	e8 55 0a ff ff       	call   f0109449 <kfree>
f01189f4:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f01189f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01189fa:	83 e8 02             	sub    $0x2,%eax
f01189fd:	8b 04 85 60 50 69 f0 	mov    -0xf96afa0(,%eax,4),%eax
f0118a04:	83 ec 0c             	sub    $0xc,%esp
f0118a07:	50                   	push   %eax
f0118a08:	e8 3c 0a ff ff       	call   f0109449 <kfree>
f0118a0d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0118a10:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118a13:	83 e8 03             	sub    $0x3,%eax
f0118a16:	8b 04 85 60 50 69 f0 	mov    -0xf96afa0(,%eax,4),%eax
f0118a1d:	83 ec 0c             	sub    $0xc,%esp
f0118a20:	50                   	push   %eax
f0118a21:	e8 23 0a ff ff       	call   f0109449 <kfree>
f0118a26:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118a29:	e8 77 be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a2e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a31:	74 17                	je     f0118a4a <test_fastfirstfit+0x2a1>
f0118a33:	83 ec 04             	sub    $0x4,%esp
f0118a36:	68 8c c7 12 f0       	push   $0xf012c78c
f0118a3b:	68 fb 02 00 00       	push   $0x2fb
f0118a40:	68 73 c7 12 f0       	push   $0xf012c773
f0118a45:	e8 ef 78 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0118a4a:	e8 5b 58 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118a4f:	89 c2                	mov    %eax,%edx
f0118a51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a54:	89 d1                	mov    %edx,%ecx
f0118a56:	29 c1                	sub    %eax,%ecx
f0118a58:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118a5b:	89 d0                	mov    %edx,%eax
f0118a5d:	c1 e0 02             	shl    $0x2,%eax
f0118a60:	01 d0                	add    %edx,%eax
f0118a62:	01 c0                	add    %eax,%eax
f0118a64:	01 d0                	add    %edx,%eax
f0118a66:	c1 e8 0c             	shr    $0xc,%eax
f0118a69:	39 c1                	cmp    %eax,%ecx
f0118a6b:	74 17                	je     f0118a84 <test_fastfirstfit+0x2db>
f0118a6d:	83 ec 04             	sub    $0x4,%esp
f0118a70:	68 44 c8 12 f0       	push   $0xf012c844
f0118a75:	68 fc 02 00 00       	push   $0x2fc
f0118a7a:	68 73 c7 12 f0       	push   $0xf012c773
f0118a7f:	e8 b5 78 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0118a84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118a87:	01 c0                	add    %eax,%eax
f0118a89:	89 c2                	mov    %eax,%edx
f0118a8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118a8e:	d1 e8                	shr    %eax
f0118a90:	01 d0                	add    %edx,%eax
f0118a92:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118a95:	e8 0b be fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118a9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118a9d:	e8 08 58 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118aa2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118aa5:	83 ec 0c             	sub    $0xc,%esp
f0118aa8:	ff 75 dc             	pushl  -0x24(%ebp)
f0118aab:	e8 39 07 ff ff       	call   f01091e9 <kmalloc>
f0118ab0:	83 c4 10             	add    $0x10,%esp
f0118ab3:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f0118ab6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118ab9:	89 d0                	mov    %edx,%eax
f0118abb:	c1 e0 02             	shl    $0x2,%eax
f0118abe:	01 d0                	add    %edx,%eax
f0118ac0:	01 c0                	add    %eax,%eax
f0118ac2:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118ac8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118acb:	39 c2                	cmp    %eax,%edx
f0118acd:	74 17                	je     f0118ae6 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f0118acf:	83 ec 04             	sub    $0x4,%esp
f0118ad2:	68 84 c8 12 f0       	push   $0xf012c884
f0118ad7:	68 07 03 00 00       	push   $0x307
f0118adc:	68 73 c7 12 f0       	push   $0xf012c773
f0118ae1:	e8 53 78 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118ae6:	e8 ba bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118aeb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118aee:	74 17                	je     f0118b07 <test_fastfirstfit+0x35e>
f0118af0:	83 ec 04             	sub    $0x4,%esp
f0118af3:	68 8c c7 12 f0       	push   $0xf012c78c
f0118af8:	68 08 03 00 00       	push   $0x308
f0118afd:	68 73 c7 12 f0       	push   $0xf012c773
f0118b02:	e8 32 78 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118b07:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118b0a:	e8 9b 57 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118b0f:	29 c3                	sub    %eax,%ebx
f0118b11:	89 da                	mov    %ebx,%edx
f0118b13:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118b16:	c1 e8 0c             	shr    $0xc,%eax
f0118b19:	39 c2                	cmp    %eax,%edx
f0118b1b:	73 17                	jae    f0118b34 <test_fastfirstfit+0x38b>
f0118b1d:	83 ec 04             	sub    $0x4,%esp
f0118b20:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118b25:	68 09 03 00 00       	push   $0x309
f0118b2a:	68 73 c7 12 f0       	push   $0xf012c773
f0118b2f:	e8 05 78 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f0118b34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118b37:	01 c0                	add    %eax,%eax
f0118b39:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118b3c:	e8 64 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b41:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118b44:	e8 61 57 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118b49:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118b4c:	83 ec 0c             	sub    $0xc,%esp
f0118b4f:	ff 75 dc             	pushl  -0x24(%ebp)
f0118b52:	e8 92 06 ff ff       	call   f01091e9 <kmalloc>
f0118b57:	83 c4 10             	add    $0x10,%esp
f0118b5a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0118b5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118b60:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0118b65:	01 c0                	add    %eax,%eax
f0118b67:	89 c2                	mov    %eax,%edx
f0118b69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118b6c:	39 c2                	cmp    %eax,%edx
f0118b6e:	74 17                	je     f0118b87 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0118b70:	83 ec 04             	sub    $0x4,%esp
f0118b73:	68 84 c8 12 f0       	push   $0xf012c884
f0118b78:	68 13 03 00 00       	push   $0x313
f0118b7d:	68 73 c7 12 f0       	push   $0xf012c773
f0118b82:	e8 b2 77 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118b87:	e8 19 bd fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118b8c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b8f:	74 17                	je     f0118ba8 <test_fastfirstfit+0x3ff>
f0118b91:	83 ec 04             	sub    $0x4,%esp
f0118b94:	68 8c c7 12 f0       	push   $0xf012c78c
f0118b99:	68 14 03 00 00       	push   $0x314
f0118b9e:	68 73 c7 12 f0       	push   $0xf012c773
f0118ba3:	e8 91 77 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118ba8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118bab:	e8 fa 56 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118bb0:	29 c3                	sub    %eax,%ebx
f0118bb2:	89 da                	mov    %ebx,%edx
f0118bb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118bb7:	c1 e8 0c             	shr    $0xc,%eax
f0118bba:	39 c2                	cmp    %eax,%edx
f0118bbc:	73 17                	jae    f0118bd5 <test_fastfirstfit+0x42c>
f0118bbe:	83 ec 04             	sub    $0x4,%esp
f0118bc1:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118bc6:	68 15 03 00 00       	push   $0x315
f0118bcb:	68 73 c7 12 f0       	push   $0xf012c773
f0118bd0:	e8 64 77 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0118bd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118bd8:	89 c2                	mov    %eax,%edx
f0118bda:	01 d2                	add    %edx,%edx
f0118bdc:	01 d0                	add    %edx,%eax
f0118bde:	d1 e8                	shr    %eax
f0118be0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118be3:	e8 bd bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118be8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118beb:	e8 ba 56 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118bf0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118bf3:	83 ec 0c             	sub    $0xc,%esp
f0118bf6:	ff 75 dc             	pushl  -0x24(%ebp)
f0118bf9:	e8 eb 05 ff ff       	call   f01091e9 <kmalloc>
f0118bfe:	83 c4 10             	add    $0x10,%esp
f0118c01:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f0118c04:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118c07:	83 e8 03             	sub    $0x3,%eax
f0118c0a:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118c0e:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118c14:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0118c17:	39 c2                	cmp    %eax,%edx
f0118c19:	74 17                	je     f0118c32 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0118c1b:	83 ec 04             	sub    $0x4,%esp
f0118c1e:	68 84 c8 12 f0       	push   $0xf012c884
f0118c23:	68 1f 03 00 00       	push   $0x31f
f0118c28:	68 73 c7 12 f0       	push   $0xf012c773
f0118c2d:	e8 07 77 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118c32:	e8 6e bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c37:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c3a:	74 17                	je     f0118c53 <test_fastfirstfit+0x4aa>
f0118c3c:	83 ec 04             	sub    $0x4,%esp
f0118c3f:	68 8c c7 12 f0       	push   $0xf012c78c
f0118c44:	68 20 03 00 00       	push   $0x320
f0118c49:	68 73 c7 12 f0       	push   $0xf012c773
f0118c4e:	e8 e6 76 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118c53:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118c56:	e8 4f 56 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118c5b:	29 c3                	sub    %eax,%ebx
f0118c5d:	89 da                	mov    %ebx,%edx
f0118c5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118c62:	c1 e8 0c             	shr    $0xc,%eax
f0118c65:	39 c2                	cmp    %eax,%edx
f0118c67:	73 17                	jae    f0118c80 <test_fastfirstfit+0x4d7>
f0118c69:	83 ec 04             	sub    $0x4,%esp
f0118c6c:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118c71:	68 21 03 00 00       	push   $0x321
f0118c76:	68 73 c7 12 f0       	push   $0xf012c773
f0118c7b:	e8 b9 76 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118c80:	e8 20 bc fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118c85:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118c88:	e8 1d 56 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118c8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118c90:	83 ec 0c             	sub    $0xc,%esp
f0118c93:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118c96:	e8 4e 05 ff ff       	call   f01091e9 <kmalloc>
f0118c9b:	83 c4 10             	add    $0x10,%esp
f0118c9e:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f0118ca1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118ca4:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118ca9:	74 17                	je     f0118cc2 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0118cab:	83 ec 04             	sub    $0x4,%esp
f0118cae:	68 84 c8 12 f0       	push   $0xf012c884
f0118cb3:	68 2a 03 00 00       	push   $0x32a
f0118cb8:	68 73 c7 12 f0       	push   $0xf012c773
f0118cbd:	e8 77 76 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118cc2:	e8 de bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118cc7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118cca:	74 17                	je     f0118ce3 <test_fastfirstfit+0x53a>
f0118ccc:	83 ec 04             	sub    $0x4,%esp
f0118ccf:	68 8c c7 12 f0       	push   $0xf012c78c
f0118cd4:	68 2b 03 00 00       	push   $0x32b
f0118cd9:	68 73 c7 12 f0       	push   $0xf012c773
f0118cde:	e8 56 76 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118ce3:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118ce6:	e8 bf 55 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118ceb:	29 c3                	sub    %eax,%ebx
f0118ced:	89 da                	mov    %ebx,%edx
f0118cef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118cf2:	c1 e8 0c             	shr    $0xc,%eax
f0118cf5:	39 c2                	cmp    %eax,%edx
f0118cf7:	73 17                	jae    f0118d10 <test_fastfirstfit+0x567>
f0118cf9:	83 ec 04             	sub    $0x4,%esp
f0118cfc:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118d01:	68 2c 03 00 00       	push   $0x32c
f0118d06:	68 73 c7 12 f0       	push   $0xf012c773
f0118d0b:	e8 29 76 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118d10:	e8 90 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d15:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118d18:	e8 8d 55 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118d1d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118d20:	83 ec 0c             	sub    $0xc,%esp
f0118d23:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118d26:	e8 be 04 ff ff       	call   f01091e9 <kmalloc>
f0118d2b:	83 c4 10             	add    $0x10,%esp
f0118d2e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0118d31:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118d34:	89 d0                	mov    %edx,%eax
f0118d36:	c1 e0 02             	shl    $0x2,%eax
f0118d39:	01 d0                	add    %edx,%eax
f0118d3b:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118d41:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118d44:	39 c2                	cmp    %eax,%edx
f0118d46:	74 17                	je     f0118d5f <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0118d48:	83 ec 04             	sub    $0x4,%esp
f0118d4b:	68 84 c8 12 f0       	push   $0xf012c884
f0118d50:	68 35 03 00 00       	push   $0x335
f0118d55:	68 73 c7 12 f0       	push   $0xf012c773
f0118d5a:	e8 da 75 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118d5f:	e8 41 bb fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118d64:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d67:	74 17                	je     f0118d80 <test_fastfirstfit+0x5d7>
f0118d69:	83 ec 04             	sub    $0x4,%esp
f0118d6c:	68 8c c7 12 f0       	push   $0xf012c78c
f0118d71:	68 36 03 00 00       	push   $0x336
f0118d76:	68 73 c7 12 f0       	push   $0xf012c773
f0118d7b:	e8 b9 75 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118d80:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118d83:	e8 22 55 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118d88:	29 c3                	sub    %eax,%ebx
f0118d8a:	89 da                	mov    %ebx,%edx
f0118d8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118d8f:	c1 e8 0c             	shr    $0xc,%eax
f0118d92:	39 c2                	cmp    %eax,%edx
f0118d94:	73 17                	jae    f0118dad <test_fastfirstfit+0x604>
f0118d96:	83 ec 04             	sub    $0x4,%esp
f0118d99:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118d9e:	68 37 03 00 00       	push   $0x337
f0118da3:	68 73 c7 12 f0       	push   $0xf012c773
f0118da8:	e8 8c 75 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118dad:	e8 f3 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118db5:	e8 f0 54 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118dba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118dbd:	83 ec 0c             	sub    $0xc,%esp
f0118dc0:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118dc3:	e8 21 04 ff ff       	call   f01091e9 <kmalloc>
f0118dc8:	83 c4 10             	add    $0x10,%esp
f0118dcb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0118dce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118dd1:	89 d0                	mov    %edx,%eax
f0118dd3:	c1 e0 02             	shl    $0x2,%eax
f0118dd6:	01 d0                	add    %edx,%eax
f0118dd8:	c1 e0 02             	shl    $0x2,%eax
f0118ddb:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118de1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118de4:	39 c2                	cmp    %eax,%edx
f0118de6:	74 17                	je     f0118dff <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0118de8:	83 ec 04             	sub    $0x4,%esp
f0118deb:	68 84 c8 12 f0       	push   $0xf012c884
f0118df0:	68 40 03 00 00       	push   $0x340
f0118df5:	68 73 c7 12 f0       	push   $0xf012c773
f0118dfa:	e8 3a 75 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118dff:	e8 a1 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118e04:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e07:	74 17                	je     f0118e20 <test_fastfirstfit+0x677>
f0118e09:	83 ec 04             	sub    $0x4,%esp
f0118e0c:	68 8c c7 12 f0       	push   $0xf012c78c
f0118e11:	68 41 03 00 00       	push   $0x341
f0118e16:	68 73 c7 12 f0       	push   $0xf012c773
f0118e1b:	e8 19 75 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118e20:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118e23:	e8 82 54 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118e28:	29 c3                	sub    %eax,%ebx
f0118e2a:	89 da                	mov    %ebx,%edx
f0118e2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118e2f:	c1 e8 0c             	shr    $0xc,%eax
f0118e32:	39 c2                	cmp    %eax,%edx
f0118e34:	73 17                	jae    f0118e4d <test_fastfirstfit+0x6a4>
f0118e36:	83 ec 04             	sub    $0x4,%esp
f0118e39:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118e3e:	68 42 03 00 00       	push   $0x342
f0118e43:	68 73 c7 12 f0       	push   $0xf012c773
f0118e48:	e8 ec 74 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e4d:	e8 53 ba fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118e52:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118e55:	e8 50 54 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118e5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118e5d:	83 ec 0c             	sub    $0xc,%esp
f0118e60:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118e63:	e8 81 03 ff ff       	call   f01091e9 <kmalloc>
f0118e68:	83 c4 10             	add    $0x10,%esp
f0118e6b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f0118e6e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118e71:	89 d0                	mov    %edx,%eax
f0118e73:	c1 e0 02             	shl    $0x2,%eax
f0118e76:	01 d0                	add    %edx,%eax
f0118e78:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118e7f:	01 d0                	add    %edx,%eax
f0118e81:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118e87:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118e8a:	39 c2                	cmp    %eax,%edx
f0118e8c:	74 17                	je     f0118ea5 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f0118e8e:	83 ec 04             	sub    $0x4,%esp
f0118e91:	68 84 c8 12 f0       	push   $0xf012c884
f0118e96:	68 4b 03 00 00       	push   $0x34b
f0118e9b:	68 73 c7 12 f0       	push   $0xf012c773
f0118ea0:	e8 94 74 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118ea5:	e8 fb b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118eaa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ead:	74 17                	je     f0118ec6 <test_fastfirstfit+0x71d>
f0118eaf:	83 ec 04             	sub    $0x4,%esp
f0118eb2:	68 8c c7 12 f0       	push   $0xf012c78c
f0118eb7:	68 4c 03 00 00       	push   $0x34c
f0118ebc:	68 73 c7 12 f0       	push   $0xf012c773
f0118ec1:	e8 73 74 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118ec6:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118ec9:	e8 dc 53 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118ece:	29 c3                	sub    %eax,%ebx
f0118ed0:	89 da                	mov    %ebx,%edx
f0118ed2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ed5:	c1 e8 0c             	shr    $0xc,%eax
f0118ed8:	39 c2                	cmp    %eax,%edx
f0118eda:	73 17                	jae    f0118ef3 <test_fastfirstfit+0x74a>
f0118edc:	83 ec 04             	sub    $0x4,%esp
f0118edf:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118ee4:	68 4d 03 00 00       	push   $0x34d
f0118ee9:	68 73 c7 12 f0       	push   $0xf012c773
f0118eee:	e8 46 74 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118ef3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118ef6:	d1 e8                	shr    %eax
f0118ef8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118efb:	e8 a5 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118f00:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118f03:	e8 a2 53 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118f08:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118f0b:	83 ec 0c             	sub    $0xc,%esp
f0118f0e:	ff 75 dc             	pushl  -0x24(%ebp)
f0118f11:	e8 d3 02 ff ff       	call   f01091e9 <kmalloc>
f0118f16:	83 c4 10             	add    $0x10,%esp
f0118f19:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f0118f1c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118f1f:	89 d0                	mov    %edx,%eax
f0118f21:	c1 e0 02             	shl    $0x2,%eax
f0118f24:	01 d0                	add    %edx,%eax
f0118f26:	01 c0                	add    %eax,%eax
f0118f28:	89 c1                	mov    %eax,%ecx
f0118f2a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118f2d:	89 d0                	mov    %edx,%eax
f0118f2f:	c1 e0 02             	shl    $0x2,%eax
f0118f32:	01 d0                	add    %edx,%eax
f0118f34:	d1 e8                	shr    %eax
f0118f36:	01 c8                	add    %ecx,%eax
f0118f38:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118f3e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118f41:	39 c2                	cmp    %eax,%edx
f0118f43:	74 17                	je     f0118f5c <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0118f45:	83 ec 04             	sub    $0x4,%esp
f0118f48:	68 84 c8 12 f0       	push   $0xf012c884
f0118f4d:	68 57 03 00 00       	push   $0x357
f0118f52:	68 73 c7 12 f0       	push   $0xf012c773
f0118f57:	e8 dd 73 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118f5c:	e8 44 b9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118f61:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f64:	74 17                	je     f0118f7d <test_fastfirstfit+0x7d4>
f0118f66:	83 ec 04             	sub    $0x4,%esp
f0118f69:	68 8c c7 12 f0       	push   $0xf012c78c
f0118f6e:	68 58 03 00 00       	push   $0x358
f0118f73:	68 73 c7 12 f0       	push   $0xf012c773
f0118f78:	e8 bc 73 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118f7d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118f80:	e8 25 53 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118f85:	29 c3                	sub    %eax,%ebx
f0118f87:	89 da                	mov    %ebx,%edx
f0118f89:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118f8c:	c1 e8 0c             	shr    $0xc,%eax
f0118f8f:	39 c2                	cmp    %eax,%edx
f0118f91:	73 17                	jae    f0118faa <test_fastfirstfit+0x801>
f0118f93:	83 ec 04             	sub    $0x4,%esp
f0118f96:	68 f4 c7 12 f0       	push   $0xf012c7f4
f0118f9b:	68 59 03 00 00       	push   $0x359
f0118fa0:	68 73 c7 12 f0       	push   $0xf012c773
f0118fa5:	e8 8f 73 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118faa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118fad:	d1 e8                	shr    %eax
f0118faf:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118fb2:	e8 ee b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0118fb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118fba:	e8 eb 52 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0118fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118fc2:	83 ec 0c             	sub    $0xc,%esp
f0118fc5:	ff 75 dc             	pushl  -0x24(%ebp)
f0118fc8:	e8 1c 02 ff ff       	call   f01091e9 <kmalloc>
f0118fcd:	83 c4 10             	add    $0x10,%esp
f0118fd0:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f0118fd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118fd6:	83 e8 03             	sub    $0x3,%eax
f0118fd9:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118fdd:	89 c2                	mov    %eax,%edx
f0118fdf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118fe2:	89 c1                	mov    %eax,%ecx
f0118fe4:	01 c9                	add    %ecx,%ecx
f0118fe6:	01 c8                	add    %ecx,%eax
f0118fe8:	d1 e8                	shr    %eax
f0118fea:	01 d0                	add    %edx,%eax
f0118fec:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118ff2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118ff5:	39 c2                	cmp    %eax,%edx
f0118ff7:	74 17                	je     f0119010 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f0118ff9:	83 ec 04             	sub    $0x4,%esp
f0118ffc:	68 84 c8 12 f0       	push   $0xf012c884
f0119001:	68 63 03 00 00       	push   $0x363
f0119006:	68 73 c7 12 f0       	push   $0xf012c773
f011900b:	e8 29 73 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119010:	e8 90 b8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119015:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119018:	74 17                	je     f0119031 <test_fastfirstfit+0x888>
f011901a:	83 ec 04             	sub    $0x4,%esp
f011901d:	68 8c c7 12 f0       	push   $0xf012c78c
f0119022:	68 64 03 00 00       	push   $0x364
f0119027:	68 73 c7 12 f0       	push   $0xf012c773
f011902c:	e8 08 73 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119031:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119034:	e8 71 52 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119039:	29 c3                	sub    %eax,%ebx
f011903b:	89 da                	mov    %ebx,%edx
f011903d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119040:	c1 e8 0c             	shr    $0xc,%eax
f0119043:	39 c2                	cmp    %eax,%edx
f0119045:	73 17                	jae    f011905e <test_fastfirstfit+0x8b5>
f0119047:	83 ec 04             	sub    $0x4,%esp
f011904a:	68 f4 c7 12 f0       	push   $0xf012c7f4
f011904f:	68 65 03 00 00       	push   $0x365
f0119054:	68 73 c7 12 f0       	push   $0xf012c773
f0119059:	e8 db 72 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f011905e:	83 ec 0c             	sub    $0xc,%esp
f0119061:	68 a4 c8 12 f0       	push   $0xf012c8a4
f0119066:	e8 20 7f fe ff       	call   f0100f8b <cprintf>
f011906b:	83 c4 10             	add    $0x10,%esp
	return 1;
f011906e:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119073:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0119076:	c9                   	leave  
f0119077:	c3                   	ret    

f0119078 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0119078:	55                   	push   %ebp
f0119079:	89 e5                	mov    %esp,%ebp
f011907b:	57                   	push   %edi
f011907c:	53                   	push   %ebx
f011907d:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119083:	83 ec 0c             	sub    $0xc,%esp
f0119086:	68 28 a8 12 f0       	push   $0xf012a828
f011908b:	e8 fb 7e fe ff       	call   f0100f8b <cprintf>
f0119090:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119093:	83 ec 0c             	sub    $0xc,%esp
f0119096:	68 58 a8 12 f0       	push   $0xf012a858
f011909b:	e8 eb 7e fe ff       	call   f0100f8b <cprintf>
f01190a0:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01190a3:	83 ec 0c             	sub    $0xc,%esp
f01190a6:	68 28 a8 12 f0       	push   $0xf012a828
f01190ab:	e8 db 7e fe ff       	call   f0100f8b <cprintf>
f01190b0:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f01190b3:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f01190b7:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f01190bb:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f01190c1:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f01190c7:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f01190ce:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f01190d5:	e8 d0 51 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01190da:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f01190dd:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f01190e3:	b9 14 00 00 00       	mov    $0x14,%ecx
f01190e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01190ed:	89 d7                	mov    %edx,%edi
f01190ef:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f01190f1:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f01190f7:	b9 14 00 00 00       	mov    $0x14,%ecx
f01190fc:	b8 00 00 00 00       	mov    $0x0,%eax
f0119101:	89 d7                	mov    %edx,%edi
f0119103:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f0119105:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011910c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f0119113:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011911a:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f0119120:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119125:	b8 00 00 00 00       	mov    $0x0,%eax
f011912a:	89 d7                	mov    %edx,%edi
f011912c:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f011912e:	83 ec 0c             	sub    $0xc,%esp
f0119131:	68 e8 c8 12 f0       	push   $0xf012c8e8
f0119136:	e8 50 7e fe ff       	call   f0100f8b <cprintf>
f011913b:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011913e:	e8 67 51 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119143:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119146:	e8 5a b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011914b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011914e:	83 ec 0c             	sub    $0xc,%esp
f0119151:	68 00 fc 1f 00       	push   $0x1ffc00
f0119156:	e8 8e 00 ff ff       	call   f01091e9 <kmalloc>
f011915b:	83 c4 10             	add    $0x10,%esp
f011915e:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119164:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011916a:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011916f:	74 17                	je     f0119188 <test_kfree_bestfirstfit+0x110>
f0119171:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119178:	83 ec 0c             	sub    $0xc,%esp
f011917b:	68 20 c9 12 f0       	push   $0xf012c920
f0119180:	e8 06 7e fe ff       	call   f0100f8b <cprintf>
f0119185:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119188:	e8 18 b7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011918d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119190:	74 17                	je     f01191a9 <test_kfree_bestfirstfit+0x131>
f0119192:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119199:	83 ec 0c             	sub    $0xc,%esp
f011919c:	68 74 c9 12 f0       	push   $0xf012c974
f01191a1:	e8 e5 7d fe ff       	call   f0100f8b <cprintf>
f01191a6:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01191a9:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01191ac:	e8 f9 50 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01191b1:	29 c3                	sub    %eax,%ebx
f01191b3:	89 d8                	mov    %ebx,%eax
f01191b5:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01191ba:	77 17                	ja     f01191d3 <test_kfree_bestfirstfit+0x15b>
f01191bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191c3:	83 ec 0c             	sub    $0xc,%esp
f01191c6:	68 e4 c9 12 f0       	push   $0xf012c9e4
f01191cb:	e8 bb 7d fe ff       	call   f0100f8b <cprintf>
f01191d0:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f01191d3:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f01191da:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f01191dd:	e8 c8 50 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01191e2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01191e5:	e8 bb b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01191ea:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01191ed:	83 ec 0c             	sub    $0xc,%esp
f01191f0:	68 00 fc 1f 00       	push   $0x1ffc00
f01191f5:	e8 ef ff fe ff       	call   f01091e9 <kmalloc>
f01191fa:	83 c4 10             	add    $0x10,%esp
f01191fd:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119203:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0119209:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011920e:	74 17                	je     f0119227 <test_kfree_bestfirstfit+0x1af>
f0119210:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119217:	83 ec 0c             	sub    $0xc,%esp
f011921a:	68 2c ca 12 f0       	push   $0xf012ca2c
f011921f:	e8 67 7d fe ff       	call   f0100f8b <cprintf>
f0119224:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119227:	e8 79 b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011922c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011922f:	74 17                	je     f0119248 <test_kfree_bestfirstfit+0x1d0>
f0119231:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119238:	83 ec 0c             	sub    $0xc,%esp
f011923b:	68 80 ca 12 f0       	push   $0xf012ca80
f0119240:	e8 46 7d fe ff       	call   f0100f8b <cprintf>
f0119245:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119248:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011924b:	e8 5a 50 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119250:	29 c3                	sub    %eax,%ebx
f0119252:	89 d8                	mov    %ebx,%eax
f0119254:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119259:	77 17                	ja     f0119272 <test_kfree_bestfirstfit+0x1fa>
f011925b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119262:	83 ec 0c             	sub    $0xc,%esp
f0119265:	68 f0 ca 12 f0       	push   $0xf012caf0
f011926a:	e8 1c 7d fe ff       	call   f0100f8b <cprintf>
f011926f:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f0119272:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f0119279:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011927c:	e8 29 50 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119281:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119284:	e8 1c b6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119289:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011928c:	83 ec 0c             	sub    $0xc,%esp
f011928f:	68 00 1c 00 00       	push   $0x1c00
f0119294:	e8 50 ff fe ff       	call   f01091e9 <kmalloc>
f0119299:	83 c4 10             	add    $0x10,%esp
f011929c:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01192a2:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01192a8:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01192ad:	74 17                	je     f01192c6 <test_kfree_bestfirstfit+0x24e>
f01192af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192b6:	83 ec 0c             	sub    $0xc,%esp
f01192b9:	68 38 cb 12 f0       	push   $0xf012cb38
f01192be:	e8 c8 7c fe ff       	call   f0100f8b <cprintf>
f01192c3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01192c6:	e8 da b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01192cb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01192ce:	74 17                	je     f01192e7 <test_kfree_bestfirstfit+0x26f>
f01192d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192d7:	83 ec 0c             	sub    $0xc,%esp
f01192da:	68 8c cb 12 f0       	push   $0xf012cb8c
f01192df:	e8 a7 7c fe ff       	call   f0100f8b <cprintf>
f01192e4:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01192e7:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01192ea:	e8 bb 4f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01192ef:	29 c3                	sub    %eax,%ebx
f01192f1:	89 d8                	mov    %ebx,%eax
f01192f3:	83 f8 01             	cmp    $0x1,%eax
f01192f6:	77 17                	ja     f011930f <test_kfree_bestfirstfit+0x297>
f01192f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192ff:	83 ec 0c             	sub    $0xc,%esp
f0119302:	68 fc cb 12 f0       	push   $0xf012cbfc
f0119307:	e8 7f 7c fe ff       	call   f0100f8b <cprintf>
f011930c:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f011930f:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f0119316:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f0119319:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011931f:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f0119322:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119329:	eb 0e                	jmp    f0119339 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f011932b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011932e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119331:	01 d0                	add    %edx,%eax
f0119333:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f0119336:	ff 45 f4             	incl   -0xc(%ebp)
f0119339:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011933f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119342:	7f e7                	jg     f011932b <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f0119344:	e8 61 4f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119349:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011934c:	e8 54 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119351:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0119354:	83 ec 0c             	sub    $0xc,%esp
f0119357:	68 00 fc 2f 00       	push   $0x2ffc00
f011935c:	e8 88 fe fe ff       	call   f01091e9 <kmalloc>
f0119361:	83 c4 10             	add    $0x10,%esp
f0119364:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011936a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119370:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119375:	74 17                	je     f011938e <test_kfree_bestfirstfit+0x316>
f0119377:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011937e:	83 ec 0c             	sub    $0xc,%esp
f0119381:	68 44 cc 12 f0       	push   $0xf012cc44
f0119386:	e8 00 7c fe ff       	call   f0100f8b <cprintf>
f011938b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011938e:	e8 12 b5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119393:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119396:	74 17                	je     f01193af <test_kfree_bestfirstfit+0x337>
f0119398:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011939f:	83 ec 0c             	sub    $0xc,%esp
f01193a2:	68 98 cc 12 f0       	push   $0xf012cc98
f01193a7:	e8 df 7b fe ff       	call   f0100f8b <cprintf>
f01193ac:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01193af:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01193b2:	e8 f3 4e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01193b7:	29 c3                	sub    %eax,%ebx
f01193b9:	89 d8                	mov    %ebx,%eax
f01193bb:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01193c0:	77 17                	ja     f01193d9 <test_kfree_bestfirstfit+0x361>
f01193c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193c9:	83 ec 0c             	sub    $0xc,%esp
f01193cc:	68 08 cd 12 f0       	push   $0xf012cd08
f01193d1:	e8 b5 7b fe ff       	call   f0100f8b <cprintf>
f01193d6:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f01193d9:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f01193e0:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f01193e3:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01193e9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f01193ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01193f3:	eb 0e                	jmp    f0119403 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f01193f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01193f8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01193fb:	01 d0                	add    %edx,%eax
f01193fd:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f0119400:	ff 45 f4             	incl   -0xc(%ebp)
f0119403:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119409:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011940c:	7f e7                	jg     f01193f5 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f011940e:	e8 97 4e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119413:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119416:	e8 8a b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011941b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011941e:	83 ec 0c             	sub    $0xc,%esp
f0119421:	68 00 fc 5f 00       	push   $0x5ffc00
f0119426:	e8 be fd fe ff       	call   f01091e9 <kmalloc>
f011942b:	83 c4 10             	add    $0x10,%esp
f011942e:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119434:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011943a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011943f:	74 17                	je     f0119458 <test_kfree_bestfirstfit+0x3e0>
f0119441:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119448:	83 ec 0c             	sub    $0xc,%esp
f011944b:	68 50 cd 12 f0       	push   $0xf012cd50
f0119450:	e8 36 7b fe ff       	call   f0100f8b <cprintf>
f0119455:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119458:	e8 48 b4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011945d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119460:	74 17                	je     f0119479 <test_kfree_bestfirstfit+0x401>
f0119462:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119469:	83 ec 0c             	sub    $0xc,%esp
f011946c:	68 a4 cd 12 f0       	push   $0xf012cda4
f0119471:	e8 15 7b fe ff       	call   f0100f8b <cprintf>
f0119476:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119479:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011947c:	e8 29 4e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119481:	29 c3                	sub    %eax,%ebx
f0119483:	89 d8                	mov    %ebx,%eax
f0119485:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011948a:	77 17                	ja     f01194a3 <test_kfree_bestfirstfit+0x42b>
f011948c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119493:	83 ec 0c             	sub    $0xc,%esp
f0119496:	68 14 ce 12 f0       	push   $0xf012ce14
f011949b:	e8 eb 7a fe ff       	call   f0100f8b <cprintf>
f01194a0:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f01194a3:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f01194aa:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f01194ad:	e8 f8 4d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01194b2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01194b5:	e8 eb b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194ba:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f01194bd:	83 ec 0c             	sub    $0xc,%esp
f01194c0:	68 00 38 00 00       	push   $0x3800
f01194c5:	e8 1f fd fe ff       	call   f01091e9 <kmalloc>
f01194ca:	83 c4 10             	add    $0x10,%esp
f01194cd:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01194d3:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f01194d9:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f01194de:	74 17                	je     f01194f7 <test_kfree_bestfirstfit+0x47f>
f01194e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194e7:	83 ec 0c             	sub    $0xc,%esp
f01194ea:	68 5c ce 12 f0       	push   $0xf012ce5c
f01194ef:	e8 97 7a fe ff       	call   f0100f8b <cprintf>
f01194f4:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01194f7:	e8 a9 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01194fc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01194ff:	74 17                	je     f0119518 <test_kfree_bestfirstfit+0x4a0>
f0119501:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119508:	83 ec 0c             	sub    $0xc,%esp
f011950b:	68 b0 ce 12 f0       	push   $0xf012ceb0
f0119510:	e8 76 7a fe ff       	call   f0100f8b <cprintf>
f0119515:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119518:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011951b:	e8 8a 4d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119520:	29 c3                	sub    %eax,%ebx
f0119522:	89 d8                	mov    %ebx,%eax
f0119524:	83 f8 03             	cmp    $0x3,%eax
f0119527:	77 17                	ja     f0119540 <test_kfree_bestfirstfit+0x4c8>
f0119529:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119530:	83 ec 0c             	sub    $0xc,%esp
f0119533:	68 20 cf 12 f0       	push   $0xf012cf20
f0119538:	e8 4e 7a fe ff       	call   f0100f8b <cprintf>
f011953d:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0119540:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0119547:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011954d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0119550:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119557:	eb 0e                	jmp    f0119567 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0119559:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011955c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011955f:	01 d0                	add    %edx,%eax
f0119561:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0119564:	ff 45 f4             	incl   -0xc(%ebp)
f0119567:	8b 45 80             	mov    -0x80(%ebp),%eax
f011956a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011956d:	7f ea                	jg     f0119559 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f011956f:	e8 36 4d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119574:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119577:	e8 29 b3 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011957c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f011957f:	83 ec 0c             	sub    $0xc,%esp
f0119582:	68 00 08 00 00       	push   $0x800
f0119587:	e8 5d fc fe ff       	call   f01091e9 <kmalloc>
f011958c:	83 c4 10             	add    $0x10,%esp
f011958f:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119595:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011959b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01195a0:	76 28                	jbe    f01195ca <test_kfree_bestfirstfit+0x552>
f01195a2:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f01195a8:	83 ec 0c             	sub    $0xc,%esp
f01195ab:	6a 00                	push   $0x0
f01195ad:	e8 04 fb fe ff       	call   f01090b6 <sbrk>
f01195b2:	83 c4 10             	add    $0x10,%esp
f01195b5:	39 c3                	cmp    %eax,%ebx
f01195b7:	73 11                	jae    f01195ca <test_kfree_bestfirstfit+0x552>
f01195b9:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01195bf:	89 c2                	mov    %eax,%edx
f01195c1:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f01195c6:	39 c2                	cmp    %eax,%edx
f01195c8:	72 17                	jb     f01195e1 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01195ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195d1:	83 ec 0c             	sub    $0xc,%esp
f01195d4:	68 68 cf 12 f0       	push   $0xf012cf68
f01195d9:	e8 ad 79 fe ff       	call   f0100f8b <cprintf>
f01195de:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01195e1:	e8 bf b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01195e6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01195e9:	74 17                	je     f0119602 <test_kfree_bestfirstfit+0x58a>
f01195eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195f2:	83 ec 0c             	sub    $0xc,%esp
f01195f5:	68 f4 cf 12 f0       	push   $0xf012cff4
f01195fa:	e8 8c 79 fe ff       	call   f0100f8b <cprintf>
f01195ff:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0119602:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0119609:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011960c:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119612:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0119615:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011961c:	eb 0e                	jmp    f011962c <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f011961e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119621:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119624:	01 d0                	add    %edx,%eax
f0119626:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0119629:	ff 45 f4             	incl   -0xc(%ebp)
f011962c:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0119632:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119635:	7f e7                	jg     f011961e <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0119637:	e8 69 b2 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011963c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011963f:	83 ec 0c             	sub    $0xc,%esp
f0119642:	68 00 08 00 00       	push   $0x800
f0119647:	e8 9d fb fe ff       	call   f01091e9 <kmalloc>
f011964c:	83 c4 10             	add    $0x10,%esp
f011964f:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119655:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011965b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119660:	76 28                	jbe    f011968a <test_kfree_bestfirstfit+0x612>
f0119662:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0119668:	83 ec 0c             	sub    $0xc,%esp
f011966b:	6a 00                	push   $0x0
f011966d:	e8 44 fa fe ff       	call   f01090b6 <sbrk>
f0119672:	83 c4 10             	add    $0x10,%esp
f0119675:	39 c3                	cmp    %eax,%ebx
f0119677:	73 11                	jae    f011968a <test_kfree_bestfirstfit+0x612>
f0119679:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011967f:	89 c2                	mov    %eax,%edx
f0119681:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f0119686:	39 c2                	cmp    %eax,%edx
f0119688:	72 17                	jb     f01196a1 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011968a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119691:	83 ec 0c             	sub    $0xc,%esp
f0119694:	68 64 d0 12 f0       	push   $0xf012d064
f0119699:	e8 ed 78 fe ff       	call   f0100f8b <cprintf>
f011969e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01196a1:	e8 ff b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01196a6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01196a9:	74 17                	je     f01196c2 <test_kfree_bestfirstfit+0x64a>
f01196ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01196b2:	83 ec 0c             	sub    $0xc,%esp
f01196b5:	68 f0 d0 12 f0       	push   $0xf012d0f0
f01196ba:	e8 cc 78 fe ff       	call   f0100f8b <cprintf>
f01196bf:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f01196c2:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f01196c9:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f01196cc:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f01196d2:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f01196d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01196dc:	eb 0e                	jmp    f01196ec <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f01196de:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01196e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01196e4:	01 d0                	add    %edx,%eax
f01196e6:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f01196e9:	ff 45 f4             	incl   -0xc(%ebp)
f01196ec:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01196f2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01196f5:	7f e7                	jg     f01196de <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f01196f7:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01196fa:	e8 ab 4b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01196ff:	29 c3                	sub    %eax,%ebx
f0119701:	89 d8                	mov    %ebx,%eax
f0119703:	83 f8 01             	cmp    $0x1,%eax
f0119706:	74 17                	je     f011971f <test_kfree_bestfirstfit+0x6a7>
f0119708:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011970f:	83 ec 0c             	sub    $0xc,%esp
f0119712:	68 60 d1 12 f0       	push   $0xf012d160
f0119717:	e8 6f 78 fe ff       	call   f0100f8b <cprintf>
f011971c:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f011971f:	83 ec 0c             	sub    $0xc,%esp
f0119722:	68 84 d1 12 f0       	push   $0xf012d184
f0119727:	e8 5f 78 fe ff       	call   f0100f8b <cprintf>
f011972c:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011972f:	e8 76 4b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119734:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0119737:	e8 69 b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011973c:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011973f:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0119745:	83 ec 0c             	sub    $0xc,%esp
f0119748:	50                   	push   %eax
f0119749:	e8 fb fc fe ff       	call   f0109449 <kfree>
f011974e:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119751:	e8 4f b1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119756:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119759:	74 17                	je     f0119772 <test_kfree_bestfirstfit+0x6fa>
f011975b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119762:	83 ec 0c             	sub    $0xc,%esp
f0119765:	68 b4 d1 12 f0       	push   $0xf012d1b4
f011976a:	e8 1c 78 fe ff       	call   f0100f8b <cprintf>
f011976f:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119772:	e8 33 4b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119777:	89 c2                	mov    %eax,%edx
f0119779:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011977c:	29 c2                	sub    %eax,%edx
f011977e:	89 d0                	mov    %edx,%eax
f0119780:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119785:	77 17                	ja     f011979e <test_kfree_bestfirstfit+0x726>
f0119787:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011978e:	83 ec 0c             	sub    $0xc,%esp
f0119791:	68 24 d2 12 f0       	push   $0xf012d224
f0119796:	e8 f0 77 fe ff       	call   f0100f8b <cprintf>
f011979b:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f011979e:	e8 07 4b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01197a3:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01197a6:	e8 fa b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01197ab:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f01197ae:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01197b4:	83 ec 0c             	sub    $0xc,%esp
f01197b7:	50                   	push   %eax
f01197b8:	e8 8c fc fe ff       	call   f0109449 <kfree>
f01197bd:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01197c0:	e8 e0 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f01197c5:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01197c8:	74 17                	je     f01197e1 <test_kfree_bestfirstfit+0x769>
f01197ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197d1:	83 ec 0c             	sub    $0xc,%esp
f01197d4:	68 60 d2 12 f0       	push   $0xf012d260
f01197d9:	e8 ad 77 fe ff       	call   f0100f8b <cprintf>
f01197de:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f01197e1:	e8 c4 4a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01197e6:	89 c2                	mov    %eax,%edx
f01197e8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01197eb:	39 c2                	cmp    %eax,%edx
f01197ed:	74 17                	je     f0119806 <test_kfree_bestfirstfit+0x78e>
f01197ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197f6:	83 ec 0c             	sub    $0xc,%esp
f01197f9:	68 d0 d2 12 f0       	push   $0xf012d2d0
f01197fe:	e8 88 77 fe ff       	call   f0100f8b <cprintf>
f0119803:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119806:	e8 9f 4a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011980b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011980e:	e8 92 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119813:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0119816:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011981c:	83 ec 0c             	sub    $0xc,%esp
f011981f:	50                   	push   %eax
f0119820:	e8 24 fc fe ff       	call   f0109449 <kfree>
f0119825:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119828:	e8 78 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011982d:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0119830:	74 17                	je     f0119849 <test_kfree_bestfirstfit+0x7d1>
f0119832:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119839:	83 ec 0c             	sub    $0xc,%esp
f011983c:	68 30 d3 12 f0       	push   $0xf012d330
f0119841:	e8 45 77 fe ff       	call   f0100f8b <cprintf>
f0119846:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119849:	e8 5c 4a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011984e:	89 c2                	mov    %eax,%edx
f0119850:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119853:	29 c2                	sub    %eax,%edx
f0119855:	89 d0                	mov    %edx,%eax
f0119857:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011985c:	77 17                	ja     f0119875 <test_kfree_bestfirstfit+0x7fd>
f011985e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119865:	83 ec 0c             	sub    $0xc,%esp
f0119868:	68 a0 d3 12 f0       	push   $0xf012d3a0
f011986d:	e8 19 77 fe ff       	call   f0100f8b <cprintf>
f0119872:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0119875:	e8 30 4a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011987a:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011987d:	e8 23 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119882:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0119885:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011988b:	83 ec 0c             	sub    $0xc,%esp
f011988e:	50                   	push   %eax
f011988f:	e8 b5 fb fe ff       	call   f0109449 <kfree>
f0119894:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119897:	e8 09 b0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011989c:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011989f:	74 17                	je     f01198b8 <test_kfree_bestfirstfit+0x840>
f01198a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198a8:	83 ec 0c             	sub    $0xc,%esp
f01198ab:	68 dc d3 12 f0       	push   $0xf012d3dc
f01198b0:	e8 d6 76 fe ff       	call   f0100f8b <cprintf>
f01198b5:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f01198b8:	e8 ed 49 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f01198bd:	89 c2                	mov    %eax,%edx
f01198bf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01198c2:	29 c2                	sub    %eax,%edx
f01198c4:	89 d0                	mov    %edx,%eax
f01198c6:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f01198cb:	77 17                	ja     f01198e4 <test_kfree_bestfirstfit+0x86c>
f01198cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198d4:	83 ec 0c             	sub    $0xc,%esp
f01198d7:	68 4c d4 12 f0       	push   $0xf012d44c
f01198dc:	e8 aa 76 fe ff       	call   f0100f8b <cprintf>
f01198e1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01198e4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01198e8:	74 04                	je     f01198ee <test_kfree_bestfirstfit+0x876>
f01198ea:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f01198ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f01198f5:	83 ec 0c             	sub    $0xc,%esp
f01198f8:	68 88 d4 12 f0       	push   $0xf012d488
f01198fd:	e8 89 76 fe ff       	call   f0100f8b <cprintf>
f0119902:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0119905:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011990b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011990e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119915:	eb 1e                	jmp    f0119935 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f0119917:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011991d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119920:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119923:	01 c8                	add    %ecx,%eax
f0119925:	8a 00                	mov    (%eax),%al
f0119927:	0f be c0             	movsbl %al,%eax
f011992a:	01 d0                	add    %edx,%eax
f011992c:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0119932:	ff 45 f4             	incl   -0xc(%ebp)
f0119935:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011993b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011993e:	7f d7                	jg     f0119917 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0119940:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0119946:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011994c:	89 c1                	mov    %eax,%ecx
f011994e:	01 c9                	add    %ecx,%ecx
f0119950:	01 c8                	add    %ecx,%eax
f0119952:	39 c2                	cmp    %eax,%edx
f0119954:	74 17                	je     f011996d <test_kfree_bestfirstfit+0x8f5>
f0119956:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011995d:	83 ec 0c             	sub    $0xc,%esp
f0119960:	68 d0 d4 12 f0       	push   $0xf012d4d0
f0119965:	e8 21 76 fe ff       	call   f0100f8b <cprintf>
f011996a:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011996d:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119973:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f0119976:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011997d:	eb 1e                	jmp    f011999d <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f011997f:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f0119985:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119988:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011998b:	01 c8                	add    %ecx,%eax
f011998d:	8a 00                	mov    (%eax),%al
f011998f:	0f be c0             	movsbl %al,%eax
f0119992:	01 d0                	add    %edx,%eax
f0119994:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011999a:	ff 45 f4             	incl   -0xc(%ebp)
f011999d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01199a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01199a6:	7f d7                	jg     f011997f <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f01199a8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01199ae:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f01199b4:	c1 e2 02             	shl    $0x2,%edx
f01199b7:	39 d0                	cmp    %edx,%eax
f01199b9:	74 17                	je     f01199d2 <test_kfree_bestfirstfit+0x95a>
f01199bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01199c2:	83 ec 0c             	sub    $0xc,%esp
f01199c5:	68 08 d5 12 f0       	push   $0xf012d508
f01199ca:	e8 bc 75 fe ff       	call   f0100f8b <cprintf>
f01199cf:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f01199d2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01199d8:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f01199db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01199e2:	eb 1e                	jmp    f0119a02 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f01199e4:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f01199ea:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01199ed:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199f0:	01 c8                	add    %ecx,%eax
f01199f2:	8a 00                	mov    (%eax),%al
f01199f4:	0f be c0             	movsbl %al,%eax
f01199f7:	01 d0                	add    %edx,%eax
f01199f9:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f01199ff:	ff 45 f4             	incl   -0xc(%ebp)
f0119a02:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119a08:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a0b:	7f d7                	jg     f01199e4 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f0119a0d:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f0119a13:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0119a19:	89 d0                	mov    %edx,%eax
f0119a1b:	c1 e0 02             	shl    $0x2,%eax
f0119a1e:	01 d0                	add    %edx,%eax
f0119a20:	39 c1                	cmp    %eax,%ecx
f0119a22:	74 17                	je     f0119a3b <test_kfree_bestfirstfit+0x9c3>
f0119a24:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a2b:	83 ec 0c             	sub    $0xc,%esp
f0119a2e:	68 40 d5 12 f0       	push   $0xf012d540
f0119a33:	e8 53 75 fe ff       	call   f0100f8b <cprintf>
f0119a38:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f0119a3b:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119a41:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f0119a44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a4b:	eb 1e                	jmp    f0119a6b <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f0119a4d:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f0119a53:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119a56:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a59:	01 c8                	add    %ecx,%eax
f0119a5b:	8a 00                	mov    (%eax),%al
f0119a5d:	0f be c0             	movsbl %al,%eax
f0119a60:	01 d0                	add    %edx,%eax
f0119a62:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f0119a68:	ff 45 f4             	incl   -0xc(%ebp)
f0119a6b:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119a6e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a71:	7f da                	jg     f0119a4d <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f0119a73:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f0119a79:	8b 55 80             	mov    -0x80(%ebp),%edx
f0119a7c:	89 d0                	mov    %edx,%eax
f0119a7e:	01 c0                	add    %eax,%eax
f0119a80:	01 d0                	add    %edx,%eax
f0119a82:	01 c0                	add    %eax,%eax
f0119a84:	01 d0                	add    %edx,%eax
f0119a86:	39 c1                	cmp    %eax,%ecx
f0119a88:	74 17                	je     f0119aa1 <test_kfree_bestfirstfit+0xa29>
f0119a8a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a91:	83 ec 0c             	sub    $0xc,%esp
f0119a94:	68 78 d5 12 f0       	push   $0xf012d578
f0119a99:	e8 ed 74 fe ff       	call   f0100f8b <cprintf>
f0119a9e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119aa1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119aa5:	74 04                	je     f0119aab <test_kfree_bestfirstfit+0xa33>
f0119aa7:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0119aab:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f0119ab2:	83 ec 0c             	sub    $0xc,%esp
f0119ab5:	68 b0 d5 12 f0       	push   $0xf012d5b0
f0119aba:	e8 cc 74 fe ff       	call   f0100f8b <cprintf>
f0119abf:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f0119ac2:	e8 e3 47 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119ac7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119aca:	e8 d6 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119acf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f0119ad2:	83 ec 0c             	sub    $0xc,%esp
f0119ad5:	68 00 04 00 00       	push   $0x400
f0119ada:	e8 0a f7 fe ff       	call   f01091e9 <kmalloc>
f0119adf:	83 c4 10             	add    $0x10,%esp
f0119ae2:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f0119ae8:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f0119aee:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119af4:	39 c2                	cmp    %eax,%edx
f0119af6:	74 17                	je     f0119b0f <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119af8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119aff:	83 ec 0c             	sub    $0xc,%esp
f0119b02:	68 d0 d5 12 f0       	push   $0xf012d5d0
f0119b07:	e8 7f 74 fe ff       	call   f0100f8b <cprintf>
f0119b0c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b0f:	e8 91 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b14:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119b17:	74 17                	je     f0119b30 <test_kfree_bestfirstfit+0xab8>
f0119b19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b20:	83 ec 0c             	sub    $0xc,%esp
f0119b23:	68 24 d6 12 f0       	push   $0xf012d624
f0119b28:	e8 5e 74 fe ff       	call   f0100f8b <cprintf>
f0119b2d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f0119b30:	e8 75 47 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119b35:	89 c2                	mov    %eax,%edx
f0119b37:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119b3a:	39 c2                	cmp    %eax,%edx
f0119b3c:	74 17                	je     f0119b55 <test_kfree_bestfirstfit+0xadd>
f0119b3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b45:	83 ec 0c             	sub    $0xc,%esp
f0119b48:	68 94 d6 12 f0       	push   $0xf012d694
f0119b4d:	e8 39 74 fe ff       	call   f0100f8b <cprintf>
f0119b52:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f0119b55:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f0119b5c:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0119b62:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f0119b65:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119b6c:	eb 0e                	jmp    f0119b7c <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f0119b6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119b71:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119b74:	01 d0                	add    %edx,%eax
f0119b76:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f0119b79:	ff 45 f4             	incl   -0xc(%ebp)
f0119b7c:	8b 45 88             	mov    -0x78(%ebp),%eax
f0119b7f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b82:	7f ea                	jg     f0119b6e <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f0119b84:	e8 21 47 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119b89:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119b8c:	e8 14 ad fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119b91:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f0119b94:	83 ec 0c             	sub    $0xc,%esp
f0119b97:	68 00 00 30 00       	push   $0x300000
f0119b9c:	e8 48 f6 fe ff       	call   f01091e9 <kmalloc>
f0119ba1:	83 c4 10             	add    $0x10,%esp
f0119ba4:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119baa:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119bb0:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119bb5:	74 17                	je     f0119bce <test_kfree_bestfirstfit+0xb56>
f0119bb7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bbe:	83 ec 0c             	sub    $0xc,%esp
f0119bc1:	68 10 d7 12 f0       	push   $0xf012d710
f0119bc6:	e8 c0 73 fe ff       	call   f0100f8b <cprintf>
f0119bcb:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119bce:	e8 d2 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119bd3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119bd6:	74 17                	je     f0119bef <test_kfree_bestfirstfit+0xb77>
f0119bd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bdf:	83 ec 0c             	sub    $0xc,%esp
f0119be2:	68 64 d7 12 f0       	push   $0xf012d764
f0119be7:	e8 9f 73 fe ff       	call   f0100f8b <cprintf>
f0119bec:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119bef:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119bf2:	e8 b3 46 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119bf7:	29 c3                	sub    %eax,%ebx
f0119bf9:	89 d8                	mov    %ebx,%eax
f0119bfb:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119c00:	77 17                	ja     f0119c19 <test_kfree_bestfirstfit+0xba1>
f0119c02:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c09:	83 ec 0c             	sub    $0xc,%esp
f0119c0c:	68 d4 d7 12 f0       	push   $0xf012d7d4
f0119c11:	e8 75 73 fe ff       	call   f0100f8b <cprintf>
f0119c16:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f0119c19:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f0119c20:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119c26:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f0119c29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119c30:	eb 0e                	jmp    f0119c40 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f0119c32:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c35:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119c38:	01 d0                	add    %edx,%eax
f0119c3a:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f0119c3d:	ff 45 f4             	incl   -0xc(%ebp)
f0119c40:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0119c43:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119c46:	7f ea                	jg     f0119c32 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f0119c48:	e8 5d 46 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119c4d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119c50:	e8 50 ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c55:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f0119c58:	83 ec 0c             	sub    $0xc,%esp
f0119c5b:	68 00 00 10 00       	push   $0x100000
f0119c60:	e8 84 f5 fe ff       	call   f01091e9 <kmalloc>
f0119c65:	83 c4 10             	add    $0x10,%esp
f0119c68:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119c6e:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119c74:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0119c79:	74 17                	je     f0119c92 <test_kfree_bestfirstfit+0xc1a>
f0119c7b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c82:	83 ec 0c             	sub    $0xc,%esp
f0119c85:	68 1c d8 12 f0       	push   $0xf012d81c
f0119c8a:	e8 fc 72 fe ff       	call   f0100f8b <cprintf>
f0119c8f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c92:	e8 0e ac fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119c97:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119c9a:	74 17                	je     f0119cb3 <test_kfree_bestfirstfit+0xc3b>
f0119c9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ca3:	83 ec 0c             	sub    $0xc,%esp
f0119ca6:	68 70 d8 12 f0       	push   $0xf012d870
f0119cab:	e8 db 72 fe ff       	call   f0100f8b <cprintf>
f0119cb0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119cb3:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119cb6:	e8 ef 45 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119cbb:	29 c3                	sub    %eax,%ebx
f0119cbd:	89 d8                	mov    %ebx,%eax
f0119cbf:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119cc4:	77 17                	ja     f0119cdd <test_kfree_bestfirstfit+0xc65>
f0119cc6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ccd:	83 ec 0c             	sub    $0xc,%esp
f0119cd0:	68 e0 d8 12 f0       	push   $0xf012d8e0
f0119cd5:	e8 b1 72 fe ff       	call   f0100f8b <cprintf>
f0119cda:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f0119cdd:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f0119ce4:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119cea:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f0119ced:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119cf4:	eb 0e                	jmp    f0119d04 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f0119cf6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119cf9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119cfc:	01 d0                	add    %edx,%eax
f0119cfe:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f0119d01:	ff 45 f4             	incl   -0xc(%ebp)
f0119d04:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119d07:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119d0a:	7f ea                	jg     f0119cf6 <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f0119d0c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119d10:	74 04                	je     f0119d16 <test_kfree_bestfirstfit+0xc9e>
f0119d12:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0119d16:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f0119d1d:	83 ec 0c             	sub    $0xc,%esp
f0119d20:	68 28 d9 12 f0       	push   $0xf012d928
f0119d25:	e8 61 72 fe ff       	call   f0100f8b <cprintf>
f0119d2a:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f0119d2d:	e8 78 45 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119d32:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119d35:	e8 6b ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d3a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f0119d3d:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0119d43:	83 ec 0c             	sub    $0xc,%esp
f0119d46:	50                   	push   %eax
f0119d47:	e8 fd f6 fe ff       	call   f0109449 <kfree>
f0119d4c:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d4f:	e8 51 ab fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119d54:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119d57:	74 17                	je     f0119d70 <test_kfree_bestfirstfit+0xcf8>
f0119d59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d60:	83 ec 0c             	sub    $0xc,%esp
f0119d63:	68 54 d9 12 f0       	push   $0xf012d954
f0119d68:	e8 1e 72 fe ff       	call   f0100f8b <cprintf>
f0119d6d:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119d70:	e8 35 45 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119d75:	89 c2                	mov    %eax,%edx
f0119d77:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119d7a:	29 c2                	sub    %eax,%edx
f0119d7c:	89 d0                	mov    %edx,%eax
f0119d7e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119d83:	77 17                	ja     f0119d9c <test_kfree_bestfirstfit+0xd24>
f0119d85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119d8c:	83 ec 0c             	sub    $0xc,%esp
f0119d8f:	68 c4 d9 12 f0       	push   $0xf012d9c4
f0119d94:	e8 f2 71 fe ff       	call   f0100f8b <cprintf>
f0119d99:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f0119d9c:	e8 09 45 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119da1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119da4:	e8 fc aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119da9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f0119dac:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0119db2:	83 ec 0c             	sub    $0xc,%esp
f0119db5:	50                   	push   %eax
f0119db6:	e8 8e f6 fe ff       	call   f0109449 <kfree>
f0119dbb:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119dbe:	e8 e2 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119dc3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119dc6:	74 17                	je     f0119ddf <test_kfree_bestfirstfit+0xd67>
f0119dc8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dcf:	83 ec 0c             	sub    $0xc,%esp
f0119dd2:	68 00 da 12 f0       	push   $0xf012da00
f0119dd7:	e8 af 71 fe ff       	call   f0100f8b <cprintf>
f0119ddc:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119ddf:	e8 c6 44 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119de4:	89 c2                	mov    %eax,%edx
f0119de6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119de9:	29 c2                	sub    %eax,%edx
f0119deb:	89 d0                	mov    %edx,%eax
f0119ded:	83 f8 01             	cmp    $0x1,%eax
f0119df0:	77 17                	ja     f0119e09 <test_kfree_bestfirstfit+0xd91>
f0119df2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119df9:	83 ec 0c             	sub    $0xc,%esp
f0119dfc:	68 70 da 12 f0       	push   $0xf012da70
f0119e01:	e8 85 71 fe ff       	call   f0100f8b <cprintf>
f0119e06:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f0119e09:	e8 9c 44 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119e0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e11:	e8 8f aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e16:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f0119e19:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0119e1f:	83 ec 0c             	sub    $0xc,%esp
f0119e22:	50                   	push   %eax
f0119e23:	e8 21 f6 fe ff       	call   f0109449 <kfree>
f0119e28:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e2b:	e8 75 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e30:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119e33:	74 17                	je     f0119e4c <test_kfree_bestfirstfit+0xdd4>
f0119e35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e3c:	83 ec 0c             	sub    $0xc,%esp
f0119e3f:	68 ac da 12 f0       	push   $0xf012daac
f0119e44:	e8 42 71 fe ff       	call   f0100f8b <cprintf>
f0119e49:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119e4c:	e8 59 44 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119e51:	89 c2                	mov    %eax,%edx
f0119e53:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119e56:	29 c2                	sub    %eax,%edx
f0119e58:	89 d0                	mov    %edx,%eax
f0119e5a:	83 f8 03             	cmp    $0x3,%eax
f0119e5d:	77 17                	ja     f0119e76 <test_kfree_bestfirstfit+0xdfe>
f0119e5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e66:	83 ec 0c             	sub    $0xc,%esp
f0119e69:	68 1c db 12 f0       	push   $0xf012db1c
f0119e6e:	e8 18 71 fe ff       	call   f0100f8b <cprintf>
f0119e73:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f0119e76:	e8 2f 44 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119e7b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119e7e:	e8 22 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e83:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f0119e86:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119e8c:	83 ec 0c             	sub    $0xc,%esp
f0119e8f:	50                   	push   %eax
f0119e90:	e8 b4 f5 fe ff       	call   f0109449 <kfree>
f0119e95:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e98:	e8 08 aa fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119e9d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119ea0:	74 17                	je     f0119eb9 <test_kfree_bestfirstfit+0xe41>
f0119ea2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ea9:	83 ec 0c             	sub    $0xc,%esp
f0119eac:	68 58 db 12 f0       	push   $0xf012db58
f0119eb1:	e8 d5 70 fe ff       	call   f0100f8b <cprintf>
f0119eb6:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119eb9:	e8 ec 43 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119ebe:	89 c2                	mov    %eax,%edx
f0119ec0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119ec3:	29 c2                	sub    %eax,%edx
f0119ec5:	89 d0                	mov    %edx,%eax
f0119ec7:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119ecc:	77 17                	ja     f0119ee5 <test_kfree_bestfirstfit+0xe6d>
f0119ece:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119ed5:	83 ec 0c             	sub    $0xc,%esp
f0119ed8:	68 c8 db 12 f0       	push   $0xf012dbc8
f0119edd:	e8 a9 70 fe ff       	call   f0100f8b <cprintf>
f0119ee2:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f0119ee5:	e8 c0 43 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119eea:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119eed:	e8 b3 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119ef2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f0119ef5:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119efb:	83 ec 0c             	sub    $0xc,%esp
f0119efe:	50                   	push   %eax
f0119eff:	e8 45 f5 fe ff       	call   f0109449 <kfree>
f0119f04:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f07:	e8 99 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f0c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119f0f:	74 17                	je     f0119f28 <test_kfree_bestfirstfit+0xeb0>
f0119f11:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f18:	83 ec 0c             	sub    $0xc,%esp
f0119f1b:	68 04 dc 12 f0       	push   $0xf012dc04
f0119f20:	e8 66 70 fe ff       	call   f0100f8b <cprintf>
f0119f25:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119f28:	e8 7d 43 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119f2d:	89 c2                	mov    %eax,%edx
f0119f2f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119f32:	29 c2                	sub    %eax,%edx
f0119f34:	89 d0                	mov    %edx,%eax
f0119f36:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119f3b:	77 17                	ja     f0119f54 <test_kfree_bestfirstfit+0xedc>
f0119f3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f44:	83 ec 0c             	sub    $0xc,%esp
f0119f47:	68 74 dc 12 f0       	push   $0xf012dc74
f0119f4c:	e8 3a 70 fe ff       	call   f0100f8b <cprintf>
f0119f51:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f0119f54:	e8 51 43 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119f59:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f5c:	e8 44 a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f61:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f0119f64:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0119f6a:	83 ec 0c             	sub    $0xc,%esp
f0119f6d:	50                   	push   %eax
f0119f6e:	e8 d6 f4 fe ff       	call   f0109449 <kfree>
f0119f73:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f76:	e8 2a a9 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119f7b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119f7e:	74 17                	je     f0119f97 <test_kfree_bestfirstfit+0xf1f>
f0119f80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f87:	83 ec 0c             	sub    $0xc,%esp
f0119f8a:	68 b0 dc 12 f0       	push   $0xf012dcb0
f0119f8f:	e8 f7 6f fe ff       	call   f0100f8b <cprintf>
f0119f94:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119f97:	e8 0e 43 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119f9c:	89 c2                	mov    %eax,%edx
f0119f9e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119fa1:	39 c2                	cmp    %eax,%edx
f0119fa3:	74 17                	je     f0119fbc <test_kfree_bestfirstfit+0xf44>
f0119fa5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fac:	83 ec 0c             	sub    $0xc,%esp
f0119faf:	68 20 dd 12 f0       	push   $0xf012dd20
f0119fb4:	e8 d2 6f fe ff       	call   f0100f8b <cprintf>
f0119fb9:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f0119fbc:	e8 e9 42 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f0119fc1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119fc4:	e8 dc a8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119fc9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f0119fcc:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0119fd2:	83 ec 0c             	sub    $0xc,%esp
f0119fd5:	50                   	push   %eax
f0119fd6:	e8 6e f4 fe ff       	call   f0109449 <kfree>
f0119fdb:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119fde:	e8 c2 a8 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f0119fe3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119fe6:	74 17                	je     f0119fff <test_kfree_bestfirstfit+0xf87>
f0119fe8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fef:	83 ec 0c             	sub    $0xc,%esp
f0119ff2:	68 5c dd 12 f0       	push   $0xf012dd5c
f0119ff7:	e8 8f 6f fe ff       	call   f0100f8b <cprintf>
f0119ffc:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119fff:	e8 a6 42 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a004:	89 c2                	mov    %eax,%edx
f011a006:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a009:	39 c2                	cmp    %eax,%edx
f011a00b:	74 17                	je     f011a024 <test_kfree_bestfirstfit+0xfac>
f011a00d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a014:	83 ec 0c             	sub    $0xc,%esp
f011a017:	68 cc dd 12 f0       	push   $0xf012ddcc
f011a01c:	e8 6a 6f fe ff       	call   f0100f8b <cprintf>
f011a021:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011a024:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a028:	74 04                	je     f011a02e <test_kfree_bestfirstfit+0xfb6>
f011a02a:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a02e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011a035:	83 ec 0c             	sub    $0xc,%esp
f011a038:	68 2c de 12 f0       	push   $0xf012de2c
f011a03d:	e8 49 6f fe ff       	call   f0100f8b <cprintf>
f011a042:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011a045:	83 ec 0c             	sub    $0xc,%esp
f011a048:	6a 03                	push   $0x3
f011a04a:	e8 84 46 ff ff       	call   f010e6d3 <sys_bypassPageFault>
f011a04f:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011a052:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a059:	e9 af 00 00 00       	jmp    f011a10d <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011a05e:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011a062:	0f 84 a1 00 00 00    	je     f011a109 <test_kfree_bestfirstfit+0x1091>
f011a068:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011a06c:	0f 84 97 00 00 00    	je     f011a109 <test_kfree_bestfirstfit+0x1091>
f011a072:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011a076:	0f 84 8d 00 00 00    	je     f011a109 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011a07c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a07f:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011a086:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011a089:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a08c:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011a08f:	e8 2d 46 ff ff       	call   f010e6c1 <sys_rcr2>
f011a094:	89 c2                	mov    %eax,%edx
f011a096:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a099:	39 c2                	cmp    %eax,%edx
f011a09b:	74 1d                	je     f011a0ba <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011a09d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a0a1:	74 17                	je     f011a0ba <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a0a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0aa:	83 ec 0c             	sub    $0xc,%esp
f011a0ad:	68 6c de 12 f0       	push   $0xf012de6c
f011a0b2:	e8 d4 6e fe ff       	call   f0100f8b <cprintf>
f011a0b7:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011a0ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a0bd:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a0c4:	89 c2                	mov    %eax,%edx
f011a0c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a0c9:	01 d0                	add    %edx,%eax
f011a0cb:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011a0ce:	e8 ee 45 ff ff       	call   f010e6c1 <sys_rcr2>
f011a0d3:	89 c2                	mov    %eax,%edx
f011a0d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a0d8:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011a0df:	89 c1                	mov    %eax,%ecx
f011a0e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a0e4:	01 c8                	add    %ecx,%eax
f011a0e6:	39 c2                	cmp    %eax,%edx
f011a0e8:	74 20                	je     f011a10a <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011a0ea:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a0ee:	74 1a                	je     f011a10a <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011a0f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0f7:	83 ec 0c             	sub    $0xc,%esp
f011a0fa:	68 b8 de 12 f0       	push   $0xf012deb8
f011a0ff:	e8 87 6e fe ff       	call   f0100f8b <cprintf>
f011a104:	83 c4 10             	add    $0x10,%esp
f011a107:	eb 01                	jmp    f011a10a <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011a109:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011a10a:	ff 45 f4             	incl   -0xc(%ebp)
f011a10d:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011a111:	0f 8e 47 ff ff ff    	jle    f011a05e <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011a117:	83 ec 0c             	sub    $0xc,%esp
f011a11a:	6a 00                	push   $0x0
f011a11c:	e8 b2 45 ff ff       	call   f010e6d3 <sys_bypassPageFault>
f011a121:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011a124:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a128:	74 04                	je     f011a12e <test_kfree_bestfirstfit+0x10b6>
f011a12a:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011a12e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011a135:	83 ec 0c             	sub    $0xc,%esp
f011a138:	68 04 df 12 f0       	push   $0xf012df04
f011a13d:	e8 49 6e fe ff       	call   f0100f8b <cprintf>
f011a142:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a145:	e8 60 41 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a14a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a14d:	e8 53 a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a152:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011a155:	83 ec 0c             	sub    $0xc,%esp
f011a158:	68 00 04 00 00       	push   $0x400
f011a15d:	e8 87 f0 fe ff       	call   f01091e9 <kmalloc>
f011a162:	83 c4 10             	add    $0x10,%esp
f011a165:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011a16b:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011a171:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a177:	39 c2                	cmp    %eax,%edx
f011a179:	74 17                	je     f011a192 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a17b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a182:	83 ec 0c             	sub    $0xc,%esp
f011a185:	68 28 df 12 f0       	push   $0xf012df28
f011a18a:	e8 fc 6d fe ff       	call   f0100f8b <cprintf>
f011a18f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a192:	e8 0e a7 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a197:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a19a:	74 17                	je     f011a1b3 <test_kfree_bestfirstfit+0x113b>
f011a19c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1a3:	83 ec 0c             	sub    $0xc,%esp
f011a1a6:	68 7c df 12 f0       	push   $0xf012df7c
f011a1ab:	e8 db 6d fe ff       	call   f0100f8b <cprintf>
f011a1b0:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a1b3:	e8 f2 40 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a1b8:	89 c2                	mov    %eax,%edx
f011a1ba:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a1bd:	39 c2                	cmp    %eax,%edx
f011a1bf:	74 17                	je     f011a1d8 <test_kfree_bestfirstfit+0x1160>
f011a1c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1c8:	83 ec 0c             	sub    $0xc,%esp
f011a1cb:	68 ec df 12 f0       	push   $0xf012dfec
f011a1d0:	e8 b6 6d fe ff       	call   f0100f8b <cprintf>
f011a1d5:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011a1d8:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011a1df:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a1e5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a1e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a1ef:	eb 0e                	jmp    f011a1ff <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011a1f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a1f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a1f7:	01 d0                	add    %edx,%eax
f011a1f9:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a1fc:	ff 45 f4             	incl   -0xc(%ebp)
f011a1ff:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a202:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a205:	7f ea                	jg     f011a1f1 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a207:	e8 9e 40 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a20c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a20f:	e8 91 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a214:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011a217:	83 ec 0c             	sub    $0xc,%esp
f011a21a:	68 00 08 00 00       	push   $0x800
f011a21f:	e8 c5 ef fe ff       	call   f01091e9 <kmalloc>
f011a224:	83 c4 10             	add    $0x10,%esp
f011a227:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011a22d:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a233:	05 08 04 00 00       	add    $0x408,%eax
f011a238:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011a23b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a241:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a244:	74 35                	je     f011a27b <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011a246:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011a24d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a253:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a259:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011a25f:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011a265:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a26b:	50                   	push   %eax
f011a26c:	51                   	push   %ecx
f011a26d:	52                   	push   %edx
f011a26e:	68 68 e0 12 f0       	push   $0xf012e068
f011a273:	e8 13 6d fe ff       	call   f0100f8b <cprintf>
f011a278:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a27b:	e8 25 a6 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a280:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a283:	74 17                	je     f011a29c <test_kfree_bestfirstfit+0x1224>
f011a285:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a28c:	83 ec 0c             	sub    $0xc,%esp
f011a28f:	68 dc e0 12 f0       	push   $0xf012e0dc
f011a294:	e8 f2 6c fe ff       	call   f0100f8b <cprintf>
f011a299:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a29c:	e8 09 40 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a2a1:	89 c2                	mov    %eax,%edx
f011a2a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a2a6:	39 c2                	cmp    %eax,%edx
f011a2a8:	74 17                	je     f011a2c1 <test_kfree_bestfirstfit+0x1249>
f011a2aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2b1:	83 ec 0c             	sub    $0xc,%esp
f011a2b4:	68 4c e1 12 f0       	push   $0xf012e14c
f011a2b9:	e8 cd 6c fe ff       	call   f0100f8b <cprintf>
f011a2be:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011a2c1:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011a2c8:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a2ce:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a2d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a2d8:	eb 0e                	jmp    f011a2e8 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011a2da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a2dd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a2e0:	01 d0                	add    %edx,%eax
f011a2e2:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a2e5:	ff 45 f4             	incl   -0xc(%ebp)
f011a2e8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a2eb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a2ee:	7f ea                	jg     f011a2da <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a2f0:	e8 b5 3f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a2f5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a2f8:	e8 a8 a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a2fd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011a300:	83 ec 0c             	sub    $0xc,%esp
f011a303:	68 00 06 00 00       	push   $0x600
f011a308:	e8 dc ee fe ff       	call   f01091e9 <kmalloc>
f011a30d:	83 c4 10             	add    $0x10,%esp
f011a310:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011a316:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a31c:	05 10 0c 00 00       	add    $0xc10,%eax
f011a321:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011a324:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a32a:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011a32d:	74 17                	je     f011a346 <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a32f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a336:	83 ec 0c             	sub    $0xc,%esp
f011a339:	68 c8 e1 12 f0       	push   $0xf012e1c8
f011a33e:	e8 48 6c fe ff       	call   f0100f8b <cprintf>
f011a343:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a346:	e8 5a a5 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a34b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a34e:	74 17                	je     f011a367 <test_kfree_bestfirstfit+0x12ef>
f011a350:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a357:	83 ec 0c             	sub    $0xc,%esp
f011a35a:	68 1c e2 12 f0       	push   $0xf012e21c
f011a35f:	e8 27 6c fe ff       	call   f0100f8b <cprintf>
f011a364:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011a367:	e8 3e 3f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a36c:	89 c2                	mov    %eax,%edx
f011a36e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a371:	39 c2                	cmp    %eax,%edx
f011a373:	74 17                	je     f011a38c <test_kfree_bestfirstfit+0x1314>
f011a375:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a37c:	83 ec 0c             	sub    $0xc,%esp
f011a37f:	68 8c e2 12 f0       	push   $0xf012e28c
f011a384:	e8 02 6c fe ff       	call   f0100f8b <cprintf>
f011a389:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011a38c:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011a393:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a399:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a39c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3a3:	eb 0e                	jmp    f011a3b3 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011a3a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a3a8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3ab:	01 d0                	add    %edx,%eax
f011a3ad:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011a3b0:	ff 45 f4             	incl   -0xc(%ebp)
f011a3b3:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a3b6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a3b9:	7f ea                	jg     f011a3a5 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011a3bb:	e8 ea 3e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a3c0:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a3c3:	e8 dd a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a3c8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011a3cb:	83 ec 0c             	sub    $0xc,%esp
f011a3ce:	68 00 00 e0 01       	push   $0x1e00000
f011a3d3:	e8 11 ee fe ff       	call   f01091e9 <kmalloc>
f011a3d8:	83 c4 10             	add    $0x10,%esp
f011a3db:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a3e1:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a3e7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a3ec:	74 17                	je     f011a405 <test_kfree_bestfirstfit+0x138d>
f011a3ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3f5:	83 ec 0c             	sub    $0xc,%esp
f011a3f8:	68 08 e3 12 f0       	push   $0xf012e308
f011a3fd:	e8 89 6b fe ff       	call   f0100f8b <cprintf>
f011a402:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a405:	e8 9b a4 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a40a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a40d:	74 17                	je     f011a426 <test_kfree_bestfirstfit+0x13ae>
f011a40f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a416:	83 ec 0c             	sub    $0xc,%esp
f011a419:	68 5c e3 12 f0       	push   $0xf012e35c
f011a41e:	e8 68 6b fe ff       	call   f0100f8b <cprintf>
f011a423:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a426:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a429:	e8 7c 3e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a42e:	29 c3                	sub    %eax,%ebx
f011a430:	89 d8                	mov    %ebx,%eax
f011a432:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011a437:	77 17                	ja     f011a450 <test_kfree_bestfirstfit+0x13d8>
f011a439:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a440:	83 ec 0c             	sub    $0xc,%esp
f011a443:	68 cc e3 12 f0       	push   $0xf012e3cc
f011a448:	e8 3e 6b fe ff       	call   f0100f8b <cprintf>
f011a44d:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011a450:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011a457:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a45d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011a460:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a467:	eb 0e                	jmp    f011a477 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011a469:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a46c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a46f:	01 d0                	add    %edx,%eax
f011a471:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011a474:	ff 45 f4             	incl   -0xc(%ebp)
f011a477:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a47a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a47d:	7f ea                	jg     f011a469 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011a47f:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011a485:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011a488:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a48f:	eb 1e                	jmp    f011a4af <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011a491:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011a497:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a49a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a49d:	01 c8                	add    %ecx,%eax
f011a49f:	8a 00                	mov    (%eax),%al
f011a4a1:	0f be c0             	movsbl %al,%eax
f011a4a4:	01 d0                	add    %edx,%eax
f011a4a6:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011a4ac:	ff 45 f4             	incl   -0xc(%ebp)
f011a4af:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011a4b2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a4b5:	7f da                	jg     f011a491 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011a4b7:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011a4bd:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011a4c0:	89 d0                	mov    %edx,%eax
f011a4c2:	c1 e0 02             	shl    $0x2,%eax
f011a4c5:	01 d0                	add    %edx,%eax
f011a4c7:	01 c0                	add    %eax,%eax
f011a4c9:	39 c1                	cmp    %eax,%ecx
f011a4cb:	74 17                	je     f011a4e4 <test_kfree_bestfirstfit+0x146c>
f011a4cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4d4:	83 ec 0c             	sub    $0xc,%esp
f011a4d7:	68 14 e4 12 f0       	push   $0xf012e414
f011a4dc:	e8 aa 6a fe ff       	call   f0100f8b <cprintf>
f011a4e1:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011a4e4:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011a4ea:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011a4ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a4f4:	eb 1e                	jmp    f011a514 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011a4f6:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011a4fc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a4ff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a502:	01 c8                	add    %ecx,%eax
f011a504:	8a 00                	mov    (%eax),%al
f011a506:	0f be c0             	movsbl %al,%eax
f011a509:	01 d0                	add    %edx,%eax
f011a50b:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011a511:	ff 45 f4             	incl   -0xc(%ebp)
f011a514:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a517:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a51a:	7f da                	jg     f011a4f6 <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011a51c:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011a522:	8b 55 90             	mov    -0x70(%ebp),%edx
f011a525:	89 d0                	mov    %edx,%eax
f011a527:	c1 e0 02             	shl    $0x2,%eax
f011a52a:	01 d0                	add    %edx,%eax
f011a52c:	01 c0                	add    %eax,%eax
f011a52e:	01 d0                	add    %edx,%eax
f011a530:	39 c1                	cmp    %eax,%ecx
f011a532:	74 17                	je     f011a54b <test_kfree_bestfirstfit+0x14d3>
f011a534:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a53b:	83 ec 0c             	sub    $0xc,%esp
f011a53e:	68 44 e4 12 f0       	push   $0xf012e444
f011a543:	e8 43 6a fe ff       	call   f0100f8b <cprintf>
f011a548:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011a54b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011a551:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011a554:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a55b:	eb 1e                	jmp    f011a57b <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011a55d:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011a563:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a566:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a569:	01 c8                	add    %ecx,%eax
f011a56b:	8a 00                	mov    (%eax),%al
f011a56d:	0f be c0             	movsbl %al,%eax
f011a570:	01 d0                	add    %edx,%eax
f011a572:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011a578:	ff 45 f4             	incl   -0xc(%ebp)
f011a57b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011a57e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a581:	7f da                	jg     f011a55d <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011a583:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011a589:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011a58c:	89 d0                	mov    %edx,%eax
f011a58e:	01 c0                	add    %eax,%eax
f011a590:	01 d0                	add    %edx,%eax
f011a592:	c1 e0 02             	shl    $0x2,%eax
f011a595:	39 c1                	cmp    %eax,%ecx
f011a597:	74 17                	je     f011a5b0 <test_kfree_bestfirstfit+0x1538>
f011a599:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5a0:	83 ec 0c             	sub    $0xc,%esp
f011a5a3:	68 74 e4 12 f0       	push   $0xf012e474
f011a5a8:	e8 de 69 fe ff       	call   f0100f8b <cprintf>
f011a5ad:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011a5b0:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011a5b6:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011a5b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a5c0:	eb 1e                	jmp    f011a5e0 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011a5c2:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011a5c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a5cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a5ce:	01 c8                	add    %ecx,%eax
f011a5d0:	8a 00                	mov    (%eax),%al
f011a5d2:	0f be c0             	movsbl %al,%eax
f011a5d5:	01 d0                	add    %edx,%eax
f011a5d7:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011a5dd:	ff 45 f4             	incl   -0xc(%ebp)
f011a5e0:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a5e3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a5e6:	7f da                	jg     f011a5c2 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011a5e8:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011a5ee:	8b 55 98             	mov    -0x68(%ebp),%edx
f011a5f1:	89 d0                	mov    %edx,%eax
f011a5f3:	01 c0                	add    %eax,%eax
f011a5f5:	01 d0                	add    %edx,%eax
f011a5f7:	c1 e0 02             	shl    $0x2,%eax
f011a5fa:	01 d0                	add    %edx,%eax
f011a5fc:	39 c1                	cmp    %eax,%ecx
f011a5fe:	74 17                	je     f011a617 <test_kfree_bestfirstfit+0x159f>
f011a600:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a607:	83 ec 0c             	sub    $0xc,%esp
f011a60a:	68 a4 e4 12 f0       	push   $0xf012e4a4
f011a60f:	e8 77 69 fe ff       	call   f0100f8b <cprintf>
f011a614:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011a617:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a61b:	74 04                	je     f011a621 <test_kfree_bestfirstfit+0x15a9>
f011a61d:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a621:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011a628:	83 ec 0c             	sub    $0xc,%esp
f011a62b:	68 d1 e4 12 f0       	push   $0xf012e4d1
f011a630:	e8 56 69 fe ff       	call   f0100f8b <cprintf>
f011a635:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011a638:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011a63f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011a646:	eb 4e                	jmp    f011a696 <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011a648:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a64b:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011a650:	83 ec 04             	sub    $0x4,%esp
f011a653:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011a659:	51                   	push   %ecx
f011a65a:	52                   	push   %edx
f011a65b:	50                   	push   %eax
f011a65c:	e8 8e dd fe ff       	call   f01083ef <get_page_table>
f011a661:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a664:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011a66a:	85 c0                	test   %eax,%eax
f011a66c:	75 1d                	jne    f011a68b <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011a66e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a672:	74 17                	je     f011a68b <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011a674:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a67b:	83 ec 0c             	sub    $0xc,%esp
f011a67e:	68 f0 e4 12 f0       	push   $0xf012e4f0
f011a683:	e8 03 69 fe ff       	call   f0100f8b <cprintf>
f011a688:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011a68b:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011a692:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011a696:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a69a:	78 ac                	js     f011a648 <test_kfree_bestfirstfit+0x15d0>
f011a69c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a6a0:	7f 09                	jg     f011a6ab <test_kfree_bestfirstfit+0x1633>
f011a6a2:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011a6a9:	76 9d                	jbe    f011a648 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011a6ab:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a6af:	74 04                	je     f011a6b5 <test_kfree_bestfirstfit+0x163d>
f011a6b1:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011a6b5:	83 ec 08             	sub    $0x8,%esp
f011a6b8:	ff 75 f0             	pushl  -0x10(%ebp)
f011a6bb:	68 58 e5 12 f0       	push   $0xf012e558
f011a6c0:	e8 c6 68 fe ff       	call   f0100f8b <cprintf>
f011a6c5:	83 c4 10             	add    $0x10,%esp

	return 1;
f011a6c8:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011a6cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a6d0:	5b                   	pop    %ebx
f011a6d1:	5f                   	pop    %edi
f011a6d2:	5d                   	pop    %ebp
f011a6d3:	c3                   	ret    

f011a6d4 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011a6d4:	55                   	push   %ebp
f011a6d5:	89 e5                	mov    %esp,%ebp
f011a6d7:	57                   	push   %edi
f011a6d8:	53                   	push   %ebx
f011a6d9:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a6df:	83 ec 0c             	sub    $0xc,%esp
f011a6e2:	68 28 a8 12 f0       	push   $0xf012a828
f011a6e7:	e8 9f 68 fe ff       	call   f0100f8b <cprintf>
f011a6ec:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a6ef:	83 ec 0c             	sub    $0xc,%esp
f011a6f2:	68 58 a8 12 f0       	push   $0xf012a858
f011a6f7:	e8 8f 68 fe ff       	call   f0100f8b <cprintf>
f011a6fc:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a6ff:	83 ec 0c             	sub    $0xc,%esp
f011a702:	68 28 a8 12 f0       	push   $0xf012a828
f011a707:	e8 7f 68 fe ff       	call   f0100f8b <cprintf>
f011a70c:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a70f:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011a713:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011a717:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011a71d:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011a723:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a72a:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011a731:	e8 74 3b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a736:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011a739:	83 ec 0c             	sub    $0xc,%esp
f011a73c:	68 7c e5 12 f0       	push   $0xf012e57c
f011a741:	e8 45 68 fe ff       	call   f0100f8b <cprintf>
f011a746:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011a749:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011a74f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a754:	b8 00 00 00 00       	mov    $0x0,%eax
f011a759:	89 d7                	mov    %edx,%edi
f011a75b:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011a75d:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011a763:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a768:	b8 00 00 00 00       	mov    $0x0,%eax
f011a76d:	89 d7                	mov    %edx,%edi
f011a76f:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011a771:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011a778:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011a77f:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011a785:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a78a:	b8 00 00 00 00       	mov    $0x0,%eax
f011a78f:	89 d7                	mov    %edx,%edi
f011a791:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a793:	e8 12 3b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a798:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a79b:	e8 05 a1 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a7a0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a7a3:	83 ec 0c             	sub    $0xc,%esp
f011a7a6:	68 00 fc 1f 00       	push   $0x1ffc00
f011a7ab:	e8 39 ea fe ff       	call   f01091e9 <kmalloc>
f011a7b0:	83 c4 10             	add    $0x10,%esp
f011a7b3:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a7b9:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011a7bf:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a7c4:	74 17                	je     f011a7dd <test_kheap_phys_addr+0x109>
f011a7c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7cd:	83 ec 0c             	sub    $0xc,%esp
f011a7d0:	68 20 c9 12 f0       	push   $0xf012c920
f011a7d5:	e8 b1 67 fe ff       	call   f0100f8b <cprintf>
f011a7da:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7dd:	e8 c3 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a7e2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a7e5:	74 17                	je     f011a7fe <test_kheap_phys_addr+0x12a>
f011a7e7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7ee:	83 ec 0c             	sub    $0xc,%esp
f011a7f1:	68 74 c9 12 f0       	push   $0xf012c974
f011a7f6:	e8 90 67 fe ff       	call   f0100f8b <cprintf>
f011a7fb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a7fe:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a801:	e8 a4 3a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a806:	29 c3                	sub    %eax,%ebx
f011a808:	89 d8                	mov    %ebx,%eax
f011a80a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a80f:	77 17                	ja     f011a828 <test_kheap_phys_addr+0x154>
f011a811:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a818:	83 ec 0c             	sub    $0xc,%esp
f011a81b:	68 e4 c9 12 f0       	push   $0xf012c9e4
f011a820:	e8 66 67 fe ff       	call   f0100f8b <cprintf>
f011a825:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a828:	e8 7d 3a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a82d:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a830:	e8 70 a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a835:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a838:	83 ec 0c             	sub    $0xc,%esp
f011a83b:	68 00 fc 1f 00       	push   $0x1ffc00
f011a840:	e8 a4 e9 fe ff       	call   f01091e9 <kmalloc>
f011a845:	83 c4 10             	add    $0x10,%esp
f011a848:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a84e:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a854:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a859:	74 17                	je     f011a872 <test_kheap_phys_addr+0x19e>
f011a85b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a862:	83 ec 0c             	sub    $0xc,%esp
f011a865:	68 2c ca 12 f0       	push   $0xf012ca2c
f011a86a:	e8 1c 67 fe ff       	call   f0100f8b <cprintf>
f011a86f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a872:	e8 2e a0 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a877:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a87a:	74 17                	je     f011a893 <test_kheap_phys_addr+0x1bf>
f011a87c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a883:	83 ec 0c             	sub    $0xc,%esp
f011a886:	68 80 ca 12 f0       	push   $0xf012ca80
f011a88b:	e8 fb 66 fe ff       	call   f0100f8b <cprintf>
f011a890:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a893:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a896:	e8 0f 3a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a89b:	29 c3                	sub    %eax,%ebx
f011a89d:	89 d8                	mov    %ebx,%eax
f011a89f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a8a4:	77 17                	ja     f011a8bd <test_kheap_phys_addr+0x1e9>
f011a8a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8ad:	83 ec 0c             	sub    $0xc,%esp
f011a8b0:	68 f0 ca 12 f0       	push   $0xf012caf0
f011a8b5:	e8 d1 66 fe ff       	call   f0100f8b <cprintf>
f011a8ba:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011a8bd:	e8 e8 39 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a8c2:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a8c5:	e8 db 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a8ca:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011a8cd:	83 ec 0c             	sub    $0xc,%esp
f011a8d0:	68 00 04 00 00       	push   $0x400
f011a8d5:	e8 0f e9 fe ff       	call   f01091e9 <kmalloc>
f011a8da:	83 c4 10             	add    $0x10,%esp
f011a8dd:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a8e3:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a8e9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a8ee:	76 28                	jbe    f011a918 <test_kheap_phys_addr+0x244>
f011a8f0:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011a8f6:	83 ec 0c             	sub    $0xc,%esp
f011a8f9:	6a 00                	push   $0x0
f011a8fb:	e8 b6 e7 fe ff       	call   f01090b6 <sbrk>
f011a900:	83 c4 10             	add    $0x10,%esp
f011a903:	39 c3                	cmp    %eax,%ebx
f011a905:	73 11                	jae    f011a918 <test_kheap_phys_addr+0x244>
f011a907:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011a90d:	89 c2                	mov    %eax,%edx
f011a90f:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011a914:	39 c2                	cmp    %eax,%edx
f011a916:	72 17                	jb     f011a92f <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a918:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a91f:	83 ec 0c             	sub    $0xc,%esp
f011a922:	68 ac e5 12 f0       	push   $0xf012e5ac
f011a927:	e8 5f 66 fe ff       	call   f0100f8b <cprintf>
f011a92c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a92f:	e8 71 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a934:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a937:	74 17                	je     f011a950 <test_kheap_phys_addr+0x27c>
f011a939:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a940:	83 ec 0c             	sub    $0xc,%esp
f011a943:	68 8c cb 12 f0       	push   $0xf012cb8c
f011a948:	e8 3e 66 fe ff       	call   f0100f8b <cprintf>
f011a94d:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a950:	e8 55 39 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a955:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a958:	e8 48 9f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a95d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a960:	83 ec 0c             	sub    $0xc,%esp
f011a963:	68 00 08 00 00       	push   $0x800
f011a968:	e8 7c e8 fe ff       	call   f01091e9 <kmalloc>
f011a96d:	83 c4 10             	add    $0x10,%esp
f011a970:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a976:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011a97c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a981:	76 28                	jbe    f011a9ab <test_kheap_phys_addr+0x2d7>
f011a983:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011a989:	83 ec 0c             	sub    $0xc,%esp
f011a98c:	6a 00                	push   $0x0
f011a98e:	e8 23 e7 fe ff       	call   f01090b6 <sbrk>
f011a993:	83 c4 10             	add    $0x10,%esp
f011a996:	39 c3                	cmp    %eax,%ebx
f011a998:	73 11                	jae    f011a9ab <test_kheap_phys_addr+0x2d7>
f011a99a:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011a9a0:	89 c2                	mov    %eax,%edx
f011a9a2:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011a9a7:	39 c2                	cmp    %eax,%edx
f011a9a9:	72 17                	jb     f011a9c2 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a9ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9b2:	83 ec 0c             	sub    $0xc,%esp
f011a9b5:	68 38 e6 12 f0       	push   $0xf012e638
f011a9ba:	e8 cc 65 fe ff       	call   f0100f8b <cprintf>
f011a9bf:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9c2:	e8 de 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a9c7:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a9ca:	74 17                	je     f011a9e3 <test_kheap_phys_addr+0x30f>
f011a9cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9d3:	83 ec 0c             	sub    $0xc,%esp
f011a9d6:	68 98 cc 12 f0       	push   $0xf012cc98
f011a9db:	e8 ab 65 fe ff       	call   f0100f8b <cprintf>
f011a9e0:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011a9e3:	e8 c2 38 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011a9e8:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a9eb:	e8 b5 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011a9f0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011a9f3:	83 ec 0c             	sub    $0xc,%esp
f011a9f6:	68 00 06 00 00       	push   $0x600
f011a9fb:	e8 e9 e7 fe ff       	call   f01091e9 <kmalloc>
f011aa00:	83 c4 10             	add    $0x10,%esp
f011aa03:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011aa09:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011aa0f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011aa14:	76 28                	jbe    f011aa3e <test_kheap_phys_addr+0x36a>
f011aa16:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011aa1c:	83 ec 0c             	sub    $0xc,%esp
f011aa1f:	6a 00                	push   $0x0
f011aa21:	e8 90 e6 fe ff       	call   f01090b6 <sbrk>
f011aa26:	83 c4 10             	add    $0x10,%esp
f011aa29:	39 c3                	cmp    %eax,%ebx
f011aa2b:	73 11                	jae    f011aa3e <test_kheap_phys_addr+0x36a>
f011aa2d:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011aa33:	89 c2                	mov    %eax,%edx
f011aa35:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011aa3a:	39 c2                	cmp    %eax,%edx
f011aa3c:	72 17                	jb     f011aa55 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011aa3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa45:	83 ec 0c             	sub    $0xc,%esp
f011aa48:	68 c4 e6 12 f0       	push   $0xf012e6c4
f011aa4d:	e8 39 65 fe ff       	call   f0100f8b <cprintf>
f011aa52:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa55:	e8 4b 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa5a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aa5d:	74 17                	je     f011aa76 <test_kheap_phys_addr+0x3a2>
f011aa5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa66:	83 ec 0c             	sub    $0xc,%esp
f011aa69:	68 a4 cd 12 f0       	push   $0xf012cda4
f011aa6e:	e8 18 65 fe ff       	call   f0100f8b <cprintf>
f011aa73:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011aa76:	e8 2f 38 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011aa7b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aa7e:	e8 22 9e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aa83:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011aa86:	83 ec 0c             	sub    $0xc,%esp
f011aa89:	68 00 1c 00 00       	push   $0x1c00
f011aa8e:	e8 56 e7 fe ff       	call   f01091e9 <kmalloc>
f011aa93:	83 c4 10             	add    $0x10,%esp
f011aa96:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011aa9c:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011aaa2:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011aaa7:	74 17                	je     f011aac0 <test_kheap_phys_addr+0x3ec>
f011aaa9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aab0:	83 ec 0c             	sub    $0xc,%esp
f011aab3:	68 5c ce 12 f0       	push   $0xf012ce5c
f011aab8:	e8 ce 64 fe ff       	call   f0100f8b <cprintf>
f011aabd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aac0:	e8 e0 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011aac5:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011aac8:	74 17                	je     f011aae1 <test_kheap_phys_addr+0x40d>
f011aaca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aad1:	83 ec 0c             	sub    $0xc,%esp
f011aad4:	68 b0 ce 12 f0       	push   $0xf012ceb0
f011aad9:	e8 ad 64 fe ff       	call   f0100f8b <cprintf>
f011aade:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aae1:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011aae4:	e8 c1 37 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011aae9:	29 c3                	sub    %eax,%ebx
f011aaeb:	89 d8                	mov    %ebx,%eax
f011aaed:	83 f8 01             	cmp    $0x1,%eax
f011aaf0:	77 17                	ja     f011ab09 <test_kheap_phys_addr+0x435>
f011aaf2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aaf9:	83 ec 0c             	sub    $0xc,%esp
f011aafc:	68 20 cf 12 f0       	push   $0xf012cf20
f011ab01:	e8 85 64 fe ff       	call   f0100f8b <cprintf>
f011ab06:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ab09:	e8 9c 37 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ab0e:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ab11:	e8 8f 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab16:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ab19:	83 ec 0c             	sub    $0xc,%esp
f011ab1c:	68 00 fc 2f 00       	push   $0x2ffc00
f011ab21:	e8 c3 e6 fe ff       	call   f01091e9 <kmalloc>
f011ab26:	83 c4 10             	add    $0x10,%esp
f011ab29:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ab2f:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011ab35:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011ab3a:	74 17                	je     f011ab53 <test_kheap_phys_addr+0x47f>
f011ab3c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab43:	83 ec 0c             	sub    $0xc,%esp
f011ab46:	68 50 e7 12 f0       	push   $0xf012e750
f011ab4b:	e8 3b 64 fe ff       	call   f0100f8b <cprintf>
f011ab50:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ab53:	e8 4d 9d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ab58:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ab5b:	74 17                	je     f011ab74 <test_kheap_phys_addr+0x4a0>
f011ab5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab64:	83 ec 0c             	sub    $0xc,%esp
f011ab67:	68 f4 cf 12 f0       	push   $0xf012cff4
f011ab6c:	e8 1a 64 fe ff       	call   f0100f8b <cprintf>
f011ab71:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ab74:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ab77:	e8 2e 37 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ab7c:	29 c3                	sub    %eax,%ebx
f011ab7e:	89 d8                	mov    %ebx,%eax
f011ab80:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ab85:	77 17                	ja     f011ab9e <test_kheap_phys_addr+0x4ca>
f011ab87:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab8e:	83 ec 0c             	sub    $0xc,%esp
f011ab91:	68 a4 e7 12 f0       	push   $0xf012e7a4
f011ab96:	e8 f0 63 fe ff       	call   f0100f8b <cprintf>
f011ab9b:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011ab9e:	e8 07 37 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011aba3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aba6:	e8 fa 9c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011abab:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011abae:	83 ec 0c             	sub    $0xc,%esp
f011abb1:	68 00 fc 5f 00       	push   $0x5ffc00
f011abb6:	e8 2e e6 fe ff       	call   f01091e9 <kmalloc>
f011abbb:	83 c4 10             	add    $0x10,%esp
f011abbe:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011abc4:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011abca:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011abcf:	74 17                	je     f011abe8 <test_kheap_phys_addr+0x514>
f011abd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abd8:	83 ec 0c             	sub    $0xc,%esp
f011abdb:	68 ec e7 12 f0       	push   $0xf012e7ec
f011abe0:	e8 a6 63 fe ff       	call   f0100f8b <cprintf>
f011abe5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011abe8:	e8 b8 9c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011abed:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011abf0:	74 17                	je     f011ac09 <test_kheap_phys_addr+0x535>
f011abf2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abf9:	83 ec 0c             	sub    $0xc,%esp
f011abfc:	68 f0 d0 12 f0       	push   $0xf012d0f0
f011ac01:	e8 85 63 fe ff       	call   f0100f8b <cprintf>
f011ac06:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ac09:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ac0c:	e8 99 36 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ac11:	29 c3                	sub    %eax,%ebx
f011ac13:	89 d8                	mov    %ebx,%eax
f011ac15:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ac1a:	77 17                	ja     f011ac33 <test_kheap_phys_addr+0x55f>
f011ac1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac23:	83 ec 0c             	sub    $0xc,%esp
f011ac26:	68 40 e8 12 f0       	push   $0xf012e840
f011ac2b:	e8 5b 63 fe ff       	call   f0100f8b <cprintf>
f011ac30:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011ac33:	e8 72 36 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ac38:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ac3b:	e8 65 9c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ac40:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011ac43:	83 ec 0c             	sub    $0xc,%esp
f011ac46:	68 00 38 00 00       	push   $0x3800
f011ac4b:	e8 99 e5 fe ff       	call   f01091e9 <kmalloc>
f011ac50:	83 c4 10             	add    $0x10,%esp
f011ac53:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac59:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011ac5f:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011ac64:	74 17                	je     f011ac7d <test_kheap_phys_addr+0x5a9>
f011ac66:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac6d:	83 ec 0c             	sub    $0xc,%esp
f011ac70:	68 88 e8 12 f0       	push   $0xf012e888
f011ac75:	e8 11 63 fe ff       	call   f0100f8b <cprintf>
f011ac7a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ac7d:	e8 23 9c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ac82:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ac85:	74 17                	je     f011ac9e <test_kheap_phys_addr+0x5ca>
f011ac87:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac8e:	83 ec 0c             	sub    $0xc,%esp
f011ac91:	68 dc e8 12 f0       	push   $0xf012e8dc
f011ac96:	e8 f0 62 fe ff       	call   f0100f8b <cprintf>
f011ac9b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ac9e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011aca1:	e8 04 36 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011aca6:	29 c3                	sub    %eax,%ebx
f011aca8:	89 d8                	mov    %ebx,%eax
f011acaa:	83 f8 03             	cmp    $0x3,%eax
f011acad:	77 17                	ja     f011acc6 <test_kheap_phys_addr+0x5f2>
f011acaf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acb6:	83 ec 0c             	sub    $0xc,%esp
f011acb9:	68 4c e9 12 f0       	push   $0xf012e94c
f011acbe:	e8 c8 62 fe ff       	call   f0100f8b <cprintf>
f011acc3:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011acc6:	83 ec 0c             	sub    $0xc,%esp
f011acc9:	68 94 e9 12 f0       	push   $0xf012e994
f011acce:	e8 b8 62 fe ff       	call   f0100f8b <cprintf>
f011acd3:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011acd6:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011acdd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011ace4:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011aceb:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011acf0:	05 00 10 00 00       	add    $0x1000,%eax
f011acf5:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011acf8:	8b 45 98             	mov    -0x68(%ebp),%eax
f011acfb:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011acfe:	eb 2e                	jmp    f011ad2e <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011ad00:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011ad03:	8d 43 01             	lea    0x1(%ebx),%eax
f011ad06:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011ad09:	83 ec 0c             	sub    $0xc,%esp
f011ad0c:	ff 75 e8             	pushl  -0x18(%ebp)
f011ad0f:	e8 1b e8 fe ff       	call   f010952f <kheap_physical_address>
f011ad14:	83 c4 10             	add    $0x10,%esp
f011ad17:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011ad1e:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011ad21:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad24:	01 d0                	add    %edx,%eax
f011ad26:	05 00 10 00 00       	add    $0x1000,%eax
f011ad2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ad2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad31:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ad34:	72 ca                	jb     f011ad00 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011ad36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ad39:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011ad3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011ad43:	8b 45 98             	mov    -0x68(%ebp),%eax
f011ad46:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011ad49:	e9 ce 00 00 00       	jmp    f011ae1c <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ad4e:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ad53:	83 ec 04             	sub    $0x4,%esp
f011ad56:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011ad5c:	52                   	push   %edx
f011ad5d:	ff 75 e8             	pushl  -0x18(%ebp)
f011ad60:	50                   	push   %eax
f011ad61:	e8 89 d6 fe ff       	call   f01083ef <get_page_table>
f011ad66:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ad69:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ad6f:	85 c0                	test   %eax,%eax
f011ad71:	75 1e                	jne    f011ad91 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ad73:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad7a:	83 ec 04             	sub    $0x4,%esp
f011ad7d:	68 e0 e9 12 f0       	push   $0xf012e9e0
f011ad82:	68 e7 05 00 00       	push   $0x5e7
f011ad87:	68 73 c7 12 f0       	push   $0xf012c773
f011ad8c:	e8 a8 55 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011ad91:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ad94:	c1 e8 0c             	shr    $0xc,%eax
f011ad97:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ad9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ad9f:	eb 62                	jmp    f011ae03 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011ada1:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ada7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011adaa:	c1 e2 02             	shl    $0x2,%edx
f011adad:	01 d0                	add    %edx,%eax
f011adaf:	8b 00                	mov    (%eax),%eax
f011adb1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011adb6:	89 c2                	mov    %eax,%edx
f011adb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011adbb:	25 ff 0f 00 00       	and    $0xfff,%eax
f011adc0:	01 c2                	add    %eax,%edx
f011adc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011adc5:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011adcc:	39 c2                	cmp    %eax,%edx
f011adce:	74 1d                	je     f011aded <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011add0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011add4:	74 17                	je     f011aded <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011add6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011addd:	83 ec 0c             	sub    $0xc,%esp
f011ade0:	68 40 ea 12 f0       	push   $0xf012ea40
f011ade5:	e8 a1 61 fe ff       	call   f0100f8b <cprintf>
f011adea:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011aded:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011adf0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011adf3:	01 d0                	add    %edx,%eax
f011adf5:	05 00 10 00 00       	add    $0x1000,%eax
f011adfa:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011adfd:	ff 45 e4             	incl   -0x1c(%ebp)
f011ae00:	ff 45 f4             	incl   -0xc(%ebp)
f011ae03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ae06:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011ae09:	7d 11                	jge    f011ae1c <test_kheap_phys_addr+0x748>
f011ae0b:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011ae12:	7f 08                	jg     f011ae1c <test_kheap_phys_addr+0x748>
f011ae14:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ae17:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ae1a:	72 85                	jb     f011ada1 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011ae1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ae1f:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011ae22:	0f 82 26 ff ff ff    	jb     f011ad4e <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011ae28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ae2c:	74 04                	je     f011ae32 <test_kheap_phys_addr+0x75e>
f011ae2e:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011ae32:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011ae39:	83 ec 0c             	sub    $0xc,%esp
f011ae3c:	68 64 ea 12 f0       	push   $0xf012ea64
f011ae41:	e8 45 61 fe ff       	call   f0100f8b <cprintf>
f011ae46:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011ae49:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011ae50:	e9 b0 00 00 00       	jmp    f011af05 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011ae55:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ae58:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011ae5f:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011ae62:	83 ec 0c             	sub    $0xc,%esp
f011ae65:	ff 75 90             	pushl  -0x70(%ebp)
f011ae68:	e8 c2 e6 fe ff       	call   f010952f <kheap_physical_address>
f011ae6d:	83 c4 10             	add    $0x10,%esp
f011ae70:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011ae73:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ae78:	83 ec 04             	sub    $0x4,%esp
f011ae7b:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011ae81:	52                   	push   %edx
f011ae82:	ff 75 90             	pushl  -0x70(%ebp)
f011ae85:	50                   	push   %eax
f011ae86:	e8 64 d5 fe ff       	call   f01083ef <get_page_table>
f011ae8b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011ae8e:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ae94:	85 c0                	test   %eax,%eax
f011ae96:	75 1e                	jne    f011aeb6 <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011ae98:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae9f:	83 ec 04             	sub    $0x4,%esp
f011aea2:	68 b4 ea 12 f0       	push   $0xf012eab4
f011aea7:	68 04 06 00 00       	push   $0x604
f011aeac:	68 73 c7 12 f0       	push   $0xf012c773
f011aeb1:	e8 83 54 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011aeb6:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011aebc:	8b 55 90             	mov    -0x70(%ebp),%edx
f011aebf:	c1 ea 0c             	shr    $0xc,%edx
f011aec2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011aec8:	c1 e2 02             	shl    $0x2,%edx
f011aecb:	01 d0                	add    %edx,%eax
f011aecd:	8b 00                	mov    (%eax),%eax
f011aecf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011aed4:	89 c2                	mov    %eax,%edx
f011aed6:	8b 45 90             	mov    -0x70(%ebp),%eax
f011aed9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011aede:	01 d0                	add    %edx,%eax
f011aee0:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011aee3:	74 1d                	je     f011af02 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011aee5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aee9:	74 17                	je     f011af02 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011aeeb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aef2:	83 ec 0c             	sub    $0xc,%esp
f011aef5:	68 14 eb 12 f0       	push   $0xf012eb14
f011aefa:	e8 8c 60 fe ff       	call   f0100f8b <cprintf>
f011aeff:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011af02:	ff 45 e0             	incl   -0x20(%ebp)
f011af05:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011af09:	0f 8e 46 ff ff ff    	jle    f011ae55 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011af0f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011af13:	74 04                	je     f011af19 <test_kheap_phys_addr+0x845>
f011af15:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011af19:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011af20:	83 ec 0c             	sub    $0xc,%esp
f011af23:	68 38 eb 12 f0       	push   $0xf012eb38
f011af28:	e8 5e 60 fe ff       	call   f0100f8b <cprintf>
f011af2d:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011af30:	e8 75 33 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011af35:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011af38:	e8 68 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af3d:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011af40:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011af46:	83 ec 0c             	sub    $0xc,%esp
f011af49:	50                   	push   %eax
f011af4a:	e8 fa e4 fe ff       	call   f0109449 <kfree>
f011af4f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af52:	e8 4e 99 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011af57:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011af5a:	74 17                	je     f011af73 <test_kheap_phys_addr+0x89f>
f011af5c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af63:	83 ec 0c             	sub    $0xc,%esp
f011af66:	68 24 d6 12 f0       	push   $0xf012d624
f011af6b:	e8 1b 60 fe ff       	call   f0100f8b <cprintf>
f011af70:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011af73:	e8 32 33 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011af78:	89 c2                	mov    %eax,%edx
f011af7a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011af7d:	29 c2                	sub    %eax,%edx
f011af7f:	89 d0                	mov    %edx,%eax
f011af81:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011af86:	77 17                	ja     f011af9f <test_kheap_phys_addr+0x8cb>
f011af88:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af8f:	83 ec 0c             	sub    $0xc,%esp
f011af92:	68 60 eb 12 f0       	push   $0xf012eb60
f011af97:	e8 ef 5f fe ff       	call   f0100f8b <cprintf>
f011af9c:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011af9f:	e8 06 33 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011afa4:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011afa7:	e8 f9 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011afac:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011afaf:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011afb5:	83 ec 0c             	sub    $0xc,%esp
f011afb8:	50                   	push   %eax
f011afb9:	e8 8b e4 fe ff       	call   f0109449 <kfree>
f011afbe:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afc1:	e8 df 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011afc6:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011afc9:	74 17                	je     f011afe2 <test_kheap_phys_addr+0x90e>
f011afcb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afd2:	83 ec 0c             	sub    $0xc,%esp
f011afd5:	68 64 d7 12 f0       	push   $0xf012d764
f011afda:	e8 ac 5f fe ff       	call   f0100f8b <cprintf>
f011afdf:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011afe2:	e8 c3 32 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011afe7:	89 c2                	mov    %eax,%edx
f011afe9:	8b 45 88             	mov    -0x78(%ebp),%eax
f011afec:	29 c2                	sub    %eax,%edx
f011afee:	89 d0                	mov    %edx,%eax
f011aff0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aff5:	77 17                	ja     f011b00e <test_kheap_phys_addr+0x93a>
f011aff7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011affe:	83 ec 0c             	sub    $0xc,%esp
f011b001:	68 9c eb 12 f0       	push   $0xf012eb9c
f011b006:	e8 80 5f fe ff       	call   f0100f8b <cprintf>
f011b00b:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b00e:	e8 97 32 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b013:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b016:	e8 8a 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b01b:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b01e:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b024:	83 ec 0c             	sub    $0xc,%esp
f011b027:	50                   	push   %eax
f011b028:	e8 1c e4 fe ff       	call   f0109449 <kfree>
f011b02d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b030:	e8 70 98 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b035:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b038:	74 17                	je     f011b051 <test_kheap_phys_addr+0x97d>
f011b03a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b041:	83 ec 0c             	sub    $0xc,%esp
f011b044:	68 70 d8 12 f0       	push   $0xf012d870
f011b049:	e8 3d 5f fe ff       	call   f0100f8b <cprintf>
f011b04e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b051:	e8 54 32 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b056:	89 c2                	mov    %eax,%edx
f011b058:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b05b:	29 c2                	sub    %eax,%edx
f011b05d:	89 d0                	mov    %edx,%eax
f011b05f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b064:	77 17                	ja     f011b07d <test_kheap_phys_addr+0x9a9>
f011b066:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b06d:	83 ec 0c             	sub    $0xc,%esp
f011b070:	68 d8 eb 12 f0       	push   $0xf012ebd8
f011b075:	e8 11 5f fe ff       	call   f0100f8b <cprintf>
f011b07a:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011b07d:	83 ec 0c             	sub    $0xc,%esp
f011b080:	68 14 ec 12 f0       	push   $0xf012ec14
f011b085:	e8 01 5f fe ff       	call   f0100f8b <cprintf>
f011b08a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b08d:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011b094:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011b09b:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011b0a2:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011b0a5:	8b 15 d8 ed 17 f0    	mov    0xf017edd8,%edx
f011b0ab:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b0b1:	01 d0                	add    %edx,%eax
f011b0b3:	05 00 10 00 00       	add    $0x1000,%eax
f011b0b8:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b0be:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b0c4:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b0c7:	eb 25                	jmp    f011b0ee <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011b0c9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011b0cc:	8d 43 01             	lea    0x1(%ebx),%eax
f011b0cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b0d2:	83 ec 0c             	sub    $0xc,%esp
f011b0d5:	ff 75 d8             	pushl  -0x28(%ebp)
f011b0d8:	e8 52 e4 fe ff       	call   f010952f <kheap_physical_address>
f011b0dd:	83 c4 10             	add    $0x10,%esp
f011b0e0:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011b0e7:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011b0ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b0f1:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b0f4:	72 d3                	jb     f011b0c9 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011b0f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b0f9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011b0ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b106:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b10c:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b10f:	e9 f4 00 00 00       	jmp    f011b208 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b114:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011b119:	83 ec 04             	sub    $0x4,%esp
f011b11c:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b122:	52                   	push   %edx
f011b123:	ff 75 d8             	pushl  -0x28(%ebp)
f011b126:	50                   	push   %eax
f011b127:	e8 c3 d2 fe ff       	call   f01083ef <get_page_table>
f011b12c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b12f:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b135:	85 c0                	test   %eax,%eax
f011b137:	75 24                	jne    f011b15d <test_kheap_phys_addr+0xa89>
				if (correct)
f011b139:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b13d:	74 1e                	je     f011b15d <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b13f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b146:	83 ec 04             	sub    $0x4,%esp
f011b149:	68 64 ec 12 f0       	push   $0xf012ec64
f011b14e:	68 42 06 00 00       	push   $0x642
f011b153:	68 73 c7 12 f0       	push   $0xf012c773
f011b158:	e8 dc 51 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b15d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b160:	c1 e8 0c             	shr    $0xc,%eax
f011b163:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b168:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b16b:	eb 7b                	jmp    f011b1e8 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011b16d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011b174:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b17a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b17d:	c1 e2 02             	shl    $0x2,%edx
f011b180:	01 d0                	add    %edx,%eax
f011b182:	8b 00                	mov    (%eax),%eax
f011b184:	83 e0 01             	and    $0x1,%eax
f011b187:	85 c0                	test   %eax,%eax
f011b189:	74 24                	je     f011b1af <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011b18b:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b191:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b194:	c1 e2 02             	shl    $0x2,%edx
f011b197:	01 d0                	add    %edx,%eax
f011b199:	8b 00                	mov    (%eax),%eax
f011b19b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b1a0:	89 c2                	mov    %eax,%edx
f011b1a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b1a5:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b1aa:	01 d0                	add    %edx,%eax
f011b1ac:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011b1af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b1b2:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011b1b9:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011b1bc:	74 1d                	je     f011b1db <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b1be:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b1c2:	74 17                	je     f011b1db <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011b1c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1cb:	83 ec 0c             	sub    $0xc,%esp
f011b1ce:	68 c4 ec 12 f0       	push   $0xf012ecc4
f011b1d3:	e8 b3 5d fe ff       	call   f0100f8b <cprintf>
f011b1d8:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011b1db:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011b1e2:	ff 45 d4             	incl   -0x2c(%ebp)
f011b1e5:	ff 45 f4             	incl   -0xc(%ebp)
f011b1e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b1eb:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011b1f1:	7d 15                	jge    f011b208 <test_kheap_phys_addr+0xb34>
f011b1f3:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b1fa:	7f 0c                	jg     f011b208 <test_kheap_phys_addr+0xb34>
f011b1fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b1ff:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b202:	0f 82 65 ff ff ff    	jb     f011b16d <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b208:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b20b:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011b20e:	0f 82 00 ff ff ff    	jb     f011b114 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b214:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b218:	74 04                	je     f011b21e <test_kheap_phys_addr+0xb4a>
f011b21a:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011b21e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011b225:	83 ec 0c             	sub    $0xc,%esp
f011b228:	68 e8 ec 12 f0       	push   $0xf012ece8
f011b22d:	e8 59 5d fe ff       	call   f0100f8b <cprintf>
f011b232:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011b235:	83 ec 0c             	sub    $0xc,%esp
f011b238:	6a 00                	push   $0x0
f011b23a:	e8 77 de fe ff       	call   f01090b6 <sbrk>
f011b23f:	83 c4 10             	add    $0x10,%esp
f011b242:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b247:	77 17                	ja     f011b260 <test_kheap_phys_addr+0xb8c>
f011b249:	83 ec 04             	sub    $0x4,%esp
f011b24c:	68 40 ed 12 f0       	push   $0xf012ed40
f011b251:	68 5d 06 00 00       	push   $0x65d
f011b256:	68 73 c7 12 f0       	push   $0xf012c773
f011b25b:	e8 d9 50 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b260:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011b267:	e9 af 00 00 00       	jmp    f011b31b <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011b26c:	83 ec 0c             	sub    $0xc,%esp
f011b26f:	ff 75 d0             	pushl  -0x30(%ebp)
f011b272:	e8 b8 e2 fe ff       	call   f010952f <kheap_physical_address>
f011b277:	83 c4 10             	add    $0x10,%esp
f011b27a:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b280:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011b285:	83 ec 04             	sub    $0x4,%esp
f011b288:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011b28e:	52                   	push   %edx
f011b28f:	ff 75 d0             	pushl  -0x30(%ebp)
f011b292:	50                   	push   %eax
f011b293:	e8 57 d1 fe ff       	call   f01083ef <get_page_table>
f011b298:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b29b:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b2a1:	85 c0                	test   %eax,%eax
f011b2a3:	75 24                	jne    f011b2c9 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011b2a5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b2a9:	74 1e                	je     f011b2c9 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b2ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2b2:	83 ec 04             	sub    $0x4,%esp
f011b2b5:	68 5c ed 12 f0       	push   $0xf012ed5c
f011b2ba:	68 65 06 00 00       	push   $0x665
f011b2bf:	68 73 c7 12 f0       	push   $0xf012c773
f011b2c4:	e8 70 50 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011b2c9:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011b2cf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b2d2:	c1 ea 0c             	shr    $0xc,%edx
f011b2d5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b2db:	c1 e2 02             	shl    $0x2,%edx
f011b2de:	01 d0                	add    %edx,%eax
f011b2e0:	8b 00                	mov    (%eax),%eax
f011b2e2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b2e7:	89 c2                	mov    %eax,%edx
f011b2e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b2ec:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b2f1:	01 d0                	add    %edx,%eax
f011b2f3:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b2f9:	74 1d                	je     f011b318 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011b2fb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b2ff:	74 17                	je     f011b318 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011b301:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b308:	83 ec 0c             	sub    $0xc,%esp
f011b30b:	68 bc ed 12 f0       	push   $0xf012edbc
f011b310:	e8 76 5c fe ff       	call   f0100f8b <cprintf>
f011b315:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b318:	ff 45 d0             	incl   -0x30(%ebp)
f011b31b:	83 ec 0c             	sub    $0xc,%esp
f011b31e:	6a 00                	push   $0x0
f011b320:	e8 91 dd fe ff       	call   f01090b6 <sbrk>
f011b325:	83 c4 10             	add    $0x10,%esp
f011b328:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011b32b:	0f 87 3b ff ff ff    	ja     f011b26c <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011b331:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b335:	74 04                	je     f011b33b <test_kheap_phys_addr+0xc67>
f011b337:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b33b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011b342:	83 ec 0c             	sub    $0xc,%esp
f011b345:	68 e0 ed 12 f0       	push   $0xf012ede0
f011b34a:	e8 3c 5c fe ff       	call   f0100f8b <cprintf>
f011b34f:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011b352:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011b359:	10 00 f9 
		i = 0;
f011b35c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b363:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b369:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b36c:	eb 0a                	jmp    f011b378 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011b36e:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011b371:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011b378:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011b37f:	76 ed                	jbe    f011b36e <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011b381:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b384:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011b38a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b391:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b397:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011b39a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011b3a1:	e9 cb 00 00 00       	jmp    f011b471 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011b3a6:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011b3a9:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011b3ae:	83 ec 04             	sub    $0x4,%esp
f011b3b1:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011b3b7:	51                   	push   %ecx
f011b3b8:	52                   	push   %edx
f011b3b9:	50                   	push   %eax
f011b3ba:	e8 30 d0 fe ff       	call   f01083ef <get_page_table>
f011b3bf:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b3c2:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011b3c8:	85 c0                	test   %eax,%eax
f011b3ca:	75 24                	jne    f011b3f0 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011b3cc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b3d0:	74 1e                	je     f011b3f0 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b3d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3d9:	83 ec 04             	sub    $0x4,%esp
f011b3dc:	68 1c ee 12 f0       	push   $0xf012ee1c
f011b3e1:	68 87 06 00 00       	push   $0x687
f011b3e6:	68 73 c7 12 f0       	push   $0xf012c773
f011b3eb:	e8 49 4f fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011b3f0:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011b3f7:	eb 59                	jmp    f011b452 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011b3f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b3fc:	c1 e0 0c             	shl    $0xc,%eax
f011b3ff:	89 c2                	mov    %eax,%edx
f011b401:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011b407:	01 d0                	add    %edx,%eax
f011b409:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011b40f:	83 ec 0c             	sub    $0xc,%esp
f011b412:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b418:	e8 12 e1 fe ff       	call   f010952f <kheap_physical_address>
f011b41d:	83 c4 10             	add    $0x10,%esp
f011b420:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011b426:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011b42d:	74 1d                	je     f011b44c <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011b42f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b433:	74 17                	je     f011b44c <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011b435:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b43c:	83 ec 0c             	sub    $0xc,%esp
f011b43f:	68 7c ee 12 f0       	push   $0xf012ee7c
f011b444:	e8 42 5b fe ff       	call   f0100f8b <cprintf>
f011b449:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011b44c:	ff 45 c8             	incl   -0x38(%ebp)
f011b44f:	ff 45 f4             	incl   -0xc(%ebp)
f011b452:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b455:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011b45b:	7d 09                	jge    f011b466 <test_kheap_phys_addr+0xd92>
f011b45d:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011b464:	7e 93                	jle    f011b3f9 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011b466:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011b46d:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011b471:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011b475:	0f 88 2b ff ff ff    	js     f011b3a6 <test_kheap_phys_addr+0xcd2>
f011b47b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011b47f:	7f 0d                	jg     f011b48e <test_kheap_phys_addr+0xdba>
f011b481:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011b488:	0f 86 18 ff ff ff    	jbe    f011b3a6 <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011b48e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b492:	74 04                	je     f011b498 <test_kheap_phys_addr+0xdc4>
f011b494:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011b498:	83 ec 08             	sub    $0x8,%esp
f011b49b:	ff 75 f0             	pushl  -0x10(%ebp)
f011b49e:	68 a0 ee 12 f0       	push   $0xf012eea0
f011b4a3:	e8 e3 5a fe ff       	call   f0100f8b <cprintf>
f011b4a8:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b4ab:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b4b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b4b3:	5b                   	pop    %ebx
f011b4b4:	5f                   	pop    %edi
f011b4b5:	5d                   	pop    %ebp
f011b4b6:	c3                   	ret    

f011b4b7 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011b4b7:	55                   	push   %ebp
f011b4b8:	89 e5                	mov    %esp,%ebp
f011b4ba:	57                   	push   %edi
f011b4bb:	56                   	push   %esi
f011b4bc:	53                   	push   %ebx
f011b4bd:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011b4c3:	89 e0                	mov    %esp,%eax
f011b4c5:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b4c7:	83 ec 0c             	sub    $0xc,%esp
f011b4ca:	68 28 a8 12 f0       	push   $0xf012a828
f011b4cf:	e8 b7 5a fe ff       	call   f0100f8b <cprintf>
f011b4d4:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b4d7:	83 ec 0c             	sub    $0xc,%esp
f011b4da:	68 58 a8 12 f0       	push   $0xf012a858
f011b4df:	e8 a7 5a fe ff       	call   f0100f8b <cprintf>
f011b4e4:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b4e7:	83 ec 0c             	sub    $0xc,%esp
f011b4ea:	68 28 a8 12 f0       	push   $0xf012a828
f011b4ef:	e8 97 5a fe ff       	call   f0100f8b <cprintf>
f011b4f4:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b4f7:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011b4fb:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011b4ff:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011b505:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011b50b:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b512:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b519:	e8 8c 2d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b51e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011b521:	83 ec 0c             	sub    $0xc,%esp
f011b524:	68 7c e5 12 f0       	push   $0xf012e57c
f011b529:	e8 5d 5a fe ff       	call   f0100f8b <cprintf>
f011b52e:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b531:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011b537:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b53c:	b8 00 00 00 00       	mov    $0x0,%eax
f011b541:	89 d7                	mov    %edx,%edi
f011b543:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b545:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011b54b:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b550:	b8 00 00 00 00       	mov    $0x0,%eax
f011b555:	89 d7                	mov    %edx,%edi
f011b557:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011b559:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011b560:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011b567:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011b56d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b572:	b8 00 00 00 00       	mov    $0x0,%eax
f011b577:	89 d7                	mov    %edx,%edi
f011b579:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b57b:	e8 2a 2d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b580:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b583:	e8 1d 93 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b588:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b58b:	83 ec 0c             	sub    $0xc,%esp
f011b58e:	68 00 fc 1f 00       	push   $0x1ffc00
f011b593:	e8 51 dc fe ff       	call   f01091e9 <kmalloc>
f011b598:	83 c4 10             	add    $0x10,%esp
f011b59b:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b5a1:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b5a7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b5ac:	74 17                	je     f011b5c5 <test_kheap_virt_addr+0x10e>
f011b5ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b5b5:	83 ec 0c             	sub    $0xc,%esp
f011b5b8:	68 20 c9 12 f0       	push   $0xf012c920
f011b5bd:	e8 c9 59 fe ff       	call   f0100f8b <cprintf>
f011b5c2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5c5:	e8 db 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b5ca:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b5cd:	74 17                	je     f011b5e6 <test_kheap_virt_addr+0x12f>
f011b5cf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b5d6:	83 ec 0c             	sub    $0xc,%esp
f011b5d9:	68 74 c9 12 f0       	push   $0xf012c974
f011b5de:	e8 a8 59 fe ff       	call   f0100f8b <cprintf>
f011b5e3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b5e6:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b5e9:	e8 bc 2c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b5ee:	29 c3                	sub    %eax,%ebx
f011b5f0:	89 d8                	mov    %ebx,%eax
f011b5f2:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b5f7:	77 17                	ja     f011b610 <test_kheap_virt_addr+0x159>
f011b5f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b600:	83 ec 0c             	sub    $0xc,%esp
f011b603:	68 e4 c9 12 f0       	push   $0xf012c9e4
f011b608:	e8 7e 59 fe ff       	call   f0100f8b <cprintf>
f011b60d:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b610:	e8 95 2c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b615:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b618:	e8 88 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b61d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b620:	83 ec 0c             	sub    $0xc,%esp
f011b623:	68 00 fc 1f 00       	push   $0x1ffc00
f011b628:	e8 bc db fe ff       	call   f01091e9 <kmalloc>
f011b62d:	83 c4 10             	add    $0x10,%esp
f011b630:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b636:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b63c:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b641:	74 17                	je     f011b65a <test_kheap_virt_addr+0x1a3>
f011b643:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b64a:	83 ec 0c             	sub    $0xc,%esp
f011b64d:	68 2c ca 12 f0       	push   $0xf012ca2c
f011b652:	e8 34 59 fe ff       	call   f0100f8b <cprintf>
f011b657:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b65a:	e8 46 92 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b65f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b662:	74 17                	je     f011b67b <test_kheap_virt_addr+0x1c4>
f011b664:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b66b:	83 ec 0c             	sub    $0xc,%esp
f011b66e:	68 80 ca 12 f0       	push   $0xf012ca80
f011b673:	e8 13 59 fe ff       	call   f0100f8b <cprintf>
f011b678:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b67b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b67e:	e8 27 2c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b683:	29 c3                	sub    %eax,%ebx
f011b685:	89 d8                	mov    %ebx,%eax
f011b687:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b68c:	77 17                	ja     f011b6a5 <test_kheap_virt_addr+0x1ee>
f011b68e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b695:	83 ec 0c             	sub    $0xc,%esp
f011b698:	68 f0 ca 12 f0       	push   $0xf012caf0
f011b69d:	e8 e9 58 fe ff       	call   f0100f8b <cprintf>
f011b6a2:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011b6a5:	e8 00 2c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b6aa:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b6ad:	e8 f3 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b6b2:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011b6b5:	83 ec 0c             	sub    $0xc,%esp
f011b6b8:	68 00 04 00 00       	push   $0x400
f011b6bd:	e8 27 db fe ff       	call   f01091e9 <kmalloc>
f011b6c2:	83 c4 10             	add    $0x10,%esp
f011b6c5:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011b6cb:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b6d1:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b6d6:	76 28                	jbe    f011b700 <test_kheap_virt_addr+0x249>
f011b6d8:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011b6de:	83 ec 0c             	sub    $0xc,%esp
f011b6e1:	6a 00                	push   $0x0
f011b6e3:	e8 ce d9 fe ff       	call   f01090b6 <sbrk>
f011b6e8:	83 c4 10             	add    $0x10,%esp
f011b6eb:	39 c3                	cmp    %eax,%ebx
f011b6ed:	73 11                	jae    f011b700 <test_kheap_virt_addr+0x249>
f011b6ef:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b6f5:	89 c2                	mov    %eax,%edx
f011b6f7:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b6fc:	39 c2                	cmp    %eax,%edx
f011b6fe:	72 17                	jb     f011b717 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b700:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b707:	83 ec 0c             	sub    $0xc,%esp
f011b70a:	68 ac e5 12 f0       	push   $0xf012e5ac
f011b70f:	e8 77 58 fe ff       	call   f0100f8b <cprintf>
f011b714:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b717:	e8 89 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b71c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b71f:	74 17                	je     f011b738 <test_kheap_virt_addr+0x281>
f011b721:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b728:	83 ec 0c             	sub    $0xc,%esp
f011b72b:	68 8c cb 12 f0       	push   $0xf012cb8c
f011b730:	e8 56 58 fe ff       	call   f0100f8b <cprintf>
f011b735:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b738:	e8 6d 2b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b73d:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b740:	e8 60 91 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b745:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011b748:	83 ec 0c             	sub    $0xc,%esp
f011b74b:	68 00 08 00 00       	push   $0x800
f011b750:	e8 94 da fe ff       	call   f01091e9 <kmalloc>
f011b755:	83 c4 10             	add    $0x10,%esp
f011b758:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011b75e:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b764:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b769:	76 28                	jbe    f011b793 <test_kheap_virt_addr+0x2dc>
f011b76b:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011b771:	83 ec 0c             	sub    $0xc,%esp
f011b774:	6a 00                	push   $0x0
f011b776:	e8 3b d9 fe ff       	call   f01090b6 <sbrk>
f011b77b:	83 c4 10             	add    $0x10,%esp
f011b77e:	39 c3                	cmp    %eax,%ebx
f011b780:	73 11                	jae    f011b793 <test_kheap_virt_addr+0x2dc>
f011b782:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b788:	89 c2                	mov    %eax,%edx
f011b78a:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b78f:	39 c2                	cmp    %eax,%edx
f011b791:	72 17                	jb     f011b7aa <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b793:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b79a:	83 ec 0c             	sub    $0xc,%esp
f011b79d:	68 38 e6 12 f0       	push   $0xf012e638
f011b7a2:	e8 e4 57 fe ff       	call   f0100f8b <cprintf>
f011b7a7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b7aa:	e8 f6 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b7af:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b7b2:	74 17                	je     f011b7cb <test_kheap_virt_addr+0x314>
f011b7b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7bb:	83 ec 0c             	sub    $0xc,%esp
f011b7be:	68 98 cc 12 f0       	push   $0xf012cc98
f011b7c3:	e8 c3 57 fe ff       	call   f0100f8b <cprintf>
f011b7c8:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b7cb:	e8 da 2a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b7d0:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b7d3:	e8 cd 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b7d8:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011b7db:	83 ec 0c             	sub    $0xc,%esp
f011b7de:	68 00 06 00 00       	push   $0x600
f011b7e3:	e8 01 da fe ff       	call   f01091e9 <kmalloc>
f011b7e8:	83 c4 10             	add    $0x10,%esp
f011b7eb:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011b7f1:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b7f7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011b7fc:	76 28                	jbe    f011b826 <test_kheap_virt_addr+0x36f>
f011b7fe:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011b804:	83 ec 0c             	sub    $0xc,%esp
f011b807:	6a 00                	push   $0x0
f011b809:	e8 a8 d8 fe ff       	call   f01090b6 <sbrk>
f011b80e:	83 c4 10             	add    $0x10,%esp
f011b811:	39 c3                	cmp    %eax,%ebx
f011b813:	73 11                	jae    f011b826 <test_kheap_virt_addr+0x36f>
f011b815:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011b81b:	89 c2                	mov    %eax,%edx
f011b81d:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011b822:	39 c2                	cmp    %eax,%edx
f011b824:	72 17                	jb     f011b83d <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011b826:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b82d:	83 ec 0c             	sub    $0xc,%esp
f011b830:	68 c4 e6 12 f0       	push   $0xf012e6c4
f011b835:	e8 51 57 fe ff       	call   f0100f8b <cprintf>
f011b83a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b83d:	e8 63 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b842:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b845:	74 17                	je     f011b85e <test_kheap_virt_addr+0x3a7>
f011b847:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b84e:	83 ec 0c             	sub    $0xc,%esp
f011b851:	68 a4 cd 12 f0       	push   $0xf012cda4
f011b856:	e8 30 57 fe ff       	call   f0100f8b <cprintf>
f011b85b:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011b85e:	e8 47 2a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b863:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b866:	e8 3a 90 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b86b:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011b86e:	83 ec 0c             	sub    $0xc,%esp
f011b871:	68 00 1c 00 00       	push   $0x1c00
f011b876:	e8 6e d9 fe ff       	call   f01091e9 <kmalloc>
f011b87b:	83 c4 10             	add    $0x10,%esp
f011b87e:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b884:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011b88a:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011b88f:	74 17                	je     f011b8a8 <test_kheap_virt_addr+0x3f1>
f011b891:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b898:	83 ec 0c             	sub    $0xc,%esp
f011b89b:	68 5c ce 12 f0       	push   $0xf012ce5c
f011b8a0:	e8 e6 56 fe ff       	call   f0100f8b <cprintf>
f011b8a5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b8a8:	e8 f8 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b8ad:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b8b0:	74 17                	je     f011b8c9 <test_kheap_virt_addr+0x412>
f011b8b2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8b9:	83 ec 0c             	sub    $0xc,%esp
f011b8bc:	68 b0 ce 12 f0       	push   $0xf012ceb0
f011b8c1:	e8 c5 56 fe ff       	call   f0100f8b <cprintf>
f011b8c6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b8c9:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b8cc:	e8 d9 29 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b8d1:	29 c3                	sub    %eax,%ebx
f011b8d3:	89 d8                	mov    %ebx,%eax
f011b8d5:	83 f8 01             	cmp    $0x1,%eax
f011b8d8:	77 17                	ja     f011b8f1 <test_kheap_virt_addr+0x43a>
f011b8da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8e1:	83 ec 0c             	sub    $0xc,%esp
f011b8e4:	68 20 cf 12 f0       	push   $0xf012cf20
f011b8e9:	e8 9d 56 fe ff       	call   f0100f8b <cprintf>
f011b8ee:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011b8f1:	e8 b4 29 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b8f6:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b8f9:	e8 a7 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b8fe:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011b901:	83 ec 0c             	sub    $0xc,%esp
f011b904:	68 00 fc 2f 00       	push   $0x2ffc00
f011b909:	e8 db d8 fe ff       	call   f01091e9 <kmalloc>
f011b90e:	83 c4 10             	add    $0x10,%esp
f011b911:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b917:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011b91d:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011b922:	74 17                	je     f011b93b <test_kheap_virt_addr+0x484>
f011b924:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b92b:	83 ec 0c             	sub    $0xc,%esp
f011b92e:	68 50 e7 12 f0       	push   $0xf012e750
f011b933:	e8 53 56 fe ff       	call   f0100f8b <cprintf>
f011b938:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b93b:	e8 65 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b940:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b943:	74 17                	je     f011b95c <test_kheap_virt_addr+0x4a5>
f011b945:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b94c:	83 ec 0c             	sub    $0xc,%esp
f011b94f:	68 f4 cf 12 f0       	push   $0xf012cff4
f011b954:	e8 32 56 fe ff       	call   f0100f8b <cprintf>
f011b959:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b95c:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b95f:	e8 46 29 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b964:	29 c3                	sub    %eax,%ebx
f011b966:	89 d8                	mov    %ebx,%eax
f011b968:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b96d:	77 17                	ja     f011b986 <test_kheap_virt_addr+0x4cf>
f011b96f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b976:	83 ec 0c             	sub    $0xc,%esp
f011b979:	68 a4 e7 12 f0       	push   $0xf012e7a4
f011b97e:	e8 08 56 fe ff       	call   f0100f8b <cprintf>
f011b983:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b986:	e8 1f 29 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b98b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b98e:	e8 12 8f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b993:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011b996:	83 ec 0c             	sub    $0xc,%esp
f011b999:	68 00 fc 5f 00       	push   $0x5ffc00
f011b99e:	e8 46 d8 fe ff       	call   f01091e9 <kmalloc>
f011b9a3:	83 c4 10             	add    $0x10,%esp
f011b9a6:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b9ac:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b9b2:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011b9b7:	74 17                	je     f011b9d0 <test_kheap_virt_addr+0x519>
f011b9b9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9c0:	83 ec 0c             	sub    $0xc,%esp
f011b9c3:	68 ec e7 12 f0       	push   $0xf012e7ec
f011b9c8:	e8 be 55 fe ff       	call   f0100f8b <cprintf>
f011b9cd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b9d0:	e8 d0 8e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011b9d5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b9d8:	74 17                	je     f011b9f1 <test_kheap_virt_addr+0x53a>
f011b9da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9e1:	83 ec 0c             	sub    $0xc,%esp
f011b9e4:	68 f0 d0 12 f0       	push   $0xf012d0f0
f011b9e9:	e8 9d 55 fe ff       	call   f0100f8b <cprintf>
f011b9ee:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b9f1:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b9f4:	e8 b1 28 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011b9f9:	29 c3                	sub    %eax,%ebx
f011b9fb:	89 d8                	mov    %ebx,%eax
f011b9fd:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ba02:	77 17                	ja     f011ba1b <test_kheap_virt_addr+0x564>
f011ba04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba0b:	83 ec 0c             	sub    $0xc,%esp
f011ba0e:	68 40 e8 12 f0       	push   $0xf012e840
f011ba13:	e8 73 55 fe ff       	call   f0100f8b <cprintf>
f011ba18:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011ba1b:	e8 8a 28 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ba20:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ba23:	e8 7d 8e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ba28:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011ba2b:	83 ec 0c             	sub    $0xc,%esp
f011ba2e:	68 00 38 00 00       	push   $0x3800
f011ba33:	e8 b1 d7 fe ff       	call   f01091e9 <kmalloc>
f011ba38:	83 c4 10             	add    $0x10,%esp
f011ba3b:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ba41:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011ba47:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011ba4c:	74 17                	je     f011ba65 <test_kheap_virt_addr+0x5ae>
f011ba4e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba55:	83 ec 0c             	sub    $0xc,%esp
f011ba58:	68 88 e8 12 f0       	push   $0xf012e888
f011ba5d:	e8 29 55 fe ff       	call   f0100f8b <cprintf>
f011ba62:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba65:	e8 3b 8e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ba6a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ba6d:	74 17                	je     f011ba86 <test_kheap_virt_addr+0x5cf>
f011ba6f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba76:	83 ec 0c             	sub    $0xc,%esp
f011ba79:	68 dc e8 12 f0       	push   $0xf012e8dc
f011ba7e:	e8 08 55 fe ff       	call   f0100f8b <cprintf>
f011ba83:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ba86:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ba89:	e8 1c 28 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ba8e:	29 c3                	sub    %eax,%ebx
f011ba90:	89 d8                	mov    %ebx,%eax
f011ba92:	83 f8 03             	cmp    $0x3,%eax
f011ba95:	77 17                	ja     f011baae <test_kheap_virt_addr+0x5f7>
f011ba97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba9e:	83 ec 0c             	sub    $0xc,%esp
f011baa1:	68 4c e9 12 f0       	push   $0xf012e94c
f011baa6:	e8 e0 54 fe ff       	call   f0100f8b <cprintf>
f011baab:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011baae:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011bab5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011bab8:	c1 e8 0c             	shr    $0xc,%eax
f011babb:	89 c2                	mov    %eax,%edx
f011babd:	4a                   	dec    %edx
f011babe:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011bac1:	c1 e0 02             	shl    $0x2,%eax
f011bac4:	8d 50 03             	lea    0x3(%eax),%edx
f011bac7:	b8 10 00 00 00       	mov    $0x10,%eax
f011bacc:	48                   	dec    %eax
f011bacd:	01 d0                	add    %edx,%eax
f011bacf:	bf 10 00 00 00       	mov    $0x10,%edi
f011bad4:	ba 00 00 00 00       	mov    $0x0,%edx
f011bad9:	f7 f7                	div    %edi
f011badb:	6b c0 10             	imul   $0x10,%eax,%eax
f011bade:	29 c4                	sub    %eax,%esp
f011bae0:	89 e0                	mov    %esp,%eax
f011bae2:	83 c0 03             	add    $0x3,%eax
f011bae5:	c1 e8 02             	shr    $0x2,%eax
f011bae8:	c1 e0 02             	shl    $0x2,%eax
f011baeb:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011baee:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011baf1:	c1 e8 0c             	shr    $0xc,%eax
f011baf4:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011baf7:	83 ec 0c             	sub    $0xc,%esp
f011bafa:	68 d4 ee 12 f0       	push   $0xf012eed4
f011baff:	e8 87 54 fe ff       	call   f0100f8b <cprintf>
f011bb04:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011bb07:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011bb0e:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011bb13:	05 00 10 00 00       	add    $0x1000,%eax
f011bb18:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011bb1b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011bb22:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011bb25:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011bb28:	e9 2d 01 00 00       	jmp    f011bc5a <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bb2d:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011bb32:	83 ec 04             	sub    $0x4,%esp
f011bb35:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011bb3b:	52                   	push   %edx
f011bb3c:	ff 75 dc             	pushl  -0x24(%ebp)
f011bb3f:	50                   	push   %eax
f011bb40:	e8 aa c8 fe ff       	call   f01083ef <get_page_table>
f011bb45:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bb48:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011bb4e:	85 c0                	test   %eax,%eax
f011bb50:	75 1e                	jne    f011bb70 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bb52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb59:	83 ec 04             	sub    $0x4,%esp
f011bb5c:	68 e0 e9 12 f0       	push   $0xf012e9e0
f011bb61:	68 26 07 00 00       	push   $0x726
f011bb66:	68 73 c7 12 f0       	push   $0xf012c773
f011bb6b:	e8 c9 47 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011bb70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bb73:	c1 e8 0c             	shr    $0xc,%eax
f011bb76:	25 ff 03 00 00       	and    $0x3ff,%eax
f011bb7b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011bb7e:	e9 ba 00 00 00       	jmp    f011bc3d <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011bb83:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011bb86:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011bb89:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011bb8f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011bb92:	c1 e2 02             	shl    $0x2,%edx
f011bb95:	01 d0                	add    %edx,%eax
f011bb97:	8b 00                	mov    (%eax),%eax
f011bb99:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bb9e:	89 c2                	mov    %eax,%edx
f011bba0:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bba3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011bba6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bba9:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011bbac:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bbaf:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bbb2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011bbb5:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bbb8:	83 ec 0c             	sub    $0xc,%esp
f011bbbb:	50                   	push   %eax
f011bbbc:	e8 cb d9 fe ff       	call   f010958c <kheap_virtual_address>
f011bbc1:	83 c4 10             	add    $0x10,%esp
f011bbc4:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011bbc7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011bbca:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bbcd:	01 d0                	add    %edx,%eax
f011bbcf:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011bbd2:	74 5c                	je     f011bc30 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011bbd4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bbd8:	74 56                	je     f011bc30 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011bbda:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bbdd:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011bbe0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bbe3:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011bbe9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011bbec:	c1 e1 02             	shl    $0x2,%ecx
f011bbef:	01 ca                	add    %ecx,%edx
f011bbf1:	8b 12                	mov    (%edx),%edx
f011bbf3:	89 d1                	mov    %edx,%ecx
f011bbf5:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011bbfb:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011bbfe:	8b 55 90             	mov    -0x70(%ebp),%edx
f011bc01:	01 da                	add    %ebx,%edx
f011bc03:	83 ec 0c             	sub    $0xc,%esp
f011bc06:	50                   	push   %eax
f011bc07:	51                   	push   %ecx
f011bc08:	52                   	push   %edx
f011bc09:	ff 75 8c             	pushl  -0x74(%ebp)
f011bc0c:	68 20 ef 12 f0       	push   $0xf012ef20
f011bc11:	e8 75 53 fe ff       	call   f0100f8b <cprintf>
f011bc16:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011bc19:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc20:	83 ec 0c             	sub    $0xc,%esp
f011bc23:	68 64 ef 12 f0       	push   $0xf012ef64
f011bc28:	e8 5e 53 fe ff       	call   f0100f8b <cprintf>
f011bc2d:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011bc30:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011bc37:	ff 45 d4             	incl   -0x2c(%ebp)
f011bc3a:	ff 45 d8             	incl   -0x28(%ebp)
f011bc3d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011bc40:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011bc43:	7d 15                	jge    f011bc5a <test_kheap_virt_addr+0x7a3>
f011bc45:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011bc4c:	7f 0c                	jg     f011bc5a <test_kheap_virt_addr+0x7a3>
f011bc4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bc51:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011bc54:	0f 82 29 ff ff ff    	jb     f011bb83 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bc5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011bc5d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011bc60:	0f 82 c7 fe ff ff    	jb     f011bb2d <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011bc66:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bc6a:	74 04                	je     f011bc70 <test_kheap_virt_addr+0x7b9>
f011bc6c:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011bc70:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011bc77:	83 ec 0c             	sub    $0xc,%esp
f011bc7a:	68 88 ef 12 f0       	push   $0xf012ef88
f011bc7f:	e8 07 53 fe ff       	call   f0100f8b <cprintf>
f011bc84:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011bc87:	e8 1e 26 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011bc8c:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011bc8f:	e8 11 8c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bc94:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011bc97:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bc9d:	83 ec 0c             	sub    $0xc,%esp
f011bca0:	50                   	push   %eax
f011bca1:	e8 a3 d7 fe ff       	call   f0109449 <kfree>
f011bca6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bca9:	e8 f7 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bcae:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bcb1:	74 17                	je     f011bcca <test_kheap_virt_addr+0x813>
f011bcb3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcba:	83 ec 0c             	sub    $0xc,%esp
f011bcbd:	68 b0 ef 12 f0       	push   $0xf012efb0
f011bcc2:	e8 c4 52 fe ff       	call   f0100f8b <cprintf>
f011bcc7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bcca:	e8 db 25 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011bccf:	89 c2                	mov    %eax,%edx
f011bcd1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bcd4:	29 c2                	sub    %eax,%edx
f011bcd6:	89 d0                	mov    %edx,%eax
f011bcd8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bcdd:	77 17                	ja     f011bcf6 <test_kheap_virt_addr+0x83f>
f011bcdf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bce6:	83 ec 0c             	sub    $0xc,%esp
f011bce9:	68 20 f0 12 f0       	push   $0xf012f020
f011bcee:	e8 98 52 fe ff       	call   f0100f8b <cprintf>
f011bcf3:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011bcf6:	e8 af 25 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011bcfb:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bcfe:	e8 a2 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd03:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011bd06:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bd0c:	83 ec 0c             	sub    $0xc,%esp
f011bd0f:	50                   	push   %eax
f011bd10:	e8 34 d7 fe ff       	call   f0109449 <kfree>
f011bd15:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd18:	e8 88 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd1d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bd20:	74 17                	je     f011bd39 <test_kheap_virt_addr+0x882>
f011bd22:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd29:	83 ec 0c             	sub    $0xc,%esp
f011bd2c:	68 5c f0 12 f0       	push   $0xf012f05c
f011bd31:	e8 55 52 fe ff       	call   f0100f8b <cprintf>
f011bd36:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bd39:	e8 6c 25 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011bd3e:	89 c2                	mov    %eax,%edx
f011bd40:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bd43:	29 c2                	sub    %eax,%edx
f011bd45:	89 d0                	mov    %edx,%eax
f011bd47:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011bd4c:	77 17                	ja     f011bd65 <test_kheap_virt_addr+0x8ae>
f011bd4e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd55:	83 ec 0c             	sub    $0xc,%esp
f011bd58:	68 cc f0 12 f0       	push   $0xf012f0cc
f011bd5d:	e8 29 52 fe ff       	call   f0100f8b <cprintf>
f011bd62:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bd65:	e8 40 25 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011bd6a:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bd6d:	e8 33 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd72:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011bd75:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011bd7b:	83 ec 0c             	sub    $0xc,%esp
f011bd7e:	50                   	push   %eax
f011bd7f:	e8 c5 d6 fe ff       	call   f0109449 <kfree>
f011bd84:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd87:	e8 19 8b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011bd8c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011bd8f:	74 17                	je     f011bda8 <test_kheap_virt_addr+0x8f1>
f011bd91:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd98:	83 ec 0c             	sub    $0xc,%esp
f011bd9b:	68 08 f1 12 f0       	push   $0xf012f108
f011bda0:	e8 e6 51 fe ff       	call   f0100f8b <cprintf>
f011bda5:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011bda8:	e8 fd 24 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011bdad:	89 c2                	mov    %eax,%edx
f011bdaf:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bdb2:	29 c2                	sub    %eax,%edx
f011bdb4:	89 d0                	mov    %edx,%eax
f011bdb6:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011bdbb:	77 17                	ja     f011bdd4 <test_kheap_virt_addr+0x91d>
f011bdbd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bdc4:	83 ec 0c             	sub    $0xc,%esp
f011bdc7:	68 78 f1 12 f0       	push   $0xf012f178
f011bdcc:	e8 ba 51 fe ff       	call   f0100f8b <cprintf>
f011bdd1:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011bdd4:	83 ec 0c             	sub    $0xc,%esp
f011bdd7:	68 b4 f1 12 f0       	push   $0xf012f1b4
f011bddc:	e8 aa 51 fe ff       	call   f0100f8b <cprintf>
f011bde1:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011bde4:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011bdeb:	a1 d8 ed 17 f0       	mov    0xf017edd8,%eax
f011bdf0:	05 00 10 00 00       	add    $0x1000,%eax
f011bdf5:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011bdfb:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011be02:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011be09:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011be0c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011be12:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011be15:	eb 44                	jmp    f011be5b <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011be17:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011be1a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011be1d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011be20:	83 ec 0c             	sub    $0xc,%esp
f011be23:	50                   	push   %eax
f011be24:	e8 63 d7 fe ff       	call   f010958c <kheap_virtual_address>
f011be29:	83 c4 10             	add    $0x10,%esp
f011be2c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011be32:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011be39:	74 1d                	je     f011be58 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011be3b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011be3f:	74 17                	je     f011be58 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011be41:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be48:	83 ec 0c             	sub    $0xc,%esp
f011be4b:	68 04 f2 12 f0       	push   $0xf012f204
f011be50:	e8 36 51 fe ff       	call   f0100f8b <cprintf>
f011be55:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011be58:	ff 45 d0             	incl   -0x30(%ebp)
f011be5b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011be61:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011be67:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011be6a:	39 c2                	cmp    %eax,%edx
f011be6c:	77 a9                	ja     f011be17 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011be6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011be74:	05 00 04 00 00       	add    $0x400,%eax
f011be79:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011be7c:	eb 64                	jmp    f011bee2 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011be7e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011be81:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011be84:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011be87:	83 ec 0c             	sub    $0xc,%esp
f011be8a:	50                   	push   %eax
f011be8b:	e8 fc d6 fe ff       	call   f010958c <kheap_virtual_address>
f011be90:	83 c4 10             	add    $0x10,%esp
f011be93:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011be99:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011be9c:	c1 e0 0c             	shl    $0xc,%eax
f011be9f:	89 c2                	mov    %eax,%edx
f011bea1:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011bea7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011beaa:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bead:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011beb0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011beb3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011beb8:	01 c8                	add    %ecx,%eax
f011beba:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011bec0:	74 1d                	je     f011bedf <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011bec2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bec6:	74 17                	je     f011bedf <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011bec8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011becf:	83 ec 0c             	sub    $0xc,%esp
f011bed2:	68 28 f2 12 f0       	push   $0xf012f228
f011bed7:	e8 af 50 fe ff       	call   f0100f8b <cprintf>
f011bedc:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bedf:	ff 45 d0             	incl   -0x30(%ebp)
f011bee2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bee8:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011beee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bef1:	39 c2                	cmp    %eax,%edx
f011bef3:	77 89                	ja     f011be7e <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bef5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011befb:	05 02 07 00 00       	add    $0x702,%eax
f011bf00:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011bf03:	eb 44                	jmp    f011bf49 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bf05:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bf08:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bf0b:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bf0e:	83 ec 0c             	sub    $0xc,%esp
f011bf11:	50                   	push   %eax
f011bf12:	e8 75 d6 fe ff       	call   f010958c <kheap_virtual_address>
f011bf17:	83 c4 10             	add    $0x10,%esp
f011bf1a:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011bf20:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011bf27:	74 1d                	je     f011bf46 <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011bf29:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bf2d:	74 17                	je     f011bf46 <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011bf2f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf36:	83 ec 0c             	sub    $0xc,%esp
f011bf39:	68 4c f2 12 f0       	push   $0xf012f24c
f011bf3e:	e8 48 50 fe ff       	call   f0100f8b <cprintf>
f011bf43:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011bf46:	ff 45 d0             	incl   -0x30(%ebp)
f011bf49:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bf4f:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011bf55:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bf58:	39 c2                	cmp    %eax,%edx
f011bf5a:	77 a9                	ja     f011bf05 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011bf5c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bf62:	05 02 0d 00 00       	add    $0xd02,%eax
f011bf67:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011bf6a:	eb 64                	jmp    f011bfd0 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011bf6c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bf6f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bf72:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bf75:	83 ec 0c             	sub    $0xc,%esp
f011bf78:	50                   	push   %eax
f011bf79:	e8 0e d6 fe ff       	call   f010958c <kheap_virtual_address>
f011bf7e:	83 c4 10             	add    $0x10,%esp
f011bf81:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011bf87:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bf8a:	c1 e0 0c             	shl    $0xc,%eax
f011bf8d:	89 c2                	mov    %eax,%edx
f011bf8f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011bf95:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011bf98:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011bf9b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011bf9e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011bfa1:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bfa6:	01 c8                	add    %ecx,%eax
f011bfa8:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011bfae:	74 1d                	je     f011bfcd <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011bfb0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bfb4:	74 17                	je     f011bfcd <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011bfb6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bfbd:	83 ec 0c             	sub    $0xc,%esp
f011bfc0:	68 70 f2 12 f0       	push   $0xf012f270
f011bfc5:	e8 c1 4f fe ff       	call   f0100f8b <cprintf>
f011bfca:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011bfcd:	ff 45 d0             	incl   -0x30(%ebp)
f011bfd0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011bfd6:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011bfdc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bfdf:	39 c2                	cmp    %eax,%edx
f011bfe1:	77 89                	ja     f011bf6c <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011bfe3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bfe7:	74 04                	je     f011bfed <test_kheap_virt_addr+0xb36>
f011bfe9:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011bfed:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011bff4:	83 ec 0c             	sub    $0xc,%esp
f011bff7:	68 94 f2 12 f0       	push   $0xf012f294
f011bffc:	e8 8a 4f fe ff       	call   f0100f8b <cprintf>
f011c001:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011c004:	83 ec 0c             	sub    $0xc,%esp
f011c007:	6a 00                	push   $0x0
f011c009:	e8 a8 d0 fe ff       	call   f01090b6 <sbrk>
f011c00e:	83 c4 10             	add    $0x10,%esp
f011c011:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c016:	77 17                	ja     f011c02f <test_kheap_virt_addr+0xb78>
f011c018:	83 ec 04             	sub    $0x4,%esp
f011c01b:	68 db f2 12 f0       	push   $0xf012f2db
f011c020:	68 91 07 00 00       	push   $0x791
f011c025:	68 73 c7 12 f0       	push   $0xf012c773
f011c02a:	e8 0a 43 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c02f:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011c036:	e9 d1 00 00 00       	jmp    f011c10c <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c03b:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011c040:	83 ec 04             	sub    $0x4,%esp
f011c043:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c049:	52                   	push   %edx
f011c04a:	ff 75 cc             	pushl  -0x34(%ebp)
f011c04d:	50                   	push   %eax
f011c04e:	e8 9c c3 fe ff       	call   f01083ef <get_page_table>
f011c053:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c056:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c05c:	85 c0                	test   %eax,%eax
f011c05e:	75 1e                	jne    f011c07e <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c060:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c067:	83 ec 04             	sub    $0x4,%esp
f011c06a:	68 64 ec 12 f0       	push   $0xf012ec64
f011c06f:	68 97 07 00 00       	push   $0x797
f011c074:	68 73 c7 12 f0       	push   $0xf012c773
f011c079:	e8 bb 42 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011c07e:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c084:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c087:	c1 ea 0c             	shr    $0xc,%edx
f011c08a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c090:	c1 e2 02             	shl    $0x2,%edx
f011c093:	01 d0                	add    %edx,%eax
f011c095:	8b 00                	mov    (%eax),%eax
f011c097:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c09c:	89 c2                	mov    %eax,%edx
f011c09e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011c0a1:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c0a6:	01 d0                	add    %edx,%eax
f011c0a8:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011c0ae:	83 ec 0c             	sub    $0xc,%esp
f011c0b1:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c0b7:	e8 d0 d4 fe ff       	call   f010958c <kheap_virtual_address>
f011c0bc:	83 c4 10             	add    $0x10,%esp
f011c0bf:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011c0c5:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011c0cb:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c0ce:	74 39                	je     f011c109 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011c0d0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c0d4:	74 33                	je     f011c109 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011c0d6:	ff 75 cc             	pushl  -0x34(%ebp)
f011c0d9:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011c0df:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c0e5:	68 f4 f2 12 f0       	push   $0xf012f2f4
f011c0ea:	e8 9c 4e fe ff       	call   f0100f8b <cprintf>
f011c0ef:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011c0f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c0f9:	83 ec 0c             	sub    $0xc,%esp
f011c0fc:	68 20 f3 12 f0       	push   $0xf012f320
f011c101:	e8 85 4e fe ff       	call   f0100f8b <cprintf>
f011c106:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c109:	ff 45 cc             	incl   -0x34(%ebp)
f011c10c:	83 ec 0c             	sub    $0xc,%esp
f011c10f:	6a 00                	push   $0x0
f011c111:	e8 a0 cf fe ff       	call   f01090b6 <sbrk>
f011c116:	83 c4 10             	add    $0x10,%esp
f011c119:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011c11c:	0f 87 19 ff ff ff    	ja     f011c03b <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011c122:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c126:	74 04                	je     f011c12c <test_kheap_virt_addr+0xc75>
f011c128:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011c12c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011c133:	83 ec 0c             	sub    $0xc,%esp
f011c136:	68 44 f3 12 f0       	push   $0xf012f344
f011c13b:	e8 4b 4e fe ff       	call   f0100f8b <cprintf>
f011c140:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c143:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011c14a:	eb 5a                	jmp    f011c1a6 <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011c14c:	83 ec 0c             	sub    $0xc,%esp
f011c14f:	ff 75 c8             	pushl  -0x38(%ebp)
f011c152:	e8 35 d4 fe ff       	call   f010958c <kheap_virtual_address>
f011c157:	83 c4 10             	add    $0x10,%esp
f011c15a:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011c160:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011c167:	74 36                	je     f011c19f <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011c169:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c16d:	74 30                	je     f011c19f <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011c16f:	83 ec 04             	sub    $0x4,%esp
f011c172:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011c178:	ff 75 c8             	pushl  -0x38(%ebp)
f011c17b:	68 83 f3 12 f0       	push   $0xf012f383
f011c180:	e8 06 4e fe ff       	call   f0100f8b <cprintf>
f011c185:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011c188:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c18f:	83 ec 0c             	sub    $0xc,%esp
f011c192:	68 a0 f3 12 f0       	push   $0xf012f3a0
f011c197:	e8 ef 4d fe ff       	call   f0100f8b <cprintf>
f011c19c:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011c19f:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011c1a6:	b8 90 84 b0 00       	mov    $0xb08490,%eax
f011c1ab:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011c1ae:	72 9c                	jb     f011c14c <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011c1b0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c1b4:	74 04                	je     f011c1ba <test_kheap_virt_addr+0xd03>
f011c1b6:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011c1ba:	83 ec 08             	sub    $0x8,%esp
f011c1bd:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c1c0:	68 c4 f3 12 f0       	push   $0xf012f3c4
f011c1c5:	e8 c1 4d fe ff       	call   f0100f8b <cprintf>
f011c1ca:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c1cd:	b8 01 00 00 00       	mov    $0x1,%eax
f011c1d2:	89 f4                	mov    %esi,%esp

}
f011c1d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c1d7:	5b                   	pop    %ebx
f011c1d8:	5e                   	pop    %esi
f011c1d9:	5f                   	pop    %edi
f011c1da:	5d                   	pop    %ebp
f011c1db:	c3                   	ret    

f011c1dc <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011c1dc:	55                   	push   %ebp
f011c1dd:	89 e5                	mov    %esp,%ebp
f011c1df:	57                   	push   %edi
f011c1e0:	56                   	push   %esi
f011c1e1:	53                   	push   %ebx
f011c1e2:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011c1e8:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011c1ee:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c1f3:	b8 00 00 00 00       	mov    $0x0,%eax
f011c1f8:	89 d7                	mov    %edx,%edi
f011c1fa:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011c1fc:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011c203:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c20a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011c211:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c216:	0f b6 c0             	movzbl %al,%eax
f011c219:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c21c:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011c223:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011c226:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c229:	39 c2                	cmp    %eax,%edx
f011c22b:	73 02                	jae    f011c22f <test_ksbrk+0x53>
f011c22d:	89 c2                	mov    %eax,%edx
f011c22f:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c234:	0f b6 c0             	movzbl %al,%eax
f011c237:	c1 e0 04             	shl    $0x4,%eax
f011c23a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011c23d:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011c244:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011c247:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011c24a:	39 c8                	cmp    %ecx,%eax
f011c24c:	73 02                	jae    f011c250 <test_ksbrk+0x74>
f011c24e:	89 c8                	mov    %ecx,%eax
f011c250:	01 d0                	add    %edx,%eax
f011c252:	83 c0 10             	add    $0x10,%eax
f011c255:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011c25a:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011c25d:	83 ec 0c             	sub    $0xc,%esp
f011c260:	68 f8 f3 12 f0       	push   $0xf012f3f8
f011c265:	e8 21 4d fe ff       	call   f0100f8b <cprintf>
f011c26a:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011c26d:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c274:	e8 31 20 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c279:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c27c:	e8 24 86 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c281:	89 45 b0             	mov    %eax,-0x50(%ebp)
		print_blocks_list(freeBlocksList);
f011c284:	83 ec 10             	sub    $0x10,%esp
f011c287:	89 e0                	mov    %esp,%eax
f011c289:	89 c2                	mov    %eax,%edx
f011c28b:	bb f0 d3 6b f0       	mov    $0xf06bd3f0,%ebx
f011c290:	b8 04 00 00 00       	mov    $0x4,%eax
f011c295:	89 d7                	mov    %edx,%edi
f011c297:	89 de                	mov    %ebx,%esi
f011c299:	89 c1                	mov    %eax,%ecx
f011c29b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011c29d:	e8 53 3e 00 00       	call   f01200f5 <print_blocks_list>
f011c2a2:	83 c4 10             	add    $0x10,%esp
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c2a5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c2a8:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c2ab:	29 c2                	sub    %eax,%edx
f011c2ad:	89 d0                	mov    %edx,%eax
f011c2af:	83 ec 0c             	sub    $0xc,%esp
f011c2b2:	50                   	push   %eax
f011c2b3:	e8 31 cf fe ff       	call   f01091e9 <kmalloc>
f011c2b8:	83 c4 10             	add    $0x10,%esp
f011c2bb:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011c2c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c2c4:	89 c2                	mov    %eax,%edx
f011c2c6:	c1 ea 1f             	shr    $0x1f,%edx
f011c2c9:	01 d0                	add    %edx,%eax
f011c2cb:	d1 f8                	sar    %eax
f011c2cd:	89 c2                	mov    %eax,%edx
f011c2cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c2d2:	01 d0                	add    %edx,%eax
f011c2d4:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c2d7:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c2dd:	6a 01                	push   $0x1
f011c2df:	ff 75 b8             	pushl  -0x48(%ebp)
f011c2e2:	ff 75 ac             	pushl  -0x54(%ebp)
f011c2e5:	50                   	push   %eax
f011c2e6:	e8 db 43 ff ff       	call   f01106c6 <check_block>
f011c2eb:	83 c4 10             	add    $0x10,%esp
f011c2ee:	85 c0                	test   %eax,%eax
f011c2f0:	75 17                	jne    f011c309 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011c2f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c2f9:	83 ec 0c             	sub    $0xc,%esp
f011c2fc:	68 49 f4 12 f0       	push   $0xf012f449
f011c301:	e8 85 4c fe ff       	call   f0100f8b <cprintf>
f011c306:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c309:	e8 9c 1f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c30e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c311:	74 17                	je     f011c32a <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011c313:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c31a:	83 ec 0c             	sub    $0xc,%esp
f011c31d:	68 60 f4 12 f0       	push   $0xf012f460
f011c322:	e8 64 4c fe ff       	call   f0100f8b <cprintf>
f011c327:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c32a:	e8 76 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c32f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c332:	74 17                	je     f011c34b <test_ksbrk+0x16f>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c334:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c33b:	83 ec 0c             	sub    $0xc,%esp
f011c33e:	68 80 f4 12 f0       	push   $0xf012f480
f011c343:	e8 43 4c fe ff       	call   f0100f8b <cprintf>
f011c348:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011c34b:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c350:	0f b6 c0             	movzbl %al,%eax
f011c353:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011c356:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011c35d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011c360:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011c363:	39 c2                	cmp    %eax,%edx
f011c365:	73 02                	jae    f011c369 <test_ksbrk+0x18d>
f011c367:	89 c2                	mov    %eax,%edx
f011c369:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011c36e:	0f b6 c0             	movzbl %al,%eax
f011c371:	c1 e0 04             	shl    $0x4,%eax
f011c374:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011c377:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011c37e:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011c381:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011c384:	39 c8                	cmp    %ecx,%eax
f011c386:	73 02                	jae    f011c38a <test_ksbrk+0x1ae>
f011c388:	89 c8                	mov    %ecx,%eax
f011c38a:	01 d0                	add    %edx,%eax
f011c38c:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011c391:	29 c2                	sub    %eax,%edx
f011c393:	89 d0                	mov    %edx,%eax
f011c395:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c398:	e8 0d 1f ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c39d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c3a0:	e8 00 85 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c3a5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011c3a8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c3ab:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c3ae:	29 c2                	sub    %eax,%edx
f011c3b0:	89 d0                	mov    %edx,%eax
f011c3b2:	83 ec 0c             	sub    $0xc,%esp
f011c3b5:	50                   	push   %eax
f011c3b6:	e8 2e ce fe ff       	call   f01091e9 <kmalloc>
f011c3bb:	83 c4 10             	add    $0x10,%esp
f011c3be:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011c3c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c3c7:	89 c2                	mov    %eax,%edx
f011c3c9:	c1 ea 1f             	shr    $0x1f,%edx
f011c3cc:	01 d0                	add    %edx,%eax
f011c3ce:	d1 f8                	sar    %eax
f011c3d0:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011c3d6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011c3d9:	01 d0                	add    %edx,%eax
f011c3db:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011c3de:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011c3e4:	6a 01                	push   $0x1
f011c3e6:	ff 75 b8             	pushl  -0x48(%ebp)
f011c3e9:	ff 75 ac             	pushl  -0x54(%ebp)
f011c3ec:	50                   	push   %eax
f011c3ed:	e8 d4 42 ff ff       	call   f01106c6 <check_block>
f011c3f2:	83 c4 10             	add    $0x10,%esp
f011c3f5:	85 c0                	test   %eax,%eax
f011c3f7:	75 17                	jne    f011c410 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011c3f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c400:	83 ec 0c             	sub    $0xc,%esp
f011c403:	68 ee f4 12 f0       	push   $0xf012f4ee
f011c408:	e8 7e 4b fe ff       	call   f0100f8b <cprintf>
f011c40d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c410:	e8 95 1e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c415:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c418:	74 17                	je     f011c431 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011c41a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c421:	83 ec 0c             	sub    $0xc,%esp
f011c424:	68 08 f5 12 f0       	push   $0xf012f508
f011c429:	e8 5d 4b fe ff       	call   f0100f8b <cprintf>
f011c42e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c431:	e8 6f 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c436:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c439:	74 17                	je     f011c452 <test_ksbrk+0x276>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c43b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c442:	83 ec 0c             	sub    $0xc,%esp
f011c445:	68 28 f5 12 f0       	push   $0xf012f528
f011c44a:	e8 3c 4b fe ff       	call   f0100f8b <cprintf>
f011c44f:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011c452:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011c459:	e8 4c 1e ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c45e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c461:	e8 3f 84 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c466:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011c469:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c46c:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c46f:	29 c2                	sub    %eax,%edx
f011c471:	89 d0                	mov    %edx,%eax
f011c473:	83 ec 0c             	sub    $0xc,%esp
f011c476:	50                   	push   %eax
f011c477:	e8 6d cd fe ff       	call   f01091e9 <kmalloc>
f011c47c:	83 c4 10             	add    $0x10,%esp
f011c47f:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011c485:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c488:	89 c2                	mov    %eax,%edx
f011c48a:	c1 ea 1f             	shr    $0x1f,%edx
f011c48d:	01 d0                	add    %edx,%eax
f011c48f:	d1 f8                	sar    %eax
f011c491:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011c496:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011c499:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011c49f:	6a 01                	push   $0x1
f011c4a1:	ff 75 b8             	pushl  -0x48(%ebp)
f011c4a4:	ff 75 ac             	pushl  -0x54(%ebp)
f011c4a7:	50                   	push   %eax
f011c4a8:	e8 19 42 ff ff       	call   f01106c6 <check_block>
f011c4ad:	83 c4 10             	add    $0x10,%esp
f011c4b0:	85 c0                	test   %eax,%eax
f011c4b2:	75 17                	jne    f011c4cb <test_ksbrk+0x2ef>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011c4b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4bb:	83 ec 0c             	sub    $0xc,%esp
f011c4be:	68 96 f5 12 f0       	push   $0xf012f596
f011c4c3:	e8 c3 4a fe ff       	call   f0100f8b <cprintf>
f011c4c8:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011c4cb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011c4ce:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011c4d1:	b8 00 10 00 00       	mov    $0x1000,%eax
f011c4d6:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011c4d9:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011c4dc:	6a 00                	push   $0x0
f011c4de:	ff 75 98             	pushl  -0x68(%ebp)
f011c4e1:	ff 75 ac             	pushl  -0x54(%ebp)
f011c4e4:	ff 75 ac             	pushl  -0x54(%ebp)
f011c4e7:	e8 da 41 ff ff       	call   f01106c6 <check_block>
f011c4ec:	83 c4 10             	add    $0x10,%esp
f011c4ef:	85 c0                	test   %eax,%eax
f011c4f1:	75 17                	jne    f011c50a <test_ksbrk+0x32e>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011c4f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c4fa:	83 ec 0c             	sub    $0xc,%esp
f011c4fd:	68 ad f5 12 f0       	push   $0xf012f5ad
f011c502:	e8 84 4a fe ff       	call   f0100f8b <cprintf>
f011c507:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011c50a:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011c511:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c514:	8b 00                	mov    (%eax),%eax
f011c516:	83 f8 01             	cmp    $0x1,%eax
f011c519:	74 17                	je     f011c532 <test_ksbrk+0x356>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011c51b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c522:	83 ec 0c             	sub    $0xc,%esp
f011c525:	68 c4 f5 12 f0       	push   $0xf012f5c4
f011c52a:	e8 5c 4a fe ff       	call   f0100f8b <cprintf>
f011c52f:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011c532:	83 ec 0c             	sub    $0xc,%esp
f011c535:	6a 00                	push   $0x0
f011c537:	e8 7a cb fe ff       	call   f01090b6 <sbrk>
f011c53c:	83 c4 10             	add    $0x10,%esp
f011c53f:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011c542:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011c549:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c54c:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c54f:	74 1d                	je     f011c56e <test_ksbrk+0x392>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011c551:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c558:	83 ec 04             	sub    $0x4,%esp
f011c55b:	ff 75 90             	pushl  -0x70(%ebp)
f011c55e:	ff 75 8c             	pushl  -0x74(%ebp)
f011c561:	68 f0 f5 12 f0       	push   $0xf012f5f0
f011c566:	e8 20 4a fe ff       	call   f0100f8b <cprintf>
f011c56b:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c56e:	e8 37 1d ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c573:	89 c2                	mov    %eax,%edx
f011c575:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c578:	29 d0                	sub    %edx,%eax
f011c57a:	83 f8 01             	cmp    $0x1,%eax
f011c57d:	74 17                	je     f011c596 <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011c57f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c586:	83 ec 0c             	sub    $0xc,%esp
f011c589:	68 24 f6 12 f0       	push   $0xf012f624
f011c58e:	e8 f8 49 fe ff       	call   f0100f8b <cprintf>
f011c593:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c596:	e8 0a 83 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c59b:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c59e:	74 17                	je     f011c5b7 <test_ksbrk+0x3db>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c5a0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c5a7:	83 ec 0c             	sub    $0xc,%esp
f011c5aa:	68 44 f6 12 f0       	push   $0xf012f644
f011c5af:	e8 d7 49 fe ff       	call   f0100f8b <cprintf>
f011c5b4:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011c5b7:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c5be:	e8 e7 1c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c5c3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c5c6:	e8 da 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c5cb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011c5ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c5d1:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c5d4:	29 c2                	sub    %eax,%edx
f011c5d6:	89 d0                	mov    %edx,%eax
f011c5d8:	83 ec 0c             	sub    $0xc,%esp
f011c5db:	50                   	push   %eax
f011c5dc:	e8 08 cc fe ff       	call   f01091e9 <kmalloc>
f011c5e1:	83 c4 10             	add    $0x10,%esp
f011c5e4:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011c5ea:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011c5f1:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011c5f7:	6a 01                	push   $0x1
f011c5f9:	ff 75 b8             	pushl  -0x48(%ebp)
f011c5fc:	ff 75 ac             	pushl  -0x54(%ebp)
f011c5ff:	50                   	push   %eax
f011c600:	e8 c1 40 ff ff       	call   f01106c6 <check_block>
f011c605:	83 c4 10             	add    $0x10,%esp
f011c608:	85 c0                	test   %eax,%eax
f011c60a:	75 17                	jne    f011c623 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011c60c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c613:	83 ec 0c             	sub    $0xc,%esp
f011c616:	68 b3 f6 12 f0       	push   $0xf012f6b3
f011c61b:	e8 6b 49 fe ff       	call   f0100f8b <cprintf>
f011c620:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c623:	e8 82 1c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c628:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c62b:	74 17                	je     f011c644 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011c62d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c634:	83 ec 0c             	sub    $0xc,%esp
f011c637:	68 cc f6 12 f0       	push   $0xf012f6cc
f011c63c:	e8 4a 49 fe ff       	call   f0100f8b <cprintf>
f011c641:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c644:	e8 5c 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c649:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c64c:	74 17                	je     f011c665 <test_ksbrk+0x489>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c64e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c655:	83 ec 0c             	sub    $0xc,%esp
f011c658:	68 ec f6 12 f0       	push   $0xf012f6ec
f011c65d:	e8 29 49 fe ff       	call   f0100f8b <cprintf>
f011c662:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011c665:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c669:	74 04                	je     f011c66f <test_ksbrk+0x493>
		eval += 25;
f011c66b:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011c66f:	83 ec 0c             	sub    $0xc,%esp
f011c672:	68 5c f7 12 f0       	push   $0xf012f75c
f011c677:	e8 0f 49 fe ff       	call   f0100f8b <cprintf>
f011c67c:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011c67f:	83 ec 0c             	sub    $0xc,%esp
f011c682:	6a 00                	push   $0x0
f011c684:	e8 2d ca fe ff       	call   f01090b6 <sbrk>
f011c689:	83 c4 10             	add    $0x10,%esp
f011c68c:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011c68f:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c696:	e8 0f 1c ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c69b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c69e:	e8 02 82 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c6a3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011c6a6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c6a9:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c6ac:	29 c2                	sub    %eax,%edx
f011c6ae:	89 d0                	mov    %edx,%eax
f011c6b0:	83 ec 0c             	sub    $0xc,%esp
f011c6b3:	50                   	push   %eax
f011c6b4:	e8 30 cb fe ff       	call   f01091e9 <kmalloc>
f011c6b9:	83 c4 10             	add    $0x10,%esp
f011c6bc:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011c6c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c6c5:	89 c2                	mov    %eax,%edx
f011c6c7:	c1 ea 1f             	shr    $0x1f,%edx
f011c6ca:	01 d0                	add    %edx,%eax
f011c6cc:	d1 f8                	sar    %eax
f011c6ce:	89 c2                	mov    %eax,%edx
f011c6d0:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c6d3:	01 d0                	add    %edx,%eax
f011c6d5:	83 e8 04             	sub    $0x4,%eax
f011c6d8:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011c6db:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011c6e1:	6a 01                	push   $0x1
f011c6e3:	ff 75 b8             	pushl  -0x48(%ebp)
f011c6e6:	ff 75 ac             	pushl  -0x54(%ebp)
f011c6e9:	50                   	push   %eax
f011c6ea:	e8 d7 3f ff ff       	call   f01106c6 <check_block>
f011c6ef:	83 c4 10             	add    $0x10,%esp
f011c6f2:	85 c0                	test   %eax,%eax
f011c6f4:	75 17                	jne    f011c70d <test_ksbrk+0x531>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011c6f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6fd:	83 ec 0c             	sub    $0xc,%esp
f011c700:	68 bf f7 12 f0       	push   $0xf012f7bf
f011c705:	e8 81 48 fe ff       	call   f0100f8b <cprintf>
f011c70a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c70d:	e8 98 1b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c712:	89 c2                	mov    %eax,%edx
f011c714:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c717:	29 d0                	sub    %edx,%eax
f011c719:	83 f8 01             	cmp    $0x1,%eax
f011c71c:	74 17                	je     f011c735 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011c71e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c725:	83 ec 0c             	sub    $0xc,%esp
f011c728:	68 d8 f7 12 f0       	push   $0xf012f7d8
f011c72d:	e8 59 48 fe ff       	call   f0100f8b <cprintf>
f011c732:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c735:	e8 6b 81 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c73a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c73d:	74 17                	je     f011c756 <test_ksbrk+0x57a>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c73f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c746:	83 ec 0c             	sub    $0xc,%esp
f011c749:	68 f8 f7 12 f0       	push   $0xf012f7f8
f011c74e:	e8 38 48 fe ff       	call   f0100f8b <cprintf>
f011c753:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011c756:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011c75d:	e8 48 1b ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c762:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c765:	e8 3b 81 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c76a:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011c76d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c770:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c773:	29 c2                	sub    %eax,%edx
f011c775:	89 d0                	mov    %edx,%eax
f011c777:	83 ec 0c             	sub    $0xc,%esp
f011c77a:	50                   	push   %eax
f011c77b:	e8 69 ca fe ff       	call   f01091e9 <kmalloc>
f011c780:	83 c4 10             	add    $0x10,%esp
f011c783:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011c789:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011c790:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011c796:	6a 01                	push   $0x1
f011c798:	ff 75 b8             	pushl  -0x48(%ebp)
f011c79b:	ff 75 ac             	pushl  -0x54(%ebp)
f011c79e:	50                   	push   %eax
f011c79f:	e8 22 3f ff ff       	call   f01106c6 <check_block>
f011c7a4:	83 c4 10             	add    $0x10,%esp
f011c7a7:	85 c0                	test   %eax,%eax
f011c7a9:	75 17                	jne    f011c7c2 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011c7ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7b2:	83 ec 0c             	sub    $0xc,%esp
f011c7b5:	68 66 f8 12 f0       	push   $0xf012f866
f011c7ba:	e8 cc 47 fe ff       	call   f0100f8b <cprintf>
f011c7bf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c7c2:	e8 e3 1a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c7c7:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c7ca:	74 17                	je     f011c7e3 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011c7cc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7d3:	83 ec 0c             	sub    $0xc,%esp
f011c7d6:	68 80 f8 12 f0       	push   $0xf012f880
f011c7db:	e8 ab 47 fe ff       	call   f0100f8b <cprintf>
f011c7e0:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c7e3:	e8 bd 80 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c7e8:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c7eb:	74 17                	je     f011c804 <test_ksbrk+0x628>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c7ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7f4:	83 ec 0c             	sub    $0xc,%esp
f011c7f7:	68 a0 f8 12 f0       	push   $0xf012f8a0
f011c7fc:	e8 8a 47 fe ff       	call   f0100f8b <cprintf>
f011c801:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011c804:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011c80b:	e8 9a 1a ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c810:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011c813:	e8 8d 80 fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c818:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011c81b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c81e:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011c821:	29 c2                	sub    %eax,%edx
f011c823:	89 d0                	mov    %edx,%eax
f011c825:	83 ec 0c             	sub    $0xc,%esp
f011c828:	50                   	push   %eax
f011c829:	e8 bb c9 fe ff       	call   f01091e9 <kmalloc>
f011c82e:	83 c4 10             	add    $0x10,%esp
f011c831:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011c837:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011c83e:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011c844:	6a 01                	push   $0x1
f011c846:	ff 75 b8             	pushl  -0x48(%ebp)
f011c849:	ff 75 ac             	pushl  -0x54(%ebp)
f011c84c:	50                   	push   %eax
f011c84d:	e8 74 3e ff ff       	call   f01106c6 <check_block>
f011c852:	83 c4 10             	add    $0x10,%esp
f011c855:	85 c0                	test   %eax,%eax
f011c857:	75 17                	jne    f011c870 <test_ksbrk+0x694>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011c859:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c860:	83 ec 0c             	sub    $0xc,%esp
f011c863:	68 0e f9 12 f0       	push   $0xf012f90e
f011c868:	e8 1e 47 fe ff       	call   f0100f8b <cprintf>
f011c86d:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011c870:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011c873:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011c876:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011c87d:	6a 00                	push   $0x0
f011c87f:	ff 75 98             	pushl  -0x68(%ebp)
f011c882:	ff 75 ac             	pushl  -0x54(%ebp)
f011c885:	ff 75 ac             	pushl  -0x54(%ebp)
f011c888:	e8 39 3e ff ff       	call   f01106c6 <check_block>
f011c88d:	83 c4 10             	add    $0x10,%esp
f011c890:	85 c0                	test   %eax,%eax
f011c892:	75 17                	jne    f011c8ab <test_ksbrk+0x6cf>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011c894:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c89b:	83 ec 0c             	sub    $0xc,%esp
f011c89e:	68 25 f9 12 f0       	push   $0xf012f925
f011c8a3:	e8 e3 46 fe ff       	call   f0100f8b <cprintf>
f011c8a8:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011c8ab:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c8ae:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011c8b3:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011c8b6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011c8b9:	8b 00                	mov    (%eax),%eax
f011c8bb:	83 f8 01             	cmp    $0x1,%eax
f011c8be:	74 17                	je     f011c8d7 <test_ksbrk+0x6fb>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011c8c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8c7:	83 ec 0c             	sub    $0xc,%esp
f011c8ca:	68 3c f9 12 f0       	push   $0xf012f93c
f011c8cf:	e8 b7 46 fe ff       	call   f0100f8b <cprintf>
f011c8d4:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011c8d7:	83 ec 0c             	sub    $0xc,%esp
f011c8da:	6a 00                	push   $0x0
f011c8dc:	e8 d5 c7 fe ff       	call   f01090b6 <sbrk>
f011c8e1:	83 c4 10             	add    $0x10,%esp
f011c8e4:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011c8e7:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c8ea:	05 00 20 00 00       	add    $0x2000,%eax
f011c8ef:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011c8f2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c8f5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c8f8:	74 1d                	je     f011c917 <test_ksbrk+0x73b>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011c8fa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c901:	83 ec 04             	sub    $0x4,%esp
f011c904:	ff 75 90             	pushl  -0x70(%ebp)
f011c907:	ff 75 8c             	pushl  -0x74(%ebp)
f011c90a:	68 68 f9 12 f0       	push   $0xf012f968
f011c90f:	e8 77 46 fe ff       	call   f0100f8b <cprintf>
f011c914:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011c917:	e8 8e 19 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011c91c:	89 c2                	mov    %eax,%edx
f011c91e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c921:	29 d0                	sub    %edx,%eax
f011c923:	83 f8 01             	cmp    $0x1,%eax
f011c926:	74 17                	je     f011c93f <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011c928:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c92f:	83 ec 0c             	sub    $0xc,%esp
f011c932:	68 9c f9 12 f0       	push   $0xf012f99c
f011c937:	e8 4f 46 fe ff       	call   f0100f8b <cprintf>
f011c93c:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c93f:	e8 61 7f fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011c944:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c947:	74 17                	je     f011c960 <test_ksbrk+0x784>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c949:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c950:	83 ec 0c             	sub    $0xc,%esp
f011c953:	68 bc f9 12 f0       	push   $0xf012f9bc
f011c958:	e8 2e 46 fe ff       	call   f0100f8b <cprintf>
f011c95d:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011c960:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c964:	74 04                	je     f011c96a <test_ksbrk+0x78e>
		eval += 25;
f011c966:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011c96a:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011c971:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011c977:	bb f8 fc 12 f0       	mov    $0xf012fcf8,%ebx
f011c97c:	ba 05 00 00 00       	mov    $0x5,%edx
f011c981:	89 c7                	mov    %eax,%edi
f011c983:	89 de                	mov    %ebx,%esi
f011c985:	89 d1                	mov    %edx,%ecx
f011c987:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011c989:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011c98f:	bb 0c fd 12 f0       	mov    $0xf012fd0c,%ebx
f011c994:	ba 05 00 00 00       	mov    $0x5,%edx
f011c999:	89 c7                	mov    %eax,%edi
f011c99b:	89 de                	mov    %ebx,%esi
f011c99d:	89 d1                	mov    %edx,%ecx
f011c99f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011c9a1:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011c9a7:	bb 20 fd 12 f0       	mov    $0xf012fd20,%ebx
f011c9ac:	ba 05 00 00 00       	mov    $0x5,%edx
f011c9b1:	89 c7                	mov    %eax,%edi
f011c9b3:	89 de                	mov    %ebx,%esi
f011c9b5:	89 d1                	mov    %edx,%ecx
f011c9b7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011c9b9:	83 ec 04             	sub    $0x4,%esp
f011c9bc:	68 00 00 00 f8       	push   $0xf8000000
f011c9c1:	68 00 10 00 00       	push   $0x1000
f011c9c6:	68 00 00 00 f6       	push   $0xf6000000
f011c9cb:	e8 cf c5 fe ff       	call   f0108f9f <initialize_kheap_dynamic_allocator>
f011c9d0:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011c9d3:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011c9da:	eb 1b                	jmp    f011c9f7 <test_ksbrk+0x81b>
	{
		unmap_frame(ptr_page_directory, va);
f011c9dc:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011c9e1:	83 ec 08             	sub    $0x8,%esp
f011c9e4:	ff 75 dc             	pushl  -0x24(%ebp)
f011c9e7:	50                   	push   %eax
f011c9e8:	e8 f2 bd fe ff       	call   f01087df <unmap_frame>
f011c9ed:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011c9f0:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011c9f7:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011c9fe:	76 dc                	jbe    f011c9dc <test_ksbrk+0x800>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011ca00:	83 ec 0c             	sub    $0xc,%esp
f011ca03:	68 2c fa 12 f0       	push   $0xf012fa2c
f011ca08:	e8 7e 45 fe ff       	call   f0100f8b <cprintf>
f011ca0d:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011ca10:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011ca17:	e9 21 01 00 00       	jmp    f011cb3d <test_ksbrk+0x961>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011ca1c:	e8 89 18 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ca21:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011ca24:	e8 7c 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca29:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011ca2c:	83 ec 0c             	sub    $0xc,%esp
f011ca2f:	6a 00                	push   $0x0
f011ca31:	e8 80 c6 fe ff       	call   f01090b6 <sbrk>
f011ca36:	83 c4 10             	add    $0x10,%esp
f011ca39:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011ca3c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ca3f:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011ca46:	83 ec 0c             	sub    $0xc,%esp
f011ca49:	50                   	push   %eax
f011ca4a:	e8 67 c6 fe ff       	call   f01090b6 <sbrk>
f011ca4f:	83 c4 10             	add    $0x10,%esp
f011ca52:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011ca55:	83 ec 0c             	sub    $0xc,%esp
f011ca58:	6a 00                	push   $0x0
f011ca5a:	e8 57 c6 fe ff       	call   f01090b6 <sbrk>
f011ca5f:	83 c4 10             	add    $0x10,%esp
f011ca62:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011ca65:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ca6c:	e8 34 7e fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ca71:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ca74:	74 1a                	je     f011ca90 <test_ksbrk+0x8b4>
			{
				correct = 0;
f011ca76:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011ca7d:	83 ec 08             	sub    $0x8,%esp
f011ca80:	ff 75 d8             	pushl  -0x28(%ebp)
f011ca83:	68 70 fa 12 f0       	push   $0xf012fa70
f011ca88:	e8 fe 44 fe ff       	call   f0100f8b <cprintf>
f011ca8d:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011ca90:	e8 15 18 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ca95:	89 c2                	mov    %eax,%edx
f011ca97:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011ca9a:	29 d0                	sub    %edx,%eax
f011ca9c:	89 c2                	mov    %eax,%edx
f011ca9e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011caa1:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011caa8:	39 c2                	cmp    %eax,%edx
f011caaa:	74 1a                	je     f011cac6 <test_ksbrk+0x8ea>
			{
				correct = 0;
f011caac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011cab3:	83 ec 08             	sub    $0x8,%esp
f011cab6:	ff 75 d8             	pushl  -0x28(%ebp)
f011cab9:	68 e0 fa 12 f0       	push   $0xf012fae0
f011cabe:	e8 c8 44 fe ff       	call   f0100f8b <cprintf>
f011cac3:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011cac6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cac9:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011cad0:	8b 45 80             	mov    -0x80(%ebp),%eax
f011cad3:	39 c2                	cmp    %eax,%edx
f011cad5:	74 25                	je     f011cafc <test_ksbrk+0x920>
			{
				correct = 0;
f011cad7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011cade:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cae1:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011cae8:	ff 75 80             	pushl  -0x80(%ebp)
f011caeb:	50                   	push   %eax
f011caec:	ff 75 d8             	pushl  -0x28(%ebp)
f011caef:	68 00 fb 12 f0       	push   $0xf012fb00
f011caf4:	e8 92 44 fe ff       	call   f0100f8b <cprintf>
f011caf9:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011cafc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011caff:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cb06:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011cb09:	74 25                	je     f011cb30 <test_ksbrk+0x954>
			{
				correct = 0;
f011cb0b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011cb12:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cb15:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cb1c:	ff 75 90             	pushl  -0x70(%ebp)
f011cb1f:	50                   	push   %eax
f011cb20:	ff 75 d8             	pushl  -0x28(%ebp)
f011cb23:	68 38 fb 12 f0       	push   $0xf012fb38
f011cb28:	e8 5e 44 fe ff       	call   f0100f8b <cprintf>
f011cb2d:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011cb30:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cb34:	74 04                	je     f011cb3a <test_ksbrk+0x95e>
				eval += 10;
f011cb36:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011cb3a:	ff 45 d8             	incl   -0x28(%ebp)
f011cb3d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011cb40:	8d 50 ff             	lea    -0x1(%eax),%edx
f011cb43:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cb46:	39 c2                	cmp    %eax,%edx
f011cb48:	0f 87 ce fe ff ff    	ja     f011ca1c <test_ksbrk+0x840>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011cb4e:	83 ec 0c             	sub    $0xc,%esp
f011cb51:	68 6c fb 12 f0       	push   $0xf012fb6c
f011cb56:	e8 30 44 fe ff       	call   f0100f8b <cprintf>
f011cb5b:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011cb5e:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011cb61:	48                   	dec    %eax
f011cb62:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011cb65:	e9 18 01 00 00       	jmp    f011cc82 <test_ksbrk+0xaa6>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011cb6a:	e8 3b 17 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011cb6f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011cb72:	e8 2e 7d fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cb77:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011cb7a:	83 ec 0c             	sub    $0xc,%esp
f011cb7d:	6a 00                	push   $0x0
f011cb7f:	e8 32 c5 fe ff       	call   f01090b6 <sbrk>
f011cb84:	83 c4 10             	add    $0x10,%esp
f011cb87:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011cb8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cb8d:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011cb94:	83 ec 0c             	sub    $0xc,%esp
f011cb97:	50                   	push   %eax
f011cb98:	e8 19 c5 fe ff       	call   f01090b6 <sbrk>
f011cb9d:	83 c4 10             	add    $0x10,%esp
f011cba0:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011cba6:	83 ec 0c             	sub    $0xc,%esp
f011cba9:	6a 00                	push   $0x0
f011cbab:	e8 06 c5 fe ff       	call   f01090b6 <sbrk>
f011cbb0:	83 c4 10             	add    $0x10,%esp
f011cbb3:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011cbb6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011cbbd:	e8 e3 7c fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cbc2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011cbc5:	74 1a                	je     f011cbe1 <test_ksbrk+0xa05>
			{
				correct = 0;
f011cbc7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011cbce:	83 ec 08             	sub    $0x8,%esp
f011cbd1:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cbd4:	68 bc fb 12 f0       	push   $0xf012fbbc
f011cbd9:	e8 ad 43 fe ff       	call   f0100f8b <cprintf>
f011cbde:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011cbe1:	e8 c4 16 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011cbe6:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011cbe9:	74 1a                	je     f011cc05 <test_ksbrk+0xa29>
			{
				correct = 0;
f011cbeb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011cbf2:	83 ec 08             	sub    $0x8,%esp
f011cbf5:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cbf8:	68 2c fc 12 f0       	push   $0xf012fc2c
f011cbfd:	e8 89 43 fe ff       	call   f0100f8b <cprintf>
f011cc02:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011cc05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc08:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011cc0f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011cc15:	39 c2                	cmp    %eax,%edx
f011cc17:	74 28                	je     f011cc41 <test_ksbrk+0xa65>
			{
				correct = 0;
f011cc19:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011cc20:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc23:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011cc2a:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011cc30:	50                   	push   %eax
f011cc31:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cc34:	68 4c fc 12 f0       	push   $0xf012fc4c
f011cc39:	e8 4d 43 fe ff       	call   f0100f8b <cprintf>
f011cc3e:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011cc41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc44:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cc4b:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011cc4e:	74 25                	je     f011cc75 <test_ksbrk+0xa99>
			{
				correct = 0;
f011cc50:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011cc57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc5a:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011cc61:	ff 75 90             	pushl  -0x70(%ebp)
f011cc64:	50                   	push   %eax
f011cc65:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cc68:	68 84 fc 12 f0       	push   $0xf012fc84
f011cc6d:	e8 19 43 fe ff       	call   f0100f8b <cprintf>
f011cc72:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011cc75:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cc79:	74 04                	je     f011cc7f <test_ksbrk+0xaa3>
				eval += 10;
f011cc7b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011cc7f:	ff 45 d4             	incl   -0x2c(%ebp)
f011cc82:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cc85:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cc88:	0f 82 dc fe ff ff    	jb     f011cb6a <test_ksbrk+0x98e>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011cc8e:	83 ec 08             	sub    $0x8,%esp
f011cc91:	ff 75 e4             	pushl  -0x1c(%ebp)
f011cc94:	68 b8 fc 12 f0       	push   $0xf012fcb8
f011cc99:	e8 ed 42 fe ff       	call   f0100f8b <cprintf>
f011cc9e:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011cca1:	83 ec 0c             	sub    $0xc,%esp
f011cca4:	68 e2 fc 12 f0       	push   $0xf012fce2
f011cca9:	e8 dd 42 fe ff       	call   f0100f8b <cprintf>
f011ccae:	83 c4 10             	add    $0x10,%esp
	return 0;
f011ccb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ccb6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011ccb9:	5b                   	pop    %ebx
f011ccba:	5e                   	pop    %esi
f011ccbb:	5f                   	pop    %edi
f011ccbc:	5d                   	pop    %ebp
f011ccbd:	c3                   	ret    

f011ccbe <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011ccbe:	55                   	push   %ebp
f011ccbf:	89 e5                	mov    %esp,%ebp
f011ccc1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ccc4:	83 ec 04             	sub    $0x4,%esp
f011ccc7:	68 34 fd 12 f0       	push   $0xf012fd34
f011cccc:	68 c2 08 00 00       	push   $0x8c2
f011ccd1:	68 73 c7 12 f0       	push   $0xf012c773
f011ccd6:	e8 5e 36 fe ff       	call   f0100339 <_panic>

f011ccdb <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011ccdb:	55                   	push   %ebp
f011ccdc:	89 e5                	mov    %esp,%ebp
f011ccde:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cce1:	83 ec 04             	sub    $0x4,%esp
f011cce4:	68 34 fd 12 f0       	push   $0xf012fd34
f011cce9:	68 c7 08 00 00       	push   $0x8c7
f011ccee:	68 73 c7 12 f0       	push   $0xf012c773
f011ccf3:	e8 41 36 fe ff       	call   f0100339 <_panic>

f011ccf8 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011ccf8:	55                   	push   %ebp
f011ccf9:	89 e5                	mov    %esp,%ebp
f011ccfb:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011ccfe:	83 ec 04             	sub    $0x4,%esp
f011cd01:	68 34 fd 12 f0       	push   $0xf012fd34
f011cd06:	68 cc 08 00 00       	push   $0x8cc
f011cd0b:	68 73 c7 12 f0       	push   $0xf012c773
f011cd10:	e8 24 36 fe ff       	call   f0100339 <_panic>

f011cd15 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011cd15:	55                   	push   %ebp
f011cd16:	89 e5                	mov    %esp,%ebp
f011cd18:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cd1b:	83 ec 04             	sub    $0x4,%esp
f011cd1e:	68 34 fd 12 f0       	push   $0xf012fd34
f011cd23:	68 d1 08 00 00       	push   $0x8d1
f011cd28:	68 73 c7 12 f0       	push   $0xf012c773
f011cd2d:	e8 07 36 fe ff       	call   f0100339 <_panic>

f011cd32 <test_kfree>:
}

int test_kfree()
{
f011cd32:	55                   	push   %ebp
f011cd33:	89 e5                	mov    %esp,%ebp
f011cd35:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cd38:	83 ec 04             	sub    $0x4,%esp
f011cd3b:	68 34 fd 12 f0       	push   $0xf012fd34
f011cd40:	68 d6 08 00 00       	push   $0x8d6
f011cd45:	68 73 c7 12 f0       	push   $0xf012c773
f011cd4a:	e8 ea 35 fe ff       	call   f0100339 <_panic>

f011cd4f <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011cd4f:	55                   	push   %ebp
f011cd50:	89 e5                	mov    %esp,%ebp
f011cd52:	57                   	push   %edi
f011cd53:	56                   	push   %esi
f011cd54:	53                   	push   %ebx
f011cd55:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011cd5b:	a0 dc ed 17 f0       	mov    0xf017eddc,%al
f011cd60:	84 c0                	test   %al,%al
f011cd62:	74 56                	je     f011cdba <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011cd64:	c6 05 dc ed 17 f0 00 	movb   $0x0,0xf017eddc
		initFreeFrames = sys_calculate_free_frames() ;
f011cd6b:	e8 3a 15 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011cd70:	a3 a8 81 b0 f0       	mov    %eax,0xf0b081a8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011cd75:	e8 2b 7b fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011cd7a:	a3 a4 81 b0 f0       	mov    %eax,0xf0b081a4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011cd7f:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011cd85:	bb 99 fe 12 f0       	mov    $0xf012fe99,%ebx
f011cd8a:	ba 11 00 00 00       	mov    $0x11,%edx
f011cd8f:	89 c7                	mov    %eax,%edi
f011cd91:	89 de                	mov    %ebx,%esi
f011cd93:	89 d1                	mov    %edx,%ecx
f011cd95:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011cd97:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011cd9d:	b9 53 00 00 00       	mov    $0x53,%ecx
f011cda2:	b0 00                	mov    $0x0,%al
f011cda4:	89 d7                	mov    %edx,%edi
f011cda6:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011cda8:	83 ec 0c             	sub    $0xc,%esp
f011cdab:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011cdb1:	50                   	push   %eax
f011cdb2:	e8 44 51 fe ff       	call   f0101efb <execute_command>
f011cdb7:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011cdba:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011cdc1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011cdc8:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f011cdcd:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011cdd0:	eb 2b                	jmp    f011cdfd <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011cdd2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011cdd5:	83 c0 20             	add    $0x20,%eax
f011cdd8:	83 ec 08             	sub    $0x8,%esp
f011cddb:	68 44 fd 12 f0       	push   $0xf012fd44
f011cde0:	50                   	push   %eax
f011cde1:	e8 ea 28 00 00       	call   f011f6d0 <strcmp>
f011cde6:	83 c4 10             	add    $0x10,%esp
f011cde9:	85 c0                	test   %eax,%eax
f011cdeb:	75 08                	jne    f011cdf5 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011cded:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011cdf0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011cdf3:	eb 2f                	jmp    f011ce24 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011cdf5:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011cdfa:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011cdfd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ce01:	74 08                	je     f011ce0b <test_three_creation_functions+0xbc>
f011ce03:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ce06:	8b 40 08             	mov    0x8(%eax),%eax
f011ce09:	eb 05                	jmp    f011ce10 <test_three_creation_functions+0xc1>
f011ce0b:	b8 00 00 00 00       	mov    $0x0,%eax
f011ce10:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f011ce15:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011ce1a:	85 c0                	test   %eax,%eax
f011ce1c:	75 b4                	jne    f011cdd2 <test_three_creation_functions+0x83>
f011ce1e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ce22:	75 ae                	jne    f011cdd2 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011ce24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ce27:	8b 80 90 05 00 00    	mov    0x590(%eax),%eax
f011ce2d:	85 c0                	test   %eax,%eax
f011ce2f:	74 17                	je     f011ce48 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011ce31:	83 ec 04             	sub    $0x4,%esp
f011ce34:	68 4c fd 12 f0       	push   $0xf012fd4c
f011ce39:	68 f7 08 00 00       	push   $0x8f7
f011ce3e:	68 73 c7 12 f0       	push   $0xf012c773
f011ce43:	e8 f1 34 fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011ce48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ce4b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011ce51:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011ce54:	e8 51 14 ff ff       	call   f010e2aa <sys_calculate_free_frames>
f011ce59:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011ce5c:	e8 44 7a fe ff       	call   f01048a5 <pf_calculate_free_frames>
f011ce61:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011ce64:	a1 a4 81 b0 f0       	mov    0xf0b081a4,%eax
f011ce69:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011ce6c:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011ce6f:	74 17                	je     f011ce88 <test_three_creation_functions+0x139>
f011ce71:	83 ec 04             	sub    $0x4,%esp
f011ce74:	68 8c c7 12 f0       	push   $0xf012c78c
f011ce79:	68 01 09 00 00       	push   $0x901
f011ce7e:	68 73 c7 12 f0       	push   $0xf012c773
f011ce83:	e8 b1 34 fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011ce88:	a1 a8 81 b0 f0       	mov    0xf0b081a8,%eax
f011ce8d:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011ce90:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ce93:	83 c2 15             	add    $0x15,%edx
f011ce96:	39 d0                	cmp    %edx,%eax
f011ce98:	74 17                	je     f011ceb1 <test_three_creation_functions+0x162>
f011ce9a:	83 ec 04             	sub    $0x4,%esp
f011ce9d:	68 9c fd 12 f0       	push   $0xf012fd9c
f011cea2:	68 03 09 00 00       	push   $0x903
f011cea7:	68 73 c7 12 f0       	push   $0xf012c773
f011ceac:	e8 88 34 fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011ceb1:	83 ec 0c             	sub    $0xc,%esp
f011ceb4:	68 00 10 00 00       	push   $0x1000
f011ceb9:	e8 2b c3 fe ff       	call   f01091e9 <kmalloc>
f011cebe:	83 c4 10             	add    $0x10,%esp
f011cec1:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011cec4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cec7:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011cecc:	74 17                	je     f011cee5 <test_three_creation_functions+0x196>
f011cece:	83 ec 04             	sub    $0x4,%esp
f011ced1:	68 dc fd 12 f0       	push   $0xf012fddc
f011ced6:	68 07 09 00 00       	push   $0x907
f011cedb:	68 73 c7 12 f0       	push   $0xf012c773
f011cee0:	e8 54 34 fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011cee5:	83 ec 0c             	sub    $0xc,%esp
f011cee8:	68 4c fe 12 f0       	push   $0xf012fe4c
f011ceed:	e8 99 40 fe ff       	call   f0100f8b <cprintf>
f011cef2:	83 c4 10             	add    $0x10,%esp

	return 1;
f011cef5:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011cefa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cefd:	5b                   	pop    %ebx
f011cefe:	5e                   	pop    %esi
f011ceff:	5f                   	pop    %edi
f011cf00:	5d                   	pop    %ebp
f011cf01:	c3                   	ret    

f011cf02 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011cf02:	55                   	push   %ebp
f011cf03:	89 e5                	mov    %esp,%ebp
f011cf05:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf08:	83 ec 04             	sub    $0x4,%esp
f011cf0b:	68 34 fd 12 f0       	push   $0xf012fd34
f011cf10:	68 15 09 00 00       	push   $0x915
f011cf15:	68 73 c7 12 f0       	push   $0xf012c773
f011cf1a:	e8 1a 34 fe ff       	call   f0100339 <_panic>

f011cf1f <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011cf1f:	55                   	push   %ebp
f011cf20:	89 e5                	mov    %esp,%ebp
f011cf22:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf25:	83 ec 04             	sub    $0x4,%esp
f011cf28:	68 34 fd 12 f0       	push   $0xf012fd34
f011cf2d:	68 1d 09 00 00       	push   $0x91d
f011cf32:	68 73 c7 12 f0       	push   $0xf012c773
f011cf37:	e8 fd 33 fe ff       	call   f0100339 <_panic>

f011cf3c <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011cf3c:	55                   	push   %ebp
f011cf3d:	89 e5                	mov    %esp,%ebp
f011cf3f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf42:	83 ec 04             	sub    $0x4,%esp
f011cf45:	68 34 fd 12 f0       	push   $0xf012fd34
f011cf4a:	68 24 09 00 00       	push   $0x924
f011cf4f:	68 73 c7 12 f0       	push   $0xf012c773
f011cf54:	e8 e0 33 fe ff       	call   f0100339 <_panic>

f011cf59 <test_kfreelast>:

}


int test_kfreelast()
{
f011cf59:	55                   	push   %ebp
f011cf5a:	89 e5                	mov    %esp,%ebp
f011cf5c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf5f:	83 ec 04             	sub    $0x4,%esp
f011cf62:	68 34 fd 12 f0       	push   $0xf012fd34
f011cf67:	68 2b 09 00 00       	push   $0x92b
f011cf6c:	68 73 c7 12 f0       	push   $0xf012c773
f011cf71:	e8 c3 33 fe ff       	call   f0100339 <_panic>

f011cf76 <test_krealloc>:

}

int test_krealloc() {
f011cf76:	55                   	push   %ebp
f011cf77:	89 e5                	mov    %esp,%ebp
f011cf79:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf7c:	83 ec 04             	sub    $0x4,%esp
f011cf7f:	68 34 fd 12 f0       	push   $0xf012fd34
f011cf84:	68 30 09 00 00       	push   $0x930
f011cf89:	68 73 c7 12 f0       	push   $0xf012c773
f011cf8e:	e8 a6 33 fe ff       	call   f0100339 <_panic>

f011cf93 <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011cf93:	55                   	push   %ebp
f011cf94:	89 e5                	mov    %esp,%ebp
f011cf96:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cf99:	83 ec 04             	sub    $0x4,%esp
f011cf9c:	68 34 fd 12 f0       	push   $0xf012fd34
f011cfa1:	68 35 09 00 00       	push   $0x935
f011cfa6:	68 73 c7 12 f0       	push   $0xf012c773
f011cfab:	e8 89 33 fe ff       	call   f0100339 <_panic>

f011cfb0 <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011cfb0:	55                   	push   %ebp
f011cfb1:	89 e5                	mov    %esp,%ebp
f011cfb3:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cfb6:	83 ec 04             	sub    $0x4,%esp
f011cfb9:	68 34 fd 12 f0       	push   $0xf012fd34
f011cfbe:	68 3b 09 00 00       	push   $0x93b
f011cfc3:	68 73 c7 12 f0       	push   $0xf012c773
f011cfc8:	e8 6c 33 fe ff       	call   f0100339 <_panic>

f011cfcd <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011cfcd:	55                   	push   %ebp
f011cfce:	89 e5                	mov    %esp,%ebp
f011cfd0:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cfd3:	83 ec 04             	sub    $0x4,%esp
f011cfd6:	68 34 fd 12 f0       	push   $0xf012fd34
f011cfdb:	68 40 09 00 00       	push   $0x940
f011cfe0:	68 73 c7 12 f0       	push   $0xf012c773
f011cfe5:	e8 4f 33 fe ff       	call   f0100339 <_panic>

f011cfea <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011cfea:	55                   	push   %ebp
f011cfeb:	89 e5                	mov    %esp,%ebp
f011cfed:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011cff0:	83 ec 04             	sub    $0x4,%esp
f011cff3:	68 34 fd 12 f0       	push   $0xf012fd34
f011cff8:	68 46 09 00 00       	push   $0x946
f011cffd:	68 73 c7 12 f0       	push   $0xf012c773
f011d002:	e8 32 33 fe ff       	call   f0100339 <_panic>

f011d007 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011d007:	55                   	push   %ebp
f011d008:	89 e5                	mov    %esp,%ebp
f011d00a:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d00d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011d014:	e9 84 00 00 00       	jmp    f011d09d <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011d019:	83 ec 08             	sub    $0x8,%esp
f011d01c:	ff 75 f4             	pushl  -0xc(%ebp)
f011d01f:	68 00 ff 12 f0       	push   $0xf012ff00
f011d024:	e8 62 3f fe ff       	call   f0100f8b <cprintf>
f011d029:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d02c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d033:	eb 4c                	jmp    f011d081 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011d035:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d038:	89 d0                	mov    %edx,%eax
f011d03a:	c1 e0 02             	shl    $0x2,%eax
f011d03d:	01 d0                	add    %edx,%eax
f011d03f:	c1 e0 03             	shl    $0x3,%eax
f011d042:	89 c2                	mov    %eax,%edx
f011d044:	8b 45 08             	mov    0x8(%ebp),%eax
f011d047:	01 c2                	add    %eax,%edx
f011d049:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d04c:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d04f:	85 c0                	test   %eax,%eax
f011d051:	74 36                	je     f011d089 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011d053:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d056:	89 d0                	mov    %edx,%eax
f011d058:	c1 e0 02             	shl    $0x2,%eax
f011d05b:	01 d0                	add    %edx,%eax
f011d05d:	c1 e0 03             	shl    $0x3,%eax
f011d060:	89 c2                	mov    %eax,%edx
f011d062:	8b 45 08             	mov    0x8(%ebp),%eax
f011d065:	01 c2                	add    %eax,%edx
f011d067:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d06a:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011d06d:	83 ec 08             	sub    $0x8,%esp
f011d070:	50                   	push   %eax
f011d071:	68 08 ff 12 f0       	push   $0xf012ff08
f011d076:	e8 10 3f fe ff       	call   f0100f8b <cprintf>
f011d07b:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011d07e:	ff 45 f0             	incl   -0x10(%ebp)
f011d081:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011d085:	7e ae                	jle    f011d035 <print_order+0x2e>
f011d087:	eb 01                	jmp    f011d08a <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011d089:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011d08a:	83 ec 0c             	sub    $0xc,%esp
f011d08d:	68 0d ff 12 f0       	push   $0xf012ff0d
f011d092:	e8 f4 3e fe ff       	call   f0100f8b <cprintf>
f011d097:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d09a:	ff 45 f4             	incl   -0xc(%ebp)
f011d09d:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011d0a1:	0f 8e 72 ff ff ff    	jle    f011d019 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011d0a7:	90                   	nop
f011d0a8:	c9                   	leave  
f011d0a9:	c3                   	ret    

f011d0aa <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011d0aa:	55                   	push   %ebp
f011d0ab:	89 e5                	mov    %esp,%ebp
f011d0ad:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011d0b0:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011d0b7:	83 ec 0c             	sub    $0xc,%esp
f011d0ba:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d0bf:	e8 52 25 ff ff       	call   f010f616 <acquire_spinlock>
f011d0c4:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011d0c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011d0ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011d0d5:	8b 55 0c             	mov    0xc(%ebp),%edx
f011d0d8:	8b 45 10             	mov    0x10(%ebp),%eax
f011d0db:	01 d0                	add    %edx,%eax
f011d0dd:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d0e0:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011d0e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d0e8:	a1 44 d3 6b f0       	mov    0xf06bd344,%eax
f011d0ed:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011d0f0:	ff 75 e8             	pushl  -0x18(%ebp)
f011d0f3:	ff 75 0c             	pushl  0xc(%ebp)
f011d0f6:	ff 75 08             	pushl  0x8(%ebp)
f011d0f9:	68 10 ff 12 f0       	push   $0xf012ff10
f011d0fe:	e8 88 3e fe ff       	call   f0100f8b <cprintf>
f011d103:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d106:	eb 34                	jmp    f011d13c <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011d108:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d10b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d10e:	7d 05                	jge    f011d115 <find_in_range+0x6b>
			{
				i++;
f011d110:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011d113:	eb 1e                	jmp    f011d133 <find_in_range+0x89>
			}
			if (i >= end)
f011d115:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d118:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011d11b:	7d 29                	jge    f011d146 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011d11d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d120:	8b 40 10             	mov    0x10(%eax),%eax
f011d123:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d126:	75 08                	jne    f011d130 <find_in_range+0x86>
			{
				ret = i;
f011d128:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d12b:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011d12e:	eb 17                	jmp    f011d147 <find_in_range+0x9d>
			}
			i++;
f011d130:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d133:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d136:	8b 40 0c             	mov    0xc(%eax),%eax
f011d139:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d13c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d13f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d142:	7c c4                	jl     f011d108 <find_in_range+0x5e>
f011d144:	eb 01                	jmp    f011d147 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011d146:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011d147:	83 ec 0c             	sub    $0xc,%esp
f011d14a:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d14f:	e8 49 25 ff ff       	call   f010f69d <release_spinlock>
f011d154:	83 c4 10             	add    $0x10,%esp
	return ret;
f011d157:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011d15a:	c9                   	leave  
f011d15b:	c3                   	ret    

f011d15c <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011d15c:	55                   	push   %ebp
f011d15d:	89 e5                	mov    %esp,%ebp
f011d15f:	57                   	push   %edi
f011d160:	56                   	push   %esi
f011d161:	53                   	push   %ebx
f011d162:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d165:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d16a:	84 c0                	test   %al,%al
f011d16c:	0f 84 9b 01 00 00    	je     f011d30d <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011d172:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011d179:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d17c:	bb 88 00 13 f0       	mov    $0xf0130088,%ebx
f011d181:	ba 05 00 00 00       	mov    $0x5,%edx
f011d186:	89 c7                	mov    %eax,%edi
f011d188:	89 de                	mov    %ebx,%esi
f011d18a:	89 d1                	mov    %edx,%ecx
f011d18c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d18e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d195:	e9 44 01 00 00       	jmp    f011d2de <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011d19a:	6a 00                	push   $0x0
f011d19c:	6a 00                	push   $0x0
f011d19e:	68 f4 01 00 00       	push   $0x1f4
f011d1a3:	68 41 ff 12 f0       	push   $0xf012ff41
f011d1a8:	e8 5d d7 fe ff       	call   f010a90a <env_create>
f011d1ad:	83 c4 10             	add    $0x10,%esp
f011d1b0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d1b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d1b6:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d1bb:	99                   	cltd   
f011d1bc:	f7 f9                	idiv   %ecx
f011d1be:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d1c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d1c4:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d1c8:	83 ec 08             	sub    $0x8,%esp
f011d1cb:	50                   	push   %eax
f011d1cc:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d1cf:	e8 b2 94 fe ff       	call   f0106686 <env_set_nice>
f011d1d4:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d1d7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d1db:	75 14                	jne    f011d1f1 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011d1dd:	83 ec 04             	sub    $0x4,%esp
f011d1e0:	68 49 ff 12 f0       	push   $0xf012ff49
f011d1e5:	6a 53                	push   $0x53
f011d1e7:	68 62 ff 12 f0       	push   $0xf012ff62
f011d1ec:	e8 48 31 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011d1f1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d1f4:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d1fa:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d1ff:	74 14                	je     f011d215 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011d201:	83 ec 04             	sub    $0x4,%esp
f011d204:	68 80 ff 12 f0       	push   $0xf012ff80
f011d209:	6a 55                	push   $0x55
f011d20b:	68 62 ff 12 f0       	push   $0xf012ff62
f011d210:	e8 24 31 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d215:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d218:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d21c:	83 c0 0a             	add    $0xa,%eax
f011d21f:	83 f8 14             	cmp    $0x14,%eax
f011d222:	0f 87 a5 00 00 00    	ja     f011d2cd <test_bsd_nice_0+0x171>
f011d228:	8b 04 85 9c 00 13 f0 	mov    -0xfecff64(,%eax,4),%eax
f011d22f:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d231:	a1 5c d0 6b f0       	mov    0xf06bd05c,%eax
f011d236:	8d 50 01             	lea    0x1(%eax),%edx
f011d239:	89 15 5c d0 6b f0    	mov    %edx,0xf06bd05c
f011d23f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d242:	8b 52 10             	mov    0x10(%edx),%edx
f011d245:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d24c:	eb 7f                	jmp    f011d2cd <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d24e:	a1 60 d0 6b f0       	mov    0xf06bd060,%eax
f011d253:	8d 50 01             	lea    0x1(%eax),%edx
f011d256:	89 15 60 d0 6b f0    	mov    %edx,0xf06bd060
f011d25c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d25f:	8b 52 10             	mov    0x10(%edx),%edx
f011d262:	83 c0 0a             	add    $0xa,%eax
f011d265:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d26c:	eb 5f                	jmp    f011d2cd <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d26e:	a1 64 d0 6b f0       	mov    0xf06bd064,%eax
f011d273:	8d 50 01             	lea    0x1(%eax),%edx
f011d276:	89 15 64 d0 6b f0    	mov    %edx,0xf06bd064
f011d27c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d27f:	8b 52 10             	mov    0x10(%edx),%edx
f011d282:	83 c0 14             	add    $0x14,%eax
f011d285:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d28c:	eb 3f                	jmp    f011d2cd <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d28e:	a1 68 d0 6b f0       	mov    0xf06bd068,%eax
f011d293:	8d 50 01             	lea    0x1(%eax),%edx
f011d296:	89 15 68 d0 6b f0    	mov    %edx,0xf06bd068
f011d29c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d29f:	8b 52 10             	mov    0x10(%edx),%edx
f011d2a2:	83 c0 1e             	add    $0x1e,%eax
f011d2a5:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d2ac:	eb 1f                	jmp    f011d2cd <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d2ae:	a1 6c d0 6b f0       	mov    0xf06bd06c,%eax
f011d2b3:	8d 50 01             	lea    0x1(%eax),%edx
f011d2b6:	89 15 6c d0 6b f0    	mov    %edx,0xf06bd06c
f011d2bc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d2bf:	8b 52 10             	mov    0x10(%edx),%edx
f011d2c2:	83 c0 28             	add    $0x28,%eax
f011d2c5:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d2cc:	90                   	nop
			}
			sched_new_env(env);
f011d2cd:	83 ec 0c             	sub    $0xc,%esp
f011d2d0:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d2d3:	e8 44 84 fe ff       	call   f010571c <sched_new_env>
f011d2d8:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011d2db:	ff 45 e4             	incl   -0x1c(%ebp)
f011d2de:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011d2e2:	0f 8e b2 fe ff ff    	jle    f011d19a <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d2e8:	83 ec 0c             	sub    $0xc,%esp
f011d2eb:	68 b0 ff 12 f0       	push   $0xf012ffb0
f011d2f0:	e8 96 3c fe ff       	call   f0100f8b <cprintf>
f011d2f5:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d2f8:	83 ec 0c             	sub    $0xc,%esp
f011d2fb:	68 ff ff 12 f0       	push   $0xf012ffff
f011d300:	e8 f6 4b fe ff       	call   f0101efb <execute_command>
f011d305:	83 c4 10             	add    $0x10,%esp
f011d308:	e9 c0 00 00 00       	jmp    f011d3cd <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011d30d:	83 ec 0c             	sub    $0xc,%esp
f011d310:	68 06 00 13 f0       	push   $0xf0130006
f011d315:	e8 71 3c fe ff       	call   f0100f8b <cprintf>
f011d31a:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d31d:	e8 32 8b fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d322:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d329:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d330:	e9 87 00 00 00       	jmp    f011d3bc <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d335:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d33c:	eb 52                	jmp    f011d390 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d33e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d341:	8b 14 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%edx
f011d348:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d34b:	89 c8                	mov    %ecx,%eax
f011d34d:	c1 e0 02             	shl    $0x2,%eax
f011d350:	01 c8                	add    %ecx,%eax
f011d352:	01 c0                	add    %eax,%eax
f011d354:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d357:	01 c8                	add    %ecx,%eax
f011d359:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d360:	83 ec 04             	sub    $0x4,%esp
f011d363:	52                   	push   %edx
f011d364:	ff 75 e0             	pushl  -0x20(%ebp)
f011d367:	50                   	push   %eax
f011d368:	e8 3d fd ff ff       	call   f011d0aa <find_in_range>
f011d36d:	83 c4 10             	add    $0x10,%esp
f011d370:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d373:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d377:	75 14                	jne    f011d38d <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011d379:	83 ec 04             	sub    $0x4,%esp
f011d37c:	68 18 00 13 f0       	push   $0xf0130018
f011d381:	6a 7b                	push   $0x7b
f011d383:	68 62 ff 12 f0       	push   $0xf012ff62
f011d388:	e8 ac 2f fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d38d:	ff 45 d8             	incl   -0x28(%ebp)
f011d390:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d393:	89 d0                	mov    %edx,%eax
f011d395:	c1 e0 02             	shl    $0x2,%eax
f011d398:	01 d0                	add    %edx,%eax
f011d39a:	01 c0                	add    %eax,%eax
f011d39c:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d39f:	01 d0                	add    %edx,%eax
f011d3a1:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d3a8:	85 c0                	test   %eax,%eax
f011d3aa:	75 92                	jne    f011d33e <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011d3ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d3af:	8b 04 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%eax
f011d3b6:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d3b9:	ff 45 dc             	incl   -0x24(%ebp)
f011d3bc:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011d3c0:	0f 8e 6f ff ff ff    	jle    f011d335 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011d3c6:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011d3cd:	83 ec 0c             	sub    $0xc,%esp
f011d3d0:	68 4c 00 13 f0       	push   $0xf013004c
f011d3d5:	e8 b1 3b fe ff       	call   f0100f8b <cprintf>
f011d3da:	83 c4 10             	add    $0x10,%esp
}
f011d3dd:	90                   	nop
f011d3de:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d3e1:	5b                   	pop    %ebx
f011d3e2:	5e                   	pop    %esi
f011d3e3:	5f                   	pop    %edi
f011d3e4:	5d                   	pop    %ebp
f011d3e5:	c3                   	ret    

f011d3e6 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011d3e6:	55                   	push   %ebp
f011d3e7:	89 e5                	mov    %esp,%ebp
f011d3e9:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011d3ec:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d3f1:	84 c0                	test   %al,%al
f011d3f3:	0f 84 50 01 00 00    	je     f011d549 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011d3f9:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011d400:	6a 00                	push   $0x0
f011d402:	6a 00                	push   $0x0
f011d404:	68 f4 01 00 00       	push   $0x1f4
f011d409:	68 41 ff 12 f0       	push   $0xf012ff41
f011d40e:	e8 f7 d4 fe ff       	call   f010a90a <env_create>
f011d413:	83 c4 10             	add    $0x10,%esp
f011d416:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011d419:	6a 00                	push   $0x0
f011d41b:	6a 00                	push   $0x0
f011d41d:	68 f4 01 00 00       	push   $0x1f4
f011d422:	68 f0 00 13 f0       	push   $0xf01300f0
f011d427:	e8 de d4 fe ff       	call   f010a90a <env_create>
f011d42c:	83 c4 10             	add    $0x10,%esp
f011d42f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011d432:	6a 00                	push   $0x0
f011d434:	6a 00                	push   $0x0
f011d436:	68 f4 01 00 00       	push   $0x1f4
f011d43b:	68 fd 00 13 f0       	push   $0xf01300fd
f011d440:	e8 c5 d4 fe ff       	call   f010a90a <env_create>
f011d445:	83 c4 10             	add    $0x10,%esp
f011d448:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011d44b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011d44f:	74 0c                	je     f011d45d <test_bsd_nice_1+0x77>
f011d451:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011d455:	74 06                	je     f011d45d <test_bsd_nice_1+0x77>
f011d457:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d45b:	75 17                	jne    f011d474 <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011d45d:	83 ec 04             	sub    $0x4,%esp
f011d460:	68 49 ff 12 f0       	push   $0xf012ff49
f011d465:	68 8e 00 00 00       	push   $0x8e
f011d46a:	68 62 ff 12 f0       	push   $0xf012ff62
f011d46f:	e8 c5 2e fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011d474:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d477:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d47d:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d482:	75 20                	jne    f011d4a4 <test_bsd_nice_1+0xbe>
f011d484:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d487:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d48d:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d492:	75 10                	jne    f011d4a4 <test_bsd_nice_1+0xbe>
f011d494:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d497:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d49d:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011d4a2:	74 35                	je     f011d4d9 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011d4a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d4a7:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011d4ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d4b0:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011d4b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d4b9:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d4bf:	83 ec 08             	sub    $0x8,%esp
f011d4c2:	51                   	push   %ecx
f011d4c3:	52                   	push   %edx
f011d4c4:	50                   	push   %eax
f011d4c5:	68 0c 01 13 f0       	push   $0xf013010c
f011d4ca:	68 90 00 00 00       	push   $0x90
f011d4cf:	68 62 ff 12 f0       	push   $0xf012ff62
f011d4d4:	e8 60 2e fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011d4d9:	83 ec 0c             	sub    $0xc,%esp
f011d4dc:	ff 75 ec             	pushl  -0x14(%ebp)
f011d4df:	e8 38 82 fe ff       	call   f010571c <sched_new_env>
f011d4e4:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011d4e7:	83 ec 0c             	sub    $0xc,%esp
f011d4ea:	ff 75 e8             	pushl  -0x18(%ebp)
f011d4ed:	e8 2a 82 fe ff       	call   f010571c <sched_new_env>
f011d4f2:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011d4f5:	83 ec 0c             	sub    $0xc,%esp
f011d4f8:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d4fb:	e8 1c 82 fe ff       	call   f010571c <sched_new_env>
f011d500:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011d503:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d506:	8b 40 10             	mov    0x10(%eax),%eax
f011d509:	a3 c0 81 b0 f0       	mov    %eax,0xf0b081c0
		prog_orders[1][0] = fibEnv->env_id;
f011d50e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d511:	8b 40 10             	mov    0x10(%eax),%eax
f011d514:	a3 e8 81 b0 f0       	mov    %eax,0xf0b081e8
		prog_orders[2][0] = fibposnEnv->env_id;
f011d519:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d51c:	8b 40 10             	mov    0x10(%eax),%eax
f011d51f:	a3 10 82 b0 f0       	mov    %eax,0xf0b08210
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d524:	83 ec 0c             	sub    $0xc,%esp
f011d527:	68 b0 ff 12 f0       	push   $0xf012ffb0
f011d52c:	e8 5a 3a fe ff       	call   f0100f8b <cprintf>
f011d531:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d534:	83 ec 0c             	sub    $0xc,%esp
f011d537:	68 ff ff 12 f0       	push   $0xf012ffff
f011d53c:	e8 ba 49 fe ff       	call   f0101efb <execute_command>
f011d541:	83 c4 10             	add    $0x10,%esp
f011d544:	e9 9e 00 00 00       	jmp    f011d5e7 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011d549:	83 ec 0c             	sub    $0xc,%esp
f011d54c:	68 06 00 13 f0       	push   $0xf0130006
f011d551:	e8 35 3a fe ff       	call   f0100f8b <cprintf>
f011d556:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d559:	e8 f6 88 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011d55e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011d565:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011d56c:	83 ec 0c             	sub    $0xc,%esp
f011d56f:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d574:	e8 9d 20 ff ff       	call   f010f616 <acquire_spinlock>
f011d579:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d57c:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011d581:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d584:	a1 44 d3 6b f0       	mov    0xf06bd344,%eax
f011d589:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d58c:	eb 41                	jmp    f011d5cf <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011d58e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d591:	89 d0                	mov    %edx,%eax
f011d593:	c1 e0 02             	shl    $0x2,%eax
f011d596:	01 d0                	add    %edx,%eax
f011d598:	c1 e0 03             	shl    $0x3,%eax
f011d59b:	05 c0 81 b0 f0       	add    $0xf0b081c0,%eax
f011d5a0:	8b 10                	mov    (%eax),%edx
f011d5a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d5a5:	8b 40 10             	mov    0x10(%eax),%eax
f011d5a8:	39 c2                	cmp    %eax,%edx
f011d5aa:	74 17                	je     f011d5c3 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011d5ac:	83 ec 04             	sub    $0x4,%esp
f011d5af:	68 18 00 13 f0       	push   $0xf0130018
f011d5b4:	68 ab 00 00 00       	push   $0xab
f011d5b9:	68 62 ff 12 f0       	push   $0xf012ff62
f011d5be:	e8 76 2d fe ff       	call   f0100339 <_panic>
				i++;
f011d5c3:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011d5c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d5c9:	8b 40 0c             	mov    0xc(%eax),%eax
f011d5cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011d5cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d5d2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011d5d5:	7c b7                	jl     f011d58e <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011d5d7:	83 ec 0c             	sub    $0xc,%esp
f011d5da:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011d5df:	e8 b9 20 ff ff       	call   f010f69d <release_spinlock>
f011d5e4:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011d5e7:	83 ec 0c             	sub    $0xc,%esp
f011d5ea:	68 78 01 13 f0       	push   $0xf0130178
f011d5ef:	e8 97 39 fe ff       	call   f0100f8b <cprintf>
f011d5f4:	83 c4 10             	add    $0x10,%esp
}
f011d5f7:	90                   	nop
f011d5f8:	c9                   	leave  
f011d5f9:	c3                   	ret    

f011d5fa <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011d5fa:	55                   	push   %ebp
f011d5fb:	89 e5                	mov    %esp,%ebp
f011d5fd:	57                   	push   %edi
f011d5fe:	56                   	push   %esi
f011d5ff:	53                   	push   %ebx
f011d600:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011d603:	a0 dd ed 17 f0       	mov    0xf017eddd,%al
f011d608:	84 c0                	test   %al,%al
f011d60a:	0f 84 ae 01 00 00    	je     f011d7be <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011d610:	83 ec 0c             	sub    $0xc,%esp
f011d613:	6a 01                	push   $0x1
f011d615:	e8 fe 10 00 00       	call   f011e718 <chksch>
f011d61a:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011d61d:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011d624:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d627:	bb fc 01 13 f0       	mov    $0xf01301fc,%ebx
f011d62c:	ba 05 00 00 00       	mov    $0x5,%edx
f011d631:	89 c7                	mov    %eax,%edi
f011d633:	89 de                	mov    %ebx,%esi
f011d635:	89 d1                	mov    %edx,%ecx
f011d637:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011d639:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011d640:	e9 4a 01 00 00       	jmp    f011d78f <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011d645:	6a 00                	push   $0x0
f011d647:	6a 00                	push   $0x0
f011d649:	68 10 27 00 00       	push   $0x2710
f011d64e:	68 b4 01 13 f0       	push   $0xf01301b4
f011d653:	e8 b2 d2 fe ff       	call   f010a90a <env_create>
f011d658:	83 c4 10             	add    $0x10,%esp
f011d65b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011d65e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d661:	b9 05 00 00 00       	mov    $0x5,%ecx
f011d666:	99                   	cltd   
f011d667:	f7 f9                	idiv   %ecx
f011d669:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011d66c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d66f:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d673:	83 ec 08             	sub    $0x8,%esp
f011d676:	50                   	push   %eax
f011d677:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d67a:	e8 07 90 fe ff       	call   f0106686 <env_set_nice>
f011d67f:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011d682:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011d686:	75 17                	jne    f011d69f <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011d688:	83 ec 04             	sub    $0x4,%esp
f011d68b:	68 49 ff 12 f0       	push   $0xf012ff49
f011d690:	68 c1 00 00 00       	push   $0xc1
f011d695:	68 62 ff 12 f0       	push   $0xf012ff62
f011d69a:	e8 9a 2c fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011d69f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d6a2:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011d6a8:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011d6ad:	74 17                	je     f011d6c6 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011d6af:	83 ec 04             	sub    $0x4,%esp
f011d6b2:	68 80 ff 12 f0       	push   $0xf012ff80
f011d6b7:	68 c3 00 00 00       	push   $0xc3
f011d6bc:	68 62 ff 12 f0       	push   $0xf012ff62
f011d6c1:	e8 73 2c fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011d6c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d6c9:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011d6cd:	83 c0 0f             	add    $0xf,%eax
f011d6d0:	83 f8 1e             	cmp    $0x1e,%eax
f011d6d3:	0f 87 a5 00 00 00    	ja     f011d77e <test_bsd_nice_2+0x184>
f011d6d9:	8b 04 85 10 02 13 f0 	mov    -0xfecfdf0(,%eax,4),%eax
f011d6e0:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011d6e2:	a1 5c d0 6b f0       	mov    0xf06bd05c,%eax
f011d6e7:	8d 50 01             	lea    0x1(%eax),%edx
f011d6ea:	89 15 5c d0 6b f0    	mov    %edx,0xf06bd05c
f011d6f0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d6f3:	8b 52 10             	mov    0x10(%edx),%edx
f011d6f6:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d6fd:	eb 7f                	jmp    f011d77e <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011d6ff:	a1 60 d0 6b f0       	mov    0xf06bd060,%eax
f011d704:	8d 50 01             	lea    0x1(%eax),%edx
f011d707:	89 15 60 d0 6b f0    	mov    %edx,0xf06bd060
f011d70d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d710:	8b 52 10             	mov    0x10(%edx),%edx
f011d713:	83 c0 0a             	add    $0xa,%eax
f011d716:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d71d:	eb 5f                	jmp    f011d77e <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011d71f:	a1 64 d0 6b f0       	mov    0xf06bd064,%eax
f011d724:	8d 50 01             	lea    0x1(%eax),%edx
f011d727:	89 15 64 d0 6b f0    	mov    %edx,0xf06bd064
f011d72d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d730:	8b 52 10             	mov    0x10(%edx),%edx
f011d733:	83 c0 14             	add    $0x14,%eax
f011d736:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d73d:	eb 3f                	jmp    f011d77e <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011d73f:	a1 68 d0 6b f0       	mov    0xf06bd068,%eax
f011d744:	8d 50 01             	lea    0x1(%eax),%edx
f011d747:	89 15 68 d0 6b f0    	mov    %edx,0xf06bd068
f011d74d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d750:	8b 52 10             	mov    0x10(%edx),%edx
f011d753:	83 c0 1e             	add    $0x1e,%eax
f011d756:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d75d:	eb 1f                	jmp    f011d77e <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011d75f:	a1 6c d0 6b f0       	mov    0xf06bd06c,%eax
f011d764:	8d 50 01             	lea    0x1(%eax),%edx
f011d767:	89 15 6c d0 6b f0    	mov    %edx,0xf06bd06c
f011d76d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011d770:	8b 52 10             	mov    0x10(%edx),%edx
f011d773:	83 c0 28             	add    $0x28,%eax
f011d776:	89 14 85 c0 81 b0 f0 	mov    %edx,-0xf4f7e40(,%eax,4)
				break;
f011d77d:	90                   	nop
			}
			sched_new_env(env);
f011d77e:	83 ec 0c             	sub    $0xc,%esp
f011d781:	ff 75 d4             	pushl  -0x2c(%ebp)
f011d784:	e8 93 7f fe ff       	call   f010571c <sched_new_env>
f011d789:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011d78c:	ff 45 e4             	incl   -0x1c(%ebp)
f011d78f:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011d793:	0f 8e ac fe ff ff    	jle    f011d645 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011d799:	83 ec 0c             	sub    $0xc,%esp
f011d79c:	68 b0 ff 12 f0       	push   $0xf012ffb0
f011d7a1:	e8 e5 37 fe ff       	call   f0100f8b <cprintf>
f011d7a6:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011d7a9:	83 ec 0c             	sub    $0xc,%esp
f011d7ac:	68 ff ff 12 f0       	push   $0xf012ffff
f011d7b1:	e8 45 47 fe ff       	call   f0101efb <execute_command>
f011d7b6:	83 c4 10             	add    $0x10,%esp
f011d7b9:	e9 d0 00 00 00       	jmp    f011d88e <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011d7be:	83 ec 0c             	sub    $0xc,%esp
f011d7c1:	6a 00                	push   $0x0
f011d7c3:	e8 50 0f 00 00       	call   f011e718 <chksch>
f011d7c8:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011d7cb:	83 ec 0c             	sub    $0xc,%esp
f011d7ce:	68 06 00 13 f0       	push   $0xf0130006
f011d7d3:	e8 b3 37 fe ff       	call   f0100f8b <cprintf>
f011d7d8:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011d7db:	e8 74 86 fe ff       	call   f0105e54 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011d7e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d7e7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011d7ee:	e9 8a 00 00 00       	jmp    f011d87d <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d7f3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011d7fa:	eb 55                	jmp    f011d851 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011d7fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d7ff:	8b 14 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%edx
f011d806:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011d809:	89 c8                	mov    %ecx,%eax
f011d80b:	c1 e0 02             	shl    $0x2,%eax
f011d80e:	01 c8                	add    %ecx,%eax
f011d810:	01 c0                	add    %eax,%eax
f011d812:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011d815:	01 c8                	add    %ecx,%eax
f011d817:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d81e:	83 ec 04             	sub    $0x4,%esp
f011d821:	52                   	push   %edx
f011d822:	ff 75 e0             	pushl  -0x20(%ebp)
f011d825:	50                   	push   %eax
f011d826:	e8 7f f8 ff ff       	call   f011d0aa <find_in_range>
f011d82b:	83 c4 10             	add    $0x10,%esp
f011d82e:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011d831:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011d835:	75 17                	jne    f011d84e <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011d837:	83 ec 04             	sub    $0x4,%esp
f011d83a:	68 18 00 13 f0       	push   $0xf0130018
f011d83f:	68 ea 00 00 00       	push   $0xea
f011d844:	68 62 ff 12 f0       	push   $0xf012ff62
f011d849:	e8 eb 2a fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011d84e:	ff 45 d8             	incl   -0x28(%ebp)
f011d851:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011d854:	89 d0                	mov    %edx,%eax
f011d856:	c1 e0 02             	shl    $0x2,%eax
f011d859:	01 d0                	add    %edx,%eax
f011d85b:	01 c0                	add    %eax,%eax
f011d85d:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011d860:	01 d0                	add    %edx,%eax
f011d862:	8b 04 85 c0 81 b0 f0 	mov    -0xf4f7e40(,%eax,4),%eax
f011d869:	85 c0                	test   %eax,%eax
f011d86b:	75 8f                	jne    f011d7fc <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011d86d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d870:	8b 04 85 5c d0 6b f0 	mov    -0xf942fa4(,%eax,4),%eax
f011d877:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011d87a:	ff 45 dc             	incl   -0x24(%ebp)
f011d87d:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011d881:	0f 8e 6c ff ff ff    	jle    f011d7f3 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011d887:	c6 05 dd ed 17 f0 00 	movb   $0x0,0xf017eddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011d88e:	83 ec 0c             	sub    $0xc,%esp
f011d891:	68 c0 01 13 f0       	push   $0xf01301c0
f011d896:	e8 f0 36 fe ff       	call   f0100f8b <cprintf>
f011d89b:	83 c4 10             	add    $0x10,%esp
}
f011d89e:	90                   	nop
f011d89f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d8a2:	5b                   	pop    %ebx
f011d8a3:	5e                   	pop    %esi
f011d8a4:	5f                   	pop    %edi
f011d8a5:	5d                   	pop    %ebp
f011d8a6:	c3                   	ret    

f011d8a7 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011d8a7:	55                   	push   %ebp
f011d8a8:	89 e5                	mov    %esp,%ebp
f011d8aa:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011d8ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d8b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011d8b3:	8b 45 08             	mov    0x8(%ebp),%eax
f011d8b6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011d8b9:	89 10                	mov    %edx,(%eax)
}
f011d8bb:	8b 45 08             	mov    0x8(%ebp),%eax
f011d8be:	c9                   	leave  
f011d8bf:	c2 04 00             	ret    $0x4

f011d8c2 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011d8c2:	55                   	push   %ebp
f011d8c3:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011d8c5:	8b 45 08             	mov    0x8(%ebp),%eax
f011d8c8:	85 c0                	test   %eax,%eax
f011d8ca:	78 16                	js     f011d8e2 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011d8cc:	8b 45 08             	mov    0x8(%ebp),%eax
f011d8cf:	05 00 20 00 00       	add    $0x2000,%eax
f011d8d4:	85 c0                	test   %eax,%eax
f011d8d6:	79 05                	jns    f011d8dd <fix_round+0x1b>
f011d8d8:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011d8dd:	c1 f8 0e             	sar    $0xe,%eax
f011d8e0:	eb 14                	jmp    f011d8f6 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011d8e2:	8b 45 08             	mov    0x8(%ebp),%eax
f011d8e5:	2d 00 20 00 00       	sub    $0x2000,%eax
f011d8ea:	85 c0                	test   %eax,%eax
f011d8ec:	79 05                	jns    f011d8f3 <fix_round+0x31>
f011d8ee:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011d8f3:	c1 f8 0e             	sar    $0xe,%eax
}
f011d8f6:	5d                   	pop    %ebp
f011d8f7:	c3                   	ret    

f011d8f8 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011d8f8:	55                   	push   %ebp
f011d8f9:	89 e5                	mov    %esp,%ebp
f011d8fb:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011d8fe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011d902:	79 16                	jns    f011d91a <fix_scale+0x22>
f011d904:	68 8c 02 13 f0       	push   $0xf013028c
f011d909:	68 93 02 13 f0       	push   $0xf0130293
f011d90e:	6a 5a                	push   $0x5a
f011d910:	68 a8 02 13 f0       	push   $0xf01302a8
f011d915:	e8 1f 2a fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011d91a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d91d:	0f af 45 10          	imul   0x10(%ebp),%eax
f011d921:	89 c2                	mov    %eax,%edx
f011d923:	8b 45 08             	mov    0x8(%ebp),%eax
f011d926:	83 ec 08             	sub    $0x8,%esp
f011d929:	52                   	push   %edx
f011d92a:	50                   	push   %eax
f011d92b:	e8 77 ff ff ff       	call   f011d8a7 <__mk_fix>
f011d930:	83 c4 0c             	add    $0xc,%esp
}
f011d933:	8b 45 08             	mov    0x8(%ebp),%eax
f011d936:	c9                   	leave  
f011d937:	c2 04 00             	ret    $0x4

f011d93a <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011d93a:	55                   	push   %ebp
f011d93b:	89 e5                	mov    %esp,%ebp
f011d93d:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011d940:	83 ec 08             	sub    $0x8,%esp
f011d943:	68 bc 02 13 f0       	push   $0xf01302bc
f011d948:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d94d:	e8 93 1c ff ff       	call   f010f5e5 <init_spinlock>
f011d952:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011d955:	83 ec 0c             	sub    $0xc,%esp
f011d958:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d95d:	e8 b4 1c ff ff       	call   f010f616 <acquire_spinlock>
f011d962:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011d965:	c7 05 a8 d1 6b f0 00 	movl   $0x0,0xf06bd1a8
f011d96c:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011d96f:	83 ec 0c             	sub    $0xc,%esp
f011d972:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d977:	e8 21 1d ff ff       	call   f010f69d <release_spinlock>
f011d97c:	83 c4 10             	add    $0x10,%esp
}
f011d97f:	90                   	nop
f011d980:	c9                   	leave  
f011d981:	c3                   	ret    

f011d982 <inctst>:
void inctst()
{
f011d982:	55                   	push   %ebp
f011d983:	89 e5                	mov    %esp,%ebp
f011d985:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011d988:	83 ec 0c             	sub    $0xc,%esp
f011d98b:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d990:	e8 81 1c ff ff       	call   f010f616 <acquire_spinlock>
f011d995:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011d998:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
f011d99d:	40                   	inc    %eax
f011d99e:	a3 a8 d1 6b f0       	mov    %eax,0xf06bd1a8
	}
	release_spinlock(&tstcntlock);
f011d9a3:	83 ec 0c             	sub    $0xc,%esp
f011d9a6:	68 c0 da 6b f0       	push   $0xf06bdac0
f011d9ab:	e8 ed 1c ff ff       	call   f010f69d <release_spinlock>
f011d9b0:	83 c4 10             	add    $0x10,%esp
}
f011d9b3:	90                   	nop
f011d9b4:	c9                   	leave  
f011d9b5:	c3                   	ret    

f011d9b6 <gettst>:
uint32 gettst()
{
f011d9b6:	55                   	push   %ebp
f011d9b7:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011d9b9:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
}
f011d9be:	5d                   	pop    %ebp
f011d9bf:	c3                   	ret    

f011d9c0 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011d9c0:	55                   	push   %ebp
f011d9c1:	89 e5                	mov    %esp,%ebp
f011d9c3:	83 ec 28             	sub    $0x28,%esp
f011d9c6:	8b 45 14             	mov    0x14(%ebp),%eax
f011d9c9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011d9cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011d9d3:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011d9d7:	83 f8 65             	cmp    $0x65,%eax
f011d9da:	74 5d                	je     f011da39 <tst+0x79>
f011d9dc:	83 f8 65             	cmp    $0x65,%eax
f011d9df:	7f 0a                	jg     f011d9eb <tst+0x2b>
f011d9e1:	83 f8 62             	cmp    $0x62,%eax
f011d9e4:	74 73                	je     f011da59 <tst+0x99>
f011d9e6:	e9 91 00 00 00       	jmp    f011da7c <tst+0xbc>
f011d9eb:	83 f8 67             	cmp    $0x67,%eax
f011d9ee:	74 29                	je     f011da19 <tst+0x59>
f011d9f0:	83 f8 6c             	cmp    $0x6c,%eax
f011d9f3:	0f 85 83 00 00 00    	jne    f011da7c <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011d9f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011d9fc:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d9ff:	73 09                	jae    f011da0a <tst+0x4a>
			chk = 1;
f011da01:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011da08:	eb 68                	jmp    f011da72 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011da0a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011da0e:	74 62                	je     f011da72 <tst+0xb2>
			chk = 1;
f011da10:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011da17:	eb 59                	jmp    f011da72 <tst+0xb2>
	case 'g':
		if (n > v1)
f011da19:	8b 45 08             	mov    0x8(%ebp),%eax
f011da1c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011da1f:	76 09                	jbe    f011da2a <tst+0x6a>
			chk = 1;
f011da21:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011da28:	eb 4b                	jmp    f011da75 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011da2a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011da2e:	74 45                	je     f011da75 <tst+0xb5>
			chk = 1;
f011da30:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011da37:	eb 3c                	jmp    f011da75 <tst+0xb5>
	case 'e':
		if (n == v1)
f011da39:	8b 45 08             	mov    0x8(%ebp),%eax
f011da3c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011da3f:	75 09                	jne    f011da4a <tst+0x8a>
			chk = 1;
f011da41:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011da48:	eb 2e                	jmp    f011da78 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011da4a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011da4e:	74 28                	je     f011da78 <tst+0xb8>
			chk = 1;
f011da50:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011da57:	eb 1f                	jmp    f011da78 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011da59:	8b 45 08             	mov    0x8(%ebp),%eax
f011da5c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011da5f:	72 1a                	jb     f011da7b <tst+0xbb>
f011da61:	8b 45 08             	mov    0x8(%ebp),%eax
f011da64:	3b 45 10             	cmp    0x10(%ebp),%eax
f011da67:	77 12                	ja     f011da7b <tst+0xbb>
			chk = 1;
f011da69:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011da70:	eb 09                	jmp    f011da7b <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011da72:	90                   	nop
f011da73:	eb 07                	jmp    f011da7c <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011da75:	90                   	nop
f011da76:	eb 04                	jmp    f011da7c <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011da78:	90                   	nop
f011da79:	eb 01                	jmp    f011da7c <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011da7b:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011da7c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011da80:	75 14                	jne    f011da96 <tst+0xd6>
f011da82:	83 ec 04             	sub    $0x4,%esp
f011da85:	68 c8 02 13 f0       	push   $0xf01302c8
f011da8a:	6a 48                	push   $0x48
f011da8c:	68 db 02 13 f0       	push   $0xf01302db
f011da91:	e8 a3 28 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011da96:	83 ec 0c             	sub    $0xc,%esp
f011da99:	68 c0 da 6b f0       	push   $0xf06bdac0
f011da9e:	e8 73 1b ff ff       	call   f010f616 <acquire_spinlock>
f011daa3:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011daa6:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
f011daab:	40                   	inc    %eax
f011daac:	a3 a8 d1 6b f0       	mov    %eax,0xf06bd1a8
	}
	release_spinlock(&tstcntlock);
f011dab1:	83 ec 0c             	sub    $0xc,%esp
f011dab4:	68 c0 da 6b f0       	push   $0xf06bdac0
f011dab9:	e8 df 1b ff ff       	call   f010f69d <release_spinlock>
f011dabe:	83 c4 10             	add    $0x10,%esp

	return;
f011dac1:	90                   	nop
}
f011dac2:	c9                   	leave  
f011dac3:	c3                   	ret    

f011dac4 <chktst>:

void chktst(uint32 n)
{
f011dac4:	55                   	push   %ebp
f011dac5:	89 e5                	mov    %esp,%ebp
f011dac7:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011daca:	83 ec 0c             	sub    $0xc,%esp
f011dacd:	68 c0 da 6b f0       	push   $0xf06bdac0
f011dad2:	e8 3f 1b ff ff       	call   f010f616 <acquire_spinlock>
f011dad7:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011dada:	a1 a8 d1 6b f0       	mov    0xf06bd1a8,%eax
f011dadf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011dae2:	83 ec 0c             	sub    $0xc,%esp
f011dae5:	68 c0 da 6b f0       	push   $0xf06bdac0
f011daea:	e8 ae 1b ff ff       	call   f010f69d <release_spinlock>
f011daef:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011daf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011daf5:	3b 45 08             	cmp    0x8(%ebp),%eax
f011daf8:	75 12                	jne    f011db0c <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011dafa:	83 ec 0c             	sub    $0xc,%esp
f011dafd:	68 f4 02 13 f0       	push   $0xf01302f4
f011db02:	e8 84 34 fe ff       	call   f0100f8b <cprintf>
f011db07:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011db0a:	eb 14                	jmp    f011db20 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011db0c:	83 ec 04             	sub    $0x4,%esp
f011db0f:	68 20 03 13 f0       	push   $0xf0130320
f011db14:	6a 5e                	push   $0x5e
f011db16:	68 db 02 13 f0       	push   $0xf01302db
f011db1b:	e8 19 28 fe ff       	call   f0100339 <_panic>
}
f011db20:	c9                   	leave  
f011db21:	c3                   	ret    

f011db22 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011db22:	55                   	push   %ebp
f011db23:	89 e5                	mov    %esp,%ebp
f011db25:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011db28:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011db2c:	77 07                	ja     f011db35 <nearest_pow2_ceil+0x13>
f011db2e:	b8 01 00 00 00       	mov    $0x1,%eax
f011db33:	eb 20                	jmp    f011db55 <nearest_pow2_ceil+0x33>
	int power = 2;
f011db35:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011db3c:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011db3f:	eb 08                	jmp    f011db49 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011db41:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011db44:	01 c0                	add    %eax,%eax
f011db46:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011db49:	d1 6d 08             	shrl   0x8(%ebp)
f011db4c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011db50:	75 ef                	jne    f011db41 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011db52:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011db55:	c9                   	leave  
f011db56:	c3                   	ret    

f011db57 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011db57:	55                   	push   %ebp
f011db58:	89 e5                	mov    %esp,%ebp
f011db5a:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011db5d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011db61:	77 07                	ja     f011db6a <log2_ceil+0x13>
f011db63:	b8 01 00 00 00       	mov    $0x1,%eax
f011db68:	eb 1b                	jmp    f011db85 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011db6a:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011db71:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011db74:	eb 03                	jmp    f011db79 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011db76:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011db79:	d1 6d 08             	shrl   0x8(%ebp)
f011db7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011db80:	75 f4                	jne    f011db76 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011db82:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011db85:	c9                   	leave  
f011db86:	c3                   	ret    

f011db87 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011db87:	55                   	push   %ebp
f011db88:	89 e5                	mov    %esp,%ebp
f011db8a:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011db8d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011db94:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011db9b:	eb 12                	jmp    f011dbaf <fixedPt2Str+0x28>
		mulFactor *= 10;
f011db9d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dba0:	89 d0                	mov    %edx,%eax
f011dba2:	c1 e0 02             	shl    $0x2,%eax
f011dba5:	01 d0                	add    %edx,%eax
f011dba7:	01 c0                	add    %eax,%eax
f011dba9:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011dbac:	ff 45 f0             	incl   -0x10(%ebp)
f011dbaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dbb2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011dbb5:	7c e6                	jl     f011db9d <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011dbb7:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011dbba:	83 ec 04             	sub    $0x4,%esp
f011dbbd:	ff 75 f4             	pushl  -0xc(%ebp)
f011dbc0:	ff 75 08             	pushl  0x8(%ebp)
f011dbc3:	50                   	push   %eax
f011dbc4:	e8 2f fd ff ff       	call   f011d8f8 <fix_scale>
f011dbc9:	83 c4 0c             	add    $0xc,%esp
f011dbcc:	83 ec 0c             	sub    $0xc,%esp
f011dbcf:	ff 75 dc             	pushl  -0x24(%ebp)
f011dbd2:	e8 eb fc ff ff       	call   f011d8c2 <fix_round>
f011dbd7:	83 c4 10             	add    $0x10,%esp
f011dbda:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011dbdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dbe0:	99                   	cltd   
f011dbe1:	f7 7d f4             	idivl  -0xc(%ebp)
f011dbe4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011dbe7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011dbea:	99                   	cltd   
f011dbeb:	f7 7d f4             	idivl  -0xc(%ebp)
f011dbee:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011dbf1:	83 ec 08             	sub    $0x8,%esp
f011dbf4:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dbf7:	50                   	push   %eax
f011dbf8:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dbfb:	e8 6a 1e 00 00       	call   f011fa6a <ltostr>
f011dc00:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011dc03:	83 ec 08             	sub    $0x8,%esp
f011dc06:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011dc09:	50                   	push   %eax
f011dc0a:	ff 75 e0             	pushl  -0x20(%ebp)
f011dc0d:	e8 58 1e 00 00       	call   f011fa6a <ltostr>
f011dc12:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011dc15:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011dc18:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011dc1d:	f7 e9                	imul   %ecx
f011dc1f:	c1 fa 02             	sar    $0x2,%edx
f011dc22:	89 c8                	mov    %ecx,%eax
f011dc24:	c1 f8 1f             	sar    $0x1f,%eax
f011dc27:	29 c2                	sub    %eax,%edx
f011dc29:	89 d0                	mov    %edx,%eax
f011dc2b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011dc2e:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011dc35:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011dc3c:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011dc42:	eb 31                	jmp    f011dc75 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011dc44:	83 ec 04             	sub    $0x4,%esp
f011dc47:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011dc4a:	50                   	push   %eax
f011dc4b:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011dc4e:	50                   	push   %eax
f011dc4f:	68 3c 03 13 f0       	push   $0xf013033c
f011dc54:	e8 ea 1e 00 00       	call   f011fb43 <strcconcat>
f011dc59:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011dc5c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011dc5f:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011dc64:	f7 e9                	imul   %ecx
f011dc66:	c1 fa 02             	sar    $0x2,%edx
f011dc69:	89 c8                	mov    %ecx,%eax
f011dc6b:	c1 f8 1f             	sar    $0x1f,%eax
f011dc6e:	29 c2                	sub    %eax,%edx
f011dc70:	89 d0                	mov    %edx,%eax
f011dc72:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011dc75:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dc78:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011dc7b:	7c c7                	jl     f011dc44 <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011dc7d:	83 ec 04             	sub    $0x4,%esp
f011dc80:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011dc83:	50                   	push   %eax
f011dc84:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011dc87:	50                   	push   %eax
f011dc88:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011dc8b:	50                   	push   %eax
f011dc8c:	e8 b2 1e 00 00       	call   f011fb43 <strcconcat>
f011dc91:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011dc94:	83 ec 04             	sub    $0x4,%esp
f011dc97:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dc9a:	50                   	push   %eax
f011dc9b:	68 3e 03 13 f0       	push   $0xf013033e
f011dca0:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dca3:	50                   	push   %eax
f011dca4:	e8 9a 1e 00 00       	call   f011fb43 <strcconcat>
f011dca9:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011dcac:	83 ec 04             	sub    $0x4,%esp
f011dcaf:	ff 75 10             	pushl  0x10(%ebp)
f011dcb2:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011dcb5:	50                   	push   %eax
f011dcb6:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011dcb9:	50                   	push   %eax
f011dcba:	e8 84 1e 00 00       	call   f011fb43 <strcconcat>
f011dcbf:	83 c4 10             	add    $0x10,%esp

}
f011dcc2:	90                   	nop
f011dcc3:	c9                   	leave  
f011dcc4:	c3                   	ret    

f011dcc5 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011dcc5:	55                   	push   %ebp
f011dcc6:	89 e5                	mov    %esp,%ebp
f011dcc8:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011dcce:	83 ec 0c             	sub    $0xc,%esp
f011dcd1:	68 40 03 13 f0       	push   $0xf0130340
f011dcd6:	e8 e9 18 00 00       	call   f011f5c4 <strlen>
f011dcdb:	83 c4 10             	add    $0x10,%esp
f011dcde:	83 ec 04             	sub    $0x4,%esp
f011dce1:	50                   	push   %eax
f011dce2:	68 40 03 13 f0       	push   $0xf0130340
f011dce7:	ff 75 08             	pushl  0x8(%ebp)
f011dcea:	e8 19 1a 00 00       	call   f011f708 <strncmp>
f011dcef:	83 c4 10             	add    $0x10,%esp
f011dcf2:	85 c0                	test   %eax,%eax
f011dcf4:	0f 85 8a 00 00 00    	jne    f011dd84 <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011dcfa:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011dcfd:	50                   	push   %eax
f011dcfe:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011dd04:	50                   	push   %eax
f011dd05:	68 4e 03 13 f0       	push   $0xf013034e
f011dd0a:	ff 75 08             	pushl  0x8(%ebp)
f011dd0d:	e8 c7 1e 00 00       	call   f011fbd9 <strsplit>
f011dd12:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011dd15:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011dd1b:	83 ec 04             	sub    $0x4,%esp
f011dd1e:	6a 0a                	push   $0xa
f011dd20:	6a 00                	push   $0x0
f011dd22:	50                   	push   %eax
f011dd23:	e8 fc 1b 00 00       	call   f011f924 <strtol>
f011dd28:	83 c4 10             	add    $0x10,%esp
f011dd2b:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011dd2e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011dd35:	83 ec 04             	sub    $0x4,%esp
f011dd38:	6a 00                	push   $0x0
f011dd3a:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011dd3d:	50                   	push   %eax
f011dd3e:	ff 75 e0             	pushl  -0x20(%ebp)
f011dd41:	e8 92 d6 fe ff       	call   f010b3d8 <envid2env>
f011dd46:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011dd49:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011dd4c:	8b 40 10             	mov    0x10(%eax),%eax
f011dd4f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011dd52:	74 19                	je     f011dd6d <sys_utilities+0xa8>
f011dd54:	68 50 03 13 f0       	push   $0xf0130350
f011dd59:	68 93 02 13 f0       	push   $0xf0130293
f011dd5e:	68 a4 00 00 00       	push   $0xa4
f011dd63:	68 db 02 13 f0       	push   $0xf01302db
f011dd68:	e8 cc 25 fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011dd6d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011dd70:	83 ec 08             	sub    $0x8,%esp
f011dd73:	ff 75 0c             	pushl  0xc(%ebp)
f011dd76:	50                   	push   %eax
f011dd77:	e8 0a 89 fe ff       	call   f0106686 <env_set_nice>
f011dd7c:	83 c4 10             	add    $0x10,%esp
f011dd7f:	e9 12 04 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011dd84:	83 ec 0c             	sub    $0xc,%esp
f011dd87:	68 65 03 13 f0       	push   $0xf0130365
f011dd8c:	e8 33 18 00 00       	call   f011f5c4 <strlen>
f011dd91:	83 c4 10             	add    $0x10,%esp
f011dd94:	83 ec 04             	sub    $0x4,%esp
f011dd97:	50                   	push   %eax
f011dd98:	68 65 03 13 f0       	push   $0xf0130365
f011dd9d:	ff 75 08             	pushl  0x8(%ebp)
f011dda0:	e8 63 19 00 00       	call   f011f708 <strncmp>
f011dda5:	83 c4 10             	add    $0x10,%esp
f011dda8:	85 c0                	test   %eax,%eax
f011ddaa:	0f 85 a6 01 00 00    	jne    f011df56 <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011ddb0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ddb3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011ddb6:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011ddb9:	50                   	push   %eax
f011ddba:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011ddc0:	50                   	push   %eax
f011ddc1:	68 4e 03 13 f0       	push   $0xf013034e
f011ddc6:	ff 75 08             	pushl  0x8(%ebp)
f011ddc9:	e8 0b 1e 00 00       	call   f011fbd9 <strsplit>
f011ddce:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011ddd1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ddd7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011ddda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011dde1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011dde8:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011ddef:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ddf2:	8b 00                	mov    (%eax),%eax
f011ddf4:	85 c0                	test   %eax,%eax
f011ddf6:	79 1c                	jns    f011de14 <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011ddf8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011ddff:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de02:	8b 00                	mov    (%eax),%eax
f011de04:	f7 d8                	neg    %eax
f011de06:	89 c2                	mov    %eax,%edx
f011de08:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de0b:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011de0d:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011de14:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011de1b:	83 ec 0c             	sub    $0xc,%esp
f011de1e:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011de23:	e8 ee 17 ff ff       	call   f010f616 <acquire_spinlock>
f011de28:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011de2b:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011de30:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011de33:	a1 44 d3 6b f0       	mov    0xf06bd344,%eax
f011de38:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011de3b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011de3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011de41:	eb 6c                	jmp    f011deaf <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011de43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011de46:	83 c0 20             	add    $0x20,%eax
f011de49:	83 ec 08             	sub    $0x8,%esp
f011de4c:	ff 75 d8             	pushl  -0x28(%ebp)
f011de4f:	50                   	push   %eax
f011de50:	e8 7b 18 00 00       	call   f011f6d0 <strcmp>
f011de55:	83 c4 10             	add    $0x10,%esp
f011de58:	85 c0                	test   %eax,%eax
f011de5a:	75 46                	jne    f011dea2 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011de5c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de5f:	8b 00                	mov    (%eax),%eax
f011de61:	8d 50 ff             	lea    -0x1(%eax),%edx
f011de64:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011de67:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011de69:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011de6d:	74 14                	je     f011de83 <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011de6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011de72:	8b 40 10             	mov    0x10(%eax),%eax
f011de75:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011de78:	7d 1d                	jge    f011de97 <sys_utilities+0x1d2>
					{
						success = 0;
f011de7a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011de81:	eb 32                	jmp    f011deb5 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011de83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011de86:	8b 40 10             	mov    0x10(%eax),%eax
f011de89:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011de8c:	7e 09                	jle    f011de97 <sys_utilities+0x1d2>
					{
						success = 0;
f011de8e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011de95:	eb 1e                	jmp    f011deb5 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011de97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011de9a:	8b 40 10             	mov    0x10(%eax),%eax
f011de9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011dea0:	eb 01                	jmp    f011dea3 <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011dea2:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011dea3:	ff 4d e4             	decl   -0x1c(%ebp)
f011dea6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dea9:	8b 40 0c             	mov    0xc(%eax),%eax
f011deac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011deaf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011deb3:	7f 8e                	jg     f011de43 <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011deb5:	83 ec 0c             	sub    $0xc,%esp
f011deb8:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011debd:	e8 db 17 ff ff       	call   f010f69d <release_spinlock>
f011dec2:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011dec5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dec8:	8b 00                	mov    (%eax),%eax
f011deca:	85 c0                	test   %eax,%eax
f011decc:	75 06                	jne    f011ded4 <sys_utilities+0x20f>
f011dece:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011ded2:	75 41                	jne    f011df15 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011ded4:	83 ec 0c             	sub    $0xc,%esp
f011ded7:	68 78 03 13 f0       	push   $0xf0130378
f011dedc:	e8 aa 30 fe ff       	call   f0100f8b <cprintf>
f011dee1:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011dee4:	83 ec 08             	sub    $0x8,%esp
f011dee7:	ff 75 d8             	pushl  -0x28(%ebp)
f011deea:	68 a8 03 13 f0       	push   $0xf01303a8
f011deef:	e8 97 30 fe ff       	call   f0100f8b <cprintf>
f011def4:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011def7:	83 ec 0c             	sub    $0xc,%esp
f011defa:	68 78 03 13 f0       	push   $0xf0130378
f011deff:	e8 87 30 fe ff       	call   f0100f8b <cprintf>
f011df04:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011df07:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011df10:	e9 81 02 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011df15:	83 ec 0c             	sub    $0xc,%esp
f011df18:	68 c8 03 13 f0       	push   $0xf01303c8
f011df1d:	e8 69 30 fe ff       	call   f0100f8b <cprintf>
f011df22:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011df25:	83 ec 08             	sub    $0x8,%esp
f011df28:	ff 75 d8             	pushl  -0x28(%ebp)
f011df2b:	68 00 04 13 f0       	push   $0xf0130400
f011df30:	e8 56 30 fe ff       	call   f0100f8b <cprintf>
f011df35:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011df38:	83 ec 0c             	sub    $0xc,%esp
f011df3b:	68 c8 03 13 f0       	push   $0xf01303c8
f011df40:	e8 46 30 fe ff       	call   f0100f8b <cprintf>
f011df45:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011df48:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011df4b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011df51:	e9 40 02 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011df56:	83 ec 08             	sub    $0x8,%esp
f011df59:	68 23 04 13 f0       	push   $0xf0130423
f011df5e:	ff 75 08             	pushl  0x8(%ebp)
f011df61:	e8 6a 17 00 00       	call   f011f6d0 <strcmp>
f011df66:	83 c4 10             	add    $0x10,%esp
f011df69:	85 c0                	test   %eax,%eax
f011df6b:	75 77                	jne    f011dfe4 <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011df6d:	a1 e0 ed 17 f0       	mov    0xf017ede0,%eax
f011df72:	85 c0                	test   %eax,%eax
f011df74:	74 34                	je     f011dfaa <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011df76:	c7 05 e0 ed 17 f0 00 	movl   $0x0,0xf017ede0
f011df7d:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011df80:	83 ec 08             	sub    $0x8,%esp
f011df83:	68 2d 04 13 f0       	push   $0xf013042d
f011df88:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011df8d:	e8 44 1a ff ff       	call   f010f9d6 <init_channel>
f011df92:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011df95:	83 ec 08             	sub    $0x8,%esp
f011df98:	68 3a 04 13 f0       	push   $0xf013043a
f011df9d:	68 20 84 b0 f0       	push   $0xf0b08420
f011dfa2:	e8 3e 16 ff ff       	call   f010f5e5 <init_spinlock>
f011dfa7:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011dfaa:	83 ec 0c             	sub    $0xc,%esp
f011dfad:	68 20 84 b0 f0       	push   $0xf0b08420
f011dfb2:	e8 5f 16 ff ff       	call   f010f616 <acquire_spinlock>
f011dfb7:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011dfba:	83 ec 08             	sub    $0x8,%esp
f011dfbd:	68 20 84 b0 f0       	push   $0xf0b08420
f011dfc2:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011dfc7:	e8 37 1a ff ff       	call   f010fa03 <sleep>
f011dfcc:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011dfcf:	83 ec 0c             	sub    $0xc,%esp
f011dfd2:	68 20 84 b0 f0       	push   $0xf0b08420
f011dfd7:	e8 c1 16 ff ff       	call   f010f69d <release_spinlock>
f011dfdc:	83 c4 10             	add    $0x10,%esp
f011dfdf:	e9 b2 01 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011dfe4:	83 ec 08             	sub    $0x8,%esp
f011dfe7:	68 4c 04 13 f0       	push   $0xf013044c
f011dfec:	ff 75 08             	pushl  0x8(%ebp)
f011dfef:	e8 dc 16 00 00       	call   f011f6d0 <strcmp>
f011dff4:	83 c4 10             	add    $0x10,%esp
f011dff7:	85 c0                	test   %eax,%eax
f011dff9:	75 15                	jne    f011e010 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011dffb:	83 ec 0c             	sub    $0xc,%esp
f011dffe:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011e003:	e8 68 1a ff ff       	call   f010fa70 <wakeup_one>
f011e008:	83 c4 10             	add    $0x10,%esp
f011e00b:	e9 86 01 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011e010:	83 ec 08             	sub    $0x8,%esp
f011e013:	68 5a 04 13 f0       	push   $0xf013045a
f011e018:	ff 75 08             	pushl  0x8(%ebp)
f011e01b:	e8 b0 16 00 00       	call   f011f6d0 <strcmp>
f011e020:	83 c4 10             	add    $0x10,%esp
f011e023:	85 c0                	test   %eax,%eax
f011e025:	75 15                	jne    f011e03c <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011e027:	83 ec 0c             	sub    $0xc,%esp
f011e02a:	68 a0 82 b0 f0       	push   $0xf0b082a0
f011e02f:	e8 c0 1a ff ff       	call   f010faf4 <wakeup_all>
f011e034:	83 c4 10             	add    $0x10,%esp
f011e037:	e9 5a 01 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011e03c:	83 ec 08             	sub    $0x8,%esp
f011e03f:	68 68 04 13 f0       	push   $0xf0130468
f011e044:	ff 75 08             	pushl  0x8(%ebp)
f011e047:	e8 84 16 00 00       	call   f011f6d0 <strcmp>
f011e04c:	83 c4 10             	add    $0x10,%esp
f011e04f:	85 c0                	test   %eax,%eax
f011e051:	75 17                	jne    f011e06a <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011e053:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e056:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011e059:	a1 ac 82 b0 f0       	mov    0xf0b082ac,%eax
f011e05e:	89 c2                	mov    %eax,%edx
f011e060:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e063:	89 10                	mov    %edx,(%eax)
f011e065:	e9 2c 01 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011e06a:	83 ec 08             	sub    $0x8,%esp
f011e06d:	68 7d 04 13 f0       	push   $0xf013047d
f011e072:	ff 75 08             	pushl  0x8(%ebp)
f011e075:	e8 56 16 00 00       	call   f011f6d0 <strcmp>
f011e07a:	83 c4 10             	add    $0x10,%esp
f011e07d:	85 c0                	test   %eax,%eax
f011e07f:	75 1a                	jne    f011e09b <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011e081:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e084:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011e087:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e08c:	8b 40 0c             	mov    0xc(%eax),%eax
f011e08f:	89 c2                	mov    %eax,%edx
f011e091:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e094:	89 10                	mov    %edx,(%eax)
f011e096:	e9 fb 00 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011e09b:	83 ec 08             	sub    $0x8,%esp
f011e09e:	68 93 04 13 f0       	push   $0xf0130493
f011e0a3:	ff 75 08             	pushl  0x8(%ebp)
f011e0a6:	e8 25 16 00 00       	call   f011f6d0 <strcmp>
f011e0ab:	83 c4 10             	add    $0x10,%esp
f011e0ae:	85 c0                	test   %eax,%eax
f011e0b0:	75 3d                	jne    f011e0ef <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011e0b2:	a1 e4 ed 17 f0       	mov    0xf017ede4,%eax
f011e0b7:	85 c0                	test   %eax,%eax
f011e0b9:	74 1f                	je     f011e0da <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011e0bb:	c7 05 e4 ed 17 f0 00 	movl   $0x0,0xf017ede4
f011e0c2:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011e0c5:	83 ec 08             	sub    $0x8,%esp
f011e0c8:	68 a8 04 13 f0       	push   $0xf01304a8
f011e0cd:	68 00 83 b0 f0       	push   $0xf0b08300
f011e0d2:	e8 99 17 ff ff       	call   f010f870 <init_sleeplock>
f011e0d7:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011e0da:	83 ec 0c             	sub    $0xc,%esp
f011e0dd:	68 00 83 b0 f0       	push   $0xf0b08300
f011e0e2:	e8 4d 18 ff ff       	call   f010f934 <acquire_sleeplock>
f011e0e7:	83 c4 10             	add    $0x10,%esp
f011e0ea:	e9 a7 00 00 00       	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011e0ef:	83 ec 08             	sub    $0x8,%esp
f011e0f2:	68 b8 04 13 f0       	push   $0xf01304b8
f011e0f7:	ff 75 08             	pushl  0x8(%ebp)
f011e0fa:	e8 d1 15 00 00       	call   f011f6d0 <strcmp>
f011e0ff:	83 c4 10             	add    $0x10,%esp
f011e102:	85 c0                	test   %eax,%eax
f011e104:	75 12                	jne    f011e118 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011e106:	83 ec 0c             	sub    $0xc,%esp
f011e109:	68 00 83 b0 f0       	push   $0xf0b08300
f011e10e:	e8 7b 18 ff ff       	call   f010f98e <release_sleeplock>
f011e113:	83 c4 10             	add    $0x10,%esp
f011e116:	eb 7e                	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011e118:	83 ec 08             	sub    $0x8,%esp
f011e11b:	68 cd 04 13 f0       	push   $0xf01304cd
f011e120:	ff 75 08             	pushl  0x8(%ebp)
f011e123:	e8 a8 15 00 00       	call   f011f6d0 <strcmp>
f011e128:	83 c4 10             	add    $0x10,%esp
f011e12b:	85 c0                	test   %eax,%eax
f011e12d:	75 14                	jne    f011e143 <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011e12f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e132:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011e135:	a1 80 83 b0 f0       	mov    0xf0b08380,%eax
f011e13a:	89 c2                	mov    %eax,%edx
f011e13c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e13f:	89 10                	mov    %edx,(%eax)
f011e141:	eb 53                	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011e143:	83 ec 08             	sub    $0x8,%esp
f011e146:	68 e2 04 13 f0       	push   $0xf01304e2
f011e14b:	ff 75 08             	pushl  0x8(%ebp)
f011e14e:	e8 7d 15 00 00       	call   f011f6d0 <strcmp>
f011e153:	83 c4 10             	add    $0x10,%esp
f011e156:	85 c0                	test   %eax,%eax
f011e158:	75 13                	jne    f011e16d <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011e15a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e15d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011e160:	8b 15 00 83 b0 f0    	mov    0xf0b08300,%edx
f011e166:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e169:	89 10                	mov    %edx,(%eax)
f011e16b:	eb 29                	jmp    f011e196 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011e16d:	83 ec 08             	sub    $0x8,%esp
f011e170:	68 f3 04 13 f0       	push   $0xf01304f3
f011e175:	ff 75 08             	pushl  0x8(%ebp)
f011e178:	e8 53 15 00 00       	call   f011f6d0 <strcmp>
f011e17d:	83 c4 10             	add    $0x10,%esp
f011e180:	85 c0                	test   %eax,%eax
f011e182:	75 12                	jne    f011e196 <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011e184:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e187:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011e18a:	a1 04 84 b0 f0       	mov    0xf0b08404,%eax
f011e18f:	89 c2                	mov    %eax,%edx
f011e191:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e194:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011e196:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e19a:	79 5b                	jns    f011e1f7 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011e19c:	83 ec 08             	sub    $0x8,%esp
f011e19f:	68 04 05 13 f0       	push   $0xf0130504
f011e1a4:	ff 75 08             	pushl  0x8(%ebp)
f011e1a7:	e8 24 15 00 00       	call   f011f6d0 <strcmp>
f011e1ac:	83 c4 10             	add    $0x10,%esp
f011e1af:	85 c0                	test   %eax,%eax
f011e1b1:	75 44                	jne    f011e1f7 <sys_utilities+0x532>
		{
			switch (value)
f011e1b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e1b6:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011e1b9:	74 07                	je     f011e1c2 <sys_utilities+0x4fd>
f011e1bb:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011e1be:	74 19                	je     f011e1d9 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011e1c0:	eb 35                	jmp    f011e1f7 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011e1c2:	83 ec 0c             	sub    $0xc,%esp
f011e1c5:	68 14 05 13 f0       	push   $0xf0130514
f011e1ca:	e8 bc 2d fe ff       	call   f0100f8b <cprintf>
f011e1cf:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011e1d2:	e8 a4 0d ff ff       	call   f010ef7b <setPageReplacmentAlgorithmFIFO>
				break;
f011e1d7:	eb 1e                	jmp    f011e1f7 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011e1d9:	83 ec 0c             	sub    $0xc,%esp
f011e1dc:	68 84 05 13 f0       	push   $0xf0130584
f011e1e1:	e8 a5 2d fe ff       	call   f0100f8b <cprintf>
f011e1e6:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011e1e9:	83 ec 0c             	sub    $0xc,%esp
f011e1ec:	6a 02                	push   $0x2
f011e1ee:	e8 45 0d ff ff       	call   f010ef38 <setPageReplacmentAlgorithmLRU>
f011e1f3:	83 c4 10             	add    $0x10,%esp
				break;
f011e1f6:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011e1f7:	90                   	nop
f011e1f8:	c9                   	leave  
f011e1f9:	c3                   	ret    

f011e1fa <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011e1fa:	55                   	push   %ebp
f011e1fb:	89 e5                	mov    %esp,%ebp
f011e1fd:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011e200:	8b 45 08             	mov    0x8(%ebp),%eax
f011e203:	8b 00                	mov    (%eax),%eax
f011e205:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011e208:	8b 45 08             	mov    0x8(%ebp),%eax
f011e20b:	8b 00                	mov    (%eax),%eax
f011e20d:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011e210:	eb 52                	jmp    f011e264 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011e212:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e215:	8b 00                	mov    (%eax),%eax
f011e217:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011e21a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e21d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e220:	75 12                	jne    f011e234 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011e222:	83 ec 0c             	sub    $0xc,%esp
f011e225:	68 f8 05 13 f0       	push   $0xf01305f8
f011e22a:	e8 5c 2d fe ff       	call   f0100f8b <cprintf>
f011e22f:	83 c4 10             	add    $0x10,%esp
			break;
f011e232:	eb 3f                	jmp    f011e273 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011e234:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e238:	74 38                	je     f011e272 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011e23a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e23d:	8b 00                	mov    (%eax),%eax
f011e23f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011e242:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e245:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e248:	75 12                	jne    f011e25c <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011e24a:	83 ec 0c             	sub    $0xc,%esp
f011e24d:	68 14 06 13 f0       	push   $0xf0130614
f011e252:	e8 34 2d fe ff       	call   f0100f8b <cprintf>
f011e257:	83 c4 10             	add    $0x10,%esp
			break;
f011e25a:	eb 17                	jmp    f011e273 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011e25c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e25f:	8b 00                	mov    (%eax),%eax
f011e261:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011e264:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e268:	74 09                	je     f011e273 <detect_loop_in_FrameInfo_list+0x79>
f011e26a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e26e:	75 a2                	jne    f011e212 <detect_loop_in_FrameInfo_list+0x18>
f011e270:	eb 01                	jmp    f011e273 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011e272:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011e273:	83 ec 0c             	sub    $0xc,%esp
f011e276:	68 2b 06 13 f0       	push   $0xf013062b
f011e27b:	e8 0b 2d fe ff       	call   f0100f8b <cprintf>
f011e280:	83 c4 10             	add    $0x10,%esp
}
f011e283:	90                   	nop
f011e284:	c9                   	leave  
f011e285:	c3                   	ret    

f011e286 <scarce_memory>:

void scarce_memory()
{
f011e286:	55                   	push   %ebp
f011e287:	89 e5                	mov    %esp,%ebp
f011e289:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011e28c:	a1 90 d4 6b f0       	mov    0xf06bd490,%eax
f011e291:	ba 64 00 00 00       	mov    $0x64,%edx
f011e296:	29 c2                	sub    %eax,%edx
f011e298:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011e29d:	0f af c2             	imul   %edx,%eax
f011e2a0:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e2a5:	f7 e2                	mul    %edx
f011e2a7:	89 d0                	mov    %edx,%eax
f011e2a9:	c1 e8 05             	shr    $0x5,%eax
f011e2ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011e2af:	a1 90 d4 6b f0       	mov    0xf06bd490,%eax
f011e2b4:	ba 64 00 00 00       	mov    $0x64,%edx
f011e2b9:	29 c2                	sub    %eax,%edx
f011e2bb:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011e2c0:	89 d1                	mov    %edx,%ecx
f011e2c2:	0f af c8             	imul   %eax,%ecx
f011e2c5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e2ca:	f7 e1                	mul    %ecx
f011e2cc:	c1 ea 05             	shr    $0x5,%edx
f011e2cf:	89 d0                	mov    %edx,%eax
f011e2d1:	c1 e0 02             	shl    $0x2,%eax
f011e2d4:	01 d0                	add    %edx,%eax
f011e2d6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e2dd:	01 d0                	add    %edx,%eax
f011e2df:	c1 e0 02             	shl    $0x2,%eax
f011e2e2:	29 c1                	sub    %eax,%ecx
f011e2e4:	89 ca                	mov    %ecx,%edx
f011e2e6:	85 d2                	test   %edx,%edx
f011e2e8:	74 03                	je     f011e2ed <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011e2ea:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011e2ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011e2f4:	83 ec 0c             	sub    $0xc,%esp
f011e2f7:	68 80 d3 6b f0       	push   $0xf06bd380
f011e2fc:	e8 15 13 ff ff       	call   f010f616 <acquire_spinlock>
f011e301:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011e304:	a1 6c d3 6b f0       	mov    0xf06bd36c,%eax
f011e309:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011e30c:	8b 15 58 d5 6b f0    	mov    0xf06bd558,%edx
f011e312:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e315:	29 c2                	sub    %eax,%edx
f011e317:	89 d0                	mov    %edx,%eax
f011e319:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011e31c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e31f:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011e322:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011e325:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e32c:	eb 12                	jmp    f011e340 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011e32e:	83 ec 0c             	sub    $0xc,%esp
f011e331:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011e334:	50                   	push   %eax
f011e335:	e8 78 9e fe ff       	call   f01081b2 <allocate_frame>
f011e33a:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011e33d:	ff 45 f0             	incl   -0x10(%ebp)
f011e340:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e343:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011e346:	76 e6                	jbe    f011e32e <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011e348:	83 ec 0c             	sub    $0xc,%esp
f011e34b:	68 80 d3 6b f0       	push   $0xf06bd380
f011e350:	e8 48 13 ff ff       	call   f010f69d <release_spinlock>
f011e355:	83 c4 10             	add    $0x10,%esp

}
f011e358:	90                   	nop
f011e359:	c9                   	leave  
f011e35a:	c3                   	ret    

f011e35b <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011e35b:	55                   	push   %ebp
f011e35c:	89 e5                	mov    %esp,%ebp
f011e35e:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011e361:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011e368:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011e36f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011e376:	e8 0d d0 fe ff       	call   f010b388 <get_cpu_proc>
f011e37b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011e37e:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e382:	75 19                	jne    f011e39d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011e384:	68 45 06 13 f0       	push   $0xf0130645
f011e389:	68 93 02 13 f0       	push   $0xf0130293
f011e38e:	68 79 01 00 00       	push   $0x179
f011e393:	68 db 02 13 f0       	push   $0xf01302db
f011e398:	e8 9c 1f fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011e39d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011e3a1:	0f 85 d6 01 00 00    	jne    f011e57d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011e3a7:	83 ec 0c             	sub    $0xc,%esp
f011e3aa:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e3af:	e8 62 12 ff ff       	call   f010f616 <acquire_spinlock>
f011e3b4:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011e3b7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011e3be:	e9 d2 00 00 00       	jmp    f011e495 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011e3c3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011e3ca:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e3cf:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e3d2:	c1 e2 04             	shl    $0x4,%edx
f011e3d5:	01 d0                	add    %edx,%eax
f011e3d7:	8b 00                	mov    (%eax),%eax
f011e3d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e3dc:	eb 7c                	jmp    f011e45a <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011e3de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e3e1:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e3e7:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e3ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e3ed:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e3f3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e3f6:	0f af c2             	imul   %edx,%eax
f011e3f9:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e3fe:	f7 e2                	mul    %edx
f011e400:	89 d0                	mov    %edx,%eax
f011e402:	c1 e8 05             	shr    $0x5,%eax
f011e405:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e408:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e40b:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e411:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011e414:	89 d1                	mov    %edx,%ecx
f011e416:	0f af c8             	imul   %eax,%ecx
f011e419:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e41e:	f7 e1                	mul    %ecx
f011e420:	c1 ea 05             	shr    $0x5,%edx
f011e423:	89 d0                	mov    %edx,%eax
f011e425:	c1 e0 02             	shl    $0x2,%eax
f011e428:	01 d0                	add    %edx,%eax
f011e42a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e431:	01 d0                	add    %edx,%eax
f011e433:	c1 e0 02             	shl    $0x2,%eax
f011e436:	29 c1                	sub    %eax,%ecx
f011e438:	89 ca                	mov    %ecx,%edx
f011e43a:	85 d2                	test   %edx,%edx
f011e43c:	74 03                	je     f011e441 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011e43e:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011e441:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e444:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011e447:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e44c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e44f:	c1 e2 04             	shl    $0x4,%edx
f011e452:	01 d0                	add    %edx,%eax
f011e454:	8b 40 08             	mov    0x8(%eax),%eax
f011e457:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e45a:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e45f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e462:	c1 e2 04             	shl    $0x4,%edx
f011e465:	01 d0                	add    %edx,%eax
f011e467:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e46b:	74 08                	je     f011e475 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011e46d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011e470:	8b 52 08             	mov    0x8(%edx),%edx
f011e473:	eb 05                	jmp    f011e47a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011e475:	ba 00 00 00 00       	mov    $0x0,%edx
f011e47a:	89 50 08             	mov    %edx,0x8(%eax)
f011e47d:	8b 40 08             	mov    0x8(%eax),%eax
f011e480:	85 c0                	test   %eax,%eax
f011e482:	0f 85 56 ff ff ff    	jne    f011e3de <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011e488:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e48c:	0f 85 4c ff ff ff    	jne    f011e3de <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011e492:	ff 45 e8             	incl   -0x18(%ebp)
f011e495:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e49a:	0f b6 c0             	movzbl %al,%eax
f011e49d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e4a0:	0f 8f 1d ff ff ff    	jg     f011e3c3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011e4a6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011e4ad:	a1 40 d3 6b f0       	mov    0xf06bd340,%eax
f011e4b2:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e4b5:	eb 1a                	jmp    f011e4d1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011e4b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4ba:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e4c0:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011e4c3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011e4c6:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011e4c9:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011e4ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011e4d1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e4d5:	74 08                	je     f011e4df <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011e4d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4da:	8b 40 08             	mov    0x8(%eax),%eax
f011e4dd:	eb 05                	jmp    f011e4e4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011e4df:	b8 00 00 00 00       	mov    $0x0,%eax
f011e4e4:	a3 48 d3 6b f0       	mov    %eax,0xf06bd348
f011e4e9:	a1 48 d3 6b f0       	mov    0xf06bd348,%eax
f011e4ee:	85 c0                	test   %eax,%eax
f011e4f0:	75 c5                	jne    f011e4b7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011e4f2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e4f6:	75 bf                	jne    f011e4b7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e4f8:	83 ec 0c             	sub    $0xc,%esp
f011e4fb:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e500:	e8 98 11 ff ff       	call   f010f69d <release_spinlock>
f011e505:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011e508:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011e50c:	0f 84 d4 00 00 00    	je     f011e5e6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011e512:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e515:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e51b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e51e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e521:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e527:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e52a:	0f af c2             	imul   %edx,%eax
f011e52d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e532:	f7 e2                	mul    %edx
f011e534:	89 d0                	mov    %edx,%eax
f011e536:	c1 e8 05             	shr    $0x5,%eax
f011e539:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e53c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e53f:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e545:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011e548:	89 d1                	mov    %edx,%ecx
f011e54a:	0f af c8             	imul   %eax,%ecx
f011e54d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e552:	f7 e1                	mul    %ecx
f011e554:	c1 ea 05             	shr    $0x5,%edx
f011e557:	89 d0                	mov    %edx,%eax
f011e559:	c1 e0 02             	shl    $0x2,%eax
f011e55c:	01 d0                	add    %edx,%eax
f011e55e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e565:	01 d0                	add    %edx,%eax
f011e567:	c1 e0 02             	shl    $0x2,%eax
f011e56a:	29 c1                	sub    %eax,%ecx
f011e56c:	89 ca                	mov    %ecx,%edx
f011e56e:	85 d2                	test   %edx,%edx
f011e570:	74 03                	je     f011e575 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011e572:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011e575:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011e578:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e57b:	eb 69                	jmp    f011e5e6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011e57d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e580:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e586:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011e589:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e58c:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e592:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e595:	0f af c2             	imul   %edx,%eax
f011e598:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011e59d:	f7 e2                	mul    %edx
f011e59f:	89 d0                	mov    %edx,%eax
f011e5a1:	c1 e8 05             	shr    $0x5,%eax
f011e5a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011e5a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e5aa:	8b 90 8c 05 00 00    	mov    0x58c(%eax),%edx
f011e5b0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011e5b3:	89 d1                	mov    %edx,%ecx
f011e5b5:	0f af c8             	imul   %eax,%ecx
f011e5b8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e5bd:	f7 e1                	mul    %ecx
f011e5bf:	c1 ea 05             	shr    $0x5,%edx
f011e5c2:	89 d0                	mov    %edx,%eax
f011e5c4:	c1 e0 02             	shl    $0x2,%eax
f011e5c7:	01 d0                	add    %edx,%eax
f011e5c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e5d0:	01 d0                	add    %edx,%eax
f011e5d2:	c1 e0 02             	shl    $0x2,%eax
f011e5d5:	29 c1                	sub    %eax,%ecx
f011e5d7:	89 ca                	mov    %ecx,%edx
f011e5d9:	85 d2                	test   %edx,%edx
f011e5db:	74 03                	je     f011e5e0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011e5dd:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011e5e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e5e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011e5e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011e5e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e5ec:	01 c2                	add    %eax,%edx
f011e5ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e5f1:	01 d0                	add    %edx,%eax
}
f011e5f3:	c9                   	leave  
f011e5f4:	c3                   	ret    

f011e5f5 <schenv>:


void schenv()
{
f011e5f5:	55                   	push   %ebp
f011e5f6:	89 e5                	mov    %esp,%ebp
f011e5f8:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011e5fb:	c6 05 a0 da 6b f0 00 	movb   $0x0,0xf06bdaa0
	__ne = NULL;
f011e602:	c7 05 ac d7 6b f0 00 	movl   $0x0,0xf06bd7ac
f011e609:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011e60c:	83 ec 0c             	sub    $0xc,%esp
f011e60f:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e614:	e8 fd 0f ff ff       	call   f010f616 <acquire_spinlock>
f011e619:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011e61c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e623:	eb 3f                	jmp    f011e664 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011e625:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e62a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e62d:	c1 e2 04             	shl    $0x4,%edx
f011e630:	01 d0                	add    %edx,%eax
f011e632:	83 ec 0c             	sub    $0xc,%esp
f011e635:	50                   	push   %eax
f011e636:	e8 57 69 fe ff       	call   f0104f92 <queue_size>
f011e63b:	83 c4 10             	add    $0x10,%esp
f011e63e:	85 c0                	test   %eax,%eax
f011e640:	74 1f                	je     f011e661 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011e642:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e647:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e64a:	c1 e2 04             	shl    $0x4,%edx
f011e64d:	01 d0                	add    %edx,%eax
f011e64f:	8b 40 04             	mov    0x4(%eax),%eax
f011e652:	a3 ac d7 6b f0       	mov    %eax,0xf06bd7ac
				__nl = i;
f011e657:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e65a:	a2 a0 da 6b f0       	mov    %al,0xf06bdaa0
				break;
f011e65f:	eb 10                	jmp    f011e671 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011e661:	ff 45 f4             	incl   -0xc(%ebp)
f011e664:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e669:	0f b6 c0             	movzbl %al,%eax
f011e66c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e66f:	7f b4                	jg     f011e625 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011e671:	83 ec 0c             	sub    $0xc,%esp
f011e674:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e679:	e8 1f 10 ff ff       	call   f010f69d <release_spinlock>
f011e67e:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011e681:	e8 02 cd fe ff       	call   f010b388 <get_cpu_proc>
f011e686:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011e689:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e68d:	0f 84 82 00 00 00    	je     f011e715 <schenv+0x120>
	{
		if (__ne != NULL)
f011e693:	a1 ac d7 6b f0       	mov    0xf06bd7ac,%eax
f011e698:	85 c0                	test   %eax,%eax
f011e69a:	74 49                	je     f011e6e5 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011e69c:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e6a1:	0f b6 c0             	movzbl %al,%eax
f011e6a4:	8d 50 01             	lea    0x1(%eax),%edx
f011e6a7:	a0 a0 da 6b f0       	mov    0xf06bdaa0,%al
f011e6ac:	0f b6 c0             	movzbl %al,%eax
f011e6af:	39 c2                	cmp    %eax,%edx
f011e6b1:	7d 62                	jge    f011e715 <schenv+0x120>
			{
				__ne = cur_env;
f011e6b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e6b6:	a3 ac d7 6b f0       	mov    %eax,0xf06bd7ac
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011e6bb:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e6c0:	0f b6 c0             	movzbl %al,%eax
f011e6c3:	8a 15 04 da 6b f0    	mov    0xf06bda04,%dl
f011e6c9:	0f b6 d2             	movzbl %dl,%edx
f011e6cc:	4a                   	dec    %edx
f011e6cd:	39 d0                	cmp    %edx,%eax
f011e6cf:	7d 08                	jge    f011e6d9 <schenv+0xe4>
f011e6d1:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e6d6:	40                   	inc    %eax
f011e6d7:	eb 05                	jmp    f011e6de <schenv+0xe9>
f011e6d9:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e6de:	a2 a0 da 6b f0       	mov    %al,0xf06bdaa0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011e6e3:	eb 30                	jmp    f011e715 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011e6e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e6e8:	a3 ac d7 6b f0       	mov    %eax,0xf06bd7ac
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011e6ed:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e6f2:	0f b6 c0             	movzbl %al,%eax
f011e6f5:	8a 15 04 da 6b f0    	mov    0xf06bda04,%dl
f011e6fb:	0f b6 d2             	movzbl %dl,%edx
f011e6fe:	4a                   	dec    %edx
f011e6ff:	39 d0                	cmp    %edx,%eax
f011e701:	7d 08                	jge    f011e70b <schenv+0x116>
f011e703:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e708:	40                   	inc    %eax
f011e709:	eb 05                	jmp    f011e710 <schenv+0x11b>
f011e70b:	a0 a1 d2 6b f0       	mov    0xf06bd2a1,%al
f011e710:	a2 a0 da 6b f0       	mov    %al,0xf06bdaa0
		}
	}
}
f011e715:	90                   	nop
f011e716:	c9                   	leave  
f011e717:	c3                   	ret    

f011e718 <chksch>:

void chksch(uint8 onoff)
{
f011e718:	55                   	push   %ebp
f011e719:	89 e5                	mov    %esp,%ebp
f011e71b:	83 ec 18             	sub    $0x18,%esp
f011e71e:	8b 45 08             	mov    0x8(%ebp),%eax
f011e721:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011e724:	e8 e9 7f fe ff       	call   f0106712 <isSchedMethodBSD>
f011e729:	85 c0                	test   %eax,%eax
f011e72b:	74 48                	je     f011e775 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011e72d:	e8 8e 7f fe ff       	call   f01066c0 <get_load_average>
f011e732:	a3 28 da 6b f0       	mov    %eax,0xf06bda28
f011e737:	a1 28 da 6b f0       	mov    0xf06bda28,%eax
f011e73c:	a3 5c d5 6b f0       	mov    %eax,0xf06bd55c
		acquire_spinlock(&ProcessQueues.qlock);
f011e741:	83 ec 0c             	sub    $0xc,%esp
f011e744:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e749:	e8 c8 0e ff ff       	call   f010f616 <acquire_spinlock>
f011e74e:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011e751:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011e756:	a3 00 d4 6b f0       	mov    %eax,0xf06bd400
		}
		release_spinlock(&ProcessQueues.qlock);
f011e75b:	83 ec 0c             	sub    $0xc,%esp
f011e75e:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e763:	e8 35 0f ff ff       	call   f010f69d <release_spinlock>
f011e768:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011e76b:	c7 05 bc d7 6b f0 01 	movl   $0x1,0xf06bd7bc
f011e772:	00 00 00 
	}
	__chkstatus = onoff;
f011e775:	8a 45 f4             	mov    -0xc(%ebp),%al
f011e778:	a2 a8 d7 6b f0       	mov    %al,0xf06bd7a8
}
f011e77d:	90                   	nop
f011e77e:	c9                   	leave  
f011e77f:	c3                   	ret    

f011e780 <chk1>:
void chk1()
{
f011e780:	55                   	push   %ebp
f011e781:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011e783:	90                   	nop
f011e784:	5d                   	pop    %ebp
f011e785:	c3                   	ret    

f011e786 <chk2>:
void chk2(struct Env* __se)
{
f011e786:	55                   	push   %ebp
f011e787:	89 e5                	mov    %esp,%ebp
f011e789:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011e78c:	a0 a8 d7 6b f0       	mov    0xf06bd7a8,%al
f011e791:	84 c0                	test   %al,%al
f011e793:	0f 84 59 03 00 00    	je     f011eaf2 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011e799:	e8 74 7f fe ff       	call   f0106712 <isSchedMethodBSD>
f011e79e:	85 c0                	test   %eax,%eax
f011e7a0:	0f 84 4d 03 00 00    	je     f011eaf3 <chk2+0x36d>
	{
		__nla = get_load_average();
f011e7a6:	e8 15 7f fe ff       	call   f01066c0 <get_load_average>
f011e7ab:	a3 94 d4 6b f0       	mov    %eax,0xf06bd494
		acquire_spinlock(&ProcessQueues.qlock);
f011e7b0:	83 ec 0c             	sub    $0xc,%esp
f011e7b3:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e7b8:	e8 59 0e ff ff       	call   f010f616 <acquire_spinlock>
f011e7bd:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e7c0:	a1 4c d3 6b f0       	mov    0xf06bd34c,%eax
f011e7c5:	a3 b0 d7 6b f0       	mov    %eax,0xf06bd7b0
		}
		release_spinlock(&ProcessQueues.qlock);
f011e7ca:	83 ec 0c             	sub    $0xc,%esp
f011e7cd:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e7d2:	e8 c6 0e ff ff       	call   f010f69d <release_spinlock>
f011e7d7:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011e7da:	a1 bc d7 6b f0       	mov    0xf06bd7bc,%eax
f011e7df:	85 c0                	test   %eax,%eax
f011e7e1:	74 72                	je     f011e855 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011e7e3:	83 ec 0c             	sub    $0xc,%esp
f011e7e6:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e7eb:	e8 26 0e ff ff       	call   f010f616 <acquire_spinlock>
f011e7f0:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011e7f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e7f7:	0f 95 c0             	setne  %al
f011e7fa:	0f b6 c0             	movzbl %al,%eax
f011e7fd:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e802:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e807:	0f b6 c0             	movzbl %al,%eax
f011e80a:	48                   	dec    %eax
f011e80b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011e80e:	eb 20                	jmp    f011e830 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011e810:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e815:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e818:	c1 e2 04             	shl    $0x4,%edx
f011e81b:	01 d0                	add    %edx,%eax
f011e81d:	8b 40 0c             	mov    0xc(%eax),%eax
f011e820:	8b 15 74 d9 6b f0    	mov    0xf06bd974,%edx
f011e826:	01 d0                	add    %edx,%eax
f011e828:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e82d:	ff 4d f4             	decl   -0xc(%ebp)
f011e830:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011e834:	79 da                	jns    f011e810 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011e836:	c7 05 bc d7 6b f0 00 	movl   $0x0,0xf06bd7bc
f011e83d:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011e840:	83 ec 0c             	sub    $0xc,%esp
f011e843:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e848:	e8 50 0e ff ff       	call   f010f69d <release_spinlock>
f011e84d:	83 c4 10             	add    $0x10,%esp
f011e850:	e9 91 02 00 00       	jmp    f011eae6 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011e855:	8b 15 00 d4 6b f0    	mov    0xf06bd400,%edx
f011e85b:	a1 b0 d7 6b f0       	mov    0xf06bd7b0,%eax
f011e860:	39 c2                	cmp    %eax,%edx
f011e862:	74 63                	je     f011e8c7 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011e864:	83 ec 0c             	sub    $0xc,%esp
f011e867:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e86c:	e8 a5 0d ff ff       	call   f010f616 <acquire_spinlock>
f011e871:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011e874:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e878:	0f 95 c0             	setne  %al
f011e87b:	0f b6 c0             	movzbl %al,%eax
f011e87e:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e883:	a0 04 da 6b f0       	mov    0xf06bda04,%al
f011e888:	0f b6 c0             	movzbl %al,%eax
f011e88b:	48                   	dec    %eax
f011e88c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e88f:	eb 20                	jmp    f011e8b1 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011e891:	a1 50 d3 6b f0       	mov    0xf06bd350,%eax
f011e896:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011e899:	c1 e2 04             	shl    $0x4,%edx
f011e89c:	01 d0                	add    %edx,%eax
f011e89e:	8b 40 0c             	mov    0xc(%eax),%eax
f011e8a1:	8b 15 74 d9 6b f0    	mov    0xf06bd974,%edx
f011e8a7:	01 d0                	add    %edx,%eax
f011e8a9:	a3 74 d9 6b f0       	mov    %eax,0xf06bd974
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011e8ae:	ff 4d f0             	decl   -0x10(%ebp)
f011e8b1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011e8b5:	79 da                	jns    f011e891 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011e8b7:	83 ec 0c             	sub    $0xc,%esp
f011e8ba:	68 c0 d2 6b f0       	push   $0xf06bd2c0
f011e8bf:	e8 d9 0d ff ff       	call   f010f69d <release_spinlock>
f011e8c4:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011e8c7:	e8 8d 7d fe ff       	call   f0106659 <timer_ticks>
f011e8cc:	6a 00                	push   $0x0
f011e8ce:	68 e8 03 00 00       	push   $0x3e8
f011e8d3:	52                   	push   %edx
f011e8d4:	50                   	push   %eax
f011e8d5:	e8 ee 31 00 00       	call   f0121ac8 <__moddi3>
f011e8da:	83 c4 10             	add    $0x10,%esp
f011e8dd:	09 d0                	or     %edx,%eax
f011e8df:	85 c0                	test   %eax,%eax
f011e8e1:	75 32                	jne    f011e915 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011e8e3:	8b 15 5c d5 6b f0    	mov    0xf06bd55c,%edx
f011e8e9:	a1 94 d4 6b f0       	mov    0xf06bd494,%eax
f011e8ee:	39 c2                	cmp    %eax,%edx
f011e8f0:	75 19                	jne    f011e90b <chk2+0x185>
f011e8f2:	68 55 06 13 f0       	push   $0xf0130655
f011e8f7:	68 93 02 13 f0       	push   $0xf0130293
f011e8fc:	68 35 02 00 00       	push   $0x235
f011e901:	68 db 02 13 f0       	push   $0xf01302db
f011e906:	e8 be 1a fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011e90b:	a1 94 d4 6b f0       	mov    0xf06bd494,%eax
f011e910:	a3 5c d5 6b f0       	mov    %eax,0xf06bd55c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011e915:	e8 3f 7d fe ff       	call   f0106659 <timer_ticks>
f011e91a:	6a 00                	push   $0x0
f011e91c:	6a 64                	push   $0x64
f011e91e:	52                   	push   %edx
f011e91f:	50                   	push   %eax
f011e920:	e8 a3 31 00 00       	call   f0121ac8 <__moddi3>
f011e925:	83 c4 10             	add    $0x10,%esp
f011e928:	09 d0                	or     %edx,%eax
f011e92a:	85 c0                	test   %eax,%eax
f011e92c:	0f 85 b4 01 00 00    	jne    f011eae6 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011e932:	8b 0d 28 da 6b f0    	mov    0xf06bda28,%ecx
f011e938:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e93d:	f7 e9                	imul   %ecx
f011e93f:	c1 fa 05             	sar    $0x5,%edx
f011e942:	89 c8                	mov    %ecx,%eax
f011e944:	c1 f8 1f             	sar    $0x1f,%eax
f011e947:	29 c2                	sub    %eax,%edx
f011e949:	89 d0                	mov    %edx,%eax
f011e94b:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011e94e:	8b 0d 28 da 6b f0    	mov    0xf06bda28,%ecx
f011e954:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e959:	f7 e9                	imul   %ecx
f011e95b:	c1 fa 05             	sar    $0x5,%edx
f011e95e:	89 c8                	mov    %ecx,%eax
f011e960:	c1 f8 1f             	sar    $0x1f,%eax
f011e963:	29 c2                	sub    %eax,%edx
f011e965:	89 d0                	mov    %edx,%eax
f011e967:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011e96a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011e96d:	89 d0                	mov    %edx,%eax
f011e96f:	c1 e0 02             	shl    $0x2,%eax
f011e972:	01 d0                	add    %edx,%eax
f011e974:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e97b:	01 d0                	add    %edx,%eax
f011e97d:	c1 e0 02             	shl    $0x2,%eax
f011e980:	29 c1                	sub    %eax,%ecx
f011e982:	89 c8                	mov    %ecx,%eax
f011e984:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011e987:	8b 0d 94 d4 6b f0    	mov    0xf06bd494,%ecx
f011e98d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e992:	f7 e9                	imul   %ecx
f011e994:	c1 fa 05             	sar    $0x5,%edx
f011e997:	89 c8                	mov    %ecx,%eax
f011e999:	c1 f8 1f             	sar    $0x1f,%eax
f011e99c:	29 c2                	sub    %eax,%edx
f011e99e:	89 d0                	mov    %edx,%eax
f011e9a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011e9a3:	8b 0d 94 d4 6b f0    	mov    0xf06bd494,%ecx
f011e9a9:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011e9ae:	f7 e9                	imul   %ecx
f011e9b0:	c1 fa 05             	sar    $0x5,%edx
f011e9b3:	89 c8                	mov    %ecx,%eax
f011e9b5:	c1 f8 1f             	sar    $0x1f,%eax
f011e9b8:	29 c2                	sub    %eax,%edx
f011e9ba:	89 d0                	mov    %edx,%eax
f011e9bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011e9bf:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011e9c2:	89 d0                	mov    %edx,%eax
f011e9c4:	c1 e0 02             	shl    $0x2,%eax
f011e9c7:	01 d0                	add    %edx,%eax
f011e9c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e9d0:	01 d0                	add    %edx,%eax
f011e9d2:	c1 e0 02             	shl    $0x2,%eax
f011e9d5:	29 c1                	sub    %eax,%ecx
f011e9d7:	89 c8                	mov    %ecx,%eax
f011e9d9:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011e9dc:	8b 15 b0 d7 6b f0    	mov    0xf06bd7b0,%edx
f011e9e2:	a1 00 d4 6b f0       	mov    0xf06bd400,%eax
f011e9e7:	39 c2                	cmp    %eax,%edx
f011e9e9:	0f 85 ed 00 00 00    	jne    f011eadc <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011e9ef:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011e9f4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e9f7:	7e 5b                	jle    f011ea54 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011e9f9:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011e9fe:	83 ec 08             	sub    $0x8,%esp
f011ea01:	ff 75 e0             	pushl  -0x20(%ebp)
f011ea04:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ea07:	ff 75 e8             	pushl  -0x18(%ebp)
f011ea0a:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea0d:	50                   	push   %eax
f011ea0e:	68 68 06 13 f0       	push   $0xf0130668
f011ea13:	e8 73 25 fe ff       	call   f0100f8b <cprintf>
f011ea18:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011ea1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea1e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea21:	0f 8f b5 00 00 00    	jg     f011eadc <chk2+0x356>
f011ea27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea2a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea2d:	75 0c                	jne    f011ea3b <chk2+0x2b5>
f011ea2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ea32:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ea35:	0f 8d a1 00 00 00    	jge    f011eadc <chk2+0x356>
f011ea3b:	68 b0 06 13 f0       	push   $0xf01306b0
f011ea40:	68 93 02 13 f0       	push   $0xf0130293
f011ea45:	68 4a 02 00 00       	push   $0x24a
f011ea4a:	68 db 02 13 f0       	push   $0xf01302db
f011ea4f:	e8 75 19 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011ea54:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011ea59:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea5c:	7d 53                	jge    f011eab1 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011ea5e:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011ea63:	83 ec 08             	sub    $0x8,%esp
f011ea66:	ff 75 e0             	pushl  -0x20(%ebp)
f011ea69:	ff 75 e4             	pushl  -0x1c(%ebp)
f011ea6c:	ff 75 e8             	pushl  -0x18(%ebp)
f011ea6f:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea72:	50                   	push   %eax
f011ea73:	68 f0 06 13 f0       	push   $0xf01306f0
f011ea78:	e8 0e 25 fe ff       	call   f0100f8b <cprintf>
f011ea7d:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011ea80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea83:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea86:	7c 54                	jl     f011eadc <chk2+0x356>
f011ea88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ea8b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ea8e:	75 08                	jne    f011ea98 <chk2+0x312>
f011ea90:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ea93:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011ea96:	7e 44                	jle    f011eadc <chk2+0x356>
f011ea98:	68 38 07 13 f0       	push   $0xf0130738
f011ea9d:	68 93 02 13 f0       	push   $0xf0130293
f011eaa2:	68 50 02 00 00       	push   $0x250
f011eaa7:	68 db 02 13 f0       	push   $0xf01302db
f011eaac:	e8 18 19 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011eab1:	a1 74 d9 6b f0       	mov    0xf06bd974,%eax
f011eab6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011eab9:	75 21                	jne    f011eadc <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011eabb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011eabe:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011eac1:	74 19                	je     f011eadc <chk2+0x356>
f011eac3:	68 78 07 13 f0       	push   $0xf0130778
f011eac8:	68 93 02 13 f0       	push   $0xf0130293
f011eacd:	68 54 02 00 00       	push   $0x254
f011ead2:	68 db 02 13 f0       	push   $0xf01302db
f011ead7:	e8 ed 18 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011eadc:	a1 94 d4 6b f0       	mov    0xf06bd494,%eax
f011eae1:	a3 28 da 6b f0       	mov    %eax,0xf06bda28
			}
		}
		__pnexit = __nnexit;
f011eae6:	a1 b0 d7 6b f0       	mov    0xf06bd7b0,%eax
f011eaeb:	a3 00 d4 6b f0       	mov    %eax,0xf06bd400
f011eaf0:	eb 01                	jmp    f011eaf3 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011eaf2:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011eaf3:	c9                   	leave  
f011eaf4:	c3                   	ret    

f011eaf5 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011eaf5:	55                   	push   %ebp
f011eaf6:	89 e5                	mov    %esp,%ebp
f011eaf8:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011eafb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011eb02:	eb 40                	jmp    f011eb44 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011eb04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb07:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011eb0d:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011eb12:	83 ec 08             	sub    $0x8,%esp
f011eb15:	52                   	push   %edx
f011eb16:	50                   	push   %eax
f011eb17:	e8 af 01 00 00       	call   f011eccb <check_va2pa>
f011eb1c:	83 c4 10             	add    $0x10,%esp
f011eb1f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011eb22:	74 19                	je     f011eb3d <check_boot_pgdir+0x48>
f011eb24:	68 8c 07 13 f0       	push   $0xf013078c
f011eb29:	68 93 02 13 f0       	push   $0xf0130293
f011eb2e:	68 9b 02 00 00       	push   $0x29b
f011eb33:	68 db 02 13 f0       	push   $0xf01302db
f011eb38:	e8 fc 17 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011eb3d:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011eb44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb47:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011eb4d:	a1 78 d9 6b f0       	mov    0xf06bd978,%eax
f011eb52:	39 c2                	cmp    %eax,%edx
f011eb54:	72 ae                	jb     f011eb04 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011eb56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011eb5d:	e9 81 00 00 00       	jmp    f011ebe3 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011eb62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb65:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011eb6a:	85 c0                	test   %eax,%eax
f011eb6c:	74 6d                	je     f011ebdb <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011eb6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb71:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011eb77:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011eb7c:	83 ec 08             	sub    $0x8,%esp
f011eb7f:	52                   	push   %edx
f011eb80:	50                   	push   %eax
f011eb81:	e8 45 01 00 00       	call   f011eccb <check_va2pa>
f011eb86:	83 c4 10             	add    $0x10,%esp
f011eb89:	c7 45 f0 00 60 17 f0 	movl   $0xf0176000,-0x10(%ebp)
f011eb90:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011eb97:	77 17                	ja     f011ebb0 <check_boot_pgdir+0xbb>
f011eb99:	ff 75 f0             	pushl  -0x10(%ebp)
f011eb9c:	68 c4 07 13 f0       	push   $0xf01307c4
f011eba1:	68 a9 02 00 00       	push   $0x2a9
f011eba6:	68 db 02 13 f0       	push   $0xf01302db
f011ebab:	e8 89 17 fe ff       	call   f0100339 <_panic>
f011ebb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ebb3:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011ebb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ebbc:	01 ca                	add    %ecx,%edx
f011ebbe:	39 d0                	cmp    %edx,%eax
f011ebc0:	74 1a                	je     f011ebdc <check_boot_pgdir+0xe7>
f011ebc2:	68 f8 07 13 f0       	push   $0xf01307f8
f011ebc7:	68 93 02 13 f0       	push   $0xf0130293
f011ebcc:	68 a9 02 00 00       	push   $0x2a9
f011ebd1:	68 db 02 13 f0       	push   $0xf01302db
f011ebd6:	e8 5e 17 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011ebdb:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011ebdc:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011ebe3:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011ebea:	0f 86 72 ff ff ff    	jbe    f011eb62 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011ebf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ebf7:	e9 af 00 00 00       	jmp    f011ecab <check_boot_pgdir+0x1b6>
		switch (i) {
f011ebfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ebff:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011ec04:	74 11                	je     f011ec17 <check_boot_pgdir+0x122>
f011ec06:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011ec0b:	72 36                	jb     f011ec43 <check_boot_pgdir+0x14e>
f011ec0d:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011ec12:	83 f8 02             	cmp    $0x2,%eax
f011ec15:	77 2c                	ja     f011ec43 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011ec17:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ec1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec1f:	c1 e2 02             	shl    $0x2,%edx
f011ec22:	01 d0                	add    %edx,%eax
f011ec24:	8b 00                	mov    (%eax),%eax
f011ec26:	85 c0                	test   %eax,%eax
f011ec28:	75 7a                	jne    f011eca4 <check_boot_pgdir+0x1af>
f011ec2a:	68 7e 08 13 f0       	push   $0xf013087e
f011ec2f:	68 93 02 13 f0       	push   $0xf0130293
f011ec34:	68 b4 02 00 00       	push   $0x2b4
f011ec39:	68 db 02 13 f0       	push   $0xf01302db
f011ec3e:	e8 f6 16 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011ec43:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011ec4a:	76 2c                	jbe    f011ec78 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011ec4c:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ec51:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec54:	c1 e2 02             	shl    $0x2,%edx
f011ec57:	01 d0                	add    %edx,%eax
f011ec59:	8b 00                	mov    (%eax),%eax
f011ec5b:	85 c0                	test   %eax,%eax
f011ec5d:	75 48                	jne    f011eca7 <check_boot_pgdir+0x1b2>
f011ec5f:	68 7e 08 13 f0       	push   $0xf013087e
f011ec64:	68 93 02 13 f0       	push   $0xf0130293
f011ec69:	68 b8 02 00 00       	push   $0x2b8
f011ec6e:	68 db 02 13 f0       	push   $0xf01302db
f011ec73:	e8 c1 16 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011ec78:	a1 7c d9 6b f0       	mov    0xf06bd97c,%eax
f011ec7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ec80:	c1 e2 02             	shl    $0x2,%edx
f011ec83:	01 d0                	add    %edx,%eax
f011ec85:	8b 00                	mov    (%eax),%eax
f011ec87:	85 c0                	test   %eax,%eax
f011ec89:	74 1c                	je     f011eca7 <check_boot_pgdir+0x1b2>
f011ec8b:	68 94 08 13 f0       	push   $0xf0130894
f011ec90:	68 93 02 13 f0       	push   $0xf0130293
f011ec95:	68 ba 02 00 00       	push   $0x2ba
f011ec9a:	68 db 02 13 f0       	push   $0xf01302db
f011ec9f:	e8 95 16 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011eca4:	90                   	nop
f011eca5:	eb 01                	jmp    f011eca8 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011eca7:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011eca8:	ff 45 f4             	incl   -0xc(%ebp)
f011ecab:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011ecb2:	0f 86 44 ff ff ff    	jbe    f011ebfc <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011ecb8:	83 ec 0c             	sub    $0xc,%esp
f011ecbb:	68 b0 08 13 f0       	push   $0xf01308b0
f011ecc0:	e8 c6 22 fe ff       	call   f0100f8b <cprintf>
f011ecc5:	83 c4 10             	add    $0x10,%esp
}
f011ecc8:	90                   	nop
f011ecc9:	c9                   	leave  
f011ecca:	c3                   	ret    

f011eccb <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011eccb:	55                   	push   %ebp
f011eccc:	89 e5                	mov    %esp,%ebp
f011ecce:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011ecd1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ecd4:	c1 e8 16             	shr    $0x16,%eax
f011ecd7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ecde:	8b 45 08             	mov    0x8(%ebp),%eax
f011ece1:	01 d0                	add    %edx,%eax
f011ece3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011ece6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ece9:	8b 00                	mov    (%eax),%eax
f011eceb:	83 e0 01             	and    $0x1,%eax
f011ecee:	85 c0                	test   %eax,%eax
f011ecf0:	75 0a                	jne    f011ecfc <check_va2pa+0x31>
		return ~0;
f011ecf2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011ecf7:	e9 87 00 00 00       	jmp    f011ed83 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011ecfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ecff:	8b 00                	mov    (%eax),%eax
f011ed01:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ed06:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ed09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed0c:	c1 e8 0c             	shr    $0xc,%eax
f011ed0f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011ed12:	a1 58 d5 6b f0       	mov    0xf06bd558,%eax
f011ed17:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011ed1a:	72 17                	jb     f011ed33 <check_va2pa+0x68>
f011ed1c:	ff 75 f0             	pushl  -0x10(%ebp)
f011ed1f:	68 d4 08 13 f0       	push   $0xf01308d4
f011ed24:	68 d0 02 00 00       	push   $0x2d0
f011ed29:	68 db 02 13 f0       	push   $0xf01302db
f011ed2e:	e8 06 16 fe ff       	call   f0100339 <_panic>
f011ed33:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed36:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011ed3b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011ed3e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed41:	c1 e8 0c             	shr    $0xc,%eax
f011ed44:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ed49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ed50:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ed53:	01 d0                	add    %edx,%eax
f011ed55:	8b 00                	mov    (%eax),%eax
f011ed57:	83 e0 01             	and    $0x1,%eax
f011ed5a:	85 c0                	test   %eax,%eax
f011ed5c:	75 07                	jne    f011ed65 <check_va2pa+0x9a>
		return ~0;
f011ed5e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011ed63:	eb 1e                	jmp    f011ed83 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011ed65:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed68:	c1 e8 0c             	shr    $0xc,%eax
f011ed6b:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ed70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011ed77:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ed7a:	01 d0                	add    %edx,%eax
f011ed7c:	8b 00                	mov    (%eax),%eax
f011ed7e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011ed83:	c9                   	leave  
f011ed84:	c3                   	ret    

f011ed85 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011ed85:	55                   	push   %ebp
f011ed86:	89 e5                	mov    %esp,%ebp
f011ed88:	53                   	push   %ebx
f011ed89:	83 ec 14             	sub    $0x14,%esp
f011ed8c:	8b 45 10             	mov    0x10(%ebp),%eax
f011ed8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ed92:	8b 45 14             	mov    0x14(%ebp),%eax
f011ed95:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011ed98:	8b 45 18             	mov    0x18(%ebp),%eax
f011ed9b:	ba 00 00 00 00       	mov    $0x0,%edx
f011eda0:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011eda3:	77 55                	ja     f011edfa <printnum+0x75>
f011eda5:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011eda8:	72 05                	jb     f011edaf <printnum+0x2a>
f011edaa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011edad:	77 4b                	ja     f011edfa <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011edaf:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011edb2:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011edb5:	8b 45 18             	mov    0x18(%ebp),%eax
f011edb8:	ba 00 00 00 00       	mov    $0x0,%edx
f011edbd:	52                   	push   %edx
f011edbe:	50                   	push   %eax
f011edbf:	ff 75 f4             	pushl  -0xc(%ebp)
f011edc2:	ff 75 f0             	pushl  -0x10(%ebp)
f011edc5:	e8 96 2e 00 00       	call   f0121c60 <__udivdi3>
f011edca:	83 c4 10             	add    $0x10,%esp
f011edcd:	83 ec 04             	sub    $0x4,%esp
f011edd0:	ff 75 20             	pushl  0x20(%ebp)
f011edd3:	53                   	push   %ebx
f011edd4:	ff 75 18             	pushl  0x18(%ebp)
f011edd7:	52                   	push   %edx
f011edd8:	50                   	push   %eax
f011edd9:	ff 75 0c             	pushl  0xc(%ebp)
f011eddc:	ff 75 08             	pushl  0x8(%ebp)
f011eddf:	e8 a1 ff ff ff       	call   f011ed85 <printnum>
f011ede4:	83 c4 20             	add    $0x20,%esp
f011ede7:	eb 1a                	jmp    f011ee03 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011ede9:	83 ec 08             	sub    $0x8,%esp
f011edec:	ff 75 0c             	pushl  0xc(%ebp)
f011edef:	ff 75 20             	pushl  0x20(%ebp)
f011edf2:	8b 45 08             	mov    0x8(%ebp),%eax
f011edf5:	ff d0                	call   *%eax
f011edf7:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011edfa:	ff 4d 1c             	decl   0x1c(%ebp)
f011edfd:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011ee01:	7f e6                	jg     f011ede9 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011ee03:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011ee06:	bb 00 00 00 00       	mov    $0x0,%ebx
f011ee0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ee0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ee11:	53                   	push   %ebx
f011ee12:	51                   	push   %ecx
f011ee13:	52                   	push   %edx
f011ee14:	50                   	push   %eax
f011ee15:	e8 56 2f 00 00       	call   f0121d70 <__umoddi3>
f011ee1a:	83 c4 10             	add    $0x10,%esp
f011ee1d:	05 34 0b 13 f0       	add    $0xf0130b34,%eax
f011ee22:	8a 00                	mov    (%eax),%al
f011ee24:	0f be c0             	movsbl %al,%eax
f011ee27:	83 ec 08             	sub    $0x8,%esp
f011ee2a:	ff 75 0c             	pushl  0xc(%ebp)
f011ee2d:	50                   	push   %eax
f011ee2e:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee31:	ff d0                	call   *%eax
f011ee33:	83 c4 10             	add    $0x10,%esp
}
f011ee36:	90                   	nop
f011ee37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011ee3a:	c9                   	leave  
f011ee3b:	c3                   	ret    

f011ee3c <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011ee3c:	55                   	push   %ebp
f011ee3d:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011ee3f:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011ee43:	7e 1c                	jle    f011ee61 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011ee45:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee48:	8b 00                	mov    (%eax),%eax
f011ee4a:	8d 50 08             	lea    0x8(%eax),%edx
f011ee4d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee50:	89 10                	mov    %edx,(%eax)
f011ee52:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee55:	8b 00                	mov    (%eax),%eax
f011ee57:	83 e8 08             	sub    $0x8,%eax
f011ee5a:	8b 50 04             	mov    0x4(%eax),%edx
f011ee5d:	8b 00                	mov    (%eax),%eax
f011ee5f:	eb 40                	jmp    f011eea1 <getuint+0x65>
	else if (lflag)
f011ee61:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ee65:	74 1e                	je     f011ee85 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011ee67:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee6a:	8b 00                	mov    (%eax),%eax
f011ee6c:	8d 50 04             	lea    0x4(%eax),%edx
f011ee6f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee72:	89 10                	mov    %edx,(%eax)
f011ee74:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee77:	8b 00                	mov    (%eax),%eax
f011ee79:	83 e8 04             	sub    $0x4,%eax
f011ee7c:	8b 00                	mov    (%eax),%eax
f011ee7e:	ba 00 00 00 00       	mov    $0x0,%edx
f011ee83:	eb 1c                	jmp    f011eea1 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011ee85:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee88:	8b 00                	mov    (%eax),%eax
f011ee8a:	8d 50 04             	lea    0x4(%eax),%edx
f011ee8d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee90:	89 10                	mov    %edx,(%eax)
f011ee92:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee95:	8b 00                	mov    (%eax),%eax
f011ee97:	83 e8 04             	sub    $0x4,%eax
f011ee9a:	8b 00                	mov    (%eax),%eax
f011ee9c:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011eea1:	5d                   	pop    %ebp
f011eea2:	c3                   	ret    

f011eea3 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011eea3:	55                   	push   %ebp
f011eea4:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011eea6:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011eeaa:	7e 1c                	jle    f011eec8 <getint+0x25>
		return va_arg(*ap, long long);
f011eeac:	8b 45 08             	mov    0x8(%ebp),%eax
f011eeaf:	8b 00                	mov    (%eax),%eax
f011eeb1:	8d 50 08             	lea    0x8(%eax),%edx
f011eeb4:	8b 45 08             	mov    0x8(%ebp),%eax
f011eeb7:	89 10                	mov    %edx,(%eax)
f011eeb9:	8b 45 08             	mov    0x8(%ebp),%eax
f011eebc:	8b 00                	mov    (%eax),%eax
f011eebe:	83 e8 08             	sub    $0x8,%eax
f011eec1:	8b 50 04             	mov    0x4(%eax),%edx
f011eec4:	8b 00                	mov    (%eax),%eax
f011eec6:	eb 38                	jmp    f011ef00 <getint+0x5d>
	else if (lflag)
f011eec8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011eecc:	74 1a                	je     f011eee8 <getint+0x45>
		return va_arg(*ap, long);
f011eece:	8b 45 08             	mov    0x8(%ebp),%eax
f011eed1:	8b 00                	mov    (%eax),%eax
f011eed3:	8d 50 04             	lea    0x4(%eax),%edx
f011eed6:	8b 45 08             	mov    0x8(%ebp),%eax
f011eed9:	89 10                	mov    %edx,(%eax)
f011eedb:	8b 45 08             	mov    0x8(%ebp),%eax
f011eede:	8b 00                	mov    (%eax),%eax
f011eee0:	83 e8 04             	sub    $0x4,%eax
f011eee3:	8b 00                	mov    (%eax),%eax
f011eee5:	99                   	cltd   
f011eee6:	eb 18                	jmp    f011ef00 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011eee8:	8b 45 08             	mov    0x8(%ebp),%eax
f011eeeb:	8b 00                	mov    (%eax),%eax
f011eeed:	8d 50 04             	lea    0x4(%eax),%edx
f011eef0:	8b 45 08             	mov    0x8(%ebp),%eax
f011eef3:	89 10                	mov    %edx,(%eax)
f011eef5:	8b 45 08             	mov    0x8(%ebp),%eax
f011eef8:	8b 00                	mov    (%eax),%eax
f011eefa:	83 e8 04             	sub    $0x4,%eax
f011eefd:	8b 00                	mov    (%eax),%eax
f011eeff:	99                   	cltd   
}
f011ef00:	5d                   	pop    %ebp
f011ef01:	c3                   	ret    

f011ef02 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011ef02:	55                   	push   %ebp
f011ef03:	89 e5                	mov    %esp,%ebp
f011ef05:	56                   	push   %esi
f011ef06:	53                   	push   %ebx
f011ef07:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011ef0a:	eb 17                	jmp    f011ef23 <vprintfmt+0x21>
			if (ch == '\0')
f011ef0c:	85 db                	test   %ebx,%ebx
f011ef0e:	0f 84 c1 03 00 00    	je     f011f2d5 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011ef14:	83 ec 08             	sub    $0x8,%esp
f011ef17:	ff 75 0c             	pushl  0xc(%ebp)
f011ef1a:	53                   	push   %ebx
f011ef1b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef1e:	ff d0                	call   *%eax
f011ef20:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011ef23:	8b 45 10             	mov    0x10(%ebp),%eax
f011ef26:	8d 50 01             	lea    0x1(%eax),%edx
f011ef29:	89 55 10             	mov    %edx,0x10(%ebp)
f011ef2c:	8a 00                	mov    (%eax),%al
f011ef2e:	0f b6 d8             	movzbl %al,%ebx
f011ef31:	83 fb 25             	cmp    $0x25,%ebx
f011ef34:	75 d6                	jne    f011ef0c <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011ef36:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011ef3a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011ef41:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011ef48:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011ef4f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011ef56:	8b 45 10             	mov    0x10(%ebp),%eax
f011ef59:	8d 50 01             	lea    0x1(%eax),%edx
f011ef5c:	89 55 10             	mov    %edx,0x10(%ebp)
f011ef5f:	8a 00                	mov    (%eax),%al
f011ef61:	0f b6 d8             	movzbl %al,%ebx
f011ef64:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011ef67:	83 f8 5b             	cmp    $0x5b,%eax
f011ef6a:	0f 87 3d 03 00 00    	ja     f011f2ad <vprintfmt+0x3ab>
f011ef70:	8b 04 85 58 0b 13 f0 	mov    -0xfecf4a8(,%eax,4),%eax
f011ef77:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011ef79:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011ef7d:	eb d7                	jmp    f011ef56 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011ef7f:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011ef83:	eb d1                	jmp    f011ef56 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011ef85:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011ef8c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011ef8f:	89 d0                	mov    %edx,%eax
f011ef91:	c1 e0 02             	shl    $0x2,%eax
f011ef94:	01 d0                	add    %edx,%eax
f011ef96:	01 c0                	add    %eax,%eax
f011ef98:	01 d8                	add    %ebx,%eax
f011ef9a:	83 e8 30             	sub    $0x30,%eax
f011ef9d:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011efa0:	8b 45 10             	mov    0x10(%ebp),%eax
f011efa3:	8a 00                	mov    (%eax),%al
f011efa5:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011efa8:	83 fb 2f             	cmp    $0x2f,%ebx
f011efab:	7e 3e                	jle    f011efeb <vprintfmt+0xe9>
f011efad:	83 fb 39             	cmp    $0x39,%ebx
f011efb0:	7f 39                	jg     f011efeb <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011efb2:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011efb5:	eb d5                	jmp    f011ef8c <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011efb7:	8b 45 14             	mov    0x14(%ebp),%eax
f011efba:	83 c0 04             	add    $0x4,%eax
f011efbd:	89 45 14             	mov    %eax,0x14(%ebp)
f011efc0:	8b 45 14             	mov    0x14(%ebp),%eax
f011efc3:	83 e8 04             	sub    $0x4,%eax
f011efc6:	8b 00                	mov    (%eax),%eax
f011efc8:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011efcb:	eb 1f                	jmp    f011efec <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011efcd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011efd1:	79 83                	jns    f011ef56 <vprintfmt+0x54>
				width = 0;
f011efd3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011efda:	e9 77 ff ff ff       	jmp    f011ef56 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011efdf:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011efe6:	e9 6b ff ff ff       	jmp    f011ef56 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011efeb:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011efec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011eff0:	0f 89 60 ff ff ff    	jns    f011ef56 <vprintfmt+0x54>
				width = precision, precision = -1;
f011eff6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011eff9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011effc:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011f003:	e9 4e ff ff ff       	jmp    f011ef56 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011f008:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011f00b:	e9 46 ff ff ff       	jmp    f011ef56 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011f010:	8b 45 14             	mov    0x14(%ebp),%eax
f011f013:	83 c0 04             	add    $0x4,%eax
f011f016:	89 45 14             	mov    %eax,0x14(%ebp)
f011f019:	8b 45 14             	mov    0x14(%ebp),%eax
f011f01c:	83 e8 04             	sub    $0x4,%eax
f011f01f:	8b 00                	mov    (%eax),%eax
f011f021:	83 ec 08             	sub    $0x8,%esp
f011f024:	ff 75 0c             	pushl  0xc(%ebp)
f011f027:	50                   	push   %eax
f011f028:	8b 45 08             	mov    0x8(%ebp),%eax
f011f02b:	ff d0                	call   *%eax
f011f02d:	83 c4 10             	add    $0x10,%esp
			break;
f011f030:	e9 9b 02 00 00       	jmp    f011f2d0 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011f035:	8b 45 14             	mov    0x14(%ebp),%eax
f011f038:	83 c0 04             	add    $0x4,%eax
f011f03b:	89 45 14             	mov    %eax,0x14(%ebp)
f011f03e:	8b 45 14             	mov    0x14(%ebp),%eax
f011f041:	83 e8 04             	sub    $0x4,%eax
f011f044:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011f046:	85 db                	test   %ebx,%ebx
f011f048:	79 02                	jns    f011f04c <vprintfmt+0x14a>
				err = -err;
f011f04a:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011f04c:	83 fb 64             	cmp    $0x64,%ebx
f011f04f:	7f 0b                	jg     f011f05c <vprintfmt+0x15a>
f011f051:	8b 34 9d a0 09 13 f0 	mov    -0xfecf660(,%ebx,4),%esi
f011f058:	85 f6                	test   %esi,%esi
f011f05a:	75 19                	jne    f011f075 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011f05c:	53                   	push   %ebx
f011f05d:	68 45 0b 13 f0       	push   $0xf0130b45
f011f062:	ff 75 0c             	pushl  0xc(%ebp)
f011f065:	ff 75 08             	pushl  0x8(%ebp)
f011f068:	e8 70 02 00 00       	call   f011f2dd <printfmt>
f011f06d:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011f070:	e9 5b 02 00 00       	jmp    f011f2d0 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011f075:	56                   	push   %esi
f011f076:	68 4e 0b 13 f0       	push   $0xf0130b4e
f011f07b:	ff 75 0c             	pushl  0xc(%ebp)
f011f07e:	ff 75 08             	pushl  0x8(%ebp)
f011f081:	e8 57 02 00 00       	call   f011f2dd <printfmt>
f011f086:	83 c4 10             	add    $0x10,%esp
			break;
f011f089:	e9 42 02 00 00       	jmp    f011f2d0 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011f08e:	8b 45 14             	mov    0x14(%ebp),%eax
f011f091:	83 c0 04             	add    $0x4,%eax
f011f094:	89 45 14             	mov    %eax,0x14(%ebp)
f011f097:	8b 45 14             	mov    0x14(%ebp),%eax
f011f09a:	83 e8 04             	sub    $0x4,%eax
f011f09d:	8b 30                	mov    (%eax),%esi
f011f09f:	85 f6                	test   %esi,%esi
f011f0a1:	75 05                	jne    f011f0a8 <vprintfmt+0x1a6>
				p = "(null)";
f011f0a3:	be 51 0b 13 f0       	mov    $0xf0130b51,%esi
			if (width > 0 && padc != '-')
f011f0a8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f0ac:	7e 6d                	jle    f011f11b <vprintfmt+0x219>
f011f0ae:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011f0b2:	74 67                	je     f011f11b <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011f0b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f0b7:	83 ec 08             	sub    $0x8,%esp
f011f0ba:	50                   	push   %eax
f011f0bb:	56                   	push   %esi
f011f0bc:	e8 26 05 00 00       	call   f011f5e7 <strnlen>
f011f0c1:	83 c4 10             	add    $0x10,%esp
f011f0c4:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011f0c7:	eb 16                	jmp    f011f0df <vprintfmt+0x1dd>
					putch(padc, putdat);
f011f0c9:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011f0cd:	83 ec 08             	sub    $0x8,%esp
f011f0d0:	ff 75 0c             	pushl  0xc(%ebp)
f011f0d3:	50                   	push   %eax
f011f0d4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f0d7:	ff d0                	call   *%eax
f011f0d9:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011f0dc:	ff 4d e4             	decl   -0x1c(%ebp)
f011f0df:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f0e3:	7f e4                	jg     f011f0c9 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f0e5:	eb 34                	jmp    f011f11b <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011f0e7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f0eb:	74 1c                	je     f011f109 <vprintfmt+0x207>
f011f0ed:	83 fb 1f             	cmp    $0x1f,%ebx
f011f0f0:	7e 05                	jle    f011f0f7 <vprintfmt+0x1f5>
f011f0f2:	83 fb 7e             	cmp    $0x7e,%ebx
f011f0f5:	7e 12                	jle    f011f109 <vprintfmt+0x207>
					putch('?', putdat);
f011f0f7:	83 ec 08             	sub    $0x8,%esp
f011f0fa:	ff 75 0c             	pushl  0xc(%ebp)
f011f0fd:	6a 3f                	push   $0x3f
f011f0ff:	8b 45 08             	mov    0x8(%ebp),%eax
f011f102:	ff d0                	call   *%eax
f011f104:	83 c4 10             	add    $0x10,%esp
f011f107:	eb 0f                	jmp    f011f118 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011f109:	83 ec 08             	sub    $0x8,%esp
f011f10c:	ff 75 0c             	pushl  0xc(%ebp)
f011f10f:	53                   	push   %ebx
f011f110:	8b 45 08             	mov    0x8(%ebp),%eax
f011f113:	ff d0                	call   *%eax
f011f115:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011f118:	ff 4d e4             	decl   -0x1c(%ebp)
f011f11b:	89 f0                	mov    %esi,%eax
f011f11d:	8d 70 01             	lea    0x1(%eax),%esi
f011f120:	8a 00                	mov    (%eax),%al
f011f122:	0f be d8             	movsbl %al,%ebx
f011f125:	85 db                	test   %ebx,%ebx
f011f127:	74 24                	je     f011f14d <vprintfmt+0x24b>
f011f129:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f12d:	78 b8                	js     f011f0e7 <vprintfmt+0x1e5>
f011f12f:	ff 4d e0             	decl   -0x20(%ebp)
f011f132:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011f136:	79 af                	jns    f011f0e7 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f138:	eb 13                	jmp    f011f14d <vprintfmt+0x24b>
				putch(' ', putdat);
f011f13a:	83 ec 08             	sub    $0x8,%esp
f011f13d:	ff 75 0c             	pushl  0xc(%ebp)
f011f140:	6a 20                	push   $0x20
f011f142:	8b 45 08             	mov    0x8(%ebp),%eax
f011f145:	ff d0                	call   *%eax
f011f147:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011f14a:	ff 4d e4             	decl   -0x1c(%ebp)
f011f14d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f151:	7f e7                	jg     f011f13a <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011f153:	e9 78 01 00 00       	jmp    f011f2d0 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011f158:	83 ec 08             	sub    $0x8,%esp
f011f15b:	ff 75 e8             	pushl  -0x18(%ebp)
f011f15e:	8d 45 14             	lea    0x14(%ebp),%eax
f011f161:	50                   	push   %eax
f011f162:	e8 3c fd ff ff       	call   f011eea3 <getint>
f011f167:	83 c4 10             	add    $0x10,%esp
f011f16a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f16d:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011f170:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f173:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f176:	85 d2                	test   %edx,%edx
f011f178:	79 23                	jns    f011f19d <vprintfmt+0x29b>
				putch('-', putdat);
f011f17a:	83 ec 08             	sub    $0x8,%esp
f011f17d:	ff 75 0c             	pushl  0xc(%ebp)
f011f180:	6a 2d                	push   $0x2d
f011f182:	8b 45 08             	mov    0x8(%ebp),%eax
f011f185:	ff d0                	call   *%eax
f011f187:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011f18a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f18d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f190:	f7 d8                	neg    %eax
f011f192:	83 d2 00             	adc    $0x0,%edx
f011f195:	f7 da                	neg    %edx
f011f197:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f19a:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011f19d:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f1a4:	e9 bc 00 00 00       	jmp    f011f265 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011f1a9:	83 ec 08             	sub    $0x8,%esp
f011f1ac:	ff 75 e8             	pushl  -0x18(%ebp)
f011f1af:	8d 45 14             	lea    0x14(%ebp),%eax
f011f1b2:	50                   	push   %eax
f011f1b3:	e8 84 fc ff ff       	call   f011ee3c <getuint>
f011f1b8:	83 c4 10             	add    $0x10,%esp
f011f1bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f1be:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011f1c1:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011f1c8:	e9 98 00 00 00       	jmp    f011f265 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011f1cd:	83 ec 08             	sub    $0x8,%esp
f011f1d0:	ff 75 0c             	pushl  0xc(%ebp)
f011f1d3:	6a 58                	push   $0x58
f011f1d5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1d8:	ff d0                	call   *%eax
f011f1da:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f1dd:	83 ec 08             	sub    $0x8,%esp
f011f1e0:	ff 75 0c             	pushl  0xc(%ebp)
f011f1e3:	6a 58                	push   $0x58
f011f1e5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1e8:	ff d0                	call   *%eax
f011f1ea:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011f1ed:	83 ec 08             	sub    $0x8,%esp
f011f1f0:	ff 75 0c             	pushl  0xc(%ebp)
f011f1f3:	6a 58                	push   $0x58
f011f1f5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f1f8:	ff d0                	call   *%eax
f011f1fa:	83 c4 10             	add    $0x10,%esp
			break;
f011f1fd:	e9 ce 00 00 00       	jmp    f011f2d0 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011f202:	83 ec 08             	sub    $0x8,%esp
f011f205:	ff 75 0c             	pushl  0xc(%ebp)
f011f208:	6a 30                	push   $0x30
f011f20a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f20d:	ff d0                	call   *%eax
f011f20f:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011f212:	83 ec 08             	sub    $0x8,%esp
f011f215:	ff 75 0c             	pushl  0xc(%ebp)
f011f218:	6a 78                	push   $0x78
f011f21a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f21d:	ff d0                	call   *%eax
f011f21f:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011f222:	8b 45 14             	mov    0x14(%ebp),%eax
f011f225:	83 c0 04             	add    $0x4,%eax
f011f228:	89 45 14             	mov    %eax,0x14(%ebp)
f011f22b:	8b 45 14             	mov    0x14(%ebp),%eax
f011f22e:	83 e8 04             	sub    $0x4,%eax
f011f231:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011f233:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f236:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011f23d:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011f244:	eb 1f                	jmp    f011f265 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011f246:	83 ec 08             	sub    $0x8,%esp
f011f249:	ff 75 e8             	pushl  -0x18(%ebp)
f011f24c:	8d 45 14             	lea    0x14(%ebp),%eax
f011f24f:	50                   	push   %eax
f011f250:	e8 e7 fb ff ff       	call   f011ee3c <getuint>
f011f255:	83 c4 10             	add    $0x10,%esp
f011f258:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f25b:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011f25e:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011f265:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011f269:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f26c:	83 ec 04             	sub    $0x4,%esp
f011f26f:	52                   	push   %edx
f011f270:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f273:	50                   	push   %eax
f011f274:	ff 75 f4             	pushl  -0xc(%ebp)
f011f277:	ff 75 f0             	pushl  -0x10(%ebp)
f011f27a:	ff 75 0c             	pushl  0xc(%ebp)
f011f27d:	ff 75 08             	pushl  0x8(%ebp)
f011f280:	e8 00 fb ff ff       	call   f011ed85 <printnum>
f011f285:	83 c4 20             	add    $0x20,%esp
			break;
f011f288:	eb 46                	jmp    f011f2d0 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011f28a:	83 ec 08             	sub    $0x8,%esp
f011f28d:	ff 75 0c             	pushl  0xc(%ebp)
f011f290:	53                   	push   %ebx
f011f291:	8b 45 08             	mov    0x8(%ebp),%eax
f011f294:	ff d0                	call   *%eax
f011f296:	83 c4 10             	add    $0x10,%esp
			break;
f011f299:	eb 35                	jmp    f011f2d0 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011f29b:	c6 05 a0 d2 6b f0 00 	movb   $0x0,0xf06bd2a0
			break;
f011f2a2:	eb 2c                	jmp    f011f2d0 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011f2a4:	c6 05 a0 d2 6b f0 01 	movb   $0x1,0xf06bd2a0
			break;
f011f2ab:	eb 23                	jmp    f011f2d0 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011f2ad:	83 ec 08             	sub    $0x8,%esp
f011f2b0:	ff 75 0c             	pushl  0xc(%ebp)
f011f2b3:	6a 25                	push   $0x25
f011f2b5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f2b8:	ff d0                	call   *%eax
f011f2ba:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011f2bd:	ff 4d 10             	decl   0x10(%ebp)
f011f2c0:	eb 03                	jmp    f011f2c5 <vprintfmt+0x3c3>
f011f2c2:	ff 4d 10             	decl   0x10(%ebp)
f011f2c5:	8b 45 10             	mov    0x10(%ebp),%eax
f011f2c8:	48                   	dec    %eax
f011f2c9:	8a 00                	mov    (%eax),%al
f011f2cb:	3c 25                	cmp    $0x25,%al
f011f2cd:	75 f3                	jne    f011f2c2 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011f2cf:	90                   	nop
		}
	}
f011f2d0:	e9 35 fc ff ff       	jmp    f011ef0a <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011f2d5:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011f2d6:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f2d9:	5b                   	pop    %ebx
f011f2da:	5e                   	pop    %esi
f011f2db:	5d                   	pop    %ebp
f011f2dc:	c3                   	ret    

f011f2dd <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011f2dd:	55                   	push   %ebp
f011f2de:	89 e5                	mov    %esp,%ebp
f011f2e0:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011f2e3:	8d 45 10             	lea    0x10(%ebp),%eax
f011f2e6:	83 c0 04             	add    $0x4,%eax
f011f2e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011f2ec:	8b 45 10             	mov    0x10(%ebp),%eax
f011f2ef:	ff 75 f4             	pushl  -0xc(%ebp)
f011f2f2:	50                   	push   %eax
f011f2f3:	ff 75 0c             	pushl  0xc(%ebp)
f011f2f6:	ff 75 08             	pushl  0x8(%ebp)
f011f2f9:	e8 04 fc ff ff       	call   f011ef02 <vprintfmt>
f011f2fe:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011f301:	90                   	nop
f011f302:	c9                   	leave  
f011f303:	c3                   	ret    

f011f304 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011f304:	55                   	push   %ebp
f011f305:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011f307:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f30a:	8b 40 08             	mov    0x8(%eax),%eax
f011f30d:	8d 50 01             	lea    0x1(%eax),%edx
f011f310:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f313:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011f316:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f319:	8b 10                	mov    (%eax),%edx
f011f31b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f31e:	8b 40 04             	mov    0x4(%eax),%eax
f011f321:	39 c2                	cmp    %eax,%edx
f011f323:	73 12                	jae    f011f337 <sprintputch+0x33>
		*b->buf++ = ch;
f011f325:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f328:	8b 00                	mov    (%eax),%eax
f011f32a:	8d 48 01             	lea    0x1(%eax),%ecx
f011f32d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f330:	89 0a                	mov    %ecx,(%edx)
f011f332:	8b 55 08             	mov    0x8(%ebp),%edx
f011f335:	88 10                	mov    %dl,(%eax)
}
f011f337:	90                   	nop
f011f338:	5d                   	pop    %ebp
f011f339:	c3                   	ret    

f011f33a <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011f33a:	55                   	push   %ebp
f011f33b:	89 e5                	mov    %esp,%ebp
f011f33d:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011f340:	8b 45 08             	mov    0x8(%ebp),%eax
f011f343:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f346:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f349:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f34c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f34f:	01 d0                	add    %edx,%eax
f011f351:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f354:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011f35b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f35f:	74 06                	je     f011f367 <vsnprintf+0x2d>
f011f361:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f365:	7f 07                	jg     f011f36e <vsnprintf+0x34>
		return -E_INVAL;
f011f367:	b8 03 00 00 00       	mov    $0x3,%eax
f011f36c:	eb 20                	jmp    f011f38e <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011f36e:	ff 75 14             	pushl  0x14(%ebp)
f011f371:	ff 75 10             	pushl  0x10(%ebp)
f011f374:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011f377:	50                   	push   %eax
f011f378:	68 04 f3 11 f0       	push   $0xf011f304
f011f37d:	e8 80 fb ff ff       	call   f011ef02 <vprintfmt>
f011f382:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011f385:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f388:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011f38b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f38e:	c9                   	leave  
f011f38f:	c3                   	ret    

f011f390 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011f390:	55                   	push   %ebp
f011f391:	89 e5                	mov    %esp,%ebp
f011f393:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011f396:	8d 45 10             	lea    0x10(%ebp),%eax
f011f399:	83 c0 04             	add    $0x4,%eax
f011f39c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011f39f:	8b 45 10             	mov    0x10(%ebp),%eax
f011f3a2:	ff 75 f4             	pushl  -0xc(%ebp)
f011f3a5:	50                   	push   %eax
f011f3a6:	ff 75 0c             	pushl  0xc(%ebp)
f011f3a9:	ff 75 08             	pushl  0x8(%ebp)
f011f3ac:	e8 89 ff ff ff       	call   f011f33a <vsnprintf>
f011f3b1:	83 c4 10             	add    $0x10,%esp
f011f3b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011f3b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011f3ba:	c9                   	leave  
f011f3bb:	c3                   	ret    

f011f3bc <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011f3bc:	55                   	push   %ebp
f011f3bd:	89 e5                	mov    %esp,%ebp
f011f3bf:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011f3c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f3c6:	74 13                	je     f011f3db <readline+0x1f>
		cprintf("%s", prompt);
f011f3c8:	83 ec 08             	sub    $0x8,%esp
f011f3cb:	ff 75 08             	pushl  0x8(%ebp)
f011f3ce:	68 c8 0c 13 f0       	push   $0xf0130cc8
f011f3d3:	e8 b3 1b fe ff       	call   f0100f8b <cprintf>
f011f3d8:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011f3db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011f3e2:	83 ec 0c             	sub    $0xc,%esp
f011f3e5:	6a 00                	push   $0x0
f011f3e7:	e8 ac 1a fe ff       	call   f0100e98 <iscons>
f011f3ec:	83 c4 10             	add    $0x10,%esp
f011f3ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011f3f2:	e8 88 1a fe ff       	call   f0100e7f <getchar>
f011f3f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011f3fa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011f3fe:	79 22                	jns    f011f422 <readline+0x66>
			if (c != -E_EOF)
f011f400:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011f404:	0f 84 ad 00 00 00    	je     f011f4b7 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011f40a:	83 ec 08             	sub    $0x8,%esp
f011f40d:	ff 75 ec             	pushl  -0x14(%ebp)
f011f410:	68 cb 0c 13 f0       	push   $0xf0130ccb
f011f415:	e8 71 1b fe ff       	call   f0100f8b <cprintf>
f011f41a:	83 c4 10             	add    $0x10,%esp
			break;
f011f41d:	e9 95 00 00 00       	jmp    f011f4b7 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011f422:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011f426:	7e 34                	jle    f011f45c <readline+0xa0>
f011f428:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011f42f:	7f 2b                	jg     f011f45c <readline+0xa0>
			if (echoing)
f011f431:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f435:	74 0e                	je     f011f445 <readline+0x89>
				cputchar(c);
f011f437:	83 ec 0c             	sub    $0xc,%esp
f011f43a:	ff 75 ec             	pushl  -0x14(%ebp)
f011f43d:	e8 26 1a fe ff       	call   f0100e68 <cputchar>
f011f442:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011f445:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f448:	8d 50 01             	lea    0x1(%eax),%edx
f011f44b:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011f44e:	89 c2                	mov    %eax,%edx
f011f450:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f453:	01 d0                	add    %edx,%eax
f011f455:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f458:	88 10                	mov    %dl,(%eax)
f011f45a:	eb 56                	jmp    f011f4b2 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011f45c:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011f460:	75 1f                	jne    f011f481 <readline+0xc5>
f011f462:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f466:	7e 19                	jle    f011f481 <readline+0xc5>
			if (echoing)
f011f468:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f46c:	74 0e                	je     f011f47c <readline+0xc0>
				cputchar(c);
f011f46e:	83 ec 0c             	sub    $0xc,%esp
f011f471:	ff 75 ec             	pushl  -0x14(%ebp)
f011f474:	e8 ef 19 fe ff       	call   f0100e68 <cputchar>
f011f479:	83 c4 10             	add    $0x10,%esp

			i--;
f011f47c:	ff 4d f4             	decl   -0xc(%ebp)
f011f47f:	eb 31                	jmp    f011f4b2 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011f481:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011f485:	74 0a                	je     f011f491 <readline+0xd5>
f011f487:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011f48b:	0f 85 61 ff ff ff    	jne    f011f3f2 <readline+0x36>
			if (echoing)
f011f491:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f495:	74 0e                	je     f011f4a5 <readline+0xe9>
				cputchar(c);
f011f497:	83 ec 0c             	sub    $0xc,%esp
f011f49a:	ff 75 ec             	pushl  -0x14(%ebp)
f011f49d:	e8 c6 19 fe ff       	call   f0100e68 <cputchar>
f011f4a2:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011f4a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f4a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f4ab:	01 d0                	add    %edx,%eax
f011f4ad:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011f4b0:	eb 06                	jmp    f011f4b8 <readline+0xfc>
		}
	}
f011f4b2:	e9 3b ff ff ff       	jmp    f011f3f2 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011f4b7:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011f4b8:	90                   	nop
f011f4b9:	c9                   	leave  
f011f4ba:	c3                   	ret    

f011f4bb <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011f4bb:	55                   	push   %ebp
f011f4bc:	89 e5                	mov    %esp,%ebp
f011f4be:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011f4c1:	e8 53 ec fe ff       	call   f010e119 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011f4c6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f4ca:	74 13                	je     f011f4df <atomic_readline+0x24>
			cprintf("%s", prompt);
f011f4cc:	83 ec 08             	sub    $0x8,%esp
f011f4cf:	ff 75 08             	pushl  0x8(%ebp)
f011f4d2:	68 c8 0c 13 f0       	push   $0xf0130cc8
f011f4d7:	e8 af 1a fe ff       	call   f0100f8b <cprintf>
f011f4dc:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011f4df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011f4e6:	83 ec 0c             	sub    $0xc,%esp
f011f4e9:	6a 00                	push   $0x0
f011f4eb:	e8 a8 19 fe ff       	call   f0100e98 <iscons>
f011f4f0:	83 c4 10             	add    $0x10,%esp
f011f4f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011f4f6:	e8 84 19 fe ff       	call   f0100e7f <getchar>
f011f4fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011f4fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011f502:	79 22                	jns    f011f526 <atomic_readline+0x6b>
				if (c != -E_EOF)
f011f504:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011f508:	0f 84 ad 00 00 00    	je     f011f5bb <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011f50e:	83 ec 08             	sub    $0x8,%esp
f011f511:	ff 75 ec             	pushl  -0x14(%ebp)
f011f514:	68 cb 0c 13 f0       	push   $0xf0130ccb
f011f519:	e8 6d 1a fe ff       	call   f0100f8b <cprintf>
f011f51e:	83 c4 10             	add    $0x10,%esp
				break;
f011f521:	e9 95 00 00 00       	jmp    f011f5bb <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011f526:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011f52a:	7e 34                	jle    f011f560 <atomic_readline+0xa5>
f011f52c:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011f533:	7f 2b                	jg     f011f560 <atomic_readline+0xa5>
				if (echoing)
f011f535:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f539:	74 0e                	je     f011f549 <atomic_readline+0x8e>
					cputchar(c);
f011f53b:	83 ec 0c             	sub    $0xc,%esp
f011f53e:	ff 75 ec             	pushl  -0x14(%ebp)
f011f541:	e8 22 19 fe ff       	call   f0100e68 <cputchar>
f011f546:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011f549:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f54c:	8d 50 01             	lea    0x1(%eax),%edx
f011f54f:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011f552:	89 c2                	mov    %eax,%edx
f011f554:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f557:	01 d0                	add    %edx,%eax
f011f559:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f55c:	88 10                	mov    %dl,(%eax)
f011f55e:	eb 56                	jmp    f011f5b6 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011f560:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011f564:	75 1f                	jne    f011f585 <atomic_readline+0xca>
f011f566:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f56a:	7e 19                	jle    f011f585 <atomic_readline+0xca>
				if (echoing)
f011f56c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f570:	74 0e                	je     f011f580 <atomic_readline+0xc5>
					cputchar(c);
f011f572:	83 ec 0c             	sub    $0xc,%esp
f011f575:	ff 75 ec             	pushl  -0x14(%ebp)
f011f578:	e8 eb 18 fe ff       	call   f0100e68 <cputchar>
f011f57d:	83 c4 10             	add    $0x10,%esp
				i--;
f011f580:	ff 4d f4             	decl   -0xc(%ebp)
f011f583:	eb 31                	jmp    f011f5b6 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011f585:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011f589:	74 0a                	je     f011f595 <atomic_readline+0xda>
f011f58b:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011f58f:	0f 85 61 ff ff ff    	jne    f011f4f6 <atomic_readline+0x3b>
				if (echoing)
f011f595:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f599:	74 0e                	je     f011f5a9 <atomic_readline+0xee>
					cputchar(c);
f011f59b:	83 ec 0c             	sub    $0xc,%esp
f011f59e:	ff 75 ec             	pushl  -0x14(%ebp)
f011f5a1:	e8 c2 18 fe ff       	call   f0100e68 <cputchar>
f011f5a6:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011f5a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f5ac:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f5af:	01 d0                	add    %edx,%eax
f011f5b1:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011f5b4:	eb 06                	jmp    f011f5bc <atomic_readline+0x101>
			}
		}
f011f5b6:	e9 3b ff ff ff       	jmp    f011f4f6 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011f5bb:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011f5bc:	e8 66 eb fe ff       	call   f010e127 <sys_unlock_cons>
}
f011f5c1:	90                   	nop
f011f5c2:	c9                   	leave  
f011f5c3:	c3                   	ret    

f011f5c4 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011f5c4:	55                   	push   %ebp
f011f5c5:	89 e5                	mov    %esp,%ebp
f011f5c7:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011f5ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f5d1:	eb 06                	jmp    f011f5d9 <strlen+0x15>
		n++;
f011f5d3:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011f5d6:	ff 45 08             	incl   0x8(%ebp)
f011f5d9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5dc:	8a 00                	mov    (%eax),%al
f011f5de:	84 c0                	test   %al,%al
f011f5e0:	75 f1                	jne    f011f5d3 <strlen+0xf>
		n++;
	return n;
f011f5e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f5e5:	c9                   	leave  
f011f5e6:	c3                   	ret    

f011f5e7 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011f5e7:	55                   	push   %ebp
f011f5e8:	89 e5                	mov    %esp,%ebp
f011f5ea:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011f5ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f5f4:	eb 09                	jmp    f011f5ff <strnlen+0x18>
		n++;
f011f5f6:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011f5f9:	ff 45 08             	incl   0x8(%ebp)
f011f5fc:	ff 4d 0c             	decl   0xc(%ebp)
f011f5ff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f603:	74 09                	je     f011f60e <strnlen+0x27>
f011f605:	8b 45 08             	mov    0x8(%ebp),%eax
f011f608:	8a 00                	mov    (%eax),%al
f011f60a:	84 c0                	test   %al,%al
f011f60c:	75 e8                	jne    f011f5f6 <strnlen+0xf>
		n++;
	return n;
f011f60e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f611:	c9                   	leave  
f011f612:	c3                   	ret    

f011f613 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011f613:	55                   	push   %ebp
f011f614:	89 e5                	mov    %esp,%ebp
f011f616:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011f619:	8b 45 08             	mov    0x8(%ebp),%eax
f011f61c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011f61f:	90                   	nop
f011f620:	8b 45 08             	mov    0x8(%ebp),%eax
f011f623:	8d 50 01             	lea    0x1(%eax),%edx
f011f626:	89 55 08             	mov    %edx,0x8(%ebp)
f011f629:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f62c:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f62f:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011f632:	8a 12                	mov    (%edx),%dl
f011f634:	88 10                	mov    %dl,(%eax)
f011f636:	8a 00                	mov    (%eax),%al
f011f638:	84 c0                	test   %al,%al
f011f63a:	75 e4                	jne    f011f620 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011f63c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011f63f:	c9                   	leave  
f011f640:	c3                   	ret    

f011f641 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011f641:	55                   	push   %ebp
f011f642:	89 e5                	mov    %esp,%ebp
f011f644:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011f647:	8b 45 08             	mov    0x8(%ebp),%eax
f011f64a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011f64d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f654:	eb 1f                	jmp    f011f675 <strncpy+0x34>
		*dst++ = *src;
f011f656:	8b 45 08             	mov    0x8(%ebp),%eax
f011f659:	8d 50 01             	lea    0x1(%eax),%edx
f011f65c:	89 55 08             	mov    %edx,0x8(%ebp)
f011f65f:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f662:	8a 12                	mov    (%edx),%dl
f011f664:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011f666:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f669:	8a 00                	mov    (%eax),%al
f011f66b:	84 c0                	test   %al,%al
f011f66d:	74 03                	je     f011f672 <strncpy+0x31>
			src++;
f011f66f:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011f672:	ff 45 fc             	incl   -0x4(%ebp)
f011f675:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f678:	3b 45 10             	cmp    0x10(%ebp),%eax
f011f67b:	72 d9                	jb     f011f656 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011f67d:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011f680:	c9                   	leave  
f011f681:	c3                   	ret    

f011f682 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011f682:	55                   	push   %ebp
f011f683:	89 e5                	mov    %esp,%ebp
f011f685:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011f688:	8b 45 08             	mov    0x8(%ebp),%eax
f011f68b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011f68e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f692:	74 30                	je     f011f6c4 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011f694:	eb 16                	jmp    f011f6ac <strlcpy+0x2a>
			*dst++ = *src++;
f011f696:	8b 45 08             	mov    0x8(%ebp),%eax
f011f699:	8d 50 01             	lea    0x1(%eax),%edx
f011f69c:	89 55 08             	mov    %edx,0x8(%ebp)
f011f69f:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f6a2:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f6a5:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011f6a8:	8a 12                	mov    (%edx),%dl
f011f6aa:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011f6ac:	ff 4d 10             	decl   0x10(%ebp)
f011f6af:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f6b3:	74 09                	je     f011f6be <strlcpy+0x3c>
f011f6b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f6b8:	8a 00                	mov    (%eax),%al
f011f6ba:	84 c0                	test   %al,%al
f011f6bc:	75 d8                	jne    f011f696 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011f6be:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6c1:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011f6c4:	8b 55 08             	mov    0x8(%ebp),%edx
f011f6c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f6ca:	29 c2                	sub    %eax,%edx
f011f6cc:	89 d0                	mov    %edx,%eax
}
f011f6ce:	c9                   	leave  
f011f6cf:	c3                   	ret    

f011f6d0 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011f6d0:	55                   	push   %ebp
f011f6d1:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011f6d3:	eb 06                	jmp    f011f6db <strcmp+0xb>
		p++, q++;
f011f6d5:	ff 45 08             	incl   0x8(%ebp)
f011f6d8:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011f6db:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6de:	8a 00                	mov    (%eax),%al
f011f6e0:	84 c0                	test   %al,%al
f011f6e2:	74 0e                	je     f011f6f2 <strcmp+0x22>
f011f6e4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6e7:	8a 10                	mov    (%eax),%dl
f011f6e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f6ec:	8a 00                	mov    (%eax),%al
f011f6ee:	38 c2                	cmp    %al,%dl
f011f6f0:	74 e3                	je     f011f6d5 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011f6f2:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6f5:	8a 00                	mov    (%eax),%al
f011f6f7:	0f b6 d0             	movzbl %al,%edx
f011f6fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f6fd:	8a 00                	mov    (%eax),%al
f011f6ff:	0f b6 c0             	movzbl %al,%eax
f011f702:	29 c2                	sub    %eax,%edx
f011f704:	89 d0                	mov    %edx,%eax
}
f011f706:	5d                   	pop    %ebp
f011f707:	c3                   	ret    

f011f708 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011f708:	55                   	push   %ebp
f011f709:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011f70b:	eb 09                	jmp    f011f716 <strncmp+0xe>
		n--, p++, q++;
f011f70d:	ff 4d 10             	decl   0x10(%ebp)
f011f710:	ff 45 08             	incl   0x8(%ebp)
f011f713:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011f716:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f71a:	74 17                	je     f011f733 <strncmp+0x2b>
f011f71c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f71f:	8a 00                	mov    (%eax),%al
f011f721:	84 c0                	test   %al,%al
f011f723:	74 0e                	je     f011f733 <strncmp+0x2b>
f011f725:	8b 45 08             	mov    0x8(%ebp),%eax
f011f728:	8a 10                	mov    (%eax),%dl
f011f72a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f72d:	8a 00                	mov    (%eax),%al
f011f72f:	38 c2                	cmp    %al,%dl
f011f731:	74 da                	je     f011f70d <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011f733:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f737:	75 07                	jne    f011f740 <strncmp+0x38>
		return 0;
f011f739:	b8 00 00 00 00       	mov    $0x0,%eax
f011f73e:	eb 14                	jmp    f011f754 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011f740:	8b 45 08             	mov    0x8(%ebp),%eax
f011f743:	8a 00                	mov    (%eax),%al
f011f745:	0f b6 d0             	movzbl %al,%edx
f011f748:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f74b:	8a 00                	mov    (%eax),%al
f011f74d:	0f b6 c0             	movzbl %al,%eax
f011f750:	29 c2                	sub    %eax,%edx
f011f752:	89 d0                	mov    %edx,%eax
}
f011f754:	5d                   	pop    %ebp
f011f755:	c3                   	ret    

f011f756 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011f756:	55                   	push   %ebp
f011f757:	89 e5                	mov    %esp,%ebp
f011f759:	83 ec 04             	sub    $0x4,%esp
f011f75c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f75f:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011f762:	eb 12                	jmp    f011f776 <strchr+0x20>
		if (*s == c)
f011f764:	8b 45 08             	mov    0x8(%ebp),%eax
f011f767:	8a 00                	mov    (%eax),%al
f011f769:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011f76c:	75 05                	jne    f011f773 <strchr+0x1d>
			return (char *) s;
f011f76e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f771:	eb 11                	jmp    f011f784 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011f773:	ff 45 08             	incl   0x8(%ebp)
f011f776:	8b 45 08             	mov    0x8(%ebp),%eax
f011f779:	8a 00                	mov    (%eax),%al
f011f77b:	84 c0                	test   %al,%al
f011f77d:	75 e5                	jne    f011f764 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011f77f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f784:	c9                   	leave  
f011f785:	c3                   	ret    

f011f786 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011f786:	55                   	push   %ebp
f011f787:	89 e5                	mov    %esp,%ebp
f011f789:	83 ec 04             	sub    $0x4,%esp
f011f78c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f78f:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011f792:	eb 0d                	jmp    f011f7a1 <strfind+0x1b>
		if (*s == c)
f011f794:	8b 45 08             	mov    0x8(%ebp),%eax
f011f797:	8a 00                	mov    (%eax),%al
f011f799:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011f79c:	74 0e                	je     f011f7ac <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011f79e:	ff 45 08             	incl   0x8(%ebp)
f011f7a1:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7a4:	8a 00                	mov    (%eax),%al
f011f7a6:	84 c0                	test   %al,%al
f011f7a8:	75 ea                	jne    f011f794 <strfind+0xe>
f011f7aa:	eb 01                	jmp    f011f7ad <strfind+0x27>
		if (*s == c)
			break;
f011f7ac:	90                   	nop
	return (char *) s;
f011f7ad:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f7b0:	c9                   	leave  
f011f7b1:	c3                   	ret    

f011f7b2 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011f7b2:	55                   	push   %ebp
f011f7b3:	89 e5                	mov    %esp,%ebp
f011f7b5:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011f7b8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011f7be:	8b 45 10             	mov    0x10(%ebp),%eax
f011f7c1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011f7c4:	eb 0e                	jmp    f011f7d4 <memset+0x22>
		*p++ = c;
f011f7c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f7c9:	8d 50 01             	lea    0x1(%eax),%edx
f011f7cc:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011f7cf:	8b 55 0c             	mov    0xc(%ebp),%edx
f011f7d2:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011f7d4:	ff 4d f8             	decl   -0x8(%ebp)
f011f7d7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011f7db:	79 e9                	jns    f011f7c6 <memset+0x14>
		*p++ = c;

	return v;
f011f7dd:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f7e0:	c9                   	leave  
f011f7e1:	c3                   	ret    

f011f7e2 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011f7e2:	55                   	push   %ebp
f011f7e3:	89 e5                	mov    %esp,%ebp
f011f7e5:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011f7e8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f7eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011f7ee:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7f1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011f7f4:	eb 16                	jmp    f011f80c <memcpy+0x2a>
		*d++ = *s++;
f011f7f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f7f9:	8d 50 01             	lea    0x1(%eax),%edx
f011f7fc:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f7ff:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f802:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f805:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011f808:	8a 12                	mov    (%edx),%dl
f011f80a:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011f80c:	8b 45 10             	mov    0x10(%ebp),%eax
f011f80f:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f812:	89 55 10             	mov    %edx,0x10(%ebp)
f011f815:	85 c0                	test   %eax,%eax
f011f817:	75 dd                	jne    f011f7f6 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011f819:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f81c:	c9                   	leave  
f011f81d:	c3                   	ret    

f011f81e <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011f81e:	55                   	push   %ebp
f011f81f:	89 e5                	mov    %esp,%ebp
f011f821:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011f824:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f827:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011f82a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f82d:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011f830:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f833:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011f836:	73 50                	jae    f011f888 <memmove+0x6a>
f011f838:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f83b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f83e:	01 d0                	add    %edx,%eax
f011f840:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011f843:	76 43                	jbe    f011f888 <memmove+0x6a>
		s += n;
f011f845:	8b 45 10             	mov    0x10(%ebp),%eax
f011f848:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011f84b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f84e:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011f851:	eb 10                	jmp    f011f863 <memmove+0x45>
			*--d = *--s;
f011f853:	ff 4d f8             	decl   -0x8(%ebp)
f011f856:	ff 4d fc             	decl   -0x4(%ebp)
f011f859:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f85c:	8a 10                	mov    (%eax),%dl
f011f85e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f861:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011f863:	8b 45 10             	mov    0x10(%ebp),%eax
f011f866:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f869:	89 55 10             	mov    %edx,0x10(%ebp)
f011f86c:	85 c0                	test   %eax,%eax
f011f86e:	75 e3                	jne    f011f853 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011f870:	eb 23                	jmp    f011f895 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011f872:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f875:	8d 50 01             	lea    0x1(%eax),%edx
f011f878:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f87b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f87e:	8d 4a 01             	lea    0x1(%edx),%ecx
f011f881:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011f884:	8a 12                	mov    (%edx),%dl
f011f886:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011f888:	8b 45 10             	mov    0x10(%ebp),%eax
f011f88b:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f88e:	89 55 10             	mov    %edx,0x10(%ebp)
f011f891:	85 c0                	test   %eax,%eax
f011f893:	75 dd                	jne    f011f872 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011f895:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f898:	c9                   	leave  
f011f899:	c3                   	ret    

f011f89a <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011f89a:	55                   	push   %ebp
f011f89b:	89 e5                	mov    %esp,%ebp
f011f89d:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011f8a0:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011f8a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f8a9:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011f8ac:	eb 2a                	jmp    f011f8d8 <memcmp+0x3e>
		if (*s1 != *s2)
f011f8ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f8b1:	8a 10                	mov    (%eax),%dl
f011f8b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f8b6:	8a 00                	mov    (%eax),%al
f011f8b8:	38 c2                	cmp    %al,%dl
f011f8ba:	74 16                	je     f011f8d2 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011f8bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f8bf:	8a 00                	mov    (%eax),%al
f011f8c1:	0f b6 d0             	movzbl %al,%edx
f011f8c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f8c7:	8a 00                	mov    (%eax),%al
f011f8c9:	0f b6 c0             	movzbl %al,%eax
f011f8cc:	29 c2                	sub    %eax,%edx
f011f8ce:	89 d0                	mov    %edx,%eax
f011f8d0:	eb 18                	jmp    f011f8ea <memcmp+0x50>
		s1++, s2++;
f011f8d2:	ff 45 fc             	incl   -0x4(%ebp)
f011f8d5:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011f8d8:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8db:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f8de:	89 55 10             	mov    %edx,0x10(%ebp)
f011f8e1:	85 c0                	test   %eax,%eax
f011f8e3:	75 c9                	jne    f011f8ae <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011f8e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f8ea:	c9                   	leave  
f011f8eb:	c3                   	ret    

f011f8ec <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011f8ec:	55                   	push   %ebp
f011f8ed:	89 e5                	mov    %esp,%ebp
f011f8ef:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011f8f2:	8b 55 08             	mov    0x8(%ebp),%edx
f011f8f5:	8b 45 10             	mov    0x10(%ebp),%eax
f011f8f8:	01 d0                	add    %edx,%eax
f011f8fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011f8fd:	eb 15                	jmp    f011f914 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011f8ff:	8b 45 08             	mov    0x8(%ebp),%eax
f011f902:	8a 00                	mov    (%eax),%al
f011f904:	0f b6 d0             	movzbl %al,%edx
f011f907:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f90a:	0f b6 c0             	movzbl %al,%eax
f011f90d:	39 c2                	cmp    %eax,%edx
f011f90f:	74 0d                	je     f011f91e <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011f911:	ff 45 08             	incl   0x8(%ebp)
f011f914:	8b 45 08             	mov    0x8(%ebp),%eax
f011f917:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011f91a:	72 e3                	jb     f011f8ff <memfind+0x13>
f011f91c:	eb 01                	jmp    f011f91f <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011f91e:	90                   	nop
	return (void *) s;
f011f91f:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011f922:	c9                   	leave  
f011f923:	c3                   	ret    

f011f924 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011f924:	55                   	push   %ebp
f011f925:	89 e5                	mov    %esp,%ebp
f011f927:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011f92a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011f931:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011f938:	eb 03                	jmp    f011f93d <strtol+0x19>
		s++;
f011f93a:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011f93d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f940:	8a 00                	mov    (%eax),%al
f011f942:	3c 20                	cmp    $0x20,%al
f011f944:	74 f4                	je     f011f93a <strtol+0x16>
f011f946:	8b 45 08             	mov    0x8(%ebp),%eax
f011f949:	8a 00                	mov    (%eax),%al
f011f94b:	3c 09                	cmp    $0x9,%al
f011f94d:	74 eb                	je     f011f93a <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011f94f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f952:	8a 00                	mov    (%eax),%al
f011f954:	3c 2b                	cmp    $0x2b,%al
f011f956:	75 05                	jne    f011f95d <strtol+0x39>
		s++;
f011f958:	ff 45 08             	incl   0x8(%ebp)
f011f95b:	eb 13                	jmp    f011f970 <strtol+0x4c>
	else if (*s == '-')
f011f95d:	8b 45 08             	mov    0x8(%ebp),%eax
f011f960:	8a 00                	mov    (%eax),%al
f011f962:	3c 2d                	cmp    $0x2d,%al
f011f964:	75 0a                	jne    f011f970 <strtol+0x4c>
		s++, neg = 1;
f011f966:	ff 45 08             	incl   0x8(%ebp)
f011f969:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011f970:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f974:	74 06                	je     f011f97c <strtol+0x58>
f011f976:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011f97a:	75 20                	jne    f011f99c <strtol+0x78>
f011f97c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f97f:	8a 00                	mov    (%eax),%al
f011f981:	3c 30                	cmp    $0x30,%al
f011f983:	75 17                	jne    f011f99c <strtol+0x78>
f011f985:	8b 45 08             	mov    0x8(%ebp),%eax
f011f988:	40                   	inc    %eax
f011f989:	8a 00                	mov    (%eax),%al
f011f98b:	3c 78                	cmp    $0x78,%al
f011f98d:	75 0d                	jne    f011f99c <strtol+0x78>
		s += 2, base = 16;
f011f98f:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011f993:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011f99a:	eb 28                	jmp    f011f9c4 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011f99c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f9a0:	75 15                	jne    f011f9b7 <strtol+0x93>
f011f9a2:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9a5:	8a 00                	mov    (%eax),%al
f011f9a7:	3c 30                	cmp    $0x30,%al
f011f9a9:	75 0c                	jne    f011f9b7 <strtol+0x93>
		s++, base = 8;
f011f9ab:	ff 45 08             	incl   0x8(%ebp)
f011f9ae:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011f9b5:	eb 0d                	jmp    f011f9c4 <strtol+0xa0>
	else if (base == 0)
f011f9b7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f9bb:	75 07                	jne    f011f9c4 <strtol+0xa0>
		base = 10;
f011f9bd:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011f9c4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9c7:	8a 00                	mov    (%eax),%al
f011f9c9:	3c 2f                	cmp    $0x2f,%al
f011f9cb:	7e 19                	jle    f011f9e6 <strtol+0xc2>
f011f9cd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9d0:	8a 00                	mov    (%eax),%al
f011f9d2:	3c 39                	cmp    $0x39,%al
f011f9d4:	7f 10                	jg     f011f9e6 <strtol+0xc2>
			dig = *s - '0';
f011f9d6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9d9:	8a 00                	mov    (%eax),%al
f011f9db:	0f be c0             	movsbl %al,%eax
f011f9de:	83 e8 30             	sub    $0x30,%eax
f011f9e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f9e4:	eb 42                	jmp    f011fa28 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011f9e6:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9e9:	8a 00                	mov    (%eax),%al
f011f9eb:	3c 60                	cmp    $0x60,%al
f011f9ed:	7e 19                	jle    f011fa08 <strtol+0xe4>
f011f9ef:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9f2:	8a 00                	mov    (%eax),%al
f011f9f4:	3c 7a                	cmp    $0x7a,%al
f011f9f6:	7f 10                	jg     f011fa08 <strtol+0xe4>
			dig = *s - 'a' + 10;
f011f9f8:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9fb:	8a 00                	mov    (%eax),%al
f011f9fd:	0f be c0             	movsbl %al,%eax
f011fa00:	83 e8 57             	sub    $0x57,%eax
f011fa03:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fa06:	eb 20                	jmp    f011fa28 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011fa08:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa0b:	8a 00                	mov    (%eax),%al
f011fa0d:	3c 40                	cmp    $0x40,%al
f011fa0f:	7e 39                	jle    f011fa4a <strtol+0x126>
f011fa11:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa14:	8a 00                	mov    (%eax),%al
f011fa16:	3c 5a                	cmp    $0x5a,%al
f011fa18:	7f 30                	jg     f011fa4a <strtol+0x126>
			dig = *s - 'A' + 10;
f011fa1a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa1d:	8a 00                	mov    (%eax),%al
f011fa1f:	0f be c0             	movsbl %al,%eax
f011fa22:	83 e8 37             	sub    $0x37,%eax
f011fa25:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011fa28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa2b:	3b 45 10             	cmp    0x10(%ebp),%eax
f011fa2e:	7d 19                	jge    f011fa49 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011fa30:	ff 45 08             	incl   0x8(%ebp)
f011fa33:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fa36:	0f af 45 10          	imul   0x10(%ebp),%eax
f011fa3a:	89 c2                	mov    %eax,%edx
f011fa3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa3f:	01 d0                	add    %edx,%eax
f011fa41:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011fa44:	e9 7b ff ff ff       	jmp    f011f9c4 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011fa49:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011fa4a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fa4e:	74 08                	je     f011fa58 <strtol+0x134>
		*endptr = (char *) s;
f011fa50:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa53:	8b 55 08             	mov    0x8(%ebp),%edx
f011fa56:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011fa58:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011fa5c:	74 07                	je     f011fa65 <strtol+0x141>
f011fa5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fa61:	f7 d8                	neg    %eax
f011fa63:	eb 03                	jmp    f011fa68 <strtol+0x144>
f011fa65:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011fa68:	c9                   	leave  
f011fa69:	c3                   	ret    

f011fa6a <ltostr>:

void
ltostr(long value, char *str)
{
f011fa6a:	55                   	push   %ebp
f011fa6b:	89 e5                	mov    %esp,%ebp
f011fa6d:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011fa70:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011fa77:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011fa7e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fa82:	79 13                	jns    f011fa97 <ltostr+0x2d>
	{
		neg = 1;
f011fa84:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011fa8b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fa8e:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011fa91:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011fa94:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011fa97:	8b 45 08             	mov    0x8(%ebp),%eax
f011fa9a:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011fa9f:	99                   	cltd   
f011faa0:	f7 f9                	idiv   %ecx
f011faa2:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011faa5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011faa8:	8d 50 01             	lea    0x1(%eax),%edx
f011faab:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011faae:	89 c2                	mov    %eax,%edx
f011fab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fab3:	01 d0                	add    %edx,%eax
f011fab5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fab8:	83 c2 30             	add    $0x30,%edx
f011fabb:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011fabd:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011fac0:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011fac5:	f7 e9                	imul   %ecx
f011fac7:	c1 fa 02             	sar    $0x2,%edx
f011faca:	89 c8                	mov    %ecx,%eax
f011facc:	c1 f8 1f             	sar    $0x1f,%eax
f011facf:	29 c2                	sub    %eax,%edx
f011fad1:	89 d0                	mov    %edx,%eax
f011fad3:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011fad6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fada:	75 bb                	jne    f011fa97 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011fadc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011fae3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fae6:	48                   	dec    %eax
f011fae7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011faea:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011faee:	74 3d                	je     f011fb2d <ltostr+0xc3>
		start = 1 ;
f011faf0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011faf7:	eb 34                	jmp    f011fb2d <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011faf9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fafc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011faff:	01 d0                	add    %edx,%eax
f011fb01:	8a 00                	mov    (%eax),%al
f011fb03:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011fb06:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb09:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb0c:	01 c2                	add    %eax,%edx
f011fb0e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011fb11:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb14:	01 c8                	add    %ecx,%eax
f011fb16:	8a 00                	mov    (%eax),%al
f011fb18:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011fb1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fb1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb20:	01 c2                	add    %eax,%edx
f011fb22:	8a 45 eb             	mov    -0x15(%ebp),%al
f011fb25:	88 02                	mov    %al,(%edx)
		start++ ;
f011fb27:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011fb2a:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011fb2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb30:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fb33:	7c c4                	jl     f011faf9 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011fb35:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011fb38:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fb3b:	01 d0                	add    %edx,%eax
f011fb3d:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011fb40:	90                   	nop
f011fb41:	c9                   	leave  
f011fb42:	c3                   	ret    

f011fb43 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011fb43:	55                   	push   %ebp
f011fb44:	89 e5                	mov    %esp,%ebp
f011fb46:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011fb49:	ff 75 08             	pushl  0x8(%ebp)
f011fb4c:	e8 73 fa ff ff       	call   f011f5c4 <strlen>
f011fb51:	83 c4 04             	add    $0x4,%esp
f011fb54:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011fb57:	ff 75 0c             	pushl  0xc(%ebp)
f011fb5a:	e8 65 fa ff ff       	call   f011f5c4 <strlen>
f011fb5f:	83 c4 04             	add    $0x4,%esp
f011fb62:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011fb65:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011fb6c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011fb73:	eb 17                	jmp    f011fb8c <strcconcat+0x49>
		final[s] = str1[s] ;
f011fb75:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fb78:	8b 45 10             	mov    0x10(%ebp),%eax
f011fb7b:	01 c2                	add    %eax,%edx
f011fb7d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011fb80:	8b 45 08             	mov    0x8(%ebp),%eax
f011fb83:	01 c8                	add    %ecx,%eax
f011fb85:	8a 00                	mov    (%eax),%al
f011fb87:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011fb89:	ff 45 fc             	incl   -0x4(%ebp)
f011fb8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fb8f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011fb92:	7c e1                	jl     f011fb75 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011fb94:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011fb9b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011fba2:	eb 1f                	jmp    f011fbc3 <strcconcat+0x80>
		final[s++] = str2[i] ;
f011fba4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011fba7:	8d 50 01             	lea    0x1(%eax),%edx
f011fbaa:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011fbad:	89 c2                	mov    %eax,%edx
f011fbaf:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbb2:	01 c2                	add    %eax,%edx
f011fbb4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011fbb7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fbba:	01 c8                	add    %ecx,%eax
f011fbbc:	8a 00                	mov    (%eax),%al
f011fbbe:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011fbc0:	ff 45 f8             	incl   -0x8(%ebp)
f011fbc3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011fbc6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fbc9:	7c d9                	jl     f011fba4 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011fbcb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011fbce:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbd1:	01 d0                	add    %edx,%eax
f011fbd3:	c6 00 00             	movb   $0x0,(%eax)
}
f011fbd6:	90                   	nop
f011fbd7:	c9                   	leave  
f011fbd8:	c3                   	ret    

f011fbd9 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011fbd9:	55                   	push   %ebp
f011fbda:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011fbdc:	8b 45 14             	mov    0x14(%ebp),%eax
f011fbdf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011fbe5:	8b 45 14             	mov    0x14(%ebp),%eax
f011fbe8:	8b 00                	mov    (%eax),%eax
f011fbea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fbf1:	8b 45 10             	mov    0x10(%ebp),%eax
f011fbf4:	01 d0                	add    %edx,%eax
f011fbf6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011fbfc:	eb 0c                	jmp    f011fc0a <strsplit+0x31>
			*string++ = 0;
f011fbfe:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc01:	8d 50 01             	lea    0x1(%eax),%edx
f011fc04:	89 55 08             	mov    %edx,0x8(%ebp)
f011fc07:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011fc0a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc0d:	8a 00                	mov    (%eax),%al
f011fc0f:	84 c0                	test   %al,%al
f011fc11:	74 18                	je     f011fc2b <strsplit+0x52>
f011fc13:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc16:	8a 00                	mov    (%eax),%al
f011fc18:	0f be c0             	movsbl %al,%eax
f011fc1b:	50                   	push   %eax
f011fc1c:	ff 75 0c             	pushl  0xc(%ebp)
f011fc1f:	e8 32 fb ff ff       	call   f011f756 <strchr>
f011fc24:	83 c4 08             	add    $0x8,%esp
f011fc27:	85 c0                	test   %eax,%eax
f011fc29:	75 d3                	jne    f011fbfe <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011fc2b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc2e:	8a 00                	mov    (%eax),%al
f011fc30:	84 c0                	test   %al,%al
f011fc32:	74 5a                	je     f011fc8e <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011fc34:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc37:	8b 00                	mov    (%eax),%eax
f011fc39:	83 f8 0f             	cmp    $0xf,%eax
f011fc3c:	75 07                	jne    f011fc45 <strsplit+0x6c>
		{
			return 0;
f011fc3e:	b8 00 00 00 00       	mov    $0x0,%eax
f011fc43:	eb 66                	jmp    f011fcab <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011fc45:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc48:	8b 00                	mov    (%eax),%eax
f011fc4a:	8d 48 01             	lea    0x1(%eax),%ecx
f011fc4d:	8b 55 14             	mov    0x14(%ebp),%edx
f011fc50:	89 0a                	mov    %ecx,(%edx)
f011fc52:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fc59:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc5c:	01 c2                	add    %eax,%edx
f011fc5e:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc61:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011fc63:	eb 03                	jmp    f011fc68 <strsplit+0x8f>
			string++;
f011fc65:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011fc68:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc6b:	8a 00                	mov    (%eax),%al
f011fc6d:	84 c0                	test   %al,%al
f011fc6f:	74 8b                	je     f011fbfc <strsplit+0x23>
f011fc71:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc74:	8a 00                	mov    (%eax),%al
f011fc76:	0f be c0             	movsbl %al,%eax
f011fc79:	50                   	push   %eax
f011fc7a:	ff 75 0c             	pushl  0xc(%ebp)
f011fc7d:	e8 d4 fa ff ff       	call   f011f756 <strchr>
f011fc82:	83 c4 08             	add    $0x8,%esp
f011fc85:	85 c0                	test   %eax,%eax
f011fc87:	74 dc                	je     f011fc65 <strsplit+0x8c>
			string++;
	}
f011fc89:	e9 6e ff ff ff       	jmp    f011fbfc <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011fc8e:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011fc8f:	8b 45 14             	mov    0x14(%ebp),%eax
f011fc92:	8b 00                	mov    (%eax),%eax
f011fc94:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fc9b:	8b 45 10             	mov    0x10(%ebp),%eax
f011fc9e:	01 d0                	add    %edx,%eax
f011fca0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011fca6:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011fcab:	c9                   	leave  
f011fcac:	c3                   	ret    

f011fcad <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011fcad:	55                   	push   %ebp
f011fcae:	89 e5                	mov    %esp,%ebp
f011fcb0:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f011fcb3:	83 ec 04             	sub    $0x4,%esp
f011fcb6:	68 dc 0c 13 f0       	push   $0xf0130cdc
f011fcbb:	68 3f 01 00 00       	push   $0x13f
f011fcc0:	68 fe 0c 13 f0       	push   $0xf0130cfe
f011fcc5:	e8 6f 06 fe ff       	call   f0100339 <_panic>

f011fcca <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011fcca:	55                   	push   %ebp
f011fccb:	89 e5                	mov    %esp,%ebp
f011fccd:	83 ec 18             	sub    $0x18,%esp
f011fcd0:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011fcd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fcda:	89 c2                	mov    %eax,%edx
f011fcdc:	ec                   	in     (%dx),%al
f011fcdd:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011fce0:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011fce3:	0f b6 c0             	movzbl %al,%eax
f011fce6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fcec:	25 c0 00 00 00       	and    $0xc0,%eax
f011fcf1:	83 f8 40             	cmp    $0x40,%eax
f011fcf4:	75 10                	jne    f011fd06 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f011fcf6:	83 ec 0c             	sub    $0xc,%esp
f011fcf9:	68 c0 d1 6b f0       	push   $0xf06bd1c0
f011fcfe:	e8 6d fd fe ff       	call   f010fa70 <wakeup_one>
f011fd03:	83 c4 10             	add    $0x10,%esp
	}

}
f011fd06:	90                   	nop
f011fd07:	c9                   	leave  
f011fd08:	c3                   	ret    

f011fd09 <ide_init>:

void ide_init()
{
f011fd09:	55                   	push   %ebp
f011fd0a:	89 e5                	mov    %esp,%ebp
f011fd0c:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f011fd0f:	83 ec 08             	sub    $0x8,%esp
f011fd12:	68 ca fc 11 f0       	push   $0xf011fcca
f011fd17:	6a 0e                	push   $0xe
f011fd19:	e8 03 df fe ff       	call   f010dc21 <irq_install_handler>
f011fd1e:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f011fd21:	83 ec 08             	sub    $0x8,%esp
f011fd24:	68 0c 0d 13 f0       	push   $0xf0130d0c
f011fd29:	68 c0 d1 6b f0       	push   $0xf06bd1c0
f011fd2e:	e8 a3 fc fe ff       	call   f010f9d6 <init_channel>
f011fd33:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f011fd36:	83 ec 08             	sub    $0x8,%esp
f011fd39:	68 19 0d 13 f0       	push   $0xf0130d19
f011fd3e:	68 e0 d7 6b f0       	push   $0xf06bd7e0
f011fd43:	e8 9d f8 fe ff       	call   f010f5e5 <init_spinlock>
f011fd48:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f011fd4b:	90                   	nop
f011fd4c:	c9                   	leave  
f011fd4d:	c3                   	ret    

f011fd4e <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f011fd4e:	55                   	push   %ebp
f011fd4f:	89 e5                	mov    %esp,%ebp
f011fd51:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011fd54:	90                   	nop
f011fd55:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011fd5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fd5f:	89 c2                	mov    %eax,%edx
f011fd61:	ec                   	in     (%dx),%al
f011fd62:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011fd65:	8a 45 ef             	mov    -0x11(%ebp),%al
f011fd68:	0f b6 c0             	movzbl %al,%eax
f011fd6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fd6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fd71:	25 c0 00 00 00       	and    $0xc0,%eax
f011fd76:	83 f8 40             	cmp    $0x40,%eax
f011fd79:	75 da                	jne    f011fd55 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011fd7b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011fd7f:	74 24                	je     f011fda5 <ide_wait_ready+0x57>
f011fd81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fd84:	83 e0 21             	and    $0x21,%eax
f011fd87:	85 c0                	test   %eax,%eax
f011fd89:	74 1a                	je     f011fda5 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011fd8b:	83 ec 0c             	sub    $0xc,%esp
f011fd8e:	ff 75 f4             	pushl  -0xc(%ebp)
f011fd91:	ff 75 f4             	pushl  -0xc(%ebp)
f011fd94:	68 2c 0d 13 f0       	push   $0xf0130d2c
f011fd99:	6a 5d                	push   $0x5d
f011fd9b:	68 4f 0d 13 f0       	push   $0xf0130d4f
f011fda0:	e8 94 05 fe ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011fda5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fdaa:	c9                   	leave  
f011fdab:	c3                   	ret    

f011fdac <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011fdac:	55                   	push   %ebp
f011fdad:	89 e5                	mov    %esp,%ebp
f011fdaf:	57                   	push   %edi
f011fdb0:	53                   	push   %ebx
f011fdb1:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f011fdb4:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011fdbb:	76 16                	jbe    f011fdd3 <ide_read+0x27>
f011fdbd:	68 5a 0d 13 f0       	push   $0xf0130d5a
f011fdc2:	68 67 0d 13 f0       	push   $0xf0130d67
f011fdc7:	6a 68                	push   $0x68
f011fdc9:	68 4f 0d 13 f0       	push   $0xf0130d4f
f011fdce:	e8 66 05 fe ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f011fdd3:	83 ec 0c             	sub    $0xc,%esp
f011fdd6:	6a 00                	push   $0x0
f011fdd8:	e8 71 ff ff ff       	call   f011fd4e <ide_wait_ready>
f011fddd:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f011fde0:	8b 45 10             	mov    0x10(%ebp),%eax
f011fde3:	0f b6 c0             	movzbl %al,%eax
f011fde6:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011fded:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011fdf0:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011fdf3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fdf6:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011fdf7:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdfa:	0f b6 c0             	movzbl %al,%eax
f011fdfd:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011fe04:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011fe07:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011fe0a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011fe0d:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011fe0e:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe11:	c1 e8 08             	shr    $0x8,%eax
f011fe14:	0f b6 c0             	movzbl %al,%eax
f011fe17:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011fe1e:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011fe21:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011fe24:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011fe27:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011fe28:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe2b:	c1 e8 10             	shr    $0x10,%eax
f011fe2e:	0f b6 c0             	movzbl %al,%eax
f011fe31:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011fe38:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011fe3b:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011fe3e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011fe41:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011fe42:	a1 70 d0 6b f0       	mov    0xf06bd070,%eax
f011fe47:	83 e0 01             	and    $0x1,%eax
f011fe4a:	c1 e0 04             	shl    $0x4,%eax
f011fe4d:	88 c2                	mov    %al,%dl
f011fe4f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe52:	c1 e8 18             	shr    $0x18,%eax
f011fe55:	83 e0 0f             	and    $0xf,%eax
f011fe58:	09 d0                	or     %edx,%eax
f011fe5a:	83 c8 e0             	or     $0xffffffe0,%eax
f011fe5d:	0f b6 c0             	movzbl %al,%eax
f011fe60:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011fe67:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011fe6a:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011fe6d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011fe70:	ee                   	out    %al,(%dx)
f011fe71:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011fe78:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f011fe7c:	8a 45 d7             	mov    -0x29(%ebp),%al
f011fe7f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011fe82:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011fe83:	eb 55                	jmp    f011feda <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f011fe85:	83 ec 0c             	sub    $0xc,%esp
f011fe88:	6a 01                	push   $0x1
f011fe8a:	e8 bf fe ff ff       	call   f011fd4e <ide_wait_ready>
f011fe8f:	83 c4 10             	add    $0x10,%esp
f011fe92:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011fe95:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011fe99:	79 05                	jns    f011fea0 <ide_read+0xf4>
			return r;
f011fe9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fe9e:	eb 45                	jmp    f011fee5 <ide_read+0x139>
f011fea0:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011fea7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011feaa:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011fead:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011feb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011feb7:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011feba:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011febd:	89 cb                	mov    %ecx,%ebx
f011febf:	89 df                	mov    %ebx,%edi
f011fec1:	89 c1                	mov    %eax,%ecx
f011fec3:	fc                   	cld    
f011fec4:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011fec6:	89 c8                	mov    %ecx,%eax
f011fec8:	89 fb                	mov    %edi,%ebx
f011feca:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011fecd:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011fed0:	ff 4d 10             	decl   0x10(%ebp)
f011fed3:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011feda:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011fede:	75 a5                	jne    f011fe85 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f011fee0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011fee5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011fee8:	5b                   	pop    %ebx
f011fee9:	5f                   	pop    %edi
f011feea:	5d                   	pop    %ebp
f011feeb:	c3                   	ret    

f011feec <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011feec:	55                   	push   %ebp
f011feed:	89 e5                	mov    %esp,%ebp
f011feef:	56                   	push   %esi
f011fef0:	53                   	push   %ebx
f011fef1:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011fef4:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011fefb:	76 19                	jbe    f011ff16 <ide_write+0x2a>
f011fefd:	68 5a 0d 13 f0       	push   $0xf0130d5a
f011ff02:	68 67 0d 13 f0       	push   $0xf0130d67
f011ff07:	68 82 00 00 00       	push   $0x82
f011ff0c:	68 4f 0d 13 f0       	push   $0xf0130d4f
f011ff11:	e8 23 04 fe ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f011ff16:	83 ec 0c             	sub    $0xc,%esp
f011ff19:	6a 00                	push   $0x0
f011ff1b:	e8 2e fe ff ff       	call   f011fd4e <ide_wait_ready>
f011ff20:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f011ff23:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff26:	0f b6 c0             	movzbl %al,%eax
f011ff29:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011ff30:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011ff33:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011ff36:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011ff39:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011ff3a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff3d:	0f b6 c0             	movzbl %al,%eax
f011ff40:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011ff47:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011ff4a:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011ff4d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ff50:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011ff51:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff54:	c1 e8 08             	shr    $0x8,%eax
f011ff57:	0f b6 c0             	movzbl %al,%eax
f011ff5a:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011ff61:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011ff64:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011ff67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ff6a:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011ff6b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff6e:	c1 e8 10             	shr    $0x10,%eax
f011ff71:	0f b6 c0             	movzbl %al,%eax
f011ff74:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011ff7b:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011ff7e:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011ff81:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011ff84:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011ff85:	a1 70 d0 6b f0       	mov    0xf06bd070,%eax
f011ff8a:	83 e0 01             	and    $0x1,%eax
f011ff8d:	c1 e0 04             	shl    $0x4,%eax
f011ff90:	88 c2                	mov    %al,%dl
f011ff92:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff95:	c1 e8 18             	shr    $0x18,%eax
f011ff98:	83 e0 0f             	and    $0xf,%eax
f011ff9b:	09 d0                	or     %edx,%eax
f011ff9d:	83 c8 e0             	or     $0xffffffe0,%eax
f011ffa0:	0f b6 c0             	movzbl %al,%eax
f011ffa3:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011ffaa:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011ffad:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011ffb0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011ffb3:	ee                   	out    %al,(%dx)
f011ffb4:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011ffbb:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f011ffbf:	8a 45 d7             	mov    -0x29(%ebp),%al
f011ffc2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ffc5:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011ffc6:	eb 55                	jmp    f012001d <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f011ffc8:	83 ec 0c             	sub    $0xc,%esp
f011ffcb:	6a 01                	push   $0x1
f011ffcd:	e8 7c fd ff ff       	call   f011fd4e <ide_wait_ready>
f011ffd2:	83 c4 10             	add    $0x10,%esp
f011ffd5:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011ffd8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011ffdc:	79 05                	jns    f011ffe3 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f011ffde:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ffe1:	eb 45                	jmp    f0120028 <ide_write+0x13c>
f011ffe3:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011ffea:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ffed:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011fff0:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011fff7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fffa:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011fffd:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120000:	89 cb                	mov    %ecx,%ebx
f0120002:	89 de                	mov    %ebx,%esi
f0120004:	89 c1                	mov    %eax,%ecx
f0120006:	fc                   	cld    
f0120007:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0120009:	89 c8                	mov    %ecx,%eax
f012000b:	89 f3                	mov    %esi,%ebx
f012000d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120010:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120013:	ff 4d 10             	decl   0x10(%ebp)
f0120016:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f012001d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120021:	75 a5                	jne    f011ffc8 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0120023:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120028:	8d 65 f8             	lea    -0x8(%ebp),%esp
f012002b:	5b                   	pop    %ebx
f012002c:	5e                   	pop    %esi
f012002d:	5d                   	pop    %ebp
f012002e:	c3                   	ret    

f012002f <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f012002f:	55                   	push   %ebp
f0120030:	89 e5                	mov    %esp,%ebp
f0120032:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120035:	8b 45 08             	mov    0x8(%ebp),%eax
f0120038:	83 e8 04             	sub    $0x4,%eax
f012003b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f012003e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120041:	8b 00                	mov    (%eax),%eax
f0120043:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0120046:	c9                   	leave  
f0120047:	c3                   	ret    

f0120048 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0120048:	55                   	push   %ebp
f0120049:	89 e5                	mov    %esp,%ebp
f012004b:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f012004e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120051:	83 e8 04             	sub    $0x4,%eax
f0120054:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0120057:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012005a:	8b 00                	mov    (%eax),%eax
f012005c:	83 e0 01             	and    $0x1,%eax
f012005f:	85 c0                	test   %eax,%eax
f0120061:	0f 94 c0             	sete   %al
}
f0120064:	c9                   	leave  
f0120065:	c3                   	ret    

f0120066 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0120066:	55                   	push   %ebp
f0120067:	89 e5                	mov    %esp,%ebp
f0120069:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f012006c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0120073:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120076:	83 f8 02             	cmp    $0x2,%eax
f0120079:	74 2b                	je     f01200a6 <alloc_block+0x40>
f012007b:	83 f8 02             	cmp    $0x2,%eax
f012007e:	7f 07                	jg     f0120087 <alloc_block+0x21>
f0120080:	83 f8 01             	cmp    $0x1,%eax
f0120083:	74 0e                	je     f0120093 <alloc_block+0x2d>
f0120085:	eb 58                	jmp    f01200df <alloc_block+0x79>
f0120087:	83 f8 03             	cmp    $0x3,%eax
f012008a:	74 2d                	je     f01200b9 <alloc_block+0x53>
f012008c:	83 f8 04             	cmp    $0x4,%eax
f012008f:	74 3b                	je     f01200cc <alloc_block+0x66>
f0120091:	eb 4c                	jmp    f01200df <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0120093:	83 ec 0c             	sub    $0xc,%esp
f0120096:	ff 75 08             	pushl  0x8(%ebp)
f0120099:	e8 11 03 00 00       	call   f01203af <alloc_block_FF>
f012009e:	83 c4 10             	add    $0x10,%esp
f01200a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01200a4:	eb 4a                	jmp    f01200f0 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f01200a6:	83 ec 0c             	sub    $0xc,%esp
f01200a9:	ff 75 08             	pushl  0x8(%ebp)
f01200ac:	e8 fa 19 00 00       	call   f0121aab <alloc_block_NF>
f01200b1:	83 c4 10             	add    $0x10,%esp
f01200b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01200b7:	eb 37                	jmp    f01200f0 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f01200b9:	83 ec 0c             	sub    $0xc,%esp
f01200bc:	ff 75 08             	pushl  0x8(%ebp)
f01200bf:	e8 a7 07 00 00       	call   f012086b <alloc_block_BF>
f01200c4:	83 c4 10             	add    $0x10,%esp
f01200c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01200ca:	eb 24                	jmp    f01200f0 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f01200cc:	83 ec 0c             	sub    $0xc,%esp
f01200cf:	ff 75 08             	pushl  0x8(%ebp)
f01200d2:	e8 b7 19 00 00       	call   f0121a8e <alloc_block_WF>
f01200d7:	83 c4 10             	add    $0x10,%esp
f01200da:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f01200dd:	eb 11                	jmp    f01200f0 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f01200df:	83 ec 0c             	sub    $0xc,%esp
f01200e2:	68 7c 0d 13 f0       	push   $0xf0130d7c
f01200e7:	e8 9f 0e fe ff       	call   f0100f8b <cprintf>
f01200ec:	83 c4 10             	add    $0x10,%esp
		break;
f01200ef:	90                   	nop
	}
	return va;
f01200f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01200f3:	c9                   	leave  
f01200f4:	c3                   	ret    

f01200f5 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f01200f5:	55                   	push   %ebp
f01200f6:	89 e5                	mov    %esp,%ebp
f01200f8:	53                   	push   %ebx
f01200f9:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f01200fc:	83 ec 0c             	sub    $0xc,%esp
f01200ff:	68 9c 0d 13 f0       	push   $0xf0130d9c
f0120104:	e8 82 0e fe ff       	call   f0100f8b <cprintf>
f0120109:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f012010c:	83 ec 0c             	sub    $0xc,%esp
f012010f:	68 c7 0d 13 f0       	push   $0xf0130dc7
f0120114:	e8 72 0e fe ff       	call   f0100f8b <cprintf>
f0120119:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f012011c:	8b 45 08             	mov    0x8(%ebp),%eax
f012011f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120122:	eb 37                	jmp    f012015b <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0120124:	83 ec 0c             	sub    $0xc,%esp
f0120127:	ff 75 f4             	pushl  -0xc(%ebp)
f012012a:	e8 19 ff ff ff       	call   f0120048 <is_free_block>
f012012f:	83 c4 10             	add    $0x10,%esp
f0120132:	0f be d8             	movsbl %al,%ebx
f0120135:	83 ec 0c             	sub    $0xc,%esp
f0120138:	ff 75 f4             	pushl  -0xc(%ebp)
f012013b:	e8 ef fe ff ff       	call   f012002f <get_block_size>
f0120140:	83 c4 10             	add    $0x10,%esp
f0120143:	83 ec 04             	sub    $0x4,%esp
f0120146:	53                   	push   %ebx
f0120147:	50                   	push   %eax
f0120148:	68 df 0d 13 f0       	push   $0xf0130ddf
f012014d:	e8 39 0e fe ff       	call   f0100f8b <cprintf>
f0120152:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0120155:	8b 45 10             	mov    0x10(%ebp),%eax
f0120158:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012015b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012015f:	74 07                	je     f0120168 <print_blocks_list+0x73>
f0120161:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120164:	8b 00                	mov    (%eax),%eax
f0120166:	eb 05                	jmp    f012016d <print_blocks_list+0x78>
f0120168:	b8 00 00 00 00       	mov    $0x0,%eax
f012016d:	89 45 10             	mov    %eax,0x10(%ebp)
f0120170:	8b 45 10             	mov    0x10(%ebp),%eax
f0120173:	85 c0                	test   %eax,%eax
f0120175:	75 ad                	jne    f0120124 <print_blocks_list+0x2f>
f0120177:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012017b:	75 a7                	jne    f0120124 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f012017d:	83 ec 0c             	sub    $0xc,%esp
f0120180:	68 9c 0d 13 f0       	push   $0xf0130d9c
f0120185:	e8 01 0e fe ff       	call   f0100f8b <cprintf>
f012018a:	83 c4 10             	add    $0x10,%esp

}
f012018d:	90                   	nop
f012018e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0120191:	c9                   	leave  
f0120192:	c3                   	ret    

f0120193 <initialize_dynamic_allocator>:
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================

// Youssef Mohsen
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0120193:	55                   	push   %ebp
f0120194:	89 e5                	mov    %esp,%ebp
f0120196:	83 ec 18             	sub    $0x18,%esp
        //==================================================================================
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0120199:	8b 45 0c             	mov    0xc(%ebp),%eax
f012019c:	83 e0 01             	and    $0x1,%eax
f012019f:	85 c0                	test   %eax,%eax
f01201a1:	74 03                	je     f01201a6 <initialize_dynamic_allocator+0x13>
f01201a3:	ff 45 0c             	incl   0xc(%ebp)
            if (initSizeOfAllocatedSpace == 0)
f01201a6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01201aa:	0f 84 c7 01 00 00    	je     f0120377 <initialize_dynamic_allocator+0x1e4>
                return ;
            is_initialized = 1;
f01201b0:	c7 05 74 d0 6b f0 01 	movl   $0x1,0xf06bd074
f01201b7:	00 00 00 
        //TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
f01201ba:	8b 55 08             	mov    0x8(%ebp),%edx
f01201bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201c0:	01 d0                	add    %edx,%eax
f01201c2:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f01201c7:	0f 87 ad 01 00 00    	ja     f012037a <initialize_dynamic_allocator+0x1e7>
        return;
    if(daStart < USER_HEAP_START)
f01201cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01201d0:	85 c0                	test   %eax,%eax
f01201d2:	0f 89 a5 01 00 00    	jns    f012037d <initialize_dynamic_allocator+0x1ea>
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
f01201d8:	8b 55 08             	mov    0x8(%ebp),%edx
f01201db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01201de:	01 d0                	add    %edx,%eax
f01201e0:	83 e8 04             	sub    $0x4,%eax
f01201e3:	a3 14 da 6b f0       	mov    %eax,0xf06bda14
     struct BlockElement * element = NULL;
f01201e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     LIST_FOREACH(element, &freeBlocksList)
f01201ef:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01201f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01201f7:	e9 87 00 00 00       	jmp    f0120283 <initialize_dynamic_allocator+0xf0>
     {
        LIST_REMOVE(&freeBlocksList,element);
f01201fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120200:	75 14                	jne    f0120216 <initialize_dynamic_allocator+0x83>
f0120202:	83 ec 04             	sub    $0x4,%esp
f0120205:	68 f7 0d 13 f0       	push   $0xf0130df7
f012020a:	6a 79                	push   $0x79
f012020c:	68 15 0e 13 f0       	push   $0xf0130e15
f0120211:	e8 23 01 fe ff       	call   f0100339 <_panic>
f0120216:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120219:	8b 00                	mov    (%eax),%eax
f012021b:	85 c0                	test   %eax,%eax
f012021d:	74 10                	je     f012022f <initialize_dynamic_allocator+0x9c>
f012021f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120222:	8b 00                	mov    (%eax),%eax
f0120224:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120227:	8b 52 04             	mov    0x4(%edx),%edx
f012022a:	89 50 04             	mov    %edx,0x4(%eax)
f012022d:	eb 0b                	jmp    f012023a <initialize_dynamic_allocator+0xa7>
f012022f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120232:	8b 40 04             	mov    0x4(%eax),%eax
f0120235:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012023a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012023d:	8b 40 04             	mov    0x4(%eax),%eax
f0120240:	85 c0                	test   %eax,%eax
f0120242:	74 0f                	je     f0120253 <initialize_dynamic_allocator+0xc0>
f0120244:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120247:	8b 40 04             	mov    0x4(%eax),%eax
f012024a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012024d:	8b 12                	mov    (%edx),%edx
f012024f:	89 10                	mov    %edx,(%eax)
f0120251:	eb 0a                	jmp    f012025d <initialize_dynamic_allocator+0xca>
f0120253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120256:	8b 00                	mov    (%eax),%eax
f0120258:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012025d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120260:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120266:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120269:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120270:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120275:	48                   	dec    %eax
f0120276:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
        return;
    if(daStart < USER_HEAP_START)
        return;
    end_add = daStart + initSizeOfAllocatedSpace - sizeof(struct Block_Start_End);
     struct BlockElement * element = NULL;
     LIST_FOREACH(element, &freeBlocksList)
f012027b:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0120280:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120283:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120287:	74 07                	je     f0120290 <initialize_dynamic_allocator+0xfd>
f0120289:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012028c:	8b 00                	mov    (%eax),%eax
f012028e:	eb 05                	jmp    f0120295 <initialize_dynamic_allocator+0x102>
f0120290:	b8 00 00 00 00       	mov    $0x0,%eax
f0120295:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f012029a:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f012029f:	85 c0                	test   %eax,%eax
f01202a1:	0f 85 55 ff ff ff    	jne    f01201fc <initialize_dynamic_allocator+0x69>
f01202a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01202ab:	0f 85 4b ff ff ff    	jne    f01201fc <initialize_dynamic_allocator+0x69>
     {
        LIST_REMOVE(&freeBlocksList,element);
     }

    // Create the BEG Block
    struct Block_Start_End* beg_block = (struct Block_Start_End*) daStart;
f01202b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01202b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    beg_block->info = 1;
f01202b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202ba:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    // Create the END Block
    end_block = (struct Block_Start_End*) (end_add);
f01202c0:	a1 14 da 6b f0       	mov    0xf06bda14,%eax
f01202c5:	a3 50 d8 6b f0       	mov    %eax,0xf06bd850
    end_block->info = 1;
f01202ca:	a1 50 d8 6b f0       	mov    0xf06bd850,%eax
f01202cf:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    // Create the first free block
    struct BlockElement* first_free_block = (struct BlockElement*)(daStart + 2*sizeof(struct Block_Start_End));
f01202d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01202d8:	83 c0 08             	add    $0x8,%eax
f01202db:	89 45 ec             	mov    %eax,-0x14(%ebp)


    //Assigning the Heap's Header/Footer values
    *(uint32*)((char*)daStart + 4 /*4 Byte*/) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01202de:	8b 45 08             	mov    0x8(%ebp),%eax
f01202e1:	83 c0 04             	add    $0x4,%eax
f01202e4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01202e7:	83 ea 08             	sub    $0x8,%edx
f01202ea:	89 10                	mov    %edx,(%eax)
    *(uint32*)((char*)daStart + initSizeOfAllocatedSpace - 8) = initSizeOfAllocatedSpace - 2 * sizeof(struct Block_Start_End) /*Heap's header/footer*/;
f01202ec:	8b 55 0c             	mov    0xc(%ebp),%edx
f01202ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01202f2:	01 d0                	add    %edx,%eax
f01202f4:	83 e8 08             	sub    $0x8,%eax
f01202f7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01202fa:	83 ea 08             	sub    $0x8,%edx
f01202fd:	89 10                	mov    %edx,(%eax)

    // Initialize links to the END block
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
f01202ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120302:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   first_free_block->prev_next_info.le_prev = NULL;
f0120308:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012030b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
f0120312:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120316:	75 17                	jne    f012032f <initialize_dynamic_allocator+0x19c>
f0120318:	83 ec 04             	sub    $0x4,%esp
f012031b:	68 30 0e 13 f0       	push   $0xf0130e30
f0120320:	68 90 00 00 00       	push   $0x90
f0120325:	68 15 0e 13 f0       	push   $0xf0130e15
f012032a:	e8 0a 00 fe ff       	call   f0100339 <_panic>
f012032f:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0120335:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120338:	89 10                	mov    %edx,(%eax)
f012033a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012033d:	8b 00                	mov    (%eax),%eax
f012033f:	85 c0                	test   %eax,%eax
f0120341:	74 0d                	je     f0120350 <initialize_dynamic_allocator+0x1bd>
f0120343:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120348:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012034b:	89 50 04             	mov    %edx,0x4(%eax)
f012034e:	eb 08                	jmp    f0120358 <initialize_dynamic_allocator+0x1c5>
f0120350:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120353:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120358:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012035b:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120360:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120363:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012036a:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012036f:	40                   	inc    %eax
f0120370:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0120375:	eb 07                	jmp    f012037e <initialize_dynamic_allocator+0x1eb>
        //DON'T CHANGE THESE LINES==========================================================
        //==================================================================================
        {
            if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
            if (initSizeOfAllocatedSpace == 0)
                return ;
f0120377:	90                   	nop
f0120378:	eb 04                	jmp    f012037e <initialize_dynamic_allocator+0x1eb>
        //COMMENT THE FOLLOWING LINE BEFORE START CODING
        //panic("initialize_dynamic_allocator is not implemented yet");

    // Check for bounds
    if ((daStart + initSizeOfAllocatedSpace) > KERNEL_HEAP_MAX)
        return;
f012037a:	90                   	nop
f012037b:	eb 01                	jmp    f012037e <initialize_dynamic_allocator+0x1eb>
    if(daStart < USER_HEAP_START)
        return;
f012037d:	90                   	nop
   first_free_block->prev_next_info.le_next = NULL; // Link to the END block
   first_free_block->prev_next_info.le_prev = NULL;

    // Link the first free block into the free block list
    LIST_INSERT_HEAD(&freeBlocksList , first_free_block);
}
f012037e:	c9                   	leave  
f012037f:	c3                   	ret    

f0120380 <set_block_data>:

//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0120380:	55                   	push   %ebp
f0120381:	89 e5                	mov    %esp,%ebp
   //TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
   //COMMENT THE FOLLOWING LINE BEFORE START CODING
   //panic("set_block_data is not implemented yet");
   //Your Code is Here...

	totalSize = totalSize|isAllocated;
f0120383:	8b 45 10             	mov    0x10(%ebp),%eax
f0120386:	09 45 0c             	or     %eax,0xc(%ebp)
   *HEADER(va) = totalSize;
f0120389:	8b 45 08             	mov    0x8(%ebp),%eax
f012038c:	8d 50 fc             	lea    -0x4(%eax),%edx
f012038f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120392:	89 02                	mov    %eax,(%edx)
   *FOOTER(va) = totalSize;
f0120394:	8b 45 08             	mov    0x8(%ebp),%eax
f0120397:	83 e8 04             	sub    $0x4,%eax
f012039a:	8b 00                	mov    (%eax),%eax
f012039c:	83 e0 fe             	and    $0xfffffffe,%eax
f012039f:	8d 50 f8             	lea    -0x8(%eax),%edx
f01203a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01203a5:	01 c2                	add    %eax,%edx
f01203a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203aa:	89 02                	mov    %eax,(%edx)
}
f01203ac:	90                   	nop
f01203ad:	5d                   	pop    %ebp
f01203ae:	c3                   	ret    

f01203af <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f01203af:	55                   	push   %ebp
f01203b0:	89 e5                	mov    %esp,%ebp
f01203b2:	83 ec 58             	sub    $0x58,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f01203b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01203b8:	83 e0 01             	and    $0x1,%eax
f01203bb:	85 c0                	test   %eax,%eax
f01203bd:	74 03                	je     f01203c2 <alloc_block_FF+0x13>
f01203bf:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f01203c2:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f01203c6:	77 07                	ja     f01203cf <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f01203c8:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f01203cf:	a1 74 d0 6b f0       	mov    0xf06bd074,%eax
f01203d4:	85 c0                	test   %eax,%eax
f01203d6:	75 73                	jne    f012044b <alloc_block_FF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f01203d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01203db:	83 c0 10             	add    $0x10,%eax
f01203de:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f01203e1:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f01203e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01203eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01203ee:	01 d0                	add    %edx,%eax
f01203f0:	48                   	dec    %eax
f01203f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01203f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01203f7:	ba 00 00 00 00       	mov    $0x0,%edx
f01203fc:	f7 75 ec             	divl   -0x14(%ebp)
f01203ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120402:	29 d0                	sub    %edx,%eax
f0120404:	c1 e8 0c             	shr    $0xc,%eax
f0120407:	83 ec 0c             	sub    $0xc,%esp
f012040a:	50                   	push   %eax
f012040b:	e8 a6 8c fe ff       	call   f01090b6 <sbrk>
f0120410:	83 c4 10             	add    $0x10,%esp
f0120413:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0120416:	83 ec 0c             	sub    $0xc,%esp
f0120419:	6a 00                	push   $0x0
f012041b:	e8 96 8c fe ff       	call   f01090b6 <sbrk>
f0120420:	83 c4 10             	add    $0x10,%esp
f0120423:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0120426:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120429:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f012042c:	83 ec 08             	sub    $0x8,%esp
f012042f:	50                   	push   %eax
f0120430:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120433:	e8 5b fd ff ff       	call   f0120193 <initialize_dynamic_allocator>
f0120438:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f012043b:	83 ec 0c             	sub    $0xc,%esp
f012043e:	68 53 0e 13 f0       	push   $0xf0130e53
f0120443:	e8 43 0b fe ff       	call   f0100f8b <cprintf>
f0120448:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
//	panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	 if (size == 0) {
f012044b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012044f:	75 0a                	jne    f012045b <alloc_block_FF+0xac>
	        return NULL;
f0120451:	b8 00 00 00 00       	mov    $0x0,%eax
f0120456:	e9 0e 04 00 00       	jmp    f0120869 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
f012045b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    LIST_FOREACH(blk, &freeBlocksList) {
f0120462:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120467:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012046a:	e9 f3 02 00 00       	jmp    f0120762 <alloc_block_FF+0x3b3>
	        void *va = (void *)blk;
f012046f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120472:	89 45 bc             	mov    %eax,-0x44(%ebp)
	        uint32 blk_size = get_block_size(va);
f0120475:	83 ec 0c             	sub    $0xc,%esp
f0120478:	ff 75 bc             	pushl  -0x44(%ebp)
f012047b:	e8 af fb ff ff       	call   f012002f <get_block_size>
f0120480:	83 c4 10             	add    $0x10,%esp
f0120483:	89 45 b8             	mov    %eax,-0x48(%ebp)

	        if(blk_size >= size + 2 * sizeof(uint32)) {
f0120486:	8b 45 08             	mov    0x8(%ebp),%eax
f0120489:	83 c0 08             	add    $0x8,%eax
f012048c:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f012048f:	0f 87 c5 02 00 00    	ja     f012075a <alloc_block_FF+0x3ab>
	            if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120495:	8b 45 08             	mov    0x8(%ebp),%eax
f0120498:	83 c0 18             	add    $0x18,%eax
f012049b:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f012049e:	0f 87 19 02 00 00    	ja     f01206bd <alloc_block_FF+0x30e>
	            {

				uint32 remaining_size = blk_size - size - 2 * sizeof(uint32);
f01204a4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01204a7:	2b 45 08             	sub    0x8(%ebp),%eax
f01204aa:	83 e8 08             	sub    $0x8,%eax
f01204ad:	89 45 b4             	mov    %eax,-0x4c(%ebp)
				void *new_block_va = (void *)((char *)va + size + 2 * sizeof(uint32));
f01204b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01204b3:	8d 50 08             	lea    0x8(%eax),%edx
f01204b6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01204b9:	01 d0                	add    %edx,%eax
f01204bb:	89 45 b0             	mov    %eax,-0x50(%ebp)
				set_block_data(va, size + 2 * sizeof(uint32), 1);
f01204be:	8b 45 08             	mov    0x8(%ebp),%eax
f01204c1:	83 c0 08             	add    $0x8,%eax
f01204c4:	83 ec 04             	sub    $0x4,%esp
f01204c7:	6a 01                	push   $0x1
f01204c9:	50                   	push   %eax
f01204ca:	ff 75 bc             	pushl  -0x44(%ebp)
f01204cd:	e8 ae fe ff ff       	call   f0120380 <set_block_data>
f01204d2:	83 c4 10             	add    $0x10,%esp

				if (LIST_PREV(blk)==NULL)
f01204d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204d8:	8b 40 04             	mov    0x4(%eax),%eax
f01204db:	85 c0                	test   %eax,%eax
f01204dd:	75 68                	jne    f0120547 <alloc_block_FF+0x198>
				{
					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f01204df:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f01204e3:	75 17                	jne    f01204fc <alloc_block_FF+0x14d>
f01204e5:	83 ec 04             	sub    $0x4,%esp
f01204e8:	68 30 0e 13 f0       	push   $0xf0130e30
f01204ed:	68 d7 00 00 00       	push   $0xd7
f01204f2:	68 15 0e 13 f0       	push   $0xf0130e15
f01204f7:	e8 3d fe fd ff       	call   f0100339 <_panic>
f01204fc:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0120502:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120505:	89 10                	mov    %edx,(%eax)
f0120507:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012050a:	8b 00                	mov    (%eax),%eax
f012050c:	85 c0                	test   %eax,%eax
f012050e:	74 0d                	je     f012051d <alloc_block_FF+0x16e>
f0120510:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120515:	8b 55 b0             	mov    -0x50(%ebp),%edx
f0120518:	89 50 04             	mov    %edx,0x4(%eax)
f012051b:	eb 08                	jmp    f0120525 <alloc_block_FF+0x176>
f012051d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120520:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120525:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120528:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012052d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120530:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120537:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012053c:	40                   	inc    %eax
f012053d:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0120542:	e9 dc 00 00 00       	jmp    f0120623 <alloc_block_FF+0x274>
				}
				else if (LIST_NEXT(blk)==NULL)
f0120547:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012054a:	8b 00                	mov    (%eax),%eax
f012054c:	85 c0                	test   %eax,%eax
f012054e:	75 65                	jne    f01205b5 <alloc_block_FF+0x206>
				{
					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120550:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f0120554:	75 17                	jne    f012056d <alloc_block_FF+0x1be>
f0120556:	83 ec 04             	sub    $0x4,%esp
f0120559:	68 64 0e 13 f0       	push   $0xf0130e64
f012055e:	68 db 00 00 00       	push   $0xdb
f0120563:	68 15 0e 13 f0       	push   $0xf0130e15
f0120568:	e8 cc fd fd ff       	call   f0100339 <_panic>
f012056d:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f0120573:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120576:	89 50 04             	mov    %edx,0x4(%eax)
f0120579:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012057c:	8b 40 04             	mov    0x4(%eax),%eax
f012057f:	85 c0                	test   %eax,%eax
f0120581:	74 0c                	je     f012058f <alloc_block_FF+0x1e0>
f0120583:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f0120588:	8b 55 b0             	mov    -0x50(%ebp),%edx
f012058b:	89 10                	mov    %edx,(%eax)
f012058d:	eb 08                	jmp    f0120597 <alloc_block_FF+0x1e8>
f012058f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120592:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120597:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012059a:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012059f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01205a8:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01205ad:	40                   	inc    %eax
f01205ae:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01205b3:	eb 6e                	jmp    f0120623 <alloc_block_FF+0x274>
				}
				else
				{
					LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement*)new_block_va);
f01205b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01205b9:	74 06                	je     f01205c1 <alloc_block_FF+0x212>
f01205bb:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
f01205bf:	75 17                	jne    f01205d8 <alloc_block_FF+0x229>
f01205c1:	83 ec 04             	sub    $0x4,%esp
f01205c4:	68 88 0e 13 f0       	push   $0xf0130e88
f01205c9:	68 df 00 00 00       	push   $0xdf
f01205ce:	68 15 0e 13 f0       	push   $0xf0130e15
f01205d3:	e8 61 fd fd ff       	call   f0100339 <_panic>
f01205d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01205db:	8b 10                	mov    (%eax),%edx
f01205dd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205e0:	89 10                	mov    %edx,(%eax)
f01205e2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01205e5:	8b 00                	mov    (%eax),%eax
f01205e7:	85 c0                	test   %eax,%eax
f01205e9:	74 0b                	je     f01205f6 <alloc_block_FF+0x247>
f01205eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01205ee:	8b 00                	mov    (%eax),%eax
f01205f0:	8b 55 b0             	mov    -0x50(%ebp),%edx
f01205f3:	89 50 04             	mov    %edx,0x4(%eax)
f01205f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01205f9:	8b 55 b0             	mov    -0x50(%ebp),%edx
f01205fc:	89 10                	mov    %edx,(%eax)
f01205fe:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120601:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120604:	89 50 04             	mov    %edx,0x4(%eax)
f0120607:	8b 45 b0             	mov    -0x50(%ebp),%eax
f012060a:	8b 00                	mov    (%eax),%eax
f012060c:	85 c0                	test   %eax,%eax
f012060e:	75 08                	jne    f0120618 <alloc_block_FF+0x269>
f0120610:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120613:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120618:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012061d:	40                   	inc    %eax
f012061e:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				}
				LIST_REMOVE(&freeBlocksList, blk);
f0120623:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120627:	75 17                	jne    f0120640 <alloc_block_FF+0x291>
f0120629:	83 ec 04             	sub    $0x4,%esp
f012062c:	68 f7 0d 13 f0       	push   $0xf0130df7
f0120631:	68 e1 00 00 00       	push   $0xe1
f0120636:	68 15 0e 13 f0       	push   $0xf0130e15
f012063b:	e8 f9 fc fd ff       	call   f0100339 <_panic>
f0120640:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120643:	8b 00                	mov    (%eax),%eax
f0120645:	85 c0                	test   %eax,%eax
f0120647:	74 10                	je     f0120659 <alloc_block_FF+0x2aa>
f0120649:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012064c:	8b 00                	mov    (%eax),%eax
f012064e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120651:	8b 52 04             	mov    0x4(%edx),%edx
f0120654:	89 50 04             	mov    %edx,0x4(%eax)
f0120657:	eb 0b                	jmp    f0120664 <alloc_block_FF+0x2b5>
f0120659:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012065c:	8b 40 04             	mov    0x4(%eax),%eax
f012065f:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120664:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120667:	8b 40 04             	mov    0x4(%eax),%eax
f012066a:	85 c0                	test   %eax,%eax
f012066c:	74 0f                	je     f012067d <alloc_block_FF+0x2ce>
f012066e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120671:	8b 40 04             	mov    0x4(%eax),%eax
f0120674:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120677:	8b 12                	mov    (%edx),%edx
f0120679:	89 10                	mov    %edx,(%eax)
f012067b:	eb 0a                	jmp    f0120687 <alloc_block_FF+0x2d8>
f012067d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120680:	8b 00                	mov    (%eax),%eax
f0120682:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120687:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012068a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120690:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120693:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012069a:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012069f:	48                   	dec    %eax
f01206a0:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				set_block_data(new_block_va, remaining_size, 0);
f01206a5:	83 ec 04             	sub    $0x4,%esp
f01206a8:	6a 00                	push   $0x0
f01206aa:	ff 75 b4             	pushl  -0x4c(%ebp)
f01206ad:	ff 75 b0             	pushl  -0x50(%ebp)
f01206b0:	e8 cb fc ff ff       	call   f0120380 <set_block_data>
f01206b5:	83 c4 10             	add    $0x10,%esp
f01206b8:	e9 95 00 00 00       	jmp    f0120752 <alloc_block_FF+0x3a3>
	            }
	            else
	            {

	            	set_block_data(va, blk_size, 1);
f01206bd:	83 ec 04             	sub    $0x4,%esp
f01206c0:	6a 01                	push   $0x1
f01206c2:	ff 75 b8             	pushl  -0x48(%ebp)
f01206c5:	ff 75 bc             	pushl  -0x44(%ebp)
f01206c8:	e8 b3 fc ff ff       	call   f0120380 <set_block_data>
f01206cd:	83 c4 10             	add    $0x10,%esp
	            	LIST_REMOVE(&freeBlocksList,blk);
f01206d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01206d4:	75 17                	jne    f01206ed <alloc_block_FF+0x33e>
f01206d6:	83 ec 04             	sub    $0x4,%esp
f01206d9:	68 f7 0d 13 f0       	push   $0xf0130df7
f01206de:	68 e8 00 00 00       	push   $0xe8
f01206e3:	68 15 0e 13 f0       	push   $0xf0130e15
f01206e8:	e8 4c fc fd ff       	call   f0100339 <_panic>
f01206ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206f0:	8b 00                	mov    (%eax),%eax
f01206f2:	85 c0                	test   %eax,%eax
f01206f4:	74 10                	je     f0120706 <alloc_block_FF+0x357>
f01206f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01206f9:	8b 00                	mov    (%eax),%eax
f01206fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01206fe:	8b 52 04             	mov    0x4(%edx),%edx
f0120701:	89 50 04             	mov    %edx,0x4(%eax)
f0120704:	eb 0b                	jmp    f0120711 <alloc_block_FF+0x362>
f0120706:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120709:	8b 40 04             	mov    0x4(%eax),%eax
f012070c:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120711:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120714:	8b 40 04             	mov    0x4(%eax),%eax
f0120717:	85 c0                	test   %eax,%eax
f0120719:	74 0f                	je     f012072a <alloc_block_FF+0x37b>
f012071b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012071e:	8b 40 04             	mov    0x4(%eax),%eax
f0120721:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120724:	8b 12                	mov    (%edx),%edx
f0120726:	89 10                	mov    %edx,(%eax)
f0120728:	eb 0a                	jmp    f0120734 <alloc_block_FF+0x385>
f012072a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012072d:	8b 00                	mov    (%eax),%eax
f012072f:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120734:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120737:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012073d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120740:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120747:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012074c:	48                   	dec    %eax
f012074d:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
	            }
	            return va;
f0120752:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120755:	e9 0f 01 00 00       	jmp    f0120869 <alloc_block_FF+0x4ba>
	    }
	// cprintf("size is %d \n",size);


	    struct BlockElement *blk = NULL;
	    LIST_FOREACH(blk, &freeBlocksList) {
f012075a:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f012075f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120762:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120766:	74 07                	je     f012076f <alloc_block_FF+0x3c0>
f0120768:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012076b:	8b 00                	mov    (%eax),%eax
f012076d:	eb 05                	jmp    f0120774 <alloc_block_FF+0x3c5>
f012076f:	b8 00 00 00 00       	mov    $0x0,%eax
f0120774:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f0120779:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f012077e:	85 c0                	test   %eax,%eax
f0120780:	0f 85 e9 fc ff ff    	jne    f012046f <alloc_block_FF+0xc0>
f0120786:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012078a:	0f 85 df fc ff ff    	jne    f012046f <alloc_block_FF+0xc0>
	            	LIST_REMOVE(&freeBlocksList,blk);
	            }
	            return va;
	        }
	    }
	    uint32 required_size = size + 2 * sizeof(uint32);
f0120790:	8b 45 08             	mov    0x8(%ebp),%eax
f0120793:	83 c0 08             	add    $0x8,%eax
f0120796:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120799:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01207a0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01207a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01207a6:	01 d0                	add    %edx,%eax
f01207a8:	48                   	dec    %eax
f01207a9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01207ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207af:	ba 00 00 00 00       	mov    $0x0,%edx
f01207b4:	f7 75 d8             	divl   -0x28(%ebp)
f01207b7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207ba:	29 d0                	sub    %edx,%eax
f01207bc:	c1 e8 0c             	shr    $0xc,%eax
f01207bf:	83 ec 0c             	sub    $0xc,%esp
f01207c2:	50                   	push   %eax
f01207c3:	e8 ee 88 fe ff       	call   f01090b6 <sbrk>
f01207c8:	83 c4 10             	add    $0x10,%esp
f01207cb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (new_mem == (void *)-1) {
f01207ce:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f01207d2:	75 0a                	jne    f01207de <alloc_block_FF+0x42f>
			return NULL; // Allocation failed
f01207d4:	b8 00 00 00 00       	mov    $0x0,%eax
f01207d9:	e9 8b 00 00 00       	jmp    f0120869 <alloc_block_FF+0x4ba>
		}
		else {
			end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f01207de:	c7 45 cc 00 10 00 00 	movl   $0x1000,-0x34(%ebp)
f01207e5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01207e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01207eb:	01 d0                	add    %edx,%eax
f01207ed:	48                   	dec    %eax
f01207ee:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01207f1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01207f4:	ba 00 00 00 00       	mov    $0x0,%edx
f01207f9:	f7 75 cc             	divl   -0x34(%ebp)
f01207fc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01207ff:	29 d0                	sub    %edx,%eax
f0120801:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120804:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120807:	01 d0                	add    %edx,%eax
f0120809:	a3 50 d8 6b f0       	mov    %eax,0xf06bd850
			end_block->info = 1;
f012080e:	a1 50 d8 6b f0       	mov    0xf06bd850,%eax
f0120813:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120819:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120820:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0120823:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120826:	01 d0                	add    %edx,%eax
f0120828:	48                   	dec    %eax
f0120829:	89 45 c0             	mov    %eax,-0x40(%ebp)
f012082c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012082f:	ba 00 00 00 00       	mov    $0x0,%edx
f0120834:	f7 75 c4             	divl   -0x3c(%ebp)
f0120837:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012083a:	29 d0                	sub    %edx,%eax
f012083c:	83 ec 04             	sub    $0x4,%esp
f012083f:	6a 01                	push   $0x1
f0120841:	50                   	push   %eax
f0120842:	ff 75 d0             	pushl  -0x30(%ebp)
f0120845:	e8 36 fb ff ff       	call   f0120380 <set_block_data>
f012084a:	83 c4 10             	add    $0x10,%esp
		free_block(new_mem);
f012084d:	83 ec 0c             	sub    $0xc,%esp
f0120850:	ff 75 d0             	pushl  -0x30(%ebp)
f0120853:	e8 1b 0a 00 00       	call   f0121273 <free_block>
f0120858:	83 c4 10             	add    $0x10,%esp
		return alloc_block_FF(size);
f012085b:	83 ec 0c             	sub    $0xc,%esp
f012085e:	ff 75 08             	pushl  0x8(%ebp)
f0120861:	e8 49 fb ff ff       	call   f01203af <alloc_block_FF>
f0120866:	83 c4 10             	add    $0x10,%esp
		}
		return new_mem;
}
f0120869:	c9                   	leave  
f012086a:	c3                   	ret    

f012086b <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f012086b:	55                   	push   %ebp
f012086c:	89 e5                	mov    %esp,%ebp
f012086e:	83 ec 68             	sub    $0x68,%esp
	//Your Code is Here...
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0120871:	8b 45 08             	mov    0x8(%ebp),%eax
f0120874:	83 e0 01             	and    $0x1,%eax
f0120877:	85 c0                	test   %eax,%eax
f0120879:	74 03                	je     f012087e <alloc_block_BF+0x13>
f012087b:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f012087e:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0120882:	77 07                	ja     f012088b <alloc_block_BF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0120884:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f012088b:	a1 74 d0 6b f0       	mov    0xf06bd074,%eax
f0120890:	85 c0                	test   %eax,%eax
f0120892:	75 73                	jne    f0120907 <alloc_block_BF+0x9c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0120894:	8b 45 08             	mov    0x8(%ebp),%eax
f0120897:	83 c0 10             	add    $0x10,%eax
f012089a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f012089d:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f01208a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01208a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01208aa:	01 d0                	add    %edx,%eax
f01208ac:	48                   	dec    %eax
f01208ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01208b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01208b3:	ba 00 00 00 00       	mov    $0x0,%edx
f01208b8:	f7 75 e0             	divl   -0x20(%ebp)
f01208bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01208be:	29 d0                	sub    %edx,%eax
f01208c0:	c1 e8 0c             	shr    $0xc,%eax
f01208c3:	83 ec 0c             	sub    $0xc,%esp
f01208c6:	50                   	push   %eax
f01208c7:	e8 ea 87 fe ff       	call   f01090b6 <sbrk>
f01208cc:	83 c4 10             	add    $0x10,%esp
f01208cf:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f01208d2:	83 ec 0c             	sub    $0xc,%esp
f01208d5:	6a 00                	push   $0x0
f01208d7:	e8 da 87 fe ff       	call   f01090b6 <sbrk>
f01208dc:	83 c4 10             	add    $0x10,%esp
f01208df:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f01208e2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01208e5:	2b 45 d8             	sub    -0x28(%ebp),%eax
f01208e8:	83 ec 08             	sub    $0x8,%esp
f01208eb:	50                   	push   %eax
f01208ec:	ff 75 d8             	pushl  -0x28(%ebp)
f01208ef:	e8 9f f8 ff ff       	call   f0120193 <initialize_dynamic_allocator>
f01208f4:	83 c4 10             	add    $0x10,%esp
			cprintf("Initialized \n");
f01208f7:	83 ec 0c             	sub    $0xc,%esp
f01208fa:	68 53 0e 13 f0       	push   $0xf0130e53
f01208ff:	e8 87 06 fe ff       	call   f0100f8b <cprintf>
f0120904:	83 c4 10             	add    $0x10,%esp
		}
	}
	//==================================================================================
	//==================================================================================

	struct BlockElement *blk = NULL;
f0120907:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	void *best_va=NULL;
f012090e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
f0120915:	c7 45 ec f8 ef ff ff 	movl   $0xffffeff8,-0x14(%ebp)
	bool internal = 0;
f012091c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	LIST_FOREACH(blk, &freeBlocksList) {
f0120923:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120928:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012092b:	e9 1d 01 00 00       	jmp    f0120a4d <alloc_block_BF+0x1e2>
		void *va = (void *)blk;
f0120930:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120933:	89 45 a8             	mov    %eax,-0x58(%ebp)
		uint32 blk_size = get_block_size(va);
f0120936:	83 ec 0c             	sub    $0xc,%esp
f0120939:	ff 75 a8             	pushl  -0x58(%ebp)
f012093c:	e8 ee f6 ff ff       	call   f012002f <get_block_size>
f0120941:	83 c4 10             	add    $0x10,%esp
f0120944:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (blk_size>=size + 2 * sizeof(uint32))
f0120947:	8b 45 08             	mov    0x8(%ebp),%eax
f012094a:	83 c0 08             	add    $0x8,%eax
f012094d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120950:	0f 87 ef 00 00 00    	ja     f0120a45 <alloc_block_BF+0x1da>
		{
			if (blk_size >= size + DYN_ALLOC_MIN_BLOCK_SIZE + 4 * sizeof(uint32))
f0120956:	8b 45 08             	mov    0x8(%ebp),%eax
f0120959:	83 c0 18             	add    $0x18,%eax
f012095c:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f012095f:	77 1d                	ja     f012097e <alloc_block_BF+0x113>
			{
				if (best_blk_size > blk_size)
f0120961:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120964:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120967:	0f 86 d8 00 00 00    	jbe    f0120a45 <alloc_block_BF+0x1da>
				{
					best_va = va;
f012096d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120970:	89 45 f0             	mov    %eax,-0x10(%ebp)
					best_blk_size = blk_size;
f0120973:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0120976:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120979:	e9 c7 00 00 00       	jmp    f0120a45 <alloc_block_BF+0x1da>
				}
			}
			else
			{
				if (blk_size == size + 2 * sizeof(uint32)){
f012097e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120981:	83 c0 08             	add    $0x8,%eax
f0120984:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120987:	0f 85 9d 00 00 00    	jne    f0120a2a <alloc_block_BF+0x1bf>
					set_block_data(va, blk_size, 1);
f012098d:	83 ec 04             	sub    $0x4,%esp
f0120990:	6a 01                	push   $0x1
f0120992:	ff 75 a4             	pushl  -0x5c(%ebp)
f0120995:	ff 75 a8             	pushl  -0x58(%ebp)
f0120998:	e8 e3 f9 ff ff       	call   f0120380 <set_block_data>
f012099d:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,blk);
f01209a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01209a4:	75 17                	jne    f01209bd <alloc_block_BF+0x152>
f01209a6:	83 ec 04             	sub    $0x4,%esp
f01209a9:	68 f7 0d 13 f0       	push   $0xf0130df7
f01209ae:	68 2c 01 00 00       	push   $0x12c
f01209b3:	68 15 0e 13 f0       	push   $0xf0130e15
f01209b8:	e8 7c f9 fd ff       	call   f0100339 <_panic>
f01209bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209c0:	8b 00                	mov    (%eax),%eax
f01209c2:	85 c0                	test   %eax,%eax
f01209c4:	74 10                	je     f01209d6 <alloc_block_BF+0x16b>
f01209c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209c9:	8b 00                	mov    (%eax),%eax
f01209cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01209ce:	8b 52 04             	mov    0x4(%edx),%edx
f01209d1:	89 50 04             	mov    %edx,0x4(%eax)
f01209d4:	eb 0b                	jmp    f01209e1 <alloc_block_BF+0x176>
f01209d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209d9:	8b 40 04             	mov    0x4(%eax),%eax
f01209dc:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01209e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209e4:	8b 40 04             	mov    0x4(%eax),%eax
f01209e7:	85 c0                	test   %eax,%eax
f01209e9:	74 0f                	je     f01209fa <alloc_block_BF+0x18f>
f01209eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209ee:	8b 40 04             	mov    0x4(%eax),%eax
f01209f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01209f4:	8b 12                	mov    (%edx),%edx
f01209f6:	89 10                	mov    %edx,(%eax)
f01209f8:	eb 0a                	jmp    f0120a04 <alloc_block_BF+0x199>
f01209fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209fd:	8b 00                	mov    (%eax),%eax
f01209ff:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120a04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120a0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a10:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120a17:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120a1c:	48                   	dec    %eax
f0120a1d:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
					return va;
f0120a22:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120a25:	e9 24 04 00 00       	jmp    f0120e4e <alloc_block_BF+0x5e3>
				}
				else
				{
					if (best_blk_size > blk_size)
f0120a2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a2d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0120a30:	76 13                	jbe    f0120a45 <alloc_block_BF+0x1da>
					{
						internal = 1;
f0120a32:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
						best_va = va;
f0120a39:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0120a3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
						best_blk_size = blk_size;
f0120a3f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0120a42:	89 45 ec             	mov    %eax,-0x14(%ebp)

	struct BlockElement *blk = NULL;
	void *best_va=NULL;
	uint32 best_blk_size = (uint32)KERNEL_HEAP_MAX - 2 * sizeof(uint32);
	bool internal = 0;
	LIST_FOREACH(blk, &freeBlocksList) {
f0120a45:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0120a4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120a4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120a51:	74 07                	je     f0120a5a <alloc_block_BF+0x1ef>
f0120a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a56:	8b 00                	mov    (%eax),%eax
f0120a58:	eb 05                	jmp    f0120a5f <alloc_block_BF+0x1f4>
f0120a5a:	b8 00 00 00 00       	mov    $0x0,%eax
f0120a5f:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f0120a64:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0120a69:	85 c0                	test   %eax,%eax
f0120a6b:	0f 85 bf fe ff ff    	jne    f0120930 <alloc_block_BF+0xc5>
f0120a71:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120a75:	0f 85 b5 fe ff ff    	jne    f0120930 <alloc_block_BF+0xc5>
			}
		}

	}

	if (best_va !=NULL && internal ==0){
f0120a7b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120a7f:	0f 84 26 02 00 00    	je     f0120cab <alloc_block_BF+0x440>
f0120a85:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120a89:	0f 85 1c 02 00 00    	jne    f0120cab <alloc_block_BF+0x440>
		uint32 remaining_size = best_blk_size - size - 2 * sizeof(uint32);
f0120a8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a92:	2b 45 08             	sub    0x8(%ebp),%eax
f0120a95:	83 e8 08             	sub    $0x8,%eax
f0120a98:	89 45 d0             	mov    %eax,-0x30(%ebp)
		void *new_block_va = (void *)((char *)best_va + size + 2 * sizeof(uint32));
f0120a9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a9e:	8d 50 08             	lea    0x8(%eax),%edx
f0120aa1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120aa4:	01 d0                	add    %edx,%eax
f0120aa6:	89 45 cc             	mov    %eax,-0x34(%ebp)
		set_block_data(best_va, size + 2 * sizeof(uint32), 1);
f0120aa9:	8b 45 08             	mov    0x8(%ebp),%eax
f0120aac:	83 c0 08             	add    $0x8,%eax
f0120aaf:	83 ec 04             	sub    $0x4,%esp
f0120ab2:	6a 01                	push   $0x1
f0120ab4:	50                   	push   %eax
f0120ab5:	ff 75 f0             	pushl  -0x10(%ebp)
f0120ab8:	e8 c3 f8 ff ff       	call   f0120380 <set_block_data>
f0120abd:	83 c4 10             	add    $0x10,%esp

		if (LIST_PREV((struct BlockElement *)best_va)==NULL)
f0120ac0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120ac3:	8b 40 04             	mov    0x4(%eax),%eax
f0120ac6:	85 c0                	test   %eax,%eax
f0120ac8:	75 68                	jne    f0120b32 <alloc_block_BF+0x2c7>
			{

				LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120aca:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120ace:	75 17                	jne    f0120ae7 <alloc_block_BF+0x27c>
f0120ad0:	83 ec 04             	sub    $0x4,%esp
f0120ad3:	68 30 0e 13 f0       	push   $0xf0130e30
f0120ad8:	68 45 01 00 00       	push   $0x145
f0120add:	68 15 0e 13 f0       	push   $0xf0130e15
f0120ae2:	e8 52 f8 fd ff       	call   f0100339 <_panic>
f0120ae7:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0120aed:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120af0:	89 10                	mov    %edx,(%eax)
f0120af2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120af5:	8b 00                	mov    (%eax),%eax
f0120af7:	85 c0                	test   %eax,%eax
f0120af9:	74 0d                	je     f0120b08 <alloc_block_BF+0x29d>
f0120afb:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0120b00:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120b03:	89 50 04             	mov    %edx,0x4(%eax)
f0120b06:	eb 08                	jmp    f0120b10 <alloc_block_BF+0x2a5>
f0120b08:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b0b:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120b10:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b13:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120b18:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b1b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120b22:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120b27:	40                   	inc    %eax
f0120b28:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0120b2d:	e9 dc 00 00 00       	jmp    f0120c0e <alloc_block_BF+0x3a3>
			}
			else if (LIST_NEXT((struct BlockElement *)best_va)==NULL)
f0120b32:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b35:	8b 00                	mov    (%eax),%eax
f0120b37:	85 c0                	test   %eax,%eax
f0120b39:	75 65                	jne    f0120ba0 <alloc_block_BF+0x335>
			{

				LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement*)new_block_va);
f0120b3b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120b3f:	75 17                	jne    f0120b58 <alloc_block_BF+0x2ed>
f0120b41:	83 ec 04             	sub    $0x4,%esp
f0120b44:	68 64 0e 13 f0       	push   $0xf0130e64
f0120b49:	68 4a 01 00 00       	push   $0x14a
f0120b4e:	68 15 0e 13 f0       	push   $0xf0130e15
f0120b53:	e8 e1 f7 fd ff       	call   f0100339 <_panic>
f0120b58:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f0120b5e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b61:	89 50 04             	mov    %edx,0x4(%eax)
f0120b64:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b67:	8b 40 04             	mov    0x4(%eax),%eax
f0120b6a:	85 c0                	test   %eax,%eax
f0120b6c:	74 0c                	je     f0120b7a <alloc_block_BF+0x30f>
f0120b6e:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f0120b73:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120b76:	89 10                	mov    %edx,(%eax)
f0120b78:	eb 08                	jmp    f0120b82 <alloc_block_BF+0x317>
f0120b7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b7d:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120b82:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b85:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120b8a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120b8d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120b93:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120b98:	40                   	inc    %eax
f0120b99:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0120b9e:	eb 6e                	jmp    f0120c0e <alloc_block_BF+0x3a3>
			}
			else
			{

				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement *)best_va, (struct BlockElement*)new_block_va);
f0120ba0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120ba4:	74 06                	je     f0120bac <alloc_block_BF+0x341>
f0120ba6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0120baa:	75 17                	jne    f0120bc3 <alloc_block_BF+0x358>
f0120bac:	83 ec 04             	sub    $0x4,%esp
f0120baf:	68 88 0e 13 f0       	push   $0xf0130e88
f0120bb4:	68 4f 01 00 00       	push   $0x14f
f0120bb9:	68 15 0e 13 f0       	push   $0xf0130e15
f0120bbe:	e8 76 f7 fd ff       	call   f0100339 <_panic>
f0120bc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120bc6:	8b 10                	mov    (%eax),%edx
f0120bc8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bcb:	89 10                	mov    %edx,(%eax)
f0120bcd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bd0:	8b 00                	mov    (%eax),%eax
f0120bd2:	85 c0                	test   %eax,%eax
f0120bd4:	74 0b                	je     f0120be1 <alloc_block_BF+0x376>
f0120bd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120bd9:	8b 00                	mov    (%eax),%eax
f0120bdb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120bde:	89 50 04             	mov    %edx,0x4(%eax)
f0120be1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120be4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0120be7:	89 10                	mov    %edx,(%eax)
f0120be9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bec:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120bef:	89 50 04             	mov    %edx,0x4(%eax)
f0120bf2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bf5:	8b 00                	mov    (%eax),%eax
f0120bf7:	85 c0                	test   %eax,%eax
f0120bf9:	75 08                	jne    f0120c03 <alloc_block_BF+0x398>
f0120bfb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120bfe:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120c03:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120c08:	40                   	inc    %eax
f0120c09:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
			}
			LIST_REMOVE(&freeBlocksList, (struct BlockElement *)best_va);
f0120c0e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120c12:	75 17                	jne    f0120c2b <alloc_block_BF+0x3c0>
f0120c14:	83 ec 04             	sub    $0x4,%esp
f0120c17:	68 f7 0d 13 f0       	push   $0xf0130df7
f0120c1c:	68 51 01 00 00       	push   $0x151
f0120c21:	68 15 0e 13 f0       	push   $0xf0130e15
f0120c26:	e8 0e f7 fd ff       	call   f0100339 <_panic>
f0120c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c2e:	8b 00                	mov    (%eax),%eax
f0120c30:	85 c0                	test   %eax,%eax
f0120c32:	74 10                	je     f0120c44 <alloc_block_BF+0x3d9>
f0120c34:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c37:	8b 00                	mov    (%eax),%eax
f0120c39:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120c3c:	8b 52 04             	mov    0x4(%edx),%edx
f0120c3f:	89 50 04             	mov    %edx,0x4(%eax)
f0120c42:	eb 0b                	jmp    f0120c4f <alloc_block_BF+0x3e4>
f0120c44:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c47:	8b 40 04             	mov    0x4(%eax),%eax
f0120c4a:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c52:	8b 40 04             	mov    0x4(%eax),%eax
f0120c55:	85 c0                	test   %eax,%eax
f0120c57:	74 0f                	je     f0120c68 <alloc_block_BF+0x3fd>
f0120c59:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c5c:	8b 40 04             	mov    0x4(%eax),%eax
f0120c5f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120c62:	8b 12                	mov    (%edx),%edx
f0120c64:	89 10                	mov    %edx,(%eax)
f0120c66:	eb 0a                	jmp    f0120c72 <alloc_block_BF+0x407>
f0120c68:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c6b:	8b 00                	mov    (%eax),%eax
f0120c6d:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120c72:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120c7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c7e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120c85:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120c8a:	48                   	dec    %eax
f0120c8b:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
			set_block_data(new_block_va, remaining_size, 0);
f0120c90:	83 ec 04             	sub    $0x4,%esp
f0120c93:	6a 00                	push   $0x0
f0120c95:	ff 75 d0             	pushl  -0x30(%ebp)
f0120c98:	ff 75 cc             	pushl  -0x34(%ebp)
f0120c9b:	e8 e0 f6 ff ff       	call   f0120380 <set_block_data>
f0120ca0:	83 c4 10             	add    $0x10,%esp
			return best_va;
f0120ca3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120ca6:	e9 a3 01 00 00       	jmp    f0120e4e <alloc_block_BF+0x5e3>
	}
	else if(internal == 1)
f0120cab:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0120caf:	0f 85 9d 00 00 00    	jne    f0120d52 <alloc_block_BF+0x4e7>
	{
		set_block_data(best_va, best_blk_size, 1);
f0120cb5:	83 ec 04             	sub    $0x4,%esp
f0120cb8:	6a 01                	push   $0x1
f0120cba:	ff 75 ec             	pushl  -0x14(%ebp)
f0120cbd:	ff 75 f0             	pushl  -0x10(%ebp)
f0120cc0:	e8 bb f6 ff ff       	call   f0120380 <set_block_data>
f0120cc5:	83 c4 10             	add    $0x10,%esp
		LIST_REMOVE(&freeBlocksList,(struct BlockElement *)best_va);
f0120cc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120ccc:	75 17                	jne    f0120ce5 <alloc_block_BF+0x47a>
f0120cce:	83 ec 04             	sub    $0x4,%esp
f0120cd1:	68 f7 0d 13 f0       	push   $0xf0130df7
f0120cd6:	68 58 01 00 00       	push   $0x158
f0120cdb:	68 15 0e 13 f0       	push   $0xf0130e15
f0120ce0:	e8 54 f6 fd ff       	call   f0100339 <_panic>
f0120ce5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120ce8:	8b 00                	mov    (%eax),%eax
f0120cea:	85 c0                	test   %eax,%eax
f0120cec:	74 10                	je     f0120cfe <alloc_block_BF+0x493>
f0120cee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cf1:	8b 00                	mov    (%eax),%eax
f0120cf3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120cf6:	8b 52 04             	mov    0x4(%edx),%edx
f0120cf9:	89 50 04             	mov    %edx,0x4(%eax)
f0120cfc:	eb 0b                	jmp    f0120d09 <alloc_block_BF+0x49e>
f0120cfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d01:	8b 40 04             	mov    0x4(%eax),%eax
f0120d04:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120d09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d0c:	8b 40 04             	mov    0x4(%eax),%eax
f0120d0f:	85 c0                	test   %eax,%eax
f0120d11:	74 0f                	je     f0120d22 <alloc_block_BF+0x4b7>
f0120d13:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d16:	8b 40 04             	mov    0x4(%eax),%eax
f0120d19:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120d1c:	8b 12                	mov    (%edx),%edx
f0120d1e:	89 10                	mov    %edx,(%eax)
f0120d20:	eb 0a                	jmp    f0120d2c <alloc_block_BF+0x4c1>
f0120d22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d25:	8b 00                	mov    (%eax),%eax
f0120d27:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120d2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d2f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120d35:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d38:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120d3f:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120d44:	48                   	dec    %eax
f0120d45:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		return best_va;
f0120d4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120d4d:	e9 fc 00 00 00       	jmp    f0120e4e <alloc_block_BF+0x5e3>
	}
	uint32 required_size = size + 2 * sizeof(uint32);
f0120d52:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d55:	83 c0 08             	add    $0x8,%eax
f0120d58:	89 45 c8             	mov    %eax,-0x38(%ebp)
		    void *new_mem = sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f0120d5b:	c7 45 c4 00 10 00 00 	movl   $0x1000,-0x3c(%ebp)
f0120d62:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120d65:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120d68:	01 d0                	add    %edx,%eax
f0120d6a:	48                   	dec    %eax
f0120d6b:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0120d6e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120d71:	ba 00 00 00 00       	mov    $0x0,%edx
f0120d76:	f7 75 c4             	divl   -0x3c(%ebp)
f0120d79:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120d7c:	29 d0                	sub    %edx,%eax
f0120d7e:	c1 e8 0c             	shr    $0xc,%eax
f0120d81:	83 ec 0c             	sub    $0xc,%esp
f0120d84:	50                   	push   %eax
f0120d85:	e8 2c 83 fe ff       	call   f01090b6 <sbrk>
f0120d8a:	83 c4 10             	add    $0x10,%esp
f0120d8d:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if (new_mem == (void *)-1) {
f0120d90:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0120d94:	75 0a                	jne    f0120da0 <alloc_block_BF+0x535>
				return NULL; // Allocation failed
f0120d96:	b8 00 00 00 00       	mov    $0x0,%eax
f0120d9b:	e9 ae 00 00 00       	jmp    f0120e4e <alloc_block_BF+0x5e3>
			}
			else {
				end_block = (struct Block_Start_End*) (new_mem + ROUNDUP(required_size, PAGE_SIZE)-sizeof(int));
f0120da0:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f0120da7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120daa:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0120dad:	01 d0                	add    %edx,%eax
f0120daf:	48                   	dec    %eax
f0120db0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0120db3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0120db6:	ba 00 00 00 00       	mov    $0x0,%edx
f0120dbb:	f7 75 b8             	divl   -0x48(%ebp)
f0120dbe:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0120dc1:	29 d0                	sub    %edx,%eax
f0120dc3:	8d 50 fc             	lea    -0x4(%eax),%edx
f0120dc6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0120dc9:	01 d0                	add    %edx,%eax
f0120dcb:	a3 50 d8 6b f0       	mov    %eax,0xf06bd850
				end_block->info = 1;
f0120dd0:	a1 50 d8 6b f0       	mov    0xf06bd850,%eax
f0120dd5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
				cprintf("251\n");
f0120ddb:	83 ec 0c             	sub    $0xc,%esp
f0120dde:	68 bc 0e 13 f0       	push   $0xf0130ebc
f0120de3:	e8 a3 01 fe ff       	call   f0100f8b <cprintf>
f0120de8:	83 c4 10             	add    $0x10,%esp
			cprintf("address : %x\n",new_mem);
f0120deb:	83 ec 08             	sub    $0x8,%esp
f0120dee:	ff 75 bc             	pushl  -0x44(%ebp)
f0120df1:	68 c1 0e 13 f0       	push   $0xf0130ec1
f0120df6:	e8 90 01 fe ff       	call   f0100f8b <cprintf>
f0120dfb:	83 c4 10             	add    $0x10,%esp
			set_block_data(new_mem, ROUNDUP(required_size, PAGE_SIZE), 1);
f0120dfe:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f0120e05:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0120e08:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0120e0b:	01 d0                	add    %edx,%eax
f0120e0d:	48                   	dec    %eax
f0120e0e:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0120e11:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0120e14:	ba 00 00 00 00       	mov    $0x0,%edx
f0120e19:	f7 75 b0             	divl   -0x50(%ebp)
f0120e1c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0120e1f:	29 d0                	sub    %edx,%eax
f0120e21:	83 ec 04             	sub    $0x4,%esp
f0120e24:	6a 01                	push   $0x1
f0120e26:	50                   	push   %eax
f0120e27:	ff 75 bc             	pushl  -0x44(%ebp)
f0120e2a:	e8 51 f5 ff ff       	call   f0120380 <set_block_data>
f0120e2f:	83 c4 10             	add    $0x10,%esp
			free_block(new_mem);
f0120e32:	83 ec 0c             	sub    $0xc,%esp
f0120e35:	ff 75 bc             	pushl  -0x44(%ebp)
f0120e38:	e8 36 04 00 00       	call   f0121273 <free_block>
f0120e3d:	83 c4 10             	add    $0x10,%esp
			return alloc_block_BF(size);
f0120e40:	83 ec 0c             	sub    $0xc,%esp
f0120e43:	ff 75 08             	pushl  0x8(%ebp)
f0120e46:	e8 20 fa ff ff       	call   f012086b <alloc_block_BF>
f0120e4b:	83 c4 10             	add    $0x10,%esp
			}
			return new_mem;
}
f0120e4e:	c9                   	leave  
f0120e4f:	c3                   	ret    

f0120e50 <merging>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void merging(struct BlockElement *prev_block, struct BlockElement *next_block, void* va){
f0120e50:	55                   	push   %ebp
f0120e51:	89 e5                	mov    %esp,%ebp
f0120e53:	53                   	push   %ebx
f0120e54:	83 ec 24             	sub    $0x24,%esp
	bool prev_is_free = 0, next_is_free = 0;
f0120e57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0120e5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (prev_block != NULL && (char *)prev_block + get_block_size(prev_block) == (char *)va) {
f0120e65:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120e69:	74 1e                	je     f0120e89 <merging+0x39>
f0120e6b:	ff 75 08             	pushl  0x8(%ebp)
f0120e6e:	e8 bc f1 ff ff       	call   f012002f <get_block_size>
f0120e73:	83 c4 04             	add    $0x4,%esp
f0120e76:	89 c2                	mov    %eax,%edx
f0120e78:	8b 45 08             	mov    0x8(%ebp),%eax
f0120e7b:	01 d0                	add    %edx,%eax
f0120e7d:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120e80:	75 07                	jne    f0120e89 <merging+0x39>
		prev_is_free = 1;
f0120e82:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
f0120e89:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120e8d:	74 1e                	je     f0120ead <merging+0x5d>
f0120e8f:	ff 75 10             	pushl  0x10(%ebp)
f0120e92:	e8 98 f1 ff ff       	call   f012002f <get_block_size>
f0120e97:	83 c4 04             	add    $0x4,%esp
f0120e9a:	89 c2                	mov    %eax,%edx
f0120e9c:	8b 45 10             	mov    0x10(%ebp),%eax
f0120e9f:	01 d0                	add    %edx,%eax
f0120ea1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120ea4:	75 07                	jne    f0120ead <merging+0x5d>
		next_is_free = 1;
f0120ea6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	if(prev_is_free && next_is_free)
f0120ead:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120eb1:	0f 84 cc 00 00 00    	je     f0120f83 <merging+0x133>
f0120eb7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120ebb:	0f 84 c2 00 00 00    	je     f0120f83 <merging+0x133>
	{
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
f0120ec1:	ff 75 08             	pushl  0x8(%ebp)
f0120ec4:	e8 66 f1 ff ff       	call   f012002f <get_block_size>
f0120ec9:	83 c4 04             	add    $0x4,%esp
f0120ecc:	89 c3                	mov    %eax,%ebx
f0120ece:	ff 75 10             	pushl  0x10(%ebp)
f0120ed1:	e8 59 f1 ff ff       	call   f012002f <get_block_size>
f0120ed6:	83 c4 04             	add    $0x4,%esp
f0120ed9:	01 c3                	add    %eax,%ebx
f0120edb:	ff 75 0c             	pushl  0xc(%ebp)
f0120ede:	e8 4c f1 ff ff       	call   f012002f <get_block_size>
f0120ee3:	83 c4 04             	add    $0x4,%esp
f0120ee6:	01 d8                	add    %ebx,%eax
f0120ee8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0120eeb:	6a 00                	push   $0x0
f0120eed:	ff 75 ec             	pushl  -0x14(%ebp)
f0120ef0:	ff 75 08             	pushl  0x8(%ebp)
f0120ef3:	e8 88 f4 ff ff       	call   f0120380 <set_block_data>
f0120ef8:	83 c4 0c             	add    $0xc,%esp
		LIST_REMOVE(&freeBlocksList, next_block);
f0120efb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120eff:	75 17                	jne    f0120f18 <merging+0xc8>
f0120f01:	83 ec 04             	sub    $0x4,%esp
f0120f04:	68 f7 0d 13 f0       	push   $0xf0130df7
f0120f09:	68 7d 01 00 00       	push   $0x17d
f0120f0e:	68 15 0e 13 f0       	push   $0xf0130e15
f0120f13:	e8 21 f4 fd ff       	call   f0100339 <_panic>
f0120f18:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f1b:	8b 00                	mov    (%eax),%eax
f0120f1d:	85 c0                	test   %eax,%eax
f0120f1f:	74 10                	je     f0120f31 <merging+0xe1>
f0120f21:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f24:	8b 00                	mov    (%eax),%eax
f0120f26:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120f29:	8b 52 04             	mov    0x4(%edx),%edx
f0120f2c:	89 50 04             	mov    %edx,0x4(%eax)
f0120f2f:	eb 0b                	jmp    f0120f3c <merging+0xec>
f0120f31:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f34:	8b 40 04             	mov    0x4(%eax),%eax
f0120f37:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0120f3c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f3f:	8b 40 04             	mov    0x4(%eax),%eax
f0120f42:	85 c0                	test   %eax,%eax
f0120f44:	74 0f                	je     f0120f55 <merging+0x105>
f0120f46:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f49:	8b 40 04             	mov    0x4(%eax),%eax
f0120f4c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120f4f:	8b 12                	mov    (%edx),%edx
f0120f51:	89 10                	mov    %edx,(%eax)
f0120f53:	eb 0a                	jmp    f0120f5f <merging+0x10f>
f0120f55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f58:	8b 00                	mov    (%eax),%eax
f0120f5a:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0120f5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f62:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120f68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f6b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120f72:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0120f77:	48                   	dec    %eax
f0120f78:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
	}
	if (next_block != NULL && (char *)va + get_block_size(va) == (char *)next_block) {
		next_is_free = 1;
	}
	if(prev_is_free && next_is_free)
	{
f0120f7d:	90                   	nop
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120f7e:	e9 ea 02 00 00       	jmp    f012126d <merging+0x41d>
		//merge - 2 sides
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va) + get_block_size(next_block);
		set_block_data(prev_block, new_block_size, 0);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else if(prev_is_free)
f0120f83:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120f87:	74 3b                	je     f0120fc4 <merging+0x174>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
f0120f89:	83 ec 0c             	sub    $0xc,%esp
f0120f8c:	ff 75 08             	pushl  0x8(%ebp)
f0120f8f:	e8 9b f0 ff ff       	call   f012002f <get_block_size>
f0120f94:	83 c4 10             	add    $0x10,%esp
f0120f97:	89 c3                	mov    %eax,%ebx
f0120f99:	83 ec 0c             	sub    $0xc,%esp
f0120f9c:	ff 75 10             	pushl  0x10(%ebp)
f0120f9f:	e8 8b f0 ff ff       	call   f012002f <get_block_size>
f0120fa4:	83 c4 10             	add    $0x10,%esp
f0120fa7:	01 d8                	add    %ebx,%eax
f0120fa9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(prev_block, new_block_size, 0);
f0120fac:	83 ec 04             	sub    $0x4,%esp
f0120faf:	6a 00                	push   $0x0
f0120fb1:	ff 75 e8             	pushl  -0x18(%ebp)
f0120fb4:	ff 75 08             	pushl  0x8(%ebp)
f0120fb7:	e8 c4 f3 ff ff       	call   f0120380 <set_block_data>
f0120fbc:	83 c4 10             	add    $0x10,%esp
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f0120fbf:	e9 a9 02 00 00       	jmp    f012126d <merging+0x41d>
	{
		//merge - left side
		uint32 new_block_size = get_block_size(prev_block) + get_block_size(va);
		set_block_data(prev_block, new_block_size, 0);
	}
	else if(next_is_free)
f0120fc4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120fc8:	0f 84 2d 01 00 00    	je     f01210fb <merging+0x2ab>
	{
		//merge - right side

		uint32 new_block_size = get_block_size(va) + get_block_size(next_block);
f0120fce:	83 ec 0c             	sub    $0xc,%esp
f0120fd1:	ff 75 10             	pushl  0x10(%ebp)
f0120fd4:	e8 56 f0 ff ff       	call   f012002f <get_block_size>
f0120fd9:	83 c4 10             	add    $0x10,%esp
f0120fdc:	89 c3                	mov    %eax,%ebx
f0120fde:	83 ec 0c             	sub    $0xc,%esp
f0120fe1:	ff 75 0c             	pushl  0xc(%ebp)
f0120fe4:	e8 46 f0 ff ff       	call   f012002f <get_block_size>
f0120fe9:	83 c4 10             	add    $0x10,%esp
f0120fec:	01 d8                	add    %ebx,%eax
f0120fee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		set_block_data(va, new_block_size, 0);
f0120ff1:	83 ec 04             	sub    $0x4,%esp
f0120ff4:	6a 00                	push   $0x0
f0120ff6:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120ff9:	ff 75 10             	pushl  0x10(%ebp)
f0120ffc:	e8 7f f3 ff ff       	call   f0120380 <set_block_data>
f0121001:	83 c4 10             	add    $0x10,%esp

		struct BlockElement *va_block = (struct BlockElement *)va;
f0121004:	8b 45 10             	mov    0x10(%ebp),%eax
f0121007:	89 45 e0             	mov    %eax,-0x20(%ebp)
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
f012100a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012100e:	74 06                	je     f0121016 <merging+0x1c6>
f0121010:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121014:	75 17                	jne    f012102d <merging+0x1dd>
f0121016:	83 ec 04             	sub    $0x4,%esp
f0121019:	68 d0 0e 13 f0       	push   $0xf0130ed0
f012101e:	68 8d 01 00 00       	push   $0x18d
f0121023:	68 15 0e 13 f0       	push   $0xf0130e15
f0121028:	e8 0c f3 fd ff       	call   f0100339 <_panic>
f012102d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121030:	8b 50 04             	mov    0x4(%eax),%edx
f0121033:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121036:	89 50 04             	mov    %edx,0x4(%eax)
f0121039:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012103c:	8b 55 0c             	mov    0xc(%ebp),%edx
f012103f:	89 10                	mov    %edx,(%eax)
f0121041:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121044:	8b 40 04             	mov    0x4(%eax),%eax
f0121047:	85 c0                	test   %eax,%eax
f0121049:	74 0d                	je     f0121058 <merging+0x208>
f012104b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012104e:	8b 40 04             	mov    0x4(%eax),%eax
f0121051:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121054:	89 10                	mov    %edx,(%eax)
f0121056:	eb 08                	jmp    f0121060 <merging+0x210>
f0121058:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012105b:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0121060:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121063:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121066:	89 50 04             	mov    %edx,0x4(%eax)
f0121069:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012106e:	40                   	inc    %eax
f012106f:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		LIST_REMOVE(&freeBlocksList, next_block);
f0121074:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121078:	75 17                	jne    f0121091 <merging+0x241>
f012107a:	83 ec 04             	sub    $0x4,%esp
f012107d:	68 f7 0d 13 f0       	push   $0xf0130df7
f0121082:	68 8e 01 00 00       	push   $0x18e
f0121087:	68 15 0e 13 f0       	push   $0xf0130e15
f012108c:	e8 a8 f2 fd ff       	call   f0100339 <_panic>
f0121091:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121094:	8b 00                	mov    (%eax),%eax
f0121096:	85 c0                	test   %eax,%eax
f0121098:	74 10                	je     f01210aa <merging+0x25a>
f012109a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012109d:	8b 00                	mov    (%eax),%eax
f012109f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01210a2:	8b 52 04             	mov    0x4(%edx),%edx
f01210a5:	89 50 04             	mov    %edx,0x4(%eax)
f01210a8:	eb 0b                	jmp    f01210b5 <merging+0x265>
f01210aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210ad:	8b 40 04             	mov    0x4(%eax),%eax
f01210b0:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01210b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210b8:	8b 40 04             	mov    0x4(%eax),%eax
f01210bb:	85 c0                	test   %eax,%eax
f01210bd:	74 0f                	je     f01210ce <merging+0x27e>
f01210bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210c2:	8b 40 04             	mov    0x4(%eax),%eax
f01210c5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01210c8:	8b 12                	mov    (%edx),%edx
f01210ca:	89 10                	mov    %edx,(%eax)
f01210cc:	eb 0a                	jmp    f01210d8 <merging+0x288>
f01210ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210d1:	8b 00                	mov    (%eax),%eax
f01210d3:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01210d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01210e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01210e4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01210eb:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01210f0:	48                   	dec    %eax
f01210f1:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
		}
		set_block_data(va, get_block_size(va), 0);
	}
}
f01210f6:	e9 72 01 00 00       	jmp    f012126d <merging+0x41d>
		LIST_INSERT_BEFORE(&freeBlocksList, next_block, va_block);
		LIST_REMOVE(&freeBlocksList, next_block);
	}
	else
	{
		struct BlockElement *va_block = (struct BlockElement *)va;
f01210fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01210fe:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(prev_block != NULL && next_block != NULL) LIST_INSERT_AFTER(&freeBlocksList, prev_block, va_block);
f0121101:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121105:	74 79                	je     f0121180 <merging+0x330>
f0121107:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f012110b:	74 73                	je     f0121180 <merging+0x330>
f012110d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121111:	74 06                	je     f0121119 <merging+0x2c9>
f0121113:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121117:	75 17                	jne    f0121130 <merging+0x2e0>
f0121119:	83 ec 04             	sub    $0x4,%esp
f012111c:	68 88 0e 13 f0       	push   $0xf0130e88
f0121121:	68 94 01 00 00       	push   $0x194
f0121126:	68 15 0e 13 f0       	push   $0xf0130e15
f012112b:	e8 09 f2 fd ff       	call   f0100339 <_panic>
f0121130:	8b 45 08             	mov    0x8(%ebp),%eax
f0121133:	8b 10                	mov    (%eax),%edx
f0121135:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121138:	89 10                	mov    %edx,(%eax)
f012113a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012113d:	8b 00                	mov    (%eax),%eax
f012113f:	85 c0                	test   %eax,%eax
f0121141:	74 0b                	je     f012114e <merging+0x2fe>
f0121143:	8b 45 08             	mov    0x8(%ebp),%eax
f0121146:	8b 00                	mov    (%eax),%eax
f0121148:	8b 55 dc             	mov    -0x24(%ebp),%edx
f012114b:	89 50 04             	mov    %edx,0x4(%eax)
f012114e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121151:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121154:	89 10                	mov    %edx,(%eax)
f0121156:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121159:	8b 55 08             	mov    0x8(%ebp),%edx
f012115c:	89 50 04             	mov    %edx,0x4(%eax)
f012115f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121162:	8b 00                	mov    (%eax),%eax
f0121164:	85 c0                	test   %eax,%eax
f0121166:	75 08                	jne    f0121170 <merging+0x320>
f0121168:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012116b:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121170:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121175:	40                   	inc    %eax
f0121176:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f012117b:	e9 ce 00 00 00       	jmp    f012124e <merging+0x3fe>
		else if(prev_block != NULL) LIST_INSERT_TAIL(&freeBlocksList, va_block);
f0121180:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121184:	74 65                	je     f01211eb <merging+0x39b>
f0121186:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012118a:	75 17                	jne    f01211a3 <merging+0x353>
f012118c:	83 ec 04             	sub    $0x4,%esp
f012118f:	68 64 0e 13 f0       	push   $0xf0130e64
f0121194:	68 95 01 00 00       	push   $0x195
f0121199:	68 15 0e 13 f0       	push   $0xf0130e15
f012119e:	e8 96 f1 fd ff       	call   f0100339 <_panic>
f01211a3:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f01211a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211ac:	89 50 04             	mov    %edx,0x4(%eax)
f01211af:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211b2:	8b 40 04             	mov    0x4(%eax),%eax
f01211b5:	85 c0                	test   %eax,%eax
f01211b7:	74 0c                	je     f01211c5 <merging+0x375>
f01211b9:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f01211be:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01211c1:	89 10                	mov    %edx,(%eax)
f01211c3:	eb 08                	jmp    f01211cd <merging+0x37d>
f01211c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211c8:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f01211cd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211d0:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01211d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01211d8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01211de:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01211e3:	40                   	inc    %eax
f01211e4:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01211e9:	eb 63                	jmp    f012124e <merging+0x3fe>
		else
		{
			LIST_INSERT_HEAD(&freeBlocksList, va_block);
f01211eb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01211ef:	75 17                	jne    f0121208 <merging+0x3b8>
f01211f1:	83 ec 04             	sub    $0x4,%esp
f01211f4:	68 30 0e 13 f0       	push   $0xf0130e30
f01211f9:	68 98 01 00 00       	push   $0x198
f01211fe:	68 15 0e 13 f0       	push   $0xf0130e15
f0121203:	e8 31 f1 fd ff       	call   f0100339 <_panic>
f0121208:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f012120e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121211:	89 10                	mov    %edx,(%eax)
f0121213:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121216:	8b 00                	mov    (%eax),%eax
f0121218:	85 c0                	test   %eax,%eax
f012121a:	74 0d                	je     f0121229 <merging+0x3d9>
f012121c:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0121221:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0121224:	89 50 04             	mov    %edx,0x4(%eax)
f0121227:	eb 08                	jmp    f0121231 <merging+0x3e1>
f0121229:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012122c:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121231:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0121234:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0121239:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012123c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121243:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121248:	40                   	inc    %eax
f0121249:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
		}
		set_block_data(va, get_block_size(va), 0);
f012124e:	83 ec 0c             	sub    $0xc,%esp
f0121251:	ff 75 10             	pushl  0x10(%ebp)
f0121254:	e8 d6 ed ff ff       	call   f012002f <get_block_size>
f0121259:	83 c4 10             	add    $0x10,%esp
f012125c:	83 ec 04             	sub    $0x4,%esp
f012125f:	6a 00                	push   $0x0
f0121261:	50                   	push   %eax
f0121262:	ff 75 10             	pushl  0x10(%ebp)
f0121265:	e8 16 f1 ff ff       	call   f0120380 <set_block_data>
f012126a:	83 c4 10             	add    $0x10,%esp
	}
}
f012126d:	90                   	nop
f012126e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121271:	c9                   	leave  
f0121272:	c3                   	ret    

f0121273 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121273:	55                   	push   %ebp
f0121274:	89 e5                	mov    %esp,%ebp
f0121276:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);
f0121279:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f012127e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
f0121281:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f0121286:	3b 45 08             	cmp    0x8(%ebp),%eax
f0121289:	73 1b                	jae    f01212a6 <free_block+0x33>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
f012128b:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f0121290:	83 ec 04             	sub    $0x4,%esp
f0121293:	ff 75 08             	pushl  0x8(%ebp)
f0121296:	6a 00                	push   $0x0
f0121298:	50                   	push   %eax
f0121299:	e8 b2 fb ff ff       	call   f0120e50 <merging>
f012129e:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01212a1:	e9 8b 00 00 00       	jmp    f0121331 <free_block+0xbe>
	struct BlockElement *prev_block = LIST_FIRST(&freeBlocksList);

	if((char *)LIST_LAST(&freeBlocksList) < (char *)va){
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
f01212a6:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01212ab:	3b 45 08             	cmp    0x8(%ebp),%eax
f01212ae:	76 18                	jbe    f01212c8 <free_block+0x55>
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
f01212b0:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01212b5:	83 ec 04             	sub    $0x4,%esp
f01212b8:	ff 75 08             	pushl  0x8(%ebp)
f01212bb:	50                   	push   %eax
f01212bc:	6a 00                	push   $0x0
f01212be:	e8 8d fb ff ff       	call   f0120e50 <merging>
f01212c3:	83 c4 10             	add    $0x10,%esp
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f01212c6:	eb 69                	jmp    f0121331 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f01212c8:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01212cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01212d0:	eb 39                	jmp    f012130b <free_block+0x98>
		if((uint32 *)prev_block < (uint32 *)va && (uint32 *)prev_block->prev_next_info.le_next > (uint32 *)va ){
f01212d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212d5:	3b 45 08             	cmp    0x8(%ebp),%eax
f01212d8:	73 29                	jae    f0121303 <free_block+0x90>
f01212da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212dd:	8b 00                	mov    (%eax),%eax
f01212df:	3b 45 08             	cmp    0x8(%ebp),%eax
f01212e2:	76 1f                	jbe    f0121303 <free_block+0x90>
			//get the address of prev and next
			struct BlockElement *next_block = LIST_NEXT(prev_block);
f01212e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01212e7:	8b 00                	mov    (%eax),%eax
f01212e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
			merging(prev_block, next_block, va);
f01212ec:	83 ec 04             	sub    $0x4,%esp
f01212ef:	ff 75 08             	pushl  0x8(%ebp)
f01212f2:	ff 75 f0             	pushl  -0x10(%ebp)
f01212f5:	ff 75 f4             	pushl  -0xc(%ebp)
f01212f8:	e8 53 fb ff ff       	call   f0120e50 <merging>
f01212fd:	83 c4 10             	add    $0x10,%esp
			break;
f0121300:	90                   	nop
		}
	}
}
f0121301:	eb 2e                	jmp    f0121331 <free_block+0xbe>
		merging(LIST_LAST(&freeBlocksList), NULL, va);
	}
	else if((char *)LIST_FIRST(&freeBlocksList) > (char *)va) {
		merging(NULL, LIST_FIRST(&freeBlocksList),va);
	}
	else LIST_FOREACH (prev_block, &freeBlocksList){
f0121303:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0121308:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012130b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012130f:	74 07                	je     f0121318 <free_block+0xa5>
f0121311:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121314:	8b 00                	mov    (%eax),%eax
f0121316:	eb 05                	jmp    f012131d <free_block+0xaa>
f0121318:	b8 00 00 00 00       	mov    $0x0,%eax
f012131d:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f0121322:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f0121327:	85 c0                	test   %eax,%eax
f0121329:	75 a7                	jne    f01212d2 <free_block+0x5f>
f012132b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012132f:	75 a1                	jne    f01212d2 <free_block+0x5f>
			struct BlockElement *next_block = LIST_NEXT(prev_block);
			merging(prev_block, next_block, va);
			break;
		}
	}
}
f0121331:	90                   	nop
f0121332:	c9                   	leave  
f0121333:	c3                   	ret    

f0121334 <copy_data>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void copy_data(void *va, void *new_va)
{
f0121334:	55                   	push   %ebp
f0121335:	89 e5                	mov    %esp,%ebp
f0121337:	83 ec 10             	sub    $0x10,%esp
	uint32 va_size = get_block_size(va);
f012133a:	ff 75 08             	pushl  0x8(%ebp)
f012133d:	e8 ed ec ff ff       	call   f012002f <get_block_size>
f0121342:	83 c4 04             	add    $0x4,%esp
f0121345:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(int i = 0; i < va_size; i++) *((char *)new_va + i) = *((char *)va + i);
f0121348:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f012134f:	eb 17                	jmp    f0121368 <copy_data+0x34>
f0121351:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0121354:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121357:	01 c2                	add    %eax,%edx
f0121359:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f012135c:	8b 45 08             	mov    0x8(%ebp),%eax
f012135f:	01 c8                	add    %ecx,%eax
f0121361:	8a 00                	mov    (%eax),%al
f0121363:	88 02                	mov    %al,(%edx)
f0121365:	ff 45 fc             	incl   -0x4(%ebp)
f0121368:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012136b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f012136e:	72 e1                	jb     f0121351 <copy_data+0x1d>
}
f0121370:	90                   	nop
f0121371:	c9                   	leave  
f0121372:	c3                   	ret    

f0121373 <realloc_block_FF>:

void *realloc_block_FF(void* va, uint32 new_size)
{
f0121373:	55                   	push   %ebp
f0121374:	89 e5                	mov    %esp,%ebp
f0121376:	83 ec 58             	sub    $0x58,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...


	if(va == NULL)
f0121379:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012137d:	75 23                	jne    f01213a2 <realloc_block_FF+0x2f>
	{
		if(new_size != 0) return alloc_block_FF(new_size);
f012137f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121383:	74 13                	je     f0121398 <realloc_block_FF+0x25>
f0121385:	83 ec 0c             	sub    $0xc,%esp
f0121388:	ff 75 0c             	pushl  0xc(%ebp)
f012138b:	e8 1f f0 ff ff       	call   f01203af <alloc_block_FF>
f0121390:	83 c4 10             	add    $0x10,%esp
f0121393:	e9 f4 06 00 00       	jmp    f0121a8c <realloc_block_FF+0x719>
		return NULL;
f0121398:	b8 00 00 00 00       	mov    $0x0,%eax
f012139d:	e9 ea 06 00 00       	jmp    f0121a8c <realloc_block_FF+0x719>
	}

	if(new_size == 0)
f01213a2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01213a6:	75 18                	jne    f01213c0 <realloc_block_FF+0x4d>
	{
		free_block(va);
f01213a8:	83 ec 0c             	sub    $0xc,%esp
f01213ab:	ff 75 08             	pushl  0x8(%ebp)
f01213ae:	e8 c0 fe ff ff       	call   f0121273 <free_block>
f01213b3:	83 c4 10             	add    $0x10,%esp
		return NULL;
f01213b6:	b8 00 00 00 00       	mov    $0x0,%eax
f01213bb:	e9 cc 06 00 00       	jmp    f0121a8c <realloc_block_FF+0x719>
	}


	if(new_size < 8) new_size = 8;
f01213c0:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f01213c4:	77 07                	ja     f01213cd <realloc_block_FF+0x5a>
f01213c6:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	new_size += (new_size % 2);
f01213cd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01213d0:	83 e0 01             	and    $0x1,%eax
f01213d3:	01 45 0c             	add    %eax,0xc(%ebp)

	//cur Block data
	uint32 newBLOCK_size = new_size + 8;
f01213d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01213d9:	83 c0 08             	add    $0x8,%eax
f01213dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 curBLOCK_size = get_block_size(va) /*BLOCK size in Bytes*/;
f01213df:	83 ec 0c             	sub    $0xc,%esp
f01213e2:	ff 75 08             	pushl  0x8(%ebp)
f01213e5:	e8 45 ec ff ff       	call   f012002f <get_block_size>
f01213ea:	83 c4 10             	add    $0x10,%esp
f01213ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 cur_size = curBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f01213f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01213f3:	83 e8 08             	sub    $0x8,%eax
f01213f6:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//next Block data
	void *next_va = (void *)(FOOTER(va) + 2);
f01213f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01213fc:	83 e8 04             	sub    $0x4,%eax
f01213ff:	8b 00                	mov    (%eax),%eax
f0121401:	83 e0 fe             	and    $0xfffffffe,%eax
f0121404:	89 c2                	mov    %eax,%edx
f0121406:	8b 45 08             	mov    0x8(%ebp),%eax
f0121409:	01 d0                	add    %edx,%eax
f012140b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 nextBLOCK_size = get_block_size(next_va)/*&is_free_block(next_block_va)*/; //=0 if not free
f012140e:	83 ec 0c             	sub    $0xc,%esp
f0121411:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121414:	e8 16 ec ff ff       	call   f012002f <get_block_size>
f0121419:	83 c4 10             	add    $0x10,%esp
f012141c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 next_cur_size = nextBLOCK_size - 8 /*8 Bytes = (Header + Footer) size*/;
f012141f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121422:	83 e8 08             	sub    $0x8,%eax
f0121425:	89 45 dc             	mov    %eax,-0x24(%ebp)


	//if the user needs the same size he owns
	if(new_size == cur_size)
f0121428:	8b 45 0c             	mov    0xc(%ebp),%eax
f012142b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f012142e:	75 08                	jne    f0121438 <realloc_block_FF+0xc5>
	{
		 return va;
f0121430:	8b 45 08             	mov    0x8(%ebp),%eax
f0121433:	e9 54 06 00 00       	jmp    f0121a8c <realloc_block_FF+0x719>

	}


	if(new_size < cur_size)
f0121438:	8b 45 0c             	mov    0xc(%ebp),%eax
f012143b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f012143e:	0f 83 e5 03 00 00    	jae    f0121829 <realloc_block_FF+0x4b6>
	{
		uint32 remaining_size = cur_size - new_size; //remaining size in single Bytes
f0121444:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0121447:	2b 45 0c             	sub    0xc(%ebp),%eax
f012144a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if(is_free_block(next_va))
f012144d:	83 ec 0c             	sub    $0xc,%esp
f0121450:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121453:	e8 f0 eb ff ff       	call   f0120048 <is_free_block>
f0121458:	83 c4 10             	add    $0x10,%esp
f012145b:	84 c0                	test   %al,%al
f012145d:	0f 84 3b 01 00 00    	je     f012159e <realloc_block_FF+0x22b>
		{

			uint32 next_newBLOCK_size = nextBLOCK_size + remaining_size;
f0121463:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121466:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0121469:	01 d0                	add    %edx,%eax
f012146b:	89 45 cc             	mov    %eax,-0x34(%ebp)
			set_block_data(va, newBLOCK_size, 1);
f012146e:	83 ec 04             	sub    $0x4,%esp
f0121471:	6a 01                	push   $0x1
f0121473:	ff 75 f0             	pushl  -0x10(%ebp)
f0121476:	ff 75 08             	pushl  0x8(%ebp)
f0121479:	e8 02 ef ff ff       	call   f0120380 <set_block_data>
f012147e:	83 c4 10             	add    $0x10,%esp
			void *next_new_va = (void *)(FOOTER(va) + 2);
f0121481:	8b 45 08             	mov    0x8(%ebp),%eax
f0121484:	83 e8 04             	sub    $0x4,%eax
f0121487:	8b 00                	mov    (%eax),%eax
f0121489:	83 e0 fe             	and    $0xfffffffe,%eax
f012148c:	89 c2                	mov    %eax,%edx
f012148e:	8b 45 08             	mov    0x8(%ebp),%eax
f0121491:	01 d0                	add    %edx,%eax
f0121493:	89 45 c8             	mov    %eax,-0x38(%ebp)
			set_block_data(next_new_va, next_newBLOCK_size, 0);
f0121496:	83 ec 04             	sub    $0x4,%esp
f0121499:	6a 00                	push   $0x0
f012149b:	ff 75 cc             	pushl  -0x34(%ebp)
f012149e:	ff 75 c8             	pushl  -0x38(%ebp)
f01214a1:	e8 da ee ff ff       	call   f0120380 <set_block_data>
f01214a6:	83 c4 10             	add    $0x10,%esp
			LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f01214a9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01214ad:	74 06                	je     f01214b5 <realloc_block_FF+0x142>
f01214af:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01214b3:	75 17                	jne    f01214cc <realloc_block_FF+0x159>
f01214b5:	83 ec 04             	sub    $0x4,%esp
f01214b8:	68 88 0e 13 f0       	push   $0xf0130e88
f01214bd:	68 f6 01 00 00       	push   $0x1f6
f01214c2:	68 15 0e 13 f0       	push   $0xf0130e15
f01214c7:	e8 6d ee fd ff       	call   f0100339 <_panic>
f01214cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01214cf:	8b 10                	mov    (%eax),%edx
f01214d1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01214d4:	89 10                	mov    %edx,(%eax)
f01214d6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01214d9:	8b 00                	mov    (%eax),%eax
f01214db:	85 c0                	test   %eax,%eax
f01214dd:	74 0b                	je     f01214ea <realloc_block_FF+0x177>
f01214df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01214e2:	8b 00                	mov    (%eax),%eax
f01214e4:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01214e7:	89 50 04             	mov    %edx,0x4(%eax)
f01214ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01214ed:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01214f0:	89 10                	mov    %edx,(%eax)
f01214f2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01214f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01214f8:	89 50 04             	mov    %edx,0x4(%eax)
f01214fb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01214fe:	8b 00                	mov    (%eax),%eax
f0121500:	85 c0                	test   %eax,%eax
f0121502:	75 08                	jne    f012150c <realloc_block_FF+0x199>
f0121504:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0121507:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f012150c:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121511:	40                   	inc    %eax
f0121512:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
			LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f0121517:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012151b:	75 17                	jne    f0121534 <realloc_block_FF+0x1c1>
f012151d:	83 ec 04             	sub    $0x4,%esp
f0121520:	68 f7 0d 13 f0       	push   $0xf0130df7
f0121525:	68 f7 01 00 00       	push   $0x1f7
f012152a:	68 15 0e 13 f0       	push   $0xf0130e15
f012152f:	e8 05 ee fd ff       	call   f0100339 <_panic>
f0121534:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121537:	8b 00                	mov    (%eax),%eax
f0121539:	85 c0                	test   %eax,%eax
f012153b:	74 10                	je     f012154d <realloc_block_FF+0x1da>
f012153d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121540:	8b 00                	mov    (%eax),%eax
f0121542:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121545:	8b 52 04             	mov    0x4(%edx),%edx
f0121548:	89 50 04             	mov    %edx,0x4(%eax)
f012154b:	eb 0b                	jmp    f0121558 <realloc_block_FF+0x1e5>
f012154d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121550:	8b 40 04             	mov    0x4(%eax),%eax
f0121553:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121558:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012155b:	8b 40 04             	mov    0x4(%eax),%eax
f012155e:	85 c0                	test   %eax,%eax
f0121560:	74 0f                	je     f0121571 <realloc_block_FF+0x1fe>
f0121562:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121565:	8b 40 04             	mov    0x4(%eax),%eax
f0121568:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f012156b:	8b 12                	mov    (%edx),%edx
f012156d:	89 10                	mov    %edx,(%eax)
f012156f:	eb 0a                	jmp    f012157b <realloc_block_FF+0x208>
f0121571:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121574:	8b 00                	mov    (%eax),%eax
f0121576:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012157b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012157e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121584:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121587:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012158e:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121593:	48                   	dec    %eax
f0121594:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0121599:	e9 83 02 00 00       	jmp    f0121821 <realloc_block_FF+0x4ae>
		}
		else
		{
			if(remaining_size>=16)
f012159e:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f01215a2:	0f 86 69 02 00 00    	jbe    f0121811 <realloc_block_FF+0x49e>
			{
				//uint32 next_new_size = remaining_size - 8;/*+ next_cur_size&is_free_block(next_cur_va)*/
				set_block_data(va, newBLOCK_size, 1);
f01215a8:	83 ec 04             	sub    $0x4,%esp
f01215ab:	6a 01                	push   $0x1
f01215ad:	ff 75 f0             	pushl  -0x10(%ebp)
f01215b0:	ff 75 08             	pushl  0x8(%ebp)
f01215b3:	e8 c8 ed ff ff       	call   f0120380 <set_block_data>
f01215b8:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f01215bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01215be:	83 e8 04             	sub    $0x4,%eax
f01215c1:	8b 00                	mov    (%eax),%eax
f01215c3:	83 e0 fe             	and    $0xfffffffe,%eax
f01215c6:	89 c2                	mov    %eax,%edx
f01215c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01215cb:	01 d0                	add    %edx,%eax
f01215cd:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				//insert new block to free_block_list
				uint32 list_size = LIST_SIZE(&freeBlocksList);
f01215d0:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01215d5:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if(list_size == 0)
f01215d8:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01215dc:	75 68                	jne    f0121646 <realloc_block_FF+0x2d3>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f01215de:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01215e2:	75 17                	jne    f01215fb <realloc_block_FF+0x288>
f01215e4:	83 ec 04             	sub    $0x4,%esp
f01215e7:	68 30 0e 13 f0       	push   $0xf0130e30
f01215ec:	68 06 02 00 00       	push   $0x206
f01215f1:	68 15 0e 13 f0       	push   $0xf0130e15
f01215f6:	e8 3e ed fd ff       	call   f0100339 <_panic>
f01215fb:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0121601:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121604:	89 10                	mov    %edx,(%eax)
f0121606:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121609:	8b 00                	mov    (%eax),%eax
f012160b:	85 c0                	test   %eax,%eax
f012160d:	74 0d                	je     f012161c <realloc_block_FF+0x2a9>
f012160f:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0121614:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121617:	89 50 04             	mov    %edx,0x4(%eax)
f012161a:	eb 08                	jmp    f0121624 <realloc_block_FF+0x2b1>
f012161c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012161f:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121624:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121627:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012162c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012162f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121636:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012163b:	40                   	inc    %eax
f012163c:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0121641:	e9 b0 01 00 00       	jmp    f01217f6 <realloc_block_FF+0x483>
				}
				else if((struct BlockElement *)next_new_va < LIST_FIRST(&freeBlocksList))
f0121646:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f012164b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f012164e:	76 68                	jbe    f01216b8 <realloc_block_FF+0x345>
				{

					LIST_INSERT_HEAD(&freeBlocksList, (struct BlockElement *)next_new_va);
f0121650:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0121654:	75 17                	jne    f012166d <realloc_block_FF+0x2fa>
f0121656:	83 ec 04             	sub    $0x4,%esp
f0121659:	68 30 0e 13 f0       	push   $0xf0130e30
f012165e:	68 0b 02 00 00       	push   $0x20b
f0121663:	68 15 0e 13 f0       	push   $0xf0130e15
f0121668:	e8 cc ec fd ff       	call   f0100339 <_panic>
f012166d:	8b 15 f0 d3 6b f0    	mov    0xf06bd3f0,%edx
f0121673:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121676:	89 10                	mov    %edx,(%eax)
f0121678:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012167b:	8b 00                	mov    (%eax),%eax
f012167d:	85 c0                	test   %eax,%eax
f012167f:	74 0d                	je     f012168e <realloc_block_FF+0x31b>
f0121681:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0121686:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121689:	89 50 04             	mov    %edx,0x4(%eax)
f012168c:	eb 08                	jmp    f0121696 <realloc_block_FF+0x323>
f012168e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121691:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121696:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121699:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012169e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216a1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01216a8:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01216ad:	40                   	inc    %eax
f01216ae:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f01216b3:	e9 3e 01 00 00       	jmp    f01217f6 <realloc_block_FF+0x483>
				}
				else if(LIST_FIRST(&freeBlocksList) < (struct BlockElement *)next_new_va)
f01216b8:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f01216bd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01216c0:	73 68                	jae    f012172a <realloc_block_FF+0x3b7>
				{

					LIST_INSERT_TAIL(&freeBlocksList, (struct BlockElement *)next_new_va);
f01216c2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01216c6:	75 17                	jne    f01216df <realloc_block_FF+0x36c>
f01216c8:	83 ec 04             	sub    $0x4,%esp
f01216cb:	68 64 0e 13 f0       	push   $0xf0130e64
f01216d0:	68 10 02 00 00       	push   $0x210
f01216d5:	68 15 0e 13 f0       	push   $0xf0130e15
f01216da:	e8 5a ec fd ff       	call   f0100339 <_panic>
f01216df:	8b 15 f4 d3 6b f0    	mov    0xf06bd3f4,%edx
f01216e5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216e8:	89 50 04             	mov    %edx,0x4(%eax)
f01216eb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01216ee:	8b 40 04             	mov    0x4(%eax),%eax
f01216f1:	85 c0                	test   %eax,%eax
f01216f3:	74 0c                	je     f0121701 <realloc_block_FF+0x38e>
f01216f5:	a1 f4 d3 6b f0       	mov    0xf06bd3f4,%eax
f01216fa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01216fd:	89 10                	mov    %edx,(%eax)
f01216ff:	eb 08                	jmp    f0121709 <realloc_block_FF+0x396>
f0121701:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121704:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0121709:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012170c:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121711:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121714:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012171a:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f012171f:	40                   	inc    %eax
f0121720:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
f0121725:	e9 cc 00 00 00       	jmp    f01217f6 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
f012172a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
					LIST_FOREACH(blk, &freeBlocksList)
f0121731:	a1 f0 d3 6b f0       	mov    0xf06bd3f0,%eax
f0121736:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121739:	e9 8a 00 00 00       	jmp    f01217c8 <realloc_block_FF+0x455>
					{
						if(blk < (struct BlockElement *)next_new_va && LIST_NEXT(blk) < (struct BlockElement *)next_new_va)
f012173e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121741:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0121744:	73 7a                	jae    f01217c0 <realloc_block_FF+0x44d>
f0121746:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121749:	8b 00                	mov    (%eax),%eax
f012174b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f012174e:	73 70                	jae    f01217c0 <realloc_block_FF+0x44d>
						{
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
f0121750:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121754:	74 06                	je     f012175c <realloc_block_FF+0x3e9>
f0121756:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f012175a:	75 17                	jne    f0121773 <realloc_block_FF+0x400>
f012175c:	83 ec 04             	sub    $0x4,%esp
f012175f:	68 88 0e 13 f0       	push   $0xf0130e88
f0121764:	68 1a 02 00 00       	push   $0x21a
f0121769:	68 15 0e 13 f0       	push   $0xf0130e15
f012176e:	e8 c6 eb fd ff       	call   f0100339 <_panic>
f0121773:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121776:	8b 10                	mov    (%eax),%edx
f0121778:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012177b:	89 10                	mov    %edx,(%eax)
f012177d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0121780:	8b 00                	mov    (%eax),%eax
f0121782:	85 c0                	test   %eax,%eax
f0121784:	74 0b                	je     f0121791 <realloc_block_FF+0x41e>
f0121786:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121789:	8b 00                	mov    (%eax),%eax
f012178b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012178e:	89 50 04             	mov    %edx,0x4(%eax)
f0121791:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121794:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0121797:	89 10                	mov    %edx,(%eax)
f0121799:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f012179c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012179f:	89 50 04             	mov    %edx,0x4(%eax)
f01217a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01217a5:	8b 00                	mov    (%eax),%eax
f01217a7:	85 c0                	test   %eax,%eax
f01217a9:	75 08                	jne    f01217b3 <realloc_block_FF+0x440>
f01217ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01217ae:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01217b3:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01217b8:	40                   	inc    %eax
f01217b9:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
							break;
f01217be:	eb 36                	jmp    f01217f6 <realloc_block_FF+0x483>
				}
				else
				{

					struct BlockElement *blk = NULL;
					LIST_FOREACH(blk, &freeBlocksList)
f01217c0:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f01217c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01217c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01217cc:	74 07                	je     f01217d5 <realloc_block_FF+0x462>
f01217ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01217d1:	8b 00                	mov    (%eax),%eax
f01217d3:	eb 05                	jmp    f01217da <realloc_block_FF+0x467>
f01217d5:	b8 00 00 00 00       	mov    $0x0,%eax
f01217da:	a3 f8 d3 6b f0       	mov    %eax,0xf06bd3f8
f01217df:	a1 f8 d3 6b f0       	mov    0xf06bd3f8,%eax
f01217e4:	85 c0                	test   %eax,%eax
f01217e6:	0f 85 52 ff ff ff    	jne    f012173e <realloc_block_FF+0x3cb>
f01217ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01217f0:	0f 85 48 ff ff ff    	jne    f012173e <realloc_block_FF+0x3cb>
							LIST_INSERT_AFTER(&freeBlocksList, blk, (struct BlockElement *)next_new_va);
							break;
						}
					}
				}
				set_block_data(next_new_va, remaining_size, 0);
f01217f6:	83 ec 04             	sub    $0x4,%esp
f01217f9:	6a 00                	push   $0x0
f01217fb:	ff 75 d8             	pushl  -0x28(%ebp)
f01217fe:	ff 75 d4             	pushl  -0x2c(%ebp)
f0121801:	e8 7a eb ff ff       	call   f0120380 <set_block_data>
f0121806:	83 c4 10             	add    $0x10,%esp
				return va;
f0121809:	8b 45 08             	mov    0x8(%ebp),%eax
f012180c:	e9 7b 02 00 00       	jmp    f0121a8c <realloc_block_FF+0x719>
			}
			cprintf("16\n");
f0121811:	83 ec 0c             	sub    $0xc,%esp
f0121814:	68 05 0f 13 f0       	push   $0xf0130f05
f0121819:	e8 6d f7 fd ff       	call   f0100f8b <cprintf>
f012181e:	83 c4 10             	add    $0x10,%esp
		}
		return va;
f0121821:	8b 45 08             	mov    0x8(%ebp),%eax
f0121824:	e9 63 02 00 00       	jmp    f0121a8c <realloc_block_FF+0x719>
	}

	if(new_size > cur_size)
f0121829:	8b 45 0c             	mov    0xc(%ebp),%eax
f012182c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f012182f:	0f 86 4d 02 00 00    	jbe    f0121a82 <realloc_block_FF+0x70f>
	{
		if(is_free_block(next_va))
f0121835:	83 ec 0c             	sub    $0xc,%esp
f0121838:	ff 75 e4             	pushl  -0x1c(%ebp)
f012183b:	e8 08 e8 ff ff       	call   f0120048 <is_free_block>
f0121840:	83 c4 10             	add    $0x10,%esp
f0121843:	84 c0                	test   %al,%al
f0121845:	0f 84 37 02 00 00    	je     f0121a82 <realloc_block_FF+0x70f>
		{

			uint32 needed_size = new_size - cur_size; //needed size in single Bytes
f012184b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012184e:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0121851:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if(needed_size > nextBLOCK_size)
f0121854:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0121857:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f012185a:	76 38                	jbe    f0121894 <realloc_block_FF+0x521>
			{
				free_block(va); //set it free
f012185c:	83 ec 0c             	sub    $0xc,%esp
f012185f:	ff 75 08             	pushl  0x8(%ebp)
f0121862:	e8 0c fa ff ff       	call   f0121273 <free_block>
f0121867:	83 c4 10             	add    $0x10,%esp
				void *new_va = alloc_block_FF(new_size); //new allocation
f012186a:	83 ec 0c             	sub    $0xc,%esp
f012186d:	ff 75 0c             	pushl  0xc(%ebp)
f0121870:	e8 3a eb ff ff       	call   f01203af <alloc_block_FF>
f0121875:	83 c4 10             	add    $0x10,%esp
f0121878:	89 45 c0             	mov    %eax,-0x40(%ebp)
				copy_data(va, new_va); //transfer data
f012187b:	83 ec 08             	sub    $0x8,%esp
f012187e:	ff 75 c0             	pushl  -0x40(%ebp)
f0121881:	ff 75 08             	pushl  0x8(%ebp)
f0121884:	e8 ab fa ff ff       	call   f0121334 <copy_data>
f0121889:	83 c4 10             	add    $0x10,%esp
				return new_va;
f012188c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012188f:	e9 f8 01 00 00       	jmp    f0121a8c <realloc_block_FF+0x719>
			}
			uint32 remaining_size = nextBLOCK_size - needed_size;
f0121894:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121897:	2b 45 c4             	sub    -0x3c(%ebp),%eax
f012189a:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if(remaining_size < 16) //merge next block to my cur block
f012189d:	83 7d bc 0f          	cmpl   $0xf,-0x44(%ebp)
f01218a1:	0f 87 a0 00 00 00    	ja     f0121947 <realloc_block_FF+0x5d4>
			{
				//remove from free_block_list, then
				LIST_REMOVE(&freeBlocksList, (struct BlockElement *)next_va);
f01218a7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01218ab:	75 17                	jne    f01218c4 <realloc_block_FF+0x551>
f01218ad:	83 ec 04             	sub    $0x4,%esp
f01218b0:	68 f7 0d 13 f0       	push   $0xf0130df7
f01218b5:	68 38 02 00 00       	push   $0x238
f01218ba:	68 15 0e 13 f0       	push   $0xf0130e15
f01218bf:	e8 75 ea fd ff       	call   f0100339 <_panic>
f01218c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218c7:	8b 00                	mov    (%eax),%eax
f01218c9:	85 c0                	test   %eax,%eax
f01218cb:	74 10                	je     f01218dd <realloc_block_FF+0x56a>
f01218cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218d0:	8b 00                	mov    (%eax),%eax
f01218d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01218d5:	8b 52 04             	mov    0x4(%edx),%edx
f01218d8:	89 50 04             	mov    %edx,0x4(%eax)
f01218db:	eb 0b                	jmp    f01218e8 <realloc_block_FF+0x575>
f01218dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218e0:	8b 40 04             	mov    0x4(%eax),%eax
f01218e3:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01218e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218eb:	8b 40 04             	mov    0x4(%eax),%eax
f01218ee:	85 c0                	test   %eax,%eax
f01218f0:	74 0f                	je     f0121901 <realloc_block_FF+0x58e>
f01218f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01218f5:	8b 40 04             	mov    0x4(%eax),%eax
f01218f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01218fb:	8b 12                	mov    (%edx),%edx
f01218fd:	89 10                	mov    %edx,(%eax)
f01218ff:	eb 0a                	jmp    f012190b <realloc_block_FF+0x598>
f0121901:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121904:	8b 00                	mov    (%eax),%eax
f0121906:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f012190b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012190e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121914:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121917:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012191e:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121923:	48                   	dec    %eax
f0121924:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc

				//set block
				set_block_data(va, curBLOCK_size + nextBLOCK_size, 1);
f0121929:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012192c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012192f:	01 d0                	add    %edx,%eax
f0121931:	83 ec 04             	sub    $0x4,%esp
f0121934:	6a 01                	push   $0x1
f0121936:	50                   	push   %eax
f0121937:	ff 75 08             	pushl  0x8(%ebp)
f012193a:	e8 41 ea ff ff       	call   f0120380 <set_block_data>
f012193f:	83 c4 10             	add    $0x10,%esp
f0121942:	e9 36 01 00 00       	jmp    f0121a7d <realloc_block_FF+0x70a>
			}
			else
			{
				newBLOCK_size = curBLOCK_size + needed_size;
f0121947:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012194a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012194d:	01 d0                	add    %edx,%eax
f012194f:	89 45 f0             	mov    %eax,-0x10(%ebp)
				set_block_data(va, newBLOCK_size, 1);
f0121952:	83 ec 04             	sub    $0x4,%esp
f0121955:	6a 01                	push   $0x1
f0121957:	ff 75 f0             	pushl  -0x10(%ebp)
f012195a:	ff 75 08             	pushl  0x8(%ebp)
f012195d:	e8 1e ea ff ff       	call   f0120380 <set_block_data>
f0121962:	83 c4 10             	add    $0x10,%esp
				void *next_new_va = (void *)(FOOTER(va) + 2);
f0121965:	8b 45 08             	mov    0x8(%ebp),%eax
f0121968:	83 e8 04             	sub    $0x4,%eax
f012196b:	8b 00                	mov    (%eax),%eax
f012196d:	83 e0 fe             	and    $0xfffffffe,%eax
f0121970:	89 c2                	mov    %eax,%edx
f0121972:	8b 45 08             	mov    0x8(%ebp),%eax
f0121975:	01 d0                	add    %edx,%eax
f0121977:	89 45 b8             	mov    %eax,-0x48(%ebp)

				//update free_block_list
				LIST_INSERT_AFTER(&freeBlocksList, (struct BlockElement*)next_va, (struct BlockElement*)next_new_va);
f012197a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012197e:	74 06                	je     f0121986 <realloc_block_FF+0x613>
f0121980:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f0121984:	75 17                	jne    f012199d <realloc_block_FF+0x62a>
f0121986:	83 ec 04             	sub    $0x4,%esp
f0121989:	68 88 0e 13 f0       	push   $0xf0130e88
f012198e:	68 44 02 00 00       	push   $0x244
f0121993:	68 15 0e 13 f0       	push   $0xf0130e15
f0121998:	e8 9c e9 fd ff       	call   f0100339 <_panic>
f012199d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01219a0:	8b 10                	mov    (%eax),%edx
f01219a2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01219a5:	89 10                	mov    %edx,(%eax)
f01219a7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01219aa:	8b 00                	mov    (%eax),%eax
f01219ac:	85 c0                	test   %eax,%eax
f01219ae:	74 0b                	je     f01219bb <realloc_block_FF+0x648>
f01219b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01219b3:	8b 00                	mov    (%eax),%eax
f01219b5:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01219b8:	89 50 04             	mov    %edx,0x4(%eax)
f01219bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01219be:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01219c1:	89 10                	mov    %edx,(%eax)
f01219c3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01219c6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01219c9:	89 50 04             	mov    %edx,0x4(%eax)
f01219cc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01219cf:	8b 00                	mov    (%eax),%eax
f01219d1:	85 c0                	test   %eax,%eax
f01219d3:	75 08                	jne    f01219dd <realloc_block_FF+0x66a>
f01219d5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01219d8:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f01219dd:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f01219e2:	40                   	inc    %eax
f01219e3:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				LIST_REMOVE(&freeBlocksList, (struct BlockElement*)next_va);
f01219e8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01219ec:	75 17                	jne    f0121a05 <realloc_block_FF+0x692>
f01219ee:	83 ec 04             	sub    $0x4,%esp
f01219f1:	68 f7 0d 13 f0       	push   $0xf0130df7
f01219f6:	68 45 02 00 00       	push   $0x245
f01219fb:	68 15 0e 13 f0       	push   $0xf0130e15
f0121a00:	e8 34 e9 fd ff       	call   f0100339 <_panic>
f0121a05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a08:	8b 00                	mov    (%eax),%eax
f0121a0a:	85 c0                	test   %eax,%eax
f0121a0c:	74 10                	je     f0121a1e <realloc_block_FF+0x6ab>
f0121a0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a11:	8b 00                	mov    (%eax),%eax
f0121a13:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121a16:	8b 52 04             	mov    0x4(%edx),%edx
f0121a19:	89 50 04             	mov    %edx,0x4(%eax)
f0121a1c:	eb 0b                	jmp    f0121a29 <realloc_block_FF+0x6b6>
f0121a1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a21:	8b 40 04             	mov    0x4(%eax),%eax
f0121a24:	a3 f4 d3 6b f0       	mov    %eax,0xf06bd3f4
f0121a29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a2c:	8b 40 04             	mov    0x4(%eax),%eax
f0121a2f:	85 c0                	test   %eax,%eax
f0121a31:	74 0f                	je     f0121a42 <realloc_block_FF+0x6cf>
f0121a33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a36:	8b 40 04             	mov    0x4(%eax),%eax
f0121a39:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0121a3c:	8b 12                	mov    (%edx),%edx
f0121a3e:	89 10                	mov    %edx,(%eax)
f0121a40:	eb 0a                	jmp    f0121a4c <realloc_block_FF+0x6d9>
f0121a42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a45:	8b 00                	mov    (%eax),%eax
f0121a47:	a3 f0 d3 6b f0       	mov    %eax,0xf06bd3f0
f0121a4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a4f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0121a55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121a58:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0121a5f:	a1 fc d3 6b f0       	mov    0xf06bd3fc,%eax
f0121a64:	48                   	dec    %eax
f0121a65:	a3 fc d3 6b f0       	mov    %eax,0xf06bd3fc
				set_block_data(next_new_va, remaining_size, 0);
f0121a6a:	83 ec 04             	sub    $0x4,%esp
f0121a6d:	6a 00                	push   $0x0
f0121a6f:	ff 75 bc             	pushl  -0x44(%ebp)
f0121a72:	ff 75 b8             	pushl  -0x48(%ebp)
f0121a75:	e8 06 e9 ff ff       	call   f0120380 <set_block_data>
f0121a7a:	83 c4 10             	add    $0x10,%esp
			}
			return va;
f0121a7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a80:	eb 0a                	jmp    f0121a8c <realloc_block_FF+0x719>
		}
	}

	int abo_salah = 1; // abo salah NUMBER 1
f0121a82:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%ebp)
	return va;
f0121a89:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0121a8c:	c9                   	leave  
f0121a8d:	c3                   	ret    

f0121a8e <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0121a8e:	55                   	push   %ebp
f0121a8f:	89 e5                	mov    %esp,%ebp
f0121a91:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0121a94:	83 ec 04             	sub    $0x4,%esp
f0121a97:	68 0c 0f 13 f0       	push   $0xf0130f0c
f0121a9c:	68 58 02 00 00       	push   $0x258
f0121aa1:	68 15 0e 13 f0       	push   $0xf0130e15
f0121aa6:	e8 8e e8 fd ff       	call   f0100339 <_panic>

f0121aab <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0121aab:	55                   	push   %ebp
f0121aac:	89 e5                	mov    %esp,%ebp
f0121aae:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0121ab1:	83 ec 04             	sub    $0x4,%esp
f0121ab4:	68 34 0f 13 f0       	push   $0xf0130f34
f0121ab9:	68 61 02 00 00       	push   $0x261
f0121abe:	68 15 0e 13 f0       	push   $0xf0130e15
f0121ac3:	e8 71 e8 fd ff       	call   f0100339 <_panic>

f0121ac8 <__moddi3>:
f0121ac8:	55                   	push   %ebp
f0121ac9:	57                   	push   %edi
f0121aca:	56                   	push   %esi
f0121acb:	53                   	push   %ebx
f0121acc:	83 ec 2c             	sub    $0x2c,%esp
f0121acf:	8b 74 24 40          	mov    0x40(%esp),%esi
f0121ad3:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0121ad7:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0121adb:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0121adf:	89 d8                	mov    %ebx,%eax
f0121ae1:	85 ff                	test   %edi,%edi
f0121ae3:	0f 88 d3 00 00 00    	js     f0121bbc <__moddi3+0xf4>
f0121ae9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0121af0:	00 
f0121af1:	85 c0                	test   %eax,%eax
f0121af3:	0f 88 ab 00 00 00    	js     f0121ba4 <__moddi3+0xdc>
f0121af9:	89 0c 24             	mov    %ecx,(%esp)
f0121afc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0121b00:	89 74 24 10          	mov    %esi,0x10(%esp)
f0121b04:	89 fb                	mov    %edi,%ebx
f0121b06:	8b 14 24             	mov    (%esp),%edx
f0121b09:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0121b0d:	89 d0                	mov    %edx,%eax
f0121b0f:	89 54 24 18          	mov    %edx,0x18(%esp)
f0121b13:	89 ca                	mov    %ecx,%edx
f0121b15:	8b 0c 24             	mov    (%esp),%ecx
f0121b18:	89 34 24             	mov    %esi,(%esp)
f0121b1b:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0121b1f:	85 d2                	test   %edx,%edx
f0121b21:	75 15                	jne    f0121b38 <__moddi3+0x70>
f0121b23:	89 c7                	mov    %eax,%edi
f0121b25:	39 d8                	cmp    %ebx,%eax
f0121b27:	76 5b                	jbe    f0121b84 <__moddi3+0xbc>
f0121b29:	89 f0                	mov    %esi,%eax
f0121b2b:	89 da                	mov    %ebx,%edx
f0121b2d:	f7 f7                	div    %edi
f0121b2f:	89 d3                	mov    %edx,%ebx
f0121b31:	89 d8                	mov    %ebx,%eax
f0121b33:	31 d2                	xor    %edx,%edx
f0121b35:	eb 09                	jmp    f0121b40 <__moddi3+0x78>
f0121b37:	90                   	nop
f0121b38:	39 fa                	cmp    %edi,%edx
f0121b3a:	76 1c                	jbe    f0121b58 <__moddi3+0x90>
f0121b3c:	89 f0                	mov    %esi,%eax
f0121b3e:	89 fa                	mov    %edi,%edx
f0121b40:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0121b44:	85 c9                	test   %ecx,%ecx
f0121b46:	74 07                	je     f0121b4f <__moddi3+0x87>
f0121b48:	f7 d8                	neg    %eax
f0121b4a:	83 d2 00             	adc    $0x0,%edx
f0121b4d:	f7 da                	neg    %edx
f0121b4f:	83 c4 2c             	add    $0x2c,%esp
f0121b52:	5b                   	pop    %ebx
f0121b53:	5e                   	pop    %esi
f0121b54:	5f                   	pop    %edi
f0121b55:	5d                   	pop    %ebp
f0121b56:	c3                   	ret    
f0121b57:	90                   	nop
f0121b58:	0f bd c2             	bsr    %edx,%eax
f0121b5b:	83 f0 1f             	xor    $0x1f,%eax
f0121b5e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0121b62:	75 6c                	jne    f0121bd0 <__moddi3+0x108>
f0121b64:	39 fa                	cmp    %edi,%edx
f0121b66:	72 05                	jb     f0121b6d <__moddi3+0xa5>
f0121b68:	3b 0c 24             	cmp    (%esp),%ecx
f0121b6b:	77 0e                	ja     f0121b7b <__moddi3+0xb3>
f0121b6d:	8b 34 24             	mov    (%esp),%esi
f0121b70:	29 ce                	sub    %ecx,%esi
f0121b72:	19 d3                	sbb    %edx,%ebx
f0121b74:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0121b78:	89 34 24             	mov    %esi,(%esp)
f0121b7b:	8b 04 24             	mov    (%esp),%eax
f0121b7e:	8b 54 24 14          	mov    0x14(%esp),%edx
f0121b82:	eb bc                	jmp    f0121b40 <__moddi3+0x78>
f0121b84:	85 c9                	test   %ecx,%ecx
f0121b86:	75 0b                	jne    f0121b93 <__moddi3+0xcb>
f0121b88:	b8 01 00 00 00       	mov    $0x1,%eax
f0121b8d:	31 d2                	xor    %edx,%edx
f0121b8f:	f7 f1                	div    %ecx
f0121b91:	89 c1                	mov    %eax,%ecx
f0121b93:	89 d8                	mov    %ebx,%eax
f0121b95:	31 d2                	xor    %edx,%edx
f0121b97:	f7 f1                	div    %ecx
f0121b99:	8b 04 24             	mov    (%esp),%eax
f0121b9c:	f7 f1                	div    %ecx
f0121b9e:	89 d3                	mov    %edx,%ebx
f0121ba0:	eb 8f                	jmp    f0121b31 <__moddi3+0x69>
f0121ba2:	66 90                	xchg   %ax,%ax
f0121ba4:	89 c8                	mov    %ecx,%eax
f0121ba6:	89 da                	mov    %ebx,%edx
f0121ba8:	f7 d8                	neg    %eax
f0121baa:	83 d2 00             	adc    $0x0,%edx
f0121bad:	f7 da                	neg    %edx
f0121baf:	89 04 24             	mov    %eax,(%esp)
f0121bb2:	89 54 24 04          	mov    %edx,0x4(%esp)
f0121bb6:	e9 45 ff ff ff       	jmp    f0121b00 <__moddi3+0x38>
f0121bbb:	90                   	nop
f0121bbc:	f7 de                	neg    %esi
f0121bbe:	83 d7 00             	adc    $0x0,%edi
f0121bc1:	f7 df                	neg    %edi
f0121bc3:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0121bca:	ff 
f0121bcb:	e9 21 ff ff ff       	jmp    f0121af1 <__moddi3+0x29>
f0121bd0:	b8 20 00 00 00       	mov    $0x20,%eax
f0121bd5:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121bd9:	29 f8                	sub    %edi,%eax
f0121bdb:	89 c6                	mov    %eax,%esi
f0121bdd:	89 44 24 14          	mov    %eax,0x14(%esp)
f0121be1:	89 f9                	mov    %edi,%ecx
f0121be3:	d3 e2                	shl    %cl,%edx
f0121be5:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0121be9:	89 e8                	mov    %ebp,%eax
f0121beb:	89 f1                	mov    %esi,%ecx
f0121bed:	d3 e8                	shr    %cl,%eax
f0121bef:	09 d0                	or     %edx,%eax
f0121bf1:	89 04 24             	mov    %eax,(%esp)
f0121bf4:	89 ea                	mov    %ebp,%edx
f0121bf6:	89 f9                	mov    %edi,%ecx
f0121bf8:	d3 e2                	shl    %cl,%edx
f0121bfa:	89 d7                	mov    %edx,%edi
f0121bfc:	89 da                	mov    %ebx,%edx
f0121bfe:	d3 e2                	shl    %cl,%edx
f0121c00:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0121c04:	d3 e5                	shl    %cl,%ebp
f0121c06:	8b 44 24 10          	mov    0x10(%esp),%eax
f0121c0a:	89 f1                	mov    %esi,%ecx
f0121c0c:	d3 e8                	shr    %cl,%eax
f0121c0e:	09 d0                	or     %edx,%eax
f0121c10:	d3 eb                	shr    %cl,%ebx
f0121c12:	89 da                	mov    %ebx,%edx
f0121c14:	f7 34 24             	divl   (%esp)
f0121c17:	89 d3                	mov    %edx,%ebx
f0121c19:	f7 e7                	mul    %edi
f0121c1b:	89 c6                	mov    %eax,%esi
f0121c1d:	89 d1                	mov    %edx,%ecx
f0121c1f:	39 d3                	cmp    %edx,%ebx
f0121c21:	72 29                	jb     f0121c4c <__moddi3+0x184>
f0121c23:	74 33                	je     f0121c58 <__moddi3+0x190>
f0121c25:	89 e8                	mov    %ebp,%eax
f0121c27:	29 f0                	sub    %esi,%eax
f0121c29:	19 cb                	sbb    %ecx,%ebx
f0121c2b:	89 de                	mov    %ebx,%esi
f0121c2d:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0121c31:	d3 e6                	shl    %cl,%esi
f0121c33:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121c37:	89 f9                	mov    %edi,%ecx
f0121c39:	d3 e8                	shr    %cl,%eax
f0121c3b:	09 c6                	or     %eax,%esi
f0121c3d:	89 f0                	mov    %esi,%eax
f0121c3f:	89 f9                	mov    %edi,%ecx
f0121c41:	d3 eb                	shr    %cl,%ebx
f0121c43:	89 da                	mov    %ebx,%edx
f0121c45:	e9 f6 fe ff ff       	jmp    f0121b40 <__moddi3+0x78>
f0121c4a:	66 90                	xchg   %ax,%ax
f0121c4c:	29 f8                	sub    %edi,%eax
f0121c4e:	1b 14 24             	sbb    (%esp),%edx
f0121c51:	89 d1                	mov    %edx,%ecx
f0121c53:	89 c6                	mov    %eax,%esi
f0121c55:	eb ce                	jmp    f0121c25 <__moddi3+0x15d>
f0121c57:	90                   	nop
f0121c58:	39 c5                	cmp    %eax,%ebp
f0121c5a:	72 f0                	jb     f0121c4c <__moddi3+0x184>
f0121c5c:	89 d9                	mov    %ebx,%ecx
f0121c5e:	eb c5                	jmp    f0121c25 <__moddi3+0x15d>

f0121c60 <__udivdi3>:
f0121c60:	55                   	push   %ebp
f0121c61:	57                   	push   %edi
f0121c62:	56                   	push   %esi
f0121c63:	53                   	push   %ebx
f0121c64:	83 ec 1c             	sub    $0x1c,%esp
f0121c67:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0121c6b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0121c6f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121c73:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0121c77:	89 ca                	mov    %ecx,%edx
f0121c79:	89 f8                	mov    %edi,%eax
f0121c7b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0121c7f:	85 f6                	test   %esi,%esi
f0121c81:	75 2d                	jne    f0121cb0 <__udivdi3+0x50>
f0121c83:	39 cf                	cmp    %ecx,%edi
f0121c85:	77 65                	ja     f0121cec <__udivdi3+0x8c>
f0121c87:	89 fd                	mov    %edi,%ebp
f0121c89:	85 ff                	test   %edi,%edi
f0121c8b:	75 0b                	jne    f0121c98 <__udivdi3+0x38>
f0121c8d:	b8 01 00 00 00       	mov    $0x1,%eax
f0121c92:	31 d2                	xor    %edx,%edx
f0121c94:	f7 f7                	div    %edi
f0121c96:	89 c5                	mov    %eax,%ebp
f0121c98:	31 d2                	xor    %edx,%edx
f0121c9a:	89 c8                	mov    %ecx,%eax
f0121c9c:	f7 f5                	div    %ebp
f0121c9e:	89 c1                	mov    %eax,%ecx
f0121ca0:	89 d8                	mov    %ebx,%eax
f0121ca2:	f7 f5                	div    %ebp
f0121ca4:	89 cf                	mov    %ecx,%edi
f0121ca6:	89 fa                	mov    %edi,%edx
f0121ca8:	83 c4 1c             	add    $0x1c,%esp
f0121cab:	5b                   	pop    %ebx
f0121cac:	5e                   	pop    %esi
f0121cad:	5f                   	pop    %edi
f0121cae:	5d                   	pop    %ebp
f0121caf:	c3                   	ret    
f0121cb0:	39 ce                	cmp    %ecx,%esi
f0121cb2:	77 28                	ja     f0121cdc <__udivdi3+0x7c>
f0121cb4:	0f bd fe             	bsr    %esi,%edi
f0121cb7:	83 f7 1f             	xor    $0x1f,%edi
f0121cba:	75 40                	jne    f0121cfc <__udivdi3+0x9c>
f0121cbc:	39 ce                	cmp    %ecx,%esi
f0121cbe:	72 0a                	jb     f0121cca <__udivdi3+0x6a>
f0121cc0:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0121cc4:	0f 87 9e 00 00 00    	ja     f0121d68 <__udivdi3+0x108>
f0121cca:	b8 01 00 00 00       	mov    $0x1,%eax
f0121ccf:	89 fa                	mov    %edi,%edx
f0121cd1:	83 c4 1c             	add    $0x1c,%esp
f0121cd4:	5b                   	pop    %ebx
f0121cd5:	5e                   	pop    %esi
f0121cd6:	5f                   	pop    %edi
f0121cd7:	5d                   	pop    %ebp
f0121cd8:	c3                   	ret    
f0121cd9:	8d 76 00             	lea    0x0(%esi),%esi
f0121cdc:	31 ff                	xor    %edi,%edi
f0121cde:	31 c0                	xor    %eax,%eax
f0121ce0:	89 fa                	mov    %edi,%edx
f0121ce2:	83 c4 1c             	add    $0x1c,%esp
f0121ce5:	5b                   	pop    %ebx
f0121ce6:	5e                   	pop    %esi
f0121ce7:	5f                   	pop    %edi
f0121ce8:	5d                   	pop    %ebp
f0121ce9:	c3                   	ret    
f0121cea:	66 90                	xchg   %ax,%ax
f0121cec:	89 d8                	mov    %ebx,%eax
f0121cee:	f7 f7                	div    %edi
f0121cf0:	31 ff                	xor    %edi,%edi
f0121cf2:	89 fa                	mov    %edi,%edx
f0121cf4:	83 c4 1c             	add    $0x1c,%esp
f0121cf7:	5b                   	pop    %ebx
f0121cf8:	5e                   	pop    %esi
f0121cf9:	5f                   	pop    %edi
f0121cfa:	5d                   	pop    %ebp
f0121cfb:	c3                   	ret    
f0121cfc:	bd 20 00 00 00       	mov    $0x20,%ebp
f0121d01:	89 eb                	mov    %ebp,%ebx
f0121d03:	29 fb                	sub    %edi,%ebx
f0121d05:	89 f9                	mov    %edi,%ecx
f0121d07:	d3 e6                	shl    %cl,%esi
f0121d09:	89 c5                	mov    %eax,%ebp
f0121d0b:	88 d9                	mov    %bl,%cl
f0121d0d:	d3 ed                	shr    %cl,%ebp
f0121d0f:	89 e9                	mov    %ebp,%ecx
f0121d11:	09 f1                	or     %esi,%ecx
f0121d13:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0121d17:	89 f9                	mov    %edi,%ecx
f0121d19:	d3 e0                	shl    %cl,%eax
f0121d1b:	89 c5                	mov    %eax,%ebp
f0121d1d:	89 d6                	mov    %edx,%esi
f0121d1f:	88 d9                	mov    %bl,%cl
f0121d21:	d3 ee                	shr    %cl,%esi
f0121d23:	89 f9                	mov    %edi,%ecx
f0121d25:	d3 e2                	shl    %cl,%edx
f0121d27:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121d2b:	88 d9                	mov    %bl,%cl
f0121d2d:	d3 e8                	shr    %cl,%eax
f0121d2f:	09 c2                	or     %eax,%edx
f0121d31:	89 d0                	mov    %edx,%eax
f0121d33:	89 f2                	mov    %esi,%edx
f0121d35:	f7 74 24 0c          	divl   0xc(%esp)
f0121d39:	89 d6                	mov    %edx,%esi
f0121d3b:	89 c3                	mov    %eax,%ebx
f0121d3d:	f7 e5                	mul    %ebp
f0121d3f:	39 d6                	cmp    %edx,%esi
f0121d41:	72 19                	jb     f0121d5c <__udivdi3+0xfc>
f0121d43:	74 0b                	je     f0121d50 <__udivdi3+0xf0>
f0121d45:	89 d8                	mov    %ebx,%eax
f0121d47:	31 ff                	xor    %edi,%edi
f0121d49:	e9 58 ff ff ff       	jmp    f0121ca6 <__udivdi3+0x46>
f0121d4e:	66 90                	xchg   %ax,%ax
f0121d50:	8b 54 24 08          	mov    0x8(%esp),%edx
f0121d54:	89 f9                	mov    %edi,%ecx
f0121d56:	d3 e2                	shl    %cl,%edx
f0121d58:	39 c2                	cmp    %eax,%edx
f0121d5a:	73 e9                	jae    f0121d45 <__udivdi3+0xe5>
f0121d5c:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0121d5f:	31 ff                	xor    %edi,%edi
f0121d61:	e9 40 ff ff ff       	jmp    f0121ca6 <__udivdi3+0x46>
f0121d66:	66 90                	xchg   %ax,%ax
f0121d68:	31 c0                	xor    %eax,%eax
f0121d6a:	e9 37 ff ff ff       	jmp    f0121ca6 <__udivdi3+0x46>
f0121d6f:	90                   	nop

f0121d70 <__umoddi3>:
f0121d70:	55                   	push   %ebp
f0121d71:	57                   	push   %edi
f0121d72:	56                   	push   %esi
f0121d73:	53                   	push   %ebx
f0121d74:	83 ec 1c             	sub    $0x1c,%esp
f0121d77:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0121d7b:	8b 74 24 34          	mov    0x34(%esp),%esi
f0121d7f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121d83:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0121d87:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0121d8b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0121d8f:	89 f3                	mov    %esi,%ebx
f0121d91:	89 fa                	mov    %edi,%edx
f0121d93:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121d97:	89 34 24             	mov    %esi,(%esp)
f0121d9a:	85 c0                	test   %eax,%eax
f0121d9c:	75 1a                	jne    f0121db8 <__umoddi3+0x48>
f0121d9e:	39 f7                	cmp    %esi,%edi
f0121da0:	0f 86 a2 00 00 00    	jbe    f0121e48 <__umoddi3+0xd8>
f0121da6:	89 c8                	mov    %ecx,%eax
f0121da8:	89 f2                	mov    %esi,%edx
f0121daa:	f7 f7                	div    %edi
f0121dac:	89 d0                	mov    %edx,%eax
f0121dae:	31 d2                	xor    %edx,%edx
f0121db0:	83 c4 1c             	add    $0x1c,%esp
f0121db3:	5b                   	pop    %ebx
f0121db4:	5e                   	pop    %esi
f0121db5:	5f                   	pop    %edi
f0121db6:	5d                   	pop    %ebp
f0121db7:	c3                   	ret    
f0121db8:	39 f0                	cmp    %esi,%eax
f0121dba:	0f 87 ac 00 00 00    	ja     f0121e6c <__umoddi3+0xfc>
f0121dc0:	0f bd e8             	bsr    %eax,%ebp
f0121dc3:	83 f5 1f             	xor    $0x1f,%ebp
f0121dc6:	0f 84 ac 00 00 00    	je     f0121e78 <__umoddi3+0x108>
f0121dcc:	bf 20 00 00 00       	mov    $0x20,%edi
f0121dd1:	29 ef                	sub    %ebp,%edi
f0121dd3:	89 fe                	mov    %edi,%esi
f0121dd5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0121dd9:	89 e9                	mov    %ebp,%ecx
f0121ddb:	d3 e0                	shl    %cl,%eax
f0121ddd:	89 d7                	mov    %edx,%edi
f0121ddf:	89 f1                	mov    %esi,%ecx
f0121de1:	d3 ef                	shr    %cl,%edi
f0121de3:	09 c7                	or     %eax,%edi
f0121de5:	89 e9                	mov    %ebp,%ecx
f0121de7:	d3 e2                	shl    %cl,%edx
f0121de9:	89 14 24             	mov    %edx,(%esp)
f0121dec:	89 d8                	mov    %ebx,%eax
f0121dee:	d3 e0                	shl    %cl,%eax
f0121df0:	89 c2                	mov    %eax,%edx
f0121df2:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121df6:	d3 e0                	shl    %cl,%eax
f0121df8:	89 44 24 04          	mov    %eax,0x4(%esp)
f0121dfc:	8b 44 24 08          	mov    0x8(%esp),%eax
f0121e00:	89 f1                	mov    %esi,%ecx
f0121e02:	d3 e8                	shr    %cl,%eax
f0121e04:	09 d0                	or     %edx,%eax
f0121e06:	d3 eb                	shr    %cl,%ebx
f0121e08:	89 da                	mov    %ebx,%edx
f0121e0a:	f7 f7                	div    %edi
f0121e0c:	89 d3                	mov    %edx,%ebx
f0121e0e:	f7 24 24             	mull   (%esp)
f0121e11:	89 c6                	mov    %eax,%esi
f0121e13:	89 d1                	mov    %edx,%ecx
f0121e15:	39 d3                	cmp    %edx,%ebx
f0121e17:	0f 82 87 00 00 00    	jb     f0121ea4 <__umoddi3+0x134>
f0121e1d:	0f 84 91 00 00 00    	je     f0121eb4 <__umoddi3+0x144>
f0121e23:	8b 54 24 04          	mov    0x4(%esp),%edx
f0121e27:	29 f2                	sub    %esi,%edx
f0121e29:	19 cb                	sbb    %ecx,%ebx
f0121e2b:	89 d8                	mov    %ebx,%eax
f0121e2d:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0121e31:	d3 e0                	shl    %cl,%eax
f0121e33:	89 e9                	mov    %ebp,%ecx
f0121e35:	d3 ea                	shr    %cl,%edx
f0121e37:	09 d0                	or     %edx,%eax
f0121e39:	89 e9                	mov    %ebp,%ecx
f0121e3b:	d3 eb                	shr    %cl,%ebx
f0121e3d:	89 da                	mov    %ebx,%edx
f0121e3f:	83 c4 1c             	add    $0x1c,%esp
f0121e42:	5b                   	pop    %ebx
f0121e43:	5e                   	pop    %esi
f0121e44:	5f                   	pop    %edi
f0121e45:	5d                   	pop    %ebp
f0121e46:	c3                   	ret    
f0121e47:	90                   	nop
f0121e48:	89 fd                	mov    %edi,%ebp
f0121e4a:	85 ff                	test   %edi,%edi
f0121e4c:	75 0b                	jne    f0121e59 <__umoddi3+0xe9>
f0121e4e:	b8 01 00 00 00       	mov    $0x1,%eax
f0121e53:	31 d2                	xor    %edx,%edx
f0121e55:	f7 f7                	div    %edi
f0121e57:	89 c5                	mov    %eax,%ebp
f0121e59:	89 f0                	mov    %esi,%eax
f0121e5b:	31 d2                	xor    %edx,%edx
f0121e5d:	f7 f5                	div    %ebp
f0121e5f:	89 c8                	mov    %ecx,%eax
f0121e61:	f7 f5                	div    %ebp
f0121e63:	89 d0                	mov    %edx,%eax
f0121e65:	e9 44 ff ff ff       	jmp    f0121dae <__umoddi3+0x3e>
f0121e6a:	66 90                	xchg   %ax,%ax
f0121e6c:	89 c8                	mov    %ecx,%eax
f0121e6e:	89 f2                	mov    %esi,%edx
f0121e70:	83 c4 1c             	add    $0x1c,%esp
f0121e73:	5b                   	pop    %ebx
f0121e74:	5e                   	pop    %esi
f0121e75:	5f                   	pop    %edi
f0121e76:	5d                   	pop    %ebp
f0121e77:	c3                   	ret    
f0121e78:	3b 04 24             	cmp    (%esp),%eax
f0121e7b:	72 06                	jb     f0121e83 <__umoddi3+0x113>
f0121e7d:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0121e81:	77 0f                	ja     f0121e92 <__umoddi3+0x122>
f0121e83:	89 f2                	mov    %esi,%edx
f0121e85:	29 f9                	sub    %edi,%ecx
f0121e87:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0121e8b:	89 14 24             	mov    %edx,(%esp)
f0121e8e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121e92:	8b 44 24 04          	mov    0x4(%esp),%eax
f0121e96:	8b 14 24             	mov    (%esp),%edx
f0121e99:	83 c4 1c             	add    $0x1c,%esp
f0121e9c:	5b                   	pop    %ebx
f0121e9d:	5e                   	pop    %esi
f0121e9e:	5f                   	pop    %edi
f0121e9f:	5d                   	pop    %ebp
f0121ea0:	c3                   	ret    
f0121ea1:	8d 76 00             	lea    0x0(%esi),%esi
f0121ea4:	2b 04 24             	sub    (%esp),%eax
f0121ea7:	19 fa                	sbb    %edi,%edx
f0121ea9:	89 d1                	mov    %edx,%ecx
f0121eab:	89 c6                	mov    %eax,%esi
f0121ead:	e9 71 ff ff ff       	jmp    f0121e23 <__umoddi3+0xb3>
f0121eb2:	66 90                	xchg   %ax,%ax
f0121eb4:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0121eb8:	72 ea                	jb     f0121ea4 <__umoddi3+0x134>
f0121eba:	89 d9                	mov    %ebx,%ecx
f0121ebc:	e9 62 ff ff ff       	jmp    f0121e23 <__umoddi3+0xb3>
